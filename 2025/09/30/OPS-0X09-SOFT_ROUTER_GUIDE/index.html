

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/avatar.png">
  <link rel="icon" href="/img/avatar.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="arttnba3">
  <meta name="keywords" content="">
  
    <meta name="description" content="阿达西，你的 homelab 里面，我的软路由雄鹰一样地在呢">
<meta property="og:type" content="article">
<meta property="og:title" content="【OPS.0x09】家用软路由手搓日志">
<meta property="og:url" content="http://example.com/2025/09/30/OPS-0X09-SOFT_ROUTER_GUIDE/index.html">
<meta property="og:site_name" content="arttnba3&#39;s blog">
<meta property="og:description" content="阿达西，你的 homelab 里面，我的软路由雄鹰一样地在呢">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2025/11/06/ThdeZAOKDm7pc58.png">
<meta property="article:published_time" content="2025-09-29T18:17:33.000Z">
<meta property="article:modified_time" content="2026-01-07T18:40:23.778Z">
<meta property="article:author" content="arttnba3">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="运维">
<meta property="article:tag" content="软路由">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://s2.loli.net/2025/11/06/ThdeZAOKDm7pc58.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>【OPS.0x09】家用软路由手搓日志 - arttnba3&#39;s blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":"§"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.1.1"><link rel="alternate" href="/atom.xml" title="arttnba3's blog" type="application/atom+xml">
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 80vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>arttnba3&#39;s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" target="_blank" rel="noopener" href="https://github.com/arttnba3">
                <i class="iconfont icon-github-fill"></i>
                GitHub
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/atom.xml">
                <i class="iconfont icon-rss"></i>
                rss
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://s2.loli.net/2025/10/06/nwVqMa4xP7Hfjcv.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="【OPS.0x09】家用软路由手搓日志"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-09-30 04:17" pubdate>
          2025年9月30日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          27k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          225 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
        <div class="scroll-down-bar">
          <i class="iconfont icon-arrowdown"></i>
        </div>
      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">【OPS.0x09】家用软路由手搓日志</h1>
            
              <p class="note note-info">
                
                  
                    本文最后更新于：2026年1月8日 凌晨
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <p>阿达西，你的 homelab 里面，我的软路由雄鹰一样地在呢</p>
<span id="more"></span>

<h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00. 一切开始之前"></a>0x00. 一切开始之前</h1><blockquote>
<p>又是经典的废话环节，愿意听笔者碎碎念一长段没有什么意义的内容的读者可以简单看看：）</p>
<p>以及以下内容仅代表笔者不成熟的主观意见，不包含任何对目前的软路由及 homelab 圈子的评判或审视，且很多观测结论来自于 <strong>中国大陆外的软路由圈子</strong> （例如 Reddit 的 <a target="_blank" rel="noopener" href="http://reddit.com/r/homelab">&#x2F;r&#x2F;homelab</a> 社区， <del>说真的笔者真不太了解国内各种圈子是啥样子</del> ），对于部分概念如果你有不认同的可以优先以自己认为对的为准：）</p>
</blockquote>
<p>众所周知 <strong>Soft Router（软路由）</strong> 一直都是 HomeLab 领域中非常火爆的一个可玩物（笔者语文功底下降太多了不知道该用什么词形容总而言之大概是这个意思），因此笔者自然也想在自己家里整一个软路由玩一玩，刚好最近几天有机会回趟国内，于是笔者打算在家里弄个软路由，改造一下自家 homelab 的网络基础设施建设</p>
<p>但是在开始之前，笔者注意到很奇怪的一个点——在仔细调研过后 <em>笔者感觉社区里绝大部分人玩的其实并不是 “路由” 本身，而是将软路由作为非计算机科班出身背景的一个接触 Linux 以及运维的敲门砖，绝大部分人真正玩的其实还是 Linux 而不是软路由</em> （当然这里笔者的意思并不是说看轻所谓非科班出身的人之类的，而是很多相关背景出身的人其实反而不会在下班之后自己在家折腾本专业的东西，毕竟一天天的上班工作已经够累的了下班回来还要再对着同一套东西折腾的话能不 PTSD 的属于是真的很热爱的神人了，例如笔者同一届读网安的同学每天从实验室回宿舍搓 PCB 板子不亦乐乎，但是另一个专门上班做硬件开发的同学已经到了看到这套东西就下意识想跑路的程度了），因此 <em>你可能会看到很多人在折腾和【路由器】这一概念本身无关的东西</em> ，例如非常经典的在 J1900 大卡车上跑万物这样的 all in one 之类的玩法：</p>
<p><img src="https://s2.loli.net/2025/11/06/ThdeZAOKDm7pc58.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://s2.loli.net/2025/11/06/GMUvV6fk9r2PiCo.png" srcset="/img/loading.gif" lazyload></p>
<p>——当然，不得不指出的一点是就工程实践而言在资源没有紧缺到吃不起饭的情况下 all in one 并不是一个比较好的实践（ <del>毕竟作为计算机专业背景的咱们还是要有点基本的计科素养</del> ），稍微一个配置错误就很容易从 all in one 变成 all in boom 全都炸了（悲），因此我们至少需要通过类似 Docker 这样的技术为不同类型的服务做好隔离——当然，比较好的工程实践还是每个独立任务专门对应一台独立的计算机，例如家里如果同时要搞 NAS 和软路由，那就整两台独立的计算机，而不是在一台计算机上又跑软路由又跑 NAS 的——就笔者个人而言，虽然说有 Proxmox VE 或者 Docker 一类的基于虚拟化技术的软件的存在使得我们能够将一台物理计算机虚拟化成多个虚拟计算机进行硬件资源的复用，但 all in one 本身就是风险极大的事情，很容易牵一发而动全身，因此笔者还是选择仅在这一台将要被配置成软路由的计算机上 <em>仅配置与路由相关的功能</em> </p>
<p>那么又来了一个核心的问题： <strong>软路由究竟能够又需要做什么？</strong> 首先需要确定的一点就是一台路由器的核心功能肯定是 <strong>路由</strong> （routing） 和 <strong>转发</strong> （forwarding）—— 也就是数据包在三层网络中的路径选择与发送，因此我们的软路由首先需要实现一台传统路由器应当具备的路由功能</p>
<p><img src="https://s2.loli.net/2025/11/06/2wLcAluprCmZ7zJ.png" srcset="/img/loading.gif" lazyload></p>
<p>在传统路由器的功能点上，软路由和硬路由间的异同如何？简而言之就是 <strong>硬路由的路由性能通常都能完全秒杀软路由</strong> ，因为有一点比较核心的区别是，硬路由通常有能够辅助数据包处理的额外的芯片，例如高性能路由器通常都会配备支持绝大部分路由功能（甚至完整支持，例如 Cisco 的 <a target="_blank" rel="noopener" href="https://www.cisco.com/c/zh_cn/products/routers/8000-series-routers/index.html">8000 系列路由器</a> 便可在单个 ASIC 上支持完整路由功能）的 <strong>专用集成电路</strong> （Application-Specific Integrated Circuit，ASIC）来 <strong>直接使用特殊的电路进行数据包的路由与转发</strong> ，从而极大程度地提升了路由器的吞吐量——而软路由则只能使用为通用计算设计的 CPU 进行数据包的转发，每个数据包的处理都需要经过 CPU 进行调度、内存拷贝、协议栈解析等，效率上比专门为路由设计的 ASIC 之流还是要低不少，因此在绝对性能的上限而言有着专门电路的硬路由通常都会能够达到比软路由更高的性能上限</p>
<blockquote>
<p>尤其是很多人讲到的一个非常核心的一个区别便是 <strong>小包转发的性能</strong> （例如 64~128B 这样的包），数据包从网卡接收-&gt;拷贝到内核网络协议栈 <code>sk_buff</code> -&gt;逐层解包处理协议头-&gt;查表-&gt;发送到网卡的这些步骤，都需要 CPU 介入，也都需要进行内存访问、上下文切换等，对于小包转发而言，每秒处理的数据包数量都非常大的情况下，我们很多的计算资源都会开销在这一些各种内存拷贝和指令执行的步骤上，而哪怕只是普通的家用路由器，都有 ASIC 芯片（例如 Broadcom 的 <code>BCM47xx</code> 芯片）进行硬件层面的加速，数据包的收发、查表、转发都可以由 ASIC 完成，CPU 只需要在各种路由协议的处理时介入，因此小包转发的性能哪怕是家用路由器都是能够秒杀高性能软路由的——当然大包转发性能也是有着 ASIC 的硬路由站优势，但是大数据包意味着每秒数据包数量少，因此 CPU 处理的压力也相对较低</p>
</blockquote>
<p>那么软路由的优势在哪呢？在笔者看来，主要的核心点还是在于 <strong>软路由作为一个足够便宜的设备，在可折腾性与价格间取得了不错的平衡</strong> ， 几百块买一台性能尚可的小主机来折腾不仅对于家用网络而言性能够用，钱包也不会太过于吃紧，还能带来极大的可玩性，因此在 homelab 小圈子当中软路由便逐渐成为了一个非常热门的选项</p>
<p>——当然，对于笔者而言， <strong>笔者更看重的是软路由作为 “路由器” 本身，能够相比起硬路由带来什么不一样的东西</strong> </p>
<blockquote>
<p>毕竟也玩 Linux 这么多年了，普通 Linux 常见的各种功能对笔者而言并没有太多新奇的值得探索的东西，例如 homelab 圈一直有个很火的概念叫 <code>玩 Docker</code> ，甚至于部分 NAS 居然将支持 Docker 作为其卖点，最初这个说法在笔者看来就有点神奇和意想不到： <em>难道不是应该是</em> <strong>玩具体的各种应用软件吗？</strong> <em>Docker 本身不应该只是一个装载与运行应用的载体吗？为什么要叫玩 Docker？</em> ——后面笔者还是仔细想了想，对于绝大部分初学者而言确实是在 “玩 Docker” ——毕竟 Docker 对于很多人而言确实也还算是一个比较新奇的能够装很多各种有意思的应用的一个入口，同时绝大部分软路由的用户其实也并不是计科专业出身，大部分人更多只是这一块的爱好者，因此 <em>使用行业内的专业标准去审视这样一个民间小圈子的用户是完全没有道理的</em> </p>
</blockquote>
<p>因此本篇博客会更多关注于 <strong>与路由器本身相关的玩法</strong> （例如 网络功能虚拟化、自定义防火墙、流量控制、软件定义网络等），而不会涉及那些虽然很火但实际上和路由器这一概念本身基本完全无关的东西（例如什么远程下载、跑定时任务、 PCDN 之类的， <em>这和 “路由器” 这个概念本身有半毛钱的关系吗？</em> 随便一个能够远程访问的普通的服务器都能干的活，没有必要专门放到软路由里去讲，也 <em>没有必要和软路由这个概念产生关联</em> ）</p>
<h2 id="网络架构设计"><a href="#网络架构设计" class="headerlink" title="网络架构设计"></a>网络架构设计</h2><p>一言蔽之，笔者认为 <strong>在适合笔者的家庭网络架构当中，一个标准的高可用的软路由所处的层级应当不高于二级路由</strong> ，也就是说软路由上面至少需要再有一个标准的硬路由作为一级路由（以及一个光猫），即下图所示的级联路由架构：</p>
<p><img src="https://s2.loli.net/2025/12/15/FiK35gyb1fLAZ6v.png" srcset="/img/loading.gif" lazyload></p>
<p>选择这样的网络架构的原因在于可以比较好地保障网络的可用性和健壮性（ <del>保持一个好的鲁棒性有助于你更好地保证你鲁棒的鲁棒性</del> ），在这种架构当中，软路由本身的引入并不会影响到常规的家用网络（软路由炸了只会影响到你自己， <del>不会让你被你爸妈痛骂一顿</del> ），此外当软路由出现一些故障时也可以通过与软路由同级的设备连接到软路由进行修复</p>
<blockquote>
<h3 id="关于旁路由的迷思（-炮打旁路由，我的一张大字报-）"><a href="#关于旁路由的迷思（-炮打旁路由，我的一张大字报-）" class="headerlink" title="关于旁路由的迷思（ 炮打旁路由，我的一张大字报 ）"></a>关于旁路由的迷思（ <del>炮打旁路由，我的一张大字报</del> ）</h3><p>众所周知在 homelab 小圈子里有一种神人架构叫做 <strong>旁路由</strong> ，简而言之一般长这个样子：</p>
<p><img src="https://s2.loli.net/2025/12/15/uWdlLMS93zDEope.png" srcset="/img/loading.gif" lazyload></p>
<p>笔者个人觉得稍微有点网络基础常识的应该都会觉得这个网络架构的设计是比较惊为天人的，而且  “旁路由” 一词 <strong>笔者并未在任何正规的网络工程教材中找到与之相关的任何定义文本</strong> ，在 r&#x2F;homelab 一类的英文社区也基本看不到这类型的网络架构设计（因此笔者哪怕是主观上想给这个词标一个相对正经的英文翻译，也不太想得明白该怎么标， <del>因为这就不是一个正经玩意</del> ），但是 <strong>这不代表这个东西最初的出现是完全没有意义的</strong> —— 但是与此同时 <strong>有意义也不代表这个东西是对的</strong> ，永远记住我们看待问题不能够极端化，善用辩证法进行思考</p>
<p>要弄清楚为什么这个神秘架构为什么会在某个特定的小圈子里流行起来，我们首先自然要先弄明白“旁路由”究竟是什么，能够做什么——首先我们需要明确的一点是，“旁路由”和你在网工教材上学到的任何一种正规网络架构都不相符，<strong>旁路由并不是单臂路由（router-on-a-stick），而且两者基本没啥关联</strong></p>
<p>让我们先从这个东西诞生的场景出发，简而言之，“旁路由”最初所设想&#x2F;面对的场景是 <strong>在主路由不能动的情况下，怎么在家用网络中玩点骚操作</strong> ——众所周知对于不处在同一网络中的数据包，计算机会选择将其发送给默认网关（Gateway，一般这个 IP 是你当前直接连接的路由器），由网关将数据包发到别的网络（因此，如果一个数据包不会出网，那么对应的网卡自然就不需要设置默认网关），因此就有点子王想到：既然要出网的数据包会被发送给网关， <strong>那我在网络中部署一台服务器，再手动把要搞操作的设备的默认网关设置成这台服务器不就好了</strong> ——于是 <strong>“旁路由” 的概念便应运而生</strong> </p>
<p>到这里有人可能就会发出疑问了：我直接把用作旁路由的这个设备作为二级路由再将要搞事的设备接到这个路由器下边不就好了——诚然，相比起我们所称之为「正统」的级联路由网络架构而言，旁路由的架构未免总归让人觉得怪怪的，但不得不说这样的架构很好地满足了部分人的需求： <strong>在不改变主路由的情况下，不需要做过多折腾，同时还能实现设备间的互通</strong> ，因此相比起正统网工思维，旁路由便是很好地满足了部分人想要折腾但是又不想付出太多精力折腾但是又要有折腾感和实用性的这样的需求的一种解决方案</p>
<blockquote>
<p>例如如果是级联路由架构，要做设备互通的话你需要一些额外的更加正规化的配置，可以参考笔者图上所示网络结构，或者参考华为的 <a target="_blank" rel="noopener" href="https://support.huawei.com/enterprise/zh/doc/EDOC1100034251/14e80e16">配置IPv4静态路由示例</a> 等文章做初步了解（看不起华为在网络这一方面造诣的人，👴只能说考个 HCIA 认证就老实了），笔者会在博客的后面详细讲述到这一块怎么配置——当然因为笔者家里就没几台设备，直接配个静态路由是比较省事的，你也可以自己玩玩动态路由，比如说 OSPF， <strong>不过需要明确的一点是这些都是正统网工的做法，并不适合小白</strong> ，因此复杂度相比起简单的架设旁路由而言要复杂的多 ——不过笔者相信阅读笔者博客的各位读者应当都是有着正统计算机科学素养的人，又或者至少是有着这方面志向的人：）</p>
</blockquote>
<p>但我们不得不明确的一点是， <strong>“旁路由” 最多只是在特殊场景下有一定作用的【能用】的架构</strong> （套用 ChatGPT 说的话便是 <strong>旁路由不是错误， 它只是一个“不该长期存在，却不得不存在”的结构。</strong> ），他存在很多 <strong>在专业场景中无法接受</strong> 的问题（这里笔者就不过多展开了，感兴趣可以自己问问 GPT）——当然，我们不得不说的是，任何事物的存在都具有其合理性， “旁路由”诞生于一个混沌的时代，作为一个 workaround 而流行了起来无可厚非，但是至少我们应当知道 <strong>什么是正规的、优雅的网络架构设计</strong> ，虽然在“旁路由”在圈子里大行其道的今天，作为个体我们没必要（至少笔者是没这个精力）跳出来和别人唱反调，但至少在我们自己家里的网络架构设计当中，我们还是要保持点 <strong>专业性</strong> ——尤其是作为学习过正统科班课程的人而言，实际上回过头来一看你会发现上面讲的很多东西你在本科的《计算机网络》当中都有学过，甚至在《组网与运维》课程实验上都实操过——既然这样我们又有什么理由选择使用民间自行发明的“旁路由”架构呢 ：）</p>
</blockquote>
<h2 id="硬件选择"><a href="#硬件选择" class="headerlink" title="硬件选择"></a>硬件选择</h2><blockquote>
<p>注： <strong>本节内容不包含任何商业推广！</strong></p>
</blockquote>
<p>从硬件而言一台合格的软路由至少需要满足以下配置：</p>
<ul>
<li>两个网口，一个负责连接上游网络，一个负责连接交换机以连接下游设备</li>
<li>一枚待机功耗较低的 CPU（例如 Intel Twinlake 系列）</li>
</ul>
<p>刚好手上还有一些闲置的内存条和 SSD，因此笔者在京东上随便买了一台有着两个网口的准系统小主机，Intel N150 CPU 是 Intel 最新的低功耗 CPU，在耗电低的同时有着还可以的性能，这也是笔者选择这个 CPU 的主要原因：）</p>
<p><img src="https://s2.loli.net/2025/12/15/Z8NWga7UkVvthiT.jpg" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>从最后的结果来看，整机功耗 10W，一个月只用不到 10 度电，这个电费开销还是没有太超出笔者的钱包负载能力上限的</p>
<p><img src="https://s2.loli.net/2025/12/15/cDQt8EfWd2CwZ7P.jpg" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<h2 id="操作系统选择"><a href="#操作系统选择" class="headerlink" title="操作系统选择"></a>操作系统选择</h2><p>接下来是操作系统的选择，这里笔者的选择是使用笔者最喜欢的 <code>Gentoo Linux</code> ，那么为什么不选择其他的操作系统呢？我们先来看看常见的那些被用来安装到软路由上的操作系统都有哪些：）</p>
<p>首先最经典的也是大家最容易想到的应该是 <a target="_blank" rel="noopener" href="https://openwrt.org/start">OpenWrt</a> 系统，这是一个专门为路由器打造的嵌入式 Linux 发行版，简而言之就是在路由器领域的专业性还算拉得比较满， <strong>甚至于部分商业路由器所使用的固件也是基于 OpenWrt 打造的</strong> ，这也是软路由圈子里应该是流行度属于绝对的第一梯队的一个系统，甚至于部分论坛 <del>例如 Chiphell 或者恩山之类的</del> 都会有很多用户分享自己自制的 OpenWrt 固件</p>
<p><img src="https://s2.loli.net/2025/12/15/iMW5DGqfRxhslve.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>首先不得不说 OpenWrt 是一个非常成熟也非常好的系统，但是就是不太满足笔者个人需求</strong> ，如果要对硬路由进行改造，自制 OpenWrt 固件再刷进去或许是个不错的方案，这也是硬路由刷机的常见玩法，但笔者用作软路由的是一台常规的通用计算机，在这种 <em>可以且性能足够正常安装其他普通 Linux 发行版的情况下，OpenWrt 就没啥优势了</em> ，因为 OpenWrt 本质上是为嵌入式场景设计的，为了能够在性能极端缺失的场景下运行而阉割了很多东西（例如 libc 使用的是 uclibc 而非 glibc），这就导致对于很多常用 Linux 功能的支持并不完善（例如老 OpenWrt 的玩家应该都知道这玩意曾经对 Docker 的支持基本上可以说是比一坨还要一坨），而如果要将其更改为一个对各种通用功能都支持比较完善的 Linux 系统则会需要耗费很多精力，而且也没有必要——这种情况下我为什么不直接安装一个普通且常规的通用 Linux 发行版呢</p>
<p>然后是中国大陆比较流行的 <a target="_blank" rel="noopener" href="https://www.ikuai8.com/component/download">iKuaiOS</a> （为什么要单独提一嘴是因为笔者确实 <strong>几乎没有</strong> 怎么在国外的 homelab 相关社区看到这个系统，可能是海外宣传比较少），简而言之这个系统是 <strong>使用了 Linux kernel 的闭源操作系统</strong>  ，首先“闭源”这个东西就不太符合笔者的口味，其次他的可折腾空间并不多（虽然说原生支持的功能很多，用知乎上的话来说就是 <strong>“一套精装修的房子”</strong> ，个人觉得其开箱即用的特性还是非常适合小白玩玩的）， <strong>对于笔者而言属于完全的 OpenWrt 的下位替代</strong> ，因此自然也没有必要使用 iKuaiOS——虽然笔者觉得这个系统在易用性这一块确实做得还是不错的，简化了很多的操作，还有图形化的管理界面，很适合小白上手畅玩</p>
<p><img src="https://s2.loli.net/2025/12/16/CRLAEXrFfOVbxqK.png" srcset="/img/loading.gif" lazyload></p>
<p>接下来是 BSD 系的 pfSense 和 OPNsense，这两个系统都是基于 <code>FreeBSD</code> 进行开发的， <strong>在海外的 homelab 相关社区当中还算是有着非常不错的流行度</strong> ，其中 OPNsense 是 pfSense 的一个分支，说实话笔者不太熟悉 FreeBSD（ <del>主要还是对整个 BSD 系都没有太多了解</del> ），相较而言笔者熟悉的各种东西还是主要在 Linux 下工作的，而且由于 <strong>马太效应</strong> 的缘故 BSD 系相较于 Linux 而言似乎是在逐渐衰落的，整个开源社区生态的注意力其实是在逐渐地收缩至 Linux only 的（例如 WhatsApp 的团队在 2020 年由原先的纯 BSD 转向 Linux，FreeNAS 在升级成 TrueNAS 后也从原先的 BSD-based 变为了 Linux-based），这也导致很多软件都没有对 BSD 的支持（别说 BSD 支持了，现在一些专业软件想要有 Linux 版本都够呛，Windows 还是太权威了），因此出于 <strong>可折腾性</strong> 的角度，笔者还是优先选择使用 Linux（毕竟家用软路由的搭建某种程度上其核心价值主要就在于通过可折腾性给你提供情绪价值），不过后面如果有机会应该会尝试一下这些小众宝藏系统：）</p>
<p><img src="https://s2.loli.net/2025/12/15/c51HSlyC9fjdwFt.png" srcset="/img/loading.gif" lazyload alt="能出来几个人说说话吗？为什么帖子光有人看，没人回复？也看不见人发帖。什么意思啊？再这样下去热情都磨光了。没人再愿意为大家服务了"></p>
<p>以及 Proxmox VE 或者 Vmware ESXi 这样的专门用来搞系统虚拟化的操作系统，首先 <strong>不得不说在海内外这都是较为流行的基本解决方案，但对于笔者而言则又有点没太多必要</strong> ，因为笔者并不需要也并不喜欢在这样一台性能一般的机器上跑太多东西，而且某种程度上这也比较违反 Unix 的 <code>“只做一件事，将其做至极致”</code> 的哲学（笔者甚至在国内圈子见到过不少先安一个 PVE 然后再安一个 OpenWRT VM 做主路由然后再安一个 iKuaiOS VM 做旁路由的神人架构， <strong>why？</strong> ），再加上 PVE 本身也只是一个基于 Debian 的 Linux 发行版罢了，背后使用的虚拟化软件还是 KVM 和 QEMU，对笔者而言不如自己安一个普通的 Linux 发行版去用这些东西，而 VMware ESXi 虽然是一个全新的 Type-I Hypervisor，但是这又回到一个核心的关键问题就是 <strong>此类 hypervisor 本身只是用来将一台物理机虚拟化成多台虚拟机的工具，真正实现路由功能的还是要落到具体的虚拟机里操作系统当中，是否选择安装 PVE 或者 ESXi 其实并没有解决笔者的核心问题</strong> ，而笔者又没有在这台仅用作软路由的机子上跑多个不同操作系统的需求，只需要跑一个系统作为软路由就行了，没有必要引入系统虚拟化的架构，因此此类 VMM 系统也被排除出笔者的选择范围</p>
<p><img src="https://s2.loli.net/2025/12/16/Um2QBZGiewpcqCF.png" srcset="/img/loading.gif" lazyload></p>
<p>Windows 或者 macOS 之流就更加没必要讨论了，选择用这类系统作为软路由属实是有点神人的选择，虽然说从纯折腾的角度而言似乎<strong>确实可行</strong> ，笔者也看到一些帖子在折腾这个，但是 <strong>更多还是偏向纯折腾，而非一个常规化的选择</strong> ——当然如果上 Windows Server 的话或许还是可以打造一个切实可行也还算实用的解决方案，但是对于笔者而言还是太过于超前了， 也不太符合笔者自身的 taste，因此就暂且不考虑</p>
<p>——因此最后综合考虑下来，笔者觉得 <strong>最适合笔者的选择便是安装一个常规的 Linux 发行版</strong> ，可折腾性拉满的同时不失稳定性</p>
<p>既然我们最后的选择还是通用 Linux 发行版，那么接下来便是到具体的 Linux 发行版的选择，这一步基本上就是多种多样众口难调的了， <strong>而且实际上绝大部分发行版没有太多本质区别，主要的核心区别就是包管理器设计和软件仓库更新速度不太一样</strong> ，因此主要就是看你的个人口味了——至于为什么笔者更喜欢 Gentoo Linux 而不是其他的发行版，之前在 <a target="_blank" rel="noopener" href="https://arttnba3.cn/2024/04/30/DISTRO-0X02-SURFACE_INSTALL_GENTOO_WINDOWS/">【DISTRO.0x02】在 Surface Pro 8 上安装 Gentoo</a> 这篇博客当中笔者已经有过一次讨论，简而言之便是 Gentoo Linux 的包管理器的的设计理念在笔者看来十分惊艳，不仅是 <code>“你所使用的每一个软件包都是你自己编译的”</code> 这件事极大程度地满足了笔者的情绪价值，<code>USE flag</code> 这样能够按照自己需求自行调整软件包的方式更是让笔者觉得 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1yE411i7Q7?t=24">屌爆了</a> ， <strong>可以说 portage 满足了笔者对于 package manager 的所有 <del>性</del> 幻想</strong> ，更多的笔者就不在这里详细展开了（懒得打字了主要是），感兴趣的读者可以自行回去看上面那篇博客里笔者写的与 Gentoo Linux 相关的内容：）</p>
<p><img src="https://steamuserimages-a.akamaihd.net/ugc/43107956178667128/BC3271F0AA6DFA2EF54A2D119994087298A53BC6/?imw=5000&imh=5000&ima=fit&impolicy=Letterbox&imcolor=%23000000&letterbox=false" srcset="/img/loading.gif" lazyload></p>
<h1 id="0x01-Gentoo-Linux-基本系统搭建（可选）"><a href="#0x01-Gentoo-Linux-基本系统搭建（可选）" class="headerlink" title="0x01. Gentoo Linux 基本系统搭建（可选）"></a>0x01. Gentoo Linux 基本系统搭建（可选）</h1><p>我们首先要进行 Gentoo Linux 的搭建，这一节你也可以参照 <a target="_blank" rel="noopener" href="https://wiki.gentoo.org/wiki/Handbook:AMD64">Gentoo 官方的 Handbook</a> ，如果你想跟着笔者的博客自己也搭一个软路由玩一玩，但是又不太想用 Gentoo Linux （例如你可能更喜欢社区更流行的 OpenWRT 或者 iKuaiOS 之类的），你也可以直接跳过并安装自己喜欢的其他发行版或是其他操作系统：）</p>
<blockquote>
<p>如果你的 ISA 不是 amd64，注意自行修改一些细节：）</p>
</blockquote>
<h2 id="创建安装镜像并启动"><a href="#创建安装镜像并启动" class="headerlink" title="创建安装镜像并启动"></a>创建安装镜像并启动</h2><p>这一节基本没有什么要讲的，从 <a target="_blank" rel="noopener" href="https://www.gentoo.org/downloads/">Gentoo 官网</a> 下载一个 amd64 的 LiveUSB 镜像然后用 <a target="_blank" rel="noopener" href="https://etcher.balena.io/">balenaEtcher</a> 一类的工具刷到 U 盘里面就行</p>
<blockquote>
<p>不过所有的这类安装镜像其实都是一个对应发行版的 Linux 系统，而笔者之前弄过一个安装在 U 盘上的 Gentoo Linux，因此笔者直接从自己制作的 U 盘上启动，而不是使用官方的镜像，因为其实核心就是各种磁盘和软件管理工具，例如 GParted 和 portage 这些，只要有能够运行这类工具的环境就行</p>
</blockquote>
<p>之后从这个 U 盘启动就行，通常需要进 BIOS&#x2F;UEFI 中进行配置，不过如果主机本身没有安装操作系统通常会默认从可以启动的安装介质进行启动，而无需手动配置</p>
<h2 id="通过-SSH-连接安装环境"><a href="#通过-SSH-连接安装环境" class="headerlink" title="通过 SSH 连接安装环境"></a>通过 SSH 连接安装环境</h2><p>如果感觉直接在主机上操作不太方便，可以在启动之后启动 sshd，再用自己的惯用 PC 进行连接：</p>
<blockquote>
<p>可以先使用 <code>ip addr</code> 命令查看主机内网 IP，然后确保在同一内网下进行连接即可</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo rc-service sshd start</span><br></code></pre></td></tr></table></figure>

<p>之后将自己的 ssh 公钥放到 <code>/home/gentoo/.ssh/authorized_keys</code> 之后就可以用下面的命令连接安装环境了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ssh -o StrictHostKeyChecking=no gentoo@主机内网IP</span><br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2025/09/26/VY7uAUFQBK42PhM.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<blockquote>
<p>可以先用 netcat 来传递公钥，例如在目标主机端首先使用 <code>nc -l 4444</code> 开启监听，之后在自己的 PC 上用 <code>nc 主机IP 4444</code> 进行连接，然后在一侧输入的字符在另一侧就能直接看到</p>
</blockquote>
<h2 id="进行磁盘分区并挂载"><a href="#进行磁盘分区并挂载" class="headerlink" title="进行磁盘分区并挂载"></a>进行磁盘分区并挂载</h2><p>我们主要需要三个分区：</p>
<ul>
<li>EFI 分区：FAT32 格式，放 EFI 启动程序，一般选 GRUB，有特殊癖好的可以选 <a target="_blank" rel="noopener" href="https://www.freedesktop.org/software/systemd/man/latest/systemd-boot.html">systemd-boot</a></li>
<li>系统分区：一般用 EXT4 格式，存放 Gentoo Linux 系统，也可以按个人喜好用 BTRFS 之类的</li>
<li>SWAP 分区：SWAP 格式的交换分区，存放一些长时间不用的数据</li>
</ul>
<blockquote>
<p>也有一些人习惯把 <code>/home</code> 单独开一个分区，不过笔者个人习惯是开一个独立的分区专门放数据，而不是放 <code>/home</code> </p>
</blockquote>
<p>首先使用 KDE Partition Manager 进行分区，毕竟都 5202 年了能用图形界面就没必要用命令行折磨自己：）</p>
<p>然后用 GNU parted 给 EFI 分区标对应的属性，可能是笔者不熟悉 KDE Partition Manager 的缘故总而言之找不到这么细粒度变更分区属性的办法：</p>
<p><img src="https://s2.loli.net/2025/09/25/m2gcIQiCxFokNW3.jpg" srcset="/img/loading.gif" lazyload></p>
<p>然后先挂载系统分区到 <code>/mnt/gentoo</code> 目录下，后面我们要 chroot 到这个目录里面进行系统的安装：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo mount /dev/nvme0n1p2 /mnt/gentoo</span><br></code></pre></td></tr></table></figure>

<h2 id="安装-Stage-3"><a href="#安装-Stage-3" class="headerlink" title="安装 Stage 3"></a>安装 Stage 3</h2><p>简而言之 stage 3 可以理解成一个最基本的 Gentoo Linux 系统，<code>Stage</code> 可以简单理解为构建 Gentoo Linux 系统的各个不同阶段：</p>
<ul>
<li><code>Stage 1</code> ：通常仅 Gentoo 内部开发人员使用，由一个基本的 <code>packages,build</code> 文件生成的系统包</li>
<li><code>Stage 2</code> ：通常仅 Gentoo 内部开发人员使用，从 Stage 1 编译而来的可以自举的工具链</li>
<li><code>Stage 3</code> ：由 Stage 2 编译而来的文件，并包含一组  <a target="_blank" rel="noopener" href="https://wiki.gentoo.org/wiki/System_set_(Portage)">@system set</a> 软件包</li>
<li><code>Stage 4</code> ：在 Stage 3 基础上安装好的完整的 Gentoo 系统</li>
</ul>
<p>首先我们将 <a target="_blank" rel="noopener" href="https://www.gentoo.org/downloads/">Stage 3</a> 下载到文件系统根目录下解压，笔者比较习惯 systemd 所以还是选择 systemd + desktop 版的：</p>
<blockquote>
<p>如果你的安装机器所处的网络环境比较复杂，有可能会出现 <code>Unable to establish SSL connection.</code> 或者 <code>Connection reset by peer</code> 的错误，通常这不是你或 Gentoo 官方的错误（出错了但我们做对了.jpg），可以考虑多次重试下载或使用代理，或者在自己电脑上下载好后再开个 python3 -m http.server 8888 之类的传过去</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> /mnt/gentoo</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo wget https://distfiles.gentoo.org/releases/amd64/autobuilds/20250921T170345Z/stage3-amd64-desktop-systemd-20250921T170345Z.tar.xz</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo tar xpvf stage3-*.tar.xz --xattrs-include=<span class="hljs-string">&#x27;*.*&#x27;</span> --numeric-owner</span><br></code></pre></td></tr></table></figure>

<h2 id="配置-portage-选项"><a href="#配置-portage-选项" class="headerlink" title="配置 portage 选项"></a>配置 portage 选项</h2><p>主要是编辑我们的文件系统挂载点 <code>/mnt/gentoo</code> 下的 <code>/etc/portage/make.conf</code> 文件以配置 Gentoo 的包管理器的各种编译选项，下面是笔者给出的一份自用的示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># These settings were set by the catalyst build script that automatically</span><br><span class="hljs-comment"># built this stage.</span><br><span class="hljs-comment"># Please consult /usr/share/portage/config/make.conf.example for a more</span><br><span class="hljs-comment"># detailed example.</span><br>COMMON_FLAGS=<span class="hljs-string">&quot;-O2 -pipe -march=native&quot;</span><br>CFLAGS=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;COMMON_FLAGS&#125;</span>&quot;</span><br>CXXFLAGS=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;COMMON_FLAGS&#125;</span>&quot;</span><br>FCFLAGS=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;COMMON_FLAGS&#125;</span>&quot;</span><br>FFLAGS=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;COMMON_FLAGS&#125;</span>&quot;</span><br><br><span class="hljs-comment"># <span class="hljs-doctag">NOTE:</span> This stage was built with the bindist USE flag enabled</span><br><br><span class="hljs-comment"># This sets the language of build output to English.</span><br><span class="hljs-comment"># Please keep this setting intact when reporting bugs.</span><br>LC_MESSAGES=C.utf8<br><br><span class="hljs-comment"># Compilation</span><br>MAKEOPTS=<span class="hljs-string">&quot;-j4 -l5&quot;</span><br>PORTAGE_NICENESS=19<br><br><span class="hljs-comment"># LLVM Configuration</span><br>LLVM_SLOT=<span class="hljs-string">&quot;20&quot;</span><br><br><span class="hljs-comment"># Graphics</span><br>VIDEO_CARDS=<span class="hljs-string">&quot;intel&quot;</span><br><br><span class="hljs-comment"># USE flags</span><br>USE=<span class="hljs-string">&quot;X wayland xwayland qt5 qt6 pipewire systemd alsa&quot;</span><br><br><span class="hljs-comment"># What to accepted</span><br>ACCEPT_KEYWORDS=<span class="hljs-string">&quot;amd64&quot;</span><br>ACCEPT_LICENSE=<span class="hljs-string">&quot;*&quot;</span><br><br><span class="hljs-comment"># boot loader</span><br>GRUB_PLATFORMS=<span class="hljs-string">&quot;efi-64&quot;</span><br><br><span class="hljs-comment"># input</span><br>INPUT_DEVICES=<span class="hljs-string">&quot;libinput&quot;</span><br><br></code></pre></td></tr></table></figure>

<p>一些关键选项简要说明如下：</p>
<ul>
<li><code>COMMON_FLAGS=&quot;-O2 -pipe -march=twinlake -mtune=twinlake&quot;</code> ：传递给编译器的标志位， <code>-O2</code>  意为开启 O2 优化， <code>-pipe</code>  意为使用管道缓存编译中间文件， <code>-march=native</code>  意为自动识别本机架构进行优化（笔者的目标安装机器的 CPU 为 Intel N150，Twin Lake 架构，但是 <code>-march</code> 不支持 <code>twinlake</code> 选项，因为这不算一个正经的处理器家族（本质 12 代 Alder Lake 的 Refresh），所以直接用 <code>native</code> ；需要注意的是 <code>-march</code> 包含了 <code>-mtune</code> 所包含的选项，因此无需额外制定 <code>-mtune</code> ）</li>
<li><code>MAKEOPTS=&quot;-j4 -l5&quot;</code> ：传递给 makefile 的标志位，这里 <code>-j4</code> 意为允许同时 4 线程编译， <code>-l5</code> 意为系统负载限制为 5，这个数量基于 Gentoo Handbook 指导（ <code>job value == nproc, load-average value slightly above nproc</code> ）</li>
<li><code>VIDEO_CARDS=&quot;intel virgl&quot;</code> ：开启 emerge 对对应图形卡的支持，笔者 CPU 是 Intel N150 ，只有 Intel 核显所以选上 <code>intel</code> </li>
<li><code>USE</code> ：全局 <a target="_blank" rel="noopener" href="https://wiki.gentoo.org/wiki/USE_flag">USE flag</a></li>
<li><code>ACCEPT_KEYWORDS</code> 、<code>ACCEPT_LICENSE</code> ：接受的软件包关键字与协议</li>
</ul>
<blockquote>
<p>需要注意的是，如果你在网络环境比较恶劣的地方，包管理器访问 Gentoo 官方仓库的速度可能会慢的令人发指，因此选择使用镜像会是一个值得考虑的选项，我们可以通过 <code>GENTOO_MIRRORS</code> 变量指定需要使用的镜像站地址，下面是一个使用中科大镜像的例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">GENTOO_MIRRORS=<span class="hljs-string">&quot;https://mirrors.ustc.edu.cn/gentoo/&quot;</span><br></code></pre></td></tr></table></figure>

<p>你也可以在 make.conf 中添加代理，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">http_proxy=<span class="hljs-string">&quot;http://代理服务器地址:代理服务端口&quot;</span><br>https_proxy=<span class="hljs-string">&quot;http://代理服务器地址:代理服务端口&quot;</span><br>ftp_proxy=<span class="hljs-string">&quot;http://代理服务器地址:代理服务端口&quot;</span><br></code></pre></td></tr></table></figure>


</blockquote>
<h2 id="安装基本系统"><a href="#安装基本系统" class="headerlink" title="安装基本系统"></a>安装基本系统</h2><p>接下来我们切换到 root 用户进行操作：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo su root</span><br></code></pre></td></tr></table></figure>

<p>首先复制当前环境的 DNS 信息，因为我们后面要 chroot 进去：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">root # cp --dereference /etc/resolv.conf /mnt/gentoo/etc/<br></code></pre></td></tr></table></figure>

<p>接下来挂载必备的一些文件系统：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">root # mount --types proc /proc /mnt/gentoo/proc<br>root # mount --rbind /sys /mnt/gentoo/sys<br>root # mount --make-rslave /mnt/gentoo/sys<br>root # mount --rbind /dev /mnt/gentoo/dev<br>root # mount --make-rslave /mnt/gentoo/dev<br>root # mount --bind /run /mnt/gentoo/run<br>root # mount --make-slave /mnt/gentoo/run<br></code></pre></td></tr></table></figure>

<p>然后 chroot 切换到 <code>/mnt/gentoo</code> 目录：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">root # chroot /mnt/gentoo /bin/bash<br>root # source /etc/profile &amp;&amp; export PS1=&quot;(chroot) $&#123;PS1&#125;&quot;<br></code></pre></td></tr></table></figure>

<p>然后挂载 EFI 目录：</p>
<blockquote>
<p>有一种说法是建议使用 <code>/efi</code> 而非 <code>/boot/efi</code> ，不过笔者还没有太具体了解过：）</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">(chroot) root # mkdir /boot/efi<br>(chroot) root # mount /dev/nvme0n1p1 /boot/efi<br></code></pre></td></tr></table></figure>

<p>然后安装 Gentoo ebuild 仓库快照：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(chroot) root # emerge-webrsync<br></code></pre></td></tr></table></figure>

<p>接下来选择 <a target="_blank" rel="noopener" href="https://wiki.gentoo.org/wiki/Profile_(Portage)">portage profile</a> ，简单来说其决定了整个系统为软件包所使用的默认 USE flag，首先可以使用如下命令查看可选配置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(chroot) root # eselect profile list<br></code></pre></td></tr></table></figure>

<p>笔者计划使用 LxQt 桌面 + systemd 的组合，所以这里选择桌面配置默认的 <code>default/linux/amd64/23.0/desktop/systemd</code> ，如果你要选择 Gnome 或 KDE Plasma 可以选择对应的特化的 profile ：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(chroot) root # eselect profile set 4<br></code></pre></td></tr></table></figure>

<blockquote>
<h4 id="可选：添加-binhost（-诶哟我，bin哥（指-binary）牛b！-）"><a href="#可选：添加-binhost（-诶哟我，bin哥（指-binary）牛b！-）" class="headerlink" title="可选：添加 binhost（ 诶哟我，bin哥（指 binary）牛b！ ）"></a>可选：添加 binhost（ <del>诶哟我，bin哥（指 binary）牛b！</del> ）</h4><p>众所周知 Gentoo 安装软件包默认需要在本机从源码进行编译，但是有的时候也没这个必要，如果你的软路由刚好又是性能比较弱的那一档，在后面编译软件包的时候也会很痛苦，因此可以像其他发行版一样使用官方编译好的二进制软件包（<del>不过这样的话用 Gentoo 的意义在哪呢</del>）</p>
<p>首先需要添加 binhost 配置，新建 <code>/etc/portage/binrepos.conf/gentoobinhost.conf</code> 文件并写入如下内容：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[binhost]</span><br><span class="hljs-attr">priority</span> = <span class="hljs-number">9999</span><br><span class="hljs-attr">sync-uri</span> = https://distfiles.gentoo.org/releases/amd64/binpackages/<span class="hljs-number">23.0</span>/x86-<span class="hljs-number">64</span>/<br></code></pre></td></tr></table></figure>

<p>最后一级目录可选的除了 <code>x86-64</code> 以外还有一些其他的，想要安全性可以选 <code>x86-64_hardened</code>：</p>
<p><img src="https://s2.loli.net/2025/09/27/P823evZMJElBgd7.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>实际安装二进制软件包有两种方式，一是在 emerge 安装软件包时附上 <code>--getbinpkg</code> 选项，二是在 <code>/etc/portage/make.conf</code> 中为 <code>FEATURES</code> 项添加 <code>getbinpkg</code> 或 <code>binpkg-request-signature</code> ，后者要求二进制包被签名，以下是一个示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Appending getbinpkg to the list of values within the FEATURES variable</span><br>FEATURES=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;FEATURES&#125;</span> getbinpkg&quot;</span><br></code></pre></td></tr></table></figure>


</blockquote>
<p>然后设置时区，笔者这台机器准备放国内，所以时区设定为亚洲上海：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(chroot) root # ln -sf ../usr/share/zoneinfo/Asia/Shanghai /etc/localtime<br></code></pre></td></tr></table></figure>

<p>然后是进行本地化配置，在 <code>/etc/locale.gen</code> 中添加对应项即可，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">en_US ISO-8859-1<br>en_US.UTF-8 UTF-8<br>zh_CN GBK <br>zh_CN.UTF-8 UTF-8<br></code></pre></td></tr></table></figure>

<p>接下来运行 <code>locale-gen</code> 命令，其会根据 <code>/etc/locale.gen</code> 中项进行生成，生成结束后通过 <code>eselect</code> 命令进行选择，一般推荐选择 <code>C.utf8</code> ，完成之后更新环境变量：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">(chroot) root # locale-gen<br>(chroot) root # eselect locale list<br>(chroot) root # eselect locale set 2<br>(chroot) root # env-update &amp;&amp; source /etc/profile &amp;&amp; export PS1=&quot;(chroot) $&#123;PS1&#125;&quot;<br></code></pre></td></tr></table></figure>

<h2 id="配置内核"><a href="#配置内核" class="headerlink" title="配置内核"></a>配置内核</h2><blockquote>
<p>（可选配置：安装固件与微码）</p>
<p>在开始配置内核前我们可以安装可选的微码与固件，笔者的 CPU 是 Intel N150，所以微码应当安装 <code>sys-firmware/intel-microcode</code> 包，固件则都为通用的 <code>sys-kernel/linux-firmware</code> 包：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">(chroot) root # emerge --ask sys-kernel/linux-firmware<br>(chroot) root # emerge --ask sys-firmware/intel-microcode<br></code></pre></td></tr></table></figure>

<p>以及可以选择安装 Sound Open Firmware，一个开源音频驱动：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(chroot) root # emerge --ask sys-firmware/sof-firmware<br></code></pre></td></tr></table></figure>


</blockquote>
<p>虽然 Gentoo 官方提供了多种安装方式，但是手动编译内核并安装是原汁原味 Linux 体验的一部分，所以这里我们选择手动从源码安装 Gentoo 的 Linux kernel</p>
<p>首先安装 boot loader，笔者个人还是比较喜欢 GNU GRUB：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">(chroot) root # emerge --ask --verbose sys-boot/grub<br>(chroot) root # grub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=Gentoo<br></code></pre></td></tr></table></figure>

<p>然后从 Gentoo 官方仓库安装带有 Gentoo Patches 的内核源码 （ <del>不会真有人以为👴要直接去 kernel.org 下最原生态的源码吧</del> ），默认安装的版本是 longterm 版本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(chroot) root # emerge --ask --verbose sys-kernel/gentoo-sources<br></code></pre></td></tr></table></figure>

<blockquote>
<p>如果你需要更新的驱动支持，可以选择安装最新版本的 stable 内核，只需要为该软件包启用 <code>~amd64</code> 关键字，这意味着额外接受 testing 中的软件包，在 <code>/etc/portage/package.accept_keywords/</code> 目录下新建一个文件 （例如 <code>/etc/portage/package.accept_keywords/kernel</code>）写入如下内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sys-kernel/gentoo-sources ~amd64<br></code></pre></td></tr></table></figure>

<p>相应地，启用了 <code>~amd64</code> 的软件包的更新频率也会快很多，但是对于绝大部分常用软件包都能保持 cutting edge</p>
<blockquote>
<p>当然，笔者也遇到过有的软件包没人维护的情况，此时就算启用了 <code>~amd64</code> 也没法跟上官方的最新版本，因为根本还没维护者将其添加到 Gentoo 官方仓库里：（</p>
</blockquote>
</blockquote>
<p>我们可以使用 <code>eselect kernel list</code> 查看系统中已经安装的内核源码，通常会被安装到 <code>/usr/src</code> 目录下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">(chroot) root # eselect kernel list<br>Available kernel symlink targets:<br>  [1]   linux-6.12.41-gentoo<br></code></pre></td></tr></table></figure>

<p>使用 <code>eselect kernel set</code> 命令将 <code>/usr/src/linux</code> 设为指定内核的符号链接：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(chroot) root # eselect kernel set 1<br></code></pre></td></tr></table></figure>

<p>下面开始正式的内核编译过程，首先来到  <code>/usr/src/linux</code> 目录下创建编译配置文件 <code>.config</code> ，这里我们直接以 livegui 的 config 作为模板，然后用 <code>menuconfig</code> 进图形化界面配置一些自己想要的配置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">(chroot) root # cd /usr/src/linux<br>(chroot) root # zcat /proc/config.gz &gt; .config<br>(chroot) root # make menuconfig<br></code></pre></td></tr></table></figure>

<blockquote>
<p>在这一步你可以尝试在 defconfig 生成之后使用 <code>make localmodconfig</code> 进行内核裁剪，从而减小内核体积，但是很容易把一些必要的东西也裁剪掉，例如笔者遇到过 FAT32 字符集缺失的问题（在重启后挂载 EFI 分区时提示 <code>IO charset iso8859-1 not found</code> 导致系统进 emergency mode，解决方案是开启 <code>CONFIG_NLS_ISO8859_1=m</code>），因此在裁剪完之后最好还是要 <strong>手动检查一下必要的各种内核编译选项是否都开启了</strong> ， <em>或者干脆就不裁剪也可以</em> </p>
<p>以及笔者还遇到过一个情况就是 defconfig 中有很多配置都不包含，例如在安装 docker 时会有下面的警告信息，因此不如直接以 liveguid 的内核配置作为模板 （听说 defconfig 似乎近段时间也被大肆批判了一番）：</p>
<p><img src="https://s2.loli.net/2025/10/05/Ja12PneE5gtOpUA.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<p>此外，以下配置是我们 <strong>必须</strong> 要编译进内核的（摘自 <a target="_blank" rel="noopener" href="https://wiki.gentoo.org/wiki/Home_router">Gentoo wiki</a> ，根据当前内核版本略有修改），因为我们的软路由需要这些配置以正常工作：</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs elm">-*- <span class="hljs-type">Networking</span> sup<span class="hljs-keyword">port</span>  <span class="hljs-comment">---&gt;</span><br>   <span class="hljs-type">Networking</span> options  <span class="hljs-comment">---&gt;</span><br>      [*] <span class="hljs-type">TCP</span>/<span class="hljs-type">IP</span> networking<br>         [*] <span class="hljs-type">IP</span>: advanced router<br>      [*] <span class="hljs-type">Network</span> packet filtering framework (<span class="hljs-type">Netfilter</span>)  <span class="hljs-comment">---&gt;</span><br>         [*]   <span class="hljs-type">Advanced</span> netfilter configuration<br>            <span class="hljs-type">IP</span>: <span class="hljs-type">Netfilter</span> <span class="hljs-type">Configuration</span>  <span class="hljs-comment">---&gt;</span><br>               &lt;<span class="hljs-type">M</span>&gt; <span class="hljs-type">IP</span> tables sup<span class="hljs-keyword">port</span> (required for filtering/masq/NAT)<br>            <span class="hljs-type">IPv6</span>: <span class="hljs-type">Netfilter</span> <span class="hljs-type">Configuration</span>  <span class="hljs-comment">---&gt; </span><br>               &lt;<span class="hljs-type">M</span>&gt; <span class="hljs-type">IP6</span> tables sup<span class="hljs-keyword">port</span> (required for filtering)<br></code></pre></td></tr></table></figure>

<p>接下来开始编译，<code>bzImage</code> 为内核本体，<code>modules</code> 为内核模块：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(chroot) root # make -j$(nproc) -l$(nproc) bzImage modules<br></code></pre></td></tr></table></figure>

<blockquote>
<p>如果你和笔者一样为软路由选择了低功耗低性能的 CPU，那么这个编译过程会非常非常非常非常长……以笔者的 <code>Intel N150</code> CPU 为例，4 核 4 线程睿频 3.6 GHz，在已经进行了内核裁剪的情况下，总编译时间来到了  <code>44min</code>（作为对比，笔者之前在 <code>Intel Ultra9 285H</code> 上开启了 <code>Compile also drivers which will not load</code> ，且尽可能开启了比较多的编译选项以支持尽可能多的机器的情况下，编译内核与模块的时间为 <code>31m12.943s</code> ，因为当时目的是制作一个类似 livecd 的能够在绝大多数机器上启动的 Gentoo Linux 环境放到 U 盘里）</p>
<blockquote>
<p>如果实在等不了可以试试 <a target="_blank" rel="noopener" href="https://arttnba3.cn/2025/07/21/OPS-0X07-DISTCC_ACCEL_COMPILE/">使用 distcc 利用起闲置计算资源加速编译过程</a> ：）</p>
</blockquote>
</blockquote>
<p>然后将内核模块安装到 <code>/lib/modules</code> 下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(chroot) root # make modules_install<br></code></pre></td></tr></table></figure>

<p>接下来安装  <a target="_blank" rel="noopener" href="https://packages.gentoo.org/packages/sys-kernel/installkernel">sys-kernel&#x2F;installkernel</a> ，这个软件包会自动帮忙进行内核安装过程中一些琐碎的事情（笔者猜测应该是给内核的 <code>make install</code> 添加了 hook），包括生成 initranfs 和更新 boot loader 配置，首先创建文件 <code>/etc/portage/package.use/installkernel</code> 并写入如下 USE flag：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sys-kernel/installkernel grub dracut<br></code></pre></td></tr></table></figure>

<p>然后安装：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(chroot) root # emerge --ask --verbose sys-kernel/installkernel<br></code></pre></td></tr></table></figure>

<p>最后生成 initramfs 等文件并安装到 <code>/boot</code> 目录：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(chroot) root # make install<br></code></pre></td></tr></table></figure>

<h2 id="配置系统"><a href="#配置系统" class="headerlink" title="配置系统"></a>配置系统</h2><p>首先配置 fstab，使用 <code>blkid</code> 命令查看不同分区的 UUID 后写到 <code>/etc/fstab</code> 当中，下面是一个 fstab 的例子：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># &lt;fs&gt;                  &lt;mountpoint&gt;    &lt;type&gt;          &lt;opts&gt;          &lt;dump&gt; &lt;pass&gt;</span><br><span class="hljs-attribute">UUID</span>=<span class="hljs-number">77886</span>e74-<span class="hljs-number">1</span>c64-<span class="hljs-number">4</span>c47-<span class="hljs-number">9</span>d5a-<span class="hljs-number">3981</span>a327cfb0       none            swap    sw              <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-attribute">UUID</span>=<span class="hljs-number">139</span>b2a0b-aaa3-<span class="hljs-number">4625</span>-<span class="hljs-number">8439</span>-<span class="hljs-number">5</span>ae51ef1ed0c       /               ext4    defaults        <span class="hljs-number">0</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">UUID</span>=<span class="hljs-number">89</span>D2-BED7                                  /boot/efi       vfat    utf8            <span class="hljs-number">0</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<p>接下来配置主机名称，随便想一个就行 ：</p>
<blockquote>
<p>在这个例子中，字符串 <code>c2VydmVyMDAw</code> 是 <code>server000</code> 的 base62 加密</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(chroot) root # echo &quot;a3homelab-c2VydmVyMDAw&quot; &gt; /etc/hostname<br></code></pre></td></tr></table></figure>

<p>安装 DHCP：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">(chroot) root # emerge --ask net-misc/dhcpcd<br>(chroot) root # systemctl enable dhcpcd<br></code></pre></td></tr></table></figure>

<p>设置 root 密码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(chroot) root # passwd<br></code></pre></td></tr></table></figure>

<p>初始化 systemd 的启动配置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">(chroot) root # systemd-machine-id-setup<br>(chroot) root # systemd-firstboot --prompt<br>(chroot) root # systemctl preset-all --preset-mode=enable-only<br></code></pre></td></tr></table></figure>

<p>配置 bash 自动补全：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(chroot) root # emerge --ask app-shells/bash-completion<br></code></pre></td></tr></table></figure>

<p>配置时间同步：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">(chroot) root # emerge --ask net-misc/chrony<br>(chroot) root # systemctl enable chronyd.service<br></code></pre></td></tr></table></figure>

<p>配置文件系统和磁盘相关的一些工具，在这台机子上笔者理论上只会用到 ext4 和 fat32 ：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">(chroot) root # emerge --ask sys-fs/e2fsprogs sys-fs/dosfstools<br>(chroot) root # emerge --ask sys-block/io-scheduler-udev-rules<br></code></pre></td></tr></table></figure>

<p>安装网络相关的一些软件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(chroot) root # emerge --ask net-dialup/ppp net-wireless/iw net-wireless/wpa_supplicant<br></code></pre></td></tr></table></figure>

<p>安装 sudo ，并用 <code>visudo</code> 删除 <code>%wheel ALL=(ALL:ALL) ALL</code> 所在行开头的注释符号 <code>#</code> 以允许 wheel 用户组使用 sudo： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">(chroot) root # emerge --ask app-admin/sudo<br>(chroot) root # visudo<br></code></pre></td></tr></table></figure>

<p>添加一个日常用的管理员账户，这里别忘了把 <code>arttnba3</code> 改成你自己的 id：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">(chroot) root # groupadd arttnba3<br>(chroot) root # useradd -g arttnba3 -m -G users,wheel,audio,cdrom,floppy,portage,usb,video -s /bin/bash arttnba3<br>(chroot) root # passwd arttnba3<br></code></pre></td></tr></table></figure>

<p>安装 ssh 以供后续连接：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">(chroot) root # emerge -av net-misc/openssh<br>(chroot) root # systemctl enable sshd<br></code></pre></td></tr></table></figure>

<p>最后重启计算机：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">(chroot) root # exit<br>root # umount -l /mnt/gentoo/dev&#123;/shm,/pts,&#125;<br>root # umount -R /mnt/gentoo<br>root # reboot<br></code></pre></td></tr></table></figure>

<h1 id="0x02-配置软路由基本功能"><a href="#0x02-配置软路由基本功能" class="headerlink" title="0x02. 配置软路由基本功能"></a>0x02. 配置软路由基本功能</h1><p>前面安装操作系统的过程基本是千篇一律的，但接下来我们要将其配置成软路由，也就是安装与配置各种软件使得这一台小主机有着路由器的功能，这是我们将软路由相比起通用计算机所多出来的部分，因此我们首先需要明确 <strong>现代路由器</strong> 都有着哪些功能（ <del>《计算机网络》复习课来了</del> </p>
<p>我们先复习一下计算机网络，首先回顾一下 OSI 七层模型，其中负责设备间如何进行连通的为 物理层、数据链路层、网络层，而自传输层开始往上的几层定义的是端到端消息通信的具体方法和格式，属于与具体物理设备无关的 <em>进程间通信</em> 的范畴，因此我们主要关注于下面三层：</p>
<p><img src="https://s2.loli.net/2025/10/06/nwVqMa4xP7Hfjcv.png" srcset="/img/loading.gif" lazyload alt="偷的图"></p>
<p>这几层的工作 <strong>极简总结</strong> 便是：</p>
<ul>
<li>物理层定义接口与传输介质的物理属性，以及数据传输的物理过程，例如定义了 RJ45 网口的形式、线路的组成、数据速率等</li>
<li>数据链路层负责 <strong>帧</strong> （frame）从一个节点到另一节点的传输，一张网卡的一个网口通常有着一个自己的 MAC 地址，在传输的帧头部封装着收发方的 MAC 地址，网络设备通过网线连接到具有多个网口的 <strong>交换机</strong> （switch）上，交换机在这一层负责根据 MAC 地址将帧从一个网口转发至另一个网口，其通过接收帧学习网口对应的 MAC 地址（并定期清理），对无法确定目标 MAC 地址对应网口的则在其余端口进行广播，交换机间也可以通过网线进行连接以组建更加复杂的网络（单个端口可以对应多个源 MAC 地址）</li>
<li>网络层负责逻辑上更细致地划分与管理网络，网络层（通常使用 IP 协议）中每个设备都有一个地址（以 IPv4为例是32位地址），子网掩码用来指示网络地址中的哪些位用以划分不同的网络（两个地址若与同一子网掩码做与运算相等则说明处在同一网络下），在同一子网中设备（主机或路由器）通过在局域网中广播 ARP 请求询问目标 IP 地址对应的 MAC 地址，若处在不同子网则目标 MAC 地址设为默认网关（通常是一个路由器）， <strong>路由器</strong> （router）在这一层负责根据 IP 地址将数据包转发到目标主机或另一路由器，并修改数据包头部数据链路层的目的 MAC 地址为下一跳的设备的 MAC 地址，路由器中存放至少一张路由表用以记录 <strong>数据包应当发往哪个端口</strong> （表项内容包括 <code>目的网络、子网掩码、下一跳 IP、物理出口</code> 等，形成过程可以是静态配置、自动生成、通过 OSPF 等协议学习等）</li>
</ul>
<p>在传统路由架构中一个端口对应一个子网，因此同一子网主机需要先连接到交换机，交换机再连接到路由器，因此传统网络架构一般都长这个样子：</p>
<p><img src="https://s2.loli.net/2025/10/06/CkJ5Qoh2Nr4nUSw.png" srcset="/img/loading.gif" lazyload alt="偷的图"></p>
<p>而现代路由器（比如说你去商场买的小米路由器）和 三层交换机 <strong>通常都同时集成了二层交换机与三层路由的功能</strong>  （这两类设备在单一子网结构中 <em>功能基本等效</em> ，如果我们只考虑网络的连接），因此我们见到的大部分家庭网络结构一般都长这种简化掉交换机的样子：</p>
<p><img src="https://s2.loli.net/2025/10/06/muL642ebSVOEwB7.png" srcset="/img/loading.gif" lazyload alt="偷的图"></p>
<p>——回到正题，我们要将一台 Linux 主机配置成一台现代路由器，他需要支持这样的功能：</p>
<ul>
<li>有电时自动启动 -&gt; 配置 <strong>上电自启动</strong></li>
<li>能够进行拨号上网（可选） -&gt; 配置 <strong>ADSL 与 PPPoE</strong></li>
<li>为连接在网口上的设备分配 IP 与 DNS 服务器 -&gt; 配置 <strong>DHCP 服务</strong></li>
<li>允许连接在网口上的设备上网 -&gt; 配置 <strong>IP 转发与 NAT</strong></li>
</ul>
<p>明确了这些核心功能点，下面我们可以开始正式进行配置了</p>
<h2 id="配置上电自启动"><a href="#配置上电自启动" class="headerlink" title="配置上电自启动"></a>配置上电自启动</h2><p>关于是否能够进行上电自启动的配置，其实关键点主要在于我们用作软路由的计算机的主板是否支持相关功能， <strong>主板不支持一切都是白搭</strong> （说实话很多笔记本还真不支持这个，例如 ASUS 笔记本的 BIOS 就阉割了很多功能），具体怎么看主板是否支持主要就是看 BIOS&#x2F;UEFI 配置界面当中是否有对于电源状态相关的设置，以 Dell Wyse 3040 的 BIOS 为例，在 <code>Power Management</code> 一节下边的 <code>AC Recovery</code> 选项规定了上电后的计算机行为，选择 <code>Power On</code> 就意味着上电自启动</p>
<p><img src="https://s2.loli.net/2025/12/15/gELCOmkH1R4bNvS.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>如果你的 BIOS 中没有类似这样的配置选项，说明主板不支持上电自启动 ：(</p>
</blockquote>
<h2 id="配置-WAN-口与-LAN-口"><a href="#配置-WAN-口与-LAN-口" class="headerlink" title="配置 WAN 口与 LAN 口"></a>配置 WAN 口与 LAN 口</h2><blockquote>
<p>需要注意的是，这一节的配置针对使用 systemd 的系统，如果你使用 OpenRC 或其他 init，请自行查阅资料 <del>问 ChatGPT</del> 进行配置</p>
</blockquote>
<p>简而言之我们的软路由至少需要两个网口，并将其配置为如下：</p>
<ul>
<li>WAN 口：用于连接外网，通常需要连接到调制解调器或更上级的网络</li>
<li>LAN 口：用于内网服务，用于连接交换机或直连设备</li>
</ul>
<p>对于 WAN 口，我们通常直接配置为 DHCP 即可（在连接调制解调器的情况下），因此创建文件 <code>/etc/systemd/network/10-wan.network</code> 写入如下内容（注意修改为自己的网卡名）：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Match]</span><br><span class="hljs-attr">Name</span>=enp1s0<br><br><span class="hljs-section">[Network]</span><br><span class="hljs-attr">DHCP</span>=<span class="hljs-literal">yes</span><br></code></pre></td></tr></table></figure>

<p>对于 LAN 口，我们则需要自行定义一个静态 IP，因此创建 <code>/etc/systemd/network/20-lan.network</code> 文件写入如下内容（注意修改为自己的网卡名）：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Match]</span><br><span class="hljs-attr">Name</span>=enp2s0<br><br><span class="hljs-section">[Network]</span><br><span class="hljs-attr">Address</span>=<span class="hljs-number">10.0</span>.<span class="hljs-number">0.1</span>/<span class="hljs-number">24</span>          <br></code></pre></td></tr></table></figure>

<p>然后重启网络服务即可 （注意网口必须要连接设备才能是 UP 状态）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl restart systemd-networkd</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是这里我们使用的是轻量级的 systemd-networkd 而非 NetworkManager（也不推荐，因为这个东西太笨重了），如果你的系统启用了 NetworkManager，你需要禁用它：）</p>
<blockquote>
<p>当然，如果从轻量级的角度考虑，你其实不应该使用 systemd，而应该使用 OpenRC，不过至少笔者个人是比较喜欢 systemd，而且笔者用作软路由的设备似乎也不是很缺这个性能：）</p>
</blockquote>
</blockquote>
<h2 id="配置-ADSL-与-PPPoE（可选）"><a href="#配置-ADSL-与-PPPoE（可选）" class="headerlink" title="配置 ADSL 与 PPPoE（可选）"></a>配置 ADSL 与 PPPoE（可选）</h2><blockquote>
<p>如果你的家庭网络架构中已经有一台独立的调制解调器（例如光猫），笔者推荐通过单独的调制解调器进行上网，进行功能分离以保持 KISS 原则， <del>毕竟 All In One 很多时候就意味着 All In BOOOOOOM…</del></p>
</blockquote>
<p>🕊🕊🕊</p>
<h2 id="配置-DHCP-服务"><a href="#配置-DHCP-服务" class="headerlink" title="配置 DHCP 服务"></a>配置 DHCP 服务</h2><p><strong>动态主机配置协议</strong> （Dynamic Host Configuration Protocol， <strong>DHCP</strong> ）用以自动配置主机网络，包括自动分配 IP 和 DNS 以及其他网络参数等，是目前最常用的网络配置协议</p>
<p>这里我们选择安装 <a target="_blank" rel="noopener" href="https://thekelleys.org.uk/dnsmasq/doc.html">dnsmasq</a> 来在软路由侧提供 DHCP 服务，首先安装软件包：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo emerge -av net-dns/dnsmasq</span><br></code></pre></td></tr></table></figure>

<p>接下来编辑 dnsmasq 配置文件 <code>/etc/dnsmasq.conf</code> ，写入如下内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">interface=enp2s0 # 在该接口监听 DHCP 和 DNS 请求，改成你的网口对应的网卡名称，可以用 ip addr 命令查看<br>bind-interfaces # 绑定到端口<br>dhcp-range=10.0.0.2,10.0.0.254,255.255.255.0,12h # IP范围、子网掩码、IP 租约时间，IP 范围仅示例<br>dhcp-option=option:router,10.0.0.1 # 默认网关，设为软路由 IP，这里仅示例<br>dhcp-option=option:dns-server,10.0.0.1 # DNS 服务器，设为软路由 IP，这里仅示例<br></code></pre></td></tr></table></figure>

<p>以及为了避免启动失败，我们需要让 dnsmasq 在网络准备好之后再启动，运行如下命令编辑：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl edit dnsmasq.service</span><br></code></pre></td></tr></table></figure>

<p>写入如下内容：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Unit]</span><br><span class="hljs-attr">After</span>=network-<span class="hljs-literal">on</span>line.target<br><span class="hljs-attr">Wants</span>=network-<span class="hljs-literal">on</span>line.target<br></code></pre></td></tr></table></figure>

<p>然后直接启用服务就行，以 systemd 为例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl daemon-reload</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl <span class="hljs-built_in">enable</span> --now dnsmasq</span><br></code></pre></td></tr></table></figure>

<h2 id="配置-IP-转发与-NAT"><a href="#配置-IP-转发与-NAT" class="headerlink" title="配置 IP 转发与 NAT"></a>配置 IP 转发与 NAT</h2><p>首先我们需要启用内核的 IPv4 转发功能，创建 <code>/etc/sysctl.d/99-ipforward.conf</code> 文件写入如下配置（如果目录不存在则创建）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">net.ipv4.ip_forward=1<br></code></pre></td></tr></table></figure>

<p>然后重新载入配置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo sysctl -p</span><br></code></pre></td></tr></table></figure>

<p>接下来配置 NAT ，我们要将来自 LAN 口的数据包都转发到 WAN 口，虽然大家可能会比较熟悉更加经典的 iptables，但是在高版本内核当中 legacy iptables 被移除，因此我们首先要将 iptables 后端切换为 nftables，首先安装 nftables：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo emerge -av net-firewall/nftables</span><br></code></pre></td></tr></table></figure>

<p>创建文件 <code>/etc/portage/package.use/iptables</code> 写入如下内容，为 iptables 添加 nftables 的 USE flag：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">net-firewall/iptables nftables<br></code></pre></td></tr></table></figure>

<p>重新编译安装 iptables 引入 nftables 后端：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo emerge -av net-firewall/iptables</span><br></code></pre></td></tr></table></figure>

<p>切换到 nftables 后端：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">eselect iptables list</span> <br>Available iptables symlink targets:<br>  [1]   xtables-legacy-multi *<br>  [2]   xtables-nft-multi<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo eselect iptables <span class="hljs-built_in">set</span> 2</span><br></code></pre></td></tr></table></figure>

<p>接下来编写 iptables 规则：</p>
<ul>
<li><code>-t nat</code> 选择 NAT 表， <code>-A POSTROUTING</code> 添加规则到 POSTROUTING 链，<code>-o enp1s0</code> 匹配目标为从 enp1s0 网卡流出的包，<code>-j MASQUERADE</code> 进行源地址伪装（修改源 IP 为 enp1s0 的 IP）</li>
<li>选择默认 filter 表，<code>-A FORWARD</code> 添加规则到 FORWARD 链，<code>-i enp2s0 -o enp1s0</code> 从 enp2s0 流入到 enp1s0 流出的包，<code>-j ACCEPT</code> 允许通行</li>
<li>选择默认 filter 表，<code>-A FORWARD</code> 添加规则到 FORWARD 链，<code>-i enp1s0 -o enp2s0</code> 从 enp1s0 流入到 enp2s0 流出的包，<code>-m state</code> 仅允许特定状态的包，<code>--state ESTABLISHED,RELATED</code> 该包为已建立连接或相关连接，<code>-j ACCEPT</code> 允许通行</li>
</ul>
<p>即允许数据包从 LAN 口通过 WAN 口发出，发出的包伪装成 WAN 口 IP （NAT），仅允许属于已经建立的连接的数据包从 WAN 口流回 LAN 口：</p>
<blockquote>
<p>回顾一下 iptables：</p>
<p><img src="https://s2.loli.net/2025/10/08/rGapZ6QYofdSbV9.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo iptables -t nat -A POSTROUTING -o enp1s0 -j MASQUERADE</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo iptables -A FORWARD -i enp2s0 -o enp1s0 -j ACCEPT</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo iptables -A FORWARD -i enp1s0 -o enp2s0 -m state --state ESTABLISHED,RELATED -j ACCEPT</span><br></code></pre></td></tr></table></figure>

<p><strong>现在我们的软路由就已经实现普通路由器的能让内网设备上网的功能了</strong> ，插入一台设备进行测试，可以发现能够成功分配 IP 且能正常上网👍</p>
<p>然后是持久化配置：</p>
<blockquote>
<p>需要注意的是 <strong>不能有其他 iptables 规则干扰</strong> （例如 docker），如果存在的话则会导致规则恢复时出现问题（因为保存了额外的规则）</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl start iptables-store.service</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl <span class="hljs-built_in">enable</span> iptables-restore.service</span><br></code></pre></td></tr></table></figure>

<h1 id="0x03-配置软路由更多玩法"><a href="#0x03-配置软路由更多玩法" class="headerlink" title="0x03. 配置软路由更多玩法"></a>0x03. 配置软路由更多玩法</h1><p>虽然说现在我们已经成功完成了软路由基本功能的配置，但 <em>就目前的状态而言和直接买一个成品路由器相比可以认为是没有太大区别的，那我们配软路由的意义在哪里呢？</em> 相比起普通的成品硬路由，软路由的核心优势在于我们是一个功能完整的用户完全可控的通用操作系统，因此我们需要开拓一些更多的常规成品路由器做不到的玩法：）</p>
<h2 id="自建安全可靠的-DNS-服务器"><a href="#自建安全可靠的-DNS-服务器" class="headerlink" title="自建安全可靠的 DNS 服务器"></a>自建安全可靠的 DNS 服务器</h2><blockquote>
<p>注：你需要一个公网服务器和域名</p>
</blockquote>
<p>前面忘了中间忘了后面也忘了，总而言之在部分比较恶劣的网络环境下你可能会面临 <code>網域伺服器快取汙染</code> 的问题，导致对部分网站的访问在 DNS 解析阶段便获取到错误的结果从而无法正常访问部分网站</p>
<p>由于我们已经有了软路由，DNS 服务器是由我们的路由器通过 DHCP 协议下发给设备的，比较朴素的思路便是将 DNS 解析的工作都交由我们的软路由来完成（在软路由侧为下行设备分配 DNS 服务器为软路由），然后在我们的软路由上再配置安全的 DNS 解析，下图是笔者所使用的架构：</p>
<p><img src="https://s2.loli.net/2025/11/06/e3CRcjHxzBD5pW9.png" srcset="/img/loading.gif" lazyload></p>
<p>首先配置软路由作为所有下行设备的默认 DNS 服务器，这里我们使用经典的 <code>dnsmasq + dnscrypt-proxy</code> 来完成，由于前面我们配置 DHCP 服务的时候已经安装了 dnsmasq，这里我们只需要安装 dnscrypt-proxy：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo emerge -av dnscrypt-proxy</span><br></code></pre></td></tr></table></figure>

<p>接下来在 dnsmasq 配置文件 <code>/etc/dnsmasq.conf</code> 中添加如下内容，将 DNS 服务器配置为软路由，并将 DNS 请求转发到本地的 53553 端口，我们的 <code>dnscrypt-proxy</code> 服务将监听这一端口：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">DNS 服务器，设为软路由 IP，这里仅示例</span><br>dhcp-option=option:dns-server,10.0.0.1<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">DNS服务转发到上游指定服务器，这里是本地的53553端口，注意这里的 <span class="hljs-comment"># 发挥的不是注释的作用</span></span><br>server=/#/127.0.0.1#53553<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">不使用本地的 /etc/resolv.conf 结果，否则部分 DNS 请求会走这条路径</span><br>no-resolv<br></code></pre></td></tr></table></figure>

<p>接下来配置 <code>dnscrypt-proxy</code> 使用安全的 <code>DNS over HTTPS</code> ，修改配置文件   <code>/etc/dnscrypt-proxy/dnscrypt-proxy.toml</code> 对应项为如下内容，这里注意的一点是虽然 DoH 在 <a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc8484">RFC8484</a> 中定义的默认路径是 <code>/dns-query</code> ，但是对于中间人攻击而言这个路径对其是可见的，从而可能会阻断我们的 DoH 查询，因此这里用正常的 <code>index.html</code> 做伪装：</p>
<blockquote>
<p>这里的 stamp 的生成可以使用 <a href="">https://dnscrypt.info/stamps/</a> ，简而言之如图：</p>
<p><img src="https://s2.loli.net/2025/11/05/YxPG5I2V4WEwKFU.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">server_names = [<span class="hljs-string">&#x27;mydoh&#x27;</span>]<br><br>listen_addresses = [<span class="hljs-string">&#x27;127.0.0.1:53553&#x27;</span>]<br><br>bootstrap_resolvers = [<span class="hljs-string">&#x27;223.5.5.5:53&#x27;</span>, <span class="hljs-string">&#x27;114.114.114.114:53&#x27;</span>]<br><br>[static]<br>  [static.mydoh]<br>    stamp = <span class="hljs-string">&quot;自己生成&quot;</span><br></code></pre></td></tr></table></figure>

<p>最后重启 dnsmasq，开启 dnscrypt-proxy ：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl restart dnsmasq</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl <span class="hljs-built_in">enable</span> --now dnscrypt-proxy.service</span><br></code></pre></td></tr></table></figure>

<p>接下来我们配置公网服务器， <code>dnscrypt-proxy</code>  默认使用 POST 方法，Content-Type 自动设置为 <code>application/dns-message</code> ，这是我们在服务端可以将 DoH 请求与普通 Web 访问请求进行区分的一个方法，因此接下来我们先在公网服务器搭建一个网站（怎么搭建就不用👴多说了8），然后修改 NGINX 相关配置如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 匹配咱们的参数并进行标识的变量</span><br><span class="hljs-attribute">map</span> <span class="hljs-string">&quot;<span class="hljs-variable">$request_method</span>:<span class="hljs-variable">$http_content_type</span>:<span class="hljs-variable">$uri</span>&quot;</span> <span class="hljs-variable">$proxy_flag</span> &#123;<br>    <span class="hljs-attribute">default</span> <span class="hljs-number">0</span>;<br>    &quot;POST:application/dns-message:/index.html&quot; &quot;doh&quot;;<br>&#125;<br><br><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-comment"># ...</span><br>    <span class="hljs-comment"># 网页基本配置比如说 ssl 证书路径之类的，这里就直接省略了</span><br>    <br>    <span class="hljs-section">location</span> = /doh &#123;<br>        <span class="hljs-attribute">if</span> (<span class="hljs-variable">$proxy_flag</span> != <span class="hljs-string">&quot;doh&quot;</span>) &#123;<br>            <span class="hljs-attribute">return</span> <span class="hljs-number">404</span>;<br>        &#125;<br><br>        <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$http_host</span>;<br>        <span class="hljs-attribute">proxy_set_header</span> X-Real-IP <span class="hljs-variable">$remote_addr</span>;<br>        <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;<br>        <span class="hljs-attribute">proxy_redirect</span> <span class="hljs-literal">off</span>;<br>        <span class="hljs-attribute">proxy_http_version</span> <span class="hljs-number">1</span>.<span class="hljs-number">1</span>;<br>        <span class="hljs-attribute">proxy_buffering</span> <span class="hljs-literal">off</span>;<br><br>        <span class="hljs-attribute">proxy_pass</span> http://127.0.0.1:8053/dns-query;<br>    &#125;<br>    <br>    <span class="hljs-section">location</span> = /index.html &#123;<br>        <span class="hljs-attribute">root</span> 你的网页文件夹路径;<br>        <br>        <span class="hljs-attribute">if</span> (<span class="hljs-variable">$proxy_flag</span> = <span class="hljs-string">&quot;doh&quot;</span>) &#123;<br>            <span class="hljs-attribute">rewrite</span><span class="hljs-regexp"> ^</span> /doh <span class="hljs-literal">last</span>;<br>        &#125;<br>        <br>        <span class="hljs-attribute">try_files</span> /index.html =<span class="hljs-number">404</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment"># 你的一些其他网页配置</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>完成后重启 NGINX：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl restart nginx</span><br></code></pre></td></tr></table></figure>

<p>然后是配置服务器的 DoH 后端，这里我们选择 <a target="_blank" rel="noopener" href="https://github.com/coredns/coredns">CoreDNS</a> ，其使用 Golang 进行编写，有着更好的性能表现以及高并发支持，这里我们使用 Docker 进行安装（因为这东西虽然火但不知道为什么没有进到各大发行版软件仓库），首先将镜像拉到本地：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker pull coredns/coredns:latest</span><br></code></pre></td></tr></table></figure>

<p>接下来编写配置文件（例如 <code>/home/你的用户名/coredns/Corefile</code> ，后面我们会将其映射进容器里），配置仅监听 <code>127.0.0.1</code> 的 8053 端口，并将 DNS 请求转发到大家所熟知的 <code>1.1.1.1</code> ：</p>
<blockquote>
<p>这里不使用 <code>8.8.8.8</code> 是因为 <code>8.8.8.8</code> 的 <strong>部分解析结果不准</strong> ，例如 <code>dnslog.cn</code> 使用 <code>8.8.8.8</code> 查询 <strong>居然得到</strong> <code>127.0.0.1</code> ， <strong>如果查询结果失真的话那咱们搞这个 DoH 就没意义了</strong> ，因此这里笔者使用 Cloudflare 的 <code>1.1.1.1</code> 服务器而非 Google 的 <code>8.8.8.8</code> </p>
<p><img src="https://s2.loli.net/2025/11/05/4hnA9aeJziCBdxP.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">https://.:8053 &#123;<br>        <span class="hljs-built_in">bind</span> 127.0.0.1<br>        forward . 1.1.1.1<br>        cache 30<br>        <span class="hljs-built_in">log</span><br>        errors<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后启动 docker，这里配置使用本地网络，不然会有一些奇奇怪怪的问题：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -d \</span><br><span class="language-bash">	--network=host \</span><br><span class="language-bash">	--restart=always \</span><br><span class="language-bash">	--name=coredns \</span><br><span class="language-bash">	-v 你的Corefile配置文件路径:/Corefile \</span><br><span class="language-bash">	coredns/coredns:latest</span><br></code></pre></td></tr></table></figure>

<p>现在咱们的安全的 DNS 服务器就完成配置了：）</p>
<h2 id="🕊🕊🕊"><a href="#🕊🕊🕊" class="headerlink" title="🕊🕊🕊"></a>🕊🕊🕊</h2><blockquote>
<p>最近没什么时间折腾软路由，后面应该会补充更新几节：）</p>
</blockquote>
<h1 id="0xFF-写在结束之后"><a href="#0xFF-写在结束之后" class="headerlink" title="0xFF. 写在结束之后"></a>0xFF. 写在结束之后</h1><p>说实话笔者各种解决方案调研下来，对部分搞 homelab 的人的一个很大的刻板印象就是 <strong>整体上不专业</strong> ——诚然，圈子里是有真正专业的人，但是 <strong>非常多的人都在不专业的解决方案上一路狂飙，同时还带动更多新入坑的小白在不专业的道路上越跑越远</strong> ——笔者个人觉得， <strong>要么就花比较少的精力弄个省事点的架构</strong> （比如说直接安个 OpenWrt 或者 iKuaiOS 然后开躺就完事了）， <strong>要么就花费足量的精力弄一个相对专业的网络架构，如果又花费大量精力结果又弄出来一个丑陋的不专业的网络架构，还带领着小白学习这样的不专业的做法，那是否未免有点…</strong> </p>
<p>诚如古人所言，“学而不思则罔，思而不学则殆”，这些问题的根源其实很大程度上就是 “思而不学” ，<strong>想折腾但又未尝深入学习计算机网络工程相关知识，毕竟能用就行</strong> ——于是乎就造出来很多虽然看着能用但是实际上十分难以用偏正面的词汇去形容的解决方案——诚然，自己用的话那没什么好说的， <strong>但真正可怕的是这种能用就行的风气会带着后面越来越多新入坑的人也在这样的道路上一路狂飙，从而使得最后错误的解决方案反而还成为了主流…</strong> </p>
<p>当然笔者并不认为自己学过一点计网和网工就高人一等或是怎么样的，但是如果哪怕稍微拉一些有思科或者华为认证的网络工程师来看一遍现在部分小圈子里的各种 主流解决方案，我相信没有一个是会不破口狂喷的——当然不得不承认的是 <strong>很多需要折腾的东西虽然丑陋但是据称也 work well ，但这应该成为主流吗？</strong> </p>
<p>诚然，笔者非常乐意看到简单易上手的 iKuaiOS 之流成为小白的心头之好，笔者也很愿意看到大家分享自己的各种奇妙的解决方案，这些都是很好的事情， <strong>但如果最终非专业的解决方案成了圈子的主流，入门软路由上来言必旁路由，在不清楚自己需求的情况下一定要 PVE 里再套 OpenWrt 和 iKuaiOS，那笔者不得不感叹一句这是这个时代的悲哀</strong> </p>
<p>当然，笔者自认为自己没办法改变一些我所不喜欢的现状， <strong>我自认也没有资格去这么做</strong> ，笔者唯一能够做的就是尽量保持自己在一定程度上依然能够保有科班出身的专业性（虽然很多专业课的知识似乎都开始有点慢慢忘却了）， 在这之外期盼一下笔者的这个基本没什么人会来看的博客能够为一小部分读者带来一定的收获， <strong>其他的笔者也就不奢求了，因为也没有必要抱有期待，毕竟期望越大失望越大</strong></p>
<p>最后的最后，如果你的观点和笔者有所不同，可以在本篇博客下方讨论，如果想转载的话按照博客的 CC 那个啥协议（看下边，👴也忘了叫啥了）就行——但是最好还是不要引流太多人过来，笔者可不希望成为众矢之的 ：(</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/OPS/" class="category-chain-item">OPS</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Linux/">#Linux</a>
      
        <a href="/tags/%E8%BF%90%E7%BB%B4/">#运维</a>
      
        <a href="/tags/%E8%BD%AF%E8%B7%AF%E7%94%B1/">#软路由</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>【OPS.0x09】家用软路由手搓日志</div>
      <div>http://example.com/2025/09/30/OPS-0X09-SOFT_ROUTER_GUIDE/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>arttnba3</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年9月30日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/08/25/OPS-0X08-SECURE_DNS/" title="【OPS.0x08】搭建安全可靠的 DNS over HTTPS">
                        <span class="hidden-mobile">【OPS.0x08】搭建安全可靠的 DNS over HTTPS</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.4.17/Valine.min.js', function() {
        var options = Object.assign(
          {"appid":"ICj6cPRQWFTNiOttBHlzxnIv-gzGzoHsz","appkey":"tuvJh3xYxPFcW2JB6K26RKP2","path":"window.location.pathname","placeholder":"说点什么呗（笑）","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false,"appId":"ICj6cPRQWFTNiOttBHlzxnIv-gzGzoHsz","appKey":"tuvJh3xYxPFcW2JB6K26RKP2"},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  <!-- 网站运行时间的设置 -->
  <span id="timeDate">载入天数...</span>
  <span id="times">载入时分秒...</span>
  <script>
      var now = new Date();
      function createtime() {
          var grt= new Date("04/20/2020 17:48:48");//此处修改你的建站时间或者网站上线时间
          now.setTime(now.getTime()+250);
          days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
          hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
          if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
          mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
          seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
          snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
          document.getElementById("timeDate").innerHTML = "arttnba3的小屋已经安全存在了 "+dnum+" 天 ";
          document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
      }
  setInterval("createtime()",250);
  </script>
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
    <!-- 备案信息 ICP for China -->
    <div class="beian">
  <span>
    <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
      桂ICP备2022005068号-1
    </a>
  </span>
  
</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.1/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
