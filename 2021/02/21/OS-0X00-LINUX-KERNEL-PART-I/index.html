

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/avatar.png">
  <link rel="icon" href="/img/avatar.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="arttnba3">
  <meta name="keywords" content="">
  
    <meta name="description" content="Big Linus is watching you!">
<meta property="og:type" content="article">
<meta property="og:title" content="【OS.0x00】Linux Kernel I：Basic Knowledge">
<meta property="og:url" content="https://arttnba3.github.io/2021/02/21/OS-0X00-LINUX-KERNEL-PART-I/index.html">
<meta property="og:site_name" content="arttnba3&#39;s blog">
<meta property="og:description" content="Big Linus is watching you!">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/IYaievPRZpAVMH7.png">
<meta property="article:published_time" content="2021-02-21T10:02:14.000Z">
<meta property="article:modified_time" content="2024-11-11T00:11:27.598Z">
<meta property="article:author" content="arttnba3">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="Linux Kernel">
<meta property="article:tag" content="操作系统">
<meta property="article:tag" content="Pwn">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/IYaievPRZpAVMH7.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>【OS.0x00】Linux Kernel I：Basic Knowledge - arttnba3&#39;s blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"arttnba3.github.io","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":"§"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.1.1"><link rel="alternate" href="/atom.xml" title="arttnba3's blog" type="application/atom+xml">
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 80vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>arttnba3&#39;s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/atom.xml">
                <i class="iconfont icon-rss"></i>
                rss
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://i.loli.net/2021/02/24/XZGi8QpIsTdMhAW.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="【OS.0x00】Linux Kernel I：Basic Knowledge"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2021-02-21 21:02" pubdate>
          2021年2月21日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          19k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          158 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
        <div class="scroll-down-bar">
          <i class="iconfont icon-arrowdown"></i>
        </div>
      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">【OS.0x00】Linux Kernel I：Basic Knowledge</h1>
            
              <p class="note note-info">
                
                  
                    本文最后更新于：2024年11月11日 上午
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <p>Big Linus is watching you!</p>
<span id="more"></span>

<h1 id="0x00-OS-Basis"><a href="#0x00-OS-Basis" class="headerlink" title="0x00.OS Basis"></a>0x00.OS Basis</h1><h3 id="I-操作系统究竟是什么？"><a href="#I-操作系统究竟是什么？" class="headerlink" title="I.操作系统究竟是什么？"></a>I.操作系统究竟是什么？</h3><p>在开始之前，笔者想让大家重新来思考这个问题：</p>
<ul>
<li>操作系统究竟是一个什么东西？</li>
</ul>
<p>可能有的人会像笔者当年那样照本宣科地说——操作系统（Operation System）本质上也是一种软件，可以看作是普通应用程式与硬件之间的一层中间层，其主要作用便是调度系统资源、控制IO设备、操作网络与文件系统等，并为上层应用提供便捷、抽象的应用接口</p>
<p>那么在抛开掉这些词藻的背后，操作系统又是什么样的一个东西呢？这里笔者给出<strong>笔者自己所认为的定义</strong>：</p>
<ul>
<li><strong>操作系统实际上是我们抽象出来的一个概念，本质上与用户进程一般无二，都是位于物理内存中的代码+数据，不同之处在于当CPU执行操作系统内核代码时通常运行在高权限环境，拥有着完全的硬件访问能力，而 CPU在执行用户态代码时通常运行在低权限环境，只拥有部分&#x2F;缺失硬件访问能力</strong></li>
</ul>
<p>这两种不同权限的运行状态实际上<strong>是通过硬件来实现的</strong>，这里我们开始引入新的一个概念——</p>
<h3 id="II-分级保护域"><a href="#II-分级保护域" class="headerlink" title="II.分级保护域"></a>II.分级保护域</h3><p><strong>分级保护域</strong>（<strong>hierarchical protection domains</strong>）又被称作保护环，简称 Rings ，是一种将计算机不同的资源划分至不同权限的模型</p>
<p> 在一些硬件或者微代码级别上提供不同特权态模式的 CPU 架构上，保护环通常都是硬件强制的。Rings是从最高特权级（通常被叫作0级）到最低特权级（通常对应最大的数字）排列的</p>
<p>Ring0 拥有最高特权，并且可以和最多的硬件直接交互（比如CPU，内存），因此<strong>操作系统内核代码通常运行在 ring0 下，即 CPU 在执行操作系统内核代码时处在 ring0 下</strong></p>
<p>Intel的CPU将权限分为四个等级：<strong>Ring0</strong>、Ring1、Ring2、<strong>Ring3</strong>，权限等级依次降低，现代操作系统模型中我们通常只会使用 ring0 和 ring3，对应操作系统内核与用户进程，即 <strong>CPU 在执行用户进程代码时处在 ring3 下</strong></p>
<p><img src="https://i.loli.net/2021/02/22/yQXZhLEHVn1b3uC.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>那么我们现在可以给【用户态】与【内核态】这两个概念下定义了：</p>
<ul>
<li>用户态：CPU 运行在 ring3 + 用户进程运行环境上下文</li>
<li>内核态：CPU 运行在 ring0 + 内核代码运行环境上下文</li>
</ul>
<h3 id="III-运行状态切换"><a href="#III-运行状态切换" class="headerlink" title="III.运行状态切换"></a>III.运行状态切换</h3><p>那么操作系统如何使得 CPU 在不同的特权级间进行切换以进行调度呢？主要有两个途径：</p>
<ul>
<li><p>中断（interrupt）：当 CPU 收到一个外部中断时，会切换到 ring0，并根据中断描述符表索引对应的中断处理代码以执行</p>
<blockquote>
<p>例如当笔者敲下这一行字时，便发生了许多次的键盘中断（笑）</p>
</blockquote>
</li>
<li><p>特权级相关指令：当 CPU 运行这些指令时会发生运行状态的改变，例如 iret 指令（ring0-&gt;ring3）或是 sysenter 指令（ring3-&gt;ring0）</p>
</li>
</ul>
<p>基于这些特权级切换的方式，现代操作系统的开发者包装出了一种名为<strong>系统调用</strong>（syscall）的东西，作为由”用户态“切换到”内核态“的入口，从而执行内核代码来完成用户进程所需的一些功能；当用户进程想要请求更高权限的服务时，便需要通过由系统提供的应用接口，使用系统调用以<strong>陷入内核态，再由操作系统完成请求</strong></p>
<h3 id="IV-进程-进程运行环境上下文-内核数据结构"><a href="#IV-进程-进程运行环境上下文-内核数据结构" class="headerlink" title="IV.进程 &#x3D; 进程运行环境上下文 + 内核数据结构"></a>IV.进程 &#x3D; 进程运行环境上下文 + 内核数据结构</h3><p>进程<strong>本质上是我们抽象出来的一个概念</strong>，CPU 是不知道也不可能知道进程是什么东西的，他只知道<strong>当前核心的寄存器的数据是这样，运行状态是这样，内存里的数据是那样</strong>，但我们可以<strong>人为地进行划分</strong>——将当前的运行环境上下文称之为一个<strong>进程实体</strong></p>
<p>接下来我们引入一个新的概念——<strong>页表</strong>（page table）。这通常是一个多级结构，用以对应表示一个虚拟地址空间中存在的每张内存页所对应的物理内存，下图是一张经典的二级页表结构：</p>
<p><img src="https://s2.loli.net/2022/03/15/bnYKURW1xPg7CHN.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>当开启分页模式之后，我们对内存的访问都需要通过页表进行，利用多级页表将对应的虚拟地址转化为物理地址后才能进行内存访问，因此<strong>当前页表集所表示的物理地址空间为我们当前所能访问的物理地址空间</strong></p>
<p>我们想要让我们的计算机真正变成一个多任务系统，让其运行多个不同的进程，则我们<strong>需要实现不同进程间的虚拟地址空间的隔离</strong>，因此：</p>
<ul>
<li><strong>每个进程都有自己独立的一组页表集</strong></li>
</ul>
<p>那么现在我们可以对抽象出来的进程的概念下一个定义了：进程 &#x3D; 寄存器上下文 + 虚拟地址空间，<strong>这便是进程最核心的本质</strong></p>
<p>但是有了这些还不够，因为需要运行的进程数量<strong>往往大于 CPU 核心数量</strong>，因此我们不能够让某几个进程占据所有的 CPU 时间，而应当对进程进行调度，让每个进程都有机会在 CPU 上运行——<strong>进程调度</strong>（schedule）的概念就出来了</p>
<p>那么我们如何知道什么时候该调度一个进程？这里我们就需要借助到硬件的辅助了——<strong>时钟中断</strong>用来帮助我们实现进程的调度</p>
<p>什么是时钟中断？这里笔者不深入介绍，你可以理解为在 CPU 上有个定时器，每隔一段时间就会向 CPU 发送一个中断，这个中断便是我们所说的时钟中断，而前面我们讲到：当 CPU 收到一个外部中断时，会切换到 ring0，并根据中断描述符表索引对应的中断处理代码以执行，<strong>因为时钟中断是会不断定时触发的，我们可以在时钟中断对应的处理代码中加入属于进程调度的部分</strong>，由此我们得知：</p>
<ul>
<li><strong>操作系统利用时钟中断完成进程调度</strong></li>
</ul>
<p>那么我们怎么知道当前运行的这个进程是否需要被调度呢？我们又如何切换到另一个进程呢？为了解决这个问题，<strong>对于每一个进程，我们在内核地址空间中都会对应创建一个新的数据结构实体，在其中保存着该进程上次运行的环境上下文、运行的总时间等信息</strong>——我们称之为<strong>进程控制块</strong>（process control block，PCB）</p>
<p>在需要进行进程调度时，我们便能将当前进程的上下文保存到其在内核空间中对应的 PCB 中，记录其运行时间，并取出要运行的下一个进程对应的 PCB，从其中恢复待运行进程的环境上下文，因此：</p>
<ul>
<li>每个进程在内核空间当中都有着一个对应的 PCB 保存其相关信息</li>
</ul>
<blockquote>
<p> 当然， PCB 还可以记录诸如进程权限、父子关系等信息，不过这里仅介绍对于 PCB 而言最基础也是最必须要的组件：进程上下文以及进程运行时间</p>
<blockquote>
<p>进程运行时间其实也可以不用记录，直接默认进程时间片为一个时钟周期即可，不过现代操作系统往往会使用更加复杂的调度系统（例如 Linux 现在使用的 CFS 调度算法）</p>
</blockquote>
</blockquote>
<p>最后，有了以上这些概念之后，我们来为<strong>进程</strong>（process）下一个定义：</p>
<ul>
<li><strong>进程 &#x3D; 进程运行环境上下文 + 内核数据结构</strong></li>
</ul>
<p>好了，现在我们可以重新从头开始看操作系统的基本知识了</p>
<h1 id="0x01-内核"><a href="#0x01-内核" class="headerlink" title="0x01.内核"></a>0x01.内核</h1><h2 id="一、Introduction"><a href="#一、Introduction" class="headerlink" title="一、Introduction"></a>一、Introduction</h2><p><strong>操作系统</strong>（Operation System）本质上也是一种软件，可以看作是普通应用程式与硬件之间的一层中间层，其主要作用便是调度系统资源、控制IO设备、操作网络与文件系统等，并为上层应用提供便捷、抽象的应用接口</p>
<p>而运行在内核态的<strong>内核</strong>（<strong>kernel</strong>）则是<strong>一个操作系统最为核心的部分</strong>，提供着一个操作系统最为基础的功能</p>
<p>这张十分经典的图片说明了Kernel在计算机体系结构中的位置：</p>
<p><img src="https://i.loli.net/2021/02/22/eX5h7aRdOrCkb9j.png" srcset="/img/loading.gif" lazyload></p>
<p>kernel 的主要功能可以归为以下三点：</p>
<ul>
<li><strong>控制并与硬件进行交互</strong></li>
<li><strong>提供应用程式运行环境</strong></li>
<li><strong>调度系统资源</strong></li>
</ul>
<p>包括 I&#x2F;O，权限控制，系统调用，进程管理，内存管理等多项功能都可以归结到以上三点中</p>
<p>但与一般的应用程式不同，系统内核的发生 crash 通常会引起系统重启</p>
<h2 id="二、内核架构：微内核-宏内核-混合内核"><a href="#二、内核架构：微内核-宏内核-混合内核" class="headerlink" title="二、内核架构：微内核 &amp; 宏内核 &amp; 混合内核"></a>二、内核架构：微内核 &amp; 宏内核 &amp; 混合内核</h2><p>通常来说我们可以把内核架构分为两种：<code>宏内核</code>和<code>微内核</code>，现在还有一种内核是混合了宏内核与微内核的特性，称为 <code>混合内核</code> ，三种内核的大致架构如下图所示：</p>
<p><img src="https://i.loli.net/2021/02/22/eQlyv3DszOjXPuw.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h3 id="I-宏内核（Monolithic-Kernel）"><a href="#I-宏内核（Monolithic-Kernel）" class="headerlink" title="I.宏内核（Monolithic Kernel）"></a>I.宏内核（Monolithic Kernel）</h3><blockquote>
<p> <strong>宏内核</strong>（英语：Monolithic kernel），也译为<strong>集成式内核</strong>、<strong>单体式内核</strong>，一种<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%86%85%E6%A0%B8">操作系统内核</a>架构，此架构的特性是整个内核程序是一个单一二进制可执行文件，在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%A0%B8%E5%BF%83%E7%A9%BA%E9%96%93">内核态</a>以监管者模式（Supervisor Mode）来运行。相对于其他类型的操作系统架构，如<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%BE%AE%E6%A0%B8%E5%BF%83">微内核</a>架构或<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%B7%B7%E6%A0%B8%E5%BF%83">混合内核</a>架构等，这些内核会定义出一个高端的虚拟接口，由该接口来涵盖描述整个电脑硬件，这些描述会集合成一组硬件描述用词，有时还会附加一些<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8">系统调用</a>，如此可以用一个或多个模块来实现各种操作系统服务，如<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B">进程</a>管理、并发（Concurrency）控制、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%A8%98%E6%86%B6%E9%AB%94%E7%AE%A1%E7%90%86">存储器管理</a>等。 </p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B4%E5%A1%8A%E6%80%A7%E6%A0%B8%E5%BF%83">Wikipedia: 整塊性核心</a></p>
</blockquote>
<p>通俗地说，宏内核几乎将一切都集成到了内核当中，并向上层应用程式提供抽象API（通常是以系统调用的形式），例如 Unix 与类 Unix 便通常都是宏内核</p>
<p><img src="https://i.loli.net/2021/02/22/fSwY9R4KHZLnkbl.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<blockquote>
<p>以 Linux 为例，其操作系统内核的二进制文件通常位于 <code>/boot/vmlinuz</code></p>
</blockquote>
<h3 id="II-微内核（Micro-Kernel）"><a href="#II-微内核（Micro-Kernel）" class="headerlink" title="II.微内核（Micro Kernel）"></a>II.微内核（Micro Kernel）</h3><p>对于微内核而言，大部分的系统服务（如文件管理等）都被剥离于内核之外，内核仅仅提供最为基本的一些功能：底层的寻址空间管理、线程管理、进程间通信等</p>
<p>Windows NT 与 Mach 都宣称采用了微内核架构，不过本质上他们更贴近于混合内核（Hybrid Kernel）——在内核中集成了部分需要具备特权的服务组件 </p>
<p><img src="https://i.loli.net/2021/02/22/eZY4WcMJytUNCuF.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<blockquote>
<p> 本文中我们主要讨论Linux内核</p>
</blockquote>
<h1 id="0x02-分级保护域"><a href="#0x02-分级保护域" class="headerlink" title="0x02.分级保护域"></a>0x02.分级保护域</h1><p><strong>分级保护域</strong>（<strong>hierarchical protection domains</strong>）又被称作保护环，简称 Rings ，是一种将计算机不同的资源划分至不同权限的模型</p>
<p> 在一些硬件或者微代码级别上提供不同特权态模式的 CPU 架构上，保护环通常都是硬件强制的。Rings是从最高特权级（通常被叫作0级）到最低特权级（通常对应最大的数字）排列的</p>
<p>在大多数操作系统中，Ring0 拥有最高特权，并且可以和最多的硬件直接交互（比如CPU，内存）</p>
<p>内层ring可以任意调用外层ring的资源</p>
<h2 id="一、Intel-Ring-Model"><a href="#一、Intel-Ring-Model" class="headerlink" title="一、Intel Ring Model"></a>一、Intel Ring Model</h2><p>Intel 的 CPU 将权限分为四个等级：<strong>Ring0</strong>、Ring1、Ring2、<strong>Ring3</strong>，权限等级依次降低，<strong>大部分现代操作系统只用到了ring0 和 ring3，其中 kernel 运行在 ring0，用户态程序运行在 ring3</strong></p>
<p><img src="https://i.loli.net/2021/02/22/yQXZhLEHVn1b3uC.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<blockquote>
<p> 使用 Ring Model 是为了提升系统安全性，例如某个间谍软件作为一个在 Ring 3 运行的用户程序，在不通知用户的时候打开摄像头会被阻止，因为访问硬件需要使用 being 驱动程序保留的 Ring 1 的方法 </p>
</blockquote>
<p>操作系统本身便是一个运行在内核态的程序，当计算机通电之后首先会载入 ROM（BIOS&#x2F;UEFI），之后载入第二引导程序（Linux 通常用 GNU Grub），由第二引导程序来将操作内核载入到内存当中并跳转到内核入口点，将控制权移交内核</p>
<p>内核在完成一系列的初始化过程之后，会启动一些低权限（ring3）的进程以向我们提供用户界面</p>
<h2 id="二、虚拟内存空间"><a href="#二、虚拟内存空间" class="headerlink" title="二、虚拟内存空间"></a>二、虚拟内存空间</h2><p>在现代操作系统中，计算机的虚拟内存地址空间通常被分为两块——供用户进程使用的用户空间（user space）与供操作系统内核使用的内核空间（kernel space），对于 Linux 而言，通常位于较高虚拟地址的虚拟内存空间被分配给内核使用，而位于较低虚拟地址的虚拟内存空间责备分配给用户进程使用</p>
<ul>
<li>32 位下的虚拟内存空间布局如下：</li>
</ul>
<p><img src="https://i.loli.net/2021/11/09/qLsr8xECYNpRbAI.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<ul>
<li>64位下的虚拟内存空间布局如下：</li>
</ul>
<p><img src="https://i.loli.net/2021/11/09/k8NHa1ljMEfXQbh.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h2 id="三、用户态-内核态"><a href="#三、用户态-内核态" class="headerlink" title="三、用户态 &amp; 内核态"></a>三、用户态 &amp; 内核态</h2><p>抛开华丽的辞藻，这两个词最本质的含义是：</p>
<ul>
<li>用户态：CPU 运行在 ring3 + 用户进程运行环境上下文</li>
<li>内核态：CPU 运行在 ring0 + 内核代码运行环境上下文</li>
</ul>
<p>通常情况下，不同用户进程间的用户地址空间是隔离的，但都共享着相同的内核地址空间，<strong>即不同的用户进程在相同的内核虚拟地址空间上都有着一致的对内核物理地址空间的映射</strong></p>
<h1 id="0x03-运行状态切换与控制流转移"><a href="#0x03-运行状态切换与控制流转移" class="headerlink" title="0x03. 运行状态切换与控制流转移"></a>0x03. 运行状态切换与控制流转移</h1><p>计算机运行时总会经历无数次的用户态与内核态之间的转换，进行无数次的控制流转移</p>
<ul>
<li>用户进程往往需要使用内核所提供的各种功能，此时就需要通过系统调用等接口陷入内核，待任务完成之后再“着陆”回用户态</li>
<li>操作系统往往也需要“主动地”暂停当前进程的运行，让 CPU 陷入到内核态并获取控制权，这通常是因为有需要内核主动处理的事件（如外部中断）</li>
</ul>
<p>通常而言，CPU 由用户态陷入到内核态主要有以下几种途径：</p>
<ul>
<li><strong>系统调用</strong>（通常通过 int 0x80&#x2F;syscall&#x2F;sysenter 指令）</li>
<li><strong>异常</strong> （例如进行了除 0 操作）</li>
<li><strong>外设产生中断</strong> （例如时钟中断）</li>
<li>…</li>
</ul>
<p>主要的一个过程如下：</p>
<ul>
<li><p>切换 GS 段寄存器：通过 <code>swapgs</code> 切换 GS 段寄存器，将 GS 寄存器值和一个特定位置的值进行交换，目的是保存 GS 值，同时将该位置的值作为内核执行时的 GS 值使用</p>
</li>
<li><p>保存用户态栈帧信息：将当前栈顶（用户空间栈顶）记录在 CPU 独占变量区域里（由 GS 寄存器所指定的<code>percpu</code> 段），将 CPU 独占区域里记录的内核栈顶放入 rsp&#x2F;esp </p>
</li>
<li><p>保存用户态寄存器信息： 通过 push 保存各寄存器值到栈上，以便后续“着陆”回用户态</p>
</li>
<li><p>通过汇编指令判断是否为32位</p>
</li>
<li><p>控制权转交内核，执行相应的操作</p>
</li>
</ul>
<p>由内核态重新“着陆”回用户态只需要恢复用户空间信息即可：</p>
<ul>
<li><code>swapgs</code> 指令恢复用户态GS寄存器</li>
<li><code>sysretq</code> 或者<code>iretq</code> 系列指令让 CPU 运行模式回到 ring 3，恢复用户空间程序的继续运行</li>
</ul>
<h2 id="一、中断"><a href="#一、中断" class="headerlink" title="一、中断"></a>一、中断</h2><p>中断即硬件&#x2F;软件向 CPU 发送的特殊信号，CPU 接收到中断后会<strong>停下当前工作转而执行中断处理程序</strong>，完成中断处理后再重新恢复原工作流程</p>
<p>实模式下使用中断向量表（interrupt vector table，该表通常位于物理地址 0~1k 处）存放不同中断号对应的中断处理程序的地址，自保护模式起引入<strong>中断描述符表</strong>（Interrupt Descriptor Table）用以存放 <strong>「门描述符」</strong>（gate descriptor），中断描述符表地址存放在 IDTR 寄存器中，CPU 通过中断描述符表访问对应门</p>
<p><strong>「门」</strong>（gate）可以理解为中断的前置检查物件，当中断发生时会先通过这些「门」，主要有如下三种门：</p>
<ul>
<li>中断门（Interrupt gate）：用以进行<strong>硬</strong>中断处理，其类型码为 110；中断门的 DPL（Descriptor Priviledge Level）为 0，故只能在内核态下访问，即中断处理程序应当由内核激活；进入中断门会清除 IF 标志位以关闭中断，防止中断嵌套的发生</li>
<li>陷阱门（Trap gate）：类型码为 111，类似于中断门，主要用以处理 CPU 异常，但不会清除 IF 标志位</li>
<li><strong>系统门</strong>（System gate）：Linux 特有门，类型码为 3、4、5、128；其 DPL 为 3，用以供用户进程访问，主要用以<strong>进行系统调用</strong>（int 0x80）</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/arttnba3/BlogPic@master/20231109210238.png" srcset="/img/loading.gif" lazyload alt="中断描述符表"></p>
<h2 id="二、系统调用"><a href="#二、系统调用" class="headerlink" title="二、系统调用"></a>二、系统调用</h2><p><strong>系统调用</strong>（<strong>system call</strong>）是由操作系统内核向上层应用程式提供的应用接口，操作系统负责调度一切的资源，当用户进程想要请求更高权限的服务时，便需要通过由系统提供的应用接口，使用系统调用以<strong>陷入内核态，再由操作系统完成请求</strong></p>
<blockquote>
<p> Windows系统下将系统调用封装在win32 API中，不过本篇博文主要讨论Linux</p>
</blockquote>
<h3 id="I-系统调用表"><a href="#I-系统调用表" class="headerlink" title="I. 系统调用表"></a>I. 系统调用表</h3><p>所有的系统调用被声明于内核源码<code>arch/x86/entry/syscalls/syscall_64.tbl</code> 中，在该表中声明了系统调用的标号、类型、名称、内核态函数名称</p>
<p>在内核中使用 <code>系统调用表（System Call Table）</code> 对系统调用进行索引，该表中储存了不同标号的系统调用函数的地址，当进程进行系统调用时会根据该表寻找到不同系统调用对应的处理函数</p>
<h3 id="II-进行系统调用"><a href="#II-进行系统调用" class="headerlink" title="II. 进行系统调用"></a>II. 进行系统调用</h3><p>Linux下的系统调用以<code>eax/rax</code>寄存器作为<strong>系统调用号</strong>，参数传递约束如下：</p>
<ul>
<li>32 位：<code>ebx、ecx、edx、esi、edi、ebp</code> 作为第一个参数、第二个参数…进行参数传递</li>
<li>64 位：<code>rdi、rsi、rdx、r10、r8、r9 </code>作为第一个参数、第二个参数…进行参数传递</li>
</ul>
<p>对于 32 位系统调用而言，Linux 实际上通过 0x80 号软中断实现系统调用的基本功能，即用户态程序通过 <code>int 0x80</code> 指令触发一个软中断陷入内核题，对应的中断处理程序会根据系统调用号在系统调用表中调用对应的处理</p>
<p><img src="https://cdn.jsdelivr.net/gh/arttnba3/BlogPic@master/20231109205928.png" srcset="/img/loading.gif" lazyload alt="0x80 号中断：系统调用"></p>
<p>对于 64 位系统调用而言，CPU 提供了 <code>syscall/sysenter</code> 指令来替代开销巨大的中断，内核启动时会将系统调用函数入口（<code>entry_SYSCALL_64</code>）写入 MSR 寄存器组中，当执行 <code>syscall/sysenter</code> 指令时 CPU 会进入 ring0 并自动跳转到 MSR 寄存器所指定的系统调用入口中：</p>
<ul>
<li>通过 <code>swapgs</code> 指令将 GS 寄存器值和一个特定位置的值进行交换，目的是保存 GS 值，同时将该位置的值作为内核执行时的 GS 值使用</li>
<li>将当前栈顶（用户空间栈顶）记录在 CPU 独占变量区域里（由 GS 寄存器所指定的 <code>percpu</code> 段），将 CPU 独占区域里记录的内核栈顶赋给 rsp&#x2F;esp 寄存器</li>
<li>将用户态各寄存器值到栈上形成一个 <code>pt_regs</code> 结构体，以便后续“着陆”回用户态</li>
<li>根据系统调用号在系统调用表中取出对应的系统调用函数指针执行</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/arttnba3/BlogPic@master/20231109205309.png" srcset="/img/loading.gif" lazyload alt="64 位系统调用：syscall 指令"></p>
<h3 id="III-系统调用返回"><a href="#III-系统调用返回" class="headerlink" title="III. 系统调用返回"></a>III. 系统调用返回</h3><p>同样地，内核执行完系统调用后退出系统调用也有对应的两种方式：</p>
<ul>
<li>执行 <code>iret</code> 汇编指令（其实就是中断返回的方式）</li>
<li>执行 <code>sysret</code> 汇编指令 &#x2F; 执行 <code>sysexit</code> 汇编指令（only Intel）</li>
</ul>
<h2 id="三、信号机制"><a href="#三、信号机制" class="headerlink" title="三、信号机制"></a>三、信号机制</h2><p>Signals 机制（又称之为软中断信号）是UNIX及类UNIX系统中的一种<strong>异步</strong>的进程间通信方式，用以通知一个进程发生了某个事件，通常情况下常见的流程如下图所示：</p>
<p><img src="https://i.loli.net/2021/03/11/DbsyXV3huR2FmQJ.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<ul>
<li>源程序通过 <code>kill()</code> 系统调用向目标程序发送信号，该信号会被存储到进程描述符的信号队列当中</li>
<li>① 当目标进程<strong>重新被调度时</strong>内核首先会检查该进程的信号队列，若存在未处理信号则会进行信号处理流程：内核会<strong>将用户态进程的寄存器逐一压入【用户态进程的栈上】</strong>，形成一个 <code>sigcontext</code> 结构体，接下来压入 SIGNALINFO 以及<strong>指向系统调用 sigreturn 的代码</strong>，用以在后续返回时恢复用户态进程上下文；压入栈上的这一大块内容称之为一个 <code>SigreturnFrame</code>，同时也是一个<code>ucontext_t</code>结构体</li>
<li>② 控制权回到用户态进程，<strong>用户态进程</strong>跳转到相应的 signal handler 函数以处理不同的信号，完成之后将会执行位于其栈上的第一条指令——<code>sigreturn系统调用</code></li>
<li>③ 进程通过 sigreturn 系统调用重新陷入内核，恢复原有工作的用户态上下文信息</li>
<li>④ 控制权重新返还给用户态进程，恢复进程原上下文</li>
</ul>
<p>需要注意的是信号处理机制并不是即时的，即<strong>发送信号并不能直接中断一个正在运行中的进程</strong>，但 Linux 进程调度的频率是非常频繁的，因此信号通常都能很快被处理</p>
<h1 id="0x04-进程权限管理"><a href="#0x04-进程权限管理" class="headerlink" title="0x04.进程权限管理"></a>0x04.进程权限管理</h1><p>前面我们讲到，kernel 调度着一切的系统资源，并为用户应用程式提供运行环境，相应地，应用程式的权限也都是由 kernel 进行管理的</p>
<h2 id="一、进程描述符（process-descriptor）"><a href="#一、进程描述符（process-descriptor）" class="headerlink" title="一、进程描述符（process descriptor）"></a>一、进程描述符（process descriptor）</h2><p>在内核中使用结构体 <code>task_struct</code> 表示一个进程，该结构体定义于内核源码<code>include/linux/sched.h</code>中，代码比较长就不在这里贴出了</p>
<p>一个进程描述符的结构应当如下图所示：</p>
<p><img src="https://i.loli.net/2021/02/23/2W8xIfwqm9Y7Fru.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>本篇我们主要关心其对于进程权限的管理</p>
<p>注意到<code>task_struct</code>的源码中有如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Process credentials: */</span><br><br><span class="hljs-comment">/* Tracer&#x27;s credentials at attach: */</span><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cred</span> __<span class="hljs-title">rcu</span>        *<span class="hljs-title">ptracer_cred</span>;</span><br><br><span class="hljs-comment">/* Objective and real subjective task credentials (COW): */</span><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cred</span> __<span class="hljs-title">rcu</span>        *<span class="hljs-title">real_cred</span>;</span><br><br><span class="hljs-comment">/* Effective (overridable) subjective task credentials (COW): */</span><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cred</span> __<span class="hljs-title">rcu</span>        *<span class="hljs-title">cred</span>;</span><br></code></pre></td></tr></table></figure>

<p><strong>Process credentials</strong> 是 kernel 用以判断一个进程权限的凭证，在 kernel 中使用 <code>cred</code> 结构体进行标识，对于一个进程而言应当有三个 cred：</p>
<ul>
<li><strong>ptracer_cred：</strong>使用<code>ptrace</code>系统调用跟踪该进程的上级进程的cred（gdb调试便是使用了这个系统调用，常见的反调试机制的原理便是提前占用了这个位置）</li>
<li><strong>real_cred：</strong>即<strong>客体凭证</strong>（<strong>objective cred</strong>），通常是一个进程最初启动时所具有的权限</li>
<li><strong>cred：</strong>即<strong>主体凭证</strong>（<strong>subjective cred</strong>），该进程的有效cred，kernel以此作为进程权限的凭证</li>
</ul>
<p>一般情况下，主体凭证与客体凭证的值是相同的</p>
<blockquote>
<p>例：当进程 A 向进程 B 发送消息时，A为主体，B为客体</p>
</blockquote>
<h3 id="进程权限凭证：cred结构体"><a href="#进程权限凭证：cred结构体" class="headerlink" title="进程权限凭证：cred结构体"></a>进程权限凭证：cred结构体</h3><p>对于一个进程，在内核当中使用一个结构体<code>cred</code>管理其权限，该结构体定义于内核源码<code>include/linux/cred.h</code>中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cred</span> &#123;</span><br>    <span class="hljs-type">atomic_t</span>    usage;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span><br>    <span class="hljs-type">atomic_t</span>    subscribers;    <span class="hljs-comment">/* number of processes subscribed */</span><br>    <span class="hljs-type">void</span>        *put_addr;<br>    <span class="hljs-type">unsigned</span>    magic;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CRED_MAGIC    0x43736564</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CRED_MAGIC_DEAD    0x44656144</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-type">kuid_t</span>        uid;        <span class="hljs-comment">/* real UID of the task */</span><br>    <span class="hljs-type">kgid_t</span>        gid;        <span class="hljs-comment">/* real GID of the task */</span><br>    <span class="hljs-type">kuid_t</span>        suid;        <span class="hljs-comment">/* saved UID of the task */</span><br>    <span class="hljs-type">kgid_t</span>        sgid;        <span class="hljs-comment">/* saved GID of the task */</span><br>    <span class="hljs-type">kuid_t</span>        euid;        <span class="hljs-comment">/* effective UID of the task */</span><br>    <span class="hljs-type">kgid_t</span>        egid;        <span class="hljs-comment">/* effective GID of the task */</span><br>    <span class="hljs-type">kuid_t</span>        fsuid;        <span class="hljs-comment">/* UID for VFS ops */</span><br>    <span class="hljs-type">kgid_t</span>        fsgid;        <span class="hljs-comment">/* GID for VFS ops */</span><br>    <span class="hljs-type">unsigned</span>    securebits;    <span class="hljs-comment">/* SUID-less security management */</span><br>    <span class="hljs-type">kernel_cap_t</span>    cap_inheritable; <span class="hljs-comment">/* caps our children can inherit */</span><br>    <span class="hljs-type">kernel_cap_t</span>    cap_permitted;    <span class="hljs-comment">/* caps we&#x27;re permitted */</span><br>    <span class="hljs-type">kernel_cap_t</span>    cap_effective;    <span class="hljs-comment">/* caps we can actually use */</span><br>    <span class="hljs-type">kernel_cap_t</span>    cap_bset;    <span class="hljs-comment">/* capability bounding set */</span><br>    <span class="hljs-type">kernel_cap_t</span>    cap_ambient;    <span class="hljs-comment">/* Ambient capability set */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_KEYS</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>    jit_keyring;    <span class="hljs-comment">/* default keyring to attach requested</span><br><span class="hljs-comment">                     * keys to */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">key</span>    *<span class="hljs-title">session_keyring</span>;</span> <span class="hljs-comment">/* keyring inherited over fork */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">key</span>    *<span class="hljs-title">process_keyring</span>;</span> <span class="hljs-comment">/* keyring private to this process */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">key</span>    *<span class="hljs-title">thread_keyring</span>;</span> <span class="hljs-comment">/* keyring private to this thread */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">key</span>    *<span class="hljs-title">request_key_auth</span>;</span> <span class="hljs-comment">/* assumed request_key authority */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SECURITY</span><br>    <span class="hljs-type">void</span>        *security;    <span class="hljs-comment">/* subjective LSM security */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">user_struct</span> *<span class="hljs-title">user</span>;</span>    <span class="hljs-comment">/* real user ID subscription */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">user_namespace</span> *<span class="hljs-title">user_ns</span>;</span> <span class="hljs-comment">/* user_ns the caps and keyrings are relative to. */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">group_info</span> *<span class="hljs-title">group_info</span>;</span>    <span class="hljs-comment">/* supplementary groups for euid/fsgid */</span><br>    <span class="hljs-comment">/* RCU deletion */</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        <span class="hljs-type">int</span> non_rcu;            <span class="hljs-comment">/* Can we skip RCU deletion? */</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rcu_head</span>    <span class="hljs-title">rcu</span>;</span>        <span class="hljs-comment">/* RCU deletion hook */</span><br>    &#125;;<br>&#125; __randomize_layout;<br></code></pre></td></tr></table></figure>

<p>我们主要关注<code>cred</code>结构体中管理权限的变量</p>
<h3 id="用户ID-组ID"><a href="#用户ID-组ID" class="headerlink" title="用户ID &amp; 组ID"></a>用户ID &amp; 组ID</h3><p>一个cred结构体中记载了<strong>一个进程四种不同的用户ID</strong>：</p>
<ul>
<li><strong>真实用户ID</strong>（real UID）：标识一个进程<strong>启动时的用户ID</strong></li>
<li><strong>保存用户ID</strong>（saved UID）：标识一个进程<strong>最初的有效用户ID</strong></li>
<li><strong>有效用户ID</strong>（effective UID）：标识一个进程<strong>正在运行时所属的用户ID</strong>，一个进程在运行途中是可以改变自己所属用户的，因而权限机制也是通过有效用户ID进行认证的，内核通过 euid 来进行特权判断；为了防止用户一直使用高权限，当任务完成之后，euid 会与 suid 进行交换，恢复进程的有效权限</li>
<li><strong>文件系统用户ID</strong>（UID for VFS ops）：标识一个进程<strong>创建文件时进行标识的用户ID</strong></li>
</ul>
<p>在通常情况下这几个ID应当都是相同的</p>
<p>用户组ID同样分为四个：<code>真实组ID</code>、<code>保存组ID</code>、<code>有效组ID</code>、<code>文件系统组ID</code>，与用户ID是类似的，这里便不再赘叙</p>
<h2 id="二、进程权限改变"><a href="#二、进程权限改变" class="headerlink" title="二、进程权限改变"></a>二、进程权限改变</h2><p>前面我们讲到，一个进程的权限是由位于内核空间的 <code>cred</code> 结构体进行管理的，那么我们不难想到：只要改变一个进程的 <code>cred</code> 结构体，就能改变其执行权限</p>
<p>在内核空间有如下两个函数，都位于 <code>kernel/cred.c</code> 中：</p>
<ul>
<li><code>struct cred* prepare_kernel_cred(struct task_struct* daemon)</code>：该函数用以拷贝一个进程的cred结构体，并返回一个新的cred结构体，需要注意的是<code>daemon</code>参数应为<strong>有效的进程描述符地址</strong></li>
<li><code>int commit_creds(struct cred *new)</code>：该函数用以将一个新的<code>cred</code>结构体应用到进程</li>
</ul>
<h1 id="0x05-I-O"><a href="#0x05-I-O" class="headerlink" title="0x05.I&#x2F;O"></a>0x05.I&#x2F;O</h1><p>*NIX&#x2F;Linux追求高层次抽象上的统一，其设计哲学之一便是<code>万物皆文件</code></p>
<h2 id="一、“万物皆文件”"><a href="#一、“万物皆文件”" class="headerlink" title="一、“万物皆文件”"></a>一、“万物皆文件”</h2><p><em>NIX&#x2F;Linux设计的哲学之一——<code>万物皆文件</code>，在Linux系统的视角下，无论是文件、设备、管道，还是目录、进程，甚至是磁盘、套接字等等，*<em>一切都可以被抽象为文件，一切都可以使用访问文件的方式进行操作</em></em></p>
<p>通过这样一种哲学，Linux予开发者以高层次抽象的统一性，提供了<code>操作的一致性</code>：</p>
<ul>
<li><strong>所有的读取操作都可以通过对文件进行 read 系统调用完成</strong></li>
<li><strong>所有的更改操作都可以通过对文件进行 write 系统调用完成</strong></li>
<li><strong>所有的配置操作都可以通过对文件进行 ioctl 系统调用完成</strong></li>
</ul>
<p>对于开发者而言，将一切的操作都统一于一个高层次抽象的应用接口，无疑是十分美妙的一件事情——<strong>我们不需要去理解实现的细节，只需要对”文件”完成简单的读写操作</strong></p>
<blockquote>
<p>例如，在较老版本的Linux中，可以使用<code>cat /dev/urandom &gt; /dev/dsp</code>命令令扬声器产生随机噪声</p>
</blockquote>
<p><img src="https://i.loli.net/2021/02/25/iUoHNsaK5vOG9cR.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h2 id="二、进程文件系统"><a href="#二、进程文件系统" class="headerlink" title="二、进程文件系统"></a>二、进程文件系统</h2><p>进程文件系统（process file system， 简写为procfs）用以描述一个进程，其中包括该进程所打开的文件描述符、堆栈内存布局、环境变量等等</p>
<p>进程文件系统本身是一个伪文件系统，通常被挂载到<code>/proc</code>目录下，并不真正占用储存空间，而是占用一定的内存</p>
<p>当一个进程被建立起来时，其进程文件系统便会被挂载到<code>/proc/[PID]</code>下，我们可以在该目录下查看其相关信息</p>
<h2 id="三、文件描述符"><a href="#三、文件描述符" class="headerlink" title="三、文件描述符"></a>三、文件描述符</h2><p>进程通过<strong>文件描述符</strong>（<strong>file descriptor</strong>）来完成对文件的访问，其在形式上是一个非负整数，本质上是对文件的索引值，进程所有执行 I&#x2F;O 操作的系统调用都会通过文件描述符 </p>
<p>每个进程都<strong>独立有着一个文件描述符表</strong>，存放着该进程所打开的文件索引，每当进程<strong>成功</strong>打开一个现有文件&#x2F;创建一个新文件时（通过系统调用open进行操作），<strong>内核会向进程返回一个文件描述符</strong></p>
<p>在kernel中有着一个文件表，由所有的进程共享</p>
<h3 id="stdin、stdout、stderr"><a href="#stdin、stdout、stderr" class="headerlink" title="stdin、stdout、stderr"></a>stdin、stdout、stderr</h3><p>每个*NIX进程都应当有着三个标准的POSIX文件描述符，对应着三个标准文件流：</p>
<ul>
<li><code>stdin：标准输入 - 0</code></li>
<li><code>stdout：标准输出 - 1</code></li>
<li><code>stderr：标准错误 - 2</code></li>
</ul>
<p>此后打开的文件描述符应当从标号<code>3</code>起始</p>
<h2 id="四、系统调用：ioctl"><a href="#四、系统调用：ioctl" class="headerlink" title="四、系统调用：ioctl"></a>四、系统调用：ioctl</h2><p>在*NIX中一切都可以被视为文件，因而一切都可以以访问文件的方式进行操作，为了方便，Linux定义了系统调用<code>ioctl</code>供进程与设备之间进行通信</p>
<p>系统调用<code>ioctl</code>是一个专用于设备输入输出操作的一个系统调用，其调用方式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">ioctl</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> request, ...)</span><br></code></pre></td></tr></table></figure>

<ul>
<li><strong>fd：设备的文件描述符</strong></li>
<li><strong>request：请求码</strong></li>
<li><strong>其他参数</strong></li>
</ul>
<p>对于一个提供了ioctl通信方式的设备而言，我们可以通过其文件描述符、使用不同的请求码及其他请求参数通过ioctl系统调用完成不同的对设备的I&#x2F;O操作</p>
<blockquote>
<p>例如CD-ROM驱动程序弹出光驱的这一操作就对应着对“光驱设备”这一文件通过ioctl传递特定的请求码与请求参数完成</p>
</blockquote>
<h1 id="0x06-Loadable-Kernel-Modules（LKMs）"><a href="#0x06-Loadable-Kernel-Modules（LKMs）" class="headerlink" title="0x06.Loadable Kernel Modules（LKMs）"></a>0x06.Loadable Kernel Modules（LKMs）</h1><p>前面我们讲到，Linux Kernle采用的是宏内核架构，一切的系统服务都需要由内核来提供，虽然效率较高，但是缺乏可扩展性与可维护性，同时内核需要装载很多可能用到的服务，但这些服务最终可能未必会用到，还会占据大量内存空间，同时新服务的提供往往意味着要重新编译整个内核</p>
<p>综合以上考虑，<strong>可装载内核模块</strong>（<strong>Loadable Kernel Modules</strong>，简称<strong>LKMs</strong>）出现了，位于内核空间的LKMs可以提供<strong>新的系统调用</strong>或其他服务，同时LKMs可以像积木一样被装载入内核&#x2F;从内核中卸载，大大提高了kernel的可拓展性与可维护性</p>
<blockquote>
<p>常见的外设驱动便是LKM的一种</p>
</blockquote>
<p>LKMs与用户态可执行文件一样都采用ELF格式，但是<strong>LKMs运行在内核空间，且无法脱离内核运行</strong></p>
<p>通常与LKM相关的命令有以下三个：</p>
<ul>
<li><code>lsmod</code>：列出现有的LKMs</li>
<li><code>insmod</code>：装载新的LKM（需要root）</li>
<li><code>rmmod</code>：从内核中移除LKM（需要root）</li>
</ul>
<blockquote>
<p>CTF 比赛中的 kernel pwn 的漏洞往往出现在第三方 LKM 中，<del>一般来说不会真的让你去直接日内核组件</del></p>
</blockquote>
<h1 id="0x07-内核内存结构-管理"><a href="#0x07-内核内存结构-管理" class="headerlink" title="0x07.内核内存结构 &amp; 管理"></a>0x07.内核内存结构 &amp; 管理</h1><p>Linux kernel 将内存分为 <code>页→区→节点</code> 三级结构，主要有两个内存管理器—— <code>buddy system</code> 与 <code>slab allocator</code></p>
<h2 id="一、-页→区→节点三级结构"><a href="#一、-页→区→节点三级结构" class="headerlink" title="一、 页→区→节点三级结构"></a>一、 页→区→节点三级结构</h2><p>这是一张十分经典的 _Overview_，自顶向下是</p>
<ul>
<li><strong>节点</strong>（node，对应结构体 pgdata_list）</li>
<li><strong>区</strong>（zone，对应结构体 zone，图上展示了三种类型的 zone）</li>
<li><strong>页</strong>（page，对应结构体 page）</li>
</ul>
<p><img src="https://i.loli.net/2021/11/28/OrsvS6GTMgPLx5E.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h3 id="I-页（page）"><a href="#I-页（page）" class="headerlink" title="I.页（page）"></a>I.页（page）</h3><p>Linux kernel 中使用 <code>page</code> 结构体来表示一个物理页框，<strong>每个物理页框都有着一个对应的 page 结构体</strong></p>
<p><img src="https://i.loli.net/2021/11/25/MjWZmba9SLH1xIO.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h3 id="II-区（zone）"><a href="#II-区（zone）" class="headerlink" title="II.区（zone）"></a>II.区（zone）</h3><p>在 Linux 下将一个节点内不同用途的内存区域划分为不同的 <code>区（zone）</code>，对应结构体 <code>struct zone</code></p>
<p><img src="https://i.loli.net/2021/11/30/sOwdI5YMNUjLSib.png" srcset="/img/loading.gif" lazyload alt="自己画的图.png"></p>
<h3 id="III-节点（node）"><a href="#III-节点（node）" class="headerlink" title="III.节点（node）"></a>III.节点（node）</h3><p>zone 再向上一层便是<strong>节点</strong>——Linux 将_内存控制器（memory controller）_作为节点划分的依据，对于 UMA 架构而言只有一个节点，而对于 NUMA 架构而言通常有多个节点，对于同一个内存控制器下的 CPU 而言其对应的节点称之为_本地内存_，不同处理器之间通过总线进行进一步的连接。如下图所示，一个 MC 对应一个节点：</p>
<p><img src="https://i.loli.net/2021/11/27/hAopSNYg23VeWzq.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h2 id="二、内存模型"><a href="#二、内存模型" class="headerlink" title="二、内存模型"></a>二、内存模型</h2><p>Linux 提供了三种内存模型，定义于 <code>include/asm-generic/memory_model.h</code> 中，如下图所示（偷的图，侵删）：</p>
<p><img src="https://i.loli.net/2021/11/25/wLzFuCB5n1DAIY7.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>内存模型在编译期就会被确定下来，目前常用的是 <code>Sparse Memory</code> 模型，即离散内存模型</p>
<h3 id="Flat-Memory"><a href="#Flat-Memory" class="headerlink" title="Flat Memory"></a>Flat Memory</h3><p>平滑内存模型。物理内存地址连续，有一个<strong>全局变量</strong> <code>mem_map</code> ——由一个大的 struct page 数组直接对应现有的物理内存</p>
<h3 id="Discontiguous-Memory"><a href="#Discontiguous-Memory" class="headerlink" title="Discontiguous Memory"></a>Discontiguous Memory</h3><p>非连续性内存模型。主要针对内存中存在空洞的情况。</p>
<p>对于每一段连续的物理内存，都有一个 <code>pglist_data</code> 结构体进行对应，其成员 <code>node_mem_map</code> 为一个 struct page 指针，指向一个 page 结构体数组，由该结构体对应到该段连续物理内存</p>
<p>有一个<strong>全局变量</strong> <code>node_data</code> 为一个 pglist_data 指针数组，其中存放着指向每一个 pglist_data 的指针，该数组的大小为 <code>MAX_NUMNODES</code></p>
<h3 id="Sparse-Memory"><a href="#Sparse-Memory" class="headerlink" title="Sparse Memory"></a>Sparse Memory</h3><p>离散内存模型。在一个 mem_section 结构体中存在一个 <code>section_mem_map</code> 成员指向一个 struct page 数组对应一段连续的物理内存，即将内存按照 section 为单位进行分段</p>
<p>存在一个全局指针数组 <code>mem_section</code> （与结构体同名）存放所有的 <code>mem_section</code> 指针，指向<strong>理论上支持的内存空间</strong>，每个 section 对应的物理内存不一定存在，若不存在则此时该 section 的指针为 NULL</p>
<p>这种模型<strong>支持内存的热拔插</strong></p>
<blockquote>
<p>图还是偷的，侵删</p>
</blockquote>
<p><img src="https://i.loli.net/2021/11/25/RN47OEoaM31xQhA.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h2 id="三、buddy-system"><a href="#三、buddy-system" class="headerlink" title="三、buddy system"></a>三、buddy system</h2><blockquote>
<p>目前的 CTF 题目当中还没有出现针对 buddy system 进行利用的题目，但是<a target="_blank" rel="noopener" href="https://etenal.me/archives/1825">有安全研究员在 CVE-2022-27666 中运用了页级堆风水的技巧</a>，笔者认为非常 nb</p>
</blockquote>
<p>buddy system 是 Linux kernel 中的一个较为底层的内存管理系统，<strong>以内存页为粒度管理者所有的物理内存</strong>，其存在于 <strong>区</strong> 这一级别，对当前区所对应拥有的所有物理页框进行管理</p>
<p>在每个 zone 结构体中都有一个 free_area 结构体数组，用以存储 buddy system <strong>按照 order 管理的页面</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zone</span> &#123;</span><br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">free_area</span>	<span class="hljs-title">free_area</span>[<span class="hljs-title">MAX_ORDER</span>];</span><br>    <span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure>

<p>其中的 <code>MAX_ORDER</code> 为一个常量，值为 11</p>
<p>在 buddy system 中按照空闲页面的连续大小进行分阶管理，这里的 order 的实际含义为<strong>连续的空闲页面的大小</strong>，不过单位不是页面数，而是<code>阶</code>，即对于每个下标而言，其中所存储的页面大小为：<br>$$<br>2^{order}<br>$$<br>在 free_area 中存放的页面通过自身的相应字段连接成双向链表结构，由此我们得到这样一张_Overview_：</p>
<p><img src="https://i.loli.net/2021/11/30/sOwdI5YMNUjLSib.png" srcset="/img/loading.gif" lazyload alt="自己画的图.png"></p>
<ul>
<li>分配：<ul>
<li>首先会将请求的内存大小向 2 的幂次方张内存页大小对齐，之后从对应的下标取出连续内存页</li>
<li>若对应下标链表为空，则会从下一个 order 中取出内存页，一分为二，装载到当前下标对应链表中，之后再返还给上层调用，若下一个 order 也为空则会继续向更高的 order 进行该请求过程</li>
</ul>
</li>
<li>释放：<ul>
<li>将对应的连续内存页释放到对应的链表上</li>
<li>检索是否有可以合并的内存页，若有，则进行合成，放入更高 order 的链表中</li>
</ul>
</li>
</ul>
<p>但是我们很容易产生不容易合并的内存碎片，因此 Linux kernel 还会进行 <em>内存迁移</em> 以减少内存碎片，原理如下图，主要由一个持续运行的内核线程完成，由于不是本篇重点故不在此赘叙</p>
<p><img src="https://i.loli.net/2021/11/30/q7T6EjtIb9PVFY3.png" srcset="/img/loading.gif" lazyload alt="从知乎偷的图.png"></p>
<h2 id="四、slab-allocator"><a href="#四、slab-allocator" class="headerlink" title="四、slab allocator"></a>四、slab allocator</h2><p>slab allocator 则是更为细粒度的内存管理器，其通过向 buddy system 请求单张或多张连续内存页后再分割成同等大小的<strong>对象</strong>（object）返还给上层调用者来实现更为细粒度的内存管理</p>
<p>slab allocator 一共有三种版本：</p>
<ul>
<li>slab（最初的版本，机制比较复杂，效率不高）</li>
<li>slob（用于嵌入式等场景的极为简化版本）</li>
<li>slub（优化后的版本，现在的通用版本）</li>
</ul>
<h3 id="I-基本结构"><a href="#I-基本结构" class="headerlink" title="I.基本结构"></a>I.基本结构</h3><p> <code>slub</code> 版本的 allocator 为现在绝大多数 Linux kernel 所装配的版本，因此本篇文章主要叙述的也是 slub allocator，其基本结构如下图所示：</p>
<p><img src="https://i.loli.net/2021/07/22/ivPnbsjHyI94m5z.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<ul>
<li><p>我们将 slub allocator 每次向 buddy system 请求得来的单张&#x2F;多张内存页称之为一个 <code>slub</code>，其被分割为多个同等大小对象（object），每个 object 作为一个被分配实体，在 slub 的第一张内存页对应的 page 结构体上的 freelist 成员指向该张内存页上的第一个空闲对象，一个 slub 上的所有空闲对象组成一个以 NULL 结尾的单向链表</p>
<blockquote>
<p>一个 object 可以理解为用户态 glibc 中的 chunk，不过 object 并不像 chunk 那样需要有一个 header，因为 page 结构体与物理内存间存在线性对应关系，我们可以直接通过 object 地址找到其对应的 page 结构体</p>
</blockquote>
</li>
<li><p><code>kmem_cache</code> 为一个基本的 allocator 组件，其用于分配某个特定大小（某种特定用途）的对象，所有的 kmem_cache 构成一个双向链表，并存在两个对应的结构体数组 <code>kmalloc_caches</code> 与 <code>kmalloc_dma_caches</code></p>
</li>
<li><p>一个 <code>kmem_cache</code> 主要由两个模块组成：</p>
<ul>
<li><code>kmem_cache_cpu</code>：这是一个<strong>percpu 变量</strong>（即每个核心上都独立保留有一个副本，原理是以 gs 寄存器作为 percpu 段的基址进行寻址），用以表示当前核心正在使用的 slub，因此当前 CPU 在从 kmem_cache_cpu 上取 object 时<strong>不需要加锁</strong>，从而极大地提高了性能</li>
<li><code>kmem_cache_node</code>：可以理解为当前 <code>kmem_cache</code> 的 slub 集散中心，其中存放着两个 slub 链表：<ul>
<li>partial：该 slub 上存在着一定数量的空闲 object，但并非全部空闲</li>
<li>full：该 slub 上的所有 object 都被分配出去了</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="II-分配-释放过程"><a href="#II-分配-释放过程" class="headerlink" title="II.分配&#x2F;释放过程"></a>II.分配&#x2F;释放过程</h3><p>那么现在我们可以来说明 slub allocator 的分配&#x2F;释放行为了</p>
<ul>
<li>分配：<ul>
<li>首先从 <code>kmem_cache_cpu</code> 上取对象，若有则直接返回</li>
<li>若 <code>kmem_cache_cpu</code> 上的 slub 已经无空闲对象了，对应 slub 会被加入到 <code>kmem_cache_node</code> 的 <strong>full</strong> 链表，并尝试从 <strong>partial</strong> 链表上取一个 slub 挂载到 <code>kmem_cache_cpu</code> 上，然后再取出空闲对象返回</li>
<li>若 <code>kmem_cache_node</code> 的 partial 链表也空了，那就<strong>向 buddy system 请求分配新的内存页</strong>，划分为多个 object 之后再给到 <code>kmem_cache_cpu</code>，取空闲对象返回上层调用</li>
</ul>
</li>
<li>释放：<ul>
<li>若被释放 object 属于  <code>kmem_cache_cpu</code> 的 slub，直接使用头插法插入当前 CPU slub 的 freelist</li>
<li>若被释放 object 属于 <code>kmem_cache_node</code> 的 partial 链表上的 slub，直接使用头插法插入对应 slub 的 freelist</li>
<li>若被释放 object 属于 <code>kmem_cache_node</code> 的 full 链表上的 slub，则其会成为对应 slub 的 freelist 头节点，<strong>且该 slub 会从 full 链表迁移到 partial 链表</strong></li>
</ul>
</li>
</ul>
<p>以上便是 slub allocator 的基本原理</p>
<h3 id="III-slab-alias（mergeability）"><a href="#III-slab-alias（mergeability）" class="headerlink" title="III. slab alias（mergeability）"></a>III. slab alias（mergeability）</h3><p>slab alias 机制是一种对同等&#x2F;相近大小 object 的 <code>kmem_cache</code> 进行<strong>复用</strong>的一种机制：</p>
<ul>
<li>当一个 <code>kmem_cache</code> 在创建时，若已经存在能分配相等&#x2F;近似大小的 object 的 <code>kmem_cache</code> ，则<strong>不会创建新的 kmem_cache，而是为原有的 kmem_cache 起一个 alias，作为“新的” kmem_cache 返回</strong></li>
</ul>
<p>举个🌰，<code>cred_jar</code> 是专门用以分配 <code>cred</code> 结构体的 <code>kmem_cache</code>，在 Linux 4.4 之前的版本中，其为 <code>kmalloc-192</code> 的 alias，即 cred 结构体与其他的 192 大小的 object 都会从同一个 <code>kmem_cache</code>——<code>kmalloc-192</code> 中分配</p>
<p>对于初始化时设置了 <code>SLAB_ACCOUNT</code> 这一 flag 的 <code>kmem_cache</code> 而言，则会新建一个新的 <code>kmem_cache</code> 而非为原有的建立 alias，🌰如在新版的内核当中 <code>cred_jar</code> 与 <code>kmalloc-192</code> 便是两个独立的 <code>kmem_cache</code>，<strong>彼此之间互不干扰</strong></p>
<h1 id="0x08-保护机制"><a href="#0x08-保护机制" class="headerlink" title="0x08.保护机制"></a>0x08.保护机制</h1><p>与一般的程序相同，Linux Kernel同样有着各种各样的保护机制：</p>
<h2 id="一、通用保护机制"><a href="#一、通用保护机制" class="headerlink" title="一、通用保护机制"></a>一、通用保护机制</h2><h4 id="KASLR"><a href="#KASLR" class="headerlink" title="KASLR"></a>KASLR</h4><p>KASLR即<code>内核空间地址随机化</code>（kernel address space layout randomize），与用户态程序的ASLR相类似——在内核镜像映射到实际的地址空间时加上一个偏移值，但是内核内部的相对偏移其实还是不变的</p>
<p>在未开启KASLR保护机制时，内核代码段的基址为 <code>0xffffffff81000000</code> ，direct mapping area 的基址为 <code>0xffff888000000000</code></p>
<p>内核内存布局可以参考<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/latest/source/Documentation/x86/x86_64/mm.rst">这↑里↓</a></p>
<h4 id="FGKASLR"><a href="#FGKASLR" class="headerlink" title="*FGKASLR"></a><em>*FGKASLR</em></h4><p>KASLR 虽然在一定程度上能够缓解攻击，但是若是攻击者通过一些信息泄露漏洞获取到内核中的某个地址，仍能够直接得知内核加载地址偏移从而得知整个内核地址布局，因此有研究者基于 KASLR 实现了 FGKASLR，<strong>以函数粒度重新排布内核代码</strong></p>
<h4 id="STACK-PROTECTOR"><a href="#STACK-PROTECTOR" class="headerlink" title="STACK PROTECTOR"></a>STACK PROTECTOR</h4><p>类似于用户态程序的 canary，通常又被称作是 stack cookie，用以检测<strong>是否发生内核堆栈溢出</strong>，若是发生内核堆栈溢出则会产生 kernel panic</p>
<p>内核中的 canary 的值通常取自 gs 段寄存器某个固定偏移处的值</p>
<h4 id="SMAP-SMEP"><a href="#SMAP-SMEP" class="headerlink" title="SMAP&#x2F;SMEP"></a>SMAP&#x2F;SMEP</h4><p>SMAP即<code>管理模式访问保护</code>（Supervisor Mode Access Prevention），SMEP即<code>管理模式执行保护</code>（Supervisor Mode Execution Prevention），这两种保护通常是同时开启的，用以阻止<strong>内核空间直接访问&#x2F;执行用户空间的数据</strong>，完全地将内核空间与用户空间相分隔开，用以防范ret2usr（return-to-user，将内核空间的指令指针重定向至用户空间上构造好的提权代码）攻击</p>
<p>SMEP保护的绕过有以下两种方式：</p>
<ul>
<li>利用内核线性映射区对物理地址空间的完整映射，找到用户空间对应页框的内核空间地址，利用该内核地址完成对用户空间的访问（即一个内核空间地址与一个用户空间地址映射到了同一个页框上），这种攻击手法称为 ret2dir</li>
<li>Intel下系统根据CR4控制寄存器的第20位标识是否开启SMEP保护（1为开启，0为关闭），若是能够通过kernel ROP改变CR4寄存器的值便能够关闭SMEP保护，完成SMEP-bypass，接下来就能够重新进行 ret2usr，<strong>但对于开启了 KPTI 的内核而言，内核页表的用户地址空间无执行权限，这使得 ret2usr 彻底成为过去式</strong></li>
</ul>
<p><img src="https://i.loli.net/2021/09/07/sYFKuZiUVNIclBp.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<blockquote>
<p> 在 ARM 下有一种类似的保护叫 <code>PXN</code></p>
</blockquote>
<h4 id="KPTI"><a href="#KPTI" class="headerlink" title="KPTI"></a><a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/latest/x86/pti.html">KPTI</a></h4><p>KPTI即<code>内核页表隔离</code>（Kernel page-table isolation），内核空间与用户空间分别使用两组不同的页表集，这对于内核的内存管理产生了根本性的变化</p>
<p>需要进行说明的是，<strong>在这两张页表上都有着对用户内存空间的完整映射，但在用户页表中只映射了少量的内核代码（例如系统调用入口点、中断处理等），而只有在内核页表中才有着对内核内存空间的完整映射，但两张页表都有着对用户内存空间的完整映射</strong>，如下图所示，左侧是未开启 KPTI 后的页表布局，右侧是开启了 KPTI 后的页表布局</p>
<blockquote>
<p>在 64 位下用户空间与内核空间都占 128 TB，所以他们占用的页全局表项（PGD）的大小应当是相同的，图上没有体现出来，因此这里由笔者代为补充（笑）</p>
</blockquote>
<p><img src="https://s2.loli.net/2022/03/11/q74X6lbTnrNGhC1.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>KPTI 的发明主要是用来修复一个史诗级别的 CPU 硬件漏洞：Meltdown。简单理解就是利用 CPU 流水线设计中（乱序执行与预测执行）的漏洞来获取到用户态无法访问的内核空间的数据，属于侧信道攻击的一种</p>
<blockquote>
<p>简单理解：你的第一条指令是合法内存访问，第二条指令是越权内存访问，CPU会在执行第一条正常指令的过程中<strong>也会执行第二条非法指令</strong>，之后再做权限判定，若是非法访问则消除该影响，这样的流水线设计虽然有着较高的性能，<strong>但是越权访问仍会留下痕迹</strong>，这给了攻击者非法获取内核空间数据的可能</p>
</blockquote>
<p>若是整个流水线设计直接扔掉那自然是捡了芝麻丢了西瓜，因此 KPTI 被快速应用到主流操作系统上（这个设计在漏洞出来之前就有，但未得到广泛应用），尽管仍旧造成了一定的性能损耗，但却有效地从软件层面修复了 Meltdown 漏洞</p>
<p><strong>KPTI 同时还令内核页表中属于用户地址空间的部分不再拥有执行权限，这使得 ret2usr 彻底成为过去式</strong></p>
<h2 id="二、内核“堆”上保护机制"><a href="#二、内核“堆”上保护机制" class="headerlink" title="二、内核“堆”上保护机制"></a>二、内核“堆”上保护机制</h2><blockquote>
<p>more info 可以参考<a target="_blank" rel="noopener" href="https://duasynt.com/blog/linux-kernel-heap-feng-shui-2022">这里</a></p>
</blockquote>
<h4 id="Hardened-Usercopy"><a href="#Hardened-Usercopy" class="headerlink" title="Hardened Usercopy"></a>Hardened Usercopy</h4><p>hardened usercopy 是用以在用户空间与内核空间之间拷贝数据时进行越界检查的一种防护机制，<strong>主要检查拷贝过程中对内核空间中数据的读写是否会越界</strong>：</p>
<ul>
<li>读取的数据长度是否超出源 object 范围</li>
<li>写入的数据长度是否超出目的 object 范围</li>
</ul>
<p>不过这种保护 <em>不适用于内核空间内的数据拷贝</em> ，这也是目前主流的绕过手段</p>
<p>这一保护被用于 <code>copy_to_user()</code> 与 <code>copy_from_user()</code> 等数据交换 API 中</p>
<h4 id="Hardened-freelist"><a href="#Hardened-freelist" class="headerlink" title="Hardened freelist"></a>Hardened freelist</h4><p>类似于 glibc 2.32 版本引入的保护，在开启这种保护之前，slub 中的 free object 的 next 指针直接存放着 next free object 的地址，攻击者可以通过读取 freelist 泄露出内核线性映射区的地址，在开启了该保护之后 free object 的 next 指针存放的是由以下三个值进行异或操作后的值：</p>
<ul>
<li>当前 free object 的地址</li>
<li>下一个 free object 的地址</li>
<li>由 kmem_cache 指定的一个 random 值</li>
</ul>
<p>攻击者至少需要获取到第一与第三个值才能篡改 freelist，这无疑为对 freelist 的直接利用增添不少难度</p>
<blockquote>
<p>在更新版本的 Linux kernel 中似乎还引入了一个偏移值，笔者尚未进行考证</p>
</blockquote>
<h4 id="Random-freelist"><a href="#Random-freelist" class="headerlink" title="Random freelist"></a>Random freelist</h4><p>这种保护主要发生在 slub allocator 向 buddy system 申请到页框之后的处理过程中，对于未开启这种保护的一张完整的 slub，其上的 object 的连接顺序是线性连续的，但在开启了这种保护之后其上的 object 之间的连接顺序是随机的，这让攻击者无法直接预测下一个分配的 object 的地址</p>
<p>需要注意的是这种保护发生在<strong>slub allocator 刚从 buddy system 拿到新 slub 的时候，运行时 freelist 的构成仍遵循 LIFO</strong></p>
<p><img src="https://s2.loli.net/2022/03/11/wQzINfhXV3gpGxJ.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h4 id="CONFIG-INIT-ON-ALLOC-DEFAULT-ON"><a href="#CONFIG-INIT-ON-ALLOC-DEFAULT-ON" class="headerlink" title="CONFIG_INIT_ON_ALLOC_DEFAULT_ON"></a>CONFIG_INIT_ON_ALLOC_DEFAULT_ON</h4><p>当编译内核时开启了这个选项时，在内核进行“堆内存”分配时（包括 buddy system 和 slab allocator），<strong>会将被分配的内存上的内容进行清零</strong>，从而防止了利用未初始化内存进行数据泄露的情况</p>
<p>据悉性能损耗在 <code>1%~7%</code> 之间</p>
<h1 id="0xFF-Reference"><a href="#0xFF-Reference" class="headerlink" title="0xFF. Reference"></a>0xFF. Reference</h1><p>《Linux Kernel Development》Robert Love 著</p>
<p><a target="_blank" rel="noopener" href="https://docs.kernel.org/">The Linux Kernel Documentation</a></p>
<p>《linux技术内幕》罗秋明 著</p>
<p>《Operating System Concepts》 Abraham Silberschatz, Greg Gagne, and Peter Baer Galvin 著</p>
<p><a target="_blank" rel="noopener" href="https://richardweiyang-2.gitbook.io/kernel-exploring/">Kernel Exploring</a></p>
<p><a target="_blank" rel="noopener" href="https://linux-kernel-labs.github.io/refs/heads/master/">Linux Kernel Teaching</a></p>
<p><a target="_blank" rel="noopener" href="http://www.wowotech.net/memory_management/memory_model.html">Linux 内存模型</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/LoyenWang/">LoyenWang - 博客园</a></p>
<p><a target="_blank" rel="noopener" href="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html">Intel® 64 and IA-32 Architectures Software Developer Manuals</a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/OS/" class="category-chain-item">OS</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Linux/">#Linux</a>
      
        <a href="/tags/Linux-Kernel/">#Linux Kernel</a>
      
        <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">#操作系统</a>
      
        <a href="/tags/Pwn/">#Pwn</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>【OS.0x00】Linux Kernel I：Basic Knowledge</div>
      <div>https://arttnba3.github.io/2021/02/21/OS-0X00-LINUX-KERNEL-PART-I/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>arttnba3</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2021年2月21日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/02/21/OS-0X01-LINUX-KERNEL-PART-II/" title="【OS.0x01】Linux Kernel II：内核简易食用指北">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">【OS.0x01】Linux Kernel II：内核简易食用指北</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/02/11/CTF-0X03-PWNABLE.TW/" title="【CTF.0x03】Pwnable.tw WP by arttnba3">
                        <span class="hidden-mobile">【CTF.0x03】Pwnable.tw WP by arttnba3</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.4.17/Valine.min.js', function() {
        var options = Object.assign(
          {"appid":"ICj6cPRQWFTNiOttBHlzxnIv-gzGzoHsz","appkey":"tuvJh3xYxPFcW2JB6K26RKP2","path":"window.location.pathname","placeholder":"说点什么呗（笑）","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false,"appId":"ICj6cPRQWFTNiOttBHlzxnIv-gzGzoHsz","appKey":"tuvJh3xYxPFcW2JB6K26RKP2"},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  <!-- 网站运行时间的设置 -->
  <span id="timeDate">载入天数...</span>
  <span id="times">载入时分秒...</span>
  <script>
      var now = new Date();
      function createtime() {
          var grt= new Date("04/20/2020 17:48:48");//此处修改你的建站时间或者网站上线时间
          now.setTime(now.getTime()+250);
          days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
          hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
          if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
          mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
          seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
          snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
          document.getElementById("timeDate").innerHTML = "arttnba3的小屋已经安全存在了 "+dnum+" 天 ";
          document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
      }
  setInterval("createtime()",250);
  </script>
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
    <!-- 备案信息 ICP for China -->
    <div class="beian">
  <span>
    <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
      桂ICP备2022005068号-1
    </a>
  </span>
  
</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.1/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
