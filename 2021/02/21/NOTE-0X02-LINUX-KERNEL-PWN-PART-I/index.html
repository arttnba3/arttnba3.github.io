<!DOCTYPE html>
<html lang="zh-CN" color-mode="light">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="keywords" content="" />
  <meta name="author" content="arttnba3" />
  <meta name="description" content="あがいた夢を捨てて揺れる今日は眠って誤魔化せ" />
  
  
  <title>
    
      【NOTES.0x02】Linux Kernel Pwn I：一切开始之前 
      
      
      |
    
     arttnba3&#39;s blog
  </title>

  
    <link rel="apple-touch-icon" href="/img/favicon.png">
    <link rel="icon" href="/img/favicon.png">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  
<link rel="stylesheet" href="/css/color-scheme.css">
<link rel="stylesheet" href="/css/base.css">
<link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css">
<link rel="stylesheet" href="/css/github-markdown.css">
<link rel="stylesheet" href="/css/highlight.css">
<link rel="stylesheet" href="/css/comments.css">

  <!-- 代码块风格 -->
  

  <!-- jquery3.3.1 -->
  
    <script defer type="text/javascript" src="/plugins/jquery.min.js"></script>
  

  <!-- fancybox -->
  
    <link href="/plugins/jquery.fancybox.min.css" rel="stylesheet">
    <script defer type="text/javascript" src="/plugins/jquery.fancybox.min.js"></script>
  
  
<script src="/js/fancybox.js"></script>


  

  <script>
    var html = document.documentElement
    const colorMode = localStorage.getItem('color-mode')
    if (colorMode) {
      document.documentElement.setAttribute('color-mode', colorMode)
    }
  </script>
<meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="arttnba3's blog" type="application/atom+xml">
</head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a target="_blank" rel="noopener" href="https://arttnba3.cn">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img src="/img/avatar.png" alt="">
      
    </a>
    <div class="nickname"><a target="_blank" rel="noopener" href="https://arttnba3.cn">arttnba3's blog</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">Home</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">Archives</a>
        </li>
      
        <li class="nav-item" data-path="/categories/">
          <a href="/categories/">Categories</a>
        </li>
      
        <li class="nav-item" data-path="/tags/">
          <a href="/tags/">Tags</a>
        </li>
      
        <li class="nav-item" data-path="/friends/">
          <a href="/friends/">Friends</a>
        </li>
      
        <li class="nav-item" data-path="/about/">
          <a href="/about/">About</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->


  <!-- LaTex Display -->

  
    <script async type="text/javascript" src="/plugins/mathjax/tex-chtml.js"></script>
  
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    }
  </script>





  <!-- clipboard -->

  
    <script async type="text/javascript" src="/plugins/clipboard.min.js"></script>
  
  
<script src="/js/codeCopy.js"></script>







  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">【NOTES.0x02】Linux Kernel Pwn I：一切开始之前</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime" title="更新时间"></i>
          2021-02-21 21:02:14
        </span>
        
              <span class="post-categories">
                <i class="iconfont icon-bookmark" title="分类"></i>
                
                <span class="span--category">
                  <a href="/categories/NOTES/" title="NOTES">
                    <b>#</b> NOTES
                  </a>
                </span>
                
              </span>
          
              <span class="post-tags">
                <i class="iconfont icon-tags" title="标签"></i>
                
                <span class="span--tag">
                  <a href="/tags/Pwn/" title="Pwn">
                    <b>#</b> Pwn
                  </a>
                </span>
                
                <span class="span--tag">
                  <a href="/tags/Linux/" title="Linux">
                    <b>#</b> Linux
                  </a>
                </span>
                
                <span class="span--tag">
                  <a href="/tags/%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0/" title="学习札记">
                    <b>#</b> 学习札记
                  </a>
                </span>
                
                <span class="span--tag">
                  <a href="/tags/Linux-Kernel/" title="Linux Kernel">
                    <b>#</b> Linux Kernel
                  </a>
                </span>
                
                <span class="span--tag">
                  <a href="/tags/Operating-System/" title="Operating System">
                    <b>#</b> Operating System
                  </a>
                </span>
                
              </span>
          
      </div>
      <div class="markdown-body">
        <p>Big Linus is watching you!</p>
<span id="more"></span>

<h1 id="0x00-Linux-Kernel-Basic-Knowledge"><a href="#0x00-Linux-Kernel-Basic-Knowledge" class="headerlink" title="0x00.Linux Kernel Basic Knowledge"></a>0x00.Linux Kernel Basic Knowledge</h1><h2 id="一、内核"><a href="#一、内核" class="headerlink" title="一、内核"></a>一、内核</h2><p><strong>操作系统</strong>（Operation System）本质上也是一种软件，可以看作是普通应用程式与硬件之间的一层中间层，其主要作用便是调度系统资源、控制IO设备、操作网络与文件系统等，并为上层应用提供便捷、抽象的应用接口</p>
<p>而运行在内核态的<strong>内核</strong>（<strong>kernel</strong>）则是<strong>一个操作系统最为核心的部分</strong>，提供着一个操作系统最为基础的功能</p>
<p>这张十分经典的图片说明了Kernel在计算机体系结构中的位置：</p>
<p><img src="https://i.loli.net/2021/02/22/eX5h7aRdOrCkb9j.png"></p>
<p>kernel的主要功能可以归为以下三点：</p>
<ul>
<li><strong>控制并与硬件进行交互</strong></li>
<li><strong>提供应用程式运行环境</strong></li>
<li><strong>调度系统资源</strong></li>
</ul>
<p>包括 I&#x2F;O，权限控制，系统调用，进程管理，内存管理等多项功能都可以归结到以上三点中</p>
<p>与一般的应用程式不同，kernel的crash通常会引起重启</p>
<h3 id="内核架构：微内核-amp-宏内核（单内核）"><a href="#内核架构：微内核-amp-宏内核（单内核）" class="headerlink" title="内核架构：微内核 &amp; 宏内核（单内核）"></a>内核架构：微内核 &amp; 宏内核（单内核）</h3><p>通常来说我们可以把内核架构分为两种：<code>宏内核</code>和<code>微内核</code>，大致架构如下图所示：</p>
<p><img src="https://i.loli.net/2021/02/22/eQlyv3DszOjXPuw.png" alt="image.png"></p>
<h4 id="宏内核（Monolithic-Kernel，又叫单内核）"><a href="#宏内核（Monolithic-Kernel，又叫单内核）" class="headerlink" title="宏内核（Monolithic Kernel，又叫单内核）"></a>宏内核（Monolithic Kernel，又叫单内核）</h4><blockquote>
<p> <strong>宏内核</strong>（英语：Monolithic kernel），也译为<strong>集成式内核</strong>、<strong>单体式内核</strong>，一种<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%86%85%E6%A0%B8">操作系统内核</a>架构，此架构的特性是整个内核程序是一个单一二进制可执行文件，在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%A0%B8%E5%BF%83%E7%A9%BA%E9%96%93">内核态</a>以监管者模式（Supervisor Mode）来运行。相对于其他类型的操作系统架构，如<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%BE%AE%E6%A0%B8%E5%BF%83">微内核</a>架构或<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%B7%B7%E6%A0%B8%E5%BF%83">混合内核</a>架构等，这些内核会定义出一个高端的虚拟接口，由该接口来涵盖描述整个电脑硬件，这些描述会集合成一组硬件描述用词，有时还会附加一些<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8">系统调用</a>，如此可以用一个或多个模块来实现各种操作系统服务，如<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B">进程</a>管理、并发（Concurrency）控制、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%A8%98%E6%86%B6%E9%AB%94%E7%AE%A1%E7%90%86">存储器管理</a>等。 </p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B4%E5%A1%8A%E6%80%A7%E6%A0%B8%E5%BF%83">Wikipedia: 整塊性核心</a></p>
<blockquote>
<p>台湾这什么鬼译名</p>
</blockquote>
</blockquote>
<p>通俗地说，宏内核几乎将一切都集成到了内核当中，并向上层应用程式提供抽象API（通常是以系统调用的形式）</p>
<p>Unix与类Unix便是宏内核</p>
<p><img src="https://i.loli.net/2021/02/22/fSwY9R4KHZLnkbl.png" alt="image.png"></p>
<h4 id="微内核（Micro-Kernel）"><a href="#微内核（Micro-Kernel）" class="headerlink" title="微内核（Micro Kernel）"></a>微内核（Micro Kernel）</h4><p>对于微内核而言，大部分的系统服务（如文件管理等）都被剥离于内核之外，内核仅仅提供最为基本的一些功能：底层的寻址空间管理、线程管理、进程间通信等</p>
<p>Windows NT与Mach都宣称采用了微内核架构，不过本质上他们更贴近于混合内核（Hybrid Kernel）——在内核中集成了部分需要具备特权的服务组件 </p>
<p><img src="https://i.loli.net/2021/02/22/eZY4WcMJytUNCuF.png" alt="image.png"></p>
<blockquote>
<p> 本文中我们主要讨论Linux内核</p>
</blockquote>
<h2 id="二、分级保护域"><a href="#二、分级保护域" class="headerlink" title="二、分级保护域"></a>二、分级保护域</h2><p><strong>分级保护域</strong>（<strong>hierarchical protection domains</strong>）又被称作保护环，简称 Rings ，是一种将计算机不同的资源划分至不同权限的模型</p>
<p> 在一些硬件或者微代码级别上提供不同特权态模式的 CPU 架构上，保护环通常都是硬件强制的。Rings是从最高特权级（通常被叫作0级）到最低特权级（通常对应最大的数字）排列的</p>
<p>在大多数操作系统中，Ring0 拥有最高特权，并且可以和最多的硬件直接交互（比如CPU，内存）</p>
<p>内层ring可以任意调用外层ring的资源</p>
<h3 id="Intel-Ring-Model"><a href="#Intel-Ring-Model" class="headerlink" title="Intel Ring Model"></a>Intel Ring Model</h3><p>Intel的CPU将权限分为四个等级：<strong>Ring0</strong>、Ring1、Ring2、<strong>Ring3</strong>，权限等级依次降低</p>
<p><img src="https://i.loli.net/2021/02/22/yQXZhLEHVn1b3uC.png" alt="image.png"></p>
<p><strong>大部分现代操作系统只用到了ring0 和 ring3，其中 kernel 运行在 ring0，用户态程序运行在 ring3</strong></p>
<blockquote>
<p> 使用 Ring Model 是为了提升系统安全性，例如某个间谍软件作为一个在 Ring 3 运行的用户程序，在不通知用户的时候打开摄像头会被阻止，因为访问硬件需要使用 being 驱动程序保留的 Ring 1 的方法 </p>
</blockquote>
<h3 id="现代操作系统启动过程概述"><a href="#现代操作系统启动过程概述" class="headerlink" title="现代操作系统启动过程概述"></a>现代操作系统启动过程概述</h3><p>操作系统本身便是一个运行在内核态的程序，当计算机通电之后处于实模式下，从磁盘上载入第一个扇区（MBR）执行，之后载入第二引导程序（Linux通常用 GNU Grub），由第二引导程序来将操作内核载入到内存当中并跳转到内核入口点，将控制权移交内核</p>
<p>内核在完成一系列的初始化过程之后，会启动一些低权限（ring3）的进程以向我们提供用户界面</p>
<h3 id="用户空间-amp-内核空间"><a href="#用户空间-amp-内核空间" class="headerlink" title="用户空间 &amp; 内核空间"></a>用户空间 &amp; 内核空间</h3><p>在现代操作系统中，计算机的虚拟内存空间通常被分为两块空间——供用户进程使用的用户空间（user space）与供操作系统内核使用的内核空间（kernel space）</p>
<p>32位下的虚拟内存空间布局如下：</p>
<p><img src="https://i.loli.net/2021/11/09/qLsr8xECYNpRbAI.png" alt="image.png"></p>
<p>64位下的虚拟内存空间布局如下：</p>
<p><img src="https://i.loli.net/2021/11/09/k8NHa1ljMEfXQbh.png" alt="image.png"></p>
<h4 id="用户态-amp-内核态"><a href="#用户态-amp-内核态" class="headerlink" title="用户态 &amp; 内核态"></a>用户态 &amp; 内核态</h4><p>通俗地说，<strong>当进程运行在内核空间时就处于内核态</strong>（kernelland），<strong>而进程运行在用户空间时则处于用户态</strong>（userland），这是现代操作系统的设计者人为区分出来的设计</p>
<p>当我们要运行一个程序时，本质上是通过操作系统预先运行的用户态进程（如 shell 等）向操作系统发出请求，此时控制权移交内核，内核完成进程内存空间的初始化后再将控制权移交回用户进程</p>
<p>我们可以将操作系统理解为一个与我们的程序并行运行着的高权限程序</p>
<h3 id="进程运行态切换"><a href="#进程运行态切换" class="headerlink" title="进程运行态切换"></a>进程运行态切换</h3><p>应用程式运行时总会经历无数次的用户态与内核态之间的转换，这是因为用户进程往往需要使用内核所提供的各种功能（如IO等），此时就需要陷入（trap）内核，待完成之后再“着陆”回用户态</p>
<p>这里我们讲到一个概念叫<strong>进入内核态</strong>，本质上其实是将进程的控制权限转交给操作系统内核，当内核完成其工作后控制权又重新回到用户进程</p>
<h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><p>中断即硬件&#x2F;软件向 CPU 发送的特殊信号，CPU 接收到中断后会停下当前工作转而执行中断处理程序，完成后恢复原工作流程</p>
<p>中断向量表（interrupt vector table）类似一个虚表，该表通常位于物理地址 0~1k处，其中存放着不同中断号对应的中断处理程序的地址</p>
<p>自保护模式起引入<strong>中断描述符表</strong>（Interrupt Descriptor Table）用以存放 <strong>「门描述符」</strong>（gate descriptor），中断描述符表地址存放在 IDTR 寄存器中，CPU 通过中断描述符表访问对应门</p>
<p><strong>「门」</strong>（gate）可以理解为中断的前置检查物件，当中断发生时会先通过这些「门」，主要有如下三种门：</p>
<ul>
<li>中断门（Interrupt gate）：用以进行<strong>硬</strong>中断处理，其类型码为 110；中断门的 DPL（Descriptor Priviledge Level）为 0，故只能在内核态下访问，即中断处理程序应当由内核激活；进入中断门会清除 IF 标志位以关闭中断，防止中断嵌套的发生</li>
<li>陷阱门（Trap gate）：类型码为 111，类似于中断门，主要用以处理 CPU 异常，但不会清除 IF 标志位</li>
<li><strong>系统门</strong>（System gate）：Linux 特有门，类型码为 3、4、5、128；其 DPL 为 3，用以供用户进程访问，主要用以<strong>进行系统调用</strong>（int 0x80）</li>
</ul>
<h4 id="信号机制"><a href="#信号机制" class="headerlink" title="信号机制"></a>信号机制</h4><p>Signals机制（又称之为软中断信号）是UNIX及类UNIX系统中的一种<strong>异步</strong>的进程间通信方式，用以通知一个进程发生了某个事件，通常情况下常见的流程如下图所示：</p>
<p><img src="https://i.loli.net/2021/03/11/DbsyXV3huR2FmQJ.png" alt="image.png"></p>
<ul>
<li>Pre. 内核代替进程接受信号，将信号放入对应进程的信号队列中，同时将对应进程<strong>挂起</strong>，让进程陷入内核态</li>
<li>① 进程陷入内核态后，在返回用户态前会检测信号队列，若存在新信号则开始进入信号处理流程：内核会<strong>将用户态进程的寄存器逐一压入【用户态进程的栈上】</strong>，形成一个<code>sigcontext</code>结构体，接下来压入 SIGNALINFO 以及<strong>指向系统调用 sigreturn 的代码</strong>，用以在后续返回时恢复用户态进程上下文；压入栈上的这一大块内容称之为一个 <code>SigreturnFrame</code>，同时也是一个<code>ucontext_t</code>结构体；接下来就是内核内部的工作了</li>
<li>② 控制权回到用户态进程，<strong>用户态进程</strong>跳转到相应的 signal handler 函数以处理不同的信号，完成之后将会执行位于其栈上的第一条指令——<code>sigreturn系统调用</code></li>
<li>③ 进程重新陷入内核，通过 sigreturn 系统调用恢复用户态上下文信息</li>
<li>④ 控制权重新返还给用户态进程，恢复进程原上下文</li>
</ul>
<h4 id="用户态-—-gt-内核态"><a href="#用户态-—-gt-内核态" class="headerlink" title="用户态 —&gt; 内核态"></a>用户态 —&gt; 内核态</h4><p>由用户态陷入到内核态主要有以下几种途径：</p>
<ul>
<li><strong>系统调用</strong>（int 0x80&#x2F;sysenter）</li>
<li><strong>异常</strong></li>
<li><strong>外设产生中断</strong></li>
<li>…</li>
</ul>
<h5 id="I-切换GS段寄存器"><a href="#I-切换GS段寄存器" class="headerlink" title="I.切换GS段寄存器"></a>I.切换GS段寄存器</h5><p>通过 <code>swapgs</code> 切换 GS 段寄存器，将 GS 寄存器值和一个特定位置的值进行交换，目的是保存 GS 值，同时将该位置的值作为内核执行时的 GS 值使用</p>
<h5 id="II-保存用户态栈帧信息"><a href="#II-保存用户态栈帧信息" class="headerlink" title="II.保存用户态栈帧信息"></a>II.保存用户态栈帧信息</h5><p> 将当前栈顶（用户空间栈顶）记录在 CPU 独占变量区域里，将 CPU 独占区域里记录的内核栈顶放入 rsp&#x2F;esp </p>
<h5 id="III-保存用户态寄存器信息"><a href="#III-保存用户态寄存器信息" class="headerlink" title="III.保存用户态寄存器信息"></a>III.保存用户态寄存器信息</h5><p> 通过 push 保存各寄存器值到栈上，以便后续“着陆”回用户态</p>
<h5 id="IV-通过汇编指令判断是否为32位"><a href="#IV-通过汇编指令判断是否为32位" class="headerlink" title="IV.通过汇编指令判断是否为32位"></a>IV.通过汇编指令判断是否为32位</h5><h5 id="V-控制权转交内核，执行系统调用"><a href="#V-控制权转交内核，执行系统调用" class="headerlink" title="V.控制权转交内核，执行系统调用"></a>V.控制权转交内核，执行系统调用</h5><p>在这里用到一个全局函数表<code>sys_call_table</code>，其中保存着系统调用的函数指针</p>
<h4 id="内核态-—-gt-用户态"><a href="#内核态-—-gt-用户态" class="headerlink" title="内核态 —&gt; 用户态"></a>内核态 —&gt; 用户态</h4><p>由内核态重新“着陆”回用户态只需要恢复用户空间信息即可：</p>
<ul>
<li><code>swapgs</code>指令恢复用户态GS寄存器</li>
<li><code>sysretq</code>或者<code>iretq</code>恢复到用户空间</li>
</ul>
<h2 id="三、系统调用"><a href="#三、系统调用" class="headerlink" title="三、系统调用"></a>三、系统调用</h2><p><strong>系统调用</strong>（<strong>system call</strong>）是由操作系统内核向上层应用程式提供的应用接口，操作系统负责调度一切的资源，当用户进程想要请求更高权限的服务时，便需要通过由系统提供的应用接口，使用系统调用以<strong>陷入内核态，再由操作系统完成请求</strong></p>
<p>系统调用本质上与一般的C库函数没有区别，不同的是系统调用位于内核空间，以内核态运行</p>
<p><img src="https://i.loli.net/2021/02/24/IYaievPRZpAVMH7.png" alt="image.png"></p>
<blockquote>
<p> Windows系统下将系统调用封装在win32 API中，不过本篇博文主要讨论Linux</p>
</blockquote>
<h3 id="系统调用表"><a href="#系统调用表" class="headerlink" title="系统调用表"></a>系统调用表</h3><p>所有的系统调用被声明于内核源码<code>arch/x86/entry/syscalls/syscall_64.tbl</code>中，在该表中声明了系统调用的标号、类型、名称、内核态函数名称</p>
<p>在内核中使用<code>系统调用表（System Call Table）</code>对系统调用进行索引，该表中储存了不同标号的系统调用函数的地址</p>
<h3 id="进入系统调用"><a href="#进入系统调用" class="headerlink" title="进入系统调用"></a>进入系统调用</h3><p>Linux 下进入系统调用有两种主要的方式：</p>
<ul>
<li>32位：执行 <code>int 0x80 </code>汇编指令（80号中断）</li>
<li>64位：执行 <code>syscall</code> 汇编指令 &#x2F; 执行 <code>sysenter</code> 汇编指令（only intel）</li>
</ul>
<p>接下来就是由用户态进入到内核态的流程</p>
<p>Linux下的系统调用以<code>eax/rax</code>寄存器作为<strong>系统调用号</strong>，参数传递约束如下：</p>
<ul>
<li>32 位：<code>ebx、ecx、edx、esi、edi、ebp</code>作为第一个参数、第二个参数…进行参数传递</li>
<li>64 位：<code>rdi、rsi、rdx、rcx、r8、r9</code>作为第一个参数、第二个参数…进行参数传递</li>
</ul>
<h3 id="退出系统调用"><a href="#退出系统调用" class="headerlink" title="退出系统调用"></a>退出系统调用</h3><p>同样地，内核执行完系统调用后退出系统调用也有对应的两种方式：</p>
<ul>
<li>执行<code>iret</code>汇编指令</li>
<li>执行 <code>sysret</code> 汇编指令 &#x2F; 执行<code>sysexit</code>汇编指令（only Intel）</li>
</ul>
<p>接下来就是由内核态回退至用户态的流程</p>
<h2 id="四、进程权限管理"><a href="#四、进程权限管理" class="headerlink" title="四、进程权限管理"></a>四、进程权限管理</h2><p>前面我们讲到，kernel 调度着一切的系统资源，并为用户应用程式提供运行环境，相应地，应用程式的权限也都是由 kernel 进行管理的</p>
<h3 id="进程描述符（process-descriptor）"><a href="#进程描述符（process-descriptor）" class="headerlink" title="进程描述符（process descriptor）"></a>进程描述符（process descriptor）</h3><p>在内核中使用结构体 <code>task_struct</code> 表示一个进程，该结构体定义于内核源码<code>include/linux/sched.h</code>中，代码比较长就不在这里贴出了</p>
<p>一个进程描述符的结构应当如下图所示：</p>
<p><img src="https://i.loli.net/2021/02/23/2W8xIfwqm9Y7Fru.png" alt="image.png"></p>
<p>本篇我们主要关心其对于进程权限的管理</p>
<p>注意到<code>task_struct</code>的源码中有如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Process credentials: */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Tracer&#x27;s credentials at attach: */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>        *<span class="title">ptracer_cred</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Objective and real subjective task credentials (COW): */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>        *<span class="title">real_cred</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Effective (overridable) subjective task credentials (COW): */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>        *<span class="title">cred</span>;</span></span><br></pre></td></tr></table></figure>

<p><strong>Process credentials</strong> 是 kernel 用以判断一个进程权限的凭证，在 kernel 中使用 <code>cred</code> 结构体进行标识，对于一个进程而言应当有三个 cred：</p>
<ul>
<li><strong>ptracer_cred：</strong>使用<code>ptrace</code>系统调用跟踪该进程的上级进程的cred（gdb调试便是使用了这个系统调用，常见的反调试机制的原理便是提前占用了这个位置）</li>
<li><strong>real_cred：</strong>即<strong>客体凭证</strong>（<strong>objective cred</strong>），通常是一个进程最初启动时所具有的权限</li>
<li><strong>cred：</strong>即<strong>主体凭证</strong>（<strong>subjective cred</strong>），该进程的有效cred，kernel以此作为进程权限的凭证</li>
</ul>
<p>一般情况下，主体凭证与客体凭证的值是相同的</p>
<blockquote>
<p>例：当进程 A 向进程 B 发送消息时，A为主体，B为客体</p>
</blockquote>
<h4 id="进程权限凭证：cred结构体"><a href="#进程权限凭证：cred结构体" class="headerlink" title="进程权限凭证：cred结构体"></a>进程权限凭证：cred结构体</h4><p>对于一个进程，在内核当中使用一个结构体<code>cred</code>管理其权限，该结构体定义于内核源码<code>include/linux/cred.h</code>中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_t</span>    usage;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">    <span class="type">atomic_t</span>    subscribers;    <span class="comment">/* number of processes subscribed */</span></span><br><span class="line">    <span class="type">void</span>        *put_addr;</span><br><span class="line">    <span class="type">unsigned</span>    magic;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC    0x43736564</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC_DEAD    0x44656144</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">kuid_t</span>        uid;        <span class="comment">/* real UID of the task */</span></span><br><span class="line">    <span class="type">kgid_t</span>        gid;        <span class="comment">/* real GID of the task */</span></span><br><span class="line">    <span class="type">kuid_t</span>        suid;        <span class="comment">/* saved UID of the task */</span></span><br><span class="line">    <span class="type">kgid_t</span>        sgid;        <span class="comment">/* saved GID of the task */</span></span><br><span class="line">    <span class="type">kuid_t</span>        euid;        <span class="comment">/* effective UID of the task */</span></span><br><span class="line">    <span class="type">kgid_t</span>        egid;        <span class="comment">/* effective GID of the task */</span></span><br><span class="line">    <span class="type">kuid_t</span>        fsuid;        <span class="comment">/* UID for VFS ops */</span></span><br><span class="line">    <span class="type">kgid_t</span>        fsgid;        <span class="comment">/* GID for VFS ops */</span></span><br><span class="line">    <span class="type">unsigned</span>    securebits;    <span class="comment">/* SUID-less security management */</span></span><br><span class="line">    <span class="type">kernel_cap_t</span>    cap_inheritable; <span class="comment">/* caps our children can inherit */</span></span><br><span class="line">    <span class="type">kernel_cap_t</span>    cap_permitted;    <span class="comment">/* caps we&#x27;re permitted */</span></span><br><span class="line">    <span class="type">kernel_cap_t</span>    cap_effective;    <span class="comment">/* caps we can actually use */</span></span><br><span class="line">    <span class="type">kernel_cap_t</span>    cap_bset;    <span class="comment">/* capability bounding set */</span></span><br><span class="line">    <span class="type">kernel_cap_t</span>    cap_ambient;    <span class="comment">/* Ambient capability set */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>    jit_keyring;    <span class="comment">/* default keyring to attach requested</span></span><br><span class="line"><span class="comment">                     * keys to */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>    *<span class="title">session_keyring</span>;</span> <span class="comment">/* keyring inherited over fork */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>    *<span class="title">process_keyring</span>;</span> <span class="comment">/* keyring private to this process */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>    *<span class="title">thread_keyring</span>;</span> <span class="comment">/* keyring private to this thread */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>    *<span class="title">request_key_auth</span>;</span> <span class="comment">/* assumed request_key authority */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">    <span class="type">void</span>        *security;    <span class="comment">/* subjective LSM security */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span>    <span class="comment">/* real user ID subscription */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span> <span class="comment">/* user_ns the caps and keyrings are relative to. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">group_info</span> *<span class="title">group_info</span>;</span>    <span class="comment">/* supplementary groups for euid/fsgid */</span></span><br><span class="line">    <span class="comment">/* RCU deletion */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> non_rcu;            <span class="comment">/* Can we skip RCU deletion? */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>    <span class="title">rcu</span>;</span>        <span class="comment">/* RCU deletion hook */</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>

<p>我们主要关注<code>cred</code>结构体中管理权限的变量</p>
<h4 id="用户ID-amp-组ID"><a href="#用户ID-amp-组ID" class="headerlink" title="用户ID &amp; 组ID"></a>用户ID &amp; 组ID</h4><p>一个cred结构体中记载了<strong>一个进程四种不同的用户ID</strong>：</p>
<ul>
<li><strong>真实用户ID</strong>（real UID）：标识一个进程<strong>启动时的用户ID</strong></li>
<li><strong>保存用户ID</strong>（saved UID）：标识一个进程<strong>最初的有效用户ID</strong></li>
<li><strong>有效用户ID</strong>（effective UID）：标识一个进程<strong>正在运行时所属的用户ID</strong>，一个进程在运行途中是可以改变自己所属用户的，因而权限机制也是通过有效用户ID进行认证的，内核通过 euid 来进行特权判断；为了防止用户一直使用高权限，当任务完成之后，euid 会与 suid 进行交换，恢复进程的有效权限</li>
<li><strong>文件系统用户ID</strong>（UID for VFS ops）：标识一个进程<strong>创建文件时进行标识的用户ID</strong></li>
</ul>
<p>在通常情况下这几个ID应当都是相同的</p>
<p>用户组ID同样分为四个：<code>真实组ID</code>、<code>保存组ID</code>、<code>有效组ID</code>、<code>文件系统组ID</code>，与用户ID是类似的，这里便不再赘叙</p>
<h3 id="进程权限改变"><a href="#进程权限改变" class="headerlink" title="进程权限改变"></a>进程权限改变</h3><p>前面我们讲到，一个进程的权限是由位于内核空间的<code>cred</code>结构体进行管理的，那么我们不难想到：只要改变一个进程的<code>cred</code>结构体，就能改变其执行权限</p>
<p>在内核空间有如下两个函数，都位于<code>kernel/cred.c</code>中：</p>
<ul>
<li><code>struct cred* prepare_kernel_cred(struct task_struct* daemon)</code>：该函数用以拷贝一个进程的cred结构体，并返回一个新的cred结构体，需要注意的是<code>daemon</code>参数应为<strong>有效的进程描述符地址或NULL</strong></li>
<li><code>int commit_creds(struct cred *new)</code>：该函数用以将一个新的<code>cred</code>结构体应用到进程</li>
</ul>
<h4 id="提权"><a href="#提权" class="headerlink" title="*提权"></a><em>*提权</em></h4><p>查看<code>prepare_kernel_cred()</code>函数源码，观察到如下逻辑：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> cred *<span class="title function_">prepare_kernel_cred</span><span class="params">(<span class="keyword">struct</span> task_struct *daemon)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">    new = kmem_cache_alloc(cred_jar, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!new)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    kdebug(<span class="string">&quot;prepare_kernel_cred() alloc %p&quot;</span>, new);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (daemon)</span><br><span class="line">        old = get_task_cred(daemon);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        old = get_cred(&amp;init_cred);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在<code>prepare_kernel_cred()</code>函数中，若传入的参数为NULL，则会缺省使用<code>init</code>进程的<code>cred</code>作为模板进行拷贝，<strong>即可以直接获得一个标识着root权限的cred结构体</strong></p>
<p>那么我们不难想到，只要我们能够在内核空间执行<code>commit_creds(prepare_kernel_cred(NULL))</code>，那么就能够将当前进程的权限提升到<code>root</code></p>
<h2 id="五、I-x2F-O"><a href="#五、I-x2F-O" class="headerlink" title="五、I&#x2F;O"></a>五、I&#x2F;O</h2><p>*NIX&#x2F;Linux追求高层次抽象上的统一，其设计哲学之一便是<code>万物皆文件</code></p>
<h3 id="“万物皆文件”"><a href="#“万物皆文件”" class="headerlink" title="“万物皆文件”"></a>“万物皆文件”</h3><p><em>NIX&#x2F;Linux设计的哲学之一——<code>万物皆文件</code>，在Linux系统的视角下，无论是文件、设备、管道，还是目录、进程，甚至是磁盘、套接字等等，*<em>一切都可以被抽象为文件，一切都可以使用访问文件的方式进行操作</em></em></p>
<p>通过这样一种哲学，Linux予开发者以高层次抽象的统一性，提供了<code>操作的一致性</code>：</p>
<ul>
<li><strong>所有的读取操作都可以通过read进行</strong></li>
<li><strong>所有的更改操作都可以通过write进行</strong></li>
</ul>
<p>对于开发者而言，将一切的操作都统一于一个高层次抽象的应用接口，无疑是十分美妙的一件事情——<strong>我们不需要去理解实现的细节，只需要对”文件”完成简单的读写操作</strong></p>
<blockquote>
<p>例如，在较老版本的Linux中，可以使用<code>cat /dev/urandom &gt; /dev/dsp</code>命令令扬声器产生随机噪声</p>
</blockquote>
<p><img src="https://i.loli.net/2021/02/25/iUoHNsaK5vOG9cR.png" alt="image.png"></p>
<h3 id="进程文件系统"><a href="#进程文件系统" class="headerlink" title="进程文件系统"></a>进程文件系统</h3><p>进程文件系统（process file system， 简写为procfs）用以描述一个进程，其中包括该进程所打开的文件描述符、堆栈内存布局、环境变量等等</p>
<p>进程文件系统本身是一个伪文件系统，通常被挂载到<code>/proc</code>目录下，并不真正占用储存空间，而是占用一定的内存</p>
<p>当一个进程被建立起来时，其进程文件系统便会被挂载到<code>/proc/[PID]</code>下，我们可以在该目录下查看其相关信息</p>
<h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>进程通过<strong>文件描述符</strong>（<strong>file descriptor</strong>）来完成对文件的访问，其在形式上是一个非负整数，本质上是对文件的索引值，进程所有执行 I&#x2F;O 操作的系统调用都会通过文件描述符 </p>
<p>每个进程都<strong>独立有着一个文件描述符表</strong>，存放着该进程所打开的文件索引，每当进程<strong>成功</strong>打开一个现有文件&#x2F;创建一个新文件时（通过系统调用open进行操作），<strong>内核会向进程返回一个文件描述符</strong></p>
<p>在kernel中有着一个文件表，由所有的进程共享</p>
<h4 id="stdin、stdout、stderr"><a href="#stdin、stdout、stderr" class="headerlink" title="stdin、stdout、stderr"></a>stdin、stdout、stderr</h4><p>每个*NIX进程都应当有着三个标准的POSIX文件描述符，对应着三个标准文件流：</p>
<ul>
<li><code>stdin：标准输入 - 0</code></li>
<li><code>stdout：标准输出 - 1</code></li>
<li><code>stderr：标准错误 - 2</code></li>
</ul>
<p>此后打开的文件描述符应当从标号<code>3</code>起始</p>
<h3 id="系统调用：ioctl"><a href="#系统调用：ioctl" class="headerlink" title="系统调用：ioctl"></a>系统调用：ioctl</h3><p>在*NIX中一切都可以被视为文件，因而一切都可以以访问文件的方式进行操作，为了方便，Linux定义了系统调用<code>ioctl</code>供进程与设备之间进行通信</p>
<p>系统调用<code>ioctl</code>是一个专用于设备输入输出操作的一个系统调用，其调用方式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ioctl</span><span class="params">(<span class="type">int</span> fd, <span class="type">unsigned</span> <span class="type">long</span> request, ...)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>fd：设备的文件描述符</strong></li>
<li><strong>request：请求码</strong></li>
<li><strong>其他参数</strong></li>
</ul>
<p>对于一个提供了ioctl通信方式的设备而言，我们可以通过其文件描述符、使用不同的请求码及其他请求参数通过ioctl系统调用完成不同的对设备的I&#x2F;O操作</p>
<blockquote>
<p>例如CD-ROM驱动程序弹出光驱的这一操作就对应着对“光驱设备”这一文件通过ioctl传递特定的请求码与请求参数完成</p>
</blockquote>
<h2 id="六、Loadable-Kernel-Modules（LKMs）"><a href="#六、Loadable-Kernel-Modules（LKMs）" class="headerlink" title="六、Loadable Kernel Modules（LKMs）"></a>六、Loadable Kernel Modules（LKMs）</h2><p>前面我们讲到，Linux Kernle采用的是宏内核架构，一切的系统服务都需要由内核来提供，虽然效率较高，但是缺乏可扩展性与可维护性，同时内核需要装载很多可能用到的服务，但这些服务最终可能未必会用到，还会占据大量内存空间，同时新服务的提供往往意味着要重新编译整个内核</p>
<p>综合以上考虑，<strong>可装载内核模块</strong>（<strong>Loadable Kernel Modules</strong>，简称<strong>LKMs</strong>）出现了，位于内核空间的LKMs可以提供<strong>新的系统调用</strong>或其他服务，同时LKMs可以像积木一样被装载入内核&#x2F;从内核中卸载，大大提高了kernel的可拓展性与可维护性</p>
<blockquote>
<p>常见的外设驱动便是LKM的一种</p>
</blockquote>
<p>LKMs与用户态可执行文件一样都采用ELF格式，但是<strong>LKMs运行在内核空间，且无法脱离内核运行</strong></p>
<p>通常与LKM相关的命令有以下三个：</p>
<ul>
<li><code>lsmod</code>：列出现有的LKMs</li>
<li><code>insmod</code>：装载新的LKM（需要root）</li>
<li><code>rmmod</code>：从内核中移除LKM（需要root）</li>
</ul>
<blockquote>
<p>CTF 比赛中的 kernel pwn 的漏洞往往出现在第三方 LKM 中，<del>一般来说不会真的让你去直接日内核组件</del></p>
</blockquote>
<h2 id="七、内核内存管理"><a href="#七、内核内存管理" class="headerlink" title="七、内核内存管理"></a>七、内核内存管理</h2><p>Linux kernel 主要有两个内存管理器——buddy system 与 slab allocator</p>
<h3 id="buddy-system"><a href="#buddy-system" class="headerlink" title="buddy system"></a>buddy system</h3><blockquote>
<p>目前的 CTF 题目当中还没有出现针对 buddy system 进行利用的题目，但是<a target="_blank" rel="noopener" href="https://etenal.me/archives/1825">有安全研究员在 CVE-2022-27666 中运用了页级堆风水的技巧</a>，笔者认为非常 nb</p>
</blockquote>
<p>buddy system 是 Linux kernel 中的一个较为底层的内存管理系统，<strong>以内存页为粒度管理者所有的物理内存</strong>，这里我们先来介绍一些基本概念</p>
<p>Linux kernel 将可用内存划分为如下的多级结构：</p>
<ul>
<li><strong>节点</strong>（node，对应结构体 pgdata_list）： <em>内存控制器（memory controller）</em> 为节点划分的依据，不同的物理内存属于不同的内存控制器，因而便对应属于不同的节点，对于同一个内存控制器下的 CPU 而言其对应的节点称之为_本地内存_，不同处理器之间通过总线进行进一步的连接</li>
<li><strong>区</strong>（zone，对应结构体 zone，图上展示了三种类型的 zone）：不同用途的内存区域划分为不同的 <code>区（zone）</code></li>
<li><strong>页</strong>（page，对应结构体 page）：表示一个物理页框，<strong>每个物理页框都有着一个对应的 page 结构体</strong></li>
</ul>
<p><img src="https://i.loli.net/2021/11/28/OrsvS6GTMgPLx5E.png" alt="image.png"></p>
<p>buddy system 存在于 <strong>区</strong> 这一级别，对当前区所对应拥有的所有物理页框进行管理</p>
<p>在每个 zone 结构体中都有一个 free_area 结构体数组，用以存储 buddy system <strong>按照 order 管理的页面</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> &#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">free_area</span>	<span class="title">free_area</span>[<span class="title">MAX_ORDER</span>];</span></span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<p>其中的 <code>MAX_ORDER</code> 为一个常量，值为 11</p>
<p>在 buddy system 中按照空闲页面的连续大小进行分阶管理，这里的 order 的实际含义为<strong>连续的空闲页面的大小</strong>，不过单位不是页面数，而是<code>阶</code>，即对于每个下标而言，其中所存储的页面大小为：<br>$$<br>2^{order}<br>$$<br>在 free_area 中存放的页面通过自身的相应字段连接成双向链表结构，由此我们得到这样一张_Overview_：</p>
<p><img src="https://i.loli.net/2021/11/30/sOwdI5YMNUjLSib.png" alt="自己画的图.png"></p>
<ul>
<li>分配：<ul>
<li>首先会将请求的内存大小向 2 的幂次方张内存页大小对齐，之后从对应的下标取出连续内存页</li>
<li>若对应下标链表为空，则会从下一个 order 中取出内存页，一分为二，装载到当前下标对应链表中，之后再返还给上层调用，若下一个 order 也为空则会继续向更高的 order 进行该请求过程</li>
</ul>
</li>
<li>释放：<ul>
<li>将对应的连续内存页释放到对应的链表上</li>
<li>检索是否有可以合并的内存页，若有，则进行合成，放入更高 order 的链表中</li>
</ul>
</li>
</ul>
<p>但是我们很容易产生不容易合并的内存碎片，因此 Linux kernel 还会进行 <em>内存迁移</em> 以减少内存碎片，原理类似下图，由于不是本篇重点故不在此赘叙</p>
<p><img src="https://i.loli.net/2021/11/30/q7T6EjtIb9PVFY3.png" alt="从知乎偷的图.png"></p>
<h3 id="slab-allocator"><a href="#slab-allocator" class="headerlink" title="slab allocator"></a>slab allocator</h3><p>slab allocator 则是更为细粒度的内存管理器，其通过向 buddy system 请求单张或多张连续内存页后再分割成同等大小的<strong>对象</strong>（object）返还给上层调用者来实现更为细粒度的内存管理</p>
<p>slab allocator 一共有三种版本：</p>
<ul>
<li>slab（最初的版本，机制比较复杂，效率不高）</li>
<li>slob（用于嵌入式等场景的极为简化版本）</li>
<li>slub（优化后的版本，现在的通用版本）</li>
</ul>
<h4 id="I-基本结构"><a href="#I-基本结构" class="headerlink" title="I.基本结构"></a>I.基本结构</h4><p> <code>slub</code> 版本的 allocator 为现在绝大多数 Linux kernel 所装配的版本，因此本篇文章主要叙述的也是 slub allocator，其基本结构如下图所示：</p>
<p><img src="https://i.loli.net/2021/07/22/ivPnbsjHyI94m5z.png" alt="image.png"></p>
<ul>
<li><p>我们将 slub allocator 每次向 buddy system 请求得来的单张&#x2F;多张内存页称之为一个 <code>slub</code>，其被分割为多个同等大小对象（object），每个 object 作为一个被分配实体，在 slub 的第一张内存页对应的 page 结构体上的 freelist 成员指向该张内存页上的第一个空闲对象，一个 slub 上的所有空闲对象组成一个以 NULL 结尾的单向链表</p>
<blockquote>
<p>一个 object 可以理解为用户态 glibc 中的 chunk，不过 object 并不像 chunk 那样需要有一个 header，因为 page 结构体与物理内存间存在线性对应关系，我们可以直接通过 object 地址找到其对应的 page 结构体</p>
</blockquote>
</li>
<li><p><code>kmem_cache</code> 为一个基本的 allocator 组件，其用于分配某个特定大小（某种特定用途）的对象，所有的 kmem_cache 构成一个双向链表，并存在两个对应的结构体数组 <code>kmalloc_caches</code> 与 <code>kmalloc_dma_caches</code></p>
</li>
<li><p>一个 <code>kmem_cache</code> 主要由两个模块组成：</p>
<ul>
<li><code>kmem_cache_cpu</code>：这是一个<strong>percpu 变量</strong>（即每个核心上都独立保留有一个副本，原理是以 gs 寄存器作为 percpu 段的基址进行寻址），用以表示当前核心正在使用的 slub，因此当前 CPU 在从 kmem_cache_cpu 上取 object 时<strong>不需要加锁</strong>，从而极大地提高了性能</li>
<li><code>kmem_cache_node</code>：可以理解为当前 <code>kmem_cache</code> 的 slub 集散中心，其中存放着两个 slub 链表：<ul>
<li>partial：该 slub 上存在着一定数量的空闲 object，但并非全部空闲</li>
<li>full：该 slub 上的所有 object 都被分配出去了</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="II-分配-x2F-释放过程"><a href="#II-分配-x2F-释放过程" class="headerlink" title="II.分配&#x2F;释放过程"></a>II.分配&#x2F;释放过程</h4><p>那么现在我们可以来说明 slub allocator 的分配&#x2F;释放行为了</p>
<ul>
<li>分配：<ul>
<li>首先从 <code>kmem_cache_cpu</code> 上取对象，若有则直接返回</li>
<li>若 <code>kmem_cache_cpu</code> 上的 slub 已经无空闲对象了，对应 slub 会被加入到 <code>kmem_cache_node</code> 的 <strong>full</strong> 链表，并尝试从 <strong>partial</strong> 链表上取一个 slub 挂载到 <code>kmem_cache_cpu</code> 上，然后再取出空闲对象返回</li>
<li>若 <code>kmem_cache_node</code> 的 partial 链表也空了，那就<strong>向 buddy system 请求分配新的内存页</strong>，划分为多个 object 之后再给到 <code>kmem_cache_cpu</code>，取空闲对象返回上层调用</li>
</ul>
</li>
<li>释放：<ul>
<li>若被释放 object 属于  <code>kmem_cache_cpu</code> 的 slub，直接使用头插法插入当前 CPU slub 的 freelist</li>
<li>若被释放 object 属于 <code>kmem_cache_node</code> 的 partial 链表上的 slub，直接使用头插法插入对应 slub 的 freelist</li>
<li>若被释放 object 属于 <code>kmem_cache_node</code> 的 full 链表上的 slub，则其会成为对应 slub 的 freelist 头节点，<strong>且该 slub 会从 full 链表迁移到 partial 链表</strong></li>
</ul>
</li>
</ul>
<p>以上便是 slub allocator 的基本原理</p>
<h4 id="III-slab-alias（mergeability）"><a href="#III-slab-alias（mergeability）" class="headerlink" title="III. slab alias（mergeability）"></a>III. slab alias（mergeability）</h4><p>slab alias 机制是一种对同等&#x2F;相近大小 object 的 <code>kmem_cache</code> 进行<strong>复用</strong>的一种机制：</p>
<ul>
<li>当一个 <code>kmem_cache</code> 在创建时，若已经存在能分配相等&#x2F;近似大小的 object 的 <code>kmem_cache</code> ，则<strong>不会创建新的 kmem_cache，而是为原有的 kmem_cache 起一个 alias，作为“新的” kmem_cache 返回</strong></li>
</ul>
<p>举个🌰，<code>cred_jar</code> 是专门用以分配 <code>cred</code> 结构体的 <code>kmem_cache</code>，在 Linux 4.4 之前的版本中，其为 <code>kmalloc-192</code> 的 alias，即 cred 结构体与其他的 192 大小的 object 都会从同一个 <code>kmem_cache</code>——<code>kmalloc-192</code> 中分配</p>
<p>对于初始化时设置了 <code>SLAB_ACCOUNT</code> 这一 flag 的 <code>kmem_cache</code> 而言，则会新建一个新的 <code>kmem_cache</code> 而非为原有的建立 alias，🌰如在新版的内核当中 <code>cred_jar</code> 与 <code>kmalloc-192</code> 便是两个独立的 <code>kmem_cache</code>，<strong>彼此之间互不干扰</strong></p>
<p><strong>对于包含有用户空间数据的独立 kmem_cache 而言，其永远不会与现有的 kmem_cache 发生合并</strong></p>
<h2 id="八、保护机制"><a href="#八、保护机制" class="headerlink" title="八、保护机制"></a>八、保护机制</h2><p>与一般的程序相同，Linux Kernel同样有着各种各样的保护机制：</p>
<h3 id="I-通用保护机制"><a href="#I-通用保护机制" class="headerlink" title="I.通用保护机制"></a>I.通用保护机制</h3><h4 id="KASLR"><a href="#KASLR" class="headerlink" title="KASLR"></a>KASLR</h4><p>KASLR即<code>内核空间地址随机化</code>（kernel address space layout randomize），与用户态程序的ASLR相类似——在内核镜像映射到实际的地址空间时加上一个偏移值，但是内核内部的相对偏移其实还是不变的</p>
<p>在未开启KASLR保护机制时，内核代码段的基址为 <code>0xffffffff81000000</code> ，direct mapping area 的基址为 <code>0xffff888000000000</code></p>
<p>内核内存布局可以参考<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/latest/source/Documentation/x86/x86_64/mm.rst">这↑里↓</a></p>
<h4 id="FGKASLR"><a href="#FGKASLR" class="headerlink" title="*FGKASLR"></a><em>*FGKASLR</em></h4><p>KASLR 虽然在一定程度上能够缓解攻击，但是若是攻击者通过一些信息泄露漏洞获取到内核中的某个地址，仍能够直接得知内核加载地址偏移从而得知整个内核地址布局，因此有研究者基于 KASLR 实现了 FGKASLR，<strong>以函数粒度重新排布内核代码</strong></p>
<h4 id="STACK-PROTECTOR"><a href="#STACK-PROTECTOR" class="headerlink" title="STACK PROTECTOR"></a>STACK PROTECTOR</h4><p>类似于用户态程序的 canary，通常又被称作是 stack cookie，用以检测<strong>是否发生内核堆栈溢出</strong>，若是发生内核堆栈溢出则会产生 kernel panic</p>
<p>内核中的 canary 的值通常取自 gs 段寄存器某个固定偏移处的值</p>
<h4 id="SMAP-x2F-SMEP"><a href="#SMAP-x2F-SMEP" class="headerlink" title="SMAP&#x2F;SMEP"></a>SMAP&#x2F;SMEP</h4><p>SMAP即<code>管理模式访问保护</code>（Supervisor Mode Access Prevention），SMEP即<code>管理模式执行保护</code>（Supervisor Mode Execution Prevention），这两种保护通常是同时开启的，用以阻止<strong>内核空间直接访问&#x2F;执行用户空间的数据</strong>，完全地将内核空间与用户空间相分隔开，用以防范ret2usr（return-to-user，将内核空间的指令指针重定向至用户空间上构造好的提权代码）攻击</p>
<p>SMEP保护的绕过有以下两种方式：</p>
<ul>
<li>利用内核线性映射区对物理地址空间的完整映射，找到用户空间对应页框的内核空间地址，利用该内核地址完成对用户空间的访问（即一个内核空间地址与一个用户空间地址映射到了同一个页框上），这种攻击手法称为 ret2dir</li>
<li>Intel下系统根据CR4控制寄存器的第20位标识是否开启SMEP保护（1为开启，0为关闭），若是能够通过kernel ROP改变CR4寄存器的值便能够关闭SMEP保护，完成SMEP-bypass，接下来就能够重新进行 ret2usr，<strong>但对于开启了 KPTI 的内核而言，内核页表的用户地址空间无执行权限，这使得 ret2usr 彻底成为过去式</strong></li>
</ul>
<p><img src="https://i.loli.net/2021/09/07/sYFKuZiUVNIclBp.png" alt="image.png"></p>
<blockquote>
<p> 在 ARM 下有一种类似的保护叫 <code>PXN</code></p>
</blockquote>
<h4 id="KPTI"><a href="#KPTI" class="headerlink" title="KPTI"></a><a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/latest/x86/pti.html">KPTI</a></h4><p>KPTI即<code>内核页表隔离</code>（Kernel page-table isolation），内核空间与用户空间分别使用两组不同的页表集，这对于内核的内存管理产生了根本性的变化</p>
<p>需要进行说明的是，<strong>在这两张页表上都有着对用户内存空间的完整映射，但在用户页表中只映射了少量的内核代码（例如系统调用入口点、中断处理等），而只有在内核页表中才有着对内核内存空间的完整映射，但两张页表都有着对用户内存空间的完整映射</strong>，如下图所示，左侧是未开启 KPTI 后的页表布局，右侧是开启了 KPTI 后的页表布局</p>
<blockquote>
<p>在 64 位下用户空间与内核空间都占 128 TB，所以他们占用的页全局表项（PGD）的大小应当是相同的，图上没有体现出来，因此这里由笔者代为补充（笑）</p>
</blockquote>
<p><img src="https://s2.loli.net/2022/03/11/q74X6lbTnrNGhC1.png" alt="image.png"></p>
<p>KPTI 的发明主要是用来修复一个史诗级别的 CPU 硬件漏洞：Meltdown。简单理解就是利用 CPU 流水线设计中（乱序执行与预测执行）的漏洞来获取到用户态无法访问的内核空间的数据，属于侧信道攻击的一种</p>
<blockquote>
<p>简单理解：你的第一条指令是合法内存访问，第二条指令是越权内存访问，CPU会在执行第一条正常指令的过程中<strong>也会执行第二条非法指令</strong>，之后再做权限判定，若是非法访问则消除该影响，这样的流水线设计虽然有着较高的性能，<strong>但是越权访问仍会留下痕迹</strong>，这给了攻击者非法获取内核空间数据的可能</p>
</blockquote>
<p>若是整个流水线设计直接扔掉那自然是捡了芝麻丢了西瓜，因此 KPTI 被快速应用到主流操作系统上（这个设计在漏洞出来之前就有，但未得到广泛应用），尽管仍旧造成了一定的性能损耗，但却有效地从软件层面修复了 Meltdown 漏洞</p>
<p><strong>KPTI 同时还令内核页表中属于用户地址空间的部分不再拥有执行权限，这使得 ret2usr 彻底成为过去式</strong></p>
<h3 id="II-内核“堆”上保护机制"><a href="#II-内核“堆”上保护机制" class="headerlink" title="II.内核“堆”上保护机制"></a>II.内核“堆”上保护机制</h3><blockquote>
<p>more info 可以参考<a target="_blank" rel="noopener" href="https://duasynt.com/blog/linux-kernel-heap-feng-shui-2022">这里</a></p>
</blockquote>
<h4 id="Hardened-Usercopy"><a href="#Hardened-Usercopy" class="headerlink" title="Hardened Usercopy"></a>Hardened Usercopy</h4><p>hardened usercopy 是用以在用户空间与内核空间之间拷贝数据时进行越界检查的一种防护机制，<strong>主要检查拷贝过程中对内核空间中数据的读写是否会越界</strong>：</p>
<ul>
<li>读取的数据长度是否超出源 object 范围</li>
<li>写入的数据长度是否超出目的 object 范围</li>
</ul>
<p>不过这种保护 <em>不适用于内核空间内的数据拷贝</em> ，这也是目前主流的绕过手段</p>
<p>这一保护被用于 <code>copy_to_user()</code> 与 <code>copy_from_user()</code> 等数据交换 API 中</p>
<h4 id="Hardened-freelist"><a href="#Hardened-freelist" class="headerlink" title="Hardened freelist"></a>Hardened freelist</h4><p>类似于 glibc 2.32 版本引入的保护，在开启这种保护之前，slub 中的 free object 的 next 指针直接存放着 next free object 的地址，攻击者可以通过读取 freelist 泄露出内核线性映射区的地址，在开启了该保护之后 free object 的 next 指针存放的是由以下三个值进行异或操作后的值：</p>
<ul>
<li>当前 free object 的地址</li>
<li>下一个 free object 的地址</li>
<li>由 kmem_cache 指定的一个 random 值</li>
</ul>
<p>攻击者至少需要获取到第一与第三个值才能篡改 freelist，这无疑为对 freelist 的直接利用增添不少难度</p>
<blockquote>
<p>在更新版本的 Linux kernel 中似乎还引入了一个偏移值，笔者尚未进行考证</p>
</blockquote>
<h4 id="Random-freelist"><a href="#Random-freelist" class="headerlink" title="Random freelist"></a>Random freelist</h4><p>这种保护主要发生在 slub allocator 向 buddy system 申请到页框之后的处理过程中，对于未开启这种保护的一张完整的 slub，其上的 object 的连接顺序是线性连续的，但在开启了这种保护之后其上的 object 之间的连接顺序是随机的，这让攻击者无法直接预测下一个分配的 object 的地址</p>
<p>需要注意的是这种保护发生在<strong>slub allocator 刚从 buddy system 拿到新 slub 的时候，运行时 freelist 的构成仍遵循 LIFO</strong></p>
<p><img src="https://s2.loli.net/2022/03/11/wQzINfhXV3gpGxJ.png" alt="image.png"></p>
<h1 id="0x01-Linux-Kernel-简易食用指南"><a href="#0x01-Linux-Kernel-简易食用指南" class="headerlink" title="0x01.Linux Kernel 简易食用指南"></a>0x01.Linux Kernel 简易食用指南</h1><h2 id="Pre-安装依赖"><a href="#Pre-安装依赖" class="headerlink" title="Pre.安装依赖"></a>Pre.安装依赖</h2><p>环境是Ubuntu20.04</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get update</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get install git fakeroot build-essential ncurses-dev xz-utils qemu flex libncurses5-dev fakeroot build-essential ncurses-dev xz-utils libssl-dev bc bison libglib2.0-dev libfdt-dev libpixman-1-dev zlib1g-dev libelf-dev</span></span><br></pre></td></tr></table></figure>

<h2 id="一、获取内核镜像（bzImage）"><a href="#一、获取内核镜像（bzImage）" class="headerlink" title="一、获取内核镜像（bzImage）"></a>一、获取内核镜像（bzImage）</h2><p>大概有如下三种方式：</p>
<ul>
<li>下载内核源码后编译</li>
<li>直接下载现成的的内核镜像，不过这样我们就不能自己魔改内核了2333</li>
<li>直接使用自己系统的镜像</li>
</ul>
<h3 id="方法一：自行编译内核源码"><a href="#方法一：自行编译内核源码" class="headerlink" title="方法一：自行编译内核源码"></a>方法一：自行编译内核源码</h3><h4 id="I-获取内核源码"><a href="#I-获取内核源码" class="headerlink" title="I.获取内核源码"></a>I.获取内核源码</h4><p>前往<a target="_blank" rel="noopener" href="https://www.kernel.org/">Linux Kernel Archive</a>下载对应版本的内核源码</p>
<p>笔者这里选用5.11这个版本的内核镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.11.tar.xz</span></span><br></pre></td></tr></table></figure>

<h4 id="II-配置编译选项"><a href="#II-配置编译选项" class="headerlink" title="II.配置编译选项"></a>II.配置编译选项</h4><p>解压我们下载来的内核源码</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar -xvf linux-5.11.tar.xz</span></span><br></pre></td></tr></table></figure>

<p>完成后进入文件夹内，执行如下命令开始配置编译选项</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make menuconfig</span></span><br></pre></td></tr></table></figure>

<p>进入如下配置界面</p>
<p><img src="https://i.loli.net/2021/02/21/YXVQhel4vjMHDSa.png" alt="image.png"></p>
<p>保证勾选如下配置（默认都是勾选了的）：</p>
<ul>
<li>Kernel hacking —&gt; Kernel debugging</li>
<li>Kernel hacking —&gt; Compile-time checks and compiler options —&gt; Compile the kernel with debug info</li>
<li>Kernel hacking —&gt; Generic Kernel Debugging Instruments –&gt; KGDB: kernel debugger</li>
<li>kernel hacking —&gt; Compile the kernel with frame pointers</li>
</ul>
<p>一般来说不需要有什么改动，直接保存退出即可</p>
<h4 id="III-开始编译"><a href="#III-开始编译" class="headerlink" title="III.开始编译"></a>III.开始编译</h4><p>运行如下命令开始编译，生成内核镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make bzImage</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以使用make bzImage -j4加速编译</p>
<p>笔者机器比较烂，大概要等一顿饭的时间…</p>
<p>以及编译内核会比较需要空间，一定要保证磁盘剩余空间充足</p>
<h5 id="可能出现的错误"><a href="#可能出现的错误" class="headerlink" title="可能出现的错误"></a>可能出现的错误</h5><p>笔者编译时出现过这个错误：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make[1]: *** No rule to make target &#x27;debian/canonical-certs.pem&#x27;, needed by &#x27;certs/x509_certificate_list&#x27;.  Stop</span><br></pre></td></tr></table></figure>

<p>只需要在 <code>.config</code> 文件中找到 <code>CONFIG_SYSTEM_TRUSTED_KEYS</code>，等于号后面的值改为 <code>&quot;&quot;</code></p>
<p><img src="https://i.loli.net/2021/04/08/kSBi5yhprCjqnfv.png" alt="image.png"></p>
<p>笔者还遇到过这个错误：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make[1]: *** No rule to make target &#x27;debian/canonical-revoked-certs.pem&#x27;, needed by &#x27;certs/x509_revocation_list&#x27;.  Stop.</span><br></pre></td></tr></table></figure>

<p>这时需要在 <code>.config</code> 文件中将 <code>CONFIG_SYSTEM_REVOCATION_KEYS</code> 项等号后面的值改为 <code>&quot;&quot;</code></p>
<p><img src="https://s2.loli.net/2022/02/15/CNogw1mDtyFlUJY.png" alt="image.png"></p>
<p>笔者在编译 4.4 版本的内核时还出现了如下错误：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc1: error: code model kernel does not support PIC mode</span><br></pre></td></tr></table></figure>

<p>这个时候只需要在Makefile文件中：</p>
<ul>
<li><code>KBUILD_CFLAGS</code> 的尾部添加选项 <code>-fno-pie</code></li>
<li><code>CC_USING_FENTRY</code> 项添加 <code>-fno-pic</code></li>
</ul>
<p>之后会出现另一个错误：<code>undefined reference to ____ilog2_NaN</code></p>
<p>这个时候在内核源码目录下创建 <code>patch.diff</code> 文件，输入如下内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/include/linux/log2.h b/include/linux/log2.h</span><br><span class="line">index ef3d4f67118c..c373295f359f <span class="number">100644</span></span><br><span class="line">--- a/include/linux/log2.h</span><br><span class="line">+++ b/include/linux/log2.h</span><br><span class="line">@@ <span class="number">-16</span>,<span class="number">12</span> +<span class="number">16</span>,<span class="number">6</span> @@</span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/bitops.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">- * deal with unrepresentable constant logarithms</span></span><br><span class="line"><span class="comment">- */</span></span><br><span class="line">-<span class="keyword">extern</span> __attribute__((<span class="type">const</span>, <span class="keyword">noreturn</span>))</span><br><span class="line">-<span class="type">int</span> ____ilog2_NaN(<span class="type">void</span>);</span><br><span class="line">-</span><br><span class="line">-<span class="comment">/*</span></span><br><span class="line"><span class="comment">  * non-constant log of base 2 calculators</span></span><br><span class="line"><span class="comment">  * - the arch may override these in asm/bitops.h if they can be implemented</span></span><br><span class="line"><span class="comment">  *   more efficiently than using fls() and fls64()</span></span><br><span class="line"><span class="comment">@@ -85,7 +79,7 @@ unsigned long __rounddown_pow_of_two(unsigned long n)</span></span><br><span class="line"><span class="comment"> #define ilog2(n)                \</span></span><br><span class="line"><span class="comment"> (                        \</span></span><br><span class="line"><span class="comment">     __builtin_constant_p(n) ? (        \</span></span><br><span class="line"><span class="comment">-        (n) &lt; 1 ? ____ilog2_NaN() :    \</span></span><br><span class="line"><span class="comment">+        (n) &lt; 2 ? 0 :            \</span></span><br><span class="line"><span class="comment">         (n) &amp; (1ULL &lt;&lt; 63) ? 63 :    \</span></span><br><span class="line"><span class="comment">         (n) &amp; (1ULL &lt;&lt; 62) ? 62 :    \</span></span><br><span class="line"><span class="comment">         (n) &amp; (1ULL &lt;&lt; 61) ? 61 :    \</span></span><br><span class="line"><span class="comment">@@ -148,10 +142,7 @@ unsigned long __rounddown_pow_of_two(unsigned long n)</span></span><br><span class="line"><span class="comment">         (n) &amp; (1ULL &lt;&lt;  4) ?  4 :    \</span></span><br><span class="line"><span class="comment">         (n) &amp; (1ULL &lt;&lt;  3) ?  3 :    \</span></span><br><span class="line"><span class="comment">         (n) &amp; (1ULL &lt;&lt;  2) ?  2 :    \</span></span><br><span class="line"><span class="comment">-        (n) &amp; (1ULL &lt;&lt;  1) ?  1 :    \</span></span><br><span class="line"><span class="comment">-        (n) &amp; (1ULL &lt;&lt;  0) ?  0 :    \</span></span><br><span class="line"><span class="comment">-        ____ilog2_NaN()            \</span></span><br><span class="line"><span class="comment">-                   ) :        \</span></span><br><span class="line"><span class="comment">+        1 ) :                \</span></span><br><span class="line"><span class="comment">     (sizeof(n) &lt;= 4) ?            \</span></span><br><span class="line"><span class="comment">     __ilog2_u32(n) :            \</span></span><br><span class="line"><span class="comment">     __ilog2_u64(n)                \</span></span><br><span class="line"><span class="comment">diff --git a/tools/include/linux/log2.h b/tools/include/linux/log2.h</span></span><br><span class="line"><span class="comment">index 41446668ccce..d5677d39c1e4 100644</span></span><br><span class="line"><span class="comment">--- a/tools/include/linux/log2.h</span></span><br><span class="line"><span class="comment">+++ b/tools/include/linux/log2.h</span></span><br><span class="line"><span class="comment">@@ -13,12 +13,6 @@</span></span><br><span class="line"><span class="comment"> #define _TOOLS_LINUX_LOG2_H</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> /*</span></span><br><span class="line"><span class="comment">- * deal with unrepresentable constant logarithms</span></span><br><span class="line"><span class="comment">- */</span></span><br><span class="line">-<span class="keyword">extern</span> __attribute__((<span class="type">const</span>, <span class="keyword">noreturn</span>))</span><br><span class="line">-<span class="type">int</span> ____ilog2_NaN(<span class="type">void</span>);</span><br><span class="line">-</span><br><span class="line">-<span class="comment">/*</span></span><br><span class="line"><span class="comment">  * non-constant log of base 2 calculators</span></span><br><span class="line"><span class="comment">  * - the arch may override these in asm/bitops.h if they can be implemented</span></span><br><span class="line"><span class="comment">  *   more efficiently than using fls() and fls64()</span></span><br><span class="line"><span class="comment">@@ -78,7 +72,7 @@ unsigned long __rounddown_pow_of_two(unsigned long n)</span></span><br><span class="line"><span class="comment"> #define ilog2(n)                \</span></span><br><span class="line"><span class="comment"> (                        \</span></span><br><span class="line"><span class="comment">     __builtin_constant_p(n) ? (        \</span></span><br><span class="line"><span class="comment">-        (n) &lt; 1 ? ____ilog2_NaN() :    \</span></span><br><span class="line"><span class="comment">+        (n) &lt; 2 ? 0 :            \</span></span><br><span class="line"><span class="comment">         (n) &amp; (1ULL &lt;&lt; 63) ? 63 :    \</span></span><br><span class="line"><span class="comment">         (n) &amp; (1ULL &lt;&lt; 62) ? 62 :    \</span></span><br><span class="line"><span class="comment">         (n) &amp; (1ULL &lt;&lt; 61) ? 61 :    \</span></span><br><span class="line"><span class="comment">@@ -141,10 +135,7 @@ unsigned long __rounddown_pow_of_two(unsigned long n)</span></span><br><span class="line"><span class="comment">         (n) &amp; (1ULL &lt;&lt;  4) ?  4 :    \</span></span><br><span class="line"><span class="comment">         (n) &amp; (1ULL &lt;&lt;  3) ?  3 :    \</span></span><br><span class="line"><span class="comment">         (n) &amp; (1ULL &lt;&lt;  2) ?  2 :    \</span></span><br><span class="line"><span class="comment">-        (n) &amp; (1ULL &lt;&lt;  1) ?  1 :    \</span></span><br><span class="line"><span class="comment">-        (n) &amp; (1ULL &lt;&lt;  0) ?  0 :    \</span></span><br><span class="line"><span class="comment">-        ____ilog2_NaN()            \</span></span><br><span class="line"><span class="comment">-                   ) :        \</span></span><br><span class="line"><span class="comment">+        1 ) :                \</span></span><br><span class="line"><span class="comment">     (sizeof(n) &lt;= 4) ?            \</span></span><br><span class="line"><span class="comment">     __ilog2_u32(n) :            \</span></span><br><span class="line"><span class="comment">     __ilog2_u64(n)                \</span></span><br></pre></td></tr></table></figure>

<p>然后在终端输入：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">patch -i patch.diff</span></span><br></pre></td></tr></table></figure>

<p>之后会提示让你输入 patch 的文件名，输入：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">include/linux/log2.h</span><br><span class="line">tools/include/linux/log2.h</span><br></pre></td></tr></table></figure>

<p>之后继续编译，又会出现一个新的问题：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Unsupported relocation type: R_X86_64_PLT32 (4)</span><br><span class="line">make[2]: *** [arch/x86/boot/compressed/Makefile:71: arch/x86/boot/compressed/vmlinux.relocs] Error 1</span><br><span class="line">make[1]: *** [arch/x86/boot/Makefile:112: arch/x86/boot/compressed/vmlinux] Error 2</span><br><span class="line">make: *** [arch/x86/Makefile:251: bzImage] Error 2</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>笔者实在忍不了了，换到Ubuntu 16进行编译…一遍过…</p>
<p>出现这种情况的原因主要是高版本的 gcc 更改了内部的一些相关机制，<del>只需要切换回老版本gcc即可正常编译</del></p>
</blockquote>
<p>完成之后会出现如下信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Kernel: arch/x86/boot/bzImage is ready  (#1)</span><br></pre></td></tr></table></figure>

<h5 id="vmlinux：原始内核文件"><a href="#vmlinux：原始内核文件" class="headerlink" title="vmlinux：原始内核文件"></a>vmlinux：原始内核文件</h5><p>在当前目录下提取到<code>vmlinux</code>，为编译出来的原始内核文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">file vmlinux</span></span><br><span class="line">vmlinux: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, BuildID[sha1]=f1fc85f87a5e6f3b5714dad93a8ac55fa7450e06, with debug_info, not stripped</span><br></pre></td></tr></table></figure>

<h5 id="bzImage：压缩内核镜像"><a href="#bzImage：压缩内核镜像" class="headerlink" title="bzImage：压缩内核镜像"></a>bzImage：压缩内核镜像</h5><p>在当前目录下的<code>arch/x86/boot/</code>目录下提取到<code>bzImage</code>，为压缩后的内核文件，适用于大内核</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">file <span class="built_in">arch</span>/x86/boot/bzImage</span></span><br><span class="line">arch/x86/boot/bzImage: Linux kernel x86 boot executable bzImage, version 5.11.0 (root@iZf3ye3at4zthpZ) #1 SMP Sun Feb 21 21:44:35 CST 2021, RO-rootFS, swap_dev 0xB, Normal VGA</span><br></pre></td></tr></table></figure>

<blockquote>
<h6 id="zImage-amp-amp-bzImage"><a href="#zImage-amp-amp-bzImage" class="headerlink" title="zImage &amp;&amp; bzImage"></a>zImage &amp;&amp; bzImage</h6><p> zImage–是vmlinux经过gzip压缩后的文件。<br>bzImage–bz表示“big zImage”，不是用bzip2压缩的，而是要偏移到一个位置，使用gzip压缩的。两者的不同之处在于，zImage解压缩内核到低端内存(第一个 640K)，bzImage解压缩内核到高端内存(1M以上)。如果内核比较小，那么采用zImage或bzImage都行，如果比较大应该用bzImage。 </p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xiaotengyi2012/article/details/8582886">https://blog.csdn.net/xiaotengyi2012/article/details/8582886</a></p>
</blockquote>
<h4 id="EXTRA-添加系统调用"><a href="#EXTRA-添加系统调用" class="headerlink" title="EXTRA.添加系统调用"></a>EXTRA.添加系统调用</h4><blockquote>
<p> 请先阅读完「0x01.四 」之后再回来看本节内容~</p>
</blockquote>
<h5 id="I-分配系统调用号"><a href="#I-分配系统调用号" class="headerlink" title="I.分配系统调用号"></a>I.分配系统调用号</h5><p>在<code>arch/x86/entry/syscalls/syscall_64.tbl</code>中添加我们自己的系统调用号，这里用笔者个人比较喜欢的数字<code>114514</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">114514    64    arttnba3_test        sys_arttnba3_test</span><br></pre></td></tr></table></figure>

<h5 id="II-声明系统调用"><a href="#II-声明系统调用" class="headerlink" title="II.声明系统调用"></a>II.声明系统调用</h5><p>在<code>include/linux/syscalls.h</code>中添加如下函数声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* for arttnba3&#x27;s personal syscall test */</span></span><br><span class="line">asmlinkage <span class="type">long</span> <span class="title function_">sys_arttnba3_test</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<h5 id="III-添加系统调用函数定义"><a href="#III-添加系统调用函数定义" class="headerlink" title="III.添加系统调用函数定义"></a>III.添加系统调用函数定义</h5><p>在<code>kernel/sys.c</code>中添加如下代码（放置于最后一行的<code>#endif /* CONFIG_COMPAT */</code>之前）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE0(arttnba3_test)</span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;arttnba3\&#x27;s personal syscall has been called!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">114514</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>SYSCALL_DEFINE0()</code>本质上是一个宏，意为<strong>接收0个参数的系统调用</strong>，其第一个参数为系统调用名</p>
<p>笔者定义了一个简单的输出一句话的系统调用，在这里使用了内核态的<code>printk()</code>函数，输出的信息可以使用<code>dmesg</code>进行查看</p>
<h5 id="IV-重新编译内核"><a href="#IV-重新编译内核" class="headerlink" title="IV.重新编译内核"></a>IV.重新编译内核</h5><p>这一步参照之前的步骤即可，通过这一步我们要将我们自己的系统调用编译到内核当中</p>
<h5 id="V-测试系统调用"><a href="#V-测试系统调用" class="headerlink" title="V.测试系统调用"></a>V.测试系统调用</h5><p>我们使用如下的例程测试我们的新系统调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    syscall(<span class="number">114514</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译，放入磁盘镜像中后重新打包，qemu起内核后尝试运行我们的例程，结果如下：</p>
<blockquote>
<p>因为dmesg输出的东西太多，这里还附加用了grep命令过滤</p>
</blockquote>
<p><img src="https://i.loli.net/2021/02/24/Zx4wOlkRpoHfSVu.png" alt="image.png"></p>
<p>可以看到，我们的系统调用<code>arttnba3_test</code>被成功地嵌入了内核当中，并成功地被测试例程所调用，撒花~🌸</p>
<h3 id="方法二：下载现有内核镜像"><a href="#方法二：下载现有内核镜像" class="headerlink" title="方法二：下载现有内核镜像"></a>方法二：下载现有内核镜像</h3><p>我们也可以自己下载现有的内核镜像，而不需要自行编译一整套Linux内核</p>
<p>使用如下命令列出可下载内核镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt search linux-image-</span> </span><br></pre></td></tr></table></figure>

<p>选一个自己喜欢的下载就行，笔者所用的阿里云源似乎没有最新的5.11的镜像，这里用5.8的做个示范：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt download linux-image-5.8.0-43-generic</span></span><br></pre></td></tr></table></figure>

<p>下载下来是一个deb文件，解压</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">dpkg -X ./linux-image-5.8.0-43-generic_5.8.0-43.49~20.04.1_amd64.deb extract</span></span><br><span class="line">./</span><br><span class="line">./boot/</span><br><span class="line">./boot/vmlinuz-5.8.0-43-generic</span><br><span class="line">./usr/</span><br><span class="line">./usr/share/</span><br><span class="line">./usr/share/doc/</span><br><span class="line">./usr/share/doc/linux-image-5.8.0-43-generic/</span><br><span class="line">./usr/share/doc/linux-image-5.8.0-43-generic/changelog.Debian.gz</span><br><span class="line">./usr/share/doc/linux-image-5.8.0-43-generic/copyright</span><br></pre></td></tr></table></figure>

<p>其中的<code>./boot/vmlinuz-5.8.0-43-generic</code>便是<code>bzImage</code>内核镜像文件</p>
<h3 id="方法三：使用系统内核镜像"><a href="#方法三：使用系统内核镜像" class="headerlink" title="方法三：使用系统内核镜像"></a>方法三：使用系统内核镜像</h3><p>一般位于<code>/boot/</code>目录下，也可以直接拿出来用</p>
<h2 id="二、获取busybox"><a href="#二、获取busybox" class="headerlink" title="二、获取busybox"></a>二、获取busybox</h2><p> BusyBox 是一个集成了三百多个最常用Linux命令和工具的软件，包含了例如ls、cat和echo等一些简单的工具</p>
<p>后续构建磁盘镜像我们需要用到busybox</p>
<h3 id="编译busybox"><a href="#编译busybox" class="headerlink" title="编译busybox"></a>编译busybox</h3><h4 id="I-获取busybox源码"><a href="#I-获取busybox源码" class="headerlink" title="I.获取busybox源码"></a>I.获取busybox源码</h4><p>在<a target="_blank" rel="noopener" href="https://busybox.net/downloads/">busybox.net</a>下载自己想要的版本，笔者这里选用<code>busybox-1.33.0.tar.bz2</code>这个版本</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget https://busybox.net/downloads/busybox-1.33.0.tar.bz2</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>外网下载的速度可能会比较慢，可以在前面下载Linux源码的时候一起下载，也可以选择去国内的镜像站下载</p>
</blockquote>
<p>解压</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar -jxvf busybox-1.33.0.tar.bz2</span></span><br></pre></td></tr></table></figure>

<h4 id="II-编译busybox源码"><a href="#II-编译busybox源码" class="headerlink" title="II.编译busybox源码"></a>II.编译busybox源码</h4><p>进入配置界面</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make menuconfig</span></span><br></pre></td></tr></table></figure>

<p>勾选Settings —&gt; Build static binary file (no shared lib)</p>
<blockquote>
<p> 若是不勾选则需要单独配置lib，比较麻烦</p>
</blockquote>
<p>接下来就是编译了，速度会比编译内核快很多</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make install</span></span><br></pre></td></tr></table></figure>

<p>编译完成后会生成一个<code>_install</code>目录，接下来我们将会用它来构建我们的磁盘镜像</p>
<h2 id="三、构建磁盘镜像"><a href="#三、构建磁盘镜像" class="headerlink" title="三、构建磁盘镜像"></a>三、构建磁盘镜像</h2><h3 id="建立文件系统"><a href="#建立文件系统" class="headerlink" title="建立文件系统"></a>建立文件系统</h3><h4 id="I-初始化文件系统"><a href="#I-初始化文件系统" class="headerlink" title="I.初始化文件系统"></a>I.初始化文件系统</h4><p>一些简单的初始化操作…</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> _install</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> -pv &#123;bin,sbin,etc,proc,sys,home,lib64,lib/x86_64-linux-gnu,usr/&#123;bin,sbin&#125;&#125;</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">touch</span> etc/inittab</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> etc/init.d</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">touch</span> etc/init.d/rcS</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> +x ./etc/init.d/rcS</span></span><br></pre></td></tr></table></figure>

<h4 id="II-配置初始化脚本"><a href="#II-配置初始化脚本" class="headerlink" title="II.配置初始化脚本"></a>II.配置初始化脚本</h4><p>首先配置<code>etc/inttab</code>，写入如下内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">::sysinit:/etc/init.d/rcS</span><br><span class="line">::askfirst:/bin/ash</span><br><span class="line">::ctrlaltdel:/sbin/reboot</span><br><span class="line">::shutdown:/sbin/swapoff -a</span><br><span class="line">::shutdown:/bin/umount -a -r</span><br><span class="line">::restart:/sbin/init</span><br></pre></td></tr></table></figure>

<p>在上面的文件中指定了系统初始化脚本，因此接下来配置<code>etc/init.d/rcS</code>，写入如下内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sys none /sys</span><br><span class="line">/bin/mount -n -t sysfs none /sys</span><br><span class="line">/bin/mount -t ramfs none /dev</span><br><span class="line">/sbin/mdev -s</span><br></pre></td></tr></table></figure>

<p>主要是配置各种目录的挂载</p>
<p>也可以在根目录下创建<code>init</code>文件，写入如下内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t devtmpfs devtmpfs /dev</span><br><span class="line"></span><br><span class="line">exec 0&lt;/dev/console</span><br><span class="line">exec 1&gt;/dev/console</span><br><span class="line">exec 2&gt;/dev/console</span><br><span class="line"></span><br><span class="line">echo -e &quot;\nBoot took $(cut -d&#x27; &#x27; -f1 /proc/uptime) seconds\n&quot;</span><br><span class="line">setsid cttyhack setuidgid 1000 sh</span><br><span class="line"></span><br><span class="line">umount /proc</span><br><span class="line">umount /sys</span><br><span class="line">poweroff -d 0  -f</span><br></pre></td></tr></table></figure>

<p>别忘了添加可执行权限：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> +x ./init</span></span><br></pre></td></tr></table></figure>

<h4 id="III-配置用户组"><a href="#III-配置用户组" class="headerlink" title="III.配置用户组"></a>III.配置用户组</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;root:x:0:0:root:/root:/bin/sh&quot;</span> &gt; etc/passwd</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;ctf:x:1000:1000:ctf:/home/ctf:/bin/sh&quot;</span> &gt;&gt; etc/passwd</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;root:x:0:&quot;</span> &gt; etc/group</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;ctf:x:1000:&quot;</span> &gt;&gt; etc/group</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;none /dev/pts devpts gid=5,mode=620 0 0&quot;</span> &gt; etc/fstab</span></span><br></pre></td></tr></table></figure>

<p>在这里建立了两个用户组<code>root</code>和<code>ctf</code>，以及两个用户<code>root</code>和<code>ctf</code></p>
<h4 id="IV-配置glibc库"><a href="#IV-配置glibc库" class="headerlink" title="IV.配置glibc库"></a>IV.配置glibc库</h4><p>将需要的动态链接库拷到相应位置即可</p>
<blockquote>
<p>为了方便笔者这里就先不弄了，直接快进到下一步，以后有时间再补充（咕咕咕</p>
</blockquote>
<h3 id="打包文件系统为镜像文件"><a href="#打包文件系统为镜像文件" class="headerlink" title="打包文件系统为镜像文件"></a>打包文件系统为镜像文件</h3><p>使用如下命令打包文件系统</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find . | cpio -o --format=newc &gt; ../../rootfs.cpio</span></span><br></pre></td></tr></table></figure>

<p>也可以这么写</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find . | cpio -o -H newc &gt; ../core.cpio</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里的位置是笔者随便选的，也可以将之放到自己喜欢的位置</p>
</blockquote>
<h3 id="向文件系统中添加文件"><a href="#向文件系统中添加文件" class="headerlink" title="向文件系统中添加文件"></a>向文件系统中添加文件</h3><p>若是我们后续需要向文件系统中补充一些其他的文件，可以选择在原先的<code>_install</code>文件夹中添加（不过这样的话若是配置多个文件系统则会变得很混乱），也可以解压文件系统镜像后添加文件再重新进行打包</p>
<h4 id="I-解压磁盘镜像"><a href="#I-解压磁盘镜像" class="headerlink" title="I.解压磁盘镜像"></a>I.解压磁盘镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cpio -idv &lt; ./rootfs.cpio</span></span><br></pre></td></tr></table></figure>

<p>该命令会将磁盘镜像中的所有文件解压到当前目录下</p>
<h4 id="II-重打包磁盘镜像"><a href="#II-重打包磁盘镜像" class="headerlink" title="II.重打包磁盘镜像"></a>II.重打包磁盘镜像</h4><p>和打包磁盘镜像的命令一样</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find . | cpio -o --format=newc &gt; ../new_rootfs.cpio</span></span><br></pre></td></tr></table></figure>

<h2 id="四、使用qemu运行内核"><a href="#四、使用qemu运行内核" class="headerlink" title="四、使用qemu运行内核"></a>四、使用qemu运行内核</h2><p>终于到了最激动人心的时候了：<strong>我们即将要将这个Linux内核跑起来——用我们自己配置的文件系统与内核</strong></p>
<p>安全起见，我们并不直接在真机上运行这个内核，而是使用qemu在虚拟机里运行</p>
<h3 id="配置启动脚本"><a href="#配置启动脚本" class="headerlink" title="配置启动脚本"></a>配置启动脚本</h3><p>首先将先前的<code>bzImage</code>和<code>rootfs.cpio</code>放到同一个目录下</p>
<p>接下来编写启动脚本</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">touch</span> boot.sh</span></span><br></pre></td></tr></table></figure>

<p>写入如下内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -m 128M \</span><br><span class="line">    -kernel ./bzImage \</span><br><span class="line">    -initrd  ./rootfs.cpio \</span><br><span class="line">    -monitor /dev/null \</span><br><span class="line">    -append &quot;root=/dev/ram rdinit=/sbin/init console=ttyS0 oops=panic panic=1 loglevel=3 quiet nokaslr&quot; \</span><br><span class="line">    -cpu kvm64,+smep \</span><br><span class="line">    -smp cores=2,threads=1 \</span><br><span class="line">    -netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \</span><br><span class="line">    -nographic \</span><br><span class="line">    -s</span><br></pre></td></tr></table></figure>

<p>部分参数说明如下：</p>
<ul>
<li><code>-m</code>：虚拟机内存大小</li>
<li><code>-kernel</code>：内存镜像路径</li>
<li><code>-initrd</code>：磁盘镜像路径</li>
<li><code>-append</code>：附加参数选项<ul>
<li><code>nokalsr</code>：关闭内核地址随机化，方便我们进行调试</li>
<li><code>rdinit</code>：指定初始启动进程，<code>/sbin/init</code>进程会默认以<code>/etc/init.d/rcS</code>作为启动脚本</li>
<li><code>loglevel=3 </code> &amp; <code>quiet</code>：不输出log</li>
<li><code>console=ttyS0</code>：指定终端为<code>/dev/ttyS0</code>，这样一启动就能进入终端界面</li>
</ul>
</li>
<li><code>-monitor</code>：将监视器重定向到主机设备<code>/dev/null</code>，这里重定向至null主要是防止CTF中被人给偷了qemu拿flag</li>
<li><code>-cpu</code>：设置CPU安全选项，在这里开启了smep保护</li>
<li><code>-s</code>：相当于<code>-gdb tcp::1234</code>的简写（也可以直接这么写），后续我们可以通过gdb连接本地端口进行调试</li>
</ul>
<p>运行<code>boot.sh</code>，成功启动~撒花~🌸🌸🌸</p>
<p><img src="https://i.loli.net/2021/02/22/Aj9sYfLCrgZFVxI.png" alt="image.png"></p>
<blockquote>
<p>在这里遇到了一条报错信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount: mounting none on /sys failed: No such device</span><br></pre></td></tr></table></figure>

<p>暂且没查到原因…</p>
</blockquote>
<h2 id="五、编写可装载内核模块（LKMs）"><a href="#五、编写可装载内核模块（LKMs）" class="headerlink" title="五、编写可装载内核模块（LKMs）"></a>五、编写可装载内核模块（LKMs）</h2><blockquote>
<p>写这一部分把我的虚拟机搞崩了好几次…Or2</p>
</blockquote>
<p>我们的Linux kernel虽然成功启动了，但是其本身的功能似乎有些单调，那么我们不如自己编写可装载内核模块（Loadable Kernel Modules）来扩充内核的功能吧！</p>
<h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><p>前面我们讲到，LKM同样是ELF格式文件，但是其不能够独立运行，而只能作为内核的一部分存在</p>
<p>同样的，对于LKM而言，其所处在的内核空间与用户空间是分开的，对于通常有着SMAP&#x2F;SMEP保护的Linux而言，这意味着<strong>LKM并不能够使用libc中的函数，也不能够直接与用户进行交互</strong></p>
<p>虽然我们同样能够使用C语言编写LKM，但是作为内核的一部分，LKM编程在一定意义上便是内核编程， 内核版本的每次变化意味着某些函数名也会相应地发生变化，因此LKM编程与内核版本密切相关 </p>
<h3 id="简单的测试模块"><a href="#简单的测试模块" class="headerlink" title="简单的测试模块"></a>简单的测试模块</h3><p>我们来编写这样一个简单的内核模块，在载入&#x2F;卸载时会通过<code>printk()</code>在内核缓冲区进行输出：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* hellokernel.c</span></span><br><span class="line"><span class="comment">* developed by arttnba3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">kernel_module_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;&lt;1&gt;Hello the Linux kernel world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">kernel_module_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;&lt;1&gt;Good bye the Linux kernel world! See you again!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(kernel_module_init);</span><br><span class="line">module_exit(kernel_module_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;arttnba3&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h4><ul>
<li><code>linux/module.h</code>：对于LKM而言这是必须包含的一个头文件</li>
<li><code>linux/kernel.h</code>：载入内核相关信息</li>
<li><code>linux/init.h</code>：包含着一些有用的宏</li>
</ul>
<p>通常情况下，这三个头文件对于内核模块编程都是不可或缺的</p>
<h4 id="入口点-x2F-出口点"><a href="#入口点-x2F-出口点" class="headerlink" title="入口点&#x2F;出口点"></a>入口点&#x2F;出口点</h4><p>一个内核模块的入口点应当为<code> module_init()</code>，出口函数应当为<code>module_exit()</code>，在内核载入&#x2F;卸载内核模块时会缺省调用这两个函数</p>
<p>在这里我们将自定义的两个函数的指针作为参数传入LKM入口函数&#x2F;出口函数中，以作为其入口&#x2F;出口函数</p>
<h4 id="其他…"><a href="#其他…" class="headerlink" title="其他…"></a>其他…</h4><ul>
<li><code>__init &amp; __exit</code>：这两个宏用以在函数结束后释放相应的内存</li>
<li><code>MODULE_AUTHOR() &amp; MODULE_LICENSE()</code>：声明内核作者与发行所用许可证</li>
<li><code>printk()</code>：内核态函数，用以在内核缓冲区写入信息，其中<code>&lt;1&gt;</code>标识着信息的紧急级别（一共有8个优先级，0为最高，相关宏定义于linux&#x2F;kernel.h中）</li>
</ul>
<h3 id="编译内核模块：makefile"><a href="#编译内核模块：makefile" class="headerlink" title="编译内核模块：makefile"></a>编译内核模块：makefile</h3><p>与一般的可执行文件所不同的是，我们应当使用makefile来构建一个内核模块</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">obj-m += hellokernel.o</span><br><span class="line">CURRENT_PATH := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line">LINUX_KERNEL := <span class="variable">$(<span class="built_in">shell</span> uname -r)</span></span><br><span class="line">LINUX_KERNEL_PATH := /usr/src/linux-headers-<span class="variable">$(LINUX_KERNEL)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(LINUX_KERNEL_PATH)</span> M=<span class="variable">$(CURRENT_PATH)</span> modules</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(LINUX_KERNEL_PATH)</span> M=<span class="variable">$(CURRENT_PATH)</span> clean</span><br></pre></td></tr></table></figure>

<p>关于makefile的编写方式在网上有着很多教程，笔者在这里便不再赘叙，只简单说明一下这个makefile：</p>
<ul>
<li><code>obj-m</code>： 指定了编译的结果应当为<code>.ko</code>文件，即可装载内核模块，类似命令有： <code>obj-y</code> 编译进内核 ，<code>obj-n</code> 不编译 </li>
<li><code>CURRENT_PATH &amp; LINUX_KERNEL &amp; LINUX_KERNEL_PATH</code>：三个自定义变量，分别意味着通过shell命令获得当前路径、内核版本、内核源码路径</li>
<li><code>all</code>：编译指令</li>
<li><code>clean</code>：清理指令</li>
</ul>
<p>将以上内容写入当前目录下一个名为<code>makefile</code>的文件后，在终端执行如下指令，我们的内核模块就会自动进行构建</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br></pre></td></tr></table></figure>

<p>随后会输出如下信息，标志着内核模块的编译顺利完成</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">make -C /usr/src/linux-headers-5.8.0-43-generic M=/home/arttnba3/Music modules</span><br><span class="line">make[1]: Entering directory &#x27;/usr/src/linux-headers-5.8.0-43-generic&#x27;</span><br><span class="line">  CC [M]  /home/arttnba3/Music/hellokernel.o</span><br><span class="line">  MODPOST /home/arttnba3/Music/Module.symvers</span><br><span class="line">  CC [M]  /home/arttnba3/Music/hellokernel.mod.o</span><br><span class="line">  LD [M]  /home/arttnba3/Music/hellokernel.ko</span><br><span class="line">make[1]: Leaving directory &#x27;/usr/src/linux-headers-5.8.0-43-generic&#x27;</span><br></pre></td></tr></table></figure>

<p>测试一下，内核模块成功运行，撒花~🌸</p>
<p><img src="https://i.loli.net/2021/02/28/vJitGgkFTzcPx8a.png" alt="image.png"></p>
<h3 id="提供应用程式I-x2F-O接口"><a href="#提供应用程式I-x2F-O接口" class="headerlink" title="提供应用程式I&#x2F;O接口"></a>提供应用程式I&#x2F;O接口</h3><p>虽然说我们的新模块成功跑起来了，但是除了在内核缓冲区进行输入输出以外好像就做不了什么了，我们希望我们写的内核模块能够向我们提供更多的功能并能够让用户与其进行交互，以发挥更多的作用</p>
<h4 id="I-设备注册"><a href="#I-设备注册" class="headerlink" title="I.设备注册"></a>I.设备注册</h4><p>前面讲到，*NIX&#x2F;Linux的哲学之一便是<code>万物皆文件</code>，<strong>一切都可以被抽象为文件，一切都可以使用访问文件的方式进行操作</strong>，这提供了高层次上的操作一致性</p>
<p>同样地，我们若是想要能够与我们的内核模块进行交互，则同样可以通过文件进行——注册一个“虚拟设备节点”，随后我们的用户态程序便可以使用系统调用<code>read、write、ioctl</code>来完成与内核模块间的通信</p>
<h5 id="设备分类"><a href="#设备分类" class="headerlink" title="设备分类"></a>设备分类</h5><p>在Linux中I&#x2F;O设备分为如下两类：</p>
<ul>
<li><code>字符设备</code>：在I&#x2F;O传输过程中<strong>以字符为单位</strong>进行传输的设备，例如键盘、串口等。字符设备<strong>按照字符流的方式被有序访问，不能够进行随机读取</strong></li>
<li><code>块设备</code>：在块设备中，信息被存储在固定大小的块中，每个块有着自己的地址，例如硬盘、SD卡等。用户可以对块设备进行<strong>随机访问——从任意位置读取一定长度的数据</strong></li>
</ul>
<h5 id="file-operations结构体"><a href="#file-operations结构体" class="headerlink" title="file_operations结构体"></a>file_operations结构体</h5><p>在注册设备之前，我们需要用到一个结构体——<code>file_operations</code>来完成对设备的一些相关定义，该结构体定义于<code>include/linux/fs.h</code>中，相关源码比较长不在此贴出，在其中定义了大量的函数指针</p>
<blockquote>
<p> 笔者感觉作用类似于OOP中的<strong>接口类</strong>，或者是虚函数表</p>
</blockquote>
<p>一个文件应当拥有一个<code>file_operations实例</code>，并指定相关系统调用函数指针所指向的自定义函数，在后续进行设备的注册时会使用该结构体</p>
<h5 id="主设备号-amp-次设备号"><a href="#主设备号-amp-次设备号" class="headerlink" title="主设备号 &amp; 次设备号"></a>主设备号 &amp; 次设备号</h5><p>在Linux内核中，使用类型<code>dev_t</code>（unsigned long）来标识一个设备的设备号</p>
<p>一个字符的设备号由<code>主设备号</code>与<code>次设备号</code>组成，高字节存储主设备号，低字节存储次设备号：</p>
<ul>
<li><code>主设备号</code>：标识设备类型，使用宏<code>MAJOR(dev_t dev)</code>可以获取主设备号</li>
<li><code>次设备号</code>：用以区分同类型设备，使用宏<code>MINOR(dev_t dev)</code>可以获取次设备号</li>
</ul>
<p>Linux还提供了一个宏<code> MKDEV(int major, int minor);</code>，用以通过主次设备号生成对应的设备号</p>
<h5 id="设备节点（struct-device-node-amp-struct-device）"><a href="#设备节点（struct-device-node-amp-struct-device）" class="headerlink" title="设备节点（struct device_node &amp; struct device）"></a>设备节点（struct device_node &amp; struct device）</h5><p>基于“万物皆文件”的设计思想，Linux中所有的设备都以文件的形式进行访问，这些文件存放在<code>/dev</code>目录下，一个文件就是一个<strong>设备节点</strong></p>
<p>在Linux kernel中使用结构体<code>device</code>描述一个设备，该结构体定义于<code>include/linux/device.h</code>（内核源码路径）中，<strong>每个设备在内核中都有着其对应的device实例，其中记录着设备的相关信息</strong></p>
<p>在DTS（Device Tree Source，设备树）中则使用<code>device_node</code>结构体表示一个设备</p>
<h5 id="设备类（struct-class）"><a href="#设备类（struct-class）" class="headerlink" title="设备类（struct class）"></a>设备类（struct class）</h5><p>在Linux kernel中使用结构体<code>class</code>用以表示<strong>高层次抽象的设备</strong>，该结构体定义于<code>include/linux/device/class.h</code>中</p>
<p>每个设备节点实例中都应当包含着一个指向相应设备类实例的指针</p>
<h5 id="设备的注册与注销"><a href="#设备的注册与注销" class="headerlink" title="设备的注册与注销"></a>设备的注册与注销</h5><p>方便起见，我们接下来将会注册一个<strong>字符型设备</strong>，大致的一个步骤如下：</p>
<ul>
<li><p>使用由内核提供的函数<code>register_chrdev(unsigned int major, const char *name, const struct file_operations *fops)</code>进行字符型设备注册，该函数定义于<code>include/linux/fs.h</code>，会将注册成功后的主设备号返回，若失败则会返回一个负值，参数说明如下：</p>
<ul>
<li>major：主设备号，若为0则由内核分配主设备号</li>
<li>name：设备名，由用户指定</li>
<li>fops：该设备的文件操作系统（file_operations结构体）指针</li>
</ul>
</li>
<li><p>使用宏<code>class_create(owner, name)</code>创建<strong>设备类</strong>，该宏定义于<code>include/linux/device.h</code>中，其核心调用函数是<code>__class_create(struct module *owner, const char *name, struct lock_class_key *key)</code></p>
</li>
<li><p>使用函数<code>device_create(struct class *cls, struct device *parent, dev_t devt, void *drvdata, const char *fmt, ...)</code><strong>创建设备节点</strong>，若成功则最终会在<code>/dev</code>目录下生成我们的设备节点文件，各参数说明如下：</p>
<ul>
<li>cls：该设备的设备类</li>
<li>parent：该设备的父设备节点，通常情况下应当为某种总线或主机控制器，若该设备为顶级设备则设为NULL</li>
<li>devt：该设备的设备号</li>
<li>drvdata：该驱动的相关信息，若无则填NULL</li>
<li>fmt：设备名称</li>
</ul>
</li>
</ul>
<p>设备的注销则是逆着上面的进程进行，同样有着相对应的三个函数：<code>device_destroy(struct class *cls, dev_t devt)</code>、<code>class_destroy(struct class *cls)</code>、<code>unregister_chrdev(unsigned int major, const char *name)</code>，用法相似，这里就不一一赘叙了</p>
<p>✳ 需要注意的是<strong>若是注册设备的进程中的某一步出错了，我们在退出内核态函数之前应当手动调用注销函数清理原先的相关资源</strong></p>
<h5 id="设备权限"><a href="#设备权限" class="headerlink" title="设备权限"></a>设备权限</h5><p>内核模块运行在内核空间，所创建的设备节点只有root用户才有权限进行读写，对于其他用户而言便毫无意义，这并不是我们想要的，因此我们需要通过进一步的设置使得所有用户都有权限通过设备节点文件与我们的内核模块进行交互</p>
<p>在内核中使用<code>inode</code>结构体表示一个文件，该结构体定义于<code>include/linux/fs.h</code>中，其中用以标识权限的是成员<code>i_mode</code></p>
<p>而在内核中对于使用<code>flip_open()</code>打开的文件，Linux内核中使用 <code>file</code> 结构体进行描述，该结构体定义于<code>include/linux/fs.h</code>中，其中有着指向内核中该文件的 inode 实例的指针，使用<code>file_inode()</code>函数可以获得一个 file 结构体中的 inode 结构体指针</p>
<p>那么我们不难想到，若是在内核模块中使用<code>file_open()</code>函数打开我们的设备节点文件，随后修改 file 结构体中的 inode 指针指向的 inode 实例的 i_mode 成员，便能够修改该文件的权限</p>
<blockquote>
<p>需要注意的是rwx三个权限位仅占3位，因而应当使用八进制进行操作：<code>__inode-&gt;i_mode |= 0666;</code>，而不是16进制</p>
</blockquote>
<p>最终的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* arttnba3_module.ko</span></span><br><span class="line"><span class="comment">* developed by arttnba3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_NAME <span class="string">&quot;a3device&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_PATH <span class="string">&quot;/dev/a3device&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLASS_NAME <span class="string">&quot;a3module&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major_num;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> * <span class="title">module_class</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">device</span> * <span class="title">module_device</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file</span> * __<span class="title">file</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> * __<span class="title">inode</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">a3_module_fo</span> =</span> </span><br><span class="line">&#123;</span><br><span class="line">    .owner = THIS_MODULE</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">kernel_module_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;[arttnba3_TestModule:] Module loaded. Start to register device...\n&quot;</span>);</span><br><span class="line">    major_num = register_chrdev(<span class="number">0</span>, DEVICE_NAME, &amp;a3_module_fo);</span><br><span class="line">    <span class="keyword">if</span> (major_num &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_INFO <span class="string">&quot;[arttnba3_TestModule:] Failed to register a major number.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> major_num;</span><br><span class="line">    &#125;    </span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;[arttnba3_TestModule:] Register complete, major number: %d\n&quot;</span>, major_num);</span><br><span class="line"></span><br><span class="line">    module_class = class_create(THIS_MODULE, CLASS_NAME);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(module_class))</span><br><span class="line">    &#123;</span><br><span class="line">        unregister_chrdev(major_num, DEVICE_NAME);</span><br><span class="line">        printk(KERN_INFO <span class="string">&quot;[arttnba3_TestModule:] Failed to register class device!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(module_class);</span><br><span class="line">    &#125;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;[arttnba3_TestModule:] Class device register complete.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    module_device = device_create(module_class, <span class="literal">NULL</span>, MKDEV(major_num, <span class="number">0</span>), <span class="literal">NULL</span>, DEVICE_NAME);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(module_device))</span><br><span class="line">    &#123;</span><br><span class="line">        class_destroy(module_class);</span><br><span class="line">        unregister_chrdev(major_num, DEVICE_NAME);</span><br><span class="line">        printk(KERN_INFO <span class="string">&quot;[arttnba3_TestModule:] Failed to create the device!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(module_device);</span><br><span class="line">    &#125;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;[arttnba3_TestModule:] Module register complete.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    __file = filp_open(DEVICE_PATH, O_RDONLY, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(__file))</span><br><span class="line">    &#123;</span><br><span class="line">        device_destroy(module_class, MKDEV(major_num, <span class="number">0</span>));</span><br><span class="line">        class_destroy(module_class);</span><br><span class="line">        unregister_chrdev(major_num, DEVICE_NAME);</span><br><span class="line">        printk(KERN_INFO <span class="string">&quot;[arttnba3_TestModule:] Unable to change module privilege!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(__file);</span><br><span class="line">    &#125;</span><br><span class="line">    __inode = file_inode(__file);</span><br><span class="line">    __inode-&gt;i_mode |= <span class="number">0666</span>;</span><br><span class="line">    filp_close(__file, <span class="literal">NULL</span>);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;[arttnba3_TestModule:] Module privilege change complete.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">kernel_module_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;[arttnba3_TestModule:] Start to clean up the module.\n&quot;</span>);</span><br><span class="line">    device_destroy(module_class, MKDEV(major_num, <span class="number">0</span>));</span><br><span class="line">    class_destroy(module_class);</span><br><span class="line">    unregister_chrdev(major_num, DEVICE_NAME);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;[arttnba3_TestModule:] Module clean up complete. See you next time.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(kernel_module_init);</span><br><span class="line">module_exit(kernel_module_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;arttnba3&quot;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在这里我们用到了一个函数<code>IS_ERR()</code>，定义于<code>include/linux/err.h</code>中，其核心为宏<code>IS_ERR_VALUE()</code>，即对于内核中的一些操作（如创建设备节点等）若是失败，则通常会返回一个小于<code>-4095</code>的负值，该函数用以进行判定</p>
</blockquote>
<p>编译，测试，我们的内核模块成功地注册了一个名叫<code>a3device</code>的设备并成功注册到了<code>/dev</code>目录下，撒花~🌸</p>
<p><img src="https://i.loli.net/2021/03/03/OvpTyoHU3A5cxtW.png" alt="image.png"></p>
<p>接下来我们只要为内核模块编写相应的API，便可以在用户态应用程式上通过虚拟设备<code>/dev/a3device</code>完成与内核模块间的通信</p>
<h4 id="II-编写系统调用接口函数"><a href="#II-编写系统调用接口函数" class="headerlink" title="II.编写系统调用接口函数"></a>II.编写系统调用接口函数</h4><p>我们编写如下的三个简单的函数使得用户应用程式可以通过<code>open、close、read、write、ioctl</code>与其进行交互</p>
<p>在这里我们引入了自旋锁<code>spinlock_t</code>类型变量以增加对多线程的支持</p>
<p>需要注意的是file_operations结构体中ioctl的函数指针应当为<code>unlocked_ioctl</code>，close对应的函数指针应当为<code>release</code></p>
<p>✳ 以及<strong>内核空间与用户空间之间传递数据应当使用</strong><code>copy_from_user(void *to, const void *from, unsigned long n)、copy_to_user(void *to, const void *from, unsigned long n)</code>函数</p>
<p>最终的代码如下：</p>
<blockquote>
<p>我们的模块也逐渐大了起来，出于软件设计的考虑笔者选择将部分内容单独封装在一个头文件中</p>
<p>a3module.h</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* arttnba3_module.ko</span></span><br><span class="line"><span class="comment">* developed by arttnba3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_NAME <span class="string">&quot;a3device&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLASS_NAME <span class="string">&quot;a3module&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NOT_INIT 0xffffffff</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> READ_ONLY 0x1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALLOW_WRITE 0x1001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_RESET 0x1002</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major_num;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> a3_module_mode = READ_ONLY;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> * <span class="title">module_class</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">device</span> * <span class="title">module_device</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> * buffer = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">spinlock_t</span> spin;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">kernel_module_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">kernel_module_exit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">a3_module_open</span><span class="params">(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">a3_module_read</span><span class="params">(<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">a3_module_write</span><span class="params">(<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">a3_module_release</span><span class="params">(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">a3_module_ioctl</span><span class="params">(<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">long</span> __internal_a3_module_ioctl(<span class="keyword">struct</span> file * __file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> param);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">a3_module_fo</span> =</span> </span><br><span class="line">&#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .unlocked_ioctl = a3_module_ioctl,</span><br><span class="line">    .open = a3_module_open,</span><br><span class="line">    .read = a3_module_read,</span><br><span class="line">    .write = a3_module_write,</span><br><span class="line">    .release = a3_module_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>arttnba3_module.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* arttnba3_module.ko</span></span><br><span class="line"><span class="comment">* developed by arttnba3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;a3module.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">module_init(kernel_module_init);</span><br><span class="line">module_exit(kernel_module_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;arttnba3&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">kernel_module_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    spin_lock_init(&amp;spin);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;[arttnba3_TestModule:] Module loaded. Start to register device...\n&quot;</span>);</span><br><span class="line">    major_num = register_chrdev(<span class="number">0</span>, DEVICE_NAME, &amp;a3_module_fo);</span><br><span class="line">    <span class="keyword">if</span>(major_num &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_INFO <span class="string">&quot;[arttnba3_TestModule:] Failed to register a major number.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> major_num;</span><br><span class="line">    &#125;    </span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;[arttnba3_TestModule:] Register complete, major number: %d\n&quot;</span>, major_num);</span><br><span class="line"></span><br><span class="line">    module_class = class_create(THIS_MODULE, CLASS_NAME);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(module_class))</span><br><span class="line">    &#123;</span><br><span class="line">        unregister_chrdev(major_num, DEVICE_NAME);</span><br><span class="line">        printk(KERN_INFO <span class="string">&quot;[arttnba3_TestModule:] Failed to register class device!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(module_class);</span><br><span class="line">    &#125;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;[arttnba3_TestModule:] Class device register complete.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    module_device = device_create(module_class, <span class="literal">NULL</span>, MKDEV(major_num, <span class="number">0</span>), <span class="literal">NULL</span>, DEVICE_NAME);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(module_device))</span><br><span class="line">    &#123;</span><br><span class="line">        class_destroy(module_class);</span><br><span class="line">        unregister_chrdev(major_num, DEVICE_NAME);</span><br><span class="line">        printk(KERN_INFO <span class="string">&quot;[arttnba3_TestModule:] Failed to create the device!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(module_device);</span><br><span class="line">    &#125;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;[arttnba3_TestModule:] Module register complete.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">kernel_module_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;[arttnba3_TestModule:] Start to clean up the module.\n&quot;</span>);</span><br><span class="line">    device_destroy(module_class, MKDEV(major_num, <span class="number">0</span>));</span><br><span class="line">    class_destroy(module_class);</span><br><span class="line">    unregister_chrdev(major_num, DEVICE_NAME);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;[arttnba3_TestModule:] Module clean up complete. See you next time.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">a3_module_ioctl</span><span class="params">(<span class="keyword">struct</span> file * __file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> param)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> ret;</span><br><span class="line"></span><br><span class="line">    spin_lock(&amp;spin);</span><br><span class="line"></span><br><span class="line">    ret = __internal_a3_module_ioctl(__file, cmd, param);</span><br><span class="line"></span><br><span class="line">    spin_unlock(&amp;spin);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> __internal_a3_module_ioctl(<span class="keyword">struct</span> file * __file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> param)</span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;[arttnba3_TestModule:] Received operation code: %d\n&quot;</span>, cmd);</span><br><span class="line">    <span class="keyword">switch</span>(cmd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> READ_ONLY:</span><br><span class="line">            <span class="keyword">if</span> (!buffer)</span><br><span class="line">            &#123;</span><br><span class="line">                printk(KERN_INFO <span class="string">&quot;[arttnba3_TestModule:] Please reset the buffer at first!\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            printk(KERN_INFO <span class="string">&quot;[arttnba3_TestModule:] Module operation mode reset to READ_ONLY.\n&quot;</span>);</span><br><span class="line">            a3_module_mode = READ_ONLY;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ALLOW_WRITE:</span><br><span class="line">            <span class="keyword">if</span> (!buffer)</span><br><span class="line">            &#123;</span><br><span class="line">                printk(KERN_INFO <span class="string">&quot;[arttnba3_TestModule:] Please reset the buffer at first!\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            printk(KERN_INFO <span class="string">&quot;[arttnba3_TestModule:] Module operation mode reset to ALLOW_WRITE.\n&quot;</span>);</span><br><span class="line">            a3_module_mode = ALLOW_WRITE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BUFFER_RESET:</span><br><span class="line">            <span class="keyword">if</span> (!buffer)</span><br><span class="line">            &#123;</span><br><span class="line">                buffer = kmalloc(<span class="number">0x500</span>, GFP_ATOMIC);</span><br><span class="line">                <span class="keyword">if</span> (buffer == <span class="literal">NULL</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    printk(KERN_INFO <span class="string">&quot;[arttnba3_TestModule:] Unable to initialize the buffer. Kernel malloc error.\n&quot;</span>);</span><br><span class="line">                    a3_module_mode = NOT_INIT;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            printk(KERN_INFO <span class="string">&quot;[arttnba3_TestModule:] Buffer reset. Module operation mode reset to READ_ONLY.\n&quot;</span>);</span><br><span class="line">            <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="number">0x500</span>);</span><br><span class="line">            a3_module_mode = READ_ONLY;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> NOT_INIT:</span><br><span class="line">            printk(KERN_INFO <span class="string">&quot;[arttnba3_TestModule:] Module operation mode reset to NOT_INIT.\n&quot;</span>);</span><br><span class="line">            a3_module_mode = NOT_INIT;</span><br><span class="line">            kfree(buffer);</span><br><span class="line">            buffer = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            printk(KERN_INFO <span class="string">&quot;[arttnba3_TestModule:] Invalid operation code.\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">a3_module_open</span><span class="params">(<span class="keyword">struct</span> inode * __inode, <span class="keyword">struct</span> file * __file)</span></span><br><span class="line">&#123;</span><br><span class="line">    spin_lock(&amp;spin);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (buffer == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;    </span><br><span class="line">        buffer = kmalloc(<span class="number">0x500</span>, GFP_ATOMIC);</span><br><span class="line">        <span class="keyword">if</span> (buffer == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            printk(KERN_INFO <span class="string">&quot;[arttnba3_TestModule:] Unable to initialize the buffer. Kernel malloc error.\n&quot;</span>);</span><br><span class="line">            a3_module_mode = NOT_INIT;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="number">0x500</span>);</span><br><span class="line">        a3_module_mode = READ_ONLY;</span><br><span class="line">        printk(KERN_INFO <span class="string">&quot;[arttnba3_TestModule:] Device open, buffer initialized successfully.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_INFO <span class="string">&quot;[arttnba3_TestModule:]Warning: reopen the device may cause unexpected error in kernel.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    spin_unlock(&amp;spin);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">a3_module_release</span><span class="params">(<span class="keyword">struct</span> inode * __inode, <span class="keyword">struct</span> file * __file)</span></span><br><span class="line">&#123;</span><br><span class="line">    spin_lock(&amp;spin);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (buffer)</span><br><span class="line">    &#123;</span><br><span class="line">        kfree(buffer);</span><br><span class="line">        buffer = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;[arttnba3_TestModule:] Device closed.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    spin_unlock(&amp;spin);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">a3_module_read</span><span class="params">(<span class="keyword">struct</span> file * __file, <span class="type">char</span> __user * user_buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> * __loff)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> buf = (<span class="type">char</span>*)buffer;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    spin_lock(&amp;spin);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a3_module_mode == NOT_INIT)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_INFO <span class="string">&quot;[arttnba3_TestModule:] Buffer not initialized yet.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    count = copy_to_user(user_buf, buf, size &gt; <span class="number">0x500</span> ? <span class="number">0x500</span> : size);</span><br><span class="line"></span><br><span class="line">    spin_unlock(&amp;spin);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">a3_module_write</span><span class="params">(<span class="keyword">struct</span> file * __file, <span class="type">const</span> <span class="type">char</span> __user * user_buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> * __loff)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> * <span class="type">const</span> buf = (<span class="type">char</span>*)buffer;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    spin_lock(&amp;spin);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a3_module_mode == NOT_INIT)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_INFO <span class="string">&quot;[arttnba3_TestModule:] Buffer not initialized yet.\n&quot;</span>);</span><br><span class="line">        count = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a3_module_mode == READ_ONLY)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_INFO <span class="string">&quot;[arttnba3_TestModule:] Unable to write under mode READ_ONLY.\n&quot;</span>);</span><br><span class="line">        count = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        count = copy_from_user(buf, user_buf, size &gt; <span class="number">0x500</span> ? <span class="number">0x500</span> : size);</span><br><span class="line"></span><br><span class="line">    spin_unlock(&amp;spin);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译成功</p>
<p><img src="https://i.loli.net/2021/03/02/W4rq81jeglpv9ai.png" alt="image.png"></p>
<p>接下来我们开始编写用户态程序以测试我们的模块功能是否正常</p>
<h4 id="III-测试模块接口"><a href="#III-测试模块接口" class="headerlink" title="III.测试模块接口"></a>III.测试模块接口</h4><p>我们编写如下程序来测试我们的接口是否正常：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> * buf = <span class="string">&quot;test for read and write.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> ch[<span class="number">0x100</span>];</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/dev/a3device&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(buf);</span><br><span class="line">    ioctl(fd, <span class="number">0x1000</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    write(fd, buf, len);</span><br><span class="line"></span><br><span class="line">    ioctl(fd, <span class="number">0x1001</span>, <span class="literal">NULL</span>);</span><br><span class="line">    write(fd, buf, len);</span><br><span class="line">    read(fd, ch, len);</span><br><span class="line">    write(<span class="number">0</span>, ch, len);</span><br><span class="line"></span><br><span class="line">    ioctl(fd, <span class="number">0x1002</span>, <span class="literal">NULL</span>);</span><br><span class="line">    read(fd, ch, len);</span><br><span class="line">    write(<span class="number">0</span>, ch, len);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行，一切正常，撒花~🌸</p>
<p><img src="https://i.loli.net/2021/03/03/bEUdnsRgOSlxKaV.png" alt="image.png"></p>
<h4 id="EXTRA-procfs接口"><a href="#EXTRA-procfs接口" class="headerlink" title="EXTRA.procfs接口"></a>EXTRA.procfs接口</h4><p>除了创建虚拟设备节点供通信以外，我们也可以选择创建虚拟文件节点的方式与用户进程间进行通信</p>
<h5 id="procfs：进程文件系统"><a href="#procfs：进程文件系统" class="headerlink" title="procfs：进程文件系统"></a>procfs：进程文件系统</h5><p>procfs即<code>进程文件系统</code>（ Process file system ），其中包含一个<strong>伪文件系统</strong>，在系统启动时动态生成文件，不会占用真正的储存空间，而是占用一定的内存</p>
<p>procfs用以通过内核访问进程信息，通常被挂载到<code>/proc</code>目录下</p>
<h5 id="proc-ops结构体"><a href="#proc-ops结构体" class="headerlink" title="proc_ops结构体"></a>proc_ops结构体</h5><p>类似于<code>file_operations</code>结构体，不同的是该结构体被用于procfs</p>
<p>定义于<code>include/linux/proc_fs.h</code>中，仅定义了少量函数指针成员，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_ops</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> proc_flags;</span><br><span class="line">    <span class="type">int</span>    (*proc_open)(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">    <span class="type">ssize_t</span>    (*proc_read)(<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">    <span class="type">ssize_t</span> (*proc_read_iter)(<span class="keyword">struct</span> kiocb *, <span class="keyword">struct</span> iov_iter *);</span><br><span class="line">    <span class="type">ssize_t</span>    (*proc_write)(<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">    <span class="type">loff_t</span>    (*proc_lseek)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span>    (*proc_release)(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">    <span class="type">__poll_t</span> (*proc_poll)(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> poll_table_struct *);</span><br><span class="line">    <span class="type">long</span>    (*proc_ioctl)(<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPAT</span></span><br><span class="line">    <span class="type">long</span>    (*proc_compat_ioctl)(<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span>    (*proc_mmap)(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> vm_area_struct *);</span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*proc_get_unmapped_area)</span><span class="params">(<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>)</span>;</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>

<h5 id="创建虚拟文件夹"><a href="#创建虚拟文件夹" class="headerlink" title="创建虚拟文件夹"></a>创建虚拟文件夹</h5><p>使用<code>proc_mkdir(const char *, struct proc_dir_entry *)</code>函数可以快速创建虚拟文件夹，第一个参数用以指定文件夹名，第二个参数用以指定该📂挂载于哪个procfs节点下，若为NULL则自动挂载到<code>/proc</code>目录下</p>
<p>该函数的返回值为<code>proc_dir_entry</code>类型的指针，该结构体定义于<code>fs/proc/internal.h</code>中，我们可以通过这个结构体指针管理我们的虚拟文件</p>
<h5 id="创建虚拟文件节点"><a href="#创建虚拟文件节点" class="headerlink" title="创建虚拟文件节点"></a>创建虚拟文件节点</h5><p>使用<code>proc_create(const char *name, umode_t mode, struct proc_dir_entry *parent, const struct proc_ops *proc_ops)</code>函数可以快速创建一个文件节点</p>
<ul>
<li><code>name</code>：文件名</li>
<li><code>mode</code>：文件读写执行权限</li>
<li><code>parent</code>：该文件挂载的procfs节点，若为NULL则自动挂载到<code>/proc</code>目录下</li>
<li><code>proc_ops</code>：该文件的proc_ops结构体</li>
</ul>
<p>该函数的返回值同样为<code>proc_dir_entry</code>类型的指针</p>
<h5 id="注销虚拟文件节点"><a href="#注销虚拟文件节点" class="headerlink" title="注销虚拟文件节点"></a>注销虚拟文件节点</h5><p>函数<code>remove_proc_entry(const char *, struct proc_dir_entry *)</code>用以注销此前创建的文件，其中第一个参数为文件名，第二个参数为其挂载的节点，若为NULL则默认为<code>/proc</code>目录</p>
<h5 id="测试模块接口"><a href="#测试模块接口" class="headerlink" title="测试模块接口"></a>测试模块接口</h5><p>我们此前的模块代码只需稍加修改即可适用于procfs，这里只贴出修改后的部分：</p>
<blockquote>
<p>a3module.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">kernel_module_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    spin_lock_init(&amp;spin);</span><br><span class="line"></span><br><span class="line">    a3_module_proc = proc_create(PROC_NAME, <span class="number">0666</span>, <span class="literal">NULL</span>, &amp;a3_module_fo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">kernel_module_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;[arttnba3_TestModule:] Start to clean up the module.\n&quot;</span>);</span><br><span class="line">    remove_proc_entry(PROC_NAME, <span class="literal">NULL</span>);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;[arttnba3_TestModule:] Module clean up complete. See you next time.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>a3module.h</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PROC_NAME <span class="string">&quot;a3proc&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> * <span class="title">a3_module_proc</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_ops</span> <span class="title">a3_module_fo</span> =</span> </span><br><span class="line">&#123;</span><br><span class="line">    .proc_ioctl = a3_module_ioctl,</span><br><span class="line">    .proc_open = a3_module_open,</span><br><span class="line">    .proc_read = a3_module_read,</span><br><span class="line">    .proc_write = a3_module_write,</span><br><span class="line">    .proc_release = a3_module_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们使用如下程序进行测试：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> * buf = <span class="string">&quot;test for read and write.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> ch[<span class="number">0x100</span>];</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/proc/a3proc&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(buf);</span><br><span class="line">    ioctl(fd, <span class="number">0x1000</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    write(fd, buf, len);</span><br><span class="line"></span><br><span class="line">    ioctl(fd, <span class="number">0x1001</span>, <span class="literal">NULL</span>);</span><br><span class="line">    write(fd, buf, len);</span><br><span class="line">    read(fd, ch, len);</span><br><span class="line">    write(<span class="number">0</span>, ch, len);</span><br><span class="line"></span><br><span class="line">    ioctl(fd, <span class="number">0x1002</span>, <span class="literal">NULL</span>);</span><br><span class="line">    read(fd, ch, len);</span><br><span class="line">    write(<span class="number">0</span>, ch, len);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成功运行~撒花~🌸</p>
<p><img src="https://i.loli.net/2021/03/06/85BoO6QiqMhj2XG.png" alt="image.png"></p>
<h2 id="六、使用-qemu-gdb-调试Linux内核"><a href="#六、使用-qemu-gdb-调试Linux内核" class="headerlink" title="六、使用 qemu + gdb 调试Linux内核"></a>六、使用 qemu + gdb 调试Linux内核</h2><h3 id="载入内核符号表"><a href="#载入内核符号表" class="headerlink" title="载入内核符号表"></a>载入内核符号表</h3><p>直接使用 gdb 载入之前在源码根目录下编译出来的未压缩内核镜像 vmlinux 即可</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo gdb vmlinux</span></span><br></pre></td></tr></table></figure>

<h3 id="remote连接"><a href="#remote连接" class="headerlink" title="remote连接"></a>remote连接</h3><p>我们启动时已经将内核映射到了本地的1234端口，只需要gdb连接上就行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash"><span class="built_in">set</span> architecture i386:x86-64</span></span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">target remote localhost:1234</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>笔者的gdb使用了<code>pwndbg</code>这个插件</p>
</blockquote>
<p><img src="https://i.loli.net/2021/04/13/Uuxeshm3rTyXV8D.png" alt="image.png"></p>
<p>需要注意的是若要源码调试则需要用我们手动编译的内核</p>
<h3 id="解压-bzImage-镜像"><a href="#解压-bzImage-镜像" class="headerlink" title="解压 bzImage 镜像"></a>解压 bzImage 镜像</h3><p>有的时候我们只有压缩后的内核镜像<code>bzImage</code> （例如在一些 CTF 题目中），此时我们可以使用如下脚本进行解压（来自<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/master/scripts/extract-vmlinux">github</a>）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">SPDX-License-Identifier: GPL-2.0-only</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">----------------------------------------------------------------------</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">extract-vmlinux - Extract uncompressed vmlinux from a kernel image</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Inspired from extract-ikconfig</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(c) 2009,2010 Dick Streefland &lt;dick@streefland.net&gt;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># (c) 2011      Corentin Chary &lt;corentin.chary@gmail.com&gt;</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># ----------------------------------------------------------------------</span></span></span><br><span class="line"></span><br><span class="line">check_vmlinux()</span><br><span class="line">&#123;</span><br><span class="line">    # Use readelf to check if it&#x27;s a valid ELF</span><br><span class="line">    # TODO: find a better to way to check that it&#x27;s really vmlinux</span><br><span class="line">    #       and not just an elf</span><br><span class="line">    readelf -h $1 &gt; /dev/null 2&gt;&amp;1 || return 1</span><br><span class="line"></span><br><span class="line">    cat $1</span><br><span class="line">    exit 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try_decompress()</span><br><span class="line">&#123;</span><br><span class="line">    # The obscure use of the &quot;tr&quot; filter is to work around older versions of</span><br><span class="line">    # &quot;grep&quot; that report the byte offset of the line instead of the pattern.</span><br><span class="line"></span><br><span class="line">    # Try to find the header ($1) and decompress from here</span><br><span class="line">    for    pos in `tr &quot;$1\n$2&quot; &quot;\n$2=&quot; &lt; &quot;$img&quot; | grep -abo &quot;^$2&quot;`</span><br><span class="line">    do</span><br><span class="line">        pos=$&#123;pos%%:*&#125;</span><br><span class="line">        tail -c+$pos &quot;$img&quot; | $3 &gt; $tmp 2&gt; /dev/null</span><br><span class="line">        check_vmlinux $tmp</span><br><span class="line">    done</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Check invocation:</span></span><br><span class="line">me=$&#123;0##*/&#125;</span><br><span class="line">img=$1</span><br><span class="line">if    [ $# -ne 1 -o ! -s &quot;$img&quot; ]</span><br><span class="line">then</span><br><span class="line">    echo &quot;Usage: $me &lt;kernel-image&gt;&quot; &gt;&amp;2</span><br><span class="line">    exit 2</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Prepare temp files:</span></span><br><span class="line">tmp=$(mktemp /tmp/vmlinux-XXX)</span><br><span class="line">trap &quot;rm -f $tmp&quot; 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">That didn<span class="string">&#x27;t work, so retry after decompression.</span></span></span><br><span class="line">try_decompress &#x27;\037\213\010&#x27; xy    gunzip</span><br><span class="line">try_decompress &#x27;\3757zXZ\000&#x27; abcde unxz</span><br><span class="line">try_decompress &#x27;BZh&#x27;          xy    bunzip2</span><br><span class="line">try_decompress &#x27;\135\0\0\0&#x27;   xxx   unlzma</span><br><span class="line">try_decompress &#x27;\211\114\132&#x27; xy    &#x27;lzop -d&#x27;</span><br><span class="line">try_decompress &#x27;\002!L\030&#x27;   xxx   &#x27;lz4 -d&#x27;</span><br><span class="line">try_decompress &#x27;(\265/\375&#x27;   xxx   unzstd</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Finally check for uncompressed images or objects:</span></span></span><br><span class="line">check_vmlinux $img</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Bail out:</span></span></span><br><span class="line">echo &quot;$me: Cannot find vmlinux.&quot; &gt;&amp;2</span><br></pre></td></tr></table></figure>

<p>用法如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./extract-vmlinux ./bzImage &gt; vmlinux</span></span><br></pre></td></tr></table></figure>

<h3 id="寻找gadget"><a href="#寻找gadget" class="headerlink" title="寻找gadget"></a>寻找gadget</h3><p>用ROPgadget或者ropper都行，笔者比较喜欢使用ROPgadget</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ROPgadget --binary ./vmlinux &gt; gadget.txt</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ropper --file ./vmlinuz --nocolor &gt; gadget2.txt</span></span><br></pre></td></tr></table></figure>

<p>一般出来大概有个几十MB</p>
<h3 id="调试内核模块"><a href="#调试内核模块" class="headerlink" title="调试内核模块"></a>调试内核模块</h3><p>使用 gdb 调试内核模块和调试普通的可执行文件大致上是相同的，不过我们需要额外指定各个需要被我们调试的 section 的载入地址</p>
<p>首先通过读取 <code>/sys/module/模块名/sections/</code> 目录下对应的文件获取对应 section 在内核中的载入地址，例如我们调试时需要用到 <code>.text</code>、<code>.data</code>、<code>.bss</code> 这三个段的数据：</p>
<p><img src="https://s2.loli.net/2022/01/29/1XwSsuLlzvc5OGP.png" alt="image.png"></p>
<p>之后在使用 gdb 连接上 qemu 后，使用 <code>add-symble-file</code> 命令载入内核模块信息，默认指定为 <code>.text</code> 段</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) add-symbol-file ./arttnba3_module.ko 0xffffffffc0002000 -s .data 0xffffffffc0004000 -s .bss 0xffffffffc0004480</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/01/29/XR4xu8arZFyzwCL.png" alt="image.png"></p>
<p>之后就可以正常调试内核模块了</p>
<p><img src="https://s2.loli.net/2022/01/29/IHTbgMaNE7UmxKo.png" alt="image.png"></p>
<p><img src="https://s2.loli.net/2022/01/29/chLJN7tdaKEU3WT.png" alt="image.png"></p>
<p>若是你只需要对代码段进行调试，也可以通过 <code>lsmod</code> 命令或者读取 <code>/proc/modules</code> 以获取代码段的载入地址</p>
<p><img src="https://s2.loli.net/2022/01/29/gc9kSXf4qANVmZ5.png" alt="image.png"></p>
<h2 id="七、编写自己的shell"><a href="#七、编写自己的shell" class="headerlink" title="七、编写自己的shell"></a>七、编写自己的shell</h2><blockquote>
<p>注：实际生产开发中推荐使用bash&#x2F;dash等成熟的shell，这里仅仅是做了一个勉强能用的小玩具</p>
</blockquote>
<p>我们的kernel虽然成功地跑了起来，但是不可置否的是，仅有一个白色的<code>/#</code>作为提示符的默认shell似乎过于丑陋了（），于是我们接下来试着开发一个属于自己的可爱的shell吧！</p>
<p>通常而言，一个shell可以简化为如下形式：</p>
<blockquote>
<p>参考自《现代操作系统》P31 图 1-19</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    typePrompt();</span><br><span class="line">    readCommand();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Unable to fork the child, inner error.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) <span class="comment">// the child thread</span></span><br><span class="line">    &#123;</span><br><span class="line">        execve(command); <span class="comment">//execve the command</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// the parent thread</span></span><br><span class="line">    &#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>); <span class="comment">//waiting for the child to exit</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们在shell中进行输入时，fork()出子进程来执行我们的输入，父进程则等待我们的子进程执行完成</p>
<h3 id="打印提示符"><a href="#打印提示符" class="headerlink" title="打印提示符"></a>打印提示符</h3><p>一个“比较好看”的shell应当形如如下形式：</p>
<blockquote>
<p>bash，大多数Linux发行版上默认的shell</p>
</blockquote>
<p><img src="https://i.loli.net/2021/03/04/JSlezZnQ3GPFfXy.png" alt="image.png"></p>
<p>即我们在输入命令之前应当有如下结构的提示符：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user@hostname:current_path$</span><br></pre></td></tr></table></figure>

<ul>
<li><p>获取用户相关信息可以使用<code>getpwuid(getuid())</code>获取一个<code>passwd</code>结构体</p>
</li>
<li><p>获取主机名则可以使用<code>gethostname()</code>函数</p>
</li>
<li><p>获取当前路径可以使用<code>getcwd()</code>函数，按照bash的风格若是包含当前用户的home路径则我们应当将其缩写为<code>~</code></p>
</li>
<li><p>改变字体颜色则可以用相应的转义序列控制字符，便不在此赘叙</p>
</li>
</ul>
<p>最终我们得到的打印提示符的函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uid_t</span> uid;</span><br><span class="line"><span class="type">int</span> user_path_len;</span><br><span class="line"><span class="type">char</span> local_host_name[<span class="number">0x100</span>];</span><br><span class="line"><span class="type">char</span> user_path[<span class="number">0x100</span>];</span><br><span class="line"><span class="type">char</span> current_path[<span class="number">0x200</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">passwd</span> * <span class="title">user_info</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">typePrompt</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    uid = getuid();</span><br><span class="line">    user_info = getpwuid(uid);</span><br><span class="line">    user_path_len = <span class="built_in">strlen</span>(user_info-&gt;pw_dir);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(gethostname(local_host_name, <span class="number">0x100</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Unable to get the hostname, inner error.\033[0m\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!getcwd(current_path, <span class="number">0x200</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Unable to get the current path, inner error.\033[0m\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(uid == <span class="number">0</span>) <span class="comment">// for root, no color</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(user_info-&gt;pw_name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;@&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(local_host_name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strlen</span>(current_path) &gt; user_path_len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(user_path, current_path, user_path_len);</span><br><span class="line">            user_path[user_path_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(user_path, user_info-&gt;pw_dir))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;~&quot;</span>);</span><br><span class="line">                <span class="built_in">printf</span>(current_path + user_path_len);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(current_path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(current_path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;# &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(user_info-&gt;pw_name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;@&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(local_host_name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[0m\033[1m&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[34m&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strlen</span>(current_path) &gt; user_path_len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(user_path, current_path, user_path_len);</span><br><span class="line">            user_path[user_path_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(user_path, user_info-&gt;pw_dir))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;~&quot;</span>);</span><br><span class="line">                <span class="built_in">printf</span>(current_path + user_path_len);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(current_path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(current_path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[0m&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;$ &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单测试一下，以假乱真还是没什么问题的（）</p>
<p><img src="https://i.loli.net/2021/03/04/L73rDxGoI4ifbRX.png" alt="image.png"></p>
<h3 id="输入读取"><a href="#输入读取" class="headerlink" title="输入读取"></a>输入读取</h3><p>对于用户的一次输入，毫无疑问我们不应当也不可能无限进行读取，因此我们应当对输入的读取的字符的上限做一个限制，超出这个限制长度往后的字符尽数丢弃</p>
<p>同样地，为了避免一开始就分配过大的内存空间，笔者选择使用malloc进行动态内存分配，一开始时先分配一个适当大小的缓冲区，后续若输入超出这个大小则重新分配一个两倍大小的缓冲区</p>
<p>对于输入历史是否记录，我们还需要进行判断，若是用户仅仅是在不断敲击<code>ENTER</code>，那么就没必要记录了</p>
<h4 id="后台执行"><a href="#后台执行" class="headerlink" title="后台执行"></a>后台执行</h4><p>有的时候我们想要让应用被放到后台去执行，那么我们的父进程（shell）就不应当等待子进程，笔者选择仿照bash的方式——若最后一个字符是<code>&#39;&amp;&#39;</code>则不等待子进程执行，这里我们选择在读取命令时使用一个返回值进行标识</p>
<h4 id="历史命令"><a href="#历史命令" class="headerlink" title="历史命令"></a>历史命令</h4><p>为了模拟bash的功能，我们还应当实现<code>!!</code>执行上一条命令、<code>!数字</code>执行历史记录中的某条命令，简单判断即可 </p>
<p>完整代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">readCommand</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>((ch = getchar()) != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(count == command_buf_size)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">2</span> * command_buf_size &gt; BUF_MAX) <span class="comment">//overflow</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>((ch = getchar()) != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">char</span> * new_buf = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">2</span> * command_buf_size);</span><br><span class="line">            <span class="keyword">if</span>(!new_buf) <span class="comment">//malloc error</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>((ch = getchar()) != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memcpy</span>(new_buf, command_buf, command_buf_size);</span><br><span class="line">            command_buf_size *= <span class="number">2</span>;</span><br><span class="line">            <span class="built_in">free</span>(command_buf);</span><br><span class="line">            command_buf = new_buf;</span><br><span class="line">        &#125;</span><br><span class="line">        command_buf[count++] = ch;</span><br><span class="line">    &#125;</span><br><span class="line">    command_buf[count] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(count == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> FLAG_NULL_INPUT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(count &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (command_buf[<span class="number">0</span>] == <span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (command_buf[<span class="number">1</span>] == <span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!his_full &amp;&amp; his_count == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">puts</span>(<span class="string">&quot;\033[31m\033[1m[x] No available command, history is empty.\033[0m&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> FLAG_NULL_INPUT;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">char</span> * temp = <span class="built_in">malloc</span>(command_buf_size);</span><br><span class="line">                <span class="type">int</span> flag = FLAG_EXECVE_WAIT;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(command_buf[count - <span class="number">1</span>] == <span class="string">&#x27;&amp;&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    command_buf[count - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                    flag = FLAG_EXECVE_BACKGROUND;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">strcpy</span>(temp, history[((his_count + HIS_MAX - <span class="number">1</span>) % HIS_MAX)]);</span><br><span class="line">                <span class="built_in">strncat</span>(temp, command_buf + <span class="number">2</span>, command_buf_size - <span class="built_in">strlen</span>(temp));</span><br><span class="line">                <span class="built_in">strcpy</span>(command_buf, temp);</span><br><span class="line">                <span class="built_in">free</span>(temp);</span><br><span class="line">                historyRecord();</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\n%s\n&quot;</span>, command_buf);</span><br><span class="line">                <span class="keyword">return</span> flag;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (command_buf[<span class="number">1</span>] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; command_buf[<span class="number">1</span>] &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> num_end = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(command_buf[num_end] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; command_buf[num_end] &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">                    num_end++;</span><br><span class="line">                <span class="type">char</span> ch = command_buf[num_end];</span><br><span class="line">                command_buf[num_end] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="type">int</span> his = atoi(command_buf + <span class="number">1</span>);</span><br><span class="line">                command_buf[num_end] = ch;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (his &lt; <span class="number">0</span> || his &gt;= HIS_MAX || !history[his])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">puts</span>(<span class="string">&quot;\033[31m\033[1m[x] No available command, invalid history index.\033[0m&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> FLAG_NULL_INPUT;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">char</span> * temp = <span class="built_in">malloc</span>(command_buf_size);</span><br><span class="line">                <span class="type">int</span> flag = FLAG_EXECVE_WAIT;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(command_buf[count - <span class="number">1</span>] == <span class="string">&#x27;&amp;&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    command_buf[count - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                    flag = FLAG_EXECVE_BACKGROUND;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">strcpy</span>(temp, history[his]);</span><br><span class="line">                <span class="built_in">strncat</span>(temp, command_buf + num_end, command_buf_size - <span class="built_in">strlen</span>(temp));</span><br><span class="line">                <span class="built_in">strcpy</span>(command_buf, temp);</span><br><span class="line">                <span class="built_in">free</span>(temp);</span><br><span class="line">                historyRecord();</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\n%s\n&quot;</span>, command_buf);</span><br><span class="line">                <span class="keyword">return</span> flag;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    historyRecord();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(command_buf[count - <span class="number">1</span>] == <span class="string">&#x27;&amp;&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        command_buf[count - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> FLAG_EXECVE_BACKGROUND;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FLAG_EXECVE_WAIT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="命令行解析"><a href="#命令行解析" class="headerlink" title="命令行解析"></a>命令行解析</h3><p>最为简单的解析方式便是使用<code>strtok()</code>函数进行分割，这里我们选择以空格<code>&quot; &quot;</code>作为分隔符</p>
<p>同样地，一行命令中的参数数量不应当过多，我们应当限制仅读取一定数量的参数</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ARGS_MAX 0x100</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> * args[<span class="number">0x100</span>];</span><br><span class="line"><span class="type">int</span> args_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">analyseCommand</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    args_count = <span class="number">0</span>;</span><br><span class="line">    args[args_count] = strtok(command_buf, <span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="type">char</span> * ptr;</span><br><span class="line">    <span class="keyword">while</span>(ptr = strtok(<span class="literal">NULL</span>, <span class="string">&quot; &quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        args_count++;</span><br><span class="line">        args[args_count] = ptr;</span><br><span class="line">        <span class="keyword">if</span>(args_count + <span class="number">1</span> == ARGS_MAX)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h3><p>相比起<code>execve()</code>，<code>execvp()</code>函数更适合用以执行我们输入的命令，同时我们解析后的命令行格式可以直接传入，较为方便</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">createChild</span><span class="params">(<span class="type">int</span> flag)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) <span class="comment">// failed to fork a new thread</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Unable to fork the child, inner error.\033[0m\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) <span class="comment">// the child thread</span></span><br><span class="line">        execvp(args[<span class="number">0</span>], args);</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// the parent thread</span></span><br><span class="line">        <span class="keyword">if</span>(flag == FLAG_EXECVE_WAIT)</span><br><span class="line">            wait(<span class="literal">NULL</span>); <span class="comment">//waiting for the child to exit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内建命令"><a href="#内建命令" class="headerlink" title="内建命令"></a>内建命令</h3><p>部分命令如<code>cd</code>（改变当前工作目录）、<code>history</code>（查看历史）、<code>exit</code>（退出）等命令若是直接使用execvp()执行的话我们会发现<strong>毫无效果</strong>，因此这几个命令我们需要自行建立在我们的shell当中</p>
<ul>
<li><code>cd</code>命令可以直接使用<code>chdir()</code>函数改变当前工作目录，需要注意的是对于字符串<code>&quot;~&quot;</code>我们应当单独解析——将其替换为用户工作目录后再进行字符串拼接</li>
<li><code>history</code>命令则需要我们预先有一个储存历史命令的缓冲区，同时当历史记录达到上限时我们应当进行清除，这里我们选择模拟一个循环链表以在历史命令满之后每次输入命令时都会去除现存的最早的命令</li>
<li><code>exit</code>命令则只需要在主进程中识别到该字符串时直接调用<code>exit()</code>即可</li>
</ul>
<p>同样地，在主进程若是检测到输入的命令为内建命令，则应当<strong>不调用</strong><code>execvp()</code>，在这里笔者选择添加一个返回值进行判定</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> * history[HIS_MAX];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> his_count = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> his_start = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> his_full = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">innerCommand</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(args[<span class="number">0</span>], <span class="string">&quot;exit&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Exit the a3shell now, see you again!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(args[<span class="number">0</span>], <span class="string">&quot;cd&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(args_count &gt; <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;cd: too many arguments&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(args[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27;~&#x27;</span> &amp;&amp; args[<span class="number">1</span>][<span class="number">1</span>] == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">char</span> * dir = <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(args[<span class="number">1</span>]) + <span class="built_in">strlen</span>(user_info-&gt;pw_dir));</span><br><span class="line">                <span class="built_in">strcpy</span>(dir, user_info-&gt;pw_dir);</span><br><span class="line">                <span class="built_in">strncat</span>(dir, args[<span class="number">1</span>][<span class="number">1</span>], <span class="built_in">strlen</span>(args[<span class="number">1</span>]) - <span class="number">1</span>);</span><br><span class="line">                chdir(dir);</span><br><span class="line">                <span class="built_in">free</span>(dir);</span><br><span class="line">                dir = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                chdir(args[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(args[<span class="number">0</span>], <span class="string">&quot;history&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(args[<span class="number">1</span>] &amp;&amp; !<span class="built_in">strcmp</span>(args[<span class="number">1</span>], <span class="string">&quot;-c&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            his_count = <span class="number">0</span>;</span><br><span class="line">            his_full = <span class="number">0</span>;</span><br><span class="line">            his_start = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(his_full)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = his_start; i &lt; HIS_MAX; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; %d  &quot;</span>, count++);</span><br><span class="line">                <span class="built_in">puts</span>(history[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; his_start;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; %d  &quot;</span>, count++);</span><br><span class="line">                <span class="built_in">puts</span>(history[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; his_count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; %d  &quot;</span>, count++);</span><br><span class="line">                <span class="built_in">puts</span>(history[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">historyRecord</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//to record the history</span></span><br><span class="line">&#123;</span><br><span class="line">    history[his_count] = <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(command_buf));</span><br><span class="line">    <span class="built_in">strcpy</span>(history[his_count], command_buf);</span><br><span class="line">    his_count++;</span><br><span class="line">    <span class="keyword">if</span>(his_full)</span><br><span class="line">    &#123;</span><br><span class="line">        his_start++;</span><br><span class="line">        his_start %= HIS_MAX;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(his_count == HIS_MAX)</span><br><span class="line">    &#123;</span><br><span class="line">        his_count = <span class="number">0</span>;</span><br><span class="line">        his_full = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a>代码测试</h3><p>最终我们的主程序如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pwd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;func.c&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    init();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(args, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">char</span>*) * <span class="number">0x100</span>);</span><br><span class="line">        typePrompt();</span><br><span class="line">        <span class="type">int</span> flag = readCommand();</span><br><span class="line">        <span class="keyword">if</span>(flag == FLAG_NULL_INPUT)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        analyseCommand();</span><br><span class="line">        <span class="keyword">if</span>(innerCommand())</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        createChild(flag);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>完整代码见<a target="_blank" rel="noopener" href="https://github.com/arttnba3/a3shell">https://github.com/arttnba3/a3shell</a></p>
</blockquote>
<p>编译运行，示意图如下，左边为<code>a3shell</code>，右边为<code>bash</code></p>
<p><img src="https://i.loli.net/2021/03/05/dVrnBjGHvlz9Ioe.png" alt="image.png"></p>
<p>勉强能用（），后面还会继续进行进一步的优化（如代码补全等</p>
<h3 id="EXTRA-MORE-POWERFUL-SHELL"><a href="#EXTRA-MORE-POWERFUL-SHELL" class="headerlink" title="EXTRA.MORE POWERFUL SHELL"></a>EXTRA.MORE POWERFUL SHELL</h3><p>毫无疑问的是，一个成熟易用的shell应当还要具备如<code>代码补全</code>、<code>上下切换历史记录</code>等功能，因此我们决定为我们的shell添加这样的功能，让她成为一个更加强大的shell</p>
<p>在这里我们将会用到一个库<a target="_blank" rel="noopener" href="https://tiswww.case.edu/php/chet/readline/rltop.html">The GNU Readline Library</a></p>
<h4 id="安装readline库"><a href="#安装readline库" class="headerlink" title="安装readline库"></a>安装readline库</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get install libreadline-gplv2-dev</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get install libreadline6-dev</span></span><br></pre></td></tr></table></figure>

<p>也可以在<a target="_blank" rel="noopener" href="http://git.savannah.gnu.org/cgit/readline.git/snapshot/readline-master.tar.gz">这里</a>下载源码</p>
<h4 id="使用readline读取输入"><a href="#使用readline读取输入" class="headerlink" title="使用readline读取输入"></a>使用readline读取输入</h4><p>需要<code>#include &lt;readline/readline.h&gt;</code></p>
<p>只需要将我们原来的<code>readCommand()</code>函数换为<code>readline()</code>函数即可，返回值即为读取到的输入</p>
<p>需要注意的是<strong>我们需要手动进行释放，否则会造成内存泄漏</strong></p>
<p>readline()函数接收一个参数作为输入前的提示符，我们只需要稍微原有函数将拼接好的提示符传入即可</p>
<p>✳需要注意的是<strong>我们传入的提示符字符串应当以</strong><code>&#39;\001&#39;</code><strong>开头</strong>、<code>&#39;\002&#39;</code><strong>结尾</strong></p>
<p>对于空行而言，readline()将会返回一个空字符串（buf[0] &#x3D;&#x3D; ‘\0’）而不是NULL</p>
<h4 id="记录历史输入"><a href="#记录历史输入" class="headerlink" title="记录历史输入"></a>记录历史输入</h4><p>readline库提供了强大的历史输入记录功能，在使用<code>readline()</code>函数读取输入后我们可以使用<code>add_history()</code>记录输入，传入的参数则是readline()返回的字符串</p>
<p><strong>添加历史后我们便可以像普通的shell那样使用↑↓来显示历史输入记录</strong></p>
<p>打印的功能依然需要我们自定义，在readline lib中使用一个<code>HIST_ENTRY</code>结构体数组来记录我们传入的历史输入，而使用<code>history_list()</code>便可以获得指向该结构体数组的指针</p>
<p>使用<code>clear_history()</code>则可以清除所有历史记录</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;readline/history.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">HIST_ENTRY ** his = history_list();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; his[i]; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; %d\t\t&quot;</span>, i);</span><br><span class="line">    <span class="built_in">puts</span>(his[i]-&gt;line);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h4><p>需要注意的是我们编译时应当添加上<code>-lreadline</code>参数</p>
<blockquote>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc shell.c -o a3sh -lreadline</span></span><br></pre></td></tr></table></figure>

<p>程序完整代码见<a target="_blank" rel="noopener" href="https://github.com/arttnba3/a3shell">https://github.com/arttnba3/a3shell</a></p>
</blockquote>
<p>大概效果图如下（自动补全的效果没法表现出来，感受一下…）</p>
<p><img src="https://i.loli.net/2021/03/05/a2PZdr8ULscwjky.png" alt="image.png"></p>
<blockquote>
<p>说实话按照笔者个人的体验而言这个库并不算特别完善…</p>
</blockquote>
<h2 id="八、替换内核"><a href="#八、替换内核" class="headerlink" title="八、替换内核"></a>八、替换内核</h2><p>好像一切都没有问题了，我们来把我们的新内核换到我们的主机上吧！</p>
<p>我们原有的机子的内核版本为 <code>5.8.0</code></p>
<p><img src="https://i.loli.net/2021/05/08/JcYL8UQ7gnubORZ.png" alt="image.png"></p>
<p>在编译好内核后，我们在之前的源码目录下继续执行如下指令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo make modules</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo make modules_install</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo make install</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo update-initramfs -c -k 5.11.0</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo update-grub</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get install linux-source</span></span><br></pre></td></tr></table></figure>

<p>这里的 <code>5.11.0</code> 应为你自己的新内核版本号</p>
<p>需要注意的是<strong>在执行命令之前我们应当预留足够的空间</strong></p>
<blockquote>
<p> 会比你预想中的可能还要再大一些<img src="https://i.loli.net/2021/05/08/fqdbRMhuKCrIozk.png" alt="image.png"></p>
</blockquote>
<p>之后输入 <code>reboot</code> 命令重启即可</p>
<p>重新进入系统，我们可以看到我们的内核版本已经被替换为 <code>5.11.0</code></p>
<p><img src="https://i.loli.net/2021/05/08/TmgAvs1VnJuYHcS.png" alt="image.png"></p>
<h2 id="九、CTF中kernel类题目的部署"><a href="#九、CTF中kernel类题目的部署" class="headerlink" title="九、CTF中kernel类题目的部署"></a>九、CTF中kernel类题目的部署</h2><p>和常规的CTF题目的布置方法是相类似的，最常见的办法便是使用<code>ctf_xinted</code> + <code>docker</code>布置，我们只需要配置<strong>用 ctf_xinetd 启动 boot.sh 即可</strong></p>
<p>首先下载<code>ctf_xinted</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://github.com/Eadom/ctf_xinetd.git</span></span><br></pre></td></tr></table></figure>

<p>之后将内核复制进来，大概的架构如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree</span></span><br><span class="line">.</span><br><span class="line">├── ctf.xinetd</span><br><span class="line">├── Dockerfile</span><br><span class="line">├── bin</span><br><span class="line">│   ├── boot.sh</span><br><span class="line">│   ├── bzImage</span><br><span class="line">│   └── rootfs.cpio</span><br><span class="line">├── README.md</span><br><span class="line">└── start.sh</span><br><span class="line"></span><br><span class="line">1 directory, 7 files</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Dockerfile</p>
<p>因为不需要太多东西所以写的比较简洁，一开始安装 qemu 可能会多耗一点点时间，<code>DEBIAN_FRONTEND=noninteractive</code> 主要用于省去配置中的一些交互</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:20.04</span><br><span class="line"></span><br><span class="line">RUN sed -i &quot;s/http:\/\/archive.ubuntu.com/http:\/\/mirrors.tuna.tsinghua.edu.cn/g&quot; /etc/apt/sources.list &amp;&amp; \</span><br><span class="line">    apt-get update &amp;&amp; apt-get -y dist-upgrade &amp;&amp; \</span><br><span class="line">    DEBIAN_FRONTEND=noninteractive \</span><br><span class="line">    apt-get install -y lib32z1 xinetd git libglib2.0-dev libfdt-dev libpixman-1-dev zlib1g-dev qemu qemu-system-x86</span><br><span class="line"></span><br><span class="line">RUN useradd -m ctf</span><br><span class="line"></span><br><span class="line">WORKDIR /</span><br><span class="line"></span><br><span class="line">COPY ./ctf.xinetd /etc/xinetd.d/ctf</span><br><span class="line">COPY ./start.sh /start.sh</span><br><span class="line">RUN echo &quot;Blocked by ctf_xinetd&quot; &gt; /etc/banner_fail</span><br><span class="line"></span><br><span class="line">RUN chmod +x /start.sh</span><br><span class="line"></span><br><span class="line">COPY ./bin/ /</span><br><span class="line"></span><br><span class="line">CMD [&quot;/start.sh&quot;]</span><br><span class="line"></span><br><span class="line">EXPOSE 25000</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ctf.xinted</p>
<p>这里直接把 boot.sh 给起了就行</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">service ctf</span><br><span class="line">&#123;</span><br><span class="line">    disable = no</span><br><span class="line">    socket_type = stream</span><br><span class="line">    protocol    = tcp</span><br><span class="line">    wait        = no</span><br><span class="line">    user        = ctf</span><br><span class="line">    type        = UNLISTED</span><br><span class="line">    port        = 25000</span><br><span class="line">    bind        = 0.0.0.0</span><br><span class="line">    server      = /boot.sh</span><br><span class="line">    # replace helloworld to your program</span><br><span class="line">    banner_fail = /etc/banner_fail</span><br><span class="line">    # safety options</span><br><span class="line">    per_source    = 10 # the maximum instances of this service per source IP address</span><br><span class="line">    rlimit_cpu    = 20 # the maximum number of CPU seconds that the service may use</span><br><span class="line">    #rlimit_as  = 1024M # the Address Space resource limit for the service</span><br><span class="line">    #access_times = 2:00-9:00 12:00-24:00</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后使用如下命令启动<code>xinted</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo docker build -t <span class="string">&quot;kernel&quot;</span> .</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo docker run -d -p <span class="string">&quot;0.0.0.0:25000:25000&quot;</span> -h <span class="string">&quot;kernel&quot;</span> --name=<span class="string">&quot;kernel&quot;</span> kernel</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>init 和 boot.sh 也应当进行适当修改：</p>
<blockquote>
<p>init</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t devtmpfs devtmpfs /dev</span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> 0&lt;/dev/console</span><br><span class="line"><span class="built_in">exec</span> 1&gt;/dev/console</span><br><span class="line"><span class="built_in">exec</span> 2&gt;/dev/console</span><br><span class="line"></span><br><span class="line"><span class="built_in">chown</span> root:root /flag</span><br><span class="line"><span class="built_in">chmod</span> 600 /flag</span><br><span class="line"></span><br><span class="line">insmod a3dev.ko</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\nBoot took <span class="subst">$(cut -d&#x27; &#x27; -f1 /proc/uptime)</span> seconds\n&quot;</span></span><br><span class="line">setsid cttyhack setuidgid 1000 sh</span><br><span class="line"></span><br><span class="line">umount /proc</span><br><span class="line">umount /sys</span><br><span class="line">poweroff -d 0  -f</span><br></pre></td></tr></table></figure>

<blockquote>
<p>boot.sh</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -m 128M \</span><br><span class="line">    -kernel ./bzImage \</span><br><span class="line">    -initrd  ./rootfs.cpio \</span><br><span class="line">    -append <span class="string">&quot;root=/dev/ram console=ttyS0 oops=panic panic=1 loglevel=3 quiet nokaslr&quot;</span> \</span><br><span class="line">    -cpu kvm64,+smep,+smap \</span><br><span class="line">    -smp cores=2,threads=2 \</span><br><span class="line">    -netdev user,<span class="built_in">id</span>=t0, -device e1000,netdev=t0,<span class="built_in">id</span>=nic0 \</span><br><span class="line">    -nographic \</span><br><span class="line">    -monitor /dev/null</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="0xFF-reference"><a href="#0xFF-reference" class="headerlink" title="0xFF.reference"></a>0xFF.reference</h1><blockquote>
<p><a target="_blank" rel="noopener" href="https://eqqie.cn/index.php/laji_note/1475/">eqqie - Linux下kernel调试环境搭建</a></p>
<p><a target="_blank" rel="noopener" href="http://taqini.space/2020/11/21/linux-kernel-pwn-learning/">TaQini - Linux Kernel Pwn 入门笔记</a></p>
<p><a target="_blank" rel="noopener" href="https://mask6asok.top/2020/02/06/Linux_Kernel_Pwn_1.html">Mask - Linux Kernel Pwn I: Basic Knowledge</a></p>
<p><a target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/kernel/basic_knowledge/">CTF Wiki - Linux Pwn - kernel - 基础知识</a></p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B4%E5%A1%8A%E6%80%A7%E6%A0%B8%E5%BF%83">Wikipedia: 整塊性核心</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wangdongfang/p/13722072.html">进程描述符</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/tsruixi/p/10777242.html">Lab1：Linux内核编译及添加系统调用（详细版） - 睿晞 - 博客园</a></p>
<p><a target="_blank" rel="noopener" href="https://m4x.fun/post/play-with-file-descriptor-2/">m4x - Play with file descriptor(II)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/luotuo44/article/details/17474099">文件描述符表、文件表、索引结点表_luotuo44的专栏-CSDN博客_文件描述符表</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/mp/homepage?__biz=MzI3NzA5MzUxNA==&hid=2&sn=73cb26dd403cac563c9d661a8126c035&scene=18#wechat_redirect">Linux内核之旅</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/geneil/archive/2011/12/03/2272869.html">linux设备驱动程序之简单字符设备驱动 - LoveFM - 博客园</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41453285/article/details/102942629">Linux驱动(字符设备):02—设备号（dev_t、MAJOR、MINOR、MKDEV、register_chrdev_region、alloc_chrdev_region）_江南、董少-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yeshennet/article/details/82315816">Linux内核模块编程指南(三)_yeshen.org-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wuyuegb2312/p/3399566.html">手把手教你编写一个具有基本功能的shell（已开源） - 五岳 - 博客园</a></p>
<p>《Understanding the Linux Kernel(Third Edition)》 —— Daniel P. Bovet &amp; Marco Cesati</p>
<p>《Modern Operating System(Fourth Edition)》 —— Andrew S. Tanenbaum &amp; Herbert Bos</p>
</blockquote>

      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
              <a href="/2021/02/11/CTF-0X03-PWNABLE.TW/" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>上一页</span>
              </a>
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">
              <i class="iconfont icon-updatetime" title="更新时间"></i>
              2021-02-21 21:02:14
            </span>
            
                  <span class="post-categories">
                    <i class="iconfont icon-bookmark" title="分类"></i>
                    
                    <span class="span--category">
                      <a href="/categories/NOTES/" title="NOTES">
                        <b>#</b> NOTES
                      </a>
                    </span>
                    
                  </span>
              
                  <span class="post-tags">
                    <i class="iconfont icon-tags" title="标签"></i>
                    
                    <span class="span--tag">
                      <a href="/tags/Pwn/" title="Pwn">
                        <b>#</b> Pwn
                      </a>
                    </span>
                    
                    <span class="span--tag">
                      <a href="/tags/Linux/" title="Linux">
                        <b>#</b> Linux
                      </a>
                    </span>
                    
                    <span class="span--tag">
                      <a href="/tags/%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0/" title="学习札记">
                        <b>#</b> 学习札记
                      </a>
                    </span>
                    
                    <span class="span--tag">
                      <a href="/tags/Linux-Kernel/" title="Linux Kernel">
                        <b>#</b> Linux Kernel
                      </a>
                    </span>
                    
                    <span class="span--tag">
                      <a href="/tags/Operating-System/" title="Operating System">
                        <b>#</b> Operating System
                      </a>
                    </span>
                    
                  </span>
              
          </div>
          <div class="post-foot-prev">
            
              <a href="/2021/03/03/NOTE-0X03-LINUX-KERNEL-PWN-PART-II/" target="_self">
                <span>下一页</span>
                <i class="iconfont icon-chevronright"></i>
              </a>
            
          </div>
        </div>
      
    </div>
    
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">目录</div>
    <div class="catalog-content">
      
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0x00-Linux-Kernel-Basic-Knowledge"><span class="toc-text">0x00.Linux Kernel Basic Knowledge</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%86%85%E6%A0%B8"><span class="toc-text">一、内核</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E6%9E%B6%E6%9E%84%EF%BC%9A%E5%BE%AE%E5%86%85%E6%A0%B8-amp-%E5%AE%8F%E5%86%85%E6%A0%B8%EF%BC%88%E5%8D%95%E5%86%85%E6%A0%B8%EF%BC%89"><span class="toc-text">内核架构：微内核 &amp; 宏内核（单内核）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8F%E5%86%85%E6%A0%B8%EF%BC%88Monolithic-Kernel%EF%BC%8C%E5%8F%88%E5%8F%AB%E5%8D%95%E5%86%85%E6%A0%B8%EF%BC%89"><span class="toc-text">宏内核（Monolithic Kernel，又叫单内核）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AE%E5%86%85%E6%A0%B8%EF%BC%88Micro-Kernel%EF%BC%89"><span class="toc-text">微内核（Micro Kernel）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%88%86%E7%BA%A7%E4%BF%9D%E6%8A%A4%E5%9F%9F"><span class="toc-text">二、分级保护域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Intel-Ring-Model"><span class="toc-text">Intel Ring Model</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="toc-text">现代操作系统启动过程概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4-amp-%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4"><span class="toc-text">用户空间 &amp; 内核空间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%80%81-amp-%E5%86%85%E6%A0%B8%E6%80%81"><span class="toc-text">用户态 &amp; 内核态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C%E6%80%81%E5%88%87%E6%8D%A2"><span class="toc-text">进程运行态切换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD"><span class="toc-text">中断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E6%9C%BA%E5%88%B6"><span class="toc-text">信号机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%80%81-%E2%80%94-gt-%E5%86%85%E6%A0%B8%E6%80%81"><span class="toc-text">用户态 —&gt; 内核态</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#I-%E5%88%87%E6%8D%A2GS%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-text">I.切换GS段寄存器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#II-%E4%BF%9D%E5%AD%98%E7%94%A8%E6%88%B7%E6%80%81%E6%A0%88%E5%B8%A7%E4%BF%A1%E6%81%AF"><span class="toc-text">II.保存用户态栈帧信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#III-%E4%BF%9D%E5%AD%98%E7%94%A8%E6%88%B7%E6%80%81%E5%AF%84%E5%AD%98%E5%99%A8%E4%BF%A1%E6%81%AF"><span class="toc-text">III.保存用户态寄存器信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#IV-%E9%80%9A%E8%BF%87%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA32%E4%BD%8D"><span class="toc-text">IV.通过汇编指令判断是否为32位</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#V-%E6%8E%A7%E5%88%B6%E6%9D%83%E8%BD%AC%E4%BA%A4%E5%86%85%E6%A0%B8%EF%BC%8C%E6%89%A7%E8%A1%8C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">V.控制权转交内核，执行系统调用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E6%80%81-%E2%80%94-gt-%E7%94%A8%E6%88%B7%E6%80%81"><span class="toc-text">内核态 —&gt; 用户态</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">三、系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%A1%A8"><span class="toc-text">系统调用表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E5%85%A5%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">进入系统调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%80%E5%87%BA%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">退出系统调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E8%BF%9B%E7%A8%8B%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86"><span class="toc-text">四、进程权限管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E7%AC%A6%EF%BC%88process-descriptor%EF%BC%89"><span class="toc-text">进程描述符（process descriptor）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%9D%83%E9%99%90%E5%87%AD%E8%AF%81%EF%BC%9Acred%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">进程权限凭证：cred结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7ID-amp-%E7%BB%84ID"><span class="toc-text">用户ID &amp; 组ID</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%9D%83%E9%99%90%E6%94%B9%E5%8F%98"><span class="toc-text">进程权限改变</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%90%E6%9D%83"><span class="toc-text">*提权</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81I-x2F-O"><span class="toc-text">五、I&#x2F;O</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%80%9C%E4%B8%87%E7%89%A9%E7%9A%86%E6%96%87%E4%BB%B6%E2%80%9D"><span class="toc-text">“万物皆文件”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-text">进程文件系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-text">文件描述符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#stdin%E3%80%81stdout%E3%80%81stderr"><span class="toc-text">stdin、stdout、stderr</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%EF%BC%9Aioctl"><span class="toc-text">系统调用：ioctl</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81Loadable-Kernel-Modules%EF%BC%88LKMs%EF%BC%89"><span class="toc-text">六、Loadable Kernel Modules（LKMs）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%86%85%E6%A0%B8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">七、内核内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#buddy-system"><span class="toc-text">buddy system</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#slab-allocator"><span class="toc-text">slab allocator</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#I-%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-text">I.基本结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#II-%E5%88%86%E9%85%8D-x2F-%E9%87%8A%E6%94%BE%E8%BF%87%E7%A8%8B"><span class="toc-text">II.分配&#x2F;释放过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#III-slab-alias%EF%BC%88mergeability%EF%BC%89"><span class="toc-text">III. slab alias（mergeability）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6"><span class="toc-text">八、保护机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#I-%E9%80%9A%E7%94%A8%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6"><span class="toc-text">I.通用保护机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#KASLR"><span class="toc-text">KASLR</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FGKASLR"><span class="toc-text">*FGKASLR</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#STACK-PROTECTOR"><span class="toc-text">STACK PROTECTOR</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SMAP-x2F-SMEP"><span class="toc-text">SMAP&#x2F;SMEP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#KPTI"><span class="toc-text">KPTI</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#II-%E5%86%85%E6%A0%B8%E2%80%9C%E5%A0%86%E2%80%9D%E4%B8%8A%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6"><span class="toc-text">II.内核“堆”上保护机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Hardened-Usercopy"><span class="toc-text">Hardened Usercopy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hardened-freelist"><span class="toc-text">Hardened freelist</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Random-freelist"><span class="toc-text">Random freelist</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x01-Linux-Kernel-%E7%AE%80%E6%98%93%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8D%97"><span class="toc-text">0x01.Linux Kernel 简易食用指南</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Pre-%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96"><span class="toc-text">Pre.安装依赖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E8%8E%B7%E5%8F%96%E5%86%85%E6%A0%B8%E9%95%9C%E5%83%8F%EF%BC%88bzImage%EF%BC%89"><span class="toc-text">一、获取内核镜像（bzImage）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E8%87%AA%E8%A1%8C%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81"><span class="toc-text">方法一：自行编译内核源码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#I-%E8%8E%B7%E5%8F%96%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81"><span class="toc-text">I.获取内核源码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#II-%E9%85%8D%E7%BD%AE%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9"><span class="toc-text">II.配置编译选项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#III-%E5%BC%80%E5%A7%8B%E7%BC%96%E8%AF%91"><span class="toc-text">III.开始编译</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E7%9A%84%E9%94%99%E8%AF%AF"><span class="toc-text">可能出现的错误</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#vmlinux%EF%BC%9A%E5%8E%9F%E5%A7%8B%E5%86%85%E6%A0%B8%E6%96%87%E4%BB%B6"><span class="toc-text">vmlinux：原始内核文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#bzImage%EF%BC%9A%E5%8E%8B%E7%BC%A9%E5%86%85%E6%A0%B8%E9%95%9C%E5%83%8F"><span class="toc-text">bzImage：压缩内核镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#zImage-amp-amp-bzImage"><span class="toc-text">zImage &amp;&amp; bzImage</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EXTRA-%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">EXTRA.添加系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#I-%E5%88%86%E9%85%8D%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8F%B7"><span class="toc-text">I.分配系统调用号</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#II-%E5%A3%B0%E6%98%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">II.声明系统调用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#III-%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89"><span class="toc-text">III.添加系统调用函数定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#IV-%E9%87%8D%E6%96%B0%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8"><span class="toc-text">IV.重新编译内核</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#V-%E6%B5%8B%E8%AF%95%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">V.测试系统调用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E4%B8%8B%E8%BD%BD%E7%8E%B0%E6%9C%89%E5%86%85%E6%A0%B8%E9%95%9C%E5%83%8F"><span class="toc-text">方法二：下载现有内核镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%89%EF%BC%9A%E4%BD%BF%E7%94%A8%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8%E9%95%9C%E5%83%8F"><span class="toc-text">方法三：使用系统内核镜像</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E8%8E%B7%E5%8F%96busybox"><span class="toc-text">二、获取busybox</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91busybox"><span class="toc-text">编译busybox</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#I-%E8%8E%B7%E5%8F%96busybox%E6%BA%90%E7%A0%81"><span class="toc-text">I.获取busybox源码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#II-%E7%BC%96%E8%AF%91busybox%E6%BA%90%E7%A0%81"><span class="toc-text">II.编译busybox源码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%9E%84%E5%BB%BA%E7%A3%81%E7%9B%98%E9%95%9C%E5%83%8F"><span class="toc-text">三、构建磁盘镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-text">建立文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#I-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-text">I.初始化文件系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#II-%E9%85%8D%E7%BD%AE%E5%88%9D%E5%A7%8B%E5%8C%96%E8%84%9A%E6%9C%AC"><span class="toc-text">II.配置初始化脚本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#III-%E9%85%8D%E7%BD%AE%E7%94%A8%E6%88%B7%E7%BB%84"><span class="toc-text">III.配置用户组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IV-%E9%85%8D%E7%BD%AEglibc%E5%BA%93"><span class="toc-text">IV.配置glibc库</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%8C%85%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%BA%E9%95%9C%E5%83%8F%E6%96%87%E4%BB%B6"><span class="toc-text">打包文件系统为镜像文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%96%87%E4%BB%B6"><span class="toc-text">向文件系统中添加文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#I-%E8%A7%A3%E5%8E%8B%E7%A3%81%E7%9B%98%E9%95%9C%E5%83%8F"><span class="toc-text">I.解压磁盘镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#II-%E9%87%8D%E6%89%93%E5%8C%85%E7%A3%81%E7%9B%98%E9%95%9C%E5%83%8F"><span class="toc-text">II.重打包磁盘镜像</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E4%BD%BF%E7%94%A8qemu%E8%BF%90%E8%A1%8C%E5%86%85%E6%A0%B8"><span class="toc-text">四、使用qemu运行内核</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC"><span class="toc-text">配置启动脚本</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E7%BC%96%E5%86%99%E5%8F%AF%E8%A3%85%E8%BD%BD%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%EF%BC%88LKMs%EF%BC%89"><span class="toc-text">五、编写可装载内核模块（LKMs）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86"><span class="toc-text">预备知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84%E6%B5%8B%E8%AF%95%E6%A8%A1%E5%9D%97"><span class="toc-text">简单的测试模块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-text">头文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A5%E5%8F%A3%E7%82%B9-x2F-%E5%87%BA%E5%8F%A3%E7%82%B9"><span class="toc-text">入口点&#x2F;出口点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E2%80%A6"><span class="toc-text">其他…</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%EF%BC%9Amakefile"><span class="toc-text">编译内核模块：makefile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E4%BE%9B%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BC%8FI-x2F-O%E6%8E%A5%E5%8F%A3"><span class="toc-text">提供应用程式I&#x2F;O接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#I-%E8%AE%BE%E5%A4%87%E6%B3%A8%E5%86%8C"><span class="toc-text">I.设备注册</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E7%B1%BB"><span class="toc-text">设备分类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#file-operations%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">file_operations结构体</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E8%AE%BE%E5%A4%87%E5%8F%B7-amp-%E6%AC%A1%E8%AE%BE%E5%A4%87%E5%8F%B7"><span class="toc-text">主设备号 &amp; 次设备号</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E8%8A%82%E7%82%B9%EF%BC%88struct-device-node-amp-struct-device%EF%BC%89"><span class="toc-text">设备节点（struct device_node &amp; struct device）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E7%B1%BB%EF%BC%88struct-class%EF%BC%89"><span class="toc-text">设备类（struct class）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E7%9A%84%E6%B3%A8%E5%86%8C%E4%B8%8E%E6%B3%A8%E9%94%80"><span class="toc-text">设备的注册与注销</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E6%9D%83%E9%99%90"><span class="toc-text">设备权限</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#II-%E7%BC%96%E5%86%99%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%8E%A5%E5%8F%A3%E5%87%BD%E6%95%B0"><span class="toc-text">II.编写系统调用接口函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#III-%E6%B5%8B%E8%AF%95%E6%A8%A1%E5%9D%97%E6%8E%A5%E5%8F%A3"><span class="toc-text">III.测试模块接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EXTRA-procfs%E6%8E%A5%E5%8F%A3"><span class="toc-text">EXTRA.procfs接口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#procfs%EF%BC%9A%E8%BF%9B%E7%A8%8B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-text">procfs：进程文件系统</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#proc-ops%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">proc_ops结构体</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E5%A4%B9"><span class="toc-text">创建虚拟文件夹</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E8%8A%82%E7%82%B9"><span class="toc-text">创建虚拟文件节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E9%94%80%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E8%8A%82%E7%82%B9"><span class="toc-text">注销虚拟文件节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E6%A8%A1%E5%9D%97%E6%8E%A5%E5%8F%A3"><span class="toc-text">测试模块接口</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E4%BD%BF%E7%94%A8-qemu-gdb-%E8%B0%83%E8%AF%95Linux%E5%86%85%E6%A0%B8"><span class="toc-text">六、使用 qemu + gdb 调试Linux内核</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%BD%E5%85%A5%E5%86%85%E6%A0%B8%E7%AC%A6%E5%8F%B7%E8%A1%A8"><span class="toc-text">载入内核符号表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#remote%E8%BF%9E%E6%8E%A5"><span class="toc-text">remote连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%8E%8B-bzImage-%E9%95%9C%E5%83%8F"><span class="toc-text">解压 bzImage 镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BB%E6%89%BEgadget"><span class="toc-text">寻找gadget</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97"><span class="toc-text">调试内核模块</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84shell"><span class="toc-text">七、编写自己的shell</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E6%8F%90%E7%A4%BA%E7%AC%A6"><span class="toc-text">打印提示符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%AF%BB%E5%8F%96"><span class="toc-text">输入读取</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E5%8F%B0%E6%89%A7%E8%A1%8C"><span class="toc-text">后台执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%86%E5%8F%B2%E5%91%BD%E4%BB%A4"><span class="toc-text">历史命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%A7%A3%E6%9E%90"><span class="toc-text">命令行解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C"><span class="toc-text">命令执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%BB%BA%E5%91%BD%E4%BB%A4"><span class="toc-text">内建命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%B5%8B%E8%AF%95"><span class="toc-text">代码测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EXTRA-MORE-POWERFUL-SHELL"><span class="toc-text">EXTRA.MORE POWERFUL SHELL</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E8%A3%85readline%E5%BA%93"><span class="toc-text">安装readline库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8readline%E8%AF%BB%E5%8F%96%E8%BE%93%E5%85%A5"><span class="toc-text">使用readline读取输入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E5%8E%86%E5%8F%B2%E8%BE%93%E5%85%A5"><span class="toc-text">记录历史输入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C"><span class="toc-text">编译运行</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E6%9B%BF%E6%8D%A2%E5%86%85%E6%A0%B8"><span class="toc-text">八、替换内核</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81CTF%E4%B8%ADkernel%E7%B1%BB%E9%A2%98%E7%9B%AE%E7%9A%84%E9%83%A8%E7%BD%B2"><span class="toc-text">九、CTF中kernel类题目的部署</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0xFF-reference"><span class="toc-text">0xFF.reference</span></a></li></ol>
      
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
      <div class="comments-container">
        




  
    <script async type="text/javascript" src="/plugins/valine.min.js" onload="loadValineSuc(this)"></script>
  

  <div id="vcomments"></div>

  <script>
    function loadValineSuc() {
      new Valine({
        el: '#vcomments',
        appId: 'ICj6cPRQWFTNiOttBHlzxnIv-gzGzoHsz',
        appKey: 'tuvJh3xYxPFcW2JB6K26RKP2',
        placeholder: '说点什么呗...',
        avatar: 'retro',
        lang: 'zh-CN'
      })
    }
  </script>

    <style>
      .comments-container .v .vempty {
        display: none!important;
      }
    </style>




      </div>
    
  </div>


        
<div class="footer">
  <div class="social">
    <ul>
      
        <li>
          <a title="github" target="_blank" rel="noopener" href="https://github.com/arttnba3">
            <i class="iconfont icon-github"></i>
          </a>
        </li>
      
        <li>
          <a title="email" href="mailto:arttnba@gmail.com">
            <i class="iconfont icon-envelope"></i>
          </a>
        </li>
      
        <li>
          <a title="twitter" target="_blank" rel="noopener" href="https://twitter.com/arttnba3">
            <i class="iconfont icon-twitter"></i>
          </a>
        </li>
      
        <li>
          <a title="rss" href="/atom.xml">
            <i class="iconfont icon-rss"></i>
          </a>
        </li>
      
    </ul>
  </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/arttnba3">Copyright © 2022 arttnba3</a>
        
    </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Theme by Oranges | Powered by Hexo</a>
        
    </div>
  
</div>

      </div>

      <div class="tools-bar">
        <div class="back-to-top tools-bar-item hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



        
  <div class="search-icon tools-bar-item" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-title">
        <span class="search-icon-input">
          <a href="javascript: void(0)">
            <i class="iconfont icon-search"></i>
          </a>
        </span>
        
          <input type="text" class="search-input" id="search-input" placeholder="搜索...">
        
        <span class="search-close-icon" id="search-close-icon">
          <a href="javascript: void(0)">
            <i class="iconfont icon-close"></i>
          </a>
        </span>
      </div>
      <div class="search-result" id="search-result"></div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    inputArea.onclick = function() {
      getSearchFile()
      this.onclick = null
    }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        // inputArea.focus()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'>首次搜索，正在载入索引文件，请稍后……<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + orig_data_title + "</a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<p class=\"search-result-abstract\">" + match_content + "...</p>"
                }
                str += "</li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>没有找到内容，请尝试更换检索词。<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>未找到search.xml文件，具体请参考：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>请求失败，尝试重新刷新页面或稍后重试。<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




        
  <div class="tools-bar-item theme-icon" id="switch-color-scheme">
    <a href="javascript: void(0)">
      <i id="theme-icon" class="iconfont icon-moon"></i>
    </a>
  </div>

  
<script src="/js/colorscheme.js"></script>





        
  
    <div class="share-icon tools-bar-item">
      <a href="javascript: void(0)" id="share-icon">
        <i class="iconfont iconshare"></i>
      </a>
      <div class="share-content hidden">
        
          <a class="share-item" href="https://twitter.com/intent/tweet?text=' + %E3%80%90NOTES.0x02%E3%80%91Linux%20Kernel%20Pwn%20I%EF%BC%9A%E4%B8%80%E5%88%87%E5%BC%80%E5%A7%8B%E4%B9%8B%E5%89%8D + '&url=' + http%3A%2F%2Fblog.arttnba3.cn%2F2021%2F02%2F21%2FNOTE-0X02-LINUX-KERNEL-PWN-PART-I%2F + '" target="_blank" title="Twitter">
            <i class="iconfont icon-twitter"></i>
          </a>
        
        
          <a class="share-item" href="https://www.facebook.com/sharer.php?u=http://blog.arttnba3.cn/2021/02/21/NOTE-0X02-LINUX-KERNEL-PWN-PART-I/" target="_blank" title="Facebook">
            <i class="iconfont icon-facebooksquare"></i>
          </a>
        
      </div>
    </div>
  
  
<script src="/js/shares.js"></script>



      </div>
    </div>
  </body>
</html>
