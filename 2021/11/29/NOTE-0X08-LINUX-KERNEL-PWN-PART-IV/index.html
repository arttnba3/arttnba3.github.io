<!DOCTYPE html>
<html lang="zh-CN" color-mode="light">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="keywords" content="" />
  <meta name="author" content="arttnba3" />
  <meta name="description" content="あがいた夢を捨てて揺れる今日は眠って誤魔化せ" />
  
  
  <title>
    
      【NOTES.0x08】Linux Kernel Pwn IV：通用结构体与技巧 
      
      
      |
    
     arttnba3&#39;s blog
  </title>

  
    <link rel="apple-touch-icon" href="/img/favicon.png">
    <link rel="icon" href="/img/favicon.png">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  
<link rel="stylesheet" href="/css/color-scheme.css">
<link rel="stylesheet" href="/css/base.css">
<link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css">
<link rel="stylesheet" href="/css/github-markdown.css">
<link rel="stylesheet" href="/css/highlight.css">
<link rel="stylesheet" href="/css/comments.css">

  <!-- 代码块风格 -->
  

  <!-- jquery3.3.1 -->
  
    <script defer type="text/javascript" src="/plugins/jquery.min.js"></script>
  

  <!-- fancybox -->
  
    <link href="/plugins/jquery.fancybox.min.css" rel="stylesheet">
    <script defer type="text/javascript" src="/plugins/jquery.fancybox.min.js"></script>
  
  
<script src="/js/fancybox.js"></script>


  

  <script>
    var html = document.documentElement
    const colorMode = localStorage.getItem('color-mode')
    if (colorMode) {
      document.documentElement.setAttribute('color-mode', colorMode)
    }
  </script>
<meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="arttnba3's blog" type="application/atom+xml">
</head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a target="_blank" rel="noopener" href="https://arttnba3.cn">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img src="/img/avatar.png" alt="">
      
    </a>
    <div class="nickname"><a target="_blank" rel="noopener" href="https://arttnba3.cn">arttnba3's blog</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">Home</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">Archives</a>
        </li>
      
        <li class="nav-item" data-path="/categories/">
          <a href="/categories/">Categories</a>
        </li>
      
        <li class="nav-item" data-path="/tags/">
          <a href="/tags/">Tags</a>
        </li>
      
        <li class="nav-item" data-path="/friends/">
          <a href="/friends/">Friends</a>
        </li>
      
        <li class="nav-item" data-path="/about/">
          <a href="/about/">About</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->


  <!-- LaTex Display -->

  
    <script async type="text/javascript" src="/plugins/mathjax/tex-chtml.js"></script>
  
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    }
  </script>





  <!-- clipboard -->

  
    <script async type="text/javascript" src="/plugins/clipboard.min.js"></script>
  
  
<script src="/js/codeCopy.js"></script>







  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">【NOTES.0x08】Linux Kernel Pwn IV：通用结构体与技巧</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime" title="更新时间"></i>
          2021-11-29 13:51:25
        </span>
        
              <span class="post-categories">
                <i class="iconfont icon-bookmark" title="分类"></i>
                
                <span class="span--category">
                  <a href="/categories/NOTES/" title="NOTES">
                    <b>#</b> NOTES
                  </a>
                </span>
                
              </span>
          
              <span class="post-tags">
                <i class="iconfont icon-tags" title="标签"></i>
                
                <span class="span--tag">
                  <a href="/tags/Pwn/" title="Pwn">
                    <b>#</b> Pwn
                  </a>
                </span>
                
                <span class="span--tag">
                  <a href="/tags/Linux/" title="Linux">
                    <b>#</b> Linux
                  </a>
                </span>
                
                <span class="span--tag">
                  <a href="/tags/%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0/" title="学习札记">
                    <b>#</b> 学习札记
                  </a>
                </span>
                
                <span class="span--tag">
                  <a href="/tags/Linux-Kernel/" title="Linux Kernel">
                    <b>#</b> Linux Kernel
                  </a>
                </span>
                
              </span>
          
      </div>
      <div class="markdown-body">
        <p><del>我是小小做题家</del></p>
<span id="more"></span>

<h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><p>本篇博客中出现的源代码皆选自 Linux v5.15，不过大部分情况下本篇博文中的大部分结构体都不会随着版本更新而发生改动</p>
<h2 id="pahole：查阅内核结构体的工具"><a href="#pahole：查阅内核结构体的工具" class="headerlink" title="pahole：查阅内核结构体的工具"></a>pahole：查阅内核结构体的工具</h2><p>有的时候在<del>做CTF题</del>进行内核漏洞利用时，我们往往会遇到各种奇葩的通用分配结构体大小，而漏洞环境提供的结构体本身不能够帮助我们比较舒适地完成利用，此时我们需要找一个较为合适的结构体帮助我们完成利用，该怎么办？</p>
<p>可能大家会想到：自然是利用谷歌搜索一下有没有什么比较好用的结构体啦！或者是寻找一些前人留下的整合的成果，比如说<a target="_blank" rel="noopener" href="https://zplin.me/papers/ELOISE.pdf">这篇论文</a>或者是其他大师傅的一些文章，偶尔或许也可能在某个角落翻到笔者的这篇博客（笑）</p>
<p>但最好的办法自然是<strong>自己动手丰衣足食</strong>，这里笔者向大家介绍一个工具——<code>pahole</code></p>
<p>用法比较简单，直接执行便能获取<strong>对应内核中所有结构体的信息，包括大小、各成员偏移量等</strong>，虽然有的内核编译时不一定会选择导出这玩意所要用的东西，但各个版本内核之间不会有太大差异，找一个相同版本的内核跑一遍 pahole 即可</p>
<h2 id="slab-amp-amp-slub-amp-amp-slob-分配-object-的最小大小"><a href="#slab-amp-amp-slub-amp-amp-slob-分配-object-的最小大小" class="headerlink" title="slab &amp;&amp; slub &amp;&amp; slob 分配 object 的最小大小"></a>slab &amp;&amp; slub &amp;&amp; slob 分配 object 的最小大小</h2><p>在 <code>include/linux/slab.h</code> 中有如下定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The largest kmalloc size supported by the SLAB allocators is</span></span><br><span class="line"><span class="comment"> * 32 megabyte (2^25) or the maximum allocatable page order if that is</span></span><br><span class="line"><span class="comment"> * less than 32 MB.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * WARNING: Its not easy to increase this value since the allocators have</span></span><br><span class="line"><span class="comment"> * to do various tricks to work around compiler limitations in order to</span></span><br><span class="line"><span class="comment"> * ensure proper constant folding.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_SHIFT_HIGH    ((MAX_ORDER + PAGE_SHIFT - 1) &lt;= 25 ? \</span></span><br><span class="line"><span class="meta">                (MAX_ORDER + PAGE_SHIFT - 1) : 25)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_SHIFT_MAX    KMALLOC_SHIFT_HIGH</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> KMALLOC_SHIFT_LOW</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_SHIFT_LOW    5</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Kmalloc subsystem.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> KMALLOC_MIN_SIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_MIN_SIZE (1 &lt;&lt; KMALLOC_SHIFT_LOW)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p> 即 <strong>slab 分配器分配的 object 的大小最小为 32，slob 和 slub 的最小 object 大小为 8</strong></p>
<h1 id="0x01-tty-设备结构体"><a href="#0x01-tty-设备结构体" class="headerlink" title="0x01.tty 设备结构体"></a>0x01.tty 设备结构体</h1><p>tty 设备可以说是 kernel pwn 入门当中 <em>最经典</em> 的利用目标，尤其是 <code>/dev/ptmx</code> ，相信大家已经对其再熟悉不过了，不过这里笔者还是简单介绍一下这个“万能”的 tty 设备及其相关内核结构体</p>
<h2 id="tty-struct（kmalloc-1k）"><a href="#tty-struct（kmalloc-1k）" class="headerlink" title="tty_struct（kmalloc-1k）"></a>tty_struct（kmalloc-1k）</h2><p>该结构体定义于 <code>include/linux/tty.h</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct tty_struct - state associated with a tty while open</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @flow.lock: lock for flow members</span></span><br><span class="line"><span class="comment"> * @flow.stopped: tty stopped/started by tty_stop/tty_start</span></span><br><span class="line"><span class="comment"> * @flow.tco_stopped: tty stopped/started by TCOOFF/TCOON ioctls (it has</span></span><br><span class="line"><span class="comment"> *              precedense over @flow.stopped)</span></span><br><span class="line"><span class="comment"> * @flow.unused: alignment for Alpha, so that no members other than @flow.* are</span></span><br><span class="line"><span class="comment"> *         modified by the same 64b word store. The @flow&#x27;s __aligned is</span></span><br><span class="line"><span class="comment"> *         there for the very same reason.</span></span><br><span class="line"><span class="comment"> * @ctrl.lock: lock for ctrl members</span></span><br><span class="line"><span class="comment"> * @ctrl.pgrp: process group of this tty (setpgrp(2))</span></span><br><span class="line"><span class="comment"> * @ctrl.session: session of this tty (setsid(2)). Writes are protected by both</span></span><br><span class="line"><span class="comment"> *          @ctrl.lock and legacy mutex, readers must use at least one of</span></span><br><span class="line"><span class="comment"> *          them.</span></span><br><span class="line"><span class="comment"> * @ctrl.pktstatus: packet mode status (bitwise OR of TIOCPKT_* constants)</span></span><br><span class="line"><span class="comment"> * @ctrl.packet: packet mode enabled</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * All of the state associated with a tty while the tty is open. Persistent</span></span><br><span class="line"><span class="comment"> * storage for tty devices is referenced here as @port in struct tty_port.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>    magic;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">kref</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span>    <span class="comment">/* class device or NULL (e.g. ptys, serdev) */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Protects ldisc changes: Lock tty not pty */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ld_semaphore</span> <span class="title">ldisc_sem</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_ldisc</span> *<span class="title">ldisc</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">atomic_write_lock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">legacy_mutex</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">throttle_mutex</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">termios_rwsem</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">winsize_mutex</span>;</span></span><br><span class="line">    <span class="comment">/* Termios values are protected by the termios rwsem */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ktermios</span> <span class="title">termios</span>, <span class="title">termios_locked</span>;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">64</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">winsize</span> <span class="title">winsize</span>;</span>        <span class="comment">/* winsize_mutex */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">spinlock_t</span> lock;</span><br><span class="line">        <span class="type">bool</span> stopped;</span><br><span class="line">        <span class="type">bool</span> tco_stopped;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> unused[<span class="number">0</span>];</span><br><span class="line">    &#125; __aligned(<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>)) flow;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">spinlock_t</span> lock;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">pgrp</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">session</span>;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> pktstatus;</span><br><span class="line">        <span class="type">bool</span> packet;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> unused[<span class="number">0</span>];</span><br><span class="line">    &#125; __aligned(<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>)) ctrl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> hw_stopped;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> receive_room;    <span class="comment">/* Bytes free for queue */</span></span><br><span class="line">    <span class="type">int</span> flow_change;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">link</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync</span>;</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> write_wait;</span><br><span class="line">    <span class="type">wait_queue_head_t</span> read_wait;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">hangup_work</span>;</span></span><br><span class="line">    <span class="type">void</span> *disc_data;</span><br><span class="line">    <span class="type">void</span> *driver_data;</span><br><span class="line">    <span class="type">spinlock_t</span> files_lock;        <span class="comment">/* protects tty_files list */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">tty_files</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N_TTY_BUF_SIZE 4096</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> closing;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *write_buf;</span><br><span class="line">    <span class="type">int</span> write_cnt;</span><br><span class="line">    <span class="comment">/* If the tty has a pending do_SAK, queue it here - akpm */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">SAK_work</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_port</span> *<span class="title">port</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Each of a tty&#x27;s open files has private_data pointing to tty_file_private */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_file_private</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">tty</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* tty magic number */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TTY_MAGIC        0x5401</span></span><br></pre></td></tr></table></figure>

<h3 id="分配-x2F-释放"><a href="#分配-x2F-释放" class="headerlink" title="分配&#x2F;释放"></a>分配&#x2F;释放</h3><p>在注释中提示我们：当我们打开 tty 设备时内核中便会创建一个 tty_struct，通常情况下我们选择打开 <code>/dev/ptmx</code> 来在内核中分配一个 tty_struct 结构体，相应地当我们将其关闭时该结构体便会被释放回 slab&#x2F;slub 中</p>
<h3 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h3><p>tty_struct 的魔数为 <code>0x5401</code>，位于该结构体的开头，我们可以利用对该魔数的搜索以锁定该结构体（例如<a target="_blank" rel="noopener" href="https://arttnba3.cn/2021/03/03/NOTE-0X03-LINUX-KERNEL-PWN-PART-II/#%E8%A7%A3%E6%B3%95%E4%B8%80%EF%BC%9Auserfaultfd-heap-spray-Kernel-UAF-stack-migration-KPTI-bypass">强网杯2021-noteook</a>)</p>
<h2 id="tty-operations"><a href="#tty-operations" class="headerlink" title="*tty_operations"></a><em>*tty_operations</em></h2><p>内核中 tty 设备的 ops 函数表，定义于 <code>/include/linux/tty_driver.h</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> * (*<span class="title">lookup</span>)(<span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>,</span></span><br><span class="line"><span class="class">            <span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span>, <span class="title">int</span> <span class="title">idx</span>);</span></span><br><span class="line">    <span class="type">int</span>  (*install)(<span class="keyword">struct</span> tty_driver *driver, <span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*remove)(<span class="keyword">struct</span> tty_driver *driver, <span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span>  (*open)(<span class="keyword">struct</span> tty_struct * tty, <span class="keyword">struct</span> file * filp);</span><br><span class="line">    <span class="type">void</span> (*close)(<span class="keyword">struct</span> tty_struct * tty, <span class="keyword">struct</span> file * filp);</span><br><span class="line">    <span class="type">void</span> (*shutdown)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*cleanup)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span>  (*write)(<span class="keyword">struct</span> tty_struct * tty,</span><br><span class="line">              <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">int</span> count);</span><br><span class="line">    <span class="type">int</span>  (*put_char)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">unsigned</span> <span class="type">char</span> ch);</span><br><span class="line">    <span class="type">void</span> (*flush_chars)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*write_room)</span><span class="params">(<span class="keyword">struct</span> tty_struct *tty)</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*chars_in_buffer)</span><span class="params">(<span class="keyword">struct</span> tty_struct *tty)</span>;</span><br><span class="line">    <span class="type">int</span>  (*ioctl)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg);</span><br><span class="line">    <span class="type">long</span> (*compat_ioctl)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">                 <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg);</span><br><span class="line">    <span class="type">void</span> (*set_termios)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> ktermios * old);</span><br><span class="line">    <span class="type">void</span> (*throttle)(<span class="keyword">struct</span> tty_struct * tty);</span><br><span class="line">    <span class="type">void</span> (*unthrottle)(<span class="keyword">struct</span> tty_struct * tty);</span><br><span class="line">    <span class="type">void</span> (*stop)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*start)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*hangup)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span> (*break_ctl)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">int</span> state);</span><br><span class="line">    <span class="type">void</span> (*flush_buffer)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*set_ldisc)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*wait_until_sent)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">int</span> timeout);</span><br><span class="line">    <span class="type">void</span> (*send_xchar)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">char</span> ch);</span><br><span class="line">    <span class="type">int</span> (*tiocmget)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span> (*tiocmset)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">set</span>, <span class="type">unsigned</span> <span class="type">int</span> clear);</span><br><span class="line">    <span class="type">int</span> (*resize)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> winsize *ws);</span><br><span class="line">    <span class="type">int</span> (*get_icount)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">                <span class="keyword">struct</span> serial_icounter_struct *icount);</span><br><span class="line">    <span class="type">int</span>  (*get_serial)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> serial_struct *p);</span><br><span class="line">    <span class="type">int</span>  (*set_serial)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> serial_struct *p);</span><br><span class="line">    <span class="type">void</span> (*show_fdinfo)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> seq_file *m);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CONSOLE_POLL</span></span><br><span class="line">    <span class="type">int</span> (*poll_init)(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> line, <span class="type">char</span> *options);</span><br><span class="line">    <span class="type">int</span> (*poll_get_char)(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> line);</span><br><span class="line">    <span class="type">void</span> (*poll_put_char)(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> line, <span class="type">char</span> ch);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> (*proc_show)(<span class="keyword">struct</span> seq_file *, <span class="type">void</span> *);</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>

<h3 id="数据泄露"><a href="#数据泄露" class="headerlink" title="数据泄露"></a>数据泄露</h3><h4 id="内核-text-段地址"><a href="#内核-text-段地址" class="headerlink" title="内核 .text 段地址"></a>内核 .text 段地址</h4><p>我们可以通过 tty_struct 的函数表 <code>tty_operations</code> 来泄露内核 <code>.text</code> 段的地址：</p>
<p>在 ptmx 被打开时内核通过 <code>alloc_tty_struct()</code> 分配 tty_struct 的内存空间，之后会将 tty_operations 初始化为<strong>全局变量</strong> <code>ptm_unix98_ops</code> 或 <code>pty_unix98_ops </code>，在调试阶段我们可以先关掉 kaslr 开 root 从 <code>/proc/kallsyms</code> 中读取其偏移</p>
<p>开启了 kaslr 的内核在内存中的偏移依然以内存页为粒度，故我们可以通过比对 tty_operations 地址的低三16进制位来判断是 ptm_unix98_ops 还是 pty_unix98_ops</p>
<h4 id="内核线性映射区（-direct-mapping-area）"><a href="#内核线性映射区（-direct-mapping-area）" class="headerlink" title="*内核线性映射区（ direct mapping area）"></a><em>*内核线性映射区（ direct mapping area）</em></h4><p>tty_struct 的 <code>dev</code> 成员与 <code>driver</code> 成员都是通过 kmalloc 分配的，那么我们可以通过这两个成员泄露内核线性映射区的地址</p>
<blockquote>
<p>笔者目前暂时还没找到通过该结构泄露 page_offset_base 的方法</p>
</blockquote>
<h3 id="劫持内核执行流"><a href="#劫持内核执行流" class="headerlink" title="劫持内核执行流"></a>劫持内核执行流</h3><p>若我们能够劫持相应 tty 设备（例如 &#x2F;dev&#x2F;ptmx）的 <code>tty_struct</code> 结构体与其内部的 <code>tty_operations</code> 函数表，那么在我们对这个设备进行相应操作（如write、ioctl）时便会执行我们布置好的恶意函数指针，从而劫持内核执行流（例如<a target="_blank" rel="noopener" href="https://arttnba3.cn/2021/03/03/NOTE-0X03-LINUX-KERNEL-PWN-PART-II/#%E8%A7%A3%E6%B3%95%E4%B8%80%EF%BC%9Auserfaultfd-heap-spray-Kernel-UAF-stack-migration-KPTI-bypass">强网杯2021-noteook</a>)</p>
<h1 id="0x02-seq-file-相关"><a href="#0x02-seq-file-相关" class="headerlink" title="0x02.seq_file 相关"></a>0x02.seq_file 相关</h1><p><strong>序列文件接口</strong>（Sequence File Interface）是针对 procfs 默认操作函数每次只能读取一页数据从而难以处理较大 proc 文件的情况下出现的，其为内核编程提供了更为友好的接口</p>
<h2 id="seq-file"><a href="#seq-file" class="headerlink" title="seq_file"></a>seq_file</h2><p>为了简化操作，在内核 <code>seq_file</code> 系列接口中为 file 结构体提供了 private data 成员 <code>seq_file</code> 结构体，该结构体定义于 <code>/include/linux/seq_file.h</code> 当中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seq_file</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *buf;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="type">size_t</span> from;</span><br><span class="line">    <span class="type">size_t</span> count;</span><br><span class="line">    <span class="type">size_t</span> pad_until;</span><br><span class="line">    <span class="type">loff_t</span> index;</span><br><span class="line">    <span class="type">loff_t</span> read_pos;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">lock</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> *<span class="title">op</span>;</span></span><br><span class="line">    <span class="type">int</span> poll_event;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    <span class="type">void</span> *private;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中的函数表成员 op 在打开文件时通过 kmalloc 进行动态分配</p>
<h2 id="single-open"><a href="#single-open" class="headerlink" title="single_open"></a>single_open</h2><p> 为了更进一步简化内核接口的实现，seq_file 接口提供了 single_open() 这个简化的初始化 file 的函数，其定义于 <code>fs/seq_file.c</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">single_open</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">int</span> (*show)(<span class="keyword">struct</span> seq_file *, <span class="type">void</span> *),</span></span><br><span class="line"><span class="params">        <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> *<span class="title">op</span> =</span> kmalloc(<span class="keyword">sizeof</span>(*op), GFP_KERNEL_ACCOUNT);</span><br><span class="line">    <span class="type">int</span> res = -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (op) &#123;</span><br><span class="line">        op-&gt;start = single_start;</span><br><span class="line">        op-&gt;next = single_next;</span><br><span class="line">        op-&gt;stop = single_stop;</span><br><span class="line">        op-&gt;show = show;</span><br><span class="line">        res = seq_open(file, op);</span><br><span class="line">        <span class="keyword">if</span> (!res)</span><br><span class="line">            ((<span class="keyword">struct</span> seq_file *)file-&gt;private_data)-&gt;private = data;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            kfree(op);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(single_open);</span><br></pre></td></tr></table></figure>

<p>其中我们可以看到的是在这里使用了 kmalloc 来分配 seq_operations 所需空间，这使得我们有机可乘</p>
<p>但是我们很难直接操纵 seq_file 结构体，这是因为其所需空间通过 <code>seq_open()</code> 中调用 kzalloc 从单独的 <code>seq_file_cache</code> 中分配</p>
<h2 id="seq-operations（kmalloc-32-GFP-KERNEL-ACCOUNT）：seq-file-函数表"><a href="#seq-operations（kmalloc-32-GFP-KERNEL-ACCOUNT）：seq-file-函数表" class="headerlink" title="seq_operations（kmalloc-32 | GFP_KERNEL_ACCOUNT）：seq_file 函数表"></a>seq_operations（kmalloc-32 | GFP_KERNEL_ACCOUNT）：seq_file 函数表</h2><p>该结构体定义于 <code>/include/linux/seq_file.h</code> 当中，只定义了四个函数指针，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> * (*start) (<span class="keyword">struct</span> seq_file *m, <span class="type">loff_t</span> *pos);</span><br><span class="line">    <span class="type">void</span> (*stop) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v);</span><br><span class="line">    <span class="type">void</span> * (*next) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v, <span class="type">loff_t</span> *pos);</span><br><span class="line">    <span class="type">int</span> (*show) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="分配-x2F-释放-1"><a href="#分配-x2F-释放-1" class="headerlink" title="分配&#x2F;释放"></a>分配&#x2F;释放</h3><p>前面我们得知通过 single_open() 函数可以分配 seq_operations 结构体，阅读内核源码，我们注意到存在如下调用链：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stat_open()        &lt;--- stat_proc_ops.proc_open</span><br><span class="line">    single_open_size()</span><br><span class="line">        single_open()</span><br></pre></td></tr></table></figure>

<p>注意到 stat_open() 为 procfs 中的 stat 文件对应的 proc_ops 函数表中 open 函数对应的默认函数指针，在内核源码 <code>fs/proc/stat.c</code> 中有如下定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_ops</span> <span class="title">stat_proc_ops</span> =</span> &#123;</span><br><span class="line">    .proc_flags    = PROC_ENTRY_PERMANENT,</span><br><span class="line">    .proc_open    = stat_open,</span><br><span class="line">    .proc_read_iter    = seq_read_iter,</span><br><span class="line">    .proc_lseek    = seq_lseek,</span><br><span class="line">    .proc_release    = single_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">proc_stat_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    proc_create(<span class="string">&quot;stat&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>, &amp;stat_proc_ops);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">fs_initcall(proc_stat_init);</span><br></pre></td></tr></table></figure>

<p>即该文件对应的是 <code>/proc/id/stat</code> 文件，那么只要我们打开 <code>proc/self/stat</code> 文件便能分配到新的 seq_operations 结构体</p>
<p>对应地，在定义于 <code>fs/seq_file.c</code> 中的 <code>single_release()</code> 为 stat 文件的 proc_ops 的默认 release 指针，其会释放掉对应的 seq_operations 结构体，故我们只需要关闭文件即可释放该结构体</p>
<h3 id="数据泄露-1"><a href="#数据泄露-1" class="headerlink" title="数据泄露"></a>数据泄露</h3><h4 id="内核-text-段地址-1"><a href="#内核-text-段地址-1" class="headerlink" title="内核 .text 段地址"></a>内核 .text 段地址</h4><p>seq_operations 结构体中有着四个内核指针（笔者尚未求证具体是什么函数），若是能够读出这些指针的值我们便毫无疑问能泄露出内核 .text 段的基址</p>
<h3 id="劫持内核执行流-1"><a href="#劫持内核执行流-1" class="headerlink" title="劫持内核执行流"></a>劫持内核执行流</h3><p>当我们 read 一个 stat 文件时，内核会调用其 proc_ops 的 <code>proc_read_iter</code> 指针，其默认值为 <code>seq_read_iter()</code> 函数，定义于 <code>fs/seq_file.c</code> 中，注意到有如下逻辑：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">seq_read_iter</span><span class="params">(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">struct</span> iov_iter *iter)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seq_file</span> *<span class="title">m</span> =</span> iocb-&gt;ki_filp-&gt;private_data;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    p = m-&gt;op-&gt;start(m, &amp;m-&gt;index);</span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<p>即其会调用 seq_operations 中的 start 函数指针，那么<strong>我们只需要控制 seq_operations-&gt;start 后再读取对应 stat 文件便能控制内核执行流</strong>（例如 <a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/258160">InCTF 2021 - Kqueue</a>）</p>
<h1 id="0x03-ldt-struct-与-modify-ldt-系统调用"><a href="#0x03-ldt-struct-与-modify-ldt-系统调用" class="headerlink" title="0x03.ldt_struct 与 modify_ldt 系统调用"></a>0x03.ldt_struct 与 modify_ldt 系统调用</h1><p>ldt 即<strong>局部段描述符表</strong>（<strong>Local Descriptor Table</strong>），其中存放着<strong>进程的</strong>段描述符，段寄存器当中存放着的段选择子便是段描述符表中段描述符的索引，在内核中与 ldt 相关联的结构体为 ldt_struct</p>
<p>在 TCTF&#x2F;0CTF 2021 FINAL 当中由 <a target="_blank" rel="noopener" href="https://github.com/yzloser">yzloser 师傅</a>展示给我们的一种_十分美妙的利用方式_——通过 modify_ldt 系统调用来操纵内核中的 ldt_struct 以进行内核空间中的任意读写</p>
<p>完整利用过程的例子可以参见<a target="_blank" rel="noopener" href="https://arttnba3.cn/2021/10/31/CTF-0X05-TCTF2021_FINAL/">TCTF2021 FINAL - kernote</a></p>
<h2 id="modify-ldt-系统调用"><a href="#modify-ldt-系统调用" class="headerlink" title="modify_ldt 系统调用"></a>modify_ldt 系统调用</h2><p>该系统调用可以用来操纵对应进程的 ldt_struct</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(modify_ldt, <span class="type">int</span> , func , <span class="type">void</span> __user * , ptr ,</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> , bytecount)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = -ENOSYS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (func) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        ret = read_ldt(ptr, bytecount);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        ret = write_ldt(ptr, bytecount, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        ret = read_default_ldt(ptr, bytecount);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x11</span>:</span><br><span class="line">        ret = write_ldt(ptr, bytecount, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The SYSCALL_DEFINE() macros give us an &#x27;unsigned long&#x27;</span></span><br><span class="line"><span class="comment">     * return type, but tht ABI for sys_modify_ldt() expects</span></span><br><span class="line"><span class="comment">     * &#x27;int&#x27;.  This cast gives us an int-sized value in %rax</span></span><br><span class="line"><span class="comment">     * for the return code.  The &#x27;unsigned&#x27; is necessary so</span></span><br><span class="line"><span class="comment">     * the compiler does not try to sign-extend the negative</span></span><br><span class="line"><span class="comment">     * return codes into the high half of the register when</span></span><br><span class="line"><span class="comment">     * taking the value from int-&gt;long.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">int</span>)ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ldt-struct-kmalloc-16-slub-x2F-kmalloc-32-slab"><a href="#ldt-struct-kmalloc-16-slub-x2F-kmalloc-32-slab" class="headerlink" title="ldt_struct:  kmalloc-16(slub)&#x2F;kmalloc-32(slab)"></a>ldt_struct:  kmalloc-16(slub)&#x2F;kmalloc-32(slab)</h2><p>该结构体定义于内核源码 <code>arch/x86/include/asm/mmu_context.h</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ldt_struct</span> &#123;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Xen requires page-aligned LDTs with special permissions.  This is</span></span><br><span class="line"><span class="comment">     * needed to prevent us from installing evil descriptors such as</span></span><br><span class="line"><span class="comment">     * call gates.  On native, we could merge the ldt_struct and LDT</span></span><br><span class="line"><span class="comment">     * allocations, but it&#x27;s not worth trying to optimize.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span>    *<span class="title">entries</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        nr_entries;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If PTI is in use, then the entries array is not mapped while we&#x27;re</span></span><br><span class="line"><span class="comment">     * in user mode.  The whole array will be aliased at the addressed</span></span><br><span class="line"><span class="comment">     * given by ldt_slot_va(slot).  We use two slots so that we can allocate</span></span><br><span class="line"><span class="comment">     * and map, and enable a new LDT without invalidating the mapping</span></span><br><span class="line"><span class="comment">     * of an older, still-in-use LDT.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * slot will be -1 if this LDT doesn&#x27;t have an alias mapping.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span>            slot;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="分配（GFP-KERNEL）：modify-ldt-系统调用——write-ldt"><a href="#分配（GFP-KERNEL）：modify-ldt-系统调用——write-ldt" class="headerlink" title="分配（GFP_KERNEL）：modify_ldt 系统调用——write_ldt()"></a>分配（GFP_KERNEL）：modify_ldt 系统调用——write_ldt()</h3><p> 定义于 <code>/arch/x86/kernel/ldt.c</code>中，我们主要关注如下逻辑： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">write_ldt</span><span class="params">(<span class="type">void</span> __user *ptr, <span class="type">unsigned</span> <span class="type">long</span> bytecount, <span class="type">int</span> oldmode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    error = -ENOMEM;</span><br><span class="line">    new_ldt = alloc_ldt_struct(new_nr_entries);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 我们注意到在 write_ldt() 当中会使用 alloc_ldt_struct() 函数来为新的 ldt_struct 分配空间，随后将之应用到进程， alloc_ldt_struct() 函数定义于 <code>arch/x86/kernel/ldt.c</code> 中，我们主要关注如下逻辑： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The caller must call finalize_ldt_struct on the result. LDT starts zeroed. */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> ldt_struct *<span class="title function_">alloc_ldt_struct</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> num_entries)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ldt_struct</span> *<span class="title">new_ldt</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> alloc_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (num_entries &gt; LDT_ENTRIES)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    new_ldt = kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ldt_struct), GFP_KERNEL);</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<p>即我们可以通过 modify_ldt 系统调用来分配新的 ldt_struct</p>
<h3 id="数据泄露：modify-ldt-系统调用——read-ldt"><a href="#数据泄露：modify-ldt-系统调用——read-ldt" class="headerlink" title="数据泄露：modify_ldt 系统调用——read_ldt()"></a>数据泄露：modify_ldt 系统调用——read_ldt()</h3><p> 定义于 <code>/arch/x86/kernel/ldt.c</code>中，我们主要关注如下逻辑： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">read_ldt</span><span class="params">(<span class="type">void</span> __user *ptr, <span class="type">unsigned</span> <span class="type">long</span> bytecount)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(ptr, mm-&gt;context.ldt-&gt;entries, entries_size)) &#123;</span><br><span class="line">        retval = -EFAULT;</span><br><span class="line">        <span class="keyword">goto</span> out_unlock;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">out_unlock:</span><br><span class="line">    up_read(&amp;mm-&gt;context.ldt_usr_sem);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里会<strong>直接调用 copy_to_user 向用户地址空间拷贝数据</strong>，我们不难想到的是若是能够控制 ldt-&gt;entries 便能够完成内核的任意地址读，由此泄露出内核数据</p>
<h4 id="①-爆破内核-text-段地址与-page-offset-base"><a href="#①-爆破内核-text-段地址与-page-offset-base" class="headerlink" title="① 爆破内核 .text 段地址与 page_offset_base"></a>① 爆破内核 .text 段地址与 page_offset_base</h4><p>前面讲到若是能够控制 ldt-&gt;entries 便能够完成内核的任意地址读 ，但在开启 KASLR 的情况下，我们并不知道该从哪里读取什么数据</p>
<p>这里我们要用到 <code>copy_to_user</code> 的一个特性：对于非法地址，其<strong>并不会造成 kernel panic，只会返回一个非零的错误码</strong>，我们不难想到的是，我们可以多次修改 ldt-&gt;entries 并多次调用 modify_ldt() 以<strong>爆破内核 .text 段地址与 page_offset_base</strong>，若是成功命中，则 modify_ldt 会返回给我们一个非负值</p>
<h4 id="②-利用-fork-完成-hardened-usercopy-下的任意地址读"><a href="#②-利用-fork-完成-hardened-usercopy-下的任意地址读" class="headerlink" title="② 利用 fork 完成 hardened usercopy 下的任意地址读"></a>② 利用 fork 完成 hardened usercopy 下的任意地址读</h4><p>当内核开启了 hardened usercopy 时，我们不能够直接搜索整个线性映射区域，这因为这有可能触发 hardened usercopy 的检查</p>
<p>ldt 是一个与进程全局相关的东西，因此现在让我们将目光放到与进程相关的其他方面上——观察 fork 系统调用的源码，我们可以发现如下执行链：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sys_fork()</span><br><span class="line">    kernel_clone()</span><br><span class="line">        copy_process()</span><br><span class="line">            copy_mm()</span><br><span class="line">                dup_mm()</span><br><span class="line">                    dup_mmap()</span><br><span class="line">                        arch_dup_mmap()</span><br><span class="line">                            ldt_dup_context()</span><br></pre></td></tr></table></figure>

<p>ldt_dup_context() 定义于 <code>arch/x86/kernel/ldt.c</code> 中，注意到如下逻辑：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Called on fork from arch_dup_mmap(). Just copy the current LDT state,</span></span><br><span class="line"><span class="comment"> * the new task is not running, so nothing can be installed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ldt_dup_context</span><span class="params">(<span class="keyword">struct</span> mm_struct *old_mm, <span class="keyword">struct</span> mm_struct *mm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(new_ldt-&gt;entries, old_mm-&gt;context.ldt-&gt;entries,</span><br><span class="line">           new_ldt-&gt;nr_entries * LDT_ENTRY_SIZE);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里会通过 memcpy 将父进程的 ldt-&gt;entries 拷贝给子进程，<strong>是完全处在内核中的操作</strong>，因此不会触发 hardened usercopy 的检查，我们只需要在父进程中设定好搜索的地址之后再开子进程来用 read_ldt() 读取数据即可</p>
<h3 id="任意地址写：modify-ldt-系统调用——write-ldt"><a href="#任意地址写：modify-ldt-系统调用——write-ldt" class="headerlink" title="任意地址写：modify_ldt 系统调用——write_ldt()"></a>任意地址写：modify_ldt 系统调用——write_ldt()</h3><p>现在让我们将目光放到 modify_ldt 系统调用中的 <code>write_ldt()</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">write_ldt</span><span class="params">(<span class="type">void</span> __user *ptr, <span class="type">unsigned</span> <span class="type">long</span> bytecount, <span class="type">int</span> oldmode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    old_ldt       = mm-&gt;context.ldt;</span><br><span class="line">    old_nr_entries = old_ldt ? old_ldt-&gt;nr_entries : <span class="number">0</span>;</span><br><span class="line">    new_nr_entries = max(ldt_info.entry_number + <span class="number">1</span>, old_nr_entries);</span><br><span class="line"></span><br><span class="line">    error = -ENOMEM;</span><br><span class="line">    new_ldt = alloc_ldt_struct(new_nr_entries);</span><br><span class="line">    <span class="keyword">if</span> (!new_ldt)</span><br><span class="line">        <span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (old_ldt)</span><br><span class="line">        <span class="built_in">memcpy</span>(new_ldt-&gt;entries, old_ldt-&gt;entries, old_nr_entries * LDT_ENTRY_SIZE);</span><br><span class="line"></span><br><span class="line">    new_ldt-&gt;entries[ldt_info.entry_number] = ldt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 我们可以看到的是，在 memcpy 时所拷贝的字节数为 <code>old_ldt-&gt;nr_entries * LDT_ENTRY_SIZE</code>，其中前者的上限值与后者都定义于 <code>arch/x86/include/uapi/asm/ldt.h</code> 中，如下： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Maximum number of LDT entries supported. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LDT_ENTRIES    8192</span></span><br><span class="line"><span class="comment">/* The size of each LDT entry. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LDT_ENTRY_SIZE    8</span></span><br></pre></td></tr></table></figure>

<p> 那么这个数据量相对较大，拷贝需要用到一定的时间，而在拷贝结束后有一句 <code>new_ldt-&gt;entries[ldt_info.entry_number] = ldt</code>，其中 ldt 为我们传入的数据，我们不难想到的是<strong>可以通过条件竞争的方式在 memcpy 过程中将 new_ldt-&gt;entries 更改为我们的目标地址从而完成任意地址写</strong>，即 double fetch </p>
<h1 id="0x04-pt-regs-与系统调用相关"><a href="#0x04-pt-regs-与系统调用相关" class="headerlink" title="0x04.pt_regs 与系统调用相关"></a>0x04.pt_regs 与系统调用相关</h1><p>严格意义上而言，<code>pt_regs</code> 并非是通过 slub 分配而来的一个结构体，而是<strong>固定位于内核栈底的一个结构体</strong>，由于其上的数据对我们而言是部分可控的，因此该结构体在内核利用当中也能发挥相当的作用</p>
<h2 id="系统调用部分过程-与-pt-regs-结构体"><a href="#系统调用部分过程-与-pt-regs-结构体" class="headerlink" title="系统调用部分过程 与 pt_regs 结构体"></a>系统调用部分过程 与 pt_regs 结构体</h2><p>系统调用的本质是什么？或许不少人都能够答得上来是由我们在用户态布置好相应的参数后执行 <code>syscall</code> 这一汇编指令，通过门结构进入到内核中的 <code>entry_SYSCALL_64</code>这一函数，随后通过系统调用表跳转到对应的函数</p>
<p>现在让我们将目光放到 <code>entry_SYSCALL_64</code> 这一用汇编写的函数内部，观察，我们不难发现其有着<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/latest/source/arch/x86/entry/entry_64.S#L107">这样一条指令</a>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUSH_AND_CLEAR_REGS rax=$-ENOSYSCopy</span><br></pre></td></tr></table></figure>

<p>这是一条十分有趣的指令，它会将所有的寄存器<strong>压入内核栈上，形成一个 pt_regs 结构体</strong>，该结构体实质上位于内核栈底：</p>
<p><a target="_blank" rel="noopener" href="https://i.loli.net/2021/11/14/NwjgEMse8cTCdLr.png"><img src="https://i.loli.net/2021/11/14/NwjgEMse8cTCdLr.png" alt="image.png"></a></p>
<p>该结构体的<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/latest/source/arch/x86/include/uapi/asm/ptrace.h#L44">定义</a>如下： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * C ABI says these regs are callee-preserved. They aren&#x27;t saved on kernel entry</span></span><br><span class="line"><span class="comment"> * unless syscall needs a complete, fully filled &quot;struct pt_regs&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r15;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r14;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r13;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r12;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rbp;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rbx;</span><br><span class="line"><span class="comment">/* These regs are callee-clobbered. Always saved on kernel entry. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r11;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r10;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r9;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r8;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rax;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rcx;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rdx;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rsi;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rdi;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * On syscall entry, this is syscall#. On CPU exception, this is error code.</span></span><br><span class="line"><span class="comment"> * On hw interrupt, it&#x27;s IRQ number:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> orig_rax;</span><br><span class="line"><span class="comment">/* Return frame for iretq */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rip;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> cs;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> eflags;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rsp;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ss;</span><br><span class="line"><span class="comment">/* top of stack page */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="内核栈-与-通用-ROP"><a href="#内核栈-与-通用-ROP" class="headerlink" title="内核栈 与 通用 ROP"></a>内核栈 与 通用 ROP</h2><p>我们都知道，内核栈<strong>只有一个页面的大小</strong>，而 pt_regs 结构体则固定位于<strong>内核栈栈底</strong>，当我们劫持内核结构体中的某个函数指针时（例如 seq_operations-&gt;start），在我们通过该函数指针劫持内核执行流时 <strong>rsp 与 栈底的相对偏移通常是不变的</strong></p>
<p>而在系统调用当中过程有很多的寄存器其实是不一定能用上的，比如 r8 ~ r15，<strong>这些寄存器为我们布置 ROP 链提供了可能，我们不难想到：</strong></p>
<ul>
<li><strong>只需要寻找到一条形如 “add rsp, val ; ret” 的 gadget 便能够完成 ROP</strong></li>
</ul>
<blockquote>
<p>这是一个方便进行调试的板子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">__asm__(</span><br><span class="line">    <span class="string">&quot;mov r15,   0xbeefdead;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov r14,   0x11111111;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov r13,   0x22222222;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov r12,   0x33333333;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov rbp,   0x44444444;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov rbx,   0x55555555;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov r11,   0x66666666;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov r10,   0x77777777;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov r9,    0x88888888;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov r8,    0x99999999;&quot;</span></span><br><span class="line">    <span class="string">&quot;xor rax,   rax;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov rcx,   0xaaaaaaaa;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov rdx,   8;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov rsi,   rsp;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov rdi,   seq_fd;&quot;</span>        <span class="comment">// 这里假定通过 seq_operations-&gt;stat 来触发</span></span><br><span class="line">    <span class="string">&quot;syscall&quot;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>例题：<a target="_blank" rel="noopener" href="https://arttnba3.cn/2021/03/03/NOTE-0X03-LINUX-KERNEL-PWN-PART-II/#%E4%BE%8B%E9%A2%98%EF%BC%9A%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%912021%E7%BA%BF%E4%B8%8A%E5%88%9D%E8%B5%9B-easykernel">西湖论剑 2021 线上初赛 - easykernel</a></p>
<h3 id="新版本内核对抗利用-pt-regs-进行攻击的办法"><a href="#新版本内核对抗利用-pt-regs-进行攻击的办法" class="headerlink" title="新版本内核对抗利用 pt_regs 进行攻击的办法"></a>新版本内核对抗利用 pt_regs 进行攻击的办法</h3><p>正所谓魔高一尺道高一丈，内核主线在 <a target="_blank" rel="noopener" href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=eea2647e74cd7bd5d04861ce55fa502de165de14">这个 commit</a> 中为系统调用栈<strong>添加了一个偏移值，这意味着 pt_regs 与我们触发劫持内核执行流时的栈间偏移值不再是固定值</strong></p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">diff --git a/arch/x86/entry/common.c b/arch/x86/entry/common.c</span></span><br><span class="line"><span class="comment">index 4efd39aacb9f2..7b2542b13ebd9 100644</span></span><br><span class="line"><span class="comment">--- a/arch/x86/entry/common.c</span></span><br><span class="line"><span class="comment">+++ b/arch/x86/entry/common.c</span></span><br><span class="line"><span class="meta">@@ -38,6 +38,7 @@</span></span><br><span class="line"> #ifdef CONFIG_X86_64</span><br><span class="line"> __visible noinstr void do_syscall_64(unsigned long nr, struct pt_regs *regs)</span><br><span class="line"> &#123;</span><br><span class="line"><span class="addition">+	add_random_kstack_offset();</span></span><br><span class="line"> 	nr = syscall_enter_from_user_mode(regs, nr);</span><br><span class="line"> </span><br><span class="line"> 	instrumentation_begin();</span><br></pre></td></tr></table></figure>

<p>当然，若是在这个随机偏移值较小且我们仍有足够多的寄存器可用的情况下，仍然可以通过布置一些 slide gadget 来继续完成利用，不过稳定性也大幅下降了， <em>可以说这种利用方式基本上是废了</em></p>
<h1 id="0x05-setxattr-相关"><a href="#0x05-setxattr-相关" class="headerlink" title="0x05.setxattr 相关"></a>0x05.setxattr 相关</h1><p><strong>setxattr</strong> 并非一个内核结构体，而是一个系统调用，但在 kernel pwn 当中这同样是一个十分有用的系统调用，利用这个系统调用，我们可以进行内核空间中任意大小的 object 的分配，<strong>通常需要配合 userfaultfd 系统调用</strong>完成进一步的利用</p>
<h2 id="任意大小-object-分配（GFP-KERNEL）-amp-释放"><a href="#任意大小-object-分配（GFP-KERNEL）-amp-释放" class="headerlink" title="任意大小 object 分配（GFP_KERNEL）&amp; 释放"></a>任意大小 object 分配（GFP_KERNEL）&amp; 释放</h2><p>观察 setxattr 源码，发现如下调用链：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SYS_setxattr()</span><br><span class="line">    path_setxattr()</span><br><span class="line">        setxattr()</span><br></pre></td></tr></table></figure>

<p>在 <code>setxattr()</code> 函数中有如下逻辑：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span></span><br><span class="line"><span class="title function_">setxattr</span><span class="params">(<span class="keyword">struct</span> dentry *d, <span class="type">const</span> <span class="type">char</span> __user *name, <span class="type">const</span> <span class="type">void</span> __user *value,</span></span><br><span class="line"><span class="params">     <span class="type">size_t</span> size, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">        kvalue = kvmalloc(size, GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (!kvalue)</span><br><span class="line">            <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(kvalue, value, size)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//,..</span></span><br><span class="line"></span><br><span class="line">    kvfree(kvalue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 value 和 size 都是由我们来指定的，即<strong>我们可以分配任意大小的 object 并向其中写入内容</strong></p>
<h2 id="setxattr-userfaultfd-堆占位技术"><a href="#setxattr-userfaultfd-堆占位技术" class="headerlink" title="setxattr + userfaultfd 堆占位技术"></a>setxattr + userfaultfd 堆占位技术</h2><p>但是该 object 在 setxattr 执行结束时又会被放回 freelist 中，设想若是我们需要劫持该 object 的前 8 字节，那将前功尽弃</p>
<p>重新考虑 setxattr 的执行流程，其中会调用 <code>copy_from_user</code> 从用户空间拷贝数据，那么让我们考虑如下场景：</p>
<p>我们通过 mmap 分配连续的两个页面，在第二个页面上启用 userfaultfd，并在第一个页面的末尾写入我们想要的数据，此时我们调用 setxattr 进行<strong>跨页面的拷贝</strong>，当 copy_from_user 拷贝到第二个页面时<strong>便会触发 userfaultfd，从而让 setxattr 的执行流程卡在此处，这样这个 object 就不会被释放掉，而是可以继续参与我们接下来的利用</strong></p>
<p><img src="https://i.loli.net/2021/11/28/vBgSsTLRf5ZdYaJ.png" alt="image.png"></p>
<p>这便是 setxattr + userfaultfd 结合的堆占位技术（例题：<a target="_blank" rel="noopener" href="https://arttnba3.cn/2021/03/03/NOTE-0X03-LINUX-KERNEL-PWN-PART-II/#%E4%BE%8B%E9%A2%98%EF%BC%9ASECCON-2020-kstack">SECCON 2020 kstack</a>）</p>
<h1 id="0x06-shm-file-data-与共享内存相关"><a href="#0x06-shm-file-data-与共享内存相关" class="headerlink" title="0x06.shm_file_data 与共享内存相关"></a>0x06.shm_file_data 与共享内存相关</h1><p><strong>进程间通信</strong>（Inter-Process Communication，IPC）即不同进程间的数据传递问题，在 Linux 当中有一种 IPC 技术名为<strong>共享内存</strong>，在用户态中我们可以通过 <code>shmget</code>、<code>shmat</code>、<code>shmctl</code>、<code>shmdt</code> 这四个系统调用操纵共享内存</p>
<h2 id="shm-file-data（kmalloc-32-GFP-KERNEL）"><a href="#shm-file-data（kmalloc-32-GFP-KERNEL）" class="headerlink" title="shm_file_data（kmalloc-32|GFP_KERNEL）"></a>shm_file_data（kmalloc-32|GFP_KERNEL）</h2><p>该结构体定义于 <code>/ipc/shm.c</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shm_file_data</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> *<span class="title">vm_ops</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="分配：shmat-系统调用"><a href="#分配：shmat-系统调用" class="headerlink" title="分配：shmat 系统调用"></a>分配：shmat 系统调用</h3><p>我们知道使用 <code>shmget</code> 系统调用可以获得一个共享内存对象，随后要使用 <code>shmat</code> 系统调用将共享内存对象映射到进程的地址空间，在该系统调用中调用了 <code>do_shmat()</code> 函数，注意到如下逻辑：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">do_shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">char</span> __user *shmaddr, <span class="type">int</span> shmflg,</span></span><br><span class="line"><span class="params">          ulong *raddr, <span class="type">unsigned</span> <span class="type">long</span> shmlba)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shm_file_data</span> *<span class="title">sfd</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    sfd = kzalloc(<span class="keyword">sizeof</span>(*sfd), GFP_KERNEL);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    file-&gt;private_data = sfd;</span><br></pre></td></tr></table></figure>

<p>即在调用 <code>shmat</code> 系统调用时会创建一个 <code>shm_file_data</code> 结构体，最后会存放在共享内存对象文件的 private_data 域中</p>
<h3 id="释放：shmdt-系统调用"><a href="#释放：shmdt-系统调用" class="headerlink" title="释放：shmdt 系统调用"></a>释放：shmdt 系统调用</h3><p>我们知道使用 <code>shmdt</code> 系统调用用以断开与共享内存对象的连接，观察其源码，发现其会调用 <code>ksys_shmdt()</code> 函数，注意到如下调用链：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SYS_shmdt()</span><br><span class="line">    ksys_shmdt()</span><br><span class="line">        do_munmap()</span><br><span class="line">            remove_vma_list()</span><br><span class="line">                remove_vma()</span><br></pre></td></tr></table></figure>

<p>其中有着这样一条代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> vm_area_struct *<span class="title function_">remove_vma</span><span class="params">(<span class="keyword">struct</span> vm_area_struct *vma)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">next</span> =</span> vma-&gt;vm_next;</span><br><span class="line"></span><br><span class="line">    might_sleep();</span><br><span class="line">    <span class="keyword">if</span> (vma-&gt;vm_ops &amp;&amp; vma-&gt;vm_ops-&gt;close)</span><br><span class="line">        vma-&gt;vm_ops-&gt;close(vma);</span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<p>在这里调用了该 vma 的 vm_ops 对应的 close 函数，我们将目光重新放回共享内存对应的 vma 的初始化的流程当中，在 shmat() 中注意到如下逻辑：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">do_shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">char</span> __user *shmaddr, <span class="type">int</span> shmflg,</span></span><br><span class="line"><span class="params">          ulong *raddr, <span class="type">unsigned</span> <span class="type">long</span> shmlba)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">sfd = kzalloc(<span class="keyword">sizeof</span>(*sfd), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!sfd) &#123;</span><br><span class="line">        fput(base);</span><br><span class="line">        <span class="keyword">goto</span> out_nattch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    file = alloc_file_clone(base, f_flags,</span><br><span class="line">              is_file_hugepages(base) ?</span><br><span class="line">                &amp;shm_file_operations_huge :</span><br><span class="line">                &amp;shm_file_operations);</span><br></pre></td></tr></table></figure>

<p>在这里调用了 <code>alloc_file_clone()</code> 函数，其会调用 <code>alloc_file()</code> 函数将第三个参数赋值给新的 file 结构体的 f_op 域，在这里是 <code>shm_file_operations</code> 或 <code>shm_file_operations_huge</code>，定义于 <code>/ipc/shm.c</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">shm_file_operations</span> =</span> &#123;</span><br><span class="line">    .mmap        = shm_mmap,</span><br><span class="line">    .fsync        = shm_fsync,</span><br><span class="line">    .release    = shm_release,</span><br><span class="line">    .get_unmapped_area    = shm_get_unmapped_area,</span><br><span class="line">    .llseek        = noop_llseek,</span><br><span class="line">    .fallocate    = shm_fallocate,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * shm_file_operations_huge is now identical to shm_file_operations,</span></span><br><span class="line"><span class="comment"> * but we keep it distinct for the sake of is_file_shm_hugepages().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">shm_file_operations_huge</span> =</span> &#123;</span><br><span class="line">    .mmap        = shm_mmap,</span><br><span class="line">    .fsync        = shm_fsync,</span><br><span class="line">    .release    = shm_release,</span><br><span class="line">    .get_unmapped_area    = shm_get_unmapped_area,</span><br><span class="line">    .llseek        = noop_llseek,</span><br><span class="line">    .fallocate    = shm_fallocate,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这里对于关闭 shm 文件，对应的是 <code>shm_release</code> 函数，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">shm_release</span><span class="params">(<span class="keyword">struct</span> inode *ino, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shm_file_data</span> *<span class="title">sfd</span> =</span> shm_file_data(file);</span><br><span class="line"></span><br><span class="line">    put_ipc_ns(sfd-&gt;ns);</span><br><span class="line">    fput(sfd-&gt;file);</span><br><span class="line">    shm_file_data(file) = <span class="literal">NULL</span>;</span><br><span class="line">    kfree(sfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即当我们进行 shmdt 系统调用时便可以释放 <code>shm_file_data</code> 结构体</p>
<h3 id="数据泄露-2"><a href="#数据泄露-2" class="headerlink" title="数据泄露"></a>数据泄露</h3><h4 id="内核-text-段地址-2"><a href="#内核-text-段地址-2" class="headerlink" title="内核 .text 段地址"></a>内核 .text 段地址</h4><p>shm_file_data 的 ns 域 和 vm_ops 域皆指向内核的 .text 段中，若是我们能够泄露这两个指针便能获取到内核 .text 段基址，其中 ns 字段通常指向 <code>init_ipc_ns</code></p>
<h4 id="内核线性映射区（-direct-mapping-area）-1"><a href="#内核线性映射区（-direct-mapping-area）-1" class="headerlink" title="*内核线性映射区（ direct mapping area）"></a><em>*内核线性映射区（ direct mapping area）</em></h4><p>shm_file_data 的 file 域为一个 file 结构体，位于线性映射区中，若能泄露 file 域则同样能泄漏出内核的“堆上地址”</p>
<h1 id="0x07-system-V-消息队列：内核中的“菜单堆”"><a href="#0x07-system-V-消息队列：内核中的“菜单堆”" class="headerlink" title="0x07.system V 消息队列：内核中的“菜单堆”"></a>0x07.system V 消息队列：内核中的“菜单堆”</h1><p>在 Linux kernel 中有着一组 system V 消息队列相关的系统调用：</p>
<ul>
<li>msgget：创建一个消息队列</li>
<li>msgsnd：向指定消息队列发送消息</li>
<li>msgrcv：从指定消息队列接接收消息</li>
</ul>
<p>当我们创建一个消息队列时，在内核空间中会创建一个 <code>msg_queue</code> 结构体，其表示一个消息队列：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* one msq_queue structure for each present queue on the system */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_queue</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span> <span class="title">q_perm</span>;</span></span><br><span class="line">	<span class="type">time64_t</span> q_stime;		<span class="comment">/* last msgsnd time */</span></span><br><span class="line">	<span class="type">time64_t</span> q_rtime;		<span class="comment">/* last msgrcv time */</span></span><br><span class="line">	<span class="type">time64_t</span> q_ctime;		<span class="comment">/* last change time */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> q_cbytes;		<span class="comment">/* current number of bytes on queue */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> q_qnum;		<span class="comment">/* number of messages in queue */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> q_qbytes;		<span class="comment">/* max number of bytes on queue */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">q_lspid</span>;</span>		<span class="comment">/* pid of last msgsnd */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">q_lrpid</span>;</span>		<span class="comment">/* last receive pid */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_messages</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_receivers</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_senders</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>

<h2 id="msg-msg-amp-msg-msgseg：近乎任意大小的对象分配"><a href="#msg-msg-amp-msg-msgseg：近乎任意大小的对象分配" class="headerlink" title="msg_msg &amp; msg_msgseg：近乎任意大小的对象分配"></a>msg_msg &amp; msg_msgseg：近乎任意大小的对象分配</h2><p>当我们调用 msgsnd 系统调用在指定消息队列上发送一条指定大小的 message 时，在内核空间中会创建这样一个结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* one msg_msg structure for each message */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line">	<span class="type">long</span> m_type;</span><br><span class="line">	<span class="type">size_t</span> m_ts;		<span class="comment">/* message text size */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">next</span>;</span></span><br><span class="line">	<span class="type">void</span> *security;</span><br><span class="line">	<span class="comment">/* the actual message follows immediately */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在内核当中这两个结构体形成一个如下结构的循环双向链表：</p>
<p><img src="https://s2.loli.net/2022/02/24/wjzFeZiDUpxXVKJ.png" alt="image.png"></p>
<p>若是消息队列中只有一个消息则是这样：</p>
<p><img src="https://s2.loli.net/2022/02/24/sD9xtpaHrQ2uneZ.png" alt="image.png"></p>
<p>虽然 <code>msg_queue</code> 的大小基本上是固定的，但是 <code>msg_msg</code> 作为承载消息的本体<strong>其大小是可以随着消息大小的改变而进行变动的</strong>，去除掉 msg_msg 结构体本身的 0x30 字节的部分（或许可以称之为 header）<strong>剩余的部分都用来存放用户数据</strong>，因此内核分配的 object 的大小是跟随着我们发送的 message 的大小进行变动的</p>
<p>而当我们单次发送<strong>大于【一个页面大小 - header size】</strong>大小的消息时，内核会额外补充添加 <code>msg_msgseg</code> 结构体，其与 <code>msg_msg</code> 之间形成如下单向链表结构：</p>
<p><img src="https://s2.loli.net/2022/02/24/5IcVxRaFQtg3HCW.png" alt="image.png"></p>
<p>同样地，单个 <code>msg_msgseg</code> 的大小最大为一个页面大小，因此超出这个范围的消息内核会额外补充上更多的 <code>msg_msgseg</code> 结构体</p>
<h3 id="分配（GFP-KERNEL-ACCOUNT）：msgsnd-系统调用"><a href="#分配（GFP-KERNEL-ACCOUNT）：msgsnd-系统调用" class="headerlink" title="分配（GFP_KERNEL_ACCOUNT）：msgsnd 系统调用"></a>分配（GFP_KERNEL_ACCOUNT）：msgsnd 系统调用</h3><p>接下来我们来深入 msg_msg 的内部结构，阅读 msgsnd 源码可知，当我们在消息队列上发送一个 message 时，其首先会调用 <code>load_msg</code> 将该 message 拷贝到内核中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">do_msgsnd</span><span class="params">(<span class="type">int</span> msqid, <span class="type">long</span> mtype, <span class="type">void</span> __user *mtext,</span></span><br><span class="line"><span class="params">		<span class="type">size_t</span> msgsz, <span class="type">int</span> msgflg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_queue</span> *<span class="title">msq</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg</span>;</span></span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line">	DEFINE_WAKE_Q(wake_q);</span><br><span class="line"></span><br><span class="line">	ns = current-&gt;nsproxy-&gt;ipc_ns;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (msgsz &gt; ns-&gt;msg_ctlmax || (<span class="type">long</span>) msgsz &lt; <span class="number">0</span> || msqid &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (mtype &lt; <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	msg = load_msg(mtext, msgsz);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<p>而 <code>load_msg()</code> 最终会调用到 <code>alloc_msg()</code> 分配所需的空间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> msg_msg *<span class="title function_">load_msg</span><span class="params">(<span class="type">const</span> <span class="type">void</span> __user *src, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">seg</span>;</span></span><br><span class="line">	<span class="type">int</span> err = -EFAULT;</span><br><span class="line">	<span class="type">size_t</span> alen;</span><br><span class="line"></span><br><span class="line">	msg = alloc_msg(len);</span><br></pre></td></tr></table></figure>

<p>阅读 <code>alloc_msg()</code> 源码可以发现，其以 msg_msg 结构体为核心生成如下结构：</p>
<ul>
<li>对于大小在【一个页面再减掉作为 header 的 msg_msg 的 size】范围内的数据而言，内核仅会分配一个 size + header size 大小的 object（通过 kmalloc），其前 0x30 大小的部分存放 msg_msg 这一 header，剩余部分用以存放用户数据</li>
<li>对于大小超出【一个页面再减掉作为 header 的 msg_msg 的 size】范围的数据而言，其会额外生成 <code>msg_msgseg</code> 结构体来存放用户数据，通过 kmalloc 分配，大小为剩余未拷贝的用户数据大小加上 next 指针；该结构体与 msg_msg 的 next 成员形成一个<strong>单向链表</strong>，其前 8 字节存放指向下一个 msg_msgseg 的指针，若无则为 NULL</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> msg_msg *<span class="title function_">alloc_msg</span><span class="params">(<span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> **<span class="title">pseg</span>;</span></span><br><span class="line">	<span class="type">size_t</span> alen;</span><br><span class="line"></span><br><span class="line">	alen = min(len, DATALEN_MSG);</span><br><span class="line">	msg = kmalloc(<span class="keyword">sizeof</span>(*msg) + alen, GFP_KERNEL_ACCOUNT);</span><br><span class="line">	<span class="keyword">if</span> (msg == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	msg-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	msg-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	len -= alen;</span><br><span class="line">	pseg = &amp;msg-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">seg</span>;</span></span><br><span class="line"></span><br><span class="line">		cond_resched();</span><br><span class="line"></span><br><span class="line">		alen = min(len, DATALEN_SEG);</span><br><span class="line">		seg = kmalloc(<span class="keyword">sizeof</span>(*seg) + alen, GFP_KERNEL_ACCOUNT);</span><br><span class="line">		<span class="keyword">if</span> (seg == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">goto</span> out_err;</span><br><span class="line">		*pseg = seg;</span><br><span class="line">		seg-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		pseg = &amp;seg-&gt;next;</span><br><span class="line">		len -= alen;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> msg;</span><br><span class="line"></span><br><span class="line">out_err:</span><br><span class="line">	free_msg(msg);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="释放：msgrcv-系统调用"><a href="#释放：msgrcv-系统调用" class="headerlink" title="释放：msgrcv 系统调用"></a>释放：msgrcv 系统调用</h3><p>IPC，有“发”自然伴随着有“收”，我们发送消息时该结构体在内核中被创建，相应地在我们接收消息时该结构体将被从内核中释放，通过 msgrcv 系统调用我们可以从指定的消息队列中接收指定大小的消息，内核首先会调用 <code>list_del()</code> 将其从 <code>msg_queue</code> 的双向链表上 unlink，之后再调用 <code>free_msg()</code> 释放 <code>msg_msg</code> 单向链表上的所有消息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">do_msgrcv</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> __user *buf, <span class="type">size_t</span> bufsz, <span class="type">long</span> msgtyp, <span class="type">int</span> msgflg,</span></span><br><span class="line"><span class="params">	       <span class="type">long</span> (*msg_handler)(<span class="type">void</span> __user *, <span class="keyword">struct</span> msg_msg *, <span class="type">size_t</span>))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    		list_del(&amp;msg-&gt;m_list);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    		<span class="keyword">goto</span> out_unlock0;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">out_unlock0:</span><br><span class="line">	ipc_unlock_object(&amp;msq-&gt;q_perm);</span><br><span class="line">	wake_up_q(&amp;wake_q);</span><br><span class="line">out_unlock1:</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(msg)) &#123;</span><br><span class="line">		free_copy(copy);</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(msg);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bufsz = msg_handler(buf, msg, bufsz);</span><br><span class="line">	free_msg(msg);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> bufsz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="读取：msgrcv-系统调用"><a href="#读取：msgrcv-系统调用" class="headerlink" title="读取：msgrcv 系统调用"></a>读取：msgrcv 系统调用</h3><p>IPC，有“发”自然伴随着有“收”，我们发送消息时该结构体在内核中被创建，相应地，在我们接收消息时 msg_msg 链上的对象上的内容会被拷贝到用户空间，其通过调用 <code>msg_handler()</code> 函数指针完成拷贝，对于 msgrcv 系统调用而言，由如下调用链传入该指针：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SYS_msgrcv()</span><br><span class="line">	ksys_msgrcv()</span><br><span class="line">		do_msgrcv()</span><br></pre></td></tr></table></figure>

<p>最终调用的是 <code>do_msg_fill()</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">do_msg_fill</span><span class="params">(<span class="type">void</span> __user *dest, <span class="keyword">struct</span> msg_msg *msg, <span class="type">size_t</span> bufsz)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> __<span class="title">user</span> *<span class="title">msgp</span> =</span> dest;</span><br><span class="line">	<span class="type">size_t</span> msgsz;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (put_user(msg-&gt;m_type, &amp;msgp-&gt;mtype))</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">	msgsz = (bufsz &gt; msg-&gt;m_ts) ? msg-&gt;m_ts : bufsz;</span><br><span class="line">	<span class="keyword">if</span> (store_msg(msgp-&gt;mtext, msg, msgsz))</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line">	<span class="keyword">return</span> msgsz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该函数中最终调用 <code>store_msg()</code> 完成消息向用户空间的拷贝，<strong>拷贝循环的终止条件是单向链表末尾的 NULL 指针</strong>，拷贝数据的<strong>长度</strong>主要依赖的是 <strong>msg_msg 的 m_ts 成员</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">store_msg</span><span class="params">(<span class="type">void</span> __user *dest, <span class="keyword">struct</span> msg_msg *msg, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">size_t</span> alen;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">seg</span>;</span></span><br><span class="line"></span><br><span class="line">	alen = min(len, DATALEN_MSG);</span><br><span class="line">	<span class="keyword">if</span> (copy_to_user(dest, msg + <span class="number">1</span>, alen))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (seg = msg-&gt;next; seg != <span class="literal">NULL</span>; seg = seg-&gt;next) &#123;</span><br><span class="line">		len -= alen;</span><br><span class="line">		dest = (<span class="type">char</span> __user *)dest + alen;</span><br><span class="line">		alen = min(len, DATALEN_SEG);</span><br><span class="line">		<span class="keyword">if</span> (copy_to_user(dest, seg + <span class="number">1</span>, alen))</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="MSG-COPY：读取但不释放"><a href="#MSG-COPY：读取但不释放" class="headerlink" title="MSG_COPY：读取但不释放"></a>MSG_COPY：读取但不释放</h4><p>当我们在调用 msgrcv 接收消息时，相应的 msg_msg 链表便会被释放，但阅读源码我们会发现，当我们在调用 msgrcv 时若设置了 <code>MSG_COPY</code> 标志位，则<strong>内核会将 message 拷贝一份后再拷贝到用户空间，原双向链表中的 message 并不会被 unlink</strong>，从而我们便可以<strong>多次重复地读取同一个</strong> <code>msg_msg</code> 链条中数据</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (msgflg &amp; MSG_COPY) &#123;</span><br><span class="line">	<span class="keyword">if</span> ((msgflg &amp; MSG_EXCEPT) || !(msgflg &amp; IPC_NOWAIT))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	copy = prepare_copy(buf, <span class="type">min_t</span>(<span class="type">size_t</span>, bufsz, ns-&gt;msg_ctlmax));</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(copy))</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(copy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If we are copying, then do not unlink message and do</span></span><br><span class="line"><span class="comment">		 * not update queue parameters.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (msgflg &amp; MSG_COPY) &#123;</span><br><span class="line">			msg = copy_msg(msg, copy);</span><br><span class="line">			<span class="keyword">goto</span> out_unlock0;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>



<h3 id="数据泄露-3"><a href="#数据泄露-3" class="headerlink" title="数据泄露"></a>数据泄露</h3><h4 id="越界数据读取"><a href="#越界数据读取" class="headerlink" title="越界数据读取"></a>越界数据读取</h4><p>在拷贝数据时对长度的判断主要依靠的是 <code>msg_msg-&gt;m_ts</code>，我们不难想到的是：若是我们能够控制一个 msg_msg 的 header，将其 m_sz 成员改为一个较大的数，我们就能够<strong>越界读取出最多将近一张内存页大小的数据</strong></p>
<h4 id="任意地址读"><a href="#任意地址读" class="headerlink" title="任意地址读"></a>任意地址读</h4><p>对于大于一张内存页的数据而言内核会在 msg_msg 的基础上再补充加上 msg_msgseg 结构体，形成一个单向链表，我们不难想到的是：若是我们能够同时劫持 <code>msg_msg-&gt;m_ts</code> 与 <code>msg_msg-&gt;next</code>，我们<strong>便能够完成内核空间中的任意地址读</strong></p>
<p>但这个方法有一个缺陷，无论是 <code>MSG_COPY</code> 还是常规的接收消息，其拷贝消息的过程的判断主要依据还是单向链表的 next 指针，因此若我们需要完成对特定地址向后的一块区域的读取，<strong>我们需要保证该地址的数据为 NULL</strong></p>
<h4 id="内核线性映射区（-direct-mapping-area）-2"><a href="#内核线性映射区（-direct-mapping-area）-2" class="headerlink" title="*内核线性映射区（ direct mapping area）"></a><em>*内核线性映射区（ direct mapping area）</em></h4><p>虽然我们不能直接读取当前 msg_msg 的 header，但我们不难想到的是：我们可以通过喷射大量的 msg_msg，从而<strong>利用越界读来读取其他 msg_msg 的 header</strong>，通过其双向链表成员泄露出一个“堆”上地址</p>
<p>那么这个“堆”上地址指向哪呢？让我们将目光重新放回 <code>msg_queue</code> 与 <code>msg_msg</code> 结构体之间的关系，当一个消息上只有一个 message 时，我们不难看出 msg_msg 的 prev 与 next 指针都指向 msg_queue 的 <code>q_messages</code> 域，对应地， msg_queue-&gt;q_message 的 prev 与 next 也同样指向 msg_msg 的 <code>m_list</code> 域</p>
<p><img src="https://s2.loli.net/2022/02/24/sD9xtpaHrQ2uneZ.png" alt="image.png"></p>
<p>因此我们可以获得到对应的 <code>msg_queue</code> 的地址，相应地，<strong>我们可以将 msg_msg 的 next 指针指回 msg_queue，从而读出上面的指向 msg_msg 的指针，将未知的地址变为已知的地址</strong></p>
<h4 id="基于堆地址泄露的堆上连续内存搜索"><a href="#基于堆地址泄露的堆上连续内存搜索" class="headerlink" title="**基于堆地址泄露的堆上连续内存搜索"></a>**基于堆地址泄露的堆上连续内存搜索</h4><p>在我们完成对“堆”上地址的泄露之后，我们可以在每一次读取时<strong>挑选已知数据为 NULL 的区域作为 next-&gt;next 以避免 kernel panic</strong>，以此获得<strong>连续的搜索内存的能力</strong>，不过这需要我们拥有足够次数的更改 msg_msg 的 header 的能力</p>
<p>（例题：<a target="_blank" rel="noopener" href="https://arttnba3.cn/2022/03/08/CTF-0X06-D3CTF2022_D3KHEAP/">D^3CTF2022 - d3kheap</a>）</p>
<blockquote>
<p>之前例题本来想选一个以前有的 CTF 题来写的（比如说 corCTF），但是<strong>笔者太懒了</strong>…于是一直拖到最近刚好拿这个结构体出了一道 CTF 题，所以就顺便把这个过去开的坑给补充上…</p>
</blockquote>
<h3 id="任意地址写（结合-userfaultfd-或-FUSE-完成-race-condition-write）"><a href="#任意地址写（结合-userfaultfd-或-FUSE-完成-race-condition-write）" class="headerlink" title="任意地址写（结合 userfaultfd 或 FUSE 完成 race condition write）"></a>任意地址写（结合 userfaultfd 或 FUSE 完成 race condition write）</h3><p>当我们调用 msgsnd 系统调用时，其会调用 <code>load_msg()</code> 将用户空间数据拷贝到内核空间中，首先是调用 <code>alloc_msg()</code> 分配 <code>msg_msg</code> 单向链表，之后才是正式的拷贝过程，即空间的分配与数据的拷贝是分开进行的</p>
<p>我们不难想到的是，<strong>在拷贝时利用 userfaultfd 将拷贝停下来，在子进程中篡改 msg_msg 的 next 指针，在恢复拷贝之后便会向我们篡改后的目标地址上写入数据，从而实现任意地址写</strong></p>
<p>这里借用一张 bsauce 师傅的图来作为🌰说明，图上是将 next 指针劫持到进程的 PCB 上从而修改 cred 指针</p>
<p><img src="https://s2.loli.net/2022/03/09/p7d1PGVaM6TzmLc.png" alt="来自 bsauce 投稿安全客的文章的图片"></p>
<p>（例题：corCTF2021 - Fire of Salvation）</p>
<blockquote>
<p>笔者还没写 wp，这里先🕳着…</p>
</blockquote>
<h1 id="0x08-pipe-管道相关"><a href="#0x08-pipe-管道相关" class="headerlink" title="0x08.pipe 管道相关"></a>0x08.pipe 管道相关</h1><p><strong>管道</strong>同样是内核中十分重要也十分常用的一个 IPC 工具，同样地管道的结构也能够在内核利用中为我们所用，其本质上是创建了一个 virtual inode 与两个对应的文件描述符构成的：</p>
<p><img src="https://s2.loli.net/2022/03/09/yTX7aREhPwsJIbM.png" alt="非常经典的一张图"></p>
<h2 id="pipe-inode-info（kmalloc-192-GFP-KERNEL-ACCOUNT）：管道本体"><a href="#pipe-inode-info（kmalloc-192-GFP-KERNEL-ACCOUNT）：管道本体" class="headerlink" title="pipe_inode_info（kmalloc-192|GFP_KERNEL_ACCOUNT）：管道本体"></a>pipe_inode_info（kmalloc-192|GFP_KERNEL_ACCOUNT）：管道本体</h2><p>在内核中，管道本质上是创建了一个<strong>虚拟的 inode</strong> 来表示的，对应的就是一个 <code>pipe_inode_info</code> 结构体（<code>inode-&gt;i_pipe</code>），其中包含了一个管道的所有信息，当我们创建一个管道时，内核会创建一个 VFS inode 与一个 pipe_inode_info 结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	struct pipe_inode_info - a linux kernel pipe</span></span><br><span class="line"><span class="comment"> *	@mutex: mutex protecting the whole thing</span></span><br><span class="line"><span class="comment"> *	@rd_wait: reader wait point in case of empty pipe</span></span><br><span class="line"><span class="comment"> *	@wr_wait: writer wait point in case of full pipe</span></span><br><span class="line"><span class="comment"> *	@head: The point of buffer production</span></span><br><span class="line"><span class="comment"> *	@tail: The point of buffer consumption</span></span><br><span class="line"><span class="comment"> *	@note_loss: The next read() should insert a data-lost message</span></span><br><span class="line"><span class="comment"> *	@max_usage: The maximum number of slots that may be used in the ring</span></span><br><span class="line"><span class="comment"> *	@ring_size: total number of buffers (should be a power of 2)</span></span><br><span class="line"><span class="comment"> *	@nr_accounted: The amount this pipe accounts for in user-&gt;pipe_bufs</span></span><br><span class="line"><span class="comment"> *	@tmp_page: cached released page</span></span><br><span class="line"><span class="comment"> *	@readers: number of current readers of this pipe</span></span><br><span class="line"><span class="comment"> *	@writers: number of current writers of this pipe</span></span><br><span class="line"><span class="comment"> *	@files: number of struct file referring this pipe (protected by -&gt;i_lock)</span></span><br><span class="line"><span class="comment"> *	@r_counter: reader counter</span></span><br><span class="line"><span class="comment"> *	@w_counter: writer counter</span></span><br><span class="line"><span class="comment"> *	@fasync_readers: reader side fasync</span></span><br><span class="line"><span class="comment"> *	@fasync_writers: writer side fasync</span></span><br><span class="line"><span class="comment"> *	@bufs: the circular array of pipe buffers</span></span><br><span class="line"><span class="comment"> *	@user: the user who created this pipe</span></span><br><span class="line"><span class="comment"> *	@watch_queue: If this pipe is a watch_queue, this is the stuff for that</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line">	<span class="type">wait_queue_head_t</span> rd_wait, wr_wait;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> head;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> tail;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> max_usage;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> ring_size;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line">	<span class="type">bool</span> note_loss;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> nr_accounted;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> readers;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> writers;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> files;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> r_counter;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> w_counter;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">tmp_page</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync_readers</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync_writers</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">bufs</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">watch_queue</span> *<span class="title">watch_queue</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="数据泄露-4"><a href="#数据泄露-4" class="headerlink" title="数据泄露"></a>数据泄露</h3><h4 id="内核线性映射区（-direct-mapping-area）-3"><a href="#内核线性映射区（-direct-mapping-area）-3" class="headerlink" title="*内核线性映射区（ direct mapping area）"></a><em>*内核线性映射区（ direct mapping area）</em></h4><p><code>pipe_inode_info-&gt;bufs</code> 为一个动态分配的结构体数组，因此我们可以利用他来泄露出内核的“堆”上地址</p>
<h2 id="pipe-buffer（kmalloc-1k-GFP-KERNEL-ACCOUNT）：管道数据"><a href="#pipe-buffer（kmalloc-1k-GFP-KERNEL-ACCOUNT）：管道数据" class="headerlink" title="pipe_buffer（kmalloc-1k|GFP_KERNEL_ACCOUNT）：管道数据"></a>pipe_buffer（kmalloc-1k|GFP_KERNEL_ACCOUNT）：管道数据</h2><p>当我们创建一个管道时，在内核中会生成数个连续的 <code>pipe_buffer</code> 结构体，申请的内存总大小刚好会让内核从 kmalloc-1k 中取出一个 object</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	struct pipe_buffer - a linux kernel pipe buffer</span></span><br><span class="line"><span class="comment"> *	@page: the page containing the data for the pipe buffer</span></span><br><span class="line"><span class="comment"> *	@offset: offset of data inside the @page</span></span><br><span class="line"><span class="comment"> *	@len: length of data inside the @page</span></span><br><span class="line"><span class="comment"> *	@ops: operations associated with this buffer. See @pipe_buf_operations.</span></span><br><span class="line"><span class="comment"> *	@flags: pipe buffer flags. See above.</span></span><br><span class="line"><span class="comment"> *	@private: private data owned by the ops.</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> offset, len;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> private;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="分配：pipe-系统调用族"><a href="#分配：pipe-系统调用族" class="headerlink" title="分配：pipe 系统调用族"></a>分配：pipe 系统调用族</h3><p>创建管道使用的自然是 pipe 与 pipe2 这两个系统调用，其最终都会调用到 <code>do_pipe2()</code> 这个函数，不同的是后者我们可以指定一个 flag，而前者默认 flag 为 0</p>
<p>存在如下调用链：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">do_pipe2()</span><br><span class="line">	__do_pipe_flags()</span><br><span class="line">		create_pipe_files()</span><br><span class="line">			get_pipe_inode()</span><br><span class="line">				alloc_pipe_info()</span><br></pre></td></tr></table></figure>

<p>最终调用 <code>kcalloc()</code> 分配一个 <code>pipe_buffer</code> 数组，默认数量为 <code>PIPE_DEF_BUFFERS</code> （16）个，因此会直接从 kmalloc-1k 中拿 object：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> pipe_inode_info *<span class="title function_">alloc_pipe_info</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> pipe_bufs = PIPE_DEF_BUFFERS;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span> =</span> get_current_user();</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> user_bufs;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> max_size = READ_ONCE(pipe_max_size);</span><br><span class="line"></span><br><span class="line">	pipe = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_inode_info), GFP_KERNEL_ACCOUNT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">	pipe-&gt;bufs = kcalloc(pipe_bufs, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_buffer),</span><br><span class="line">			     GFP_KERNEL_ACCOUNT);</span><br></pre></td></tr></table></figure>

<h3 id="释放：close-系统调用"><a href="#释放：close-系统调用" class="headerlink" title="释放：close 系统调用"></a>释放：close 系统调用</h3><p>当我们关闭一个管道的两端之后，对应的管道就会被释放掉，相应地，<code>pipe_buffer</code> 数组也会被释放掉</p>
<p>对于管道对应的文件，其 <code>file_operations</code> 被设为 <code>pipefifo_fops</code> ，其中 release 函数指针设为 <code>pipe_release</code> 函数，因此在关闭管道文件时有如下调用链：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pipe_release()</span><br><span class="line">    put_pipe_info()</span><br></pre></td></tr></table></figure>

<p>在 <code>put_pipe_info()</code> 中会将管道对应的文件计数减一，管道两端都关闭之后最终会走到 <code>free_pipe_info()</code> 中，在该函数中释放掉管道本体与 buffer 数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free_pipe_info</span><span class="params">(<span class="keyword">struct</span> pipe_inode_info *pipe)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line">	<span class="keyword">if</span> (pipe-&gt;watch_queue) &#123;</span><br><span class="line">		watch_queue_clear(pipe-&gt;watch_queue);</span><br><span class="line">		put_watch_queue(pipe-&gt;watch_queue);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	(<span class="type">void</span>) account_pipe_buffers(pipe-&gt;user, pipe-&gt;nr_accounted, <span class="number">0</span>);</span><br><span class="line">	free_uid(pipe-&gt;user);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pipe-&gt;ring_size; i++) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> =</span> pipe-&gt;bufs + i;</span><br><span class="line">		<span class="keyword">if</span> (buf-&gt;ops)</span><br><span class="line">			pipe_buf_release(pipe, buf);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (pipe-&gt;tmp_page)</span><br><span class="line">		__free_page(pipe-&gt;tmp_page);</span><br><span class="line">	kfree(pipe-&gt;bufs);</span><br><span class="line">	kfree(pipe);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数据泄露-5"><a href="#数据泄露-5" class="headerlink" title="数据泄露"></a>数据泄露</h3><h4 id="内核-text-段地址-3"><a href="#内核-text-段地址-3" class="headerlink" title="内核 .text 段地址"></a>内核 .text 段地址</h4><p><code>pipe_buffer-&gt;pipe_buf_operations</code> 通常指向一张全局函数表，我们可以通过该函数表的地址泄露出内核 .text 段基址</p>
<h3 id="劫持内核执行流-2"><a href="#劫持内核执行流-2" class="headerlink" title="劫持内核执行流"></a>劫持内核执行流</h3><p>当我们关闭了管道的两端时，会触发 <code>pipe_buffer-&gt;pipe_buffer_operations-&gt;release</code> 这一指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> &#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * -&gt;confirm() verifies that the data in the pipe buffer is there</span></span><br><span class="line"><span class="comment">	 * and that the contents are good. If the pages in the pipe belong</span></span><br><span class="line"><span class="comment">	 * to a file system, we may need to wait for IO completion in this</span></span><br><span class="line"><span class="comment">	 * hook. Returns 0 for good, or a negative error value in case of</span></span><br><span class="line"><span class="comment">	 * error.  If not present all pages are considered good.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> (*confirm)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * When the contents of this pipe buffer has been completely</span></span><br><span class="line"><span class="comment">	 * consumed by a reader, -&gt;release() is called.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">void</span> (*release)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Attempt to take ownership of the pipe buffer and its contents.</span></span><br><span class="line"><span class="comment">	 * -&gt;try_steal() returns %true for success, in which case the contents</span></span><br><span class="line"><span class="comment">	 * of the pipe (the buf-&gt;page) is locked and now completely owned by the</span></span><br><span class="line"><span class="comment">	 * caller. The page may then be transferred to a different mapping, the</span></span><br><span class="line"><span class="comment">	 * most often used case is insertion into different file address space</span></span><br><span class="line"><span class="comment">	 * cache.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">bool</span> (*try_steal)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Get a reference to the pipe buffer.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">bool</span> (*get)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>存在如下调用链：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pipe_release()</span><br><span class="line">    put_pipe_info()</span><br><span class="line">        free_pipe_info()</span><br><span class="line">            pipe_buf_release()</span><br><span class="line">                pipe_buffer-&gt;pipe_buf_operations-&gt;release() // it should be anon_pipe_buf_release()</span><br></pre></td></tr></table></figure>

<p>在 <code>pipe_buf_release()</code> 中会调用到该 <code>pipe_buffer</code> 的函数表中的 release 指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * pipe_buf_release - put a reference to a pipe_buffer</span></span><br><span class="line"><span class="comment"> * @pipe:	the pipe that the buffer belongs to</span></span><br><span class="line"><span class="comment"> * @buf:	the buffer to put a reference to</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">pipe_buf_release</span><span class="params">(<span class="keyword">struct</span> pipe_inode_info *pipe,</span></span><br><span class="line"><span class="params">				    <span class="keyword">struct</span> pipe_buffer *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span> =</span> buf-&gt;ops;</span><br><span class="line"></span><br><span class="line">	buf-&gt;ops = <span class="literal">NULL</span>;</span><br><span class="line">	ops-&gt;release(pipe, buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此我们只需要劫持其函数表到可控区域后再关闭管道的两端便能劫持内核执行流</p>
<p>经过笔者实测（其实从源码上便能看出），当执行到该指针时 rsi 寄存器刚好指向对应的 <code>pipe_buffer</code>，因此我们可以将函数表劫持到 <code>pipe_buffer</code> 上，找到一条合适的 gadget 将栈迁移到该处，从而更顺利地完成 ROP</p>
<p><img src="https://s2.loli.net/2022/02/25/daklBHtIYCs3K6q.png" alt="image.png"></p>
<p>（例题：<a target="_blank" rel="noopener" href="https://arttnba3.cn/2022/03/08/CTF-0X06-D3CTF2022_D3KHEAP/">D^3CTF2022 - d3kheap</a>）</p>
<blockquote>
<p>之前例题本来想选一个以前有的 CTF 题来写的，但是<strong>笔者太懒了</strong>…于是一直拖到最近刚好拿这个结构体出了一道 CTF 题，所以就顺便把这个过去开的坑给补充上…</p>
</blockquote>
<h1 id="0x09-sk-buff：内核中的“大对象菜单堆”"><a href="#0x09-sk-buff：内核中的“大对象菜单堆”" class="headerlink" title="0x09.sk_buff：内核中的“大对象菜单堆”"></a>0x09.sk_buff：内核中的“大对象菜单堆”</h1><p>说到 Linux kernel 的网络协议栈，我们毫无疑问无法绕开 <code>sk_buff</code> 这一基础结构体，但相比于他的常规功能，我们更加关注其在漏洞利用中给我们带来的便利</p>
<h2 id="sk-buff：size-gt-x3D-512-的对象分配"><a href="#sk-buff：size-gt-x3D-512-的对象分配" class="headerlink" title="sk_buff：size &gt;&#x3D; 512 的对象分配"></a>sk_buff：size &gt;&#x3D; 512 的对象分配</h2><p><code>sk_buff</code> 是 Linux kernel 网络协议栈中一个<strong>重要的基础结构体</strong>，其用以表示在网络协议栈中传输的一个「包」，但其结构体本身不包含一个包的数据部分，而是包含该包的各种属性，<strong>数据包的本体数据则使用一个单独的 object 储存</strong></p>
<p>这个结构体成员比较多，我们主要关注核心部分</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			<span class="comment">/* These two members must be first. */</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>		*<span class="title">next</span>;</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>		*<span class="title">prev</span>;</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// ...</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* These elements must be at the end, see alloc_skb() for details.  */</span></span><br><span class="line">	<span class="type">sk_buff_data_t</span>		tail;</span><br><span class="line">	<span class="type">sk_buff_data_t</span>		end;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>		*head,</span><br><span class="line">				*data;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		truesize;</span><br><span class="line">	<span class="type">refcount_t</span>		users;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SKB_EXTENSIONS</span></span><br><span class="line">	<span class="comment">/* only useable after checking -&gt;active_extensions != 0 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">skb_ext</span>		*<span class="title">extensions</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>sk_buff</code> 结构体与其所表示的数据包形成如下结构，其中：</p>
<ul>
<li><code>head</code> ：一个数据包<strong>实际的起始处</strong>（也就是为该数据包分配的 object 的首地址）</li>
<li><code>end</code> ：一个数据包实际的末尾（为该数据包分配的 object 的末尾地址）</li>
<li><code>data</code> ：<strong>当前所在 layer 的数据包对应的起始地址</strong></li>
<li><code>tail</code> ：<strong>当前所在 layer 的数据包对应的末尾地址</strong></li>
</ul>
<p>data 和 tail 可以这么理解：数据包每经过网络层次模型中的一层都会被添加&#x2F;删除一个 header （有时还有一个 tail），data 与 tail 便是用以对此进行标识的</p>
<p><img src="https://s2.loli.net/2022/03/31/AV8HsnZj2bUCl4J.png" alt="image.png"></p>
<p>多个 <code>sk_buff</code> 之间形成双向链表结构，类似于 <code>msg_queue</code>，这里同样有一个 <code>sk_buff_head</code> 结构作为哨兵节点</p>
<p><img src="https://s2.loli.net/2022/04/11/U8CjYMBOcZ74s3W.png" alt="image.png"></p>
<h3 id="分配（数据包：-GFP-NOMEMALLOC-GFP-NOWARN）"><a href="#分配（数据包：-GFP-NOMEMALLOC-GFP-NOWARN）" class="headerlink" title="分配（数据包：__GFP_NOMEMALLOC | __GFP_NOWARN）"></a>分配（数据包：__GFP_NOMEMALLOC | __GFP_NOWARN）</h3><p>在内核网络协议栈中很多地方都会用到该结构体，例如 sendmsg 系统调用一类的操作都会造成包的创建，其最终都会调用到 <code>alloc_skb()</code> 来分配该结构体，而这个函数又是 <code>__alloc_skb()</code> 的 wrapper，不过需要注意的是其会从<strong>独立的</strong> <code>skbuff_fclone_cache </code> &#x2F; <code> skbuff_head_cache</code> 取 object</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *__<span class="title">alloc_skb</span>(<span class="title">unsigned</span> <span class="title">int</span> <span class="title">size</span>, <span class="title">gfp_t</span> <span class="title">gfp_mask</span>,</span></span><br><span class="line"><span class="class">			    <span class="title">int</span> <span class="title">flags</span>, <span class="title">int</span> <span class="title">node</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">cache</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">	u8 *data;</span><br><span class="line">	<span class="type">bool</span> pfmemalloc;</span><br><span class="line"></span><br><span class="line">	cache = (flags &amp; SKB_ALLOC_FCLONE)</span><br><span class="line">		? skbuff_fclone_cache : skbuff_head_cache;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sk_memalloc_socks() &amp;&amp; (flags &amp; SKB_ALLOC_RX))</span><br><span class="line">		gfp_mask |= __GFP_MEMALLOC;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Get the HEAD */</span></span><br><span class="line">	<span class="keyword">if</span> ((flags &amp; (SKB_ALLOC_FCLONE | SKB_ALLOC_NAPI)) == SKB_ALLOC_NAPI &amp;&amp;</span><br><span class="line">	    likely(node == NUMA_NO_NODE || node == numa_mem_id()))</span><br><span class="line">		skb = napi_skb_cache_get();</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		skb = kmem_cache_alloc_node(cache, gfp_mask &amp; ~GFP_DMA, node);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!skb))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	prefetchw(skb);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We do our best to align skb_shared_info on a separate cache</span></span><br><span class="line"><span class="comment">	 * line. It usually works because kmalloc(X &gt; SMP_CACHE_BYTES) gives</span></span><br><span class="line"><span class="comment">	 * aligned memory blocks, unless SLUB/SLAB debug is enabled.</span></span><br><span class="line"><span class="comment">	 * Both skb-&gt;head and skb_shared_info are cache line aligned.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	size = SKB_DATA_ALIGN(size);</span><br><span class="line">	size += SKB_DATA_ALIGN(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> skb_shared_info));</span><br><span class="line">	data = kmalloc_reserve(size, gfp_mask, node, &amp;pfmemalloc);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!data))</span><br><span class="line">		<span class="keyword">goto</span> nodata;</span><br><span class="line">	<span class="comment">/* kmalloc(size) might give us more room than requested.</span></span><br><span class="line"><span class="comment">	 * Put skb_shared_info exactly at the end of allocated zone,</span></span><br><span class="line"><span class="comment">	 * to allow max possible filling before reallocation.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	size = SKB_WITH_OVERHEAD(ksize(data));</span><br><span class="line">	prefetchw(data + size);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Only clear those fields we need to clear, not those that we will</span></span><br><span class="line"><span class="comment">	 * actually initialise below. Hence, don&#x27;t put any more fields after</span></span><br><span class="line"><span class="comment">	 * the tail pointer in struct sk_buff!</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">memset</span>(skb, <span class="number">0</span>, offsetof(<span class="keyword">struct</span> sk_buff, tail));</span><br><span class="line">	__build_skb_around(skb, data, <span class="number">0</span>);</span><br><span class="line">	skb-&gt;pfmemalloc = pfmemalloc;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; SKB_ALLOC_FCLONE) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff_fclones</span> *<span class="title">fclones</span>;</span></span><br><span class="line"></span><br><span class="line">		fclones = container_of(skb, <span class="keyword">struct</span> sk_buff_fclones, skb1);</span><br><span class="line"></span><br><span class="line">		skb-&gt;fclone = SKB_FCLONE_ORIG;</span><br><span class="line">		refcount_set(&amp;fclones-&gt;fclone_ref, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		fclones-&gt;skb2.fclone = SKB_FCLONE_CLONE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> skb;</span><br><span class="line"></span><br><span class="line">nodata:</span><br><span class="line">	kmem_cache_free(cache, skb);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__alloc_skb);</span><br></pre></td></tr></table></figure>

<p><code>sk_buff</code> 虽然是从独立的 kmem_cache 中分配的，<strong>但其对应的数据包不是</strong>，我们在这里注意到分配数据包时使用的是 <code>kmalloc_reserve()</code>，最终会调用到 <code>__kmalloc_node_track_caller()</code>，<strong>走常规的 kmalloc 分配路径</strong>，因此我们仍然可以实现近乎任意大小 object 的分配与释放</p>
<p>因此 <code>sk_buff</code> 与 <code>msg_msg</code> 一样常被用来完成堆喷的工作，不同的是 <code>msg_msg</code> 带了一个 header，而 <code>sk_buff</code> 的数据包则带一个 tail——<code>skb_shared_info</code> 结构体</p>
<p><img src="https://s2.loli.net/2022/04/11/YQJMeIwR8P9hC1t.png" alt="image.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skb_shared_info</span> &#123;</span></span><br><span class="line">	__u8		flags;</span><br><span class="line">	__u8		meta_len;</span><br><span class="line">	__u8		nr_frags;</span><br><span class="line">	__u8		tx_flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span>	gso_size;</span><br><span class="line">	<span class="comment">/* Warning: this field is not always filled in (UFO)! */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span>	gso_segs;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>	*<span class="title">frag_list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">skb_shared_hwtstamps</span> <span class="title">hwtstamps</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>	gso_type;</span><br><span class="line">	u32		tskey;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Warning : all fields before dataref are cleared in __alloc_skb()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">atomic_t</span>	dataref;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Intermediate layers must ensure that destructor_arg</span></span><br><span class="line"><span class="comment">	 * remains valid until skb destructor */</span></span><br><span class="line">	<span class="type">void</span> *		destructor_arg;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* must be last field, see pskb_expand_head() */</span></span><br><span class="line">	<span class="type">skb_frag_t</span>	frags[MAX_SKB_FRAGS];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>skb_shared_info</code> 结构体的<strong>大小为 320 字节，这意味着我们能够利用分配的 object 最小的大小也得是 512 字节，这无疑为我们的利用增添了几分难度</strong>，但不可否认的是 <code>sk_buff</code> 仍为我们提供了较大对象的任意分配写入与释放</p>
<h3 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h3><p>正所谓有发必有收，我们只需要沿着发送的路径接收该包就能将其释放掉，例如若是我们通过向套接字中写入数据创建了一个包，则从套接字中读出该包便能将其释放</p>
<p>在内核中调用的是 <code>kfree_skb()</code> 函数进行释放，对于数据，其最终会调用到 <code>skb_release_data()</code> ，在这其中调用到 <code>skb_free_head()</code> 进行释放：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">skb_free_head</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *head = skb-&gt;head;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (skb-&gt;head_frag) &#123;</span><br><span class="line">		<span class="keyword">if</span> (skb_pp_recycle(skb, head))</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		skb_free_frag(head);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		kfree(head);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而 <code>sk_buff</code> 本身则通过 <code>kfree_skbmem()</code> 进行释放，主要就是直接放入对应的 kmem_cache 中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Free an skbuff by memory without cleaning the state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">kfree_skbmem</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff_fclones</span> *<span class="title">fclones</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (skb-&gt;fclone) &#123;</span><br><span class="line">	<span class="keyword">case</span> SKB_FCLONE_UNAVAILABLE:</span><br><span class="line">		kmem_cache_free(skbuff_head_cache, skb);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> SKB_FCLONE_ORIG:</span><br><span class="line">		fclones = container_of(skb, <span class="keyword">struct</span> sk_buff_fclones, skb1);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* We usually free the clone (TX completion) before original skb</span></span><br><span class="line"><span class="comment">		 * This test would have no chance to be true for the clone,</span></span><br><span class="line"><span class="comment">		 * while here, branch prediction will be good.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (refcount_read(&amp;fclones-&gt;fclone_ref) == <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">goto</span> fastpath;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>: <span class="comment">/* SKB_FCLONE_CLONE */</span></span><br><span class="line">		fclones = container_of(skb, <span class="keyword">struct</span> sk_buff_fclones, skb2);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!refcount_dec_and_test(&amp;fclones-&gt;fclone_ref))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">fastpath:</span><br><span class="line">	kmem_cache_free(skbuff_fclone_cache, fclones);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这里我们也可以看出 <code>sk_buff</code> 结构体也为我们提供了一个简陋的“菜单堆”功能，比较朴素的利用方式就是利用 <code>socketpair</code> 系统调用创建一对套接字，往其中一端写入以完成发包，从另一端读出以完成收包</p>
<blockquote>
<p>例题：D^3CTF2022 - d3kheap</p>
<p>利用参考：CVE-2021-22255</p>
</blockquote>
<h1 id="0x0A-packet-sock-与套接字相关（TBD）"><a href="#0x0A-packet-sock-与套接字相关（TBD）" class="headerlink" title="0x0A.packet_sock 与套接字相关（TBD）"></a>0x0A.packet_sock 与套接字相关（TBD）</h1><p><code>sock</code> 结构体是内核网络协议栈中的一个非常重要的基础结构体，<strong>用以在 <em>网络层</em> 表示一个 socket</strong>，内核以这个结构体为核心建立更高层面的抽象 socket，例如表示 BSD socket 的 <code>socket</code> 结构体或是 <code>inet_socket</code> 等结构体都有一个 <code>sock</code> 结构体成员，本节我们介绍 <code>AF_PACKET</code> 族所用到的套接字结构体 <code>packet_sock</code>——其通过常规的 kmalloc 路径进行分配</p>
<h2 id="packet-sock（kmalloc-2048-GFP-KERNEL）"><a href="#packet-sock（kmalloc-2048-GFP-KERNEL）" class="headerlink" title="packet_sock（kmalloc-2048 | GFP_KERNEL）"></a>packet_sock（kmalloc-2048 | GFP_KERNEL）</h2><p>packet socket 用以在 <em>设备驱动级</em> （OSI Layer 2，数据链路层）收发 raw packets，这允许用户在物理层之上应用用户空间中的协议模块</p>
<p>当我们通过 socket 系统调用创建 <code>AF_PACKET</code> 族的套接字时，在内核空间中会创建一个 <code>packet_sock</code> 结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packet_sock</span> &#123;</span></span><br><span class="line">	<span class="comment">/* struct sock has to be the first member of packet_sock */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span>		<span class="title">sk</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">packet_fanout</span>	*<span class="title">fanout</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span>  <span class="title">tpacket_stats_u</span>	<span class="title">stats</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">packet_ring_buffer</span>	<span class="title">rx_ring</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">packet_ring_buffer</span>	<span class="title">tx_ring</span>;</span></span><br><span class="line">	<span class="type">int</span>			copy_thresh;</span><br><span class="line">	<span class="type">spinlock_t</span>		bind_lock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>		<span class="title">pg_vec_lock</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		running;	<span class="comment">/* bind_lock must be held */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		auxdata:<span class="number">1</span>,	<span class="comment">/* writer must hold sock lock */</span></span><br><span class="line">				origdev:<span class="number">1</span>,</span><br><span class="line">				has_vnet_hdr:<span class="number">1</span>,</span><br><span class="line">				tp_loss:<span class="number">1</span>,</span><br><span class="line">				tp_tx_has_off:<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span>			pressure;</span><br><span class="line">	<span class="type">int</span>			ifindex;	<span class="comment">/* bound device		*/</span></span><br><span class="line">	__be16			num;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">packet_rollover</span>	*<span class="title">rollover</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">packet_mclist</span>	*<span class="title">mclist</span>;</span></span><br><span class="line">	<span class="type">atomic_t</span>		mapped;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">tpacket_versions</span>	<span class="title">tp_version</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		tp_hdrlen;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		tp_reserve;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		tp_tstamp;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">completion</span>	<span class="title">skb_completion</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> __<span class="title">rcu</span>	*<span class="title">cached_dev</span>;</span></span><br><span class="line">	<span class="type">int</span>			(*xmit)(<span class="keyword">struct</span> sk_buff *skb);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">packet_type</span>	<span class="title">prot_hook</span> ____<span class="title">cacheline_aligned_in_smp</span>;</span></span><br><span class="line">	<span class="type">atomic_t</span>		tp_drops ____cacheline_aligned_in_smp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h3><p>当我们创建一个 packet socket 时内核便会分配一个 <code>packet_sock</code> 结构体，我们可以通过如下方式创建 packet socket：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket(AF_PACKET, SOCK_DGRAM, htons(ETH_P_ARP));</span><br></pre></td></tr></table></figure>

<p>在内核中存在如下调用链：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sys_socket()</span><br><span class="line">    __sys_socket()</span><br><span class="line">    	sock_create()</span><br><span class="line">    		__sock_create()</span><br><span class="line">    			<span class="comment">// 首先在 net_families 数组中找协议族对应的 net_proto_family 结构体</span></span><br><span class="line">    			<span class="comment">/* </span></span><br><span class="line"><span class="comment">    			 * 对 AF_PACKET 而言，其在 packet_init() 中通过 sock_register()</span></span><br><span class="line"><span class="comment">    			 * 注册了packet_family_ops，其中 create 指针为 packet_create()</span></span><br><span class="line"><span class="comment">    			 */</span></span><br><span class="line">    			<span class="comment">// 接下来会调用 net_proto_family 的 create 指针进行 sock 的创建</span></span><br><span class="line">    			packet_create()</span><br><span class="line">    				sk_alloc()</span><br></pre></td></tr></table></figure>

<p>在 <code>packet_create()</code> 中会调用 <code>sk_alloc()</code> 创建 sock 的空间，这是一个通用的创建 sock 的函数，这里我们注意到传入一个指向 proto 结构体类型全局变量 <code>packet_proto</code> 的指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">packet_create</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="keyword">struct</span> socket *sock, <span class="type">int</span> protocol,</span></span><br><span class="line"><span class="params">			 <span class="type">int</span> kern)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    sk = sk_alloc(net, PF_PACKET, GFP_KERNEL, &amp;packet_proto, kern);</span><br></pre></td></tr></table></figure>

<p><code>sk_alloc()</code> 最后会调用到 <code>sk_prot_alloc()</code>，对于在协议对应的 proto 结构体中有指定 kmem_cache 的情况而言会直接从其中分配对象，否则走常规的 kmalloc 分配路径，这里我们注意到分配的 flag 为 <code>GFP_KERNEL</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> sock *<span class="title function_">sk_prot_alloc</span><span class="params">(<span class="keyword">struct</span> proto *prot, <span class="type">gfp_t</span> priority,</span></span><br><span class="line"><span class="params">		<span class="type">int</span> family)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab</span>;</span></span><br><span class="line"></span><br><span class="line">	slab = prot-&gt;slab;</span><br><span class="line">	<span class="keyword">if</span> (slab != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		sk = kmem_cache_alloc(slab, priority &amp; ~__GFP_ZERO);</span><br><span class="line">		<span class="keyword">if</span> (!sk)</span><br><span class="line">			<span class="keyword">return</span> sk;</span><br><span class="line">		<span class="keyword">if</span> (want_init_on_alloc(priority))</span><br><span class="line">			sk_prot_clear_nulls(sk, prot-&gt;obj_size);</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		sk = kmalloc(prot-&gt;obj_size, priority);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sk != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (security_sk_alloc(sk, family, priority))</span><br><span class="line">			<span class="keyword">goto</span> out_free;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!try_module_get(prot-&gt;owner))</span><br><span class="line">			<span class="keyword">goto</span> out_free_sec;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> sk;</span><br><span class="line"></span><br><span class="line">out_free_sec:</span><br><span class="line">	security_sk_free(sk);</span><br><span class="line">out_free:</span><br><span class="line">	<span class="keyword">if</span> (slab != <span class="literal">NULL</span>)</span><br><span class="line">		kmem_cache_free(slab, sk);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		kfree(sk);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分配的对象 size 为 <code>proto-&gt;obj_size</code>，在 <code>packet_proto</code> 中指定为 <code>packet_sock</code> 的大小，在各个版本上可能略有不同（笔者的机子上是1500+，也见到有1400+的），不过大小浮动不大，最终都会从 <code>kmalloc-2k</code> 中取对象</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proto</span> <span class="title">packet_proto</span> =</span> &#123;</span><br><span class="line">	.name	  = <span class="string">&quot;PACKET&quot;</span>,</span><br><span class="line">	.owner	  = THIS_MODULE,</span><br><span class="line">	.obj_size = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> packet_sock),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="释放-1"><a href="#释放-1" class="headerlink" title="释放"></a>释放</h3><p>当我们关闭对应的套接字时就能释放对应的 sock 结构体了</p>
<p>众所周知 Linux 中“一切皆文件”，在我们创建一个套接字时其实内核中会创建一个 file 结构体并返回给我们一个文件描述符，在 <code>__sys_socket()</code> 中会通过 <code>sock_map_fd()</code> 分配一个文件描述符并将套接字文件的函数表设为 <code>socket_file_ops</code>，其中 close 指针对应的函数应为 <code>sock_close()</code>，其实为 <code>__sock_release() </code>的 wrapper</p>
<p>该函数会检查 socket 的函数表，若有则直接调用其函数表的 release 函数指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __sock_release(<span class="keyword">struct</span> socket *sock, <span class="keyword">struct</span> inode *inode)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (sock-&gt;ops) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span> =</span> sock-&gt;ops-&gt;owner;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (inode)</span><br><span class="line">			inode_lock(inode);</span><br><span class="line">		sock-&gt;ops-&gt;release(sock);</span><br><span class="line">		sock-&gt;sk = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">if</span> (inode)</span><br><span class="line">			inode_unlock(inode);</span><br><span class="line">		sock-&gt;ops = <span class="literal">NULL</span>;</span><br><span class="line">		module_put(owner);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sock-&gt;wq.fasync_list)</span><br><span class="line">		pr_err(<span class="string">&quot;%s: fasync list not empty!\n&quot;</span>, __func__);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!sock-&gt;file) &#123;</span><br><span class="line">		iput(SOCK_INODE(sock));</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	sock-&gt;file = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个表的设置其实在 <code>sk_alloc()</code> 中通过协议族对应的结构体的 create 函数指针执行过程中进行指定，对应 packet socket 而言即在 <code>packet_create()</code> 中指定，这里我们可以看到函数表被设为 <code>packet_ops</code> 或 <code>packet_ops_spkt</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">packet_create</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="keyword">struct</span> socket *sock, <span class="type">int</span> protocol,</span></span><br><span class="line"><span class="params">			 <span class="type">int</span> kern)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">	sock-&gt;ops = &amp;packet_ops;</span><br><span class="line">	<span class="keyword">if</span> (sock-&gt;type == SOCK_PACKET)</span><br><span class="line">		sock-&gt;ops = &amp;packet_ops_spkt;</span><br></pre></td></tr></table></figure>

<p>这两个函数表的 release 指针对应的都是 <code>packet_release()</code>，最终存在如下调用链：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">packet_release()</span><br><span class="line">    sock_put()</span><br><span class="line">    	sk_free() <span class="comment">// 引用计数为 0 时调用，释放 sock 结构体</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意不要混淆了 sock 和 socket 哟，不知道的可以去百度（笑）</p>
</blockquote>
<h3 id="数据泄露-6"><a href="#数据泄露-6" class="headerlink" title="数据泄露"></a>数据泄露</h3><h3 id="劫持内核执行流-3"><a href="#劫持内核执行流-3" class="headerlink" title="劫持内核执行流"></a>劫持内核执行流</h3><h1 id="0x0B-subprocess-info-与套接字相关"><a href="#0x0B-subprocess-info-与套接字相关" class="headerlink" title="0x0B.subprocess_info 与套接字相关"></a>0x0B.subprocess_info 与套接字相关</h1><p>Linux 内核的网络协议栈的一系列操作同样涉及到一系列的结构体，其中 <code>subprocess_info</code> 便是一个比较神奇的结构体，这里也来简单介绍一下</p>
<h2 id="subprocess-info：kmalloc-128"><a href="#subprocess-info：kmalloc-128" class="headerlink" title="subprocess_info：kmalloc-128"></a>subprocess_info：kmalloc-128</h2><blockquote>
<p>感觉没啥好说的…</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">subprocess_info</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">completion</span> *<span class="title">complete</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *path;</span><br><span class="line">	<span class="type">char</span> **argv;</span><br><span class="line">	<span class="type">char</span> **envp;</span><br><span class="line">	<span class="type">int</span> wait;</span><br><span class="line">	<span class="type">int</span> retval;</span><br><span class="line">	<span class="type">int</span> (*init)(<span class="keyword">struct</span> subprocess_info *info, <span class="keyword">struct</span> cred *new);</span><br><span class="line">	<span class="type">void</span> (*cleanup)(<span class="keyword">struct</span> subprocess_info *info);</span><br><span class="line">	<span class="type">void</span> *data;</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>

<h3 id="产生-amp-释放"><a href="#产生-amp-释放" class="headerlink" title="产生 &amp; 释放"></a>产生 &amp; 释放</h3><p>当我们尝试创建一个未知协议（<code>socket(22, AF_INET, 0)</code>）时，便会创建一个 <code>subprocess_info</code> 结构体，对应地，在系统调用结束之后该结构体便会被立即释放，过程其实有点类似 setxattr，不同的是没有任何用户空间数据会被拷贝至内核空间</p>
<p>因为该结构体在创建之后就会被释放掉，因此基于该结构体的利用都要用到条件竞争，笔者认为其实不是特别的方便</p>
<blockquote>
<p>笔者本想分析一下其创建与释放的调用链，但是大量使用了 LSM hook 看着实在头疼，就此作罢，就利用层面而言这个结构体也不是特别好用+稳定，所以这里只抄一些总结性的结论XD</p>
</blockquote>
<h3 id="数据泄露（条件竞争）"><a href="#数据泄露（条件竞争）" class="headerlink" title="数据泄露（条件竞争）"></a>数据泄露（条件竞争）</h3><h4 id="内核-text-段地址-4"><a href="#内核-text-段地址-4" class="headerlink" title="内核 .text 段地址"></a>内核 .text 段地址</h4><p>该结构体的 <code>work.func</code> 可能指向 <code>call_usermodehelper_exec_work</code>，若是我们能利用条件竞争读出该指针便能泄露出内核的 .text 段的基址</p>
<h3 id="劫持内核执行流（条件竞争）"><a href="#劫持内核执行流（条件竞争）" class="headerlink" title="劫持内核执行流（条件竞争）"></a>劫持内核执行流（条件竞争）</h3><p>在释放该结构体时会调用其 <code>cleanup</code> 指针成员，若是我们能够在创建该结构体之后、释放该结构体之前劫持该指针便能控制内核执行流</p>
<blockquote>
<p>例题：SCTF2022 - flying_kernel</p>
<blockquote>
<p>笔者在比赛中死活竞争不出来，就很离谱…所以暂时没有 wp（🕊</p>
</blockquote>
</blockquote>
<h1 id="0x0C-timerfd-ctx-与-timerfd-系列系统调用"><a href="#0x0C-timerfd-ctx-与-timerfd-系列系统调用" class="headerlink" title="0x0C.timerfd_ctx 与 timerfd 系列系统调用"></a>0x0C.timerfd_ctx 与 timerfd 系列系统调用</h1><p>自 2.6.25 版本起 Linux 提供了一种可以用以创建定时器的系统调用——timerfd 系列系统调用，相比起定时器的功能，我们更加关注系统调用过程中涉及到的 <code>timerfd_ctx</code> 结构体</p>
<h2 id="timerfd-ctx（kmalloc-256-GPF-KERNEL）"><a href="#timerfd-ctx（kmalloc-256-GPF-KERNEL）" class="headerlink" title="timerfd_ctx（kmalloc-256 | GPF_KERNEL）"></a>timerfd_ctx（kmalloc-256 | GPF_KERNEL）</h2><p>该结构体定义于 <code>fs/timerfd.c</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timerfd_ctx</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hrtimer</span> <span class="title">tmr</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">alarm</span> <span class="title">alarm</span>;</span></span><br><span class="line">    &#125; t;</span><br><span class="line">    <span class="type">ktime_t</span> tintv;</span><br><span class="line">    <span class="type">ktime_t</span> moffs;</span><br><span class="line">    <span class="type">wait_queue_head_t</span> wqh;</span><br><span class="line">    u64 ticks;</span><br><span class="line">    <span class="type">int</span> clockid;</span><br><span class="line">    <span class="type">short</span> <span class="type">unsigned</span> expired;</span><br><span class="line">    <span class="type">short</span> <span class="type">unsigned</span> settime_flags;    <span class="comment">/* to show in fdinfo */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">clist</span>;</span></span><br><span class="line">    <span class="type">spinlock_t</span> cancel_lock;</span><br><span class="line">    <span class="type">bool</span> might_cancel;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中的 <code>hrtimer</code> 结构体定义于 <code>/include/linux/hrtimer.h</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hrtimer</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timerqueue_node</span>        <span class="title">node</span>;</span></span><br><span class="line">    <span class="type">ktime_t</span>                _softexpires;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title function_">hrtimer_restart</span>        <span class="params">(*function)</span><span class="params">(<span class="keyword">struct</span> hrtimer *)</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hrtimer_clock_base</span>    *<span class="title">base</span>;</span></span><br><span class="line">    u8                state;</span><br><span class="line">    u8                is_rel;</span><br><span class="line">    u8                is_soft;</span><br><span class="line">    u8                is_hard;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="分配-x2F-释放-2"><a href="#分配-x2F-释放-2" class="headerlink" title="分配&#x2F;释放"></a>分配&#x2F;释放</h3><p>我们可以通过 <code>timerfd_create</code> 系统调用来分配一个 <code>timerfd_ctx</code> 结构体，在 <code>fs/timerfd.c</code> 中有如下定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE2(timerfd_create, <span class="type">int</span>, clockid, <span class="type">int</span>, flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ufd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timerfd_ctx</span> *<span class="title">ctx</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    ctx = kzalloc(<span class="keyword">sizeof</span>(*ctx), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样地，对于 timerfd 文件在 <code>fs/timerfd.c</code> 中定义了其函数表 <code>timerfd_ops</code>，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">timerfd_fops</span> =</span> &#123;</span><br><span class="line">    .release    = timerfd_release,</span><br><span class="line">    .poll        = timerfd_poll,</span><br><span class="line">    .read        = timerfd_read,</span><br><span class="line">    .llseek        = noop_llseek,</span><br><span class="line">    .show_fdinfo    = timerfd_show,</span><br><span class="line">    .unlocked_ioctl    = timerfd_ioctl,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中 <code>timerfd_release</code> 定义于 <code>fs/timerfd.c</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">timerfd_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timerfd_ctx</span> *<span class="title">ctx</span> =</span> file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    timerfd_remove_cancel(ctx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isalarm(ctx))</span><br><span class="line">        alarm_cancel(&amp;ctx-&gt;t.alarm);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        hrtimer_cancel(&amp;ctx-&gt;t.tmr);</span><br><span class="line">    kfree_rcu(ctx, rcu);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即我们可以通过关闭 timerfd 文件来释放 timerfd_ctx 结构体</p>
<h3 id="数据泄露-7"><a href="#数据泄露-7" class="headerlink" title="数据泄露"></a>数据泄露</h3><h4 id="内核-text-段地址-5"><a href="#内核-text-段地址-5" class="headerlink" title="内核 .text 段地址"></a>内核 .text 段地址</h4><p>timerfd_ctx 的 tmr 字段的 <code>function</code> 字段指向内核代码段（笔者尚未求证具体指向函数），若能泄漏出该指针则我们便毫无疑问能泄漏出内核基址</p>
<h4 id="内核线性映射区（-direct-mapping-area）-4"><a href="#内核线性映射区（-direct-mapping-area）-4" class="headerlink" title="*内核线性映射区（ direct mapping area）"></a><em>*内核线性映射区（ direct mapping area）</em></h4><p>timerfd_ctx 的 tmr 字段的 <code>base</code> 字段指向内核“堆”上，若能泄露该字段我们同样能泄漏出内核的“堆上地址”</p>

      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
              <a href="/2021/11/28/NOTE-0X07-LINUX-KERNEL-MEMORY-5.11-PART-I/" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>上一页</span>
              </a>
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">
              <i class="iconfont icon-updatetime" title="更新时间"></i>
              2021-11-29 13:51:25
            </span>
            
                  <span class="post-categories">
                    <i class="iconfont icon-bookmark" title="分类"></i>
                    
                    <span class="span--category">
                      <a href="/categories/NOTES/" title="NOTES">
                        <b>#</b> NOTES
                      </a>
                    </span>
                    
                  </span>
              
                  <span class="post-tags">
                    <i class="iconfont icon-tags" title="标签"></i>
                    
                    <span class="span--tag">
                      <a href="/tags/Pwn/" title="Pwn">
                        <b>#</b> Pwn
                      </a>
                    </span>
                    
                    <span class="span--tag">
                      <a href="/tags/Linux/" title="Linux">
                        <b>#</b> Linux
                      </a>
                    </span>
                    
                    <span class="span--tag">
                      <a href="/tags/%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0/" title="学习札记">
                        <b>#</b> 学习札记
                      </a>
                    </span>
                    
                    <span class="span--tag">
                      <a href="/tags/Linux-Kernel/" title="Linux Kernel">
                        <b>#</b> Linux Kernel
                      </a>
                    </span>
                    
                  </span>
              
          </div>
          <div class="post-foot-prev">
            
              <a href="/2021/12/31/PIECES-0X02-SHELL_OUTSIDE-2-DEEP_INTO_THE_SEA/" target="_self">
                <span>下一页</span>
                <i class="iconfont icon-chevronright"></i>
              </a>
            
          </div>
        </div>
      
    </div>
    
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">目录</div>
    <div class="catalog-content">
      
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0x00-%E4%B8%80%E5%88%87%E5%BC%80%E5%A7%8B%E4%B9%8B%E5%89%8D"><span class="toc-text">0x00.一切开始之前</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#pahole%EF%BC%9A%E6%9F%A5%E9%98%85%E5%86%85%E6%A0%B8%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%B7%A5%E5%85%B7"><span class="toc-text">pahole：查阅内核结构体的工具</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#slab-amp-amp-slub-amp-amp-slob-%E5%88%86%E9%85%8D-object-%E7%9A%84%E6%9C%80%E5%B0%8F%E5%A4%A7%E5%B0%8F"><span class="toc-text">slab &amp;&amp; slub &amp;&amp; slob 分配 object 的最小大小</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x01-tty-%E8%AE%BE%E5%A4%87%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">0x01.tty 设备结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#tty-struct%EF%BC%88kmalloc-1k%EF%BC%89"><span class="toc-text">tty_struct（kmalloc-1k）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%85%8D-x2F-%E9%87%8A%E6%94%BE"><span class="toc-text">分配&#x2F;释放</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AD%94%E6%95%B0"><span class="toc-text">魔数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tty-operations"><span class="toc-text">*tty_operations</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B3%84%E9%9C%B2"><span class="toc-text">数据泄露</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E6%A0%B8-text-%E6%AE%B5%E5%9C%B0%E5%9D%80"><span class="toc-text">内核 .text 段地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E7%BA%BF%E6%80%A7%E6%98%A0%E5%B0%84%E5%8C%BA%EF%BC%88-direct-mapping-area%EF%BC%89"><span class="toc-text">*内核线性映射区（ direct mapping area）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%AB%E6%8C%81%E5%86%85%E6%A0%B8%E6%89%A7%E8%A1%8C%E6%B5%81"><span class="toc-text">劫持内核执行流</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x02-seq-file-%E7%9B%B8%E5%85%B3"><span class="toc-text">0x02.seq_file 相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#seq-file"><span class="toc-text">seq_file</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#single-open"><span class="toc-text">single_open</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#seq-operations%EF%BC%88kmalloc-32-GFP-KERNEL-ACCOUNT%EF%BC%89%EF%BC%9Aseq-file-%E5%87%BD%E6%95%B0%E8%A1%A8"><span class="toc-text">seq_operations（kmalloc-32 | GFP_KERNEL_ACCOUNT）：seq_file 函数表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%85%8D-x2F-%E9%87%8A%E6%94%BE-1"><span class="toc-text">分配&#x2F;释放</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B3%84%E9%9C%B2-1"><span class="toc-text">数据泄露</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E6%A0%B8-text-%E6%AE%B5%E5%9C%B0%E5%9D%80-1"><span class="toc-text">内核 .text 段地址</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%AB%E6%8C%81%E5%86%85%E6%A0%B8%E6%89%A7%E8%A1%8C%E6%B5%81-1"><span class="toc-text">劫持内核执行流</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x03-ldt-struct-%E4%B8%8E-modify-ldt-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">0x03.ldt_struct 与 modify_ldt 系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#modify-ldt-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">modify_ldt 系统调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ldt-struct-kmalloc-16-slub-x2F-kmalloc-32-slab"><span class="toc-text">ldt_struct:  kmalloc-16(slub)&#x2F;kmalloc-32(slab)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%85%8D%EF%BC%88GFP-KERNEL%EF%BC%89%EF%BC%9Amodify-ldt-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E2%80%94%E2%80%94write-ldt"><span class="toc-text">分配（GFP_KERNEL）：modify_ldt 系统调用——write_ldt()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B3%84%E9%9C%B2%EF%BC%9Amodify-ldt-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E2%80%94%E2%80%94read-ldt"><span class="toc-text">数据泄露：modify_ldt 系统调用——read_ldt()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0-%E7%88%86%E7%A0%B4%E5%86%85%E6%A0%B8-text-%E6%AE%B5%E5%9C%B0%E5%9D%80%E4%B8%8E-page-offset-base"><span class="toc-text">① 爆破内核 .text 段地址与 page_offset_base</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1-%E5%88%A9%E7%94%A8-fork-%E5%AE%8C%E6%88%90-hardened-usercopy-%E4%B8%8B%E7%9A%84%E4%BB%BB%E6%84%8F%E5%9C%B0%E5%9D%80%E8%AF%BB"><span class="toc-text">② 利用 fork 完成 hardened usercopy 下的任意地址读</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E6%84%8F%E5%9C%B0%E5%9D%80%E5%86%99%EF%BC%9Amodify-ldt-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E2%80%94%E2%80%94write-ldt"><span class="toc-text">任意地址写：modify_ldt 系统调用——write_ldt()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x04-pt-regs-%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9B%B8%E5%85%B3"><span class="toc-text">0x04.pt_regs 与系统调用相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E9%83%A8%E5%88%86%E8%BF%87%E7%A8%8B-%E4%B8%8E-pt-regs-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">系统调用部分过程 与 pt_regs 结构体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E6%A0%88-%E4%B8%8E-%E9%80%9A%E7%94%A8-ROP"><span class="toc-text">内核栈 与 通用 ROP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E7%89%88%E6%9C%AC%E5%86%85%E6%A0%B8%E5%AF%B9%E6%8A%97%E5%88%A9%E7%94%A8-pt-regs-%E8%BF%9B%E8%A1%8C%E6%94%BB%E5%87%BB%E7%9A%84%E5%8A%9E%E6%B3%95"><span class="toc-text">新版本内核对抗利用 pt_regs 进行攻击的办法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x05-setxattr-%E7%9B%B8%E5%85%B3"><span class="toc-text">0x05.setxattr 相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E6%84%8F%E5%A4%A7%E5%B0%8F-object-%E5%88%86%E9%85%8D%EF%BC%88GFP-KERNEL%EF%BC%89-amp-%E9%87%8A%E6%94%BE"><span class="toc-text">任意大小 object 分配（GFP_KERNEL）&amp; 释放</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#setxattr-userfaultfd-%E5%A0%86%E5%8D%A0%E4%BD%8D%E6%8A%80%E6%9C%AF"><span class="toc-text">setxattr + userfaultfd 堆占位技术</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x06-shm-file-data-%E4%B8%8E%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3"><span class="toc-text">0x06.shm_file_data 与共享内存相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#shm-file-data%EF%BC%88kmalloc-32-GFP-KERNEL%EF%BC%89"><span class="toc-text">shm_file_data（kmalloc-32|GFP_KERNEL）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%85%8D%EF%BC%9Ashmat-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">分配：shmat 系统调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8A%E6%94%BE%EF%BC%9Ashmdt-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">释放：shmdt 系统调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B3%84%E9%9C%B2-2"><span class="toc-text">数据泄露</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E6%A0%B8-text-%E6%AE%B5%E5%9C%B0%E5%9D%80-2"><span class="toc-text">内核 .text 段地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E7%BA%BF%E6%80%A7%E6%98%A0%E5%B0%84%E5%8C%BA%EF%BC%88-direct-mapping-area%EF%BC%89-1"><span class="toc-text">*内核线性映射区（ direct mapping area）</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x07-system-V-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9A%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E2%80%9C%E8%8F%9C%E5%8D%95%E5%A0%86%E2%80%9D"><span class="toc-text">0x07.system V 消息队列：内核中的“菜单堆”</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#msg-msg-amp-msg-msgseg%EF%BC%9A%E8%BF%91%E4%B9%8E%E4%BB%BB%E6%84%8F%E5%A4%A7%E5%B0%8F%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D"><span class="toc-text">msg_msg &amp; msg_msgseg：近乎任意大小的对象分配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%85%8D%EF%BC%88GFP-KERNEL-ACCOUNT%EF%BC%89%EF%BC%9Amsgsnd-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">分配（GFP_KERNEL_ACCOUNT）：msgsnd 系统调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8A%E6%94%BE%EF%BC%9Amsgrcv-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">释放：msgrcv 系统调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%EF%BC%9Amsgrcv-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">读取：msgrcv 系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MSG-COPY%EF%BC%9A%E8%AF%BB%E5%8F%96%E4%BD%86%E4%B8%8D%E9%87%8A%E6%94%BE"><span class="toc-text">MSG_COPY：读取但不释放</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B3%84%E9%9C%B2-3"><span class="toc-text">数据泄露</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B6%8A%E7%95%8C%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%8F%96"><span class="toc-text">越界数据读取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E6%84%8F%E5%9C%B0%E5%9D%80%E8%AF%BB"><span class="toc-text">任意地址读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E7%BA%BF%E6%80%A7%E6%98%A0%E5%B0%84%E5%8C%BA%EF%BC%88-direct-mapping-area%EF%BC%89-2"><span class="toc-text">*内核线性映射区（ direct mapping area）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%A0%86%E5%9C%B0%E5%9D%80%E6%B3%84%E9%9C%B2%E7%9A%84%E5%A0%86%E4%B8%8A%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E6%90%9C%E7%B4%A2"><span class="toc-text">**基于堆地址泄露的堆上连续内存搜索</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E6%84%8F%E5%9C%B0%E5%9D%80%E5%86%99%EF%BC%88%E7%BB%93%E5%90%88-userfaultfd-%E6%88%96-FUSE-%E5%AE%8C%E6%88%90-race-condition-write%EF%BC%89"><span class="toc-text">任意地址写（结合 userfaultfd 或 FUSE 完成 race condition write）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x08-pipe-%E7%AE%A1%E9%81%93%E7%9B%B8%E5%85%B3"><span class="toc-text">0x08.pipe 管道相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#pipe-inode-info%EF%BC%88kmalloc-192-GFP-KERNEL-ACCOUNT%EF%BC%89%EF%BC%9A%E7%AE%A1%E9%81%93%E6%9C%AC%E4%BD%93"><span class="toc-text">pipe_inode_info（kmalloc-192|GFP_KERNEL_ACCOUNT）：管道本体</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B3%84%E9%9C%B2-4"><span class="toc-text">数据泄露</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E7%BA%BF%E6%80%A7%E6%98%A0%E5%B0%84%E5%8C%BA%EF%BC%88-direct-mapping-area%EF%BC%89-3"><span class="toc-text">*内核线性映射区（ direct mapping area）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pipe-buffer%EF%BC%88kmalloc-1k-GFP-KERNEL-ACCOUNT%EF%BC%89%EF%BC%9A%E7%AE%A1%E9%81%93%E6%95%B0%E6%8D%AE"><span class="toc-text">pipe_buffer（kmalloc-1k|GFP_KERNEL_ACCOUNT）：管道数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%85%8D%EF%BC%9Apipe-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%97%8F"><span class="toc-text">分配：pipe 系统调用族</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8A%E6%94%BE%EF%BC%9Aclose-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">释放：close 系统调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B3%84%E9%9C%B2-5"><span class="toc-text">数据泄露</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E6%A0%B8-text-%E6%AE%B5%E5%9C%B0%E5%9D%80-3"><span class="toc-text">内核 .text 段地址</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%AB%E6%8C%81%E5%86%85%E6%A0%B8%E6%89%A7%E8%A1%8C%E6%B5%81-2"><span class="toc-text">劫持内核执行流</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x09-sk-buff%EF%BC%9A%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E2%80%9C%E5%A4%A7%E5%AF%B9%E8%B1%A1%E8%8F%9C%E5%8D%95%E5%A0%86%E2%80%9D"><span class="toc-text">0x09.sk_buff：内核中的“大对象菜单堆”</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#sk-buff%EF%BC%9Asize-gt-x3D-512-%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D"><span class="toc-text">sk_buff：size &gt;&#x3D; 512 的对象分配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%85%8D%EF%BC%88%E6%95%B0%E6%8D%AE%E5%8C%85%EF%BC%9A-GFP-NOMEMALLOC-GFP-NOWARN%EF%BC%89"><span class="toc-text">分配（数据包：__GFP_NOMEMALLOC | __GFP_NOWARN）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8A%E6%94%BE"><span class="toc-text">释放</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x0A-packet-sock-%E4%B8%8E%E5%A5%97%E6%8E%A5%E5%AD%97%E7%9B%B8%E5%85%B3%EF%BC%88TBD%EF%BC%89"><span class="toc-text">0x0A.packet_sock 与套接字相关（TBD）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#packet-sock%EF%BC%88kmalloc-2048-GFP-KERNEL%EF%BC%89"><span class="toc-text">packet_sock（kmalloc-2048 | GFP_KERNEL）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%85%8D"><span class="toc-text">分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8A%E6%94%BE-1"><span class="toc-text">释放</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B3%84%E9%9C%B2-6"><span class="toc-text">数据泄露</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%AB%E6%8C%81%E5%86%85%E6%A0%B8%E6%89%A7%E8%A1%8C%E6%B5%81-3"><span class="toc-text">劫持内核执行流</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x0B-subprocess-info-%E4%B8%8E%E5%A5%97%E6%8E%A5%E5%AD%97%E7%9B%B8%E5%85%B3"><span class="toc-text">0x0B.subprocess_info 与套接字相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#subprocess-info%EF%BC%9Akmalloc-128"><span class="toc-text">subprocess_info：kmalloc-128</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A7%E7%94%9F-amp-%E9%87%8A%E6%94%BE"><span class="toc-text">产生 &amp; 释放</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B3%84%E9%9C%B2%EF%BC%88%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89%EF%BC%89"><span class="toc-text">数据泄露（条件竞争）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E6%A0%B8-text-%E6%AE%B5%E5%9C%B0%E5%9D%80-4"><span class="toc-text">内核 .text 段地址</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%AB%E6%8C%81%E5%86%85%E6%A0%B8%E6%89%A7%E8%A1%8C%E6%B5%81%EF%BC%88%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89%EF%BC%89"><span class="toc-text">劫持内核执行流（条件竞争）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x0C-timerfd-ctx-%E4%B8%8E-timerfd-%E7%B3%BB%E5%88%97%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">0x0C.timerfd_ctx 与 timerfd 系列系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#timerfd-ctx%EF%BC%88kmalloc-256-GPF-KERNEL%EF%BC%89"><span class="toc-text">timerfd_ctx（kmalloc-256 | GPF_KERNEL）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%85%8D-x2F-%E9%87%8A%E6%94%BE-2"><span class="toc-text">分配&#x2F;释放</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B3%84%E9%9C%B2-7"><span class="toc-text">数据泄露</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E6%A0%B8-text-%E6%AE%B5%E5%9C%B0%E5%9D%80-5"><span class="toc-text">内核 .text 段地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E7%BA%BF%E6%80%A7%E6%98%A0%E5%B0%84%E5%8C%BA%EF%BC%88-direct-mapping-area%EF%BC%89-4"><span class="toc-text">*内核线性映射区（ direct mapping area）</span></a></li></ol></li></ol></li></ol></li></ol>
      
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
      <div class="comments-container">
        




  
    <script async type="text/javascript" src="/plugins/valine.min.js" onload="loadValineSuc(this)"></script>
  

  <div id="vcomments"></div>

  <script>
    function loadValineSuc() {
      new Valine({
        el: '#vcomments',
        appId: 'ICj6cPRQWFTNiOttBHlzxnIv-gzGzoHsz',
        appKey: 'tuvJh3xYxPFcW2JB6K26RKP2',
        placeholder: '说点什么呗...',
        avatar: 'retro',
        lang: 'zh-CN'
      })
    }
  </script>

    <style>
      .comments-container .v .vempty {
        display: none!important;
      }
    </style>




      </div>
    
  </div>


        
<div class="footer">
  <div class="social">
    <ul>
      
        <li>
          <a title="github" target="_blank" rel="noopener" href="https://github.com/arttnba3">
            <i class="iconfont icon-github"></i>
          </a>
        </li>
      
        <li>
          <a title="email" href="mailto:arttnba@gmail.com">
            <i class="iconfont icon-envelope"></i>
          </a>
        </li>
      
        <li>
          <a title="twitter" target="_blank" rel="noopener" href="https://twitter.com/arttnba3">
            <i class="iconfont icon-twitter"></i>
          </a>
        </li>
      
        <li>
          <a title="rss" href="/atom.xml">
            <i class="iconfont icon-rss"></i>
          </a>
        </li>
      
    </ul>
  </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/arttnba3">Copyright © 2022 arttnba3</a>
        
    </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Theme by Oranges | Powered by Hexo</a>
        
    </div>
  
</div>

      </div>

      <div class="tools-bar">
        <div class="back-to-top tools-bar-item hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



        
  <div class="search-icon tools-bar-item" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-title">
        <span class="search-icon-input">
          <a href="javascript: void(0)">
            <i class="iconfont icon-search"></i>
          </a>
        </span>
        
          <input type="text" class="search-input" id="search-input" placeholder="搜索...">
        
        <span class="search-close-icon" id="search-close-icon">
          <a href="javascript: void(0)">
            <i class="iconfont icon-close"></i>
          </a>
        </span>
      </div>
      <div class="search-result" id="search-result"></div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    inputArea.onclick = function() {
      getSearchFile()
      this.onclick = null
    }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        // inputArea.focus()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'>首次搜索，正在载入索引文件，请稍后……<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + orig_data_title + "</a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<p class=\"search-result-abstract\">" + match_content + "...</p>"
                }
                str += "</li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>没有找到内容，请尝试更换检索词。<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>未找到search.xml文件，具体请参考：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>请求失败，尝试重新刷新页面或稍后重试。<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




        
  <div class="tools-bar-item theme-icon" id="switch-color-scheme">
    <a href="javascript: void(0)">
      <i id="theme-icon" class="iconfont icon-moon"></i>
    </a>
  </div>

  
<script src="/js/colorscheme.js"></script>





        
  
    <div class="share-icon tools-bar-item">
      <a href="javascript: void(0)" id="share-icon">
        <i class="iconfont iconshare"></i>
      </a>
      <div class="share-content hidden">
        
          <a class="share-item" href="https://twitter.com/intent/tweet?text=' + %E3%80%90NOTES.0x08%E3%80%91Linux%20Kernel%20Pwn%20IV%EF%BC%9A%E9%80%9A%E7%94%A8%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E6%8A%80%E5%B7%A7 + '&url=' + http%3A%2F%2Fblog.arttnba3.cn%2F2021%2F11%2F29%2FNOTE-0X08-LINUX-KERNEL-PWN-PART-IV%2F + '" target="_blank" title="Twitter">
            <i class="iconfont icon-twitter"></i>
          </a>
        
        
          <a class="share-item" href="https://www.facebook.com/sharer.php?u=http://blog.arttnba3.cn/2021/11/29/NOTE-0X08-LINUX-KERNEL-PWN-PART-IV/" target="_blank" title="Facebook">
            <i class="iconfont icon-facebooksquare"></i>
          </a>
        
      </div>
    </div>
  
  
<script src="/js/shares.js"></script>



      </div>
    </div>
  </body>
</html>
