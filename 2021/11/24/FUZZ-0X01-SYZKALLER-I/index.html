<!DOCTYPE html>
<html lang="zh-CN" color-mode="light">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="keywords" content="" />
  <meta name="author" content="arttnba3" />
  <meta name="description" content="あがいた夢を捨てて揺れる今日は眠って誤魔化せ" />
  
  
  <title>
    
      【FUZZ.0x01】syzkaller - I：使用 syzkaller 进行漏洞挖掘 
      
      
      |
    
     arttnba3&#39;s blog
  </title>

  
    <link rel="apple-touch-icon" href="/img/favicon.png">
    <link rel="icon" href="/img/favicon.png">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  
<link rel="stylesheet" href="/css/color-scheme.css">
<link rel="stylesheet" href="/css/base.css">
<link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css">
<link rel="stylesheet" href="/css/github-markdown.css">
<link rel="stylesheet" href="/css/highlight.css">
<link rel="stylesheet" href="/css/comments.css">

  <!-- 代码块风格 -->
  

  <!-- jquery3.3.1 -->
  
    <script defer type="text/javascript" src="/plugins/jquery.min.js"></script>
  

  <!-- fancybox -->
  
    <link href="/plugins/jquery.fancybox.min.css" rel="stylesheet">
    <script defer type="text/javascript" src="/plugins/jquery.fancybox.min.js"></script>
  
  
<script src="/js/fancybox.js"></script>


  

  <script>
    var html = document.documentElement
    const colorMode = localStorage.getItem('color-mode')
    if (colorMode) {
      document.documentElement.setAttribute('color-mode', colorMode)
    }
  </script>
<meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="arttnba3's blog" type="application/atom+xml">
</head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a target="_blank" rel="noopener" href="https://arttnba3.cn">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img src="/img/avatar.png" alt="">
      
    </a>
    <div class="nickname"><a target="_blank" rel="noopener" href="https://arttnba3.cn">arttnba3's blog</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">Home</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">Archives</a>
        </li>
      
        <li class="nav-item" data-path="/categories/">
          <a href="/categories/">Categories</a>
        </li>
      
        <li class="nav-item" data-path="/tags/">
          <a href="/tags/">Tags</a>
        </li>
      
        <li class="nav-item" data-path="/friends/">
          <a href="/friends/">Friends</a>
        </li>
      
        <li class="nav-item" data-path="/about/">
          <a href="/about/">About</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->


  <!-- LaTex Display -->

  
    <script async type="text/javascript" src="/plugins/mathjax/tex-chtml.js"></script>
  
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    }
  </script>





  <!-- clipboard -->

  
    <script async type="text/javascript" src="/plugins/clipboard.min.js"></script>
  
  
<script src="/js/codeCopy.js"></script>







  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">【FUZZ.0x01】syzkaller - I：使用 syzkaller 进行漏洞挖掘</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime" title="更新时间"></i>
          2021-11-24 03:09:11
        </span>
        
              <span class="post-categories">
                <i class="iconfont icon-bookmark" title="分类"></i>
                
                <span class="span--category">
                  <a href="/categories/FUZZ/" title="FUZZ">
                    <b>#</b> FUZZ
                  </a>
                </span>
                
              </span>
          
              <span class="post-tags">
                <i class="iconfont icon-tags" title="标签"></i>
                
                <span class="span--tag">
                  <a href="/tags/Pwn/" title="Pwn">
                    <b>#</b> Pwn
                  </a>
                </span>
                
                <span class="span--tag">
                  <a href="/tags/Linux/" title="Linux">
                    <b>#</b> Linux
                  </a>
                </span>
                
                <span class="span--tag">
                  <a href="/tags/Linux-Kernel/" title="Linux Kernel">
                    <b>#</b> Linux Kernel
                  </a>
                </span>
                
                <span class="span--tag">
                  <a href="/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/" title="漏洞挖掘">
                    <b>#</b> 漏洞挖掘
                  </a>
                </span>
                
                <span class="span--tag">
                  <a href="/tags/syzkaller/" title="syzkaller">
                    <b>#</b> syzkaller
                  </a>
                </span>
                
              </span>
          
      </div>
      <div class="markdown-body">
        <p>尝试遍历所有的世界线</p>
<span id="more"></span>

<h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><p>syzkaller 是由 Google 开发的一个十分强大的针对内核的 fuzzer，自其面世以来已经帮助全世界的内核安全研究员发现了数量惊人的内核漏洞</p>
<p>本篇文章中笔者将简述 syzkaller 的使用方法</p>
<h1 id="0x01-环境配置"><a href="#0x01-环境配置" class="headerlink" title="0x01.环境配置"></a>0x01.环境配置</h1><blockquote>
<p>这里参照官方文档进行配置： <a target="_blank" rel="noopener" href="https://github.com/google/syzkaller">https://github.com/google/syzkaller</a></p>
<p>笔者本地环境：Ubuntu 21.04</p>
</blockquote>
<p><strong>在安装之前请确保你的电脑具有足够的运行内存与存储空间！</strong>（笔者的2G阿里云学生机就被搞炸了</p>
<p>要使用 syzkaller 进行漏洞挖掘，我们需要：</p>
<ul>
<li><code>Go compiler and syzkaller itself</code></li>
<li><code>C compiler with coverage support</code></li>
<li><code>Linux kernel with coverage additions</code></li>
<li><code>Virtual machine or a physical device</code></li>
</ul>
<h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt update</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt install make gcc flex bison libncurses-dev libelf-dev libssl-dev clang clang-format</span></span><br></pre></td></tr></table></figure>

<h2 id="配置-golang-环境"><a href="#配置-golang-环境" class="headerlink" title="配置 golang 环境"></a>配置 golang 环境</h2><p>首先配置 golang 环境，可以参照<a target="_blank" rel="noopener" href="https://golang.org/doc/install">官方文档</a>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget https://dl.google.com/go/go1.14.2.linux-amd64.tar.gz</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar -xf go1.14.2.linux-amd64.tar.gz</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> go goroot</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> gopath</span></span><br></pre></td></tr></table></figure>

<p>在 <code>/etc/profile</code> 中写入如下配置，重启，这里需要注意的是 <code>YourGoPath</code><strong>应当替换为你实际存放 go 的路径</strong>，在上一步的终端中输入 <code>pwd</code> 后将其值替换到下方</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> GOPATH=YourGoPath/gopath</span><br><span class="line"><span class="built_in">export</span> GOROOT=YourGoPath/goroot</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$GOPATH</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$GOROOT</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>

<h2 id="编译-syzkaller"><a href="#编译-syzkaller" class="headerlink" title="编译 syzkaller"></a>编译 syzkaller</h2><p>安装 syzkaller 本体</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go get -u -d github.com/google/syzkaller/prog</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> gopath/src/github.com/google/syzkaller/</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br></pre></td></tr></table></figure>

<h2 id="编译目标内核"><a href="#编译目标内核" class="headerlink" title="编译目标内核"></a>编译目标内核</h2><p>从镜像站随便拉一个版本的源码过来就行，笔者这里拉了一个 5.11 版本的内核</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget https://mirrors.tuna.tsinghua.edu.cn/kernel/v5.x/linux-5.11.tar.gz</span></span><br></pre></td></tr></table></figure>

<p>解压</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar -zxvf linux-5.11.tar.gz</span> </span><br></pre></td></tr></table></figure>

<p>然后执行下面这两条指令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make CC=<span class="string">&quot;/usr/bin/gcc&quot;</span> defconfig</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make CC=<span class="string">&quot;/usr/bin/gcc&quot;</span> kvm_guest.config</span></span><br></pre></td></tr></table></figure>

<p>对于老版本内核，应当为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make CC=<span class="string">&quot;/usr/bin/gcc&quot;</span> defconfig</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make CC=<span class="string">&quot;/usr/bin/gcc&quot;</span> kvmconfig</span></span><br></pre></td></tr></table></figure>

<p>接下来编辑 <code>.config</code> 文件，在其末尾添加如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_KCOV=y</span><br><span class="line">CONFIG_DEBUG_INFO=y</span><br><span class="line">CONFIG_KASAN=y</span><br><span class="line">CONFIG_KASAN_INLINE=y</span><br><span class="line">CONFIG_CONFIGFS_FS=y</span><br><span class="line">CONFIG_SECURITYFS=y</span><br></pre></td></tr></table></figure>

<p>接下来开始编译内核，这个时候可以简单开一局你喜欢的游戏慢慢等待（笑）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make CC=<span class="string">&quot;/usr/bin/gcc&quot;</span> olddefconfig</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make CC=<span class="string">&quot;/usr/bin/gcc&quot;</span> -j64</span></span><br></pre></td></tr></table></figure>

<p>这里笔者还遇到一个问题，**笔者的 gcc 版本太高了…**于是编译的时候又出现了这个错误：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc1: error: ‘-fcf-protection’ is not compatible with this target</span><br></pre></td></tr></table></figure>

<p><strong>切换回官方推荐的 gcc8 后重新进行编译</strong></p>
<blockquote>
<p>笔者<del>向生活妥协了，</del>暂时没找到高版本 gcc 在这个配置下能够成功编译的方法</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get install gcc-8 gcc-8-multilib</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get install g++-8 g++-8-multilib</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo update-alternatives --install /usr/bin/gcc gcc  /usr/bin/gcc-8 1</span></span><br></pre></td></tr></table></figure>

<p>出现下面这行就标志着编译完成</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Kernel: arch/x86/boot/bzImage is ready  (#1)</span><br></pre></td></tr></table></figure>

<p>编译出来的 bzImage 在 <code>arch/x86/boot/bzImage</code>，vmlinux 则就在源码根目录下，这两个文件前者是压缩后的内核后者是原始内核文件</p>
<h2 id="配置-ext4-硬盘镜像文件"><a href="#配置-ext4-硬盘镜像文件" class="headerlink" title="配置 ext4 硬盘镜像文件"></a>配置 ext4 硬盘镜像文件</h2><p>这里我们使用 <code>debootstrap</code> 来创建ext4硬盘镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get install debootstrap</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> image</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> image</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget https://raw.githubusercontent.com/google/syzkaller/master/tools/create-image.sh -O create-image.sh</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> +x create-image.sh</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./create-image.sh</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>wget 的这一步<strong>需要翻墙</strong>（<code>raw.githubusercontent.com</code> 在国内似乎是被墙了，总之笔者记忆里从没成功在不翻墙的情况下成功上去过），若嫌麻烦可以直接 copy <a href="/download/create-image.sh">笔者已经下好的</a></p>
</blockquote>
<p>这一步不知道是因为网络原因还是别的原因<strong>总而言之非常的慢</strong>（比上面编译内核耗时还长），完成之后如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ll</span></span><br><span class="line">total 554772</span><br><span class="line">drwxrwxr-x  3 arttnba3 arttnba3       4096 Nov 12 03:02 ./</span><br><span class="line">drwxrwxr-x  7 arttnba3 arttnba3       4096 Nov 12 00:53 ../</span><br><span class="line">drwxr-xr-x 21 root     root           4096 Nov 12 02:58 chroot/</span><br><span class="line">-rwxrwxr-x  1 arttnba3 arttnba3       6360 Nov 11 23:25 create-image.sh*</span><br><span class="line">-rw-------  1 arttnba3 arttnba3       2602 Nov 12 03:02 stretch.id_rsa</span><br><span class="line">-rw-r--r--  1 arttnba3 arttnba3        569 Nov 12 03:02 stretch.id_rsa.pub</span><br><span class="line">-rw-rw-r--  1 arttnba3 arttnba3 2147483648 Nov 12 03:02 stretch.img</span><br></pre></td></tr></table></figure>

<p>我们可以在文件目录下找到一个名为 <code>stretch.img</code> 的文件，这个文件就是构建好的磁盘镜像文件</p>
<h2 id="安装-qemu"><a href="#安装-qemu" class="headerlink" title="安装 qemu"></a>安装 qemu</h2><p>这一步还是比较简单的，需要注意的是如果你和笔者一样在 VMware 上使用 Linux 则应当在设置中把 <code>虚拟化 Intel VT-x/EPT 或 AMD-V/RVI(V)</code> 打开</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt install qemu-system-x86</span></span><br></pre></td></tr></table></figure>

<p>完成这一切之后看看内核是否能够被成功启动，启动脚本如下（别忘了替换内核镜像与硬盘镜像的路径）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">	-m 2G \</span><br><span class="line">	-smp 2 \</span><br><span class="line">	-kernel ./bzImage \</span><br><span class="line">	-append <span class="string">&quot;console=ttyS0 root=/dev/sda earlyprintk=serial net.ifnames=0&quot;</span> \</span><br><span class="line">	-drive file=./stretch.img,format=raw \</span><br><span class="line">	-net user,host=10.0.2.10,hostfwd=tcp:127.0.0.1:10021-:22 \</span><br><span class="line">	-net nic,model=e1000 \</span><br><span class="line">	-enable-kvm \</span><br><span class="line">	-nographic \</span><br><span class="line">	-pidfile vm.pid \</span><br><span class="line">	2&gt;&amp;1 | <span class="built_in">tee</span> vm.log</span><br></pre></td></tr></table></figure>

<p>默认 root 账户无密码，成功登入</p>
<p><img src="https://i.loli.net/2021/11/12/v5sQXyulgK92Mq1.png" alt="image.png"></p>
<p>前面在配置硬盘镜像文件时还给我们提供了 ssh key，我们也可以用 ssh 来直接连接至虚拟机：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh -i ./stretch.id_rsa -p 10021 -o <span class="string">&quot;StrictHostKeyChecking no&quot;</span> root@localhost</span></span><br></pre></td></tr></table></figure>

<p>至此，需要的环境就都配置完成了</p>
<h1 id="0x02-开始使用-syzkaller"><a href="#0x02-开始使用-syzkaller" class="headerlink" title="0x02.开始使用 syzkaller"></a>0x02.开始使用 syzkaller</h1><h2 id="PRE-工作原理"><a href="#PRE-工作原理" class="headerlink" title="PRE.工作原理"></a><em>PRE.工作原理</em></h2><p>对于 syzkaller 的架构，官方给出了这样的一张 Overview</p>
<p><img src="https://i.loli.net/2021/11/11/LxNvdhpEX2sBjYc.png" alt="image.png"></p>
<ul>
<li><p><code>syz-manager</code> ：syzkaller 的控制中枢，其会启动多个 VM 实例（如图所示的一个黄色卡片就是一个实例）并进行监视，同时通过 RPC 来启动 <code>syz-fuzzer</code></p>
</li>
<li><p><code>syz-fuzzer</code> ：负责引导整个 fuzz 的过程：</p>
<ul>
<li>生成 input</li>
<li>启动 <code>syz-executor</code> 进程进行 fuzz</li>
<li>从被 fuzz 的 kernel 的 <code>/sys/kernel/debug/kcov</code> 获得覆盖（coverage）的相关信息</li>
<li>通过 RPC 将新的覆盖回送到 <code>syz-manager</code></li>
</ul>
</li>
<li><p><code>syz-executor</code>：负责<strong>执行单个输入</strong>——从 <code>syz-fuzzer</code> 处接受 input 并执行，最后回送结果</p>
</li>
</ul>
<h2 id="配置文件（for-test）"><a href="#配置文件（for-test）" class="headerlink" title="配置文件（for test）"></a>配置文件（for test）</h2><p>我们需要为 syzkaller 编写额外的配置文件，一个简单的例子如下，这里需要注意替换为你自己的路径，包括 <code>workdir</code> 文件夹你应当手动 mkdir 一个：</p>
<blockquote>
<p>config.cfg</p>
</blockquote>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;linux/amd64&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;http&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1:56741&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;workdir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/arttnba3/Documents/golang/gopath/src/github.com/google/syzkaller/workdir&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;kernel_obj&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/arttnba3/Desktop/kernel/linux-5.11&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;image&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/arttnba3/Desktop/kernel/image/stretch.img&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;sshkey&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/arttnba3/Desktop/kernel/image/stretch.id_rsa&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;syzkaller&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/arttnba3/Documents/golang/gopath/src/github.com/google/syzkaller&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;procs&quot;</span><span class="punctuation">:</span> <span class="number">8</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;qemu&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;vm&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;count&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;kernel&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/arttnba3/Desktop/kernel/syzkaller/bzImage&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;cpu&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;mem&quot;</span><span class="punctuation">:</span> <span class="number">2048</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="启动-syzkaller"><a href="#启动-syzkaller" class="headerlink" title="启动 syzkaller"></a>启动 syzkaller</h2><p>在 syzkaller 目录下输入如下命令启动 syzkaller：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./bin/syz-manager -config=config.cfg</span></span><br></pre></td></tr></table></figure>

<p>成功启动后我们可以通过访问 <code>localhost:56741</code> 来获取 syzkaller 的状态，效果如下图所示：</p>
<p><img src="https://i.loli.net/2021/11/12/BnYuNbO2MdiEw5V.png" alt="image.png"></p>
<h3 id="可能会遇到的问题"><a href="#可能会遇到的问题" class="headerlink" title="*可能会遇到的问题"></a><em>*可能会遇到的问题</em></h3><h4 id="无法启动-vm-instance"><a href="#无法启动-vm-instance" class="headerlink" title="无法启动 vm instance"></a>无法启动 vm instance</h4><p>有可能会遇到无法启动 vm instance 的问题，报错形式大致如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64: error: failed to set MSR 0x48f to 0x7fffff00036dfb</span><br><span class="line">qemu-system-x86_64: ../../target/i386/kvm/kvm.c:2753: kvm_buf_set_msrs: Assertion `ret == cpu-&gt;kvm_msr_buf-&gt;nmsrs&#x27; failed.</span><br></pre></td></tr></table></figure>

<p>按照官方给出的解决办法是在 qemu 的启动参数中去掉 <code>-cpu host,migratable=off</code>，我们需要在配置文件的 <code>vm</code> 项中添加 <code>qemu-args</code>项，值为 <code>-enable-kvm</code>，如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;linux/amd64&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;http&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1:56741&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;workdir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/arttnba3/Documents/golang/gopath/src/github.com/google/syzkaller/workdir&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;kernel_obj&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/arttnba3/Desktop/kernel/linux-5.11&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;image&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/arttnba3/Desktop/kernel/image/stretch.img&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;sshkey&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/arttnba3/Desktop/kernel/image/stretch.id_rsa&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;syzkaller&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/arttnba3/Documents/golang/gopath/src/github.com/google/syzkaller&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;procs&quot;</span><span class="punctuation">:</span> <span class="number">8</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;qemu&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;vm&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;count&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;kernel&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/arttnba3/Desktop/kernel/syzkaller/bzImage&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;cpu&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;mem&quot;</span><span class="punctuation">:</span> <span class="number">2048</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;qemu_args&quot;</span><span class="punctuation">:</span><span class="string">&quot;-enable-kvm&quot;</span></span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="网络设备问题"><a href="#网络设备问题" class="headerlink" title="网络设备问题"></a>网络设备问题</h4><p>在 syzkaller 挖掘过程中可能出现如下报错信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[FAILED] Failed to start Raise network interfaces.</span><br></pre></td></tr></table></figure>

<p>虽然似乎还是能正常启动的</p>
<h2 id="crash-分析"><a href="#crash-分析" class="headerlink" title="crash 分析"></a>crash 分析</h2><p>笔者本来想写一个有漏洞点内核模块来人为制造 crash，不过现在刚开挖没几分钟就出了一个 crash，由于用的是 5.11 版本的内核，已经不算太新了，笔者认为应该是挖到了现有的 CVE，通过 Google 笔者也找到了一个<a target="_blank" rel="noopener" href="https://syzkaller.appspot.com/bug?id=ad240ff5c32ca4f3406dc3acca519370693bb47c">基本上是一样的 crash</a>，不过我们还是来简单分析一下</p>
<p><img src="https://i.loli.net/2021/11/12/7EHYatBoG6KFxqR.png" alt="image.png"></p>
<p>在 Description 项中说明了 crash 的简要信息，点开分为两项：<code>log</code> 和 <code>report</code></p>
<p><img src="https://i.loli.net/2021/11/12/Q6dBoPOHm7sRtgI.png" alt="image.png"></p>
<p>log 中给出的是 fuzz 的流程，包括运行的系统调用、输入参数等一系列信息，因为是自动生成的所以一般不会特别好看</p>
<p><img src="https://i.loli.net/2021/11/12/ANwKC67iRQL2ZHt.png" alt="image.png"></p>
<p>report 中给出的则是 kernel 相关信息，例如调用栈回溯等</p>
<p><img src="https://i.loli.net/2021/11/12/UvNkQe7ElAHSKm6.png" alt="image.png"></p>
<p>比较可惜的是这个 crash <strong>没法重现</strong>，在一个 crash 刚刚生成时 syzkaller 会尝试进行重现，此时 report 的状态会显示为 <code>reproducing</code>，若成功了则会显示对应的结果，品相比较好的一种 report 就是 <code>has C repo</code>：有产生该 crash 的 C 代码</p>
<p><img src="https://i.loli.net/2021/11/12/l47kcaVMS9wH6u5.png" alt="image.png"></p>
<h1 id="0x03-使用-syzlang-编写描述文件进行-fuzz"><a href="#0x03-使用-syzlang-编写描述文件进行-fuzz" class="headerlink" title="0x03.使用 syzlang 编写描述文件进行 fuzz"></a>0x03.使用 syzlang 编写描述文件进行 fuzz</h1><p>直接就这样挂着肯定不能直接就把洞挖出来<del>虽然笔者前面没挂一会就出了一个crash</del>，因此接下来我们需要人工配置系统调用模板，以<strong>有针对性地</strong>进行漏洞挖掘</p>
<p>syzkaller 使用它自己的声明式语言（Syscall Description Language，aka <code>syzlang</code>（读作 <code>[siːzˈlæŋg]</code>，<del>笔者以前一直读作 [saiːzˈlæŋg]…</del>））来描述系统调用模板，在安装目录下的 <code>docs/syscall_descriptions.md</code> 与 <code>docs/syscall_descriptions_syntax.md</code> 中有着相关的说明，在笔者看来是类似 C 的一门描述语言</p>
<p>我们需要使用 syzlang 来编写特定的系统调用描述文件（也叫规则文件，后文中这两个词指的是同一个东西），syzkaller 会根据我们的描述文件有针对性地进行 fuzz</p>
<p><a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/sys/linux/sys.txt">这是 Google 给出的一个例子</a></p>
<blockquote>
<p>笔者看着也是比较头大的…还是慢慢来吧…</p>
<p>以下主要是翻译谷歌官方的文档（<del>谁叫国内没有中文文档呢</del>），外加一些笔者自己本人的理解以及补充说明</p>
</blockquote>
<h2 id="syzlang-语法"><a href="#syzlang-语法" class="headerlink" title="syzlang 语法"></a>syzlang 语法</h2><p>syzlang 的语法结构如下，<del>看完你也能快速上手！</del>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">syscallname &quot;(&quot; [arg [&quot;,&quot; arg]*] &quot;)&quot; [type] [&quot;(&quot; attribute* &quot;)&quot;]</span><br><span class="line">arg = argname type</span><br><span class="line">argname = identifier</span><br><span class="line">type = typename [ &quot;[&quot; type-options &quot;]&quot; ]</span><br><span class="line">typename = &quot;const&quot; | &quot;intN&quot; | &quot;intptr&quot; | &quot;flags&quot; | &quot;array&quot; | &quot;ptr&quot; |</span><br><span class="line">	   &quot;string&quot; | &quot;strconst&quot; | &quot;filename&quot; | &quot;glob&quot; | &quot;len&quot; |</span><br><span class="line">	   &quot;bytesize&quot; | &quot;bytesizeN&quot; | &quot;bitsize&quot; | &quot;vma&quot; | &quot;proc&quot;</span><br><span class="line">type-options = [type-opt [&quot;,&quot; type-opt]]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个时候你需要把自己当作一个 scanner + parser（大雾</p>
<p><del>正则表达式相信大家应该都学过，哪怕没学过编译原理课上你总会学到的，那么按照正则来看的话其实这个语法结构并不难解析</del>（</p>
</blockquote>
<p>以下是对其中的一些符号说明，<strong>不是 syzlang 实际语法内容</strong>：</p>
<ul>
<li>双引号 <code>&quot;&quot; </code>表示这个符号内的东西表示<strong>要按其原样进行匹配</strong>，丢弃双引号</li>
<li>或符号 <code>|</code> 表示值可以取左边也可以取右边</li>
<li>等于号 <code>=</code> 表示左边的表达式应当为右边的形式</li>
<li>中括号 <code>[]</code> 表示一个<strong>可选表达式</strong>，取其内的值并丢弃中括号</li>
<li>星号 <code>*</code> 表示<strong>闭包</strong>，即 0 次或多次的自我连接  <del>什么？你还没学过离散数学</del></li>
</ul>
<p>这是谷歌官方给出的一个例子：</p>
<blockquote>
<p><code>syzkaller</code> uses declarative description of syscall interfaces to manipulate programs (sequences of syscalls). Below you can see (hopefully self-explanatory) excerpt from the descriptions:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">open(file filename, flags flags[open_flags], mode flags[open_mode]) fd</span><br><span class="line">read(fd fd, buf buffer[out], count len[buf])</span><br><span class="line">close(fd fd)</span><br><span class="line">open_mode = S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH</span><br></pre></td></tr></table></figure>

<p><del>斯密🦄赛，👴没法做到 self-explanatory</del></p>
</blockquote>
<h3 id="O-注释与文件包含"><a href="#O-注释与文件包含" class="headerlink" title="O.注释与文件包含"></a>O.注释与文件包含</h3><p>syzlang 中的注释与 shell 脚本注释形式相同，为以 <code>#</code> 开头的单行注释</p>
<p>这是一个🌰：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># this is a useful sentence! do not delete it!</span><br></pre></td></tr></table></figure>

<p>在 syzlang 中，我们可以额外引入<strong>内核源码文件</strong>作为参数、系统调用…等等一系列的补充，形式与 C 语言的 include 语句大致相同，不过**没有了开头的”#”**（因为 # 开头是注释）</p>
<p>这是一个🌰：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include &lt;linux/fs.h&gt;</span><br></pre></td></tr></table></figure>

<h3 id="I-参数（arg）与参数名（argname）"><a href="#I-参数（arg）与参数名（argname）" class="headerlink" title="I.参数（arg）与参数名（argname）"></a>I.参数（arg）与参数名（argname）</h3><p>我们输入给系统调用模板的 <code>参数 （arg）</code> 应当为如下形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arg = argname type</span><br></pre></td></tr></table></figure>

<p>即一个参数由 <code>参数名 （argname）  </code> 与 <code>类型（type）</code> 组成</p>
<p>其中，参数名便是 <code>标识符（identifier）</code></p>
<h4 id="example"><a href="#example" class="headerlink" title="example"></a>example</h4><p>这么讲有些空泛，我们来简单看一个例子，在 Linux 中系统调用 <code>read</code> 的声明（其实是定义）如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(read, <span class="type">unsigned</span> <span class="type">int</span>, fd, <span class="type">char</span> __user *, buf, <span class="type">size_t</span>, count)</span><br></pre></td></tr></table></figure>

<p>当我们使用 libc 的 wrapper 进行 read 系统调用时，形式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> 	my_file_fd = open(<span class="string">&quot;/dev/a3dev&quot;</span>, O_RDONLY);</span><br><span class="line"><span class="type">char</span> 			my_buf[<span class="number">114514</span>];</span><br><span class="line"><span class="type">size_t</span>			my_count = <span class="number">114514</span>;</span><br><span class="line">read(my_file_fd, my_buf, my_count);</span><br></pre></td></tr></table></figure>

<p>在这个例子当中，<code>fd、buf、count</code> 便是 <strong>argname</strong>，<code>my_file_fd、my_buf、my_count</code> 便是 <strong>type</strong></p>
<p>那么，在我们使用 syzlang 编写系统调用模板时，例如 read 的第一个参数，我们应该写成下面这个样子（假设 my_file_fd 已定义为一个 <code>resources</code>（后面会讲））：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd my_file_fd</span><br></pre></td></tr></table></figure>

<h3 id="II-类型（type）"><a href="#II-类型（type）" class="headerlink" title="II.类型（type）"></a>II.类型（type）</h3><blockquote>
<p>其实这么翻译笔者觉得好像不大准确，不过笔者英文不大行所以这里暂且直译…</p>
</blockquote>
<p>前面我们讲到一个 <code>arg</code> 由 一个 <code>argname </code>与 <code>type</code> 组成，argname 我们已经讲了，现在我们来讲 type</p>
<p>type 的定义同样由两部分组成——<code>类型名（typename）</code> 与 <code>类型选项（type-options）</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type = typename [ &quot;[&quot; type-options &quot;]&quot; ]</span><br></pre></td></tr></table></figure>

<h4 id="类型名（typename）"><a href="#类型名（typename）" class="headerlink" title="类型名（typename）"></a>类型名（typename）</h4><p>即该 type 的类型，例如 C 当中的int、char、void 等等</p>
<p>常规选项包括：</p>
<ul>
<li><strong>opt</strong>：这是一个可选参数（例如 mmap 的 fd）</li>
</ul>
<p>其余 type-options 是基于特定 type 的，如下：</p>
<ul>
<li><p><strong>const</strong>：整型常数</p>
<ul>
<li>类型选项：<ul>
<li>值（value）：例如 <code>0</code></li>
<li>基础类型（underlying type）：<code>intN</code> 或 <code>intptr</code> 之一</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>intN</strong> 或 <strong>intptr</strong>：一个有着特殊含义的整型，下文会进行详细说明</p>
<ul>
<li>类型选项：<ul>
<li>可选范围区间：例如 <code>&quot;1:100&quot;</code> 表示取值值的区间为 <code>[1, 100]</code></li>
<li>可选参数</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>flags</strong>：值的集合</p>
<ul>
<li>类型选项：<ul>
<li>对 flags 描述的引用</li>
<li>基础整型类型：例如 <code>int32</code></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>array</strong>：一个可变长&#x2F;固定长度的数组</p>
<ul>
<li>类型选项：<ul>
<li>元素的 type</li>
<li>可选长度区间：例如固定长度 <code>&quot;5&quot;</code> 或者长度范围 <code>&quot;5:10&quot;</code>（包括边界）</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>ptr</strong> 或 <strong>ptr64</strong>：指向一个对象的指针</p>
<ul>
<li>类型选项：<ul>
<li>方向：<code>in</code> 或 <code>out</code> 或 <code>inout</code></li>
<li>对象的 type</li>
</ul>
</li>
<li>无论对象指针大小如何，ptr64 永远为 8 字节</li>
</ul>
</li>
<li><p><strong>string</strong>：一块有着 0 终止符的内存缓冲区</p>
<ul>
<li>类型选项：<ul>
<li>常量字符串&#x2F;对字符串的引用<ul>
<li>前者：例如 <code>&quot;foo&quot;</code>作为常规字符串进行解析，或者`deadbeef`作为4个 16 进制字节进行解析</li>
<li>后者：若是特殊类型 <code>filename</code> 则会<strong>生成</strong>文件名</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>stringnoz</strong>：一块<strong>没有</strong> 0 终止符的内存缓冲区</p>
<ul>
<li>类型选项：（同 <code>string</code>)</li>
</ul>
</li>
<li><p><strong>glob</strong>：匹配目标文件的 glob（？）模式</p>
<ul>
<li>类型选项：<ul>
<li>用引号包裹着的模式字符串：例如 <code>&quot;/sys/&quot;</code> 或 <code>&quot;/sys/**/*/&quot;</code>，具体用法参见<a target="_blank" rel="noopener" href="https://pkg.go.dev/path/filepath#Match">https://pkg.go.dev/path/filepath#Match</a></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>fmt</strong>：一个表示一个整数的字符串</p>
<ul>
<li>类型选项：<ul>
<li>格式与值：前者可取值为 <code>dec</code>或  <code>hex</code> 或 <code>oct</code>；后者可以是一个 resource、int、flags、const 或 proc</li>
</ul>
</li>
<li>最终的结果通常是固定尺寸的</li>
</ul>
</li>
<li><p><strong>len</strong>：另一个 <code> 字段</code> 的长度（对于 array 而言为元素的数量）</p>
<ul>
<li>类型选项：<ul>
<li>对象的 argname</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>bytesize</strong>：与 len 类似，不过单位是<strong>字节</strong></p>
<ul>
<li>类型选项：<ul>
<li>对象的 argname</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>bitsize</strong>：与 len 类型，不过单位是<strong>比特位</strong></p>
<ul>
<li>类型选项：<ul>
<li>对象的 argname</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>offsetof</strong>：一个 <code>字段</code> 在其 parent struct  中的偏移（笔者怎么译都没那感觉，故保留原词）</p>
<ul>
<li>类型选项：<ul>
<li><code>字段</code></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>vma</strong> 或 <strong>vma64</strong>：指向一组页的指针（用作 mmap&#x2F;munmap&#x2F;mremap&#x2F;madvise 的输入）</p>
<ul>
<li>类型选项：<ul>
<li>（可选）页的数量或页的范围：前者例如 <code>vma[7]</code>，后者例如 <code>vma[2-4]</code></li>
</ul>
</li>
<li>vma64 的长度恒为 8 字节</li>
</ul>
</li>
<li><p><strong>proc</strong>：单个进程的整型（详见下面的描述）</p>
<ul>
<li>类型选项：<ul>
<li>值的区间的起始</li>
<li>每个进程的值的数量</li>
<li>基础类型</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>text</strong>：特定 type 的机器码</p>
<ul>
<li>类型选项：<ul>
<li>代码类型：<code>x86_real</code>, <code>x86_16</code>, <code>x86_32</code>, <code>x86_64</code>, <code>arm64</code></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>void</strong>：type with static size 0（自己体会，怎么译都没那种感觉…）</p>
<ul>
<li>通常在模板以及可变长（varlen）联合体中使用，<strong>不能用作系统调用的参数</strong></li>
</ul>
</li>
</ul>
<p>在 <code>结构体/联合体/指针</code> 中使用时，<code>flags/len/flags</code> 的构成中尾部还可以跟着 type type-options</p>
<blockquote>
<p><del>唉呀你说了这么多谁听得懂啊，还是快把🌰搬上来吧</del></p>
</blockquote>
<h5 id="关于-flags-的补充说明"><a href="#关于-flags-的补充说明" class="headerlink" title="关于 flags 的补充说明"></a>关于 <em>flags</em> 的补充说明</h5><p>flags 通常具有如下形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flagname = const [&quot;,&quot; const]*</span><br></pre></td></tr></table></figure>

<p>这是一个🌰：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_flags = 1,2,3,4,5,6,7,8,9,0</span><br></pre></td></tr></table></figure>

<p>对于 string 类型的 flag，其应当具有如下形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flagname = &quot;\&quot;&quot; literal &quot;\&quot;&quot; [&quot;,&quot; &quot;\&quot;&quot; literal &quot;\&quot;&quot;]*</span><br></pre></td></tr></table></figure>

<p>这是一个🌰：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_str_flags = &quot;arttnba3&quot;, &quot;arttnba4&quot;, &quot;arttnba5&quot;</span><br></pre></td></tr></table></figure>

<h4 id="类型选项（type-options）"><a href="#类型选项（type-options）" class="headerlink" title="类型选项（type-options）"></a>类型选项（type-options）</h4><blockquote>
<p>在类型当中，类型选项其实也是可选项（<del>又搁这绕口令了</del>）</p>
</blockquote>
<p>type-options 在笔者的理解中为<strong>对一个特定 type 的补充说明</strong>，其应当具有如下形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type-options = [type-opt [&quot;,&quot; type-opt]]</span><br></pre></td></tr></table></figure>

<p>我们不难看出 type-options 在 syzlang 中为<strong>可选项</strong>，同样地，对于一个 type 其可以有多个 type-options</p>
<p>查看前面 type 的形式说明可知，在使用类型选项时，我们应当使用 <code>[]</code> 将之包裹</p>
<p>以下是一个简单的🌰（作为系统调用参数输入，而非单独的参数定义）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flags flags[open_flags]</span><br></pre></td></tr></table></figure>

<p>从左向右解析：对于这个系统调用的 <code>flags</code> 参数，我们的输入是一个 flags 类型，其类型选项为对一个 flags 描述 <code>open_flags</code> 的引用，意为取值为 open_flags 中之一</p>
<p>其中 open_flags 被定义如下，这些值通过 include 语句从内核源文件中被包含进来：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open_flags = O_WRONLY, O_RDWR, O_APPEND, FASYNC, O_CLOEXEC, O_CREAT, O_DIRECT, O_DIRECTORY, O_EXCL, O_LARGEFILE, O_NOATIME, O_NOCTTY, O_NOFOLLOW, O_NONBLOCK, O_PATH, O_SYNC, O_TRUNC, __O_TMPFILE</span><br></pre></td></tr></table></figure>

<h3 id="III-系统调用模板"><a href="#III-系统调用模板" class="headerlink" title="III.系统调用模板"></a>III.系统调用模板</h3><p>我们将上面的结果进行整合，一个系统调用的形式应当如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">syscallname &quot;(&quot; [arg [&quot;,&quot; arg]*] &quot;)&quot; [type] [&quot;(&quot; attribute* &quot;)&quot;]</span><br></pre></td></tr></table></figure>

<p>接下来笔者通过一个🌰进行分解说明</p>
<h4 id="基本形式"><a href="#基本形式" class="headerlink" title="基本形式"></a>基本形式</h4><p>我们将其最小化，我们应当书写为如下形式，类似于常规的 C 语言函数调用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">syscallname(arg)</span><br></pre></td></tr></table></figure>

<p>例如对于 open 这个系统调用，我们可以写成这个样子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">open(file ptr[in, filename], flags flags[open_flags], mode flags[open_mode])</span><br><span class="line">#...</span><br><span class="line">open_flags = O_WRONLY, O_RDWR, O_APPEND, FASYNC, O_CLOEXEC, O_CREAT, O_DIRECT, O_DIRECTORY, O_EXCL, O_LARGEFILE, O_NOATIME, O_NOCTTY, O_NOFOLLOW, O_NONBLOCK, O_PATH, O_SYNC, O_TRUNC, __O_TMPFILE</span><br><span class="line">open_mode = S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH</span><br></pre></td></tr></table></figure>

<p>对于 open 系统调用的三个参数，我们给了这样的输入：</p>
<ul>
<li>file 参数：一个<strong>指针</strong>类型，其 type-opetions 的第一个为 <code>in</code>，意为由该指针指向特定对象，第二个为 <code>filename</code>，为<strong>特殊的 string 对象</strong>，对于 filename，syzlang 会进行文件生成，将文件名作为输入</li>
<li>flags 参数：一个 <strong>flags</strong> 类型，其 type-options 为 <code>open_flags</code> ，意为从我们定义的 flags——<code>open_flags</code> 中取值</li>
<li>mode 参数：一个 <strong>flags</strong> 类型，其 type-options 为 <code>open_mode</code> ，意为从我们定义的 flags——<code>open_mode</code> 中取值</li>
</ul>
<h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>接下来我们再继续深入，系统调用通常都有返回值，我们可以选择接收也可以选择忽视，若是我们需要进行接收，则应当在系统调用的末尾添加 type ，例如 open 这个系统调用会返回一个文件描述符，我们现在想将其返回的文件描述符存到一个变量比如说 <code>a3fd</code>（假如已被声明为 _资源_（下文解释）） 当中，我们应当写成下面这个形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open(file ptr[in, filename], flags flags[open_flags], mode flags[open_mode]) a3fd</span><br></pre></td></tr></table></figure>

<p>那么 open 的返回值便被存储到了 <code>a3fd</code> 这一个 type 当中，我们在后续便可以将 fd 用作其他系统调用的参数，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close(fd a3fd)</span><br></pre></td></tr></table></figure>

<h4 id="call-attributes"><a href="#call-attributes" class="headerlink" title="call attributes"></a>call attributes</h4><p>系统调用模板当中还有一个可选项是 <code>attributes</code>，即这一个系统调用的<strong>属性</strong>，可以取的值如下：</p>
<ul>
<li><code>disabled</code>：该系统调用将不用于 fuzzing；这个属性通常用于临时禁用某些系统调用，或者禁用特定的参数组合</li>
<li><code>timeout[N]</code>：系统调用在默认值以外的额外的超时时间，单位为毫秒（ms）</li>
<li><code>prog_timeoout[N]</code>：若一个程序包含了该系统调用，则该属性为整个程序的执行的超时时间，若存在多个定义了该属性的系统调用则取最大值</li>
<li><code>ignore_return</code>：在回退反馈（笔者推指的是 syzkaller 的 fuzz 机制之一，根据返回值判断路径覆盖之类的）中忽视这个系统调用的返回值；用于不返回固定的错误码（例如 -EFAULT）而是返回其他值的系统调用</li>
<li><code>break_returns</code>：忽略回退反馈中程序中所有后续系统调用的返回值（文档中说 <code>can&#39;t be trusted</code>，笔者暂时不理解…）</li>
</ul>
<h4 id="变种（variants）"><a href="#变种（variants）" class="headerlink" title="变种（variants）"></a>变种（variants）</h4><p>对于系统调用的变种形式，我们应当在系统调用名后面使用 <code>$</code> 符号进行额外的指定</p>
<p>下面是一个🌰：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open$dir(file ptr[in, filename], flags flags[open_flags], mode flags[open_mode]) fd_dir</span><br></pre></td></tr></table></figure>

<blockquote>
<p>按笔者的理解应该是为其取一个别名？比如说对于 syzkaller 而言 <code>open$dir</code> 和 <code>open$a3dir</code> 就是两个东西，而若是在两个不同的文件中都出现了 <code>open$dir</code> 则会在_重编译_（下文解释）时发生冲突</p>
</blockquote>
<h3 id="IV-整型（integer）"><a href="#IV-整型（integer）" class="headerlink" title="IV.整型（integer）"></a>IV.整型（integer）</h3><p>整型也是一种 type，其可选项为 <code>int8</code> 、<code>int16</code>、<code>int32</code>、<code>int64</code>，表示相应大小的整型</p>
<p><code>intptr</code> 用以表示一个<strong>指针大小</strong>的整型，对应 C 语言中的 <code>long</code></p>
<p>通过添加 <code>be</code> 后缀表示这个整型存储为<strong>大端序</strong></p>
<p>这是一个🌰：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read$eventfd(fd fd_event, val ptr[out, int64], len len[val])</span><br></pre></td></tr></table></figure>

<p>我们可以用这样的形式来指定 int 的范围：<code>int32[0:100]</code>——意为该整型的取值范围为 <code>[0,100]</code></p>
<p>我们还可以额外指定取值的跨度，例如 <code>int32[1:10, 2]</code> 意为其取值为 {1, 3, 5, 7, 9}</p>
<p>我们还可以额外指定一个整型的取值范围，单位为比特位，例如 <code>int64:20</code> 意为这个整型只取其 20 bit 的值进行随机化</p>
<h3 id="V-结构体、联合体与其成员（字段）"><a href="#V-结构体、联合体与其成员（字段）" class="headerlink" title="V.结构体、联合体与其成员（字段）"></a>V.结构体、联合体与其成员（字段）</h3><p>在 syzlang 中同样可以定义结构体&#x2F;联合体，结构体&#x2F;联合体的成员被称之为 <code>字段</code>（field）</p>
<h4 id="结构体（struct）"><a href="#结构体（struct）" class="headerlink" title="结构体（struct）"></a>结构体（struct）</h4><p>在 syzlang 中，一个结构体应为如下形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">structname &quot;&#123;&quot; &quot;\n&quot;</span><br><span class="line">	(fieldname type (&quot;(&quot; fieldattribute* &quot;)&quot;)? &quot;\n&quot;)+</span><br><span class="line">&quot;&#125;&quot; (&quot;[&quot; attribute* &quot;]&quot;)?</span><br></pre></td></tr></table></figure>

<p>对于字段而言，其可以在后面的 <code>()</code> 中指定字段属性，但与 type 的属性不同，唯一的属性只有方向： <code>in/out/inout</code>，对于指定的字段，其方向属性会被上层属性给覆盖</p>
<p>在结构体定义的尾部，我们可以额外指定一些属性（使用 <code>[]</code> 包裹），可选属性有：</p>
<ul>
<li><code>packed</code>：该结构体不同字段之间没有 padding（例如 C 中有一个结构体 <code>struct T&#123;int a; char b;&#125;;</code>，char 为 1 字节，int 为 4 字节，那么该结构体便会对 4 字节对齐，在其两个字段之间就会有 3 字节的 padding）</li>
<li><code>align[N]</code>：指定该结构体对 N 字节对齐，padding 的内容并未指定（通常为0）</li>
<li><code>size[N]</code>：结构体被填充到指定的大小 <code>N</code></li>
</ul>
<p>其实和我们在 C 语言中写结构体差不多，下面是一个🌰：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">my_struct &#123;</span><br><span class="line">	a3f1 	int8						# 一个随机的 1 字节的 int</span><br><span class="line">	a3f2	const[0xdeadbeef, int32be]	# 一个固定的 8 字节的 int，取值为 0xdeadbeef，大端序</span><br><span class="line">	a3f3	int32[0:100]				# 一个随机的 4 字节的 int，取值范围为 [0,100]</span><br><span class="line">	a3f4	int64:20					# 一个随机的 8 字节的 int，只取20个比特的值（其他bit置0？）</span><br><span class="line">&#125; [packed]</span><br></pre></td></tr></table></figure>

<h4 id="联合体（union）"><a href="#联合体（union）" class="headerlink" title="联合体（union）"></a>联合体（union）</h4><p>与结构体基本相同，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unionname &quot;[&quot; &quot;\n&quot;</span><br><span class="line">	(fieldname type (&quot;(&quot; fieldattribute* &quot;)&quot;)? &quot;\n&quot;)+</span><br><span class="line">&quot;]&quot; (&quot;[&quot; attribute* &quot;]&quot;)?</span><br></pre></td></tr></table></figure>

<p>不同的是其属性的可选项，有：</p>
<ul>
<li><code>varlen</code>：联合体的大小可变（为指定的字段的长度），若未指定则该联合体大小为其最大字段的大小（类型 C 语言）</li>
<li><code>size[N]</code>：该联合体被填充到指定的大小 <code>N</code></li>
</ul>
<h3 id="VI-资源（resources）"><a href="#VI-资源（resources）" class="headerlink" title="VI.资源（resources）"></a>VI.资源（resources）</h3><p>资源（resources）用作那些需要作为一个系统调用的输出的值传递给另一个系统调用做输入的值。</p>
<p>这么说可能有些空泛，笔者来举个🌰， <code>close</code> 系统调用接收一个文件描述符作为参数，而这个文件描述符应当为你在之前进行 <code>open </code> 或 <code>pipe</code> 系统调用时获得的返回值，为了达成这个目的，我们需要将文件描述符（比如说叫 <code>fd</code>）声明为一个<strong>资源</strong></p>
<p>resources 的形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;resource&quot; identifier &quot;[&quot; underlying_type &quot;]&quot; [ &quot;:&quot; const (&quot;,&quot; const)* ]</span><br></pre></td></tr></table></figure>

<p>其中的 <code>underlying_type</code> 可以是 <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>, <code>intptr</code> 或者是另一个资源（可以是其子类，比如说一个 socket 便是 文件描述符的“子类”）</p>
<p>常量集合可以作为可选参数，表示该资源的特殊值（比如说 0xdeadbeef），特殊值偶尔被用作资源的值，若未指定特殊值，则会使用特殊值 <code>0</code></p>
<p>资源也可以被用作类型（types），这是官方给出的一个🌰：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">resource fd[int32]: 0xffffffffffffffff, AT_FDCWD, 1000000</span><br><span class="line">resource sock[fd]			# 继承 fd 类型</span><br><span class="line">resource sock_unix[sock]	# 继承 sock 类型</span><br><span class="line"></span><br><span class="line">socket(...) sock</span><br><span class="line">accept(fd sock, ...) sock</span><br><span class="line">listen(fd sock, backlog int32)</span><br></pre></td></tr></table></figure>

<p>资源<strong>并不一定要是系统调用的返回值</strong>，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">resource my_resource[int32]</span><br><span class="line"></span><br><span class="line">request_producer(..., arg ptr[out, my_resource])</span><br><span class="line">request_consumer(..., arg ptr[inout, test_struct])</span><br><span class="line"></span><br><span class="line">test_struct &#123;</span><br><span class="line">	...</span><br><span class="line">	attr	my_resource</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于更为复杂的生产者&#x2F;消费者场景，字段属性也可以被利用，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">resource my_resource_1[int32]</span><br><span class="line">resource my_resource_2[int32]</span><br><span class="line"></span><br><span class="line">request_produce1_consume2(..., arg ptr[inout, test_struct])</span><br><span class="line"></span><br><span class="line">test_struct &#123;</span><br><span class="line">	...</span><br><span class="line">	field0	my_resource_1	(out)</span><br><span class="line">	field1	my_resource_2	(in)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="VII-类型别名（Type-Alias）"><a href="#VII-类型别名（Type-Alias）" class="headerlink" title="VII.类型别名（Type Alias）"></a>VII.类型别名（Type Alias）</h3><p>笔者认为可以理解为 C 中的一种特殊的 typedef，其格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type identifier underlying_type</span><br></pre></td></tr></table></figure>

<p>这么看可能有些空泛，我们来看一个🌰：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type bool8		int8[0:1]</span><br><span class="line">type bool16		int16[0:1]</span><br><span class="line">type bool32		int32[0:1]</span><br><span class="line">type bool64		int64[0:1]</span><br><span class="line">type boolptr	intptr[0:1]</span><br><span class="line"></span><br><span class="line">type fileoff[BASE] BASE</span><br><span class="line"></span><br><span class="line">type filename string[filename]</span><br><span class="line"></span><br><span class="line">type buffer[DIR] ptr[DIR, array[int8]]</span><br></pre></td></tr></table></figure>

<p>在这个例子当中我们需要使用布尔值，其取值只有 0 或 1 ，所以我们需要写成 <code>intN[0:1]</code>，但是若是在每一个需要用到布尔值的地方都这么写就太麻烦了，也不利于理解，这个时候就可以给他定义一个<strong>类型别名</strong> <code>boolN</code>，简单易懂</p>
<h3 id="VIII-类型模板（Type-Template）"><a href="#VIII-类型模板（Type-Template）" class="headerlink" title="VIII.类型模板（Type Template）"></a>VIII.类型模板（Type Template）</h3><p>类型模板应定义为如下形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type optional[T] [</span><br><span class="line">	val		T</span><br><span class="line">	void	void</span><br><span class="line">] [varlen]</span><br></pre></td></tr></table></figure>

<p><del>唉呀谷歌你这么讲谁能够看得懂啊，还是赶紧把🌰给掏出来吧</del></p>
<p>下面是一个简单的用法🌰：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type buffer[DIR] ptr[DIR, array[int8]]</span><br><span class="line">type fileoff[BASE] BASE</span><br><span class="line">type nlattr[TYPE, PAYLOAD] &#123;</span><br><span class="line">	nla_len		len[parent, int16]</span><br><span class="line">	nla_type	const[TYPE, int16]</span><br><span class="line">	payload		PAYLOAD</span><br><span class="line">&#125; [align_4]</span><br><span class="line"></span><br><span class="line">#...</span><br><span class="line"></span><br><span class="line">syscall(a buffer[in], b fileoff[int64], c ptr[in, nlattr[FOO, int32]])</span><br></pre></td></tr></table></figure>

<p><del>笔者也没看明白，暂时就先不误人子弟了</del></p>
<h3 id="IX-长度（length）"><a href="#IX-长度（length）" class="headerlink" title="IX.长度（length）"></a>IX.长度（length）</h3><p>你可以使用关键字 <code>len</code>、<code>bytesize</code>、<code>bitsize</code> 来指定结构体当中特定字段的长度</p>
<p>若是 <code>len</code> 的参数为一个指针，则其取值为<strong>指针所指对象的大小</strong></p>
<p>若要表示一个 <code>N 字节的字</code> 中字段的长度，则应当使用 <code>bytesizeN</code>，其中 N 的取值可以为 1、2、4、8</p>
<h4 id="example-1"><a href="#example-1" class="headerlink" title="example"></a><em>example</em></h4><p>这是谷歌官方给出的一个🌰：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">write(fd fd, buf ptr[in, array[int8]], count len[buf])</span><br><span class="line"></span><br><span class="line">sock_fprog &#123;</span><br><span class="line">	len	len[filter, int16]</span><br><span class="line">	filter	ptr[in, array[sock_filter]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 write 系统调用当中，我们给其 count 参数传入了一个特殊的参数 <code>len[buf]</code>，表示此处传入的值为参数 buf 的长度</p>
<p>在 sock_fprog 这个结构体当中，我们给其字段 len 设置的值为其 filter 字段的长度，类型为 int 16</p>
<p>若要表示父类的长度，可以使用 <code>len[parent, intN]</code>，若要在结构体互相嵌入时表示更顶层的父类的长度，可以指定特定父类的类型名称，下面是一个🌰：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">s1 &#123;</span><br><span class="line">    f0      len[s2]  # length of s2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s2 &#123;</span><br><span class="line">    f0      s1</span><br><span class="line">    f1      array[int32]</span><br><span class="line">    f2      len[parent, int32]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>len 也支持更加复杂的路径寻址，比如说如果你闲着没事干你可以写成谷歌给出的这个🌰里的样子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">s1 &#123;</span><br><span class="line">	a	ptr[in, s2]</span><br><span class="line">	b	ptr[in, s3]</span><br><span class="line">	c	array[int8]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s2 &#123;</span><br><span class="line">	d	array[int8]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s3 &#123;</span><br><span class="line"># This refers to the array c in the parent s1.</span><br><span class="line">	e	len[s1:c, int32]</span><br><span class="line"># This refers to the array d in the sibling s2.</span><br><span class="line">	f	len[s1:a:d, int32]</span><br><span class="line"># This refers to the array k in the child s4.</span><br><span class="line">	g	len[i:j, int32]</span><br><span class="line"># This refers to syscall argument l.</span><br><span class="line">	h	len[syscall:l, int32]</span><br><span class="line">	i	ptr[in, s4]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s4 &#123;</span><br><span class="line">	j	array[int8]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(k ptr[in, s1], l ptr[in, array[int8]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="X-进程（proc）"><a href="#X-进程（proc）" class="headerlink" title="X.进程（proc）"></a>X.进程（proc）</h3><p>进程 <code>proc</code> 类型可以用于表示分进程整型值，即为每一个执行程序设置一个单独的值的范围，这样他们之间就不会互相干扰，🌰如端口号就不能够被共享，而是需要每个进程有一个自己的端口</p>
<p>这里举一个简单的🌰， <code>proc[20000, 4, int16be]</code> 表示为每个进程生成一个大端序的 int16 的值，为每个进程分配其中的 4 个值，从 20000 开始分配，比如说第 N 个 executor 分配到的值范围便是 <code>[20000 + n * 4, 20000 + (n + 1) * 4)</code></p>
<h3 id="XI-整型常量（Integer-Constants）"><a href="#XI-整型常量（Integer-Constants）" class="headerlink" title="XI.整型常量（Integer Constants）"></a>XI.整型常量（Integer Constants）</h3><p>整型常量可以指定为十进制、<code>0x</code> 开头的十六进制、用单引号 <code>&#39;</code> 包裹的字符，或者从内核头文件中提取出来的由 <code>define</code> 定义的常量（比如说 <code>O_RDONLY</code>）</p>
<p>这是一个🌰：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">foo(a const[10], b const[-10])</span><br><span class="line">foo(a const[0xabcd])</span><br><span class="line">foo(a int8[&#x27;a&#x27;:&#x27;z&#x27;])</span><br><span class="line">foo(a const[PATH_MAX])</span><br><span class="line">foo(a ptr[in, array[int8, MY_PATH_MAX]])</span><br><span class="line">define MY_PATH_MAX	PATH_MAX + 2</span><br></pre></td></tr></table></figure>

<h3 id="XII-杂项（Misc）"><a href="#XII-杂项（Misc）" class="headerlink" title="XII.杂项（Misc）"></a>XII.杂项（Misc）</h3><p>描述文件还包括用以进行内核头文件包含的 <code>include</code> 指令，用以包含内核头文件目录的 <code>incdir</code> 指令，以及用以设置常量的 <code>define</code> 指令</p>
<p>syzkaller executor 还定义了一些 <a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/docs/pseudo_syscalls.md">pseudo system calls</a> ，我们可以在描述文件中使用这些伪系统调用。这些伪系统调用被扩展为 C 代码，可以执行用户自定义的一些操作，<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/executor/common_linux.h">这里</a>是一些🌰</p>
<p>要写出优秀的描述文件，<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/docs/syscall_descriptions.md#tips">这里</a>是一些 tips</p>
<h2 id="编写并使用描述文件"><a href="#编写并使用描述文件" class="headerlink" title="编写并使用描述文件"></a>编写并使用描述文件</h2><h3 id="Step-I-编写描述文件"><a href="#Step-I-编写描述文件" class="headerlink" title="Step I.编写描述文件"></a>Step I.编写描述文件</h3><p>我们需要在 syzkaller 目录下的 <code>syzkaller/sys/linux/</code> 这个目录下面新建我们自己的描述文件，比如说笔者新建一个 <code>a3_handsome.txt</code> 文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">include &lt;linux/fs.h&gt;</span><br><span class="line"></span><br><span class="line">resource a3fd[int64]</span><br><span class="line"></span><br><span class="line">open$a3proc(file ptr[in, string[&quot;/dev/tty&quot;]], flags flags[a3_open_flags]) a3fd</span><br><span class="line">read$a3proc(fd a3fd, buf ptr[in, array[int8]], count len[buf])</span><br><span class="line">write$a3proc(fd a3fd, buf ptr[in, array[int8]], count len[buf])</span><br><span class="line">close$a3proc(fd a3fd)</span><br><span class="line"></span><br><span class="line">a3_open_flags = O_WRONLY, O_RDWR, O_APPEND, FASYNC, O_CLOEXEC, O_CREAT, O_DIRECT, O_DIRECTORY, O_EXCL, O_LARGEFILE, O_NOATIME, O_NOCTTY, O_NOFOLLOW, O_NONBLOCK, O_PATH, O_SYNC, O_TRUNC, __O_TMPFILE</span><br></pre></td></tr></table></figure>

<blockquote>
<p>随便写的，没有任何的针对性设计</p>
</blockquote>
<p>在这里变种名为 <code>a3proc</code>，可以理解为笔者自己取的别名，这是因为若不同的描述文件中存在相同的系统调用则编译时会发生冲突</p>
<h3 id="Step-II-编译-syz-extract-与-syz-sysgen"><a href="#Step-II-编译-syz-extract-与-syz-sysgen" class="headerlink" title="Step II.编译 syz-extract 与 syz-sysgen"></a>Step II.编译 syz-extract 与 syz-sysgen</h3><p>接下来我们需要编译 <code>syz-extract</code> 与 <code>syz-sysgen</code>，从而应用我们新编写的描述文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make bin/syz-extract</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make bin/syz-sysgen	<span class="comment"># no need for syzkaller in new version</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>syz-extract 用以提取引入的内核头文件中的 define 常量等，生成 <code>.const</code> 文件</li>
<li>syz-sysgen 用以结合 <code>.txt</code> 文件与 <code>.const</code> 文件进行语法分析和语义分析生成 AST ，最后生成 <code>.go</code> 文件</li>
</ul>
<p>对于版本较新的 syzkaller ，其在编译时会默认编译 syz-sysgen，因此我们只需要手动编译 syz-extract 即可</p>
<h3 id="Step-III-处理新规则文件"><a href="#Step-III-处理新规则文件" class="headerlink" title="Step III.处理新规则文件"></a>Step III.处理新规则文件</h3><p>使用如下命令处理我们刚刚写的规则文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">bin/syz-extract -os linux -<span class="built_in">arch</span> <span class="variable">$ARCH</span> -sourcedir <span class="variable">$KSRC</span> -builddir <span class="variable">$LINUXBLD</span> &lt;new&gt;.txt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">bin/syz-sysgen	<span class="comment"># no need for syzkaller in new version</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>$ARCH</code> 应为你的目标架构，可选项有 <code>amd64</code>, <code>386</code> <code>arm64</code>, <code>arm</code>, <code>ppc64le</code>, <code>mips64le</code></li>
<li><code>$KSRC</code> 应为 fuzz 的内核的源码目录</li>
<li><code>$LINUXBLD</code> 应为你的编译目录，为可选项（-builddir）</li>
<li><code>&lt;new&gt;.txt</code> 就是你刚刚编写的规则文件的文件名</li>
</ul>
<p>会在 <code>syzkaller/sys/linux</code> 下生成 <code>.const</code> 文件提取出常量，在正式编译时会进行替换，例如笔者上面给出的例程生成的 <code>.const</code> 文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># Code generated by syz-sysgen. DO NOT EDIT.</span><br><span class="line">arches = amd64</span><br><span class="line">FASYNC = amd64:8192</span><br><span class="line">O_APPEND = amd64:1024</span><br><span class="line">O_CLOEXEC = amd64:524288</span><br><span class="line">O_CREAT = amd64:64</span><br><span class="line">O_DIRECT = amd64:16384</span><br><span class="line">O_DIRECTORY = amd64:65536</span><br><span class="line">O_EXCL = amd64:128</span><br><span class="line">O_LARGEFILE = amd64:32768</span><br><span class="line">O_NOATIME = amd64:262144</span><br><span class="line">O_NOCTTY = amd64:256</span><br><span class="line">O_NOFOLLOW = amd64:131072</span><br><span class="line">O_NONBLOCK = amd64:2048</span><br><span class="line">O_PATH = amd64:2097152</span><br><span class="line">O_RDWR = amd64:2</span><br><span class="line">O_SYNC = amd64:1052672</span><br><span class="line">O_TRUNC = amd64:512</span><br><span class="line">O_WRONLY = amd64:1</span><br><span class="line">__NR_open = amd64:2</span><br><span class="line">__NR_read = amd64:0</span><br><span class="line">__NR_write = amd64:1</span><br><span class="line">__O_TMPFILE = amd64:4194304</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Step-IV-重新编译-syzkaller"><a href="#Step-IV-重新编译-syzkaller" class="headerlink" title="Step IV.重新编译 syzkaller"></a>Step IV.重新编译 syzkaller</h3><p>命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make generate</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br></pre></td></tr></table></figure>

<h3 id="Step-V-修改配置文件，启动-syzkaller"><a href="#Step-V-修改配置文件，启动-syzkaller" class="headerlink" title="Step V.修改配置文件，启动 syzkaller"></a>Step V.修改配置文件，启动 syzkaller</h3><p>前面我们命名了 <code>a3proc</code> ，因此我们还需要在配置文件中进行 enable，在你的 <code>.cfg</code> 文件中添加这一项：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;enable_syscalls&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">	<span class="string">&quot;open$a3proc&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="string">&quot;read$a3proc&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="string">&quot;write$a3proc&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="string">&quot;close$a3proc&quot;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p>之后按惯例启动即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./bin/syz-manager -config=config.cfg</span></span><br></pre></td></tr></table></figure>

<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="*工作原理"></a><em>*工作原理</em></h2><p>当我们使用 syzlang 编写好模板之后，这些系统调用模板会通过 <strong>syz-extract</strong> 和 <strong>syz-sysgen</strong> 翻译为 syzkaller 能够读懂的代码，笔者这里简述一下其原理</p>
<blockquote>
<p>这里你可能需要一点编译原理的知识，不过笔者相信大家编译原理应当都及格了（笑）</p>
<blockquote>
<p><del>什么？你说你还没上这门课</del></p>
<blockquote>
<p><del>什么？用 syzkaller 挖洞只要会写 syzlang 就行了，根本不需要理解他的原理</del></p>
</blockquote>
</blockquote>
<p>简要而言，从源代码到可执行文件大概有如下过程：</p>
<ul>
<li>词法分析（lexical analysis）：扫描器（scanner，通常是一个有限状态自动机）从源码文本中逐字符读入，过滤掉注释，将词素映射为词法单元，生成符号表，建立映射，最终输出词素序列</li>
<li>语法分析（syntax analysis）：语法分析器从词法分析器中获取词素序列，构建树形的中间表示：通常是抽象语法树（abstract syntax tree），树形中间节点表示运算分量，最终输出被称之为词法单元流的语法树</li>
<li>语义分析（semantic analysis）：语义分析器使用语法树与符号表检查源程序的语义一致性，例如一个整数和一个字符串相加是符合语法规则的，但对于大部分语言而言这并不是一个合法的运算，因此不符合语义规则（<del>什么？你说你用 JavaScript</del>）</li>
<li><em>中间代码生成与优化：中间代码生成器通过语义分析的结果生成对应的中间代码（例如三地址码），并进行一定的优化</em></li>
<li><em>代码生成：由代码生成器将中间代码转为可执行代码</em></li>
</ul>
</blockquote>
<h3 id="syz-extract"><a href="#syz-extract" class="headerlink" title="syz-extract"></a>syz-extract</h3><p>第一步是从内核源文件中提取符号常量的值：<code>syz-extract</code> 会根据 syzlang 文件从内核源文件中提取出使用的对应的宏、系统调用号等的值，生成 <code>.const</code> 文件</p>
<h3 id="syz-sysgen"><a href="#syz-sysgen" class="headerlink" title="syz-sysgen"></a>syz-sysgen</h3><p>第二步便是将描述翻译成 Golang 代码：<code>syz-sysgen</code> 通过 syzlang 文件与 .const 文件进行语法分析与语义分析，生成抽象语法树，最终生成供 syzkaller 使用的 golang 代码，分为如下四个步骤：</p>
<ul>
<li><strong>assignSyscallNumbers</strong>：分配系统调用号，检测不支持的系统调用并丢弃</li>
<li><strong>patchConsts</strong>：将 AST 中的常量替换为对应的值</li>
<li><strong>check</strong>：进行语义分析</li>
<li><strong>genSyscalls</strong>：从 AST 生成 prog 对象</li>
</ul>
<h1 id="0x04-实战：用-syzkaller-挖掘出-CVE-20"><a href="#0x04-实战：用-syzkaller-挖掘出-CVE-20" class="headerlink" title="0x04.实战：用 syzkaller 挖掘出 CVE-20??-????"></a><del>0x04.实战：用 syzkaller 挖掘出 CVE-20??-????</del></h1><p><del>CVE-20??-???? 是由于 ?? 原因造成的内核空间中的 ??，笔者接下来将尝试使用 syzkaller 来挖掘出该漏洞</del></p>
<blockquote>
<p>🕊🕊🕊</p>
</blockquote>

      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
              <a href="/2021/10/31/CTF-0X05-TCTF2021_FINAL/" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>上一页</span>
              </a>
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">
              <i class="iconfont icon-updatetime" title="更新时间"></i>
              2021-11-24 03:09:11
            </span>
            
                  <span class="post-categories">
                    <i class="iconfont icon-bookmark" title="分类"></i>
                    
                    <span class="span--category">
                      <a href="/categories/FUZZ/" title="FUZZ">
                        <b>#</b> FUZZ
                      </a>
                    </span>
                    
                  </span>
              
                  <span class="post-tags">
                    <i class="iconfont icon-tags" title="标签"></i>
                    
                    <span class="span--tag">
                      <a href="/tags/Pwn/" title="Pwn">
                        <b>#</b> Pwn
                      </a>
                    </span>
                    
                    <span class="span--tag">
                      <a href="/tags/Linux/" title="Linux">
                        <b>#</b> Linux
                      </a>
                    </span>
                    
                    <span class="span--tag">
                      <a href="/tags/Linux-Kernel/" title="Linux Kernel">
                        <b>#</b> Linux Kernel
                      </a>
                    </span>
                    
                    <span class="span--tag">
                      <a href="/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/" title="漏洞挖掘">
                        <b>#</b> 漏洞挖掘
                      </a>
                    </span>
                    
                    <span class="span--tag">
                      <a href="/tags/syzkaller/" title="syzkaller">
                        <b>#</b> syzkaller
                      </a>
                    </span>
                    
                  </span>
              
          </div>
          <div class="post-foot-prev">
            
              <a href="/2021/11/28/OS-0X02-LINUX-KERNEL-MEMORY-5.11-PART-I/" target="_self">
                <span>下一页</span>
                <i class="iconfont icon-chevronright"></i>
              </a>
            
          </div>
        </div>
      
    </div>
    
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">目录</div>
    <div class="catalog-content">
      
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0x00-%E4%B8%80%E5%88%87%E5%BC%80%E5%A7%8B%E4%B9%8B%E5%89%8D"><span class="toc-text">0x00.一切开始之前</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x01-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="toc-text">0x01.环境配置</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96"><span class="toc-text">安装依赖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-golang-%E7%8E%AF%E5%A2%83"><span class="toc-text">配置 golang 环境</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91-syzkaller"><span class="toc-text">编译 syzkaller</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E7%9B%AE%E6%A0%87%E5%86%85%E6%A0%B8"><span class="toc-text">编译目标内核</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-ext4-%E7%A1%AC%E7%9B%98%E9%95%9C%E5%83%8F%E6%96%87%E4%BB%B6"><span class="toc-text">配置 ext4 硬盘镜像文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85-qemu"><span class="toc-text">安装 qemu</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x02-%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8-syzkaller"><span class="toc-text">0x02.开始使用 syzkaller</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#PRE-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">PRE.工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%88for-test%EF%BC%89"><span class="toc-text">配置文件（for test）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8-syzkaller"><span class="toc-text">启动 syzkaller</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%83%BD%E4%BC%9A%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">*可能会遇到的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8-vm-instance"><span class="toc-text">无法启动 vm instance</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E9%97%AE%E9%A2%98"><span class="toc-text">网络设备问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#crash-%E5%88%86%E6%9E%90"><span class="toc-text">crash 分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x03-%E4%BD%BF%E7%94%A8-syzlang-%E7%BC%96%E5%86%99%E6%8F%8F%E8%BF%B0%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C-fuzz"><span class="toc-text">0x03.使用 syzlang 编写描述文件进行 fuzz</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#syzlang-%E8%AF%AD%E6%B3%95"><span class="toc-text">syzlang 语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#O-%E6%B3%A8%E9%87%8A%E4%B8%8E%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB"><span class="toc-text">O.注释与文件包含</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-%E5%8F%82%E6%95%B0%EF%BC%88arg%EF%BC%89%E4%B8%8E%E5%8F%82%E6%95%B0%E5%90%8D%EF%BC%88argname%EF%BC%89"><span class="toc-text">I.参数（arg）与参数名（argname）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#example"><span class="toc-text">example</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#II-%E7%B1%BB%E5%9E%8B%EF%BC%88type%EF%BC%89"><span class="toc-text">II.类型（type）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%90%8D%EF%BC%88typename%EF%BC%89"><span class="toc-text">类型名（typename）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E-flags-%E7%9A%84%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E"><span class="toc-text">关于 flags 的补充说明</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E9%80%89%E9%A1%B9%EF%BC%88type-options%EF%BC%89"><span class="toc-text">类型选项（type-options）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#III-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%A8%A1%E6%9D%BF"><span class="toc-text">III.系统调用模板</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%BD%A2%E5%BC%8F"><span class="toc-text">基本形式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-text">返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#call-attributes"><span class="toc-text">call attributes</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E7%A7%8D%EF%BC%88variants%EF%BC%89"><span class="toc-text">变种（variants）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IV-%E6%95%B4%E5%9E%8B%EF%BC%88integer%EF%BC%89"><span class="toc-text">IV.整型（integer）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#V-%E7%BB%93%E6%9E%84%E4%BD%93%E3%80%81%E8%81%94%E5%90%88%E4%BD%93%E4%B8%8E%E5%85%B6%E6%88%90%E5%91%98%EF%BC%88%E5%AD%97%E6%AE%B5%EF%BC%89"><span class="toc-text">V.结构体、联合体与其成员（字段）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%88struct%EF%BC%89"><span class="toc-text">结构体（struct）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%94%E5%90%88%E4%BD%93%EF%BC%88union%EF%BC%89"><span class="toc-text">联合体（union）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VI-%E8%B5%84%E6%BA%90%EF%BC%88resources%EF%BC%89"><span class="toc-text">VI.资源（resources）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VII-%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%EF%BC%88Type-Alias%EF%BC%89"><span class="toc-text">VII.类型别名（Type Alias）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VIII-%E7%B1%BB%E5%9E%8B%E6%A8%A1%E6%9D%BF%EF%BC%88Type-Template%EF%BC%89"><span class="toc-text">VIII.类型模板（Type Template）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IX-%E9%95%BF%E5%BA%A6%EF%BC%88length%EF%BC%89"><span class="toc-text">IX.长度（length）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#example-1"><span class="toc-text">example</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#X-%E8%BF%9B%E7%A8%8B%EF%BC%88proc%EF%BC%89"><span class="toc-text">X.进程（proc）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XI-%E6%95%B4%E5%9E%8B%E5%B8%B8%E9%87%8F%EF%BC%88Integer-Constants%EF%BC%89"><span class="toc-text">XI.整型常量（Integer Constants）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XII-%E6%9D%82%E9%A1%B9%EF%BC%88Misc%EF%BC%89"><span class="toc-text">XII.杂项（Misc）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E5%B9%B6%E4%BD%BF%E7%94%A8%E6%8F%8F%E8%BF%B0%E6%96%87%E4%BB%B6"><span class="toc-text">编写并使用描述文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Step-I-%E7%BC%96%E5%86%99%E6%8F%8F%E8%BF%B0%E6%96%87%E4%BB%B6"><span class="toc-text">Step I.编写描述文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Step-II-%E7%BC%96%E8%AF%91-syz-extract-%E4%B8%8E-syz-sysgen"><span class="toc-text">Step II.编译 syz-extract 与 syz-sysgen</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Step-III-%E5%A4%84%E7%90%86%E6%96%B0%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6"><span class="toc-text">Step III.处理新规则文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Step-IV-%E9%87%8D%E6%96%B0%E7%BC%96%E8%AF%91-syzkaller"><span class="toc-text">Step IV.重新编译 syzkaller</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Step-V-%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%8C%E5%90%AF%E5%8A%A8-syzkaller"><span class="toc-text">Step V.修改配置文件，启动 syzkaller</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">*工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#syz-extract"><span class="toc-text">syz-extract</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#syz-sysgen"><span class="toc-text">syz-sysgen</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x04-%E5%AE%9E%E6%88%98%EF%BC%9A%E7%94%A8-syzkaller-%E6%8C%96%E6%8E%98%E5%87%BA-CVE-20"><span class="toc-text">0x04.实战：用 syzkaller 挖掘出 CVE-20??-????</span></a></li></ol>
      
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
      <div class="comments-container">
        




  
    <script async type="text/javascript" src="/plugins/valine.min.js" onload="loadValineSuc(this)"></script>
  

  <div id="vcomments"></div>

  <script>
    function loadValineSuc() {
      new Valine({
        el: '#vcomments',
        appId: 'ICj6cPRQWFTNiOttBHlzxnIv-gzGzoHsz',
        appKey: 'tuvJh3xYxPFcW2JB6K26RKP2',
        placeholder: '说点什么呗...',
        avatar: 'retro',
        lang: 'zh-CN'
      })
    }
  </script>

    <style>
      .comments-container .v .vempty {
        display: none!important;
      }
    </style>




      </div>
    
  </div>


        
<div class="footer">
  <div class="social">
    <ul>
      
        <li>
          <a title="github" target="_blank" rel="noopener" href="https://github.com/arttnba3">
            <i class="iconfont icon-github"></i>
          </a>
        </li>
      
        <li>
          <a title="email" href="mailto:arttnba@gmail.com">
            <i class="iconfont icon-envelope"></i>
          </a>
        </li>
      
        <li>
          <a title="twitter" target="_blank" rel="noopener" href="https://twitter.com/arttnba3">
            <i class="iconfont icon-twitter"></i>
          </a>
        </li>
      
        <li>
          <a title="rss" href="/atom.xml">
            <i class="iconfont icon-rss"></i>
          </a>
        </li>
      
    </ul>
  </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/arttnba3">Copyright © 2022 arttnba3</a>
        
    </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Theme by Oranges | Powered by Hexo</a>
        
    </div>
  
</div>

      </div>

      <div class="tools-bar">
        <div class="back-to-top tools-bar-item hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



        
  <div class="search-icon tools-bar-item" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-title">
        <span class="search-icon-input">
          <a href="javascript: void(0)">
            <i class="iconfont icon-search"></i>
          </a>
        </span>
        
          <input type="text" class="search-input" id="search-input" placeholder="搜索...">
        
        <span class="search-close-icon" id="search-close-icon">
          <a href="javascript: void(0)">
            <i class="iconfont icon-close"></i>
          </a>
        </span>
      </div>
      <div class="search-result" id="search-result"></div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    inputArea.onclick = function() {
      getSearchFile()
      this.onclick = null
    }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        // inputArea.focus()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'>首次搜索，正在载入索引文件，请稍后……<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + orig_data_title + "</a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<p class=\"search-result-abstract\">" + match_content + "...</p>"
                }
                str += "</li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>没有找到内容，请尝试更换检索词。<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>未找到search.xml文件，具体请参考：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>请求失败，尝试重新刷新页面或稍后重试。<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




        
  <div class="tools-bar-item theme-icon" id="switch-color-scheme">
    <a href="javascript: void(0)">
      <i id="theme-icon" class="iconfont icon-moon"></i>
    </a>
  </div>

  
<script src="/js/colorscheme.js"></script>





        
  
    <div class="share-icon tools-bar-item">
      <a href="javascript: void(0)" id="share-icon">
        <i class="iconfont iconshare"></i>
      </a>
      <div class="share-content hidden">
        
          <a class="share-item" href="https://twitter.com/intent/tweet?text=' + %E3%80%90FUZZ.0x01%E3%80%91syzkaller%20-%20I%EF%BC%9A%E4%BD%BF%E7%94%A8%20syzkaller%20%E8%BF%9B%E8%A1%8C%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98 + '&url=' + http%3A%2F%2Fblog.arttnba3.cn%2F2021%2F11%2F24%2FFUZZ-0X01-SYZKALLER-I%2F + '" target="_blank" title="Twitter">
            <i class="iconfont icon-twitter"></i>
          </a>
        
        
          <a class="share-item" href="https://www.facebook.com/sharer.php?u=http://blog.arttnba3.cn/2021/11/24/FUZZ-0X01-SYZKALLER-I/" target="_blank" title="Facebook">
            <i class="iconfont icon-facebooksquare"></i>
          </a>
        
      </div>
    </div>
  
  
<script src="/js/shares.js"></script>



      </div>
    </div>
  </body>
</html>
