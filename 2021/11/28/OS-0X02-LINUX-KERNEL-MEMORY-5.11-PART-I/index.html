<!DOCTYPE html>
<html lang="zh-CN" color-mode="light">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="keywords" content="" />
  <meta name="author" content="arttnba3" />
  <meta name="description" content="あがいた夢を捨てて揺れる今日は眠って誤魔化せ" />
  
  
  <title>
    
      【OS.0x02】Linux Kernel 内存管理浅析 I - 页、区、节点 
      
      
      |
    
     arttnba3&#39;s blog
  </title>

  
    <link rel="apple-touch-icon" href="/img/favicon.png">
    <link rel="icon" href="/img/favicon.png">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  
<link rel="stylesheet" href="/css/color-scheme.css">
<link rel="stylesheet" href="/css/base.css">
<link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css">
<link rel="stylesheet" href="/css/github-markdown.css">
<link rel="stylesheet" href="/css/highlight.css">
<link rel="stylesheet" href="/css/comments.css">

  <!-- 代码块风格 -->
  

  <!-- jquery3.3.1 -->
  
    <script defer type="text/javascript" src="/plugins/jquery.min.js"></script>
  

  <!-- fancybox -->
  
    <link href="/plugins/jquery.fancybox.min.css" rel="stylesheet">
    <script defer type="text/javascript" src="/plugins/jquery.fancybox.min.js"></script>
  
  
<script src="/js/fancybox.js"></script>


  

  <script>
    var html = document.documentElement
    const colorMode = localStorage.getItem('color-mode')
    if (colorMode) {
      document.documentElement.setAttribute('color-mode', colorMode)
    }
  </script>
<meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="arttnba3's blog" type="application/atom+xml">
</head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a target="_blank" rel="noopener" href="https://arttnba3.cn">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img src="/img/avatar.png" alt="">
      
    </a>
    <div class="nickname"><a target="_blank" rel="noopener" href="https://arttnba3.cn">arttnba3's blog</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">Home</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">Archives</a>
        </li>
      
        <li class="nav-item" data-path="/categories/">
          <a href="/categories/">Categories</a>
        </li>
      
        <li class="nav-item" data-path="/tags/">
          <a href="/tags/">Tags</a>
        </li>
      
        <li class="nav-item" data-path="/friends/">
          <a href="/friends/">Friends</a>
        </li>
      
        <li class="nav-item" data-path="/about/">
          <a href="/about/">About</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->


  <!-- LaTex Display -->

  
    <script async type="text/javascript" src="/plugins/mathjax/tex-chtml.js"></script>
  
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    }
  </script>





  <!-- clipboard -->

  
    <script async type="text/javascript" src="/plugins/clipboard.min.js"></script>
  
  
<script src="/js/codeCopy.js"></script>







  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">【OS.0x02】Linux Kernel 内存管理浅析 I - 页、区、节点</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime" title="更新时间"></i>
          2021-11-28 02:45:29
        </span>
        
              <span class="post-categories">
                <i class="iconfont icon-bookmark" title="分类"></i>
                
                <span class="span--category">
                  <a href="/categories/OS/" title="OS">
                    <b>#</b> OS
                  </a>
                </span>
                
              </span>
          
              <span class="post-tags">
                <i class="iconfont icon-tags" title="标签"></i>
                
                <span class="span--tag">
                  <a href="/tags/Linux/" title="Linux">
                    <b>#</b> Linux
                  </a>
                </span>
                
                <span class="span--tag">
                  <a href="/tags/%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0/" title="学习札记">
                    <b>#</b> 学习札记
                  </a>
                </span>
                
                <span class="span--tag">
                  <a href="/tags/Linux-Kernel/" title="Linux Kernel">
                    <b>#</b> Linux Kernel
                  </a>
                </span>
                
                <span class="span--tag">
                  <a href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" title="内存管理">
                    <b>#</b> 内存管理
                  </a>
                </span>
                
              </span>
          
      </div>
      <div class="markdown-body">
        <p>无内鬼，来点内存条</p>
<span id="more"></span>

<h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><p>本系列文章将通过 Linux 5.11 的源代码简要分析 Linux 内核中的<strong>内存管理</strong>（memory management）部分，笔者选择采用自底向上的方式来逐层分析，本篇文章便从最基础的<strong>页框</strong>开始进行分析</p>
<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>这是一张十分经典的 _Overview_，自顶向下是</p>
<ul>
<li><strong>节点</strong>（node，对应结构体 pgdata_list）</li>
<li><strong>区</strong>（zone，对应结构体 zone，图上展示了三种类型的 zone）</li>
<li><strong>页</strong>（page，对应结构体 page）</li>
</ul>
<p><img src="https://i.loli.net/2021/11/28/OrsvS6GTMgPLx5E.png" alt="image.png"></p>
<p>我们可以通过 <code>cat /proc/buddyinfo</code> 与 <code>cat /proc/pagetypeinfo</code> 查看页面相关信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">arttnba3@ubuntu:~$ sudo cat /proc/buddyinfo </span><br><span class="line">Node 0, zone      DMA      0      1      1      0      2      1      1      0      1      2      2 </span><br><span class="line">Node 0, zone    DMA32   8706   1386    748    543    232     48     39      9      0      0      0 </span><br><span class="line">Node 0, zone   Normal  15391   3317    877    826    221     77     14      2      0      0      0 </span><br><span class="line">arttnba3@ubuntu:~$ sudo cat /proc/pagetypeinfo </span><br><span class="line">Page block order: 9</span><br><span class="line">Pages per block:  512</span><br><span class="line"></span><br><span class="line">Free pages count per migrate type at order       0      1      2      3      4      5      6      7      8      9     10 </span><br><span class="line">Node    0, zone      DMA, type    Unmovable      0      1      1      0      2      1      1      0      1      1      0 </span><br><span class="line">Node    0, zone      DMA, type      Movable      0      0      0      0      0      0      0      0      0      1      2 </span><br><span class="line">Node    0, zone      DMA, type  Reclaimable      0      0      0      0      0      0      0      0      0      0      0 </span><br><span class="line">Node    0, zone      DMA, type   HighAtomic      0      0      0      0      0      0      0      0      0      0      0 </span><br><span class="line">Node    0, zone      DMA, type      Isolate      0      0      0      0      0      0      0      0      0      0      0 </span><br><span class="line">Node    0, zone    DMA32, type    Unmovable    254    166     54     33     18      8     11      1      0      0      0 </span><br><span class="line">Node    0, zone    DMA32, type      Movable   6762    740    535    278     43      3      3      2      0      0      0 </span><br><span class="line">Node    0, zone    DMA32, type  Reclaimable   1690    480    159    232    171     37     25      6      0      0      0 </span><br><span class="line">Node    0, zone    DMA32, type   HighAtomic      0      0      0      0      0      0      0      0      0      0      0 </span><br><span class="line">Node    0, zone    DMA32, type      Isolate      0      0      0      0      0      0      0      0      0      0      0 </span><br><span class="line">Node    0, zone   Normal, type    Unmovable     27     30     15      0      1      4      4      2      0      0      0 </span><br><span class="line">Node    0, zone   Normal, type      Movable  12963   3039    806    727    197     68     10      0      0      0      0 </span><br><span class="line">Node    0, zone   Normal, type  Reclaimable   1135    251     56     99     23      5      0      0      0      0      0 </span><br><span class="line">Node    0, zone   Normal, type   HighAtomic      0      0      0      0      0      0      0      0      0      0      0 </span><br><span class="line">Node    0, zone   Normal, type      Isolate      0      0      0      0      0      0      0      0      0      0      0 </span><br><span class="line"></span><br><span class="line">Number of blocks type     Unmovable      Movable  Reclaimable   HighAtomic      Isolate </span><br><span class="line">Node 0, zone      DMA            3            5            0            0            0 </span><br><span class="line">Node 0, zone    DMA32           60         1382           86            0            0 </span><br><span class="line">Node 0, zone   Normal          245         4270           93            0            0</span><br></pre></td></tr></table></figure>

<h1 id="0x01-struct-page：页"><a href="#0x01-struct-page：页" class="headerlink" title="0x01.struct page：页"></a>0x01.struct page：页</h1><p>Linux kernel 中使用 <code>page</code> 结构体来表示一个物理页框，<strong>每个物理页框都有着一个对应的 page 结构体</strong>，为了节省内存空间，其定义中使用了大量的联合体</p>
<p>一个 page 结构体的大小为 64B，若是每个物理页框大小为 4KB，则仅需要牺牲 <code>1.5625%</code> 的空间存储 page 结构体</p>
<p>在这里给出一张 struct page 的overview</p>
<blockquote>
<p>网上找的图，侵删</p>
</blockquote>
<p><img src="https://i.loli.net/2021/11/25/MjWZmba9SLH1xIO.png" alt="image.png"></p>
<p>该结构体定义于内核源码 <code>include/linux/mm_types.h</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> &#123;</span></span><br><span class="line">    <span class="comment">// flags 用以存储该 page 的标志位，每一个位表示一种状态，故一张页可以有 32 种状态，这些状态定义于 include/linux/page-flags.h 中</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;        <span class="comment">/* 原子变量 flag，也可能被异步更新 */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 该联合体中 5 个 word（32 位系统20字节/64位系统40字节）是可用的</span></span><br><span class="line"><span class="comment">     * 警告：第一个 word 的 0 bit 供 PageTail()使用</span></span><br><span class="line"><span class="comment">     * 这意味着其他用户使用该结构体时【禁止】使用该 bit</span></span><br><span class="line"><span class="comment">     * 以避免碰撞和误判 PageTail().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span>    <span class="comment">/* 页缓存与匿名页 */</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * @lru: Pageout 链表, 例如 active_list 便由</span></span><br><span class="line"><span class="comment">             * lruvec-&gt;lru_lock 保护。  </span></span><br><span class="line"><span class="comment">             * 有时会被页所有者作为常规链表使用。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lru</span>;</span></span><br><span class="line">            <span class="comment">/* See page-flags.h for PAGE_MAPPING_FLAGS */</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span>;</span></span><br><span class="line">            <span class="type">pgoff_t</span> index;        <span class="comment">/* 在映射的虚拟空间（vma_area）内的偏移 */</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * @private: 私有映射的非透明数据</span></span><br><span class="line"><span class="comment">             * 在 PagePrivate 中通常用于 buffer_heads.</span></span><br><span class="line"><span class="comment">             * 在 PageSwapCache 中用于 swp_entry_t</span></span><br><span class="line"><span class="comment">             * 在 PageBuddy 中指定在 buddy system 中的次序</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> private;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span>    <span class="comment">/* page_pool used by netstack */</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * @dma_addr: 在 32 位机器上仍可能需要 64 位的空间</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">dma_addr_t</span> dma_addr;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span>    <span class="comment">/* 供 slab, slob and slub 使用 */</span></span><br><span class="line">            <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slab_list</span>;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> &#123;</span>    <span class="comment">/* Partial pages */</span></span><br><span class="line">                    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_64BIT</span></span><br><span class="line">                    <span class="type">int</span> pages;    <span class="comment">/* 剩余的页数量 */</span></span><br><span class="line">                    <span class="type">int</span> pobjects;    <span class="comment">/* 近似计数 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">                    <span class="type">short</span> <span class="type">int</span> pages;</span><br><span class="line">                    <span class="type">short</span> <span class="type">int</span> pobjects;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab_cache</span>;</span> <span class="comment">/* 不在 slob 中使用 */</span></span><br><span class="line">            <span class="comment">/* 两个 word 的范围 */</span></span><br><span class="line">            <span class="type">void</span> *freelist;        <span class="comment">/* 第一个空闲对象 */</span></span><br><span class="line">            <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">                <span class="type">void</span> *s_mem;    <span class="comment">/* slab: first object */</span></span><br><span class="line">                <span class="type">unsigned</span> <span class="type">long</span> counters;        <span class="comment">/* SLUB */</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> &#123;</span>            <span class="comment">/* SLUB */</span></span><br><span class="line">                    <span class="type">unsigned</span> inuse:<span class="number">16</span>;</span><br><span class="line">                    <span class="type">unsigned</span> objects:<span class="number">15</span>;</span><br><span class="line">                    <span class="type">unsigned</span> frozen:<span class="number">1</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span>    <span class="comment">/* 复合页的尾页 */</span></span><br><span class="line">            <span class="comment">// 复合页 （compound page）即为将多个物理连续页框视作一个大页</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> compound_head;    <span class="comment">/* Bit zero is set */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* First tail page only */</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span> compound_dtor;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span> compound_order;</span><br><span class="line">            <span class="type">atomic_t</span> compound_mapcount;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> compound_nr; <span class="comment">/* 1 &lt;&lt; compound_order */</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span>    <span class="comment">/* Second tail page of compound page */</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> _compound_pad_1;    <span class="comment">/* compound_head */</span></span><br><span class="line">            <span class="type">atomic_t</span> hpage_pinned_refcount;</span><br><span class="line">            <span class="comment">/* For both global and memcg */</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">deferred_list</span>;</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span>    <span class="comment">/* 页表页面 */</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> _pt_pad_1;    <span class="comment">/* compound_head */</span></span><br><span class="line">            <span class="type">pgtable_t</span> pmd_huge_pte; <span class="comment">/* protected by page-&gt;ptl */</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> _pt_pad_2;    <span class="comment">/* mapping */</span></span><br><span class="line">            <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">pt_mm</span>;</span> <span class="comment">/* 用于 x86 的全局目录表（pgd） */</span></span><br><span class="line">                <span class="type">atomic_t</span> pt_frag_refcount; <span class="comment">/* 用于 powerpc 架构 */</span></span><br><span class="line">            &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ALLOC_SPLIT_PTLOCKS</span></span><br><span class="line">            <span class="type">spinlock_t</span> *ptl;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">            <span class="type">spinlock_t</span> ptl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span>    <span class="comment">/* ZONE_DEVICE pages */</span></span><br><span class="line">            <span class="comment">/** @pgmap: Points to the hosting device page map. */</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">dev_pagemap</span> *<span class="title">pgmap</span>;</span></span><br><span class="line">            <span class="type">void</span> *zone_device_data;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * ZONE_DEVICE private pages are counted as being</span></span><br><span class="line"><span class="comment">             * mapped so the next 3 words hold the mapping, index,</span></span><br><span class="line"><span class="comment">             * and private fields from the source anonymous or</span></span><br><span class="line"><span class="comment">             * page cache page while the page is migrated to device</span></span><br><span class="line"><span class="comment">             * private memory.</span></span><br><span class="line"><span class="comment">             * ZONE_DEVICE MEMORY_DEVICE_FS_DAX pages also</span></span><br><span class="line"><span class="comment">             * use the mapping, index, and private fields when</span></span><br><span class="line"><span class="comment">             * pmem backed DAX files are mapped.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** @rcu_head: 你可以通过该成员以通过 RCU 释放内存页 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu_head</span>;</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span>        <span class="comment">/* 这个联合体占用四个字节 */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 若是这个页被映射到用户空间, 记录该页被页表引用的次数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 每个进程有其独立的页表，故可以理解为该值记录了该页被多少个进程共享，初始值为 -1</span></span><br><span class="line">        <span class="type">atomic_t</span> _mapcount;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 若是该页既不是 PageSlab 也没有被映射到用户空间，</span></span><br><span class="line"><span class="comment">         * 则该值会帮助决定该页的作用。</span></span><br><span class="line"><span class="comment">         * 该处的页面类型列表参见 page-flags.h</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> page_type;</span><br><span class="line"></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> active;        <span class="comment">/* SLAB */</span></span><br><span class="line">        <span class="type">int</span> units;            <span class="comment">/* SLOB */</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 使用计数. 【不要直接使用】. 参见 page_ref.h */</span></span><br><span class="line">    <span class="type">atomic_t</span> _refcount;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMCG</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> memcg_data;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 当机器上的所有内存都被映射到内核空间时,</span></span><br><span class="line"><span class="comment">     * 我们可以简单地计算其虚拟地址。</span></span><br><span class="line"><span class="comment">     * 在有着【高端内存（大于896MB）】的机器上，有的内存被动态地映射到内核</span></span><br><span class="line"><span class="comment">     * 虚拟空间中，因此我们需要一个地方来存储这个地址</span></span><br><span class="line"><span class="comment">     * 在 x86 机器上这个域可能占 16 bit 的空间 ... ;)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 乘法计算较慢的架构可以在 asm/page.h 中定义 WANT_PAGE_VIRTUAL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(WANT_PAGE_VIRTUAL)</span></span><br><span class="line">    <span class="type">void</span> *virtual;            <span class="comment">/* 内核虚拟地址 (若非 kmapped 则为 NULL, 即高端内存) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* WANT_PAGE_VIRTUAL */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LAST_CPUPID_NOT_IN_PAGE_FLAGS</span></span><br><span class="line">    <span class="type">int</span> _last_cpupid;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; _struct_page_alignment;</span><br></pre></td></tr></table></figure>

<h2 id="I-几个比较重要的字段"><a href="#I-几个比较重要的字段" class="headerlink" title="I.几个比较重要的字段"></a>I.几个比较重要的字段</h2><p>简单讲讲其中几个重要的成员</p>
<h3 id="lru：LRU-链表节点"><a href="#lru：LRU-链表节点" class="headerlink" title="lru：LRU 链表节点"></a>lru：LRU 链表节点</h3><p>lru 即 <code>Least Recently Used</code>，在操作系统课程上我们已经学习了这个页面置换算法的概念，这里不再过多赘叙</p>
<p>在 Linux 内核中，page 结构体通过其 lru 字段组织成链表，如下图所示</p>
<p><img src="https://i.loli.net/2021/11/25/QbuxcXTWdzMari5.png" alt="image.png"></p>
<p>lru 成员是一个 <code>struct list_head</code> 类型，这是内核中通用的双向链表节点结构</p>
<h3 id="slab相关结构体"><a href="#slab相关结构体" class="headerlink" title="**slab相关结构体**"></a>**slab相关结构体**</h3><p>在 page 结构体中专门有着一个匿名结构体用于存放与 slab 相关的成员</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span>    <span class="comment">/* 供 slab, slob and slub 使用 */</span></span><br><span class="line">            <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slab_list</span>;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> &#123;</span>    <span class="comment">/* Partial pages */</span></span><br><span class="line">                    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_64BIT</span></span><br><span class="line">                    <span class="type">int</span> pages;    <span class="comment">/* 剩余的页数量 */</span></span><br><span class="line">                    <span class="type">int</span> pobjects;    <span class="comment">/* 近似计数 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">                    <span class="type">short</span> <span class="type">int</span> pages;</span><br><span class="line">                    <span class="type">short</span> <span class="type">int</span> pobjects;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab_cache</span>;</span> <span class="comment">/* 不在 slob 中使用 */</span></span><br><span class="line">            <span class="comment">/* 两个 word 的范围 */</span></span><br><span class="line">            <span class="type">void</span> *freelist;        <span class="comment">/* 第一个空闲对象 */</span></span><br><span class="line">            <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">                <span class="type">void</span> *s_mem;    <span class="comment">/* slab: first object */</span></span><br><span class="line">                <span class="type">unsigned</span> <span class="type">long</span> counters;        <span class="comment">/* SLUB */</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> &#123;</span>            <span class="comment">/* SLUB */</span></span><br><span class="line">                    <span class="type">unsigned</span> inuse:<span class="number">16</span>;</span><br><span class="line">                    <span class="type">unsigned</span> objects:<span class="number">15</span>;</span><br><span class="line">                    <span class="type">unsigned</span> frozen:<span class="number">1</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>

<p>Linux kernel 中的 slab allocator 一共有三种：slab、slob、slub，其中比较常用的是 slub 分配器，关于 slab allocator 将在后续的文章中进行更为详细的叙述，下图是一张 slub 分配器的 overview</p>
<p><img src="https://i.loli.net/2021/07/22/ivPnbsjHyI94m5z.png" alt="image.png"></p>
<h3 id="flags：标志位"><a href="#flags：标志位" class="headerlink" title="flags：标志位"></a>flags：标志位</h3><p>即该页的标志位成员，用以表示该页所处在的状态，每一个位表示一种状态，故一张页可以有 32 种不同的状态，这些状态定义于 <code>include/linux/page-flags.h</code> 中，<strong>该字段与体系无关</strong></p>
<p>我们可以通过该头文件中定义的枚举类型获取相应的值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">pageflags</span> &#123;</span></span><br><span class="line">    PG_locked,        <span class="comment">/* Page is locked. Don&#x27;t touch. */</span></span><br><span class="line">    PG_referenced,</span><br><span class="line">    PG_uptodate,</span><br><span class="line">    PG_dirty,</span><br><span class="line">    PG_lru,</span><br><span class="line">    PG_active,</span><br><span class="line">    PG_workingset,</span><br><span class="line">    PG_waiters,        <span class="comment">/* Page has waiters, check its waitqueue. Must be bit #7 and in the same byte as &quot;PG_locked&quot; */</span></span><br><span class="line">    PG_error,</span><br><span class="line">    PG_slab,</span><br><span class="line">    PG_owner_priv_1,    <span class="comment">/* Owner use. If pagecache, fs may use*/</span></span><br><span class="line">    PG_arch_1,</span><br><span class="line">    PG_reserved,</span><br><span class="line">    PG_private,        <span class="comment">/* If pagecache, has fs-private data */</span></span><br><span class="line">    PG_private_2,        <span class="comment">/* If pagecache, has fs aux data */</span></span><br><span class="line">    PG_writeback,        <span class="comment">/* Page is under writeback */</span></span><br><span class="line">    PG_head,        <span class="comment">/* A head page */</span></span><br><span class="line">    PG_mappedtodisk,    <span class="comment">/* Has blocks allocated on-disk */</span></span><br><span class="line">    PG_reclaim,        <span class="comment">/* To be reclaimed asap */</span></span><br><span class="line">    PG_swapbacked,        <span class="comment">/* Page is backed by RAM/swap */</span></span><br><span class="line">    PG_unevictable,        <span class="comment">/* Page is &quot;unevictable&quot;  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MMU</span></span><br><span class="line">    PG_mlocked,        <span class="comment">/* Page is vma mlocked */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARCH_USES_PG_UNCACHED</span></span><br><span class="line">    PG_uncached,        <span class="comment">/* Page has been mapped as uncached */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMORY_FAILURE</span></span><br><span class="line">    PG_hwpoison,        <span class="comment">/* hardware poisoned page. Don&#x27;t touch */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_IDLE_PAGE_TRACKING) &amp;&amp; defined(CONFIG_64BIT)</span></span><br><span class="line">    PG_young,</span><br><span class="line">    PG_idle,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_64BIT</span></span><br><span class="line">    PG_arch_2,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    __NR_PAGEFLAGS,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Filesystems */</span></span><br><span class="line">    PG_checked = PG_owner_priv_1,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* SwapBacked */</span></span><br><span class="line">    PG_swapcache = PG_owner_priv_1,    <span class="comment">/* Swap page: swp_entry_t in private */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Two page bits are conscripted by FS-Cache to maintain local caching</span></span><br><span class="line"><span class="comment">     * state.  These bits are set on pages belonging to the netfs&#x27;s inodes</span></span><br><span class="line"><span class="comment">     * when those inodes are being locally cached.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PG_fscache = PG_private_2,    <span class="comment">/* page backed by cache */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* XEN */</span></span><br><span class="line">    <span class="comment">/* Pinned in Xen as a read-only pagetable page. */</span></span><br><span class="line">    PG_pinned = PG_owner_priv_1,</span><br><span class="line">    <span class="comment">/* Pinned as part of domain save (see xen_mm_pin_all()). */</span></span><br><span class="line">    PG_savepinned = PG_dirty,</span><br><span class="line">    <span class="comment">/* Has a grant mapping of another (foreign) domain&#x27;s page. */</span></span><br><span class="line">    PG_foreign = PG_owner_priv_1,</span><br><span class="line">    <span class="comment">/* Remapped by swiotlb-xen. */</span></span><br><span class="line">    PG_xen_remapped = PG_owner_priv_1,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* SLOB */</span></span><br><span class="line">    PG_slob_free = PG_private,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Compound pages. Stored in first tail page&#x27;s flags */</span></span><br><span class="line">    PG_double_map = PG_workingset,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* non-lru isolated movable page */</span></span><br><span class="line">    PG_isolated = PG_reclaim,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Only valid for buddy pages. Used to track pages that are reported */</span></span><br><span class="line">    PG_reported = PG_uptodate,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>PG_locked</code>：该页已被上锁，说明此时该页正在被使用</li>
<li><code>PG_referenced</code>：该页刚刚被访问过；该标志位与 PG_reclaim 标志位共同被用于匿名与文件备份缓存的页面回收</li>
<li><code>PG_uptodate</code>：该页处在最新状态（up-to-date）；当对该页完成一次读取时，该页便变更为 up-to-date 状态，除非发生了磁盘 IO 错误</li>
<li><code>PG_dirty</code>：该页为<strong>脏页</strong>，即该页的内容已被修改，应当尽快将内容写回磁盘上</li>
<li><code>PG_lru</code>：该页处在一个 LRU 链表上</li>
<li><code>PG_active</code>：该页面位于活跃 lru 链表中</li>
<li><code>PG_workingset</code>：该页位于某个进程的 working set（工作集，即一个进程同时使用的内存数量，例如一个进程可能分配了114514MB内存，但是在同一时刻只使用其中的1919MB，这就是工作集）中</li>
<li><code>PG_waiters</code>：有进程在等待该页面</li>
<li><code>PG_error</code>：该页在 I&#x2F;O 过程中出现了差错</li>
<li><code>PG_slab</code>：该页由 slab 使用</li>
<li><code>PG_owner_priv_1</code>：该页由其所有者使用，若是作为 pagecache 页面，则可能是被文件系统使用</li>
<li><code>PG_arch_1</code>：该标志位与体系结构相关联</li>
<li><code>PG_reserved</code>：该页被保留，不能够被 swap out（内核会将不活跃的页交换到磁盘上）</li>
<li><code>PG_private</code> &amp;&amp; <code>PG_private2</code>：该页拥有私有数据（private 字段）</li>
<li><code>PG_writeback</code>：该页正在被写到磁盘上</li>
<li><code>PG_head</code>：在内核中有时需要将多个页组成一个 compound pages，而设置该状态时表明该页是 compound pages 的第一个页</li>
<li><code>PG_mappedtodisk</code>：该页被映射到硬盘中</li>
<li><code>PG_reclaim</code>：该页可以被回收</li>
<li><code>PG_swapbacked</code>：该页的后备存储器为 swap&#x2F;RAM</li>
<li><code>PG_unevictable</code>：该页不可被回收（被锁），且会出现在 <code>LRU_UNEVICTABLE</code> 链表中</li>
<li><code>PG_mlocked</code>：该页被对应的 vma 上锁（通常是系统调用 mlock）</li>
<li><code>PG_uncached</code>：该页被设置为不可缓存</li>
<li><code>PG_hwpoison</code>：硬件相关的标志位</li>
<li><code>PG_young</code>：</li>
<li><code>PG_idle</code>：</li>
<li><code>PG_arch_2</code>：64位下的体系结构相关标志位</li>
</ul>
<h4 id="flags-内存复用"><a href="#flags-内存复用" class="headerlink" title="flags 内存复用"></a>flags 内存复用</h4><p>为了节省空间，flags 字段除了用作标志位外还给其他结构使用，其划分的形式其实与内核配置的内存模型有关，在 <code>include\linux\page-flags-layout.h</code>  文件中描述了五种划分形式（其实是三大种）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * page-&gt;flags layout:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * There are five possibilities for how page-&gt;flags get laid out.  The first</span></span><br><span class="line"><span class="comment"> * pair is for the normal case without sparsemem. The second pair is for</span></span><br><span class="line"><span class="comment"> * sparsemem when there is plenty of space for node and section information.</span></span><br><span class="line"><span class="comment"> * The last is when there is insufficient space in page-&gt;flags and a separate</span></span><br><span class="line"><span class="comment"> * lookup is necessary.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * No sparsemem or sparsemem vmemmap: |       NODE     | ZONE |             ... | FLAGS |</span></span><br><span class="line"><span class="comment"> *      &quot; plus space for last_cpupid: |       NODE     | ZONE | LAST_CPUPID ... | FLAGS |</span></span><br><span class="line"><span class="comment"> * classic sparse with space for node:| SECTION | NODE | ZONE |             ... | FLAGS |</span></span><br><span class="line"><span class="comment"> *      &quot; plus space for last_cpupid: | SECTION | NODE | ZONE | LAST_CPUPID ... | FLAGS |</span></span><br><span class="line"><span class="comment"> * classic sparse no space for node:  | SECTION |     ZONE    | ... | FLAGS |</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h5 id="非-sparse-内存模式-x2F-sparse-vmemmap-内存模式"><a href="#非-sparse-内存模式-x2F-sparse-vmemmap-内存模式" class="headerlink" title="非 sparse 内存模式 &#x2F; sparse vmemmap 内存模式"></a>非 sparse 内存模式 &#x2F; sparse vmemmap 内存模式</h5><p>如下图所示，低位用作该 page 的 flag，高位分别标识其归属的 zone， node id（非 NUMA 系统中为0），中间剩余的位保留</p>
<p><img src="https://i.loli.net/2021/11/25/8J9pm3n1eZuTKi6.png" alt="image.png"></p>
<p>这种形式中若是开启了 <code>last_cpuid</code> 则是下面这个样子：</p>
<p><img src="https://i.loli.net/2021/11/25/xhNpH3vkmli8EXt.png" alt="image.png"></p>
<h5 id="sparse-内存模式"><a href="#sparse-内存模式" class="headerlink" title="sparse 内存模式"></a>sparse 内存模式</h5><p>如下图所示，相比起第一种形式多了一个 SECTION 字段标识其归属的 <code>mem_section</code></p>
<p><img src="https://i.loli.net/2021/11/25/CETbQSKwV8er5OR.png" alt="image.png"></p>
<p>若是开启了 <code>last_cpuid</code> 则是下面这个样子</p>
<p><img src="https://i.loli.net/2021/11/25/KDSHvF4LjOXpIcE.png" alt="image.png"></p>
<h5 id="没有-Node-的-sparse-内存模式"><a href="#没有-Node-的-sparse-内存模式" class="headerlink" title="没有 Node 的 sparse 内存模式"></a>没有 Node 的 sparse 内存模式</h5><p>主要是针对非 NUMA 设计的，在这种模式下取消了 Node 结构</p>
<p><img src="https://i.loli.net/2021/11/25/QiJChHBdvARktOs.png" alt="image.png"></p>
<h3 id="mapcount：映射计数"><a href="#mapcount：映射计数" class="headerlink" title="_mapcount：映射计数"></a>_mapcount：映射计数</h3><p>记录该页被页表映射的次数，每个进程有其独立的页表，故可以理解为该值记录了该页被多少个进程共享，其初始值为 -1</p>
<p>由于这是一个联合体，若是该页既不是 PageSlab 也没有被映射到用户空间，则为 page_type 字段，具体说明定义于 <code>/include/linux/page-flags.h</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * For pages that are never mapped to userspace (and aren&#x27;t PageSlab),</span></span><br><span class="line"><span class="comment"> * page_type may be used.  Because it is initialised to -1, we invert the</span></span><br><span class="line"><span class="comment"> * sense of the bit, so __SetPageFoo *clears* the bit used for PageFoo, and</span></span><br><span class="line"><span class="comment"> * __ClearPageFoo *sets* the bit used for PageFoo.  We reserve a few high and</span></span><br><span class="line"><span class="comment"> * low bits so that an underflow or overflow of page_mapcount() won&#x27;t be</span></span><br><span class="line"><span class="comment"> * mistaken for a page type value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_TYPE_BASE    0xf0000000</span></span><br><span class="line"><span class="comment">/* Reserve        0x0000007f to catch underflows of page_mapcount */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_MAPCOUNT_RESERVE    -128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PG_buddy    0x00000080</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PG_offline    0x00000100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PG_table    0x00000200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PG_guard    0x00000400</span></span><br></pre></td></tr></table></figure>

<h3 id="refcount：引用计数"><a href="#refcount：引用计数" class="headerlink" title="_refcount：引用计数"></a>_refcount：引用计数</h3><p>该字段用作该页面<strong>在内核中</strong>的引用计数器，初始时页面为空闲状态，该计数器为 0，每当该页面被分配引用时计数器会 + 1，被其他页面进行引用时也会 + 1</p>
<p>当引用计数器为 0 时表示该页面为空闲状态或即将要被释放，若大于 0 则表示正在被使用，暂时不会释放</p>
<p>内核中提供了两个函数 <code>get_page()</code>与 <code>put_page()</code> 来进行引用计数的增减，后者在引用计数器为 1 时会调用 <code>__put_single_page()</code> 释放该页面（1-&gt;0，该页面已空闲）</p>
<h3 id="virtual：虚拟地址"><a href="#virtual：虚拟地址" class="headerlink" title="**virtual：虚拟地址**"></a>**virtual：虚拟地址**</h3><p>该字段为该物理页框对应的的<strong>虚拟地址</strong>，那么这里又要放上这张经典的图：</p>
<p><img src="https://i.loli.net/2021/11/23/q6jTAJkU9XuCHWV.png" alt="image.png"></p>
<p>每一个 struct page 对应一个物理页框，那么这个 virtual 字段其实就是<strong>上图的反向映射</strong></p>
<h2 id="II-不同内存模型下的-struct-page-存储方式"><a href="#II-不同内存模型下的-struct-page-存储方式" class="headerlink" title="II.不同内存模型下的 struct page 存储方式"></a>II.不同内存模型下的 struct page 存储方式</h2><p>Linux 提供了三种内存模型，定义于 <code>include/asm-generic/memory_model.h</code> 中，如下图所示（偷的图，侵删）：</p>
<p><img src="https://i.loli.net/2021/11/25/wLzFuCB5n1DAIY7.png" alt="image.png"></p>
<p>内存模型在编译期就会被确定下来，目前常用的是 <code>Sparse Memory</code> 模型，即离散内存模型</p>
<h3 id="Flat-Memory"><a href="#Flat-Memory" class="headerlink" title="Flat Memory"></a>Flat Memory</h3><p>平滑内存模型。物理内存地址连续，有一个<strong>全局变量</strong> <code>mem_map</code> ——由一个大的 struct page 数组直接对应现有的物理内存</p>
<h3 id="Discontiguous-Memory"><a href="#Discontiguous-Memory" class="headerlink" title="Discontiguous Memory"></a>Discontiguous Memory</h3><p>非连续性内存模型。主要针对内存中存在空洞的情况。</p>
<p>对于每一段连续的物理内存，都有一个 <code>pglist_data</code> 结构体进行对应，其成员 <code>node_mem_map</code> 为一个 struct page 指针，指向一个 page 结构体数组，由该结构体对应到该段连续物理内存</p>
<p>有一个<strong>全局变量</strong> <code>node_data</code> 为一个 pglist_data 指针数组，其中存放着指向每一个 pglist_data 的指针，该数组的大小为 <code>MAX_NUMNODES</code></p>
<h3 id="Sparse-Memory"><a href="#Sparse-Memory" class="headerlink" title="Sparse Memory"></a>Sparse Memory</h3><p>离散内存模型。在一个 mem_section 结构体中存在一个 <code>section_mem_map</code> 成员指向一个 struct page 数组对应一段连续的物理内存，即将内存按照 section 为单位进行分段</p>
<p>存在一个全局指针数组 <code>mem_section</code> （与结构体同名）存放所有的 <code>mem_section</code> 指针，指向<strong>理论上支持的内存空间</strong>，每个 section 对应的物理内存不一定存在，若不存在则此时该 section 的指针为 NULL</p>
<p>这种模型<strong>支持内存的热拔插</strong></p>
<blockquote>
<p>图还是偷的，侵删</p>
</blockquote>
<p><img src="https://i.loli.net/2021/11/25/RN47OEoaM31xQhA.png" alt="image.png"></p>
<h4 id="mem-section-结构体"><a href="#mem-section-结构体" class="headerlink" title="mem_section 结构体"></a>mem_section 结构体</h4><p>该结构体定义于 <code>/include/linux/mmzone.h</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_section</span> &#123;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 逻辑上这指向一个 pages 结构体数组，</span></span><br><span class="line"><span class="comment">     * 然而，他的存储还有一些别的魔力</span></span><br><span class="line"><span class="comment">     * (参见 sparse.c::sparse_init_one_section())</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 此外，在引导的早期，我们对此处节区的位置的</span></span><br><span class="line"><span class="comment">     * 节点的id进行编码，以指引分配。</span></span><br><span class="line"><span class="comment">     * (参见 sparse.c::memory_present())</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 将之声明为一个 unsigned long，至少可以让人在</span></span><br><span class="line"><span class="comment">     * 错误使用之前完成一次（类型）转换</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> section_mem_map;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mem_section_usage</span> *<span class="title">usage</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PAGE_EXTENSION</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 若是 SPARSEMEM, pgdat 没有 page_ext 指针.</span></span><br><span class="line"><span class="comment">     * 我们使用 section. (关于这个，参见 page_ext.h)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page_ext</span> *<span class="title">page_ext</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> pad;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 警告: mem_section 的大小必须是2的幂次方， 以便于</span></span><br><span class="line"><span class="comment">     * 让计算与使用 SECTION_ROOT_MASK 有意义</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="CONFIG-SPARSEMEM-EXTREME-：动态分配-mem-section-数组"><a href="#CONFIG-SPARSEMEM-EXTREME-：动态分配-mem-section-数组" class="headerlink" title="_CONFIG_SPARSEMEM_EXTREME_：动态分配 mem_section 数组"></a>_CONFIG_SPARSEMEM_EXTREME_：动态分配 <code>mem_section</code> 数组</h4><p>内核编译选项之一，若开启了则连 <code>mem_section</code> 数组的空间也是动态分配的，在 section 较多的情况下通常会开启这个编译选项</p>
<h4 id="全局-mem-section-数组"><a href="#全局-mem-section-数组" class="headerlink" title="全局 mem_section 数组"></a>全局 mem_section 数组</h4><p>该数组中存放着指向所有 mem_section 结构体的指针，定义于 <code>/mm/sparse.c</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SPARSEMEM_EXTREME</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_section</span> **<span class="title">mem_section</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_section</span> <span class="title">mem_section</span>[<span class="title">NR_SECTION_ROOTS</span>][<span class="title">SECTIONS_PER_ROOT</span>]</span></span><br><span class="line"><span class="class">    ____<span class="title">cacheline_internodealigned_in_smp</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>若未开启 <em>CONFIG_SPARSEMEM_EXTREME</em> 编译选项则 mem_section 为一个常规的<strong>二维数组</strong>，否则为一个<strong>二级指针</strong>，其所指向空间内存动态分配</p>
<p>对于后一种情况，其结构如下图所示：</p>
<p><img src="https://i.loli.net/2021/12/03/wVpetDxj5gRlfWN.png" alt="自己画的图.png"></p>
<h4 id="PFN-与-page-结构体间的转换"><a href="#PFN-与-page-结构体间的转换" class="headerlink" title="PFN 与 page 结构体间的转换"></a>PFN 与 page 结构体间的转换</h4><p>kernel 中提供了两个用以在 PFN（Page Frame Numer） 与 page 结构体之间进行转换的宏，定义于 <code>/include/asm-generic/memory_model.h</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(CONFIG_SPARSEMEM)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Note: 节区的 mem_map 被编码以表示其 start_pfn.</span></span><br><span class="line"><span class="comment"> * section[i].section_mem_map == mem_map&#x27;s address - start_pfn;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __page_to_pfn(pg)                    \</span></span><br><span class="line"><span class="meta">(&#123;    const struct page *__pg = (pg);                \</span></span><br><span class="line"><span class="meta">    int __sec = page_to_section(__pg);            \</span></span><br><span class="line"><span class="meta">    (unsigned long)(__pg - __section_mem_map_addr(__nr_to_section(__sec)));    \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __pfn_to_page(pfn)                \</span></span><br><span class="line"><span class="meta">(&#123;    unsigned long __pfn = (pfn);            \</span></span><br><span class="line"><span class="meta">    struct mem_section *__sec = __pfn_to_section(__pfn);    \</span></span><br><span class="line"><span class="meta">    __section_mem_map_addr(__sec) + __pfn;        \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_FLATMEM/DISCONTIGMEM/SPARSEMEM */</span></span></span><br></pre></td></tr></table></figure>

<p>在这里我们需要注意一点：<strong>mem_section 结构体的 section_mem_map 中存储的为 page 数组与 PFN 的差值</strong></p>
<h5 id="（1）page-结构体到-PFN：page-结构体地址减去对应-mem-section-gt-section-mem-map"><a href="#（1）page-结构体到-PFN：page-结构体地址减去对应-mem-section-gt-section-mem-map" class="headerlink" title="（1）page 结构体到 PFN：page 结构体地址减去对应 mem_section-&gt;section_mem_map"></a>（1）page 结构体到 PFN：page 结构体地址减去对应 mem_section-&gt;section_mem_map</h5><p>该宏首先会使用 <code>page_to_section()</code> <strong>通过 page 结构体的 flags 字段</strong>获取该 page 所属的 section 标号，该函数定义于 <code>/include/linux/mm.h</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">page_to_section</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> page *page)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (page-&gt;flags &gt;&gt; SECTIONS_PGSHIFT) &amp; SECTIONS_MASK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后使用 <code>__nr_to_section()</code> 来获取对应的 mem_section 结构体的地址，该函数定义于 <code>/include/linux/mmzone.h</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">mem_section</span> *__<span class="title">nr_to_section</span>(<span class="title">unsigned</span> <span class="title">long</span> <span class="title">nr</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SPARSEMEM_EXTREME</span></span><br><span class="line">    <span class="keyword">if</span> (!mem_section)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (!mem_section[SECTION_NR_TO_ROOT(nr)])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;mem_section[SECTION_NR_TO_ROOT(nr)][nr &amp; SECTION_ROOT_MASK];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里用到一个宏 <code>SEECTION_NR_TO_ROOT</code>，定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SPARSEMEM_EXTREME</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECTIONS_PER_ROOT       (PAGE_SIZE / sizeof (struct mem_section))</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECTIONS_PER_ROOT    1</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECTION_NR_TO_ROOT(sec)    ((sec) / SECTIONS_PER_ROOT)</span></span><br></pre></td></tr></table></figure>

<p>我们默认开启 <code>CONFIG_SPARSEMEM_EXTREME</code>，此时 <code>SECTION_PER_ROOT</code> 意为一张页中 mem_section 结构体的数量，即宏 <code>SEECTION_NR_TO_ROOT</code> 得到的是对应的_页下标_，之后再通过 mem_section 标号与每页中 mem_section 数量 - 1（<code>SECTION_ROOT_MASK</code>）做与运算最终得到该 mem_section 在该页这一 mem_section 数组中的下标</p>
<p>之后通过 <code>__section_mem_map_addr()</code> 获取到 mem_section 结构体中的 section_mem_map 成员，该函数定义于 <code>/include/linux/mmzone.h</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *__<span class="title">section_mem_map_addr</span>(<span class="keyword">struct</span> <span class="title">mem_section</span> *<span class="title">section</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="built_in">map</span> = section-&gt;section_mem_map;</span><br><span class="line">    <span class="built_in">map</span> &amp;= SECTION_MAP_MASK;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">struct</span> page *)<span class="built_in">map</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后与 page 结构体的地址做差运算便能获得其 PFN，需要注意的是在这里进行的是 <em>page 结构体指针间的运算</em> 而非简单的地址加减法，计算过程为：<br>$$<br>address_{struct\ page} - section_mem_map &#x3D; address_{struct\ page} - (address_{mem_map} - start_PFN)\<br>&#x3D;(address_{struct\ page} - address_{mem_map}) + start_PFN<br>\<br>&#x3D;PFN<br>$$</p>
<h5 id="（2）PFN-到-page-结构体：页框号加上对应-mem-section-gt-section-mem-map"><a href="#（2）PFN-到-page-结构体：页框号加上对应-mem-section-gt-section-mem-map" class="headerlink" title="（2）PFN 到 page 结构体：页框号加上对应 mem_section-&gt;section_mem_map"></a>（2）PFN 到 page 结构体：页框号加上对应 mem_section-&gt;section_mem_map</h5><p>该宏首先使用 <code>__pfn_section()</code> 来获取到 PFN 所属的 mem_section，该函数定义于 <code>/include/linux/mmzone.h</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">mem_section</span> *__<span class="title">pfn_to_section</span>(<span class="title">unsigned</span> <span class="title">long</span> <span class="title">pfn</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">return</span> __nr_to_section(pfn_to_section_nr(pfn));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>pfn_to_section_nr()</code> 定义如下，用以获取对应的 section 的索引：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">pfn_to_section_nr</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> pfn)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> pfn &gt;&gt; PFN_SECTION_SHIFT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里用到一个宏 <code>PFN_SECTION_SHIFT</code>，定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PFN_SECTION_SHIFT    (SECTION_SIZE_BITS - PAGE_SHIFT)</span></span><br></pre></td></tr></table></figure>

<p>其中的 <code>SECTION_SIZE_BIT</code> 表示一个 section 的大小（恒定为2的幂次方）所占位数，而 <code>PAGE_SHIFT</code> 则为一个页的大小（通常为4096）所占位数，前者移位后者所得为_一个 section 中页的数量_</p>
<p>由页框号移位（本质为除法）单个 section 中页的数量便能得到其所属 section 标号</p>
<p>之后使用 <code>__nr_to_section()</code> 来获取对应的 mem_section 结构体的地址，最后使用 <code>__section_mem_map_addr()</code> 获取到 mem_section 结构体中的 section_mem_map 成员后再与页框号做 <em>指针加法</em> 便能获取到对应的 page 结构体数组，计算过程如下：<br>$$<br>PFN - section_mem_map &#x3D; PFN - (address_{mem_map} - start_PFN)\<br>&#x3D; (PFN - start_PFN )+ address_{mem_map}<br>\<br>&#x3D;address_{struct\ page}<br>$$</p>
<h4 id="Sparse-Memory-virtual-memmap"><a href="#Sparse-Memory-virtual-memmap" class="headerlink" title="*Sparse Memory virtual memmap"></a><em>*Sparse Memory virtual memmap</em></h4><p>基于Sparse Memory 内存模型上引入了 vmemmap 的概念，是目前 Linux 最常用的内存模型之一</p>
<blockquote>
<p>图依然是偷的，侵删</p>
</blockquote>
<p><img src="https://i.loli.net/2021/11/25/mnAUkENCoRwjtpq.png" alt="image.png"></p>
<p>在开启了 vmemmap 之后，所有的 mem_section 中的 page 都抽象到一个虚拟数组 vmemmap 中，这样在进行struct page * 和 pfn 转换时，直接使用 vmemmap 数组即可</p>
<h1 id="0x02-struct-zone：区"><a href="#0x02-struct-zone：区" class="headerlink" title="0x02.struct zone：区"></a>0x02.struct zone：区</h1><p>在 Linux 下将一个节点内不同用途的内存区域划分为不同的 <code>区（zone）</code>，对应结构体 <code>struct zone</code>，该结构体定义于 <code>/include/linux/mmzone.h</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Read-mostly fields */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* zone 的“水位线”, 使用宏 *_wmark_pages(zone) 进行访问 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> _watermark[NR_WMARK];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> watermark_boost;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> nr_reserved_highatomic;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 我们不知道我们将要分配的内存是否是可释放的 或/且 最终会被释放，</span></span><br><span class="line"><span class="comment">     * 因此为了避免将整个的几个 GB 的 RAM浪费掉，</span></span><br><span class="line"><span class="comment">     * 我们必须要保留一些 lower zone memory</span></span><br><span class="line"><span class="comment">     * (否则我们将有在 lower zones 上耗尽所有内存（OOM）的风险，</span></span><br><span class="line"><span class="comment">     * 尽管此时在 higher zones 仍有大量的 RAM).</span></span><br><span class="line"><span class="comment">     * 若 sysctl_lowmem_reserve_ratio 系统控制项改变，</span></span><br><span class="line"><span class="comment">     * 这个数组有可能在运行时被改变</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">long</span> lowmem_reserve[MAX_NR_ZONES];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">    <span class="type">int</span> node;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span>    *<span class="title">zone_pgdat</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pageset</span> __<span class="title">percpu</span> *<span class="title">pageset</span>;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * the high and batch values are copied to individual pagesets for</span></span><br><span class="line"><span class="comment">     * faster access</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> pageset_high;</span><br><span class="line">    <span class="type">int</span> pageset_batch;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_SPARSEMEM</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 单个 pageblock_nr_pages block 的标志位. 参见 pageblock-flags.h.</span></span><br><span class="line"><span class="comment">     * 在 SPARSEMEM 中, 该 map 存放于 struct mem_section 中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        *pageblock_flags;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_SPARSEMEM */</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* zone_start_pfn == zone_start_paddr &gt;&gt; PAGE_SHIFT */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        zone_start_pfn;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * spanned_pages 为该 zone 所包含的 pages 的范围, 包括空洞</span></span><br><span class="line"><span class="comment">     * 计算方式如下:</span></span><br><span class="line"><span class="comment">     *     spanned_pages = zone_end_pfn - zone_start_pfn;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * present_pages 为该 zone 中存在的物理页框数</span></span><br><span class="line"><span class="comment">     * 计算方式如下:</span></span><br><span class="line"><span class="comment">     *    present_pages = spanned_pages - absent_pages(pages in holes);</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * managed_pages 为现有的由 buddy system 管理的页面数量, </span></span><br><span class="line"><span class="comment">     * 计算方式如下 (reserved_pages 包括由 bootmem allocator 分配的页面):</span></span><br><span class="line"><span class="comment">     *    managed_pages = present_pages - reserved_pages;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * present_pages 可能会被内存热拔插或内存电源管理逻辑</span></span><br><span class="line"><span class="comment">     * 通过检查(present_pages - managed_pages)来算出未被管理的页面. </span></span><br><span class="line"><span class="comment">     * managed_pages 应被页面分配器与 vm 扫描器用以计算所有的水位线与阈值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 锁规则:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * zone_start_pfn 与 spanned_pages 由 span_seqlock 保护.</span></span><br><span class="line"><span class="comment">     * 这是一个顺序锁（seqlock，译者补充：写优先锁）因为他得在 zone-&gt;lock 之外被读取,</span></span><br><span class="line"><span class="comment">     * 在主分配器路径中完成. </span></span><br><span class="line"><span class="comment">     * 但他确实不经常被写入。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * span_seq lock 随着 zone-&gt;lock 被定义，因为相较于 zone-&gt;lock，</span></span><br><span class="line"><span class="comment">     * 他经常被读取. 让他们有个机会在同一条缓存线（cacheline）上一件好事</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 运行时 present_pages 应当由 mem_hotplug_begin/end() 进行保护.</span></span><br><span class="line"><span class="comment">     * 任何无法忍受 present_pages 的应当使用 get_online_mems()来获得固定的值.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">atomic_long_t</span>        managed_pages;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        spanned_pages;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        present_pages;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>        *name;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMORY_ISOLATION</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 独立的 pageblock 的数量. 用以解决由于对 pagelock</span></span><br><span class="line"><span class="comment">     * 的 migratetype 的竞态检索导致的对 freepage 的错误计数.</span></span><br><span class="line"><span class="comment">     * 由 zone-&gt;lock 保护</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        nr_isolate_pageblock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMORY_HOTPLUG</span></span><br><span class="line">    <span class="comment">/* 参见 spanned/present_pages 以获得更多描述 */</span></span><br><span class="line">    <span class="type">seqlock_t</span>        span_seqlock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> initialized;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 供页分配器使用的写敏感字段 */</span></span><br><span class="line">    ZONE_PADDING(_pad1_)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 不同 sizes 的闲置区域 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">free_area</span>    <span class="title">free_area</span>[<span class="title">MAX_ORDER</span>];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* zone 标志位 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 主要保护 free_area */</span></span><br><span class="line">    <span class="type">spinlock_t</span>        lock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 供 compaction and vmstats 使用的写敏感字段. */</span></span><br><span class="line">    ZONE_PADDING(_pad2_)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 当闲置页在这一点下时, 在读取闲置页数量时会采取额外的步骤</span></span><br><span class="line"><span class="comment">     * 以避免 per-cpu 计数器</span></span><br><span class="line"><span class="comment">     * 漂移导致水位线被突破</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> percpu_drift_mark;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined CONFIG_COMPACTION || defined CONFIG_CMA</span></span><br><span class="line">    <span class="comment">/* pfn where compaction free scanner should start */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        compact_cached_free_pfn;</span><br><span class="line">    <span class="comment">/* pfn where compaction migration scanner should start */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        compact_cached_migrate_pfn[ASYNC_AND_SYNC];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        compact_init_migrate_pfn;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        compact_init_free_pfn;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPACTION</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * On compaction failure, 1&lt;&lt;compact_defer_shift compactions</span></span><br><span class="line"><span class="comment">     * are skipped before trying again. The number attempted since</span></span><br><span class="line"><span class="comment">     * last failure is tracked with compact_considered.</span></span><br><span class="line"><span class="comment">     * compact_order_failed is the minimum compaction failed order.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        compact_considered;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        compact_defer_shift;</span><br><span class="line">    <span class="type">int</span>            compact_order_failed;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined CONFIG_COMPACTION || defined CONFIG_CMA</span></span><br><span class="line">    <span class="comment">/* Set to true when the PG_migrate_skip bits should be cleared */</span></span><br><span class="line">    <span class="type">bool</span>            compact_blockskip_flush;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span>            contiguous;</span><br><span class="line"></span><br><span class="line">    ZONE_PADDING(_pad3_)</span><br><span class="line">    <span class="comment">/* Zone 的统计数据 */</span></span><br><span class="line">    <span class="type">atomic_long_t</span>        vm_stat[NR_VM_ZONE_STAT_ITEMS];</span><br><span class="line">    <span class="type">atomic_long_t</span>        vm_numa_stat[NR_VM_NUMA_STAT_ITEMS];</span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br></pre></td></tr></table></figure>

<h2 id="I-页面迁移机制"><a href="#I-页面迁移机制" class="headerlink" title="I.页面迁移机制"></a>I.页面迁移机制</h2><p>页面迁移主要用以解决内核空间中的<strong>碎片问题</strong>，在长期的运行之后内存当中空闲页面的分布可能是零散的，这便导致了内核<strong>有可能无法映射到足够大的连续内存</strong>，因此需要进行_页面迁移_——将旧的页面迁移到新的位置</p>
<p><img src="https://i.loli.net/2021/11/30/q7T6EjtIb9PVFY3.png" alt="从知乎偷的图.png"></p>
<p>但<strong>并非所有的页面都是能够随意迁移的</strong>，因此我们在 buddy system 当中还需要将页面按照迁移类型进行分类</p>
<h3 id="迁移类型"><a href="#迁移类型" class="headerlink" title="迁移类型"></a>迁移类型</h3><p>迁移类型由一个枚举类型定义，定义于 <code>/include/linux/mmzone.h</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">migratetype</span> &#123;</span></span><br><span class="line">    MIGRATE_UNMOVABLE,</span><br><span class="line">    MIGRATE_MOVABLE,</span><br><span class="line">    MIGRATE_RECLAIMABLE,</span><br><span class="line">    MIGRATE_PCPTYPES,    <span class="comment">/* the number of types on the pcp lists */</span></span><br><span class="line">    MIGRATE_HIGHATOMIC = MIGRATE_PCPTYPES,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CMA</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * MIGRATE_CMA migration type is designed to mimic the way</span></span><br><span class="line"><span class="comment">     * ZONE_MOVABLE works.  Only movable pages can be allocated</span></span><br><span class="line"><span class="comment">     * from MIGRATE_CMA pageblocks and page allocator never</span></span><br><span class="line"><span class="comment">     * implicitly change migration type of MIGRATE_CMA pageblock.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The way to use it is to change migratetype of a range of</span></span><br><span class="line"><span class="comment">     * pageblocks to MIGRATE_CMA which can be done by</span></span><br><span class="line"><span class="comment">     * __free_pageblock_cma() function.  What is important though</span></span><br><span class="line"><span class="comment">     * is that a range of pageblocks must be aligned to</span></span><br><span class="line"><span class="comment">     * MAX_ORDER_NR_PAGES should biggest page be bigger then</span></span><br><span class="line"><span class="comment">     * a single pageblock.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    MIGRATE_CMA,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMORY_ISOLATION</span></span><br><span class="line">    MIGRATE_ISOLATE,    <span class="comment">/* can&#x27;t allocate from here */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    MIGRATE_TYPES</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>MIGRATE_UNMOVABLE</strong>：这类型页面在内存当中有着固定的位置，<strong>不能移动</strong></li>
<li><strong>MIGRATE_MOVABLE</strong>：这类页面<strong>可以随意移动</strong>，例如用户空间的页面，我们只需要复制数据后改变页表映射即可</li>
<li><strong>MIGRATE_RECLAIMABLE</strong>：这类页面<strong>不能直接移动，但是可以删除</strong>，例如映射自文件的页</li>
<li><strong>MIGRATE_PCPTYPES</strong>：<code>per_cpu_pageset</code>，即每 CPU 页帧缓存，其迁移<strong>仅限于同一节点内</strong></li>
<li><strong>MIGRATE_ISOLATE</strong>：<strong>不能从该链表分配页面</strong>，该链表用于跨 NUMA 节点进行页面移动，将页面移动到使用该页面最为频繁的 CPU 所处节点</li>
<li><em>MIGRATE_TYPES_：表示迁移类型的数目，_并不存在这一链表</em></li>
</ul>
<h2 id="II-几个比较重要的字段"><a href="#II-几个比较重要的字段" class="headerlink" title="II.几个比较重要的字段"></a>II.几个比较重要的字段</h2><p>简单讲讲其中几个重要的成员</p>
<h3 id="watermark：“水位线”"><a href="#watermark：“水位线”" class="headerlink" title="_watermark：“水位线”"></a>_watermark：“水位线”</h3><p>每一个 zone 都有着其对应的三档“水位线”： <code>WMARK_MIN</code>、<code>WMARK_LOW</code>、<code>WMARK_HIGH</code>，存放在 _watermark 数组中，在进行内存分配时，分配器（例如 buddy system）会根据当前 zone 中空余内存所处在的“水位线”来判断当前的内存状况，如下图所示：</p>
<blockquote>
<p>图仍然是偷的，侵删</p>
</blockquote>
<p><img src="https://i.loli.net/2021/11/25/8OuZhEfjHIy9AeL.png" alt="image.png"></p>
<blockquote>
<p>具体机制可以参见<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/73539328">这里</a></p>
</blockquote>
<h3 id="lowmem-reserve：zone-自身的保留内存"><a href="#lowmem-reserve：zone-自身的保留内存" class="headerlink" title="lowmem_reserve：zone 自身的保留内存"></a>lowmem_reserve：zone 自身的保留内存</h3><p>在进行内存分配时，若当前的 zone 没有足够的内存了，则会向下一个 zone 索要内存，那么这就存在一个问题：来自 higher zones 的内存分配请求可能耗尽 lower zones 的内存，但这样分配的内存未必是可释放的（freeable），亦或者&#x2F;且最终不一定会被释放，这有可能导致 <strong>lower zones 的内存提前耗尽，而 higher zones 却仍保留有大量的内存</strong></p>
<p>为了避免这样的一种情况的发生，<code>lowmem_reserve</code> 字段用以声明<strong>为该 zone 保留的内存</strong>，这一块内存别的 zone 是不能动的</p>
<h3 id="node：NUMA-中标识所属-node"><a href="#node：NUMA-中标识所属-node" class="headerlink" title="node：NUMA 中标识所属 node"></a><em>node：NUMA 中标识所属 node</em></h3><p>这个字段只在 NUMA 系统中被启用，用以标识该 zone 所属的 node</p>
<p>可以参考下面的图</p>
<blockquote>
<p>图还是偷的，侵删</p>
</blockquote>
<p><img src="https://i.loli.net/2021/11/25/LlaVq9eREW5sJAH.png" alt="image.png"></p>
<p><img src="https://i.loli.net/2021/11/25/uwbo53W2Mjh1gOm.png" alt="image.png"></p>
<h3 id="zone-pgdat：zone-所属的-pglist-data-节点"><a href="#zone-pgdat：zone-所属的-pglist-data-节点" class="headerlink" title="zone_pgdat：zone 所属的 pglist_data 节点"></a>zone_pgdat：zone 所属的 pglist_data 节点</h3><p>该字段用以标识该 zone 所属的 pglist_data 节点</p>
<h3 id="pageset-：zone-为每个-CPU-划分一个独立的”页面仓库“"><a href="#pageset-：zone-为每个-CPU-划分一个独立的”页面仓库“" class="headerlink" title="**pageset**：zone 为每个 CPU 划分一个独立的”页面仓库“"></a>**pageset**：zone 为每个 CPU 划分一个独立的”页面仓库“</h3><p>众所周知伴随着多 CPU 的引入，<strong>条件竞争</strong>就是一个不可忽视的问题，当多个 CPU 需要对一个 zone 进行操作时，频繁的加锁&#x2F;解锁操作则毫无疑问会造成大量的开销，因此 zone 引入了 <code>per_cpu_pageset</code> 结构体成员，即<strong>为每一个 CPU 都准备一个单独的页面仓库</strong>，因此其实现方式是实现为一个 <code>percpu</code> 变量</p>
<p>在一开始时 buddy system 会将页面放置到各个 CPU 自己独立的页面仓库中，需要进行分配时 CPU 优先从自己的页面仓库中分配</p>
<p>该结构体定义于 <code>/include/linux/mmzone.h</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pages</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> count;        <span class="comment">/* 链表中页的数量 */</span></span><br><span class="line">    <span class="type">int</span> high;        <span class="comment">/* 高水位线, 清空需要（笔者补：用以进行判断） */</span></span><br><span class="line">    <span class="type">int</span> batch;        <span class="comment">/* chunk size for buddy add/remove */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 页面链表, 在 pcp-lists 上储存的独立的迁移类型 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lists</span>[<span class="title">MIGRATE_PCPTYPES</span>];</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pageset</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pages</span> <span class="title">pcp</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">    s8 expire;</span><br><span class="line">    u16 vm_numa_stat_diff[NR_VM_NUMA_STAT_ITEMS];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">    s8 stat_threshold;</span><br><span class="line">    s8 vm_stat_diff[NR_VM_ZONE_STAT_ITEMS];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>该结构体会被存放在每个 CPU 自己独立的 <code>.data..percpu</code> 段中，以 CPU0 为例，结构如下图所示</p>
<p><img src="https://i.loli.net/2021/12/03/1dCZA3IDpUK2xYg.png" alt="自己画的图.png"></p>
<h3 id="zone-start-pfn：zone-的起始物理PFN"><a href="#zone-start-pfn：zone-的起始物理PFN" class="headerlink" title="zone_start_pfn：zone 的起始物理PFN"></a>zone_start_pfn：zone 的起始物理PFN</h3><p>该字段用以标识该 zone 的起始物理<strong>页帧编号</strong>（page frame number）</p>
<h3 id="spanned-pages：-zone-对应的内存区域中的-pages-总数（包括空洞）"><a href="#spanned-pages：-zone-对应的内存区域中的-pages-总数（包括空洞）" class="headerlink" title="spanned_pages： zone 对应的内存区域中的 pages 总数（包括空洞）"></a>spanned_pages： zone 对应的内存区域中的 pages 总数（包括空洞）</h3><p>该字段用以标识该 zone 对应的内存区域中的 pages 总数, <strong>包括空洞</strong></p>
<h3 id="present-pages：-zone-中存在的物理页框数"><a href="#present-pages：-zone-中存在的物理页框数" class="headerlink" title="present_pages： zone 中存在的物理页框数"></a>present_pages： zone 中存在的物理页框数</h3><p>该字段用以标识  zone 中实际存在的物理页框数</p>
<h3 id="managed-pages：zone-中-buddy-system-管理的页面数量"><a href="#managed-pages：zone-中-buddy-system-管理的页面数量" class="headerlink" title="managed_pages：zone 中 buddy system 管理的页面数量"></a>managed_pages：zone 中 buddy system 管理的页面数量</h3><p>该字段用以标识 zone 中 buddy system 管理的页面数量</p>
<h3 id="free-area-：buddy-system-按照-order-管理的页面"><a href="#free-area-：buddy-system-按照-order-管理的页面" class="headerlink" title="**free_area**：buddy system 按照 order 管理的页面"></a>**free_area**：buddy system 按照 order 管理的页面</h3><p>该字段用以存储 buddy system 按照 order 管理的页面，为一个 <code>free_area</code> 结构体数组，该结构体定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">free_area</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">free_list</span>[<span class="title">MIGRATE_TYPES</span>];</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        nr_free;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在 free_area 中存放的页面通过自身的相应字段连接成双向链表结构，这里放一张 overview</p>
<p><img src="https://i.loli.net/2021/11/30/sOwdI5YMNUjLSib.png" alt="自己画的图.png"></p>
<p>free_area 中并非只有一个双向链表，而是按照不同的“迁移类型”（migrate type）进行分开存放，这是由于_页面迁移_机制的存在</p>
<p>以 <em>free_list[0]</em> 作为例子，我们可以得到如下 overview：</p>
<p><img src="https://i.loli.net/2021/11/30/sbNImKo6tBS5GUe.png" alt="自己画的图.png"></p>
<h3 id="flags：标志位-1"><a href="#flags：标志位-1" class="headerlink" title="flags：标志位"></a>flags：标志位</h3><p>该 zone 的标志位，用以标识其所处的状态</p>
<h2 id="II-zone-的分类"><a href="#II-zone-的分类" class="headerlink" title="II.zone 的分类"></a>II.zone 的分类</h2><p>在 Linux kernel 当中，我们根据内存区段的不同用途，将其划分为不同的 zone，在 <code>/include/linux/mmzone.h</code> 中有着相应的枚举定义，如下：</p>
<blockquote>
<p>摆烂了，可能某天想起来会补充翻译</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">zone_type</span> &#123;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * ZONE_DMA and ZONE_DMA32 are used when there are peripherals not able</span></span><br><span class="line"><span class="comment">     * to DMA to all of the addressable memory (ZONE_NORMAL).</span></span><br><span class="line"><span class="comment">     * On architectures where this area covers the whole 32 bit address</span></span><br><span class="line"><span class="comment">     * space ZONE_DMA32 is used. ZONE_DMA is left for the ones with smaller</span></span><br><span class="line"><span class="comment">     * DMA addressing constraints. This distinction is important as a 32bit</span></span><br><span class="line"><span class="comment">     * DMA mask is assumed when ZONE_DMA32 is defined. Some 64-bit</span></span><br><span class="line"><span class="comment">     * platforms may need both zones as they support peripherals with</span></span><br><span class="line"><span class="comment">     * different DMA addressing limitations.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ZONE_DMA</span></span><br><span class="line">    ZONE_DMA,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ZONE_DMA32</span></span><br><span class="line">    ZONE_DMA32,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Normal addressable memory is in ZONE_NORMAL. DMA operations can be</span></span><br><span class="line"><span class="comment">     * performed on pages in ZONE_NORMAL if the DMA devices support</span></span><br><span class="line"><span class="comment">     * transfers to all addressable memory.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ZONE_NORMAL,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HIGHMEM</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * A memory area that is only addressable by the kernel through</span></span><br><span class="line"><span class="comment">     * mapping portions into its own address space. This is for example</span></span><br><span class="line"><span class="comment">     * used by i386 to allow the kernel to address the memory beyond</span></span><br><span class="line"><span class="comment">     * 900MB. The kernel will set up special mappings (page</span></span><br><span class="line"><span class="comment">     * table entries on i386) for each page that the kernel needs to</span></span><br><span class="line"><span class="comment">     * access.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ZONE_HIGHMEM,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * ZONE_MOVABLE is similar to ZONE_NORMAL, except that it contains</span></span><br><span class="line"><span class="comment">     * movable pages with few exceptional cases described below. Main use</span></span><br><span class="line"><span class="comment">     * cases for ZONE_MOVABLE are to make memory offlining/unplug more</span></span><br><span class="line"><span class="comment">     * likely to succeed, and to locally limit unmovable allocations - e.g.,</span></span><br><span class="line"><span class="comment">     * to increase the number of THP/huge pages. Notable special cases are:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. Pinned pages: (long-term) pinning of movable pages might</span></span><br><span class="line"><span class="comment">     *    essentially turn such pages unmovable. Memory offlining might</span></span><br><span class="line"><span class="comment">     *    retry a long time.</span></span><br><span class="line"><span class="comment">     * 2. memblock allocations: kernelcore/movablecore setups might create</span></span><br><span class="line"><span class="comment">     *    situations where ZONE_MOVABLE contains unmovable allocations</span></span><br><span class="line"><span class="comment">     *    after boot. Memory offlining and allocations fail early.</span></span><br><span class="line"><span class="comment">     * 3. Memory holes: kernelcore/movablecore setups might create very rare</span></span><br><span class="line"><span class="comment">     *    situations where ZONE_MOVABLE contains memory holes after boot,</span></span><br><span class="line"><span class="comment">     *    for example, if we have sections that are only partially</span></span><br><span class="line"><span class="comment">     *    populated. Memory offlining and allocations fail early.</span></span><br><span class="line"><span class="comment">     * 4. PG_hwpoison pages: while poisoned pages can be skipped during</span></span><br><span class="line"><span class="comment">     *    memory offlining, such pages cannot be allocated.</span></span><br><span class="line"><span class="comment">     * 5. Unmovable PG_offline pages: in paravirtualized environments,</span></span><br><span class="line"><span class="comment">     *    hotplugged memory blocks might only partially be managed by the</span></span><br><span class="line"><span class="comment">     *    buddy (e.g., via XEN-balloon, Hyper-V balloon, virtio-mem). The</span></span><br><span class="line"><span class="comment">     *    parts not manged by the buddy are unmovable PG_offline pages. In</span></span><br><span class="line"><span class="comment">     *    some cases (virtio-mem), such pages can be skipped during</span></span><br><span class="line"><span class="comment">     *    memory offlining, however, cannot be moved/allocated. These</span></span><br><span class="line"><span class="comment">     *    techniques might use alloc_contig_range() to hide previously</span></span><br><span class="line"><span class="comment">     *    exposed pages from the buddy again (e.g., to implement some sort</span></span><br><span class="line"><span class="comment">     *    of memory unplug in virtio-mem).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * In general, no unmovable allocations that degrade memory offlining</span></span><br><span class="line"><span class="comment">     * should end up in ZONE_MOVABLE. Allocators (like alloc_contig_range())</span></span><br><span class="line"><span class="comment">     * have to expect that migrating pages in ZONE_MOVABLE can fail (even</span></span><br><span class="line"><span class="comment">     * if has_unmovable_pages() states that there are no unmovable pages,</span></span><br><span class="line"><span class="comment">     * there can be false negatives).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ZONE_MOVABLE,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ZONE_DEVICE</span></span><br><span class="line">    ZONE_DEVICE,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    __MAX_NR_ZONES</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="X86-32"><a href="#X86-32" class="headerlink" title="X86-32"></a>X86-32</h3><p>如下表格所示（懒得找图了）</p>
<table>
<thead>
<tr>
<th align="center">Type</th>
<th align="center">Start address</th>
<th align="center">End address</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ZONE_DMA</td>
<td align="center">0MB</td>
<td align="center">16MB</td>
</tr>
<tr>
<td align="center">ZONE_NORMAL</td>
<td align="center">16MB</td>
<td align="center">896MB</td>
</tr>
<tr>
<td align="center">ZONE_HIGHMEM</td>
<td align="center">896MB</td>
<td align="center">…</td>
</tr>
</tbody></table>
<p>通常我们简单地划分为两部分：</p>
<ul>
<li><code>线性映射区</code>（前 896MB）：这一块内存直接映射到物理内存地址 0 起始往后的总计 896MB，为<strong>线性映射</strong></li>
<li><code>高端内存</code>（从 896MB 开始往后）：这一块内存的映射是<strong>不连续的</strong></li>
</ul>
<h3 id="X86-64"><a href="#X86-64" class="headerlink" title="X86-64"></a>X86-64</h3><p>如下表格所示（懒得找图了）</p>
<table>
<thead>
<tr>
<th align="center">Type</th>
<th align="center">Start address</th>
<th align="center">End address</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ZONE_DMA</td>
<td align="center">0MB</td>
<td align="center">16MB</td>
</tr>
<tr>
<td align="center">ZONE_DMA32</td>
<td align="center">16MB</td>
<td align="center">4GB</td>
</tr>
<tr>
<td align="center">ZONE_NORMAL</td>
<td align="center">4GB</td>
<td align="center">…</td>
</tr>
</tbody></table>
<p>在 64 位的 Linux kernel 中没有了“高端内存”这一概念</p>
<h1 id="0x03-struct-pglist-data：节点"><a href="#0x03-struct-pglist-data：节点" class="headerlink" title="0x03.struct pglist_data：节点"></a>0x03.struct pglist_data：节点</h1><p>zone 再向上一层便是<strong>节点</strong>——Linux 将_内存控制器（memory controller）_作为节点划分的依据，对于 UMA 架构而言只有一个节点，而对于 NUMA 架构而言通常有多个节点，对于同一个内存控制器下的 CPU 而言其对应的节点称之为_本地内存_，不同处理器之间通过总线进行进一步的连接。如下图所示，一个MC对应一个节点：</p>
<p><img src="https://i.loli.net/2021/11/27/hAopSNYg23VeWzq.png" alt="image.png"></p>
<p>一个节点使用 <code>pglist_data</code> 结构进行描述，该结构定义于 <code>/include/linux/mmzone.h</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 在 NUMA 机器上, 每个 NUMA 节点都有一个 pg_data_t 用以描述其内存布局。</span></span><br><span class="line"><span class="comment"> * 在 UMA 机器上则只有一个单独的 pglist_data 描述整个内存。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 内存统计数据与页置换数据结构由一个 per-zone basis维持</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span> &#123;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * node_zones 字段包含该节点所拥有的 zones。 并非所有的 zone 都已被填充，但这是一个满的列表。</span></span><br><span class="line"><span class="comment">     * 它被该节点的 node_zonelists 以及其他节点的 node_zonelists 所引用.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zone</span> <span class="title">node_zones</span>[<span class="title">MAX_NR_ZONES</span>];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * node_zonelists 包含有对所有节点中所有区的引用。</span></span><br><span class="line"><span class="comment">     * 通常第一个区将会作为该节点的 node_zones 的引用.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> <span class="title">node_zonelists</span>[<span class="title">MAX_ZONELISTS</span>];</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> nr_zones; <span class="comment">/* 该节点中被填充的 zone 的数量 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FLAT_NODE_MEM_MAP    <span class="comment">/* 即 SPARSEMEM */</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">node_mem_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PAGE_EXTENSION</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page_ext</span> *<span class="title">node_page_ext</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_MEMORY_HOTPLUG) || defined(CONFIG_DEFERRED_STRUCT_PAGE_INIT)</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 若你期望 node_start_pfn, node_present_pages, </span></span><br><span class="line"><span class="comment">     * node_spanned_pages 或 nr_zones 保持不变，</span></span><br><span class="line"><span class="comment">     * 必须在任何时刻持有（这个锁）。</span></span><br><span class="line"><span class="comment">     * 同时在 deferred page 初始化期间对 pgdat-&gt;first_deferred_pfn 进行同步。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * （内核）提供了 pgdat_resize_lock() 与 pgdat_resize_unlock() </span></span><br><span class="line"><span class="comment">     * 以在没有对 CONFIG_MEMORY_HOTPLUG 或 CONFIG_DEFERRED_STRUCT_PAGE_INIT</span></span><br><span class="line"><span class="comment">     * 进行检查的情况下操纵 node_size_lock </span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 基于 zone-&gt;lock 与 zone-&gt;span_seqlock</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">spinlock_t</span> node_size_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> node_start_pfn;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> node_present_pages; <span class="comment">/* 所有物理页的数量 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> node_spanned_pages; <span class="comment">/* 所有物理页的大小，包括空洞 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> node_id;</span><br><span class="line">    <span class="type">wait_queue_head_t</span> kswapd_wait;</span><br><span class="line">    <span class="type">wait_queue_head_t</span> pfmemalloc_wait;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">kswapd</span>;</span>    <span class="comment">/* 由 mem_hotplug_begin/end() 保护 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> kswapd_order;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">zone_type</span> <span class="title">kswapd_highest_zoneidx</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> kswapd_failures;        <span class="comment">/* 进行了 &#x27;reclaimed == 0&#x27; 判断的次数 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPACTION</span></span><br><span class="line">    <span class="type">int</span> kcompactd_max_order;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">zone_type</span> <span class="title">kcompactd_highest_zoneidx</span>;</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> kcompactd_wait;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">kcompactd</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 这是每个 node 保留的对用户空间分配不可用的页面</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        totalreserve_pages;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 若存在更多的未映射页面，则节点回收将会变得活跃</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        min_unmapped_pages;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        min_slab_pages;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_NUMA */</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 页回收使用的写敏感字段 */</span></span><br><span class="line">    ZONE_PADDING(_pad1_)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEFERRED_STRUCT_PAGE_INIT</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 若在大机器上的内存初始化被推迟了，那么这是</span></span><br><span class="line"><span class="comment">     * 第一个需要被初始化的 PFN</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> first_deferred_pfn;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_DEFERRED_STRUCT_PAGE_INIT */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TRANSPARENT_HUGEPAGE</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">deferred_split</span> <span class="title">deferred_split_queue</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 页回收扫描器通常访问的字段 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * <span class="doctag">NOTE:</span> 若开启了 MEMCG 则其将不会被使用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 使用 mem_cgroup_lruvec() 以查询 lruvecs.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lruvec</span>        __<span class="title">lruvec</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        flags;</span><br><span class="line"></span><br><span class="line">    ZONE_PADDING(_pad2_)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Per-node vmstats */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_nodestat</span> __<span class="title">percpu</span> *<span class="title">per_cpu_nodestats</span>;</span></span><br><span class="line">    <span class="type">atomic_long_t</span>        vm_stat[NR_VM_NODE_STAT_ITEMS];</span><br><span class="line">&#125; <span class="type">pg_data_t</span>;</span><br></pre></td></tr></table></figure>

<h2 id="几个比较重要的字段"><a href="#几个比较重要的字段" class="headerlink" title="几个比较重要的字段"></a>几个比较重要的字段</h2><p>简单讲讲其中几个重要的成员</p>
<h3 id="node-zones-：node-的-zone-列表"><a href="#node-zones-：node-的-zone-列表" class="headerlink" title="**node_zones**：node 的 zone 列表"></a>**node_zones**：node 的 zone 列表</h3><p>节点中最重要的字段 <code>node_zones</code> 作为一个 zone 结构体数组记录了<strong>本节点上所有的 zone</strong>，其中有效的 zone 的个数由节点结构体的 <code>nr_zones</code> 字段指出</p>
<h3 id="node-zonelists：内存分配时备用-zone-的搜索顺序"><a href="#node-zonelists：内存分配时备用-zone-的搜索顺序" class="headerlink" title="node_zonelists：内存分配时备用 zone 的搜索顺序"></a>node_zonelists：内存分配时备用 zone 的搜索顺序</h3><p>该字段用以确定内存分配时对备用的 zone 的搜索顺序，在本节点常规内存分配失败时会沿着这个数组进行搜索，其中包含的 zone <strong>可以是非本节点的 zone</strong></p>
<h3 id="nr-zones：node-中-zone-的数量"><a href="#nr-zones：node-中-zone-的数量" class="headerlink" title="nr_zones：node 中 zone 的数量"></a>nr_zones：node 中 zone 的数量</h3><p>该字段存储了该节点中所有可用的 zone 的数量</p>
<h3 id="node-start-pfn：node-的起始页框标号"><a href="#node-start-pfn：node-的起始页框标号" class="headerlink" title="node_start_pfn：node 的起始页框标号"></a>node_start_pfn：node 的起始页框标号</h3><p>该字段记录了该节点上的物理内存起始页框标号</p>
<h3 id="node-present-pages：node-中物理页的总数量"><a href="#node-present-pages：node-中物理页的总数量" class="headerlink" title="node_present_pages：node 中物理页的总数量"></a>node_present_pages：node 中物理页的总数量</h3><p>该字段记录了节点中可用的物理页的总数量</p>
<h3 id="unsigned-long-node-spanned-pages：-node-中物理页的总大小"><a href="#unsigned-long-node-spanned-pages：-node-中物理页的总大小" class="headerlink" title="unsigned long node_spanned_pages： node 中物理页的总大小"></a>unsigned long node_spanned_pages： node 中物理页的总大小</h3><p>该字段记录了节点上<strong>包括空洞在内</strong>的页帧为单位的该节点内存的总长度</p>
<h3 id="node-id：node-的标号"><a href="#node-id：node-的标号" class="headerlink" title="node_id：node 的标号"></a>node_id：node 的标号</h3><p>该字段记录了该节点在系统中的标号，从 0 开始</p>
<h2 id="node-存储方式：全局数组-node-data"><a href="#node-存储方式：全局数组-node-data" class="headerlink" title="node 存储方式：全局数组 node_data[]"></a>node 存储方式：全局数组 node_data[]</h2><p>在 <code>/arch/x86/mm/numa.c</code> 中定义了一个 pglist_data 数组，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span> *<span class="title">node_data</span>[<span class="title">MAX_NUMNODES</span>] __<span class="title">read_mostly</span>;</span></span><br><span class="line">EXPORT_SYMBOL(node_data);</span><br></pre></td></tr></table></figure>

<p>该数组中保存了系统中的<strong>所有的节点</strong></p>
<p>由此，我们最终得到这样一张架构图：</p>
<blockquote>
<p>还是偷的图，侵删</p>
</blockquote>
<p><img src="https://i.loli.net/2021/11/28/KcHILforOySi8YR.png" alt="image.png"></p>
<blockquote>
<p>我们可以使用 <code>numactl</code> 工具来查看系统中的节点信息，如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">numactl --hardware</span></span><br><span class="line">available: 1 nodes (0)</span><br><span class="line">node 0 cpus: 0 1 2 3</span><br><span class="line">node 0 size: 11942 MB</span><br><span class="line">node 0 free: 4464 MB</span><br><span class="line">node distances:</span><br><span class="line">node   0 </span><br><span class="line">  0:  10 </span><br></pre></td></tr></table></figure>

<blockquote>
<p>笔者的机器比较弱，只有一个节点</p>
</blockquote>
</blockquote>
<h2 id="node-状态：全局数组-node-states"><a href="#node-状态：全局数组-node-states" class="headerlink" title="node 状态：全局数组 node_states[]"></a>node 状态：全局数组 node_states[]</h2><p>在 <code>/mm/page_alloc.c</code> 中定义了一个全局数组 <code>node_states</code> 用以标识对应标号的节点的状态，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Array of node states.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">nodemask_t</span> node_states[NR_NODE_STATES] __read_mostly = &#123;</span><br><span class="line">    [N_POSSIBLE] = NODE_MASK_ALL,</span><br><span class="line">    [N_ONLINE] = &#123; &#123; [<span class="number">0</span>] = <span class="number">1UL</span> &#125; &#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_NUMA</span></span><br><span class="line">    [N_NORMAL_MEMORY] = &#123; &#123; [<span class="number">0</span>] = <span class="number">1UL</span> &#125; &#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HIGHMEM</span></span><br><span class="line">    [N_HIGH_MEMORY] = &#123; &#123; [<span class="number">0</span>] = <span class="number">1UL</span> &#125; &#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    [N_MEMORY] = &#123; &#123; [<span class="number">0</span>] = <span class="number">1UL</span> &#125; &#125;,</span><br><span class="line">    [N_CPU] = &#123; &#123; [<span class="number">0</span>] = <span class="number">1UL</span> &#125; &#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>    <span class="comment">/* NUMA */</span></span></span><br><span class="line">&#125;;</span><br><span class="line">EXPORT_SYMBOL(node_states);</span><br></pre></td></tr></table></figure>

<p>在这里的 <code>nodemask_t</code> 类型为一个<strong>位图</strong>类型，定义于 <code>/include/linux/nodemask.h</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> DECLARE_BITMAP(bits, MAX_NUMNODES); &#125; <span class="type">nodemask_t</span>;</span><br></pre></td></tr></table></figure>

<p>这个状态由一个枚举类型 <code>node_states</code> 定义，该枚举类型定义于 <code>/include/linux/nodemask.h</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 位掩码将为所有节点保存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">node_states</span> &#123;</span></span><br><span class="line">    N_POSSIBLE,        <span class="comment">/* 节点在某个时刻是联机的 */</span></span><br><span class="line">    N_ONLINE,        <span class="comment">/* 节点是联机的 */</span></span><br><span class="line">    N_NORMAL_MEMORY,    <span class="comment">/* 节点有着普通的内存 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HIGHMEM</span></span><br><span class="line">    N_HIGH_MEMORY,        <span class="comment">/* 节点有着普通或高端内存 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    N_HIGH_MEMORY = N_NORMAL_MEMORY,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    N_MEMORY,        <span class="comment">/* 节点有着内存(普通，高端，可移动) */</span></span><br><span class="line">    N_CPU,        <span class="comment">/* 节点有着一个或多个 cpu */</span></span><br><span class="line">    N_GENERIC_INITIATOR,    <span class="comment">/* 节点有一个或多个 Generic Initiators */</span></span><br><span class="line">    NR_NODE_STATES</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
              <a href="/2021/11/24/FUZZ-0X01-SYZKALLER-I/" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>上一页</span>
              </a>
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">
              <i class="iconfont icon-updatetime" title="更新时间"></i>
              2021-11-28 02:45:29
            </span>
            
                  <span class="post-categories">
                    <i class="iconfont icon-bookmark" title="分类"></i>
                    
                    <span class="span--category">
                      <a href="/categories/OS/" title="OS">
                        <b>#</b> OS
                      </a>
                    </span>
                    
                  </span>
              
                  <span class="post-tags">
                    <i class="iconfont icon-tags" title="标签"></i>
                    
                    <span class="span--tag">
                      <a href="/tags/Linux/" title="Linux">
                        <b>#</b> Linux
                      </a>
                    </span>
                    
                    <span class="span--tag">
                      <a href="/tags/%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0/" title="学习札记">
                        <b>#</b> 学习札记
                      </a>
                    </span>
                    
                    <span class="span--tag">
                      <a href="/tags/Linux-Kernel/" title="Linux Kernel">
                        <b>#</b> Linux Kernel
                      </a>
                    </span>
                    
                    <span class="span--tag">
                      <a href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" title="内存管理">
                        <b>#</b> 内存管理
                      </a>
                    </span>
                    
                  </span>
              
          </div>
          <div class="post-foot-prev">
            
              <a href="/2021/11/29/PWN-0X02-LINUX-KERNEL-PWN-PART-II/" target="_self">
                <span>下一页</span>
                <i class="iconfont icon-chevronright"></i>
              </a>
            
          </div>
        </div>
      
    </div>
    
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">目录</div>
    <div class="catalog-content">
      
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0x00-%E4%B8%80%E5%88%87%E5%BC%80%E5%A7%8B%E4%B9%8B%E5%89%8D"><span class="toc-text">0x00.一切开始之前</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Overview"><span class="toc-text">Overview</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x01-struct-page%EF%BC%9A%E9%A1%B5"><span class="toc-text">0x01.struct page：页</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#I-%E5%87%A0%E4%B8%AA%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%AD%97%E6%AE%B5"><span class="toc-text">I.几个比较重要的字段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#lru%EF%BC%9ALRU-%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9"><span class="toc-text">lru：LRU 链表节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#slab%E7%9B%B8%E5%85%B3%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">**slab相关结构体**</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#flags%EF%BC%9A%E6%A0%87%E5%BF%97%E4%BD%8D"><span class="toc-text">flags：标志位</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#flags-%E5%86%85%E5%AD%98%E5%A4%8D%E7%94%A8"><span class="toc-text">flags 内存复用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%9E-sparse-%E5%86%85%E5%AD%98%E6%A8%A1%E5%BC%8F-x2F-sparse-vmemmap-%E5%86%85%E5%AD%98%E6%A8%A1%E5%BC%8F"><span class="toc-text">非 sparse 内存模式 &#x2F; sparse vmemmap 内存模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sparse-%E5%86%85%E5%AD%98%E6%A8%A1%E5%BC%8F"><span class="toc-text">sparse 内存模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B2%A1%E6%9C%89-Node-%E7%9A%84-sparse-%E5%86%85%E5%AD%98%E6%A8%A1%E5%BC%8F"><span class="toc-text">没有 Node 的 sparse 内存模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mapcount%EF%BC%9A%E6%98%A0%E5%B0%84%E8%AE%A1%E6%95%B0"><span class="toc-text">_mapcount：映射计数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#refcount%EF%BC%9A%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="toc-text">_refcount：引用计数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#virtual%EF%BC%9A%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80"><span class="toc-text">**virtual：虚拟地址**</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#II-%E4%B8%8D%E5%90%8C%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8B%E7%9A%84-struct-page-%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="toc-text">II.不同内存模型下的 struct page 存储方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Flat-Memory"><span class="toc-text">Flat Memory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Discontiguous-Memory"><span class="toc-text">Discontiguous Memory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sparse-Memory"><span class="toc-text">Sparse Memory</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#mem-section-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">mem_section 结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CONFIG-SPARSEMEM-EXTREME-%EF%BC%9A%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D-mem-section-%E6%95%B0%E7%BB%84"><span class="toc-text">_CONFIG_SPARSEMEM_EXTREME_：动态分配 mem_section 数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80-mem-section-%E6%95%B0%E7%BB%84"><span class="toc-text">全局 mem_section 数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PFN-%E4%B8%8E-page-%E7%BB%93%E6%9E%84%E4%BD%93%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-text">PFN 与 page 结构体间的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89page-%E7%BB%93%E6%9E%84%E4%BD%93%E5%88%B0-PFN%EF%BC%9Apage-%E7%BB%93%E6%9E%84%E4%BD%93%E5%9C%B0%E5%9D%80%E5%87%8F%E5%8E%BB%E5%AF%B9%E5%BA%94-mem-section-gt-section-mem-map"><span class="toc-text">（1）page 结构体到 PFN：page 结构体地址减去对应 mem_section-&gt;section_mem_map</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89PFN-%E5%88%B0-page-%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%9A%E9%A1%B5%E6%A1%86%E5%8F%B7%E5%8A%A0%E4%B8%8A%E5%AF%B9%E5%BA%94-mem-section-gt-section-mem-map"><span class="toc-text">（2）PFN 到 page 结构体：页框号加上对应 mem_section-&gt;section_mem_map</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Sparse-Memory-virtual-memmap"><span class="toc-text">*Sparse Memory virtual memmap</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x02-struct-zone%EF%BC%9A%E5%8C%BA"><span class="toc-text">0x02.struct zone：区</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#I-%E9%A1%B5%E9%9D%A2%E8%BF%81%E7%A7%BB%E6%9C%BA%E5%88%B6"><span class="toc-text">I.页面迁移机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%81%E7%A7%BB%E7%B1%BB%E5%9E%8B"><span class="toc-text">迁移类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#II-%E5%87%A0%E4%B8%AA%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%AD%97%E6%AE%B5"><span class="toc-text">II.几个比较重要的字段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#watermark%EF%BC%9A%E2%80%9C%E6%B0%B4%E4%BD%8D%E7%BA%BF%E2%80%9D"><span class="toc-text">_watermark：“水位线”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lowmem-reserve%EF%BC%9Azone-%E8%87%AA%E8%BA%AB%E7%9A%84%E4%BF%9D%E7%95%99%E5%86%85%E5%AD%98"><span class="toc-text">lowmem_reserve：zone 自身的保留内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#node%EF%BC%9ANUMA-%E4%B8%AD%E6%A0%87%E8%AF%86%E6%89%80%E5%B1%9E-node"><span class="toc-text">node：NUMA 中标识所属 node</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#zone-pgdat%EF%BC%9Azone-%E6%89%80%E5%B1%9E%E7%9A%84-pglist-data-%E8%8A%82%E7%82%B9"><span class="toc-text">zone_pgdat：zone 所属的 pglist_data 节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pageset-%EF%BC%9Azone-%E4%B8%BA%E6%AF%8F%E4%B8%AA-CPU-%E5%88%92%E5%88%86%E4%B8%80%E4%B8%AA%E7%8B%AC%E7%AB%8B%E7%9A%84%E2%80%9D%E9%A1%B5%E9%9D%A2%E4%BB%93%E5%BA%93%E2%80%9C"><span class="toc-text">**pageset**：zone 为每个 CPU 划分一个独立的”页面仓库“</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#zone-start-pfn%EF%BC%9Azone-%E7%9A%84%E8%B5%B7%E5%A7%8B%E7%89%A9%E7%90%86PFN"><span class="toc-text">zone_start_pfn：zone 的起始物理PFN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spanned-pages%EF%BC%9A-zone-%E5%AF%B9%E5%BA%94%E7%9A%84%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%AD%E7%9A%84-pages-%E6%80%BB%E6%95%B0%EF%BC%88%E5%8C%85%E6%8B%AC%E7%A9%BA%E6%B4%9E%EF%BC%89"><span class="toc-text">spanned_pages： zone 对应的内存区域中的 pages 总数（包括空洞）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#present-pages%EF%BC%9A-zone-%E4%B8%AD%E5%AD%98%E5%9C%A8%E7%9A%84%E7%89%A9%E7%90%86%E9%A1%B5%E6%A1%86%E6%95%B0"><span class="toc-text">present_pages： zone 中存在的物理页框数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#managed-pages%EF%BC%9Azone-%E4%B8%AD-buddy-system-%E7%AE%A1%E7%90%86%E7%9A%84%E9%A1%B5%E9%9D%A2%E6%95%B0%E9%87%8F"><span class="toc-text">managed_pages：zone 中 buddy system 管理的页面数量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#free-area-%EF%BC%9Abuddy-system-%E6%8C%89%E7%85%A7-order-%E7%AE%A1%E7%90%86%E7%9A%84%E9%A1%B5%E9%9D%A2"><span class="toc-text">**free_area**：buddy system 按照 order 管理的页面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#flags%EF%BC%9A%E6%A0%87%E5%BF%97%E4%BD%8D-1"><span class="toc-text">flags：标志位</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#II-zone-%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">II.zone 的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#X86-32"><span class="toc-text">X86-32</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#X86-64"><span class="toc-text">X86-64</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x03-struct-pglist-data%EF%BC%9A%E8%8A%82%E7%82%B9"><span class="toc-text">0x03.struct pglist_data：节点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%A0%E4%B8%AA%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%AD%97%E6%AE%B5"><span class="toc-text">几个比较重要的字段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#node-zones-%EF%BC%9Anode-%E7%9A%84-zone-%E5%88%97%E8%A1%A8"><span class="toc-text">**node_zones**：node 的 zone 列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#node-zonelists%EF%BC%9A%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%97%B6%E5%A4%87%E7%94%A8-zone-%E7%9A%84%E6%90%9C%E7%B4%A2%E9%A1%BA%E5%BA%8F"><span class="toc-text">node_zonelists：内存分配时备用 zone 的搜索顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nr-zones%EF%BC%9Anode-%E4%B8%AD-zone-%E7%9A%84%E6%95%B0%E9%87%8F"><span class="toc-text">nr_zones：node 中 zone 的数量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#node-start-pfn%EF%BC%9Anode-%E7%9A%84%E8%B5%B7%E5%A7%8B%E9%A1%B5%E6%A1%86%E6%A0%87%E5%8F%B7"><span class="toc-text">node_start_pfn：node 的起始页框标号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#node-present-pages%EF%BC%9Anode-%E4%B8%AD%E7%89%A9%E7%90%86%E9%A1%B5%E7%9A%84%E6%80%BB%E6%95%B0%E9%87%8F"><span class="toc-text">node_present_pages：node 中物理页的总数量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unsigned-long-node-spanned-pages%EF%BC%9A-node-%E4%B8%AD%E7%89%A9%E7%90%86%E9%A1%B5%E7%9A%84%E6%80%BB%E5%A4%A7%E5%B0%8F"><span class="toc-text">unsigned long node_spanned_pages： node 中物理页的总大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#node-id%EF%BC%9Anode-%E7%9A%84%E6%A0%87%E5%8F%B7"><span class="toc-text">node_id：node 的标号</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#node-%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%EF%BC%9A%E5%85%A8%E5%B1%80%E6%95%B0%E7%BB%84-node-data"><span class="toc-text">node 存储方式：全局数组 node_data[]</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#node-%E7%8A%B6%E6%80%81%EF%BC%9A%E5%85%A8%E5%B1%80%E6%95%B0%E7%BB%84-node-states"><span class="toc-text">node 状态：全局数组 node_states[]</span></a></li></ol></li></ol>
      
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
      <div class="comments-container">
        




  
    <script async type="text/javascript" src="/plugins/valine.min.js" onload="loadValineSuc(this)"></script>
  

  <div id="vcomments"></div>

  <script>
    function loadValineSuc() {
      new Valine({
        el: '#vcomments',
        appId: 'ICj6cPRQWFTNiOttBHlzxnIv-gzGzoHsz',
        appKey: 'tuvJh3xYxPFcW2JB6K26RKP2',
        placeholder: '说点什么呗...',
        avatar: 'retro',
        lang: 'zh-CN'
      })
    }
  </script>

    <style>
      .comments-container .v .vempty {
        display: none!important;
      }
    </style>




      </div>
    
  </div>


        
<div class="footer">
  <div class="social">
    <ul>
      
        <li>
          <a title="github" target="_blank" rel="noopener" href="https://github.com/arttnba3">
            <i class="iconfont icon-github"></i>
          </a>
        </li>
      
        <li>
          <a title="email" href="mailto:arttnba@gmail.com">
            <i class="iconfont icon-envelope"></i>
          </a>
        </li>
      
        <li>
          <a title="twitter" target="_blank" rel="noopener" href="https://twitter.com/arttnba3">
            <i class="iconfont icon-twitter"></i>
          </a>
        </li>
      
        <li>
          <a title="rss" href="/atom.xml">
            <i class="iconfont icon-rss"></i>
          </a>
        </li>
      
    </ul>
  </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/arttnba3">Copyright © 2022 arttnba3</a>
        
    </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Theme by Oranges | Powered by Hexo</a>
        
    </div>
  
</div>

      </div>

      <div class="tools-bar">
        <div class="back-to-top tools-bar-item hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



        
  <div class="search-icon tools-bar-item" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-title">
        <span class="search-icon-input">
          <a href="javascript: void(0)">
            <i class="iconfont icon-search"></i>
          </a>
        </span>
        
          <input type="text" class="search-input" id="search-input" placeholder="搜索...">
        
        <span class="search-close-icon" id="search-close-icon">
          <a href="javascript: void(0)">
            <i class="iconfont icon-close"></i>
          </a>
        </span>
      </div>
      <div class="search-result" id="search-result"></div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    inputArea.onclick = function() {
      getSearchFile()
      this.onclick = null
    }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        // inputArea.focus()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'>首次搜索，正在载入索引文件，请稍后……<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + orig_data_title + "</a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<p class=\"search-result-abstract\">" + match_content + "...</p>"
                }
                str += "</li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>没有找到内容，请尝试更换检索词。<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>未找到search.xml文件，具体请参考：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>请求失败，尝试重新刷新页面或稍后重试。<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




        
  <div class="tools-bar-item theme-icon" id="switch-color-scheme">
    <a href="javascript: void(0)">
      <i id="theme-icon" class="iconfont icon-moon"></i>
    </a>
  </div>

  
<script src="/js/colorscheme.js"></script>





        
  
    <div class="share-icon tools-bar-item">
      <a href="javascript: void(0)" id="share-icon">
        <i class="iconfont iconshare"></i>
      </a>
      <div class="share-content hidden">
        
          <a class="share-item" href="https://twitter.com/intent/tweet?text=' + %E3%80%90OS.0x02%E3%80%91Linux%20Kernel%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%B5%85%E6%9E%90%20I%20-%20%E9%A1%B5%E3%80%81%E5%8C%BA%E3%80%81%E8%8A%82%E7%82%B9 + '&url=' + http%3A%2F%2Fblog.arttnba3.cn%2F2021%2F11%2F28%2FOS-0X02-LINUX-KERNEL-MEMORY-5.11-PART-I%2F + '" target="_blank" title="Twitter">
            <i class="iconfont icon-twitter"></i>
          </a>
        
        
          <a class="share-item" href="https://www.facebook.com/sharer.php?u=http://blog.arttnba3.cn/2021/11/28/OS-0X02-LINUX-KERNEL-MEMORY-5.11-PART-I/" target="_blank" title="Facebook">
            <i class="iconfont icon-facebooksquare"></i>
          </a>
        
      </div>
    </div>
  
  
<script src="/js/shares.js"></script>



      </div>
    </div>
  </body>
</html>
