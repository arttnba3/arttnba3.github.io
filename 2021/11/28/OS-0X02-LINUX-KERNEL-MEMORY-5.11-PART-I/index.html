

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/avatar.png">
  <link rel="icon" href="/img/avatar.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="arttnba3">
  <meta name="keywords" content="">
  
    <meta name="description" content="无内鬼，来点内存条">
<meta property="og:type" content="article">
<meta property="og:title" content="【OS.0x02】Linux Kernel 内存管理浅析 I - 页、区、节点">
<meta property="og:url" content="http://blog.arttnba3.cn/2021/11/28/OS-0X02-LINUX-KERNEL-MEMORY-5.11-PART-I/index.html">
<meta property="og:site_name" content="arttnba3&#39;s blog">
<meta property="og:description" content="无内鬼，来点内存条">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/11/23/q6jTAJkU9XuCHWV.png">
<meta property="article:published_time" content="2021-11-27T18:45:29.000Z">
<meta property="article:modified_time" content="2022-08-18T17:46:43.739Z">
<meta property="article:author" content="arttnba3">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="学习札记">
<meta property="article:tag" content="Linux Kernel">
<meta property="article:tag" content="内存管理">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://i.loli.net/2021/11/23/q6jTAJkU9XuCHWV.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>【OS.0x02】Linux Kernel 内存管理浅析 I - 页、区、节点 - arttnba3&#39;s blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"blog.arttnba3.cn","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":"§"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="arttnba3's blog" type="application/atom+xml">
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 80vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>arttnba3&#39;s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/atom.xml">
                <i class="iconfont icon-rss"></i>
                rss
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://i.loli.net/2021/11/28/KcHILforOySi8YR.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="【OS.0x02】Linux Kernel 内存管理浅析 I - 页、区、节点"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2021-11-28 02:45" pubdate>
          2021年11月28日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          32k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          268 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
        <div class="scroll-down-bar">
          <i class="iconfont icon-arrowdown"></i>
        </div>
      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">【OS.0x02】Linux Kernel 内存管理浅析 I - 页、区、节点</h1>
            
              <p class="note note-info">
                
                  
                    本文最后更新于：2022年8月19日 凌晨
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <p>无内鬼，来点内存条</p>
<span id="more"></span>

<h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><p>本系列文章将通过 Linux 5.11 的源代码简要分析 Linux 内核中的<strong>内存管理</strong>（memory management）部分，笔者选择采用自底向上的方式来逐层分析，本篇文章便从最基础的<strong>页框</strong>开始进行分析</p>
<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>这是一张十分经典的 _Overview_，自顶向下是</p>
<ul>
<li><strong>节点</strong>（node，对应结构体 pgdata_list）</li>
<li><strong>区</strong>（zone，对应结构体 zone，图上展示了三种类型的 zone）</li>
<li><strong>页</strong>（page，对应结构体 page）</li>
</ul>
<p><img src="https://i.loli.net/2021/11/28/OrsvS6GTMgPLx5E.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>我们可以通过 <code>cat /proc/buddyinfo</code> 与 <code>cat /proc/pagetypeinfo</code> 查看页面相关信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs shell">arttnba3@ubuntu:~$ sudo cat /proc/buddyinfo <br>Node 0, zone      DMA      0      1      1      0      2      1      1      0      1      2      2 <br>Node 0, zone    DMA32   8706   1386    748    543    232     48     39      9      0      0      0 <br>Node 0, zone   Normal  15391   3317    877    826    221     77     14      2      0      0      0 <br>arttnba3@ubuntu:~$ sudo cat /proc/pagetypeinfo <br>Page block order: 9<br>Pages per block:  512<br><br>Free pages count per migrate type at order       0      1      2      3      4      5      6      7      8      9     10 <br>Node    0, zone      DMA, type    Unmovable      0      1      1      0      2      1      1      0      1      1      0 <br>Node    0, zone      DMA, type      Movable      0      0      0      0      0      0      0      0      0      1      2 <br>Node    0, zone      DMA, type  Reclaimable      0      0      0      0      0      0      0      0      0      0      0 <br>Node    0, zone      DMA, type   HighAtomic      0      0      0      0      0      0      0      0      0      0      0 <br>Node    0, zone      DMA, type      Isolate      0      0      0      0      0      0      0      0      0      0      0 <br>Node    0, zone    DMA32, type    Unmovable    254    166     54     33     18      8     11      1      0      0      0 <br>Node    0, zone    DMA32, type      Movable   6762    740    535    278     43      3      3      2      0      0      0 <br>Node    0, zone    DMA32, type  Reclaimable   1690    480    159    232    171     37     25      6      0      0      0 <br>Node    0, zone    DMA32, type   HighAtomic      0      0      0      0      0      0      0      0      0      0      0 <br>Node    0, zone    DMA32, type      Isolate      0      0      0      0      0      0      0      0      0      0      0 <br>Node    0, zone   Normal, type    Unmovable     27     30     15      0      1      4      4      2      0      0      0 <br>Node    0, zone   Normal, type      Movable  12963   3039    806    727    197     68     10      0      0      0      0 <br>Node    0, zone   Normal, type  Reclaimable   1135    251     56     99     23      5      0      0      0      0      0 <br>Node    0, zone   Normal, type   HighAtomic      0      0      0      0      0      0      0      0      0      0      0 <br>Node    0, zone   Normal, type      Isolate      0      0      0      0      0      0      0      0      0      0      0 <br><br>Number of blocks type     Unmovable      Movable  Reclaimable   HighAtomic      Isolate <br>Node 0, zone      DMA            3            5            0            0            0 <br>Node 0, zone    DMA32           60         1382           86            0            0 <br>Node 0, zone   Normal          245         4270           93            0            0<br></code></pre></td></tr></table></figure>

<h1 id="0x01-struct-page：页"><a href="#0x01-struct-page：页" class="headerlink" title="0x01.struct page：页"></a>0x01.struct page：页</h1><p>Linux kernel 中使用 <code>page</code> 结构体来表示一个物理页框，<strong>每个物理页框都有着一个对应的 page 结构体</strong>，为了节省内存空间，其定义中使用了大量的联合体</p>
<p>一个 page 结构体的大小为 64B，若是每个物理页框大小为 4KB，则仅需要牺牲 <code>1.5625%</code> 的空间存储 page 结构体</p>
<p>在这里给出一张 struct page 的overview</p>
<blockquote>
<p>网上找的图，侵删</p>
</blockquote>
<p><img src="https://i.loli.net/2021/11/25/MjWZmba9SLH1xIO.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>该结构体定义于内核源码 <code>include/linux/mm_types.h</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> &#123;</span><br>    <span class="hljs-comment">// flags 用以存储该 page 的标志位，每一个位表示一种状态，故一张页可以有 32 种状态，这些状态定义于 include/linux/page-flags.h 中</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;        <span class="hljs-comment">/* 原子变量 flag，也可能被异步更新 */</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 该联合体中 5 个 word（32 位系统20字节/64位系统40字节）是可用的</span><br><span class="hljs-comment">     * 警告：第一个 word 的 0 bit 供 PageTail()使用</span><br><span class="hljs-comment">     * 这意味着其他用户使用该结构体时【禁止】使用该 bit</span><br><span class="hljs-comment">     * 以避免碰撞和误判 PageTail().</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>    <span class="hljs-comment">/* 页缓存与匿名页 */</span><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * @lru: Pageout 链表, 例如 active_list 便由</span><br><span class="hljs-comment">             * lruvec-&gt;lru_lock 保护。  </span><br><span class="hljs-comment">             * 有时会被页所有者作为常规链表使用。</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">lru</span>;</span><br>            <span class="hljs-comment">/* See page-flags.h for PAGE_MAPPING_FLAGS */</span><br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">address_space</span> *<span class="hljs-title">mapping</span>;</span><br>            <span class="hljs-type">pgoff_t</span> index;        <span class="hljs-comment">/* 在映射的虚拟空间（vma_area）内的偏移 */</span><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * @private: 私有映射的非透明数据</span><br><span class="hljs-comment">             * 在 PagePrivate 中通常用于 buffer_heads.</span><br><span class="hljs-comment">             * 在 PageSwapCache 中用于 swp_entry_t</span><br><span class="hljs-comment">             * 在 PageBuddy 中指定在 buddy system 中的次序</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> private;<br>        &#125;;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>    <span class="hljs-comment">/* page_pool used by netstack */</span><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * @dma_addr: 在 32 位机器上仍可能需要 64 位的空间</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-type">dma_addr_t</span> dma_addr;<br>        &#125;;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>    <span class="hljs-comment">/* 供 slab, slob and slub 使用 */</span><br>            <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>                <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">slab_list</span>;</span><br>                <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>    <span class="hljs-comment">/* Partial pages */</span><br>                    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">next</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_64BIT</span><br>                    <span class="hljs-type">int</span> pages;    <span class="hljs-comment">/* 剩余的页数量 */</span><br>                    <span class="hljs-type">int</span> pobjects;    <span class="hljs-comment">/* 近似计数 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>                    <span class="hljs-type">short</span> <span class="hljs-type">int</span> pages;<br>                    <span class="hljs-type">short</span> <span class="hljs-type">int</span> pobjects;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>                &#125;;<br>            &#125;;<br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache</span> *<span class="hljs-title">slab_cache</span>;</span> <span class="hljs-comment">/* 不在 slob 中使用 */</span><br>            <span class="hljs-comment">/* 两个 word 的范围 */</span><br>            <span class="hljs-type">void</span> *freelist;        <span class="hljs-comment">/* 第一个空闲对象 */</span><br>            <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>                <span class="hljs-type">void</span> *s_mem;    <span class="hljs-comment">/* slab: first object */</span><br>                <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> counters;        <span class="hljs-comment">/* SLUB */</span><br>                <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>            <span class="hljs-comment">/* SLUB */</span><br>                    <span class="hljs-type">unsigned</span> inuse:<span class="hljs-number">16</span>;<br>                    <span class="hljs-type">unsigned</span> objects:<span class="hljs-number">15</span>;<br>                    <span class="hljs-type">unsigned</span> frozen:<span class="hljs-number">1</span>;<br>                &#125;;<br>            &#125;;<br>        &#125;;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>    <span class="hljs-comment">/* 复合页的尾页 */</span><br>            <span class="hljs-comment">// 复合页 （compound page）即为将多个物理连续页框视作一个大页</span><br>            <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> compound_head;    <span class="hljs-comment">/* Bit zero is set */</span><br><br>            <span class="hljs-comment">/* First tail page only */</span><br>            <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> compound_dtor;<br>            <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> compound_order;<br>            <span class="hljs-type">atomic_t</span> compound_mapcount;<br>            <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> compound_nr; <span class="hljs-comment">/* 1 &lt;&lt; compound_order */</span><br>        &#125;;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>    <span class="hljs-comment">/* Second tail page of compound page */</span><br>            <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> _compound_pad_1;    <span class="hljs-comment">/* compound_head */</span><br>            <span class="hljs-type">atomic_t</span> hpage_pinned_refcount;<br>            <span class="hljs-comment">/* For both global and memcg */</span><br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">deferred_list</span>;</span><br>        &#125;;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>    <span class="hljs-comment">/* 页表页面 */</span><br>            <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> _pt_pad_1;    <span class="hljs-comment">/* compound_head */</span><br>            <span class="hljs-type">pgtable_t</span> pmd_huge_pte; <span class="hljs-comment">/* protected by page-&gt;ptl */</span><br>            <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> _pt_pad_2;    <span class="hljs-comment">/* mapping */</span><br>            <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>                <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">pt_mm</span>;</span> <span class="hljs-comment">/* 用于 x86 的全局目录表（pgd） */</span><br>                <span class="hljs-type">atomic_t</span> pt_frag_refcount; <span class="hljs-comment">/* 用于 powerpc 架构 */</span><br>            &#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> ALLOC_SPLIT_PTLOCKS</span><br>            <span class="hljs-type">spinlock_t</span> *ptl;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>            <span class="hljs-type">spinlock_t</span> ptl;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>        &#125;;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>    <span class="hljs-comment">/* ZONE_DEVICE pages */</span><br>            <span class="hljs-comment">/** @pgmap: Points to the hosting device page map. */</span><br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dev_pagemap</span> *<span class="hljs-title">pgmap</span>;</span><br>            <span class="hljs-type">void</span> *zone_device_data;<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * ZONE_DEVICE private pages are counted as being</span><br><span class="hljs-comment">             * mapped so the next 3 words hold the mapping, index,</span><br><span class="hljs-comment">             * and private fields from the source anonymous or</span><br><span class="hljs-comment">             * page cache page while the page is migrated to device</span><br><span class="hljs-comment">             * private memory.</span><br><span class="hljs-comment">             * ZONE_DEVICE MEMORY_DEVICE_FS_DAX pages also</span><br><span class="hljs-comment">             * use the mapping, index, and private fields when</span><br><span class="hljs-comment">             * pmem backed DAX files are mapped.</span><br><span class="hljs-comment">             */</span><br>        &#125;;<br><br>        <span class="hljs-comment">/** @rcu_head: 你可以通过该成员以通过 RCU 释放内存页 */</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rcu_head</span> <span class="hljs-title">rcu_head</span>;</span><br>    &#125;;<br><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span>        <span class="hljs-comment">/* 这个联合体占用四个字节 */</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 若是这个页被映射到用户空间, 记录该页被页表引用的次数</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">// 每个进程有其独立的页表，故可以理解为该值记录了该页被多少个进程共享，初始值为 -1</span><br>        <span class="hljs-type">atomic_t</span> _mapcount;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 若是该页既不是 PageSlab 也没有被映射到用户空间，</span><br><span class="hljs-comment">         * 则该值会帮助决定该页的作用。</span><br><span class="hljs-comment">         * 该处的页面类型列表参见 page-flags.h</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> page_type;<br><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> active;        <span class="hljs-comment">/* SLAB */</span><br>        <span class="hljs-type">int</span> units;            <span class="hljs-comment">/* SLOB */</span><br>    &#125;;<br><br>    <span class="hljs-comment">/* 使用计数. 【不要直接使用】. 参见 page_ref.h */</span><br>    <span class="hljs-type">atomic_t</span> _refcount;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_MEMCG</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> memcg_data;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 当机器上的所有内存都被映射到内核空间时,</span><br><span class="hljs-comment">     * 我们可以简单地计算其虚拟地址。</span><br><span class="hljs-comment">     * 在有着【高端内存（大于896MB）】的机器上，有的内存被动态地映射到内核</span><br><span class="hljs-comment">     * 虚拟空间中，因此我们需要一个地方来存储这个地址</span><br><span class="hljs-comment">     * 在 x86 机器上这个域可能占 16 bit 的空间 ... ;)</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 乘法计算较慢的架构可以在 asm/page.h 中定义 WANT_PAGE_VIRTUAL</span><br><span class="hljs-comment">     */</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(WANT_PAGE_VIRTUAL)</span><br>    <span class="hljs-type">void</span> *virtual;            <span class="hljs-comment">/* 内核虚拟地址 (若非 kmapped 则为 NULL, 即高端内存) */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* WANT_PAGE_VIRTUAL */</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> LAST_CPUPID_NOT_IN_PAGE_FLAGS</span><br>    <span class="hljs-type">int</span> _last_cpupid;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125; _struct_page_alignment;<br></code></pre></td></tr></table></figure>

<h2 id="I-几个比较重要的字段"><a href="#I-几个比较重要的字段" class="headerlink" title="I.几个比较重要的字段"></a>I.几个比较重要的字段</h2><p>简单讲讲其中几个重要的成员</p>
<h3 id="lru：LRU-链表节点"><a href="#lru：LRU-链表节点" class="headerlink" title="lru：LRU 链表节点"></a>lru：LRU 链表节点</h3><p>lru 即 <code>Least Recently Used</code>，在操作系统课程上我们已经学习了这个页面置换算法的概念，这里不再过多赘叙</p>
<p>在 Linux 内核中，page 结构体通过其 lru 字段组织成链表，如下图所示</p>
<p><img src="https://i.loli.net/2021/11/25/QbuxcXTWdzMari5.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>lru 成员是一个 <code>struct list_head</code> 类型，这是内核中通用的双向链表节点结构</p>
<h3 id="slab相关结构体"><a href="#slab相关结构体" class="headerlink" title="**slab相关结构体**"></a>**slab相关结构体**</h3><p>在 page 结构体中专门有着一个匿名结构体用于存放与 slab 相关的成员</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>    <span class="hljs-comment">/* 供 slab, slob and slub 使用 */</span><br>            <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>                <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">slab_list</span>;</span><br>                <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>    <span class="hljs-comment">/* Partial pages */</span><br>                    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">next</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_64BIT</span><br>                    <span class="hljs-type">int</span> pages;    <span class="hljs-comment">/* 剩余的页数量 */</span><br>                    <span class="hljs-type">int</span> pobjects;    <span class="hljs-comment">/* 近似计数 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>                    <span class="hljs-type">short</span> <span class="hljs-type">int</span> pages;<br>                    <span class="hljs-type">short</span> <span class="hljs-type">int</span> pobjects;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>                &#125;;<br>            &#125;;<br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache</span> *<span class="hljs-title">slab_cache</span>;</span> <span class="hljs-comment">/* 不在 slob 中使用 */</span><br>            <span class="hljs-comment">/* 两个 word 的范围 */</span><br>            <span class="hljs-type">void</span> *freelist;        <span class="hljs-comment">/* 第一个空闲对象 */</span><br>            <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>                <span class="hljs-type">void</span> *s_mem;    <span class="hljs-comment">/* slab: first object */</span><br>                <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> counters;        <span class="hljs-comment">/* SLUB */</span><br>                <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>            <span class="hljs-comment">/* SLUB */</span><br>                    <span class="hljs-type">unsigned</span> inuse:<span class="hljs-number">16</span>;<br>                    <span class="hljs-type">unsigned</span> objects:<span class="hljs-number">15</span>;<br>                    <span class="hljs-type">unsigned</span> frozen:<span class="hljs-number">1</span>;<br>                &#125;;<br>            &#125;;<br>        &#125;;<br></code></pre></td></tr></table></figure>

<p>Linux kernel 中的 slab allocator 一共有三种：slab、slob、slub，其中比较常用的是 slub 分配器，关于 slab allocator 将在后续的文章中进行更为详细的叙述，下图是一张 slub 分配器的 overview</p>
<p><img src="https://i.loli.net/2021/07/22/ivPnbsjHyI94m5z.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h3 id="flags：标志位"><a href="#flags：标志位" class="headerlink" title="flags：标志位"></a>flags：标志位</h3><p>即该页的标志位成员，用以表示该页所处在的状态，每一个位表示一种状态，故一张页可以有 32 种不同的状态，这些状态定义于 <code>include/linux/page-flags.h</code> 中，<strong>该字段与体系无关</strong></p>
<p>我们可以通过该头文件中定义的枚举类型获取相应的值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">pageflags</span> &#123;</span><br>    PG_locked,        <span class="hljs-comment">/* Page is locked. Don&#x27;t touch. */</span><br>    PG_referenced,<br>    PG_uptodate,<br>    PG_dirty,<br>    PG_lru,<br>    PG_active,<br>    PG_workingset,<br>    PG_waiters,        <span class="hljs-comment">/* Page has waiters, check its waitqueue. Must be bit #7 and in the same byte as &quot;PG_locked&quot; */</span><br>    PG_error,<br>    PG_slab,<br>    PG_owner_priv_1,    <span class="hljs-comment">/* Owner use. If pagecache, fs may use*/</span><br>    PG_arch_1,<br>    PG_reserved,<br>    PG_private,        <span class="hljs-comment">/* If pagecache, has fs-private data */</span><br>    PG_private_2,        <span class="hljs-comment">/* If pagecache, has fs aux data */</span><br>    PG_writeback,        <span class="hljs-comment">/* Page is under writeback */</span><br>    PG_head,        <span class="hljs-comment">/* A head page */</span><br>    PG_mappedtodisk,    <span class="hljs-comment">/* Has blocks allocated on-disk */</span><br>    PG_reclaim,        <span class="hljs-comment">/* To be reclaimed asap */</span><br>    PG_swapbacked,        <span class="hljs-comment">/* Page is backed by RAM/swap */</span><br>    PG_unevictable,        <span class="hljs-comment">/* Page is &quot;unevictable&quot;  */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_MMU</span><br>    PG_mlocked,        <span class="hljs-comment">/* Page is vma mlocked */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_ARCH_USES_PG_UNCACHED</span><br>    PG_uncached,        <span class="hljs-comment">/* Page has been mapped as uncached */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_MEMORY_FAILURE</span><br>    PG_hwpoison,        <span class="hljs-comment">/* hardware poisoned page. Don&#x27;t touch */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_IDLE_PAGE_TRACKING) &amp;&amp; defined(CONFIG_64BIT)</span><br>    PG_young,<br>    PG_idle,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_64BIT</span><br>    PG_arch_2,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    __NR_PAGEFLAGS,<br><br>    <span class="hljs-comment">/* Filesystems */</span><br>    PG_checked = PG_owner_priv_1,<br><br>    <span class="hljs-comment">/* SwapBacked */</span><br>    PG_swapcache = PG_owner_priv_1,    <span class="hljs-comment">/* Swap page: swp_entry_t in private */</span><br><br>    <span class="hljs-comment">/* Two page bits are conscripted by FS-Cache to maintain local caching</span><br><span class="hljs-comment">     * state.  These bits are set on pages belonging to the netfs&#x27;s inodes</span><br><span class="hljs-comment">     * when those inodes are being locally cached.</span><br><span class="hljs-comment">     */</span><br>    PG_fscache = PG_private_2,    <span class="hljs-comment">/* page backed by cache */</span><br><br>    <span class="hljs-comment">/* XEN */</span><br>    <span class="hljs-comment">/* Pinned in Xen as a read-only pagetable page. */</span><br>    PG_pinned = PG_owner_priv_1,<br>    <span class="hljs-comment">/* Pinned as part of domain save (see xen_mm_pin_all()). */</span><br>    PG_savepinned = PG_dirty,<br>    <span class="hljs-comment">/* Has a grant mapping of another (foreign) domain&#x27;s page. */</span><br>    PG_foreign = PG_owner_priv_1,<br>    <span class="hljs-comment">/* Remapped by swiotlb-xen. */</span><br>    PG_xen_remapped = PG_owner_priv_1,<br><br>    <span class="hljs-comment">/* SLOB */</span><br>    PG_slob_free = PG_private,<br><br>    <span class="hljs-comment">/* Compound pages. Stored in first tail page&#x27;s flags */</span><br>    PG_double_map = PG_workingset,<br><br>    <span class="hljs-comment">/* non-lru isolated movable page */</span><br>    PG_isolated = PG_reclaim,<br><br>    <span class="hljs-comment">/* Only valid for buddy pages. Used to track pages that are reported */</span><br>    PG_reported = PG_uptodate,<br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>PG_locked</code>：该页已被上锁，说明此时该页正在被使用</li>
<li><code>PG_referenced</code>：该页刚刚被访问过；该标志位与 PG_reclaim 标志位共同被用于匿名与文件备份缓存的页面回收</li>
<li><code>PG_uptodate</code>：该页处在最新状态（up-to-date）；当对该页完成一次读取时，该页便变更为 up-to-date 状态，除非发生了磁盘 IO 错误</li>
<li><code>PG_dirty</code>：该页为<strong>脏页</strong>，即该页的内容已被修改，应当尽快将内容写回磁盘上</li>
<li><code>PG_lru</code>：该页处在一个 LRU 链表上</li>
<li><code>PG_active</code>：该页面位于活跃 lru 链表中</li>
<li><code>PG_workingset</code>：该页位于某个进程的 working set（工作集，即一个进程同时使用的内存数量，例如一个进程可能分配了114514MB内存，但是在同一时刻只使用其中的1919MB，这就是工作集）中</li>
<li><code>PG_waiters</code>：有进程在等待该页面</li>
<li><code>PG_error</code>：该页在 I&#x2F;O 过程中出现了差错</li>
<li><code>PG_slab</code>：该页由 slab 使用</li>
<li><code>PG_owner_priv_1</code>：该页由其所有者使用，若是作为 pagecache 页面，则可能是被文件系统使用</li>
<li><code>PG_arch_1</code>：该标志位与体系结构相关联</li>
<li><code>PG_reserved</code>：该页被保留，不能够被 swap out（内核会将不活跃的页交换到磁盘上）</li>
<li><code>PG_private</code> &amp;&amp; <code>PG_private2</code>：该页拥有私有数据（private 字段）</li>
<li><code>PG_writeback</code>：该页正在被写到磁盘上</li>
<li><code>PG_head</code>：在内核中有时需要将多个页组成一个 compound pages，而设置该状态时表明该页是 compound pages 的第一个页</li>
<li><code>PG_mappedtodisk</code>：该页被映射到硬盘中</li>
<li><code>PG_reclaim</code>：该页可以被回收</li>
<li><code>PG_swapbacked</code>：该页的后备存储器为 swap&#x2F;RAM</li>
<li><code>PG_unevictable</code>：该页不可被回收（被锁），且会出现在 <code>LRU_UNEVICTABLE</code> 链表中</li>
<li><code>PG_mlocked</code>：该页被对应的 vma 上锁（通常是系统调用 mlock）</li>
<li><code>PG_uncached</code>：该页被设置为不可缓存</li>
<li><code>PG_hwpoison</code>：硬件相关的标志位</li>
<li><code>PG_young</code>：</li>
<li><code>PG_idle</code>：</li>
<li><code>PG_arch_2</code>：64位下的体系结构相关标志位</li>
</ul>
<h4 id="flags-内存复用"><a href="#flags-内存复用" class="headerlink" title="flags 内存复用"></a>flags 内存复用</h4><p>为了节省空间，flags 字段除了用作标志位外还给其他结构使用，其划分的形式其实与内核配置的内存模型有关，在 <code>include\linux\page-flags-layout.h</code>  文件中描述了五种划分形式（其实是三大种）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * page-&gt;flags layout:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * There are five possibilities for how page-&gt;flags get laid out.  The first</span><br><span class="hljs-comment"> * pair is for the normal case without sparsemem. The second pair is for</span><br><span class="hljs-comment"> * sparsemem when there is plenty of space for node and section information.</span><br><span class="hljs-comment"> * The last is when there is insufficient space in page-&gt;flags and a separate</span><br><span class="hljs-comment"> * lookup is necessary.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * No sparsemem or sparsemem vmemmap: |       NODE     | ZONE |             ... | FLAGS |</span><br><span class="hljs-comment"> *      &quot; plus space for last_cpupid: |       NODE     | ZONE | LAST_CPUPID ... | FLAGS |</span><br><span class="hljs-comment"> * classic sparse with space for node:| SECTION | NODE | ZONE |             ... | FLAGS |</span><br><span class="hljs-comment"> *      &quot; plus space for last_cpupid: | SECTION | NODE | ZONE | LAST_CPUPID ... | FLAGS |</span><br><span class="hljs-comment"> * classic sparse no space for node:  | SECTION |     ZONE    | ... | FLAGS |</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>

<h5 id="非-sparse-内存模式-x2F-sparse-vmemmap-内存模式"><a href="#非-sparse-内存模式-x2F-sparse-vmemmap-内存模式" class="headerlink" title="非 sparse 内存模式 &#x2F; sparse vmemmap 内存模式"></a>非 sparse 内存模式 &#x2F; sparse vmemmap 内存模式</h5><p>如下图所示，低位用作该 page 的 flag，高位分别标识其归属的 zone， node id（非 NUMA 系统中为0），中间剩余的位保留</p>
<p><img src="https://i.loli.net/2021/11/25/8J9pm3n1eZuTKi6.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>这种形式中若是开启了 <code>last_cpuid</code> 则是下面这个样子：</p>
<p><img src="https://i.loli.net/2021/11/25/xhNpH3vkmli8EXt.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h5 id="sparse-内存模式"><a href="#sparse-内存模式" class="headerlink" title="sparse 内存模式"></a>sparse 内存模式</h5><p>如下图所示，相比起第一种形式多了一个 SECTION 字段标识其归属的 <code>mem_section</code></p>
<p><img src="https://i.loli.net/2021/11/25/CETbQSKwV8er5OR.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>若是开启了 <code>last_cpuid</code> 则是下面这个样子</p>
<p><img src="https://i.loli.net/2021/11/25/KDSHvF4LjOXpIcE.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h5 id="没有-Node-的-sparse-内存模式"><a href="#没有-Node-的-sparse-内存模式" class="headerlink" title="没有 Node 的 sparse 内存模式"></a>没有 Node 的 sparse 内存模式</h5><p>主要是针对非 NUMA 设计的，在这种模式下取消了 Node 结构</p>
<p><img src="https://i.loli.net/2021/11/25/QiJChHBdvARktOs.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h3 id="mapcount：映射计数"><a href="#mapcount：映射计数" class="headerlink" title="_mapcount：映射计数"></a>_mapcount：映射计数</h3><p>记录该页被页表映射的次数，每个进程有其独立的页表，故可以理解为该值记录了该页被多少个进程共享，其初始值为 -1</p>
<p>由于这是一个联合体，若是该页既不是 PageSlab 也没有被映射到用户空间，则为 page_type 字段，具体说明定义于 <code>/include/linux/page-flags.h</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * For pages that are never mapped to userspace (and aren&#x27;t PageSlab),</span><br><span class="hljs-comment"> * page_type may be used.  Because it is initialised to -1, we invert the</span><br><span class="hljs-comment"> * sense of the bit, so __SetPageFoo *clears* the bit used for PageFoo, and</span><br><span class="hljs-comment"> * __ClearPageFoo *sets* the bit used for PageFoo.  We reserve a few high and</span><br><span class="hljs-comment"> * low bits so that an underflow or overflow of page_mapcount() won&#x27;t be</span><br><span class="hljs-comment"> * mistaken for a page type value.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PAGE_TYPE_BASE    0xf0000000</span><br><span class="hljs-comment">/* Reserve        0x0000007f to catch underflows of page_mapcount */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PAGE_MAPCOUNT_RESERVE    -128</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PG_buddy    0x00000080</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PG_offline    0x00000100</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PG_table    0x00000200</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PG_guard    0x00000400</span><br></code></pre></td></tr></table></figure>

<h3 id="refcount：引用计数"><a href="#refcount：引用计数" class="headerlink" title="_refcount：引用计数"></a>_refcount：引用计数</h3><p>该字段用作该页面<strong>在内核中</strong>的引用计数器，初始时页面为空闲状态，该计数器为 0，每当该页面被分配引用时计数器会 + 1，被其他页面进行引用时也会 + 1</p>
<p>当引用计数器为 0 时表示该页面为空闲状态或即将要被释放，若大于 0 则表示正在被使用，暂时不会释放</p>
<p>内核中提供了两个函数 <code>get_page()</code>与 <code>put_page()</code> 来进行引用计数的增减，后者在引用计数器为 1 时会调用 <code>__put_single_page()</code> 释放该页面（1-&gt;0，该页面已空闲）</p>
<h3 id="virtual：虚拟地址"><a href="#virtual：虚拟地址" class="headerlink" title="**virtual：虚拟地址**"></a>**virtual：虚拟地址**</h3><p>该字段为该物理页框对应的的<strong>虚拟地址</strong>，那么这里又要放上这张经典的图：</p>
<p><img src="https://i.loli.net/2021/11/23/q6jTAJkU9XuCHWV.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>每一个 struct page 对应一个物理页框，那么这个 virtual 字段其实就是<strong>上图的反向映射</strong></p>
<h2 id="II-不同内存模型下的-struct-page-存储方式"><a href="#II-不同内存模型下的-struct-page-存储方式" class="headerlink" title="II.不同内存模型下的 struct page 存储方式"></a>II.不同内存模型下的 struct page 存储方式</h2><p>Linux 提供了三种内存模型，定义于 <code>include/asm-generic/memory_model.h</code> 中，如下图所示（偷的图，侵删）：</p>
<p><img src="https://i.loli.net/2021/11/25/wLzFuCB5n1DAIY7.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>内存模型在编译期就会被确定下来，目前常用的是 <code>Sparse Memory</code> 模型，即离散内存模型</p>
<h3 id="Flat-Memory"><a href="#Flat-Memory" class="headerlink" title="Flat Memory"></a>Flat Memory</h3><p>平滑内存模型。物理内存地址连续，有一个<strong>全局变量</strong> <code>mem_map</code> ——由一个大的 struct page 数组直接对应现有的物理内存</p>
<h3 id="Discontiguous-Memory"><a href="#Discontiguous-Memory" class="headerlink" title="Discontiguous Memory"></a>Discontiguous Memory</h3><p>非连续性内存模型。主要针对内存中存在空洞的情况。</p>
<p>对于每一段连续的物理内存，都有一个 <code>pglist_data</code> 结构体进行对应，其成员 <code>node_mem_map</code> 为一个 struct page 指针，指向一个 page 结构体数组，由该结构体对应到该段连续物理内存</p>
<p>有一个<strong>全局变量</strong> <code>node_data</code> 为一个 pglist_data 指针数组，其中存放着指向每一个 pglist_data 的指针，该数组的大小为 <code>MAX_NUMNODES</code></p>
<h3 id="Sparse-Memory"><a href="#Sparse-Memory" class="headerlink" title="Sparse Memory"></a>Sparse Memory</h3><p>离散内存模型。在一个 mem_section 结构体中存在一个 <code>section_mem_map</code> 成员指向一个 struct page 数组对应一段连续的物理内存，即将内存按照 section 为单位进行分段</p>
<p>存在一个全局指针数组 <code>mem_section</code> （与结构体同名）存放所有的 <code>mem_section</code> 指针，指向<strong>理论上支持的内存空间</strong>，每个 section 对应的物理内存不一定存在，若不存在则此时该 section 的指针为 NULL</p>
<p>这种模型<strong>支持内存的热拔插</strong></p>
<blockquote>
<p>图还是偷的，侵删</p>
</blockquote>
<p><img src="https://i.loli.net/2021/11/25/RN47OEoaM31xQhA.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h4 id="mem-section-结构体"><a href="#mem-section-结构体" class="headerlink" title="mem_section 结构体"></a>mem_section 结构体</h4><p>该结构体定义于 <code>/include/linux/mmzone.h</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mem_section</span> &#123;</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 逻辑上这指向一个 pages 结构体数组，</span><br><span class="hljs-comment">     * 然而，他的存储还有一些别的魔力</span><br><span class="hljs-comment">     * (参见 sparse.c::sparse_init_one_section())</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 此外，在引导的早期，我们对此处节区的位置的</span><br><span class="hljs-comment">     * 节点的id进行编码，以指引分配。</span><br><span class="hljs-comment">     * (参见 sparse.c::memory_present())</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 将之声明为一个 unsigned long，至少可以让人在</span><br><span class="hljs-comment">     * 错误使用之前完成一次（类型）转换</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> section_mem_map;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mem_section_usage</span> *<span class="hljs-title">usage</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_PAGE_EXTENSION</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 若是 SPARSEMEM, pgdat 没有 page_ext 指针.</span><br><span class="hljs-comment">     * 我们使用 section. (关于这个，参见 page_ext.h)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page_ext</span> *<span class="hljs-title">page_ext</span>;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> pad;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 警告: mem_section 的大小必须是2的幂次方， 以便于</span><br><span class="hljs-comment">     * 让计算与使用 SECTION_ROOT_MASK 有意义</span><br><span class="hljs-comment">     */</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="CONFIG-SPARSEMEM-EXTREME-：动态分配-mem-section-数组"><a href="#CONFIG-SPARSEMEM-EXTREME-：动态分配-mem-section-数组" class="headerlink" title="_CONFIG_SPARSEMEM_EXTREME_：动态分配 mem_section 数组"></a>_CONFIG_SPARSEMEM_EXTREME_：动态分配 <code>mem_section</code> 数组</h4><p>内核编译选项之一，若开启了则连 <code>mem_section</code> 数组的空间也是动态分配的，在 section 较多的情况下通常会开启这个编译选项</p>
<h4 id="全局-mem-section-数组"><a href="#全局-mem-section-数组" class="headerlink" title="全局 mem_section 数组"></a>全局 mem_section 数组</h4><p>该数组中存放着指向所有 mem_section 结构体的指针，定义于 <code>/mm/sparse.c</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SPARSEMEM_EXTREME</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mem_section</span> **<span class="hljs-title">mem_section</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mem_section</span> <span class="hljs-title">mem_section</span>[<span class="hljs-title">NR_SECTION_ROOTS</span>][<span class="hljs-title">SECTIONS_PER_ROOT</span>]</span><br><span class="hljs-class">    ____<span class="hljs-title">cacheline_internodealigned_in_smp</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>

<p>若未开启 <em>CONFIG_SPARSEMEM_EXTREME</em> 编译选项则 mem_section 为一个常规的<strong>二维数组</strong>，否则为一个<strong>二级指针</strong>，其所指向空间内存动态分配</p>
<p>对于后一种情况，其结构如下图所示：</p>
<p><img src="https://i.loli.net/2021/12/03/wVpetDxj5gRlfWN.png" srcset="/img/loading.gif" lazyload alt="自己画的图.png"></p>
<h4 id="PFN-与-page-结构体间的转换"><a href="#PFN-与-page-结构体间的转换" class="headerlink" title="PFN 与 page 结构体间的转换"></a>PFN 与 page 结构体间的转换</h4><p>kernel 中提供了两个用以在 PFN（Page Frame Numer） 与 page 结构体之间进行转换的宏，定义于 <code>/include/asm-generic/memory_model.h</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(CONFIG_SPARSEMEM)</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Note: 节区的 mem_map 被编码以表示其 start_pfn.</span><br><span class="hljs-comment"> * section[i].section_mem_map == mem_map&#x27;s address - start_pfn;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __page_to_pfn(pg)                    \</span><br><span class="hljs-meta">(&#123;    const struct page *__pg = (pg);                \</span><br><span class="hljs-meta">    int __sec = page_to_section(__pg);            \</span><br><span class="hljs-meta">    (unsigned long)(__pg - __section_mem_map_addr(__nr_to_section(__sec)));    \</span><br><span class="hljs-meta">&#125;)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __pfn_to_page(pfn)                \</span><br><span class="hljs-meta">(&#123;    unsigned long __pfn = (pfn);            \</span><br><span class="hljs-meta">    struct mem_section *__sec = __pfn_to_section(__pfn);    \</span><br><span class="hljs-meta">    __section_mem_map_addr(__sec) + __pfn;        \</span><br><span class="hljs-meta">&#125;)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* CONFIG_FLATMEM/DISCONTIGMEM/SPARSEMEM */</span></span><br></code></pre></td></tr></table></figure>

<p>在这里我们需要注意一点：<strong>mem_section 结构体的 section_mem_map 中存储的为 page 数组与 PFN 的差值</strong></p>
<h5 id="（1）page-结构体到-PFN：page-结构体地址减去对应-mem-section-gt-section-mem-map"><a href="#（1）page-结构体到-PFN：page-结构体地址减去对应-mem-section-gt-section-mem-map" class="headerlink" title="（1）page 结构体到 PFN：page 结构体地址减去对应 mem_section-&gt;section_mem_map"></a>（1）page 结构体到 PFN：page 结构体地址减去对应 mem_section-&gt;section_mem_map</h5><p>该宏首先会使用 <code>page_to_section()</code> <strong>通过 page 结构体的 flags 字段</strong>获取该 page 所属的 section 标号，该函数定义于 <code>/include/linux/mm.h</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title function_">page_to_section</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> page *page)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> (page-&gt;flags &gt;&gt; SECTIONS_PGSHIFT) &amp; SECTIONS_MASK;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>之后使用 <code>__nr_to_section()</code> 来获取对应的 mem_section 结构体的地址，该函数定义于 <code>/include/linux/mmzone.h</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mem_section</span> *__<span class="hljs-title">nr_to_section</span>(<span class="hljs-title">unsigned</span> <span class="hljs-title">long</span> <span class="hljs-title">nr</span>)</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SPARSEMEM_EXTREME</span><br>    <span class="hljs-keyword">if</span> (!mem_section)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-keyword">if</span> (!mem_section[SECTION_NR_TO_ROOT(nr)])<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> &amp;mem_section[SECTION_NR_TO_ROOT(nr)][nr &amp; SECTION_ROOT_MASK];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里用到一个宏 <code>SEECTION_NR_TO_ROOT</code>，定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SPARSEMEM_EXTREME</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SECTIONS_PER_ROOT       (PAGE_SIZE / sizeof (struct mem_section))</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SECTIONS_PER_ROOT    1</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SECTION_NR_TO_ROOT(sec)    ((sec) / SECTIONS_PER_ROOT)</span><br></code></pre></td></tr></table></figure>

<p>我们默认开启 <code>CONFIG_SPARSEMEM_EXTREME</code>，此时 <code>SECTION_PER_ROOT</code> 意为一张页中 mem_section 结构体的数量，即宏 <code>SEECTION_NR_TO_ROOT</code> 得到的是对应的_页下标_，之后再通过 mem_section 标号与每页中 mem_section 数量 - 1（<code>SECTION_ROOT_MASK</code>）做与运算最终得到该 mem_section 在该页这一 mem_section 数组中的下标</p>
<p>之后通过 <code>__section_mem_map_addr()</code> 获取到 mem_section 结构体中的 section_mem_map 成员，该函数定义于 <code>/include/linux/mmzone.h</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *__<span class="hljs-title">section_mem_map_addr</span>(<span class="hljs-keyword">struct</span> <span class="hljs-title">mem_section</span> *<span class="hljs-title">section</span>)</span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-built_in">map</span> = section-&gt;section_mem_map;<br>    <span class="hljs-built_in">map</span> &amp;= SECTION_MAP_MASK;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">struct</span> page *)<span class="hljs-built_in">map</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最后与 page 结构体的地址做差运算便能获得其 PFN，需要注意的是在这里进行的是 <em>page 结构体指针间的运算</em> 而非简单的地址加减法，计算过程为：<br>$$<br>address_{struct\ page} - section_mem_map &#x3D; address_{struct\ page} - (address_{mem_map} - start_PFN)\<br>&#x3D;(address_{struct\ page} - address_{mem_map}) + start_PFN<br>\<br>&#x3D;PFN<br>$$</p>
<h5 id="（2）PFN-到-page-结构体：页框号加上对应-mem-section-gt-section-mem-map"><a href="#（2）PFN-到-page-结构体：页框号加上对应-mem-section-gt-section-mem-map" class="headerlink" title="（2）PFN 到 page 结构体：页框号加上对应 mem_section-&gt;section_mem_map"></a>（2）PFN 到 page 结构体：页框号加上对应 mem_section-&gt;section_mem_map</h5><p>该宏首先使用 <code>__pfn_section()</code> 来获取到 PFN 所属的 mem_section，该函数定义于 <code>/include/linux/mmzone.h</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mem_section</span> *__<span class="hljs-title">pfn_to_section</span>(<span class="hljs-title">unsigned</span> <span class="hljs-title">long</span> <span class="hljs-title">pfn</span>)</span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">return</span> __nr_to_section(pfn_to_section_nr(pfn));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其中 <code>pfn_to_section_nr()</code> 定义如下，用以获取对应的 section 的索引：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title function_">pfn_to_section_nr</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> pfn)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> pfn &gt;&gt; PFN_SECTION_SHIFT;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里用到一个宏 <code>PFN_SECTION_SHIFT</code>，定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PFN_SECTION_SHIFT    (SECTION_SIZE_BITS - PAGE_SHIFT)</span><br></code></pre></td></tr></table></figure>

<p>其中的 <code>SECTION_SIZE_BIT</code> 表示一个 section 的大小（恒定为2的幂次方）所占位数，而 <code>PAGE_SHIFT</code> 则为一个页的大小（通常为4096）所占位数，前者移位后者所得为_一个 section 中页的数量_</p>
<p>由页框号移位（本质为除法）单个 section 中页的数量便能得到其所属 section 标号</p>
<p>之后使用 <code>__nr_to_section()</code> 来获取对应的 mem_section 结构体的地址，最后使用 <code>__section_mem_map_addr()</code> 获取到 mem_section 结构体中的 section_mem_map 成员后再与页框号做 <em>指针加法</em> 便能获取到对应的 page 结构体数组，计算过程如下：<br>$$<br>PFN - section_mem_map &#x3D; PFN - (address_{mem_map} - start_PFN)\<br>&#x3D; (PFN - start_PFN )+ address_{mem_map}<br>\<br>&#x3D;address_{struct\ page}<br>$$</p>
<h4 id="Sparse-Memory-virtual-memmap"><a href="#Sparse-Memory-virtual-memmap" class="headerlink" title="*Sparse Memory virtual memmap"></a><em>*Sparse Memory virtual memmap</em></h4><p>基于Sparse Memory 内存模型上引入了 vmemmap 的概念，是目前 Linux 最常用的内存模型之一</p>
<blockquote>
<p>图依然是偷的，侵删</p>
</blockquote>
<p><img src="https://i.loli.net/2021/11/25/mnAUkENCoRwjtpq.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>在开启了 vmemmap 之后，所有的 mem_section 中的 page 都抽象到一个虚拟数组 vmemmap 中，这样在进行struct page * 和 pfn 转换时，直接使用 vmemmap 数组即可</p>
<h1 id="0x02-struct-zone：区"><a href="#0x02-struct-zone：区" class="headerlink" title="0x02.struct zone：区"></a>0x02.struct zone：区</h1><p>在 Linux 下将一个节点内不同用途的内存区域划分为不同的 <code>区（zone）</code>，对应结构体 <code>struct zone</code>，该结构体定义于 <code>/include/linux/mmzone.h</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zone</span> &#123;</span><br>    <span class="hljs-comment">/* Read-mostly fields */</span><br><br>    <span class="hljs-comment">/* zone 的“水位线”, 使用宏 *_wmark_pages(zone) 进行访问 */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> _watermark[NR_WMARK];<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> watermark_boost;<br><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> nr_reserved_highatomic;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 我们不知道我们将要分配的内存是否是可释放的 或/且 最终会被释放，</span><br><span class="hljs-comment">     * 因此为了避免将整个的几个 GB 的 RAM浪费掉，</span><br><span class="hljs-comment">     * 我们必须要保留一些 lower zone memory</span><br><span class="hljs-comment">     * (否则我们将有在 lower zones 上耗尽所有内存（OOM）的风险，</span><br><span class="hljs-comment">     * 尽管此时在 higher zones 仍有大量的 RAM).</span><br><span class="hljs-comment">     * 若 sysctl_lowmem_reserve_ratio 系统控制项改变，</span><br><span class="hljs-comment">     * 这个数组有可能在运行时被改变</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">long</span> lowmem_reserve[MAX_NR_ZONES];<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_NUMA</span><br>    <span class="hljs-type">int</span> node;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pglist_data</span>    *<span class="hljs-title">zone_pgdat</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">per_cpu_pageset</span> __<span class="hljs-title">percpu</span> *<span class="hljs-title">pageset</span>;</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * the high and batch values are copied to individual pagesets for</span><br><span class="hljs-comment">     * faster access</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> pageset_high;<br>    <span class="hljs-type">int</span> pageset_batch;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_SPARSEMEM</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 单个 pageblock_nr_pages block 的标志位. 参见 pageblock-flags.h.</span><br><span class="hljs-comment">     * 在 SPARSEMEM 中, 该 map 存放于 struct mem_section 中</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>        *pageblock_flags;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* CONFIG_SPARSEMEM */</span></span><br><br>    <span class="hljs-comment">/* zone_start_pfn == zone_start_paddr &gt;&gt; PAGE_SHIFT */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>        zone_start_pfn;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * spanned_pages 为该 zone 所包含的 pages 的范围, 包括空洞</span><br><span class="hljs-comment">     * 计算方式如下:</span><br><span class="hljs-comment">     *     spanned_pages = zone_end_pfn - zone_start_pfn;</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * present_pages 为该 zone 中存在的物理页框数</span><br><span class="hljs-comment">     * 计算方式如下:</span><br><span class="hljs-comment">     *    present_pages = spanned_pages - absent_pages(pages in holes);</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * managed_pages 为现有的由 buddy system 管理的页面数量, </span><br><span class="hljs-comment">     * 计算方式如下 (reserved_pages 包括由 bootmem allocator 分配的页面):</span><br><span class="hljs-comment">     *    managed_pages = present_pages - reserved_pages;</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * present_pages 可能会被内存热拔插或内存电源管理逻辑</span><br><span class="hljs-comment">     * 通过检查(present_pages - managed_pages)来算出未被管理的页面. </span><br><span class="hljs-comment">     * managed_pages 应被页面分配器与 vm 扫描器用以计算所有的水位线与阈值</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 锁规则:</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * zone_start_pfn 与 spanned_pages 由 span_seqlock 保护.</span><br><span class="hljs-comment">     * 这是一个顺序锁（seqlock，译者补充：写优先锁）因为他得在 zone-&gt;lock 之外被读取,</span><br><span class="hljs-comment">     * 在主分配器路径中完成. </span><br><span class="hljs-comment">     * 但他确实不经常被写入。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * span_seq lock 随着 zone-&gt;lock 被定义，因为相较于 zone-&gt;lock，</span><br><span class="hljs-comment">     * 他经常被读取. 让他们有个机会在同一条缓存线（cacheline）上一件好事</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 运行时 present_pages 应当由 mem_hotplug_begin/end() 进行保护.</span><br><span class="hljs-comment">     * 任何无法忍受 present_pages 的应当使用 get_online_mems()来获得固定的值.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">atomic_long_t</span>        managed_pages;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>        spanned_pages;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>        present_pages;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>        *name;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_MEMORY_ISOLATION</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 独立的 pageblock 的数量. 用以解决由于对 pagelock</span><br><span class="hljs-comment">     * 的 migratetype 的竞态检索导致的对 freepage 的错误计数.</span><br><span class="hljs-comment">     * 由 zone-&gt;lock 保护</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>        nr_isolate_pageblock;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_MEMORY_HOTPLUG</span><br>    <span class="hljs-comment">/* 参见 spanned/present_pages 以获得更多描述 */</span><br>    <span class="hljs-type">seqlock_t</span>        span_seqlock;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-type">int</span> initialized;<br><br>    <span class="hljs-comment">/* 供页分配器使用的写敏感字段 */</span><br>    ZONE_PADDING(_pad1_)<br><br>    <span class="hljs-comment">/* 不同 sizes 的闲置区域 */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">free_area</span>    <span class="hljs-title">free_area</span>[<span class="hljs-title">MAX_ORDER</span>];</span><br><br>    <span class="hljs-comment">/* zone 标志位 */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>        flags;<br><br>    <span class="hljs-comment">/* 主要保护 free_area */</span><br>    <span class="hljs-type">spinlock_t</span>        lock;<br><br>    <span class="hljs-comment">/* 供 compaction and vmstats 使用的写敏感字段. */</span><br>    ZONE_PADDING(_pad2_)<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 当闲置页在这一点下时, 在读取闲置页数量时会采取额外的步骤</span><br><span class="hljs-comment">     * 以避免 per-cpu 计数器</span><br><span class="hljs-comment">     * 漂移导致水位线被突破</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> percpu_drift_mark;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined CONFIG_COMPACTION || defined CONFIG_CMA</span><br>    <span class="hljs-comment">/* pfn where compaction free scanner should start */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>        compact_cached_free_pfn;<br>    <span class="hljs-comment">/* pfn where compaction migration scanner should start */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>        compact_cached_migrate_pfn[ASYNC_AND_SYNC];<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>        compact_init_migrate_pfn;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>        compact_init_free_pfn;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_COMPACTION</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * On compaction failure, 1&lt;&lt;compact_defer_shift compactions</span><br><span class="hljs-comment">     * are skipped before trying again. The number attempted since</span><br><span class="hljs-comment">     * last failure is tracked with compact_considered.</span><br><span class="hljs-comment">     * compact_order_failed is the minimum compaction failed order.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>        compact_considered;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>        compact_defer_shift;<br>    <span class="hljs-type">int</span>            compact_order_failed;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined CONFIG_COMPACTION || defined CONFIG_CMA</span><br>    <span class="hljs-comment">/* Set to true when the PG_migrate_skip bits should be cleared */</span><br>    <span class="hljs-type">bool</span>            compact_blockskip_flush;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-type">bool</span>            contiguous;<br><br>    ZONE_PADDING(_pad3_)<br>    <span class="hljs-comment">/* Zone 的统计数据 */</span><br>    <span class="hljs-type">atomic_long_t</span>        vm_stat[NR_VM_ZONE_STAT_ITEMS];<br>    <span class="hljs-type">atomic_long_t</span>        vm_numa_stat[NR_VM_NUMA_STAT_ITEMS];<br>&#125; ____cacheline_internodealigned_in_smp;<br></code></pre></td></tr></table></figure>

<h2 id="I-页面迁移机制"><a href="#I-页面迁移机制" class="headerlink" title="I.页面迁移机制"></a>I.页面迁移机制</h2><p>页面迁移主要用以解决内核空间中的<strong>碎片问题</strong>，在长期的运行之后内存当中空闲页面的分布可能是零散的，这便导致了内核<strong>有可能无法映射到足够大的连续内存</strong>，因此需要进行_页面迁移_——将旧的页面迁移到新的位置</p>
<p><img src="https://i.loli.net/2021/11/30/q7T6EjtIb9PVFY3.png" srcset="/img/loading.gif" lazyload alt="从知乎偷的图.png"></p>
<p>但<strong>并非所有的页面都是能够随意迁移的</strong>，因此我们在 buddy system 当中还需要将页面按照迁移类型进行分类</p>
<h3 id="迁移类型"><a href="#迁移类型" class="headerlink" title="迁移类型"></a>迁移类型</h3><p>迁移类型由一个枚举类型定义，定义于 <code>/include/linux/mmzone.h</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">migratetype</span> &#123;</span><br>    MIGRATE_UNMOVABLE,<br>    MIGRATE_MOVABLE,<br>    MIGRATE_RECLAIMABLE,<br>    MIGRATE_PCPTYPES,    <span class="hljs-comment">/* the number of types on the pcp lists */</span><br>    MIGRATE_HIGHATOMIC = MIGRATE_PCPTYPES,<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_CMA</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * MIGRATE_CMA migration type is designed to mimic the way</span><br><span class="hljs-comment">     * ZONE_MOVABLE works.  Only movable pages can be allocated</span><br><span class="hljs-comment">     * from MIGRATE_CMA pageblocks and page allocator never</span><br><span class="hljs-comment">     * implicitly change migration type of MIGRATE_CMA pageblock.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * The way to use it is to change migratetype of a range of</span><br><span class="hljs-comment">     * pageblocks to MIGRATE_CMA which can be done by</span><br><span class="hljs-comment">     * __free_pageblock_cma() function.  What is important though</span><br><span class="hljs-comment">     * is that a range of pageblocks must be aligned to</span><br><span class="hljs-comment">     * MAX_ORDER_NR_PAGES should biggest page be bigger then</span><br><span class="hljs-comment">     * a single pageblock.</span><br><span class="hljs-comment">     */</span><br>    MIGRATE_CMA,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_MEMORY_ISOLATION</span><br>    MIGRATE_ISOLATE,    <span class="hljs-comment">/* can&#x27;t allocate from here */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    MIGRATE_TYPES<br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>MIGRATE_UNMOVABLE</strong>：这类型页面在内存当中有着固定的位置，<strong>不能移动</strong></li>
<li><strong>MIGRATE_MOVABLE</strong>：这类页面<strong>可以随意移动</strong>，例如用户空间的页面，我们只需要复制数据后改变页表映射即可</li>
<li><strong>MIGRATE_RECLAIMABLE</strong>：这类页面<strong>不能直接移动，但是可以删除</strong>，例如映射自文件的页</li>
<li><strong>MIGRATE_PCPTYPES</strong>：<code>per_cpu_pageset</code>，即每 CPU 页帧缓存，其迁移<strong>仅限于同一节点内</strong></li>
<li><strong>MIGRATE_ISOLATE</strong>：<strong>不能从该链表分配页面</strong>，该链表用于跨 NUMA 节点进行页面移动，将页面移动到使用该页面最为频繁的 CPU 所处节点</li>
<li><em>MIGRATE_TYPES_：表示迁移类型的数目，_并不存在这一链表</em></li>
</ul>
<h2 id="II-几个比较重要的字段"><a href="#II-几个比较重要的字段" class="headerlink" title="II.几个比较重要的字段"></a>II.几个比较重要的字段</h2><p>简单讲讲其中几个重要的成员</p>
<h3 id="watermark：“水位线”"><a href="#watermark：“水位线”" class="headerlink" title="_watermark：“水位线”"></a>_watermark：“水位线”</h3><p>每一个 zone 都有着其对应的三档“水位线”： <code>WMARK_MIN</code>、<code>WMARK_LOW</code>、<code>WMARK_HIGH</code>，存放在 _watermark 数组中，在进行内存分配时，分配器（例如 buddy system）会根据当前 zone 中空余内存所处在的“水位线”来判断当前的内存状况，如下图所示：</p>
<blockquote>
<p>图仍然是偷的，侵删</p>
</blockquote>
<p><img src="https://i.loli.net/2021/11/25/8OuZhEfjHIy9AeL.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<blockquote>
<p>具体机制可以参见<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/73539328">这里</a></p>
</blockquote>
<h3 id="lowmem-reserve：zone-自身的保留内存"><a href="#lowmem-reserve：zone-自身的保留内存" class="headerlink" title="lowmem_reserve：zone 自身的保留内存"></a>lowmem_reserve：zone 自身的保留内存</h3><p>在进行内存分配时，若当前的 zone 没有足够的内存了，则会向下一个 zone 索要内存，那么这就存在一个问题：来自 higher zones 的内存分配请求可能耗尽 lower zones 的内存，但这样分配的内存未必是可释放的（freeable），亦或者&#x2F;且最终不一定会被释放，这有可能导致 <strong>lower zones 的内存提前耗尽，而 higher zones 却仍保留有大量的内存</strong></p>
<p>为了避免这样的一种情况的发生，<code>lowmem_reserve</code> 字段用以声明<strong>为该 zone 保留的内存</strong>，这一块内存别的 zone 是不能动的</p>
<h3 id="node：NUMA-中标识所属-node"><a href="#node：NUMA-中标识所属-node" class="headerlink" title="node：NUMA 中标识所属 node"></a><em>node：NUMA 中标识所属 node</em></h3><p>这个字段只在 NUMA 系统中被启用，用以标识该 zone 所属的 node</p>
<p>可以参考下面的图</p>
<blockquote>
<p>图还是偷的，侵删</p>
</blockquote>
<p><img src="https://i.loli.net/2021/11/25/LlaVq9eREW5sJAH.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p><img src="https://i.loli.net/2021/11/25/uwbo53W2Mjh1gOm.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h3 id="zone-pgdat：zone-所属的-pglist-data-节点"><a href="#zone-pgdat：zone-所属的-pglist-data-节点" class="headerlink" title="zone_pgdat：zone 所属的 pglist_data 节点"></a>zone_pgdat：zone 所属的 pglist_data 节点</h3><p>该字段用以标识该 zone 所属的 pglist_data 节点</p>
<h3 id="pageset-：zone-为每个-CPU-划分一个独立的”页面仓库“"><a href="#pageset-：zone-为每个-CPU-划分一个独立的”页面仓库“" class="headerlink" title="**pageset**：zone 为每个 CPU 划分一个独立的”页面仓库“"></a>**pageset**：zone 为每个 CPU 划分一个独立的”页面仓库“</h3><p>众所周知伴随着多 CPU 的引入，<strong>条件竞争</strong>就是一个不可忽视的问题，当多个 CPU 需要对一个 zone 进行操作时，频繁的加锁&#x2F;解锁操作则毫无疑问会造成大量的开销，因此 zone 引入了 <code>per_cpu_pageset</code> 结构体成员，即<strong>为每一个 CPU 都准备一个单独的页面仓库</strong>，因此其实现方式是实现为一个 <code>percpu</code> 变量</p>
<p>在一开始时 buddy system 会将页面放置到各个 CPU 自己独立的页面仓库中，需要进行分配时 CPU 优先从自己的页面仓库中分配</p>
<p>该结构体定义于 <code>/include/linux/mmzone.h</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">per_cpu_pages</span> &#123;</span><br>    <span class="hljs-type">int</span> count;        <span class="hljs-comment">/* 链表中页的数量 */</span><br>    <span class="hljs-type">int</span> high;        <span class="hljs-comment">/* 高水位线, 清空需要（笔者补：用以进行判断） */</span><br>    <span class="hljs-type">int</span> batch;        <span class="hljs-comment">/* chunk size for buddy add/remove */</span><br><br>    <span class="hljs-comment">/* 页面链表, 在 pcp-lists 上储存的独立的迁移类型 */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">lists</span>[<span class="hljs-title">MIGRATE_PCPTYPES</span>];</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">per_cpu_pageset</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">per_cpu_pages</span> <span class="hljs-title">pcp</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_NUMA</span><br>    s8 expire;<br>    u16 vm_numa_stat_diff[NR_VM_NUMA_STAT_ITEMS];<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SMP</span><br>    s8 stat_threshold;<br>    s8 vm_stat_diff[NR_VM_ZONE_STAT_ITEMS];<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>该结构体会被存放在每个 CPU 自己独立的 <code>.data..percpu</code> 段中，以 CPU0 为例，结构如下图所示</p>
<p><img src="https://i.loli.net/2021/12/03/1dCZA3IDpUK2xYg.png" srcset="/img/loading.gif" lazyload alt="自己画的图.png"></p>
<h3 id="zone-start-pfn：zone-的起始物理PFN"><a href="#zone-start-pfn：zone-的起始物理PFN" class="headerlink" title="zone_start_pfn：zone 的起始物理PFN"></a>zone_start_pfn：zone 的起始物理PFN</h3><p>该字段用以标识该 zone 的起始物理<strong>页帧编号</strong>（page frame number）</p>
<h3 id="spanned-pages：-zone-对应的内存区域中的-pages-总数（包括空洞）"><a href="#spanned-pages：-zone-对应的内存区域中的-pages-总数（包括空洞）" class="headerlink" title="spanned_pages： zone 对应的内存区域中的 pages 总数（包括空洞）"></a>spanned_pages： zone 对应的内存区域中的 pages 总数（包括空洞）</h3><p>该字段用以标识该 zone 对应的内存区域中的 pages 总数, <strong>包括空洞</strong></p>
<h3 id="present-pages：-zone-中存在的物理页框数"><a href="#present-pages：-zone-中存在的物理页框数" class="headerlink" title="present_pages： zone 中存在的物理页框数"></a>present_pages： zone 中存在的物理页框数</h3><p>该字段用以标识  zone 中实际存在的物理页框数</p>
<h3 id="managed-pages：zone-中-buddy-system-管理的页面数量"><a href="#managed-pages：zone-中-buddy-system-管理的页面数量" class="headerlink" title="managed_pages：zone 中 buddy system 管理的页面数量"></a>managed_pages：zone 中 buddy system 管理的页面数量</h3><p>该字段用以标识 zone 中 buddy system 管理的页面数量</p>
<h3 id="free-area-：buddy-system-按照-order-管理的页面"><a href="#free-area-：buddy-system-按照-order-管理的页面" class="headerlink" title="**free_area**：buddy system 按照 order 管理的页面"></a>**free_area**：buddy system 按照 order 管理的页面</h3><p>该字段用以存储 buddy system 按照 order 管理的页面，为一个 <code>free_area</code> 结构体数组，该结构体定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">free_area</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span>    <span class="hljs-title">free_list</span>[<span class="hljs-title">MIGRATE_TYPES</span>];</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>        nr_free;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>在 free_area 中存放的页面通过自身的相应字段连接成双向链表结构，这里放一张 overview</p>
<p><img src="https://i.loli.net/2021/11/30/sOwdI5YMNUjLSib.png" srcset="/img/loading.gif" lazyload alt="自己画的图.png"></p>
<p>free_area 中并非只有一个双向链表，而是按照不同的“迁移类型”（migrate type）进行分开存放，这是由于_页面迁移_机制的存在</p>
<p>以 <em>free_list[0]</em> 作为例子，我们可以得到如下 overview：</p>
<p><img src="https://i.loli.net/2021/11/30/sbNImKo6tBS5GUe.png" srcset="/img/loading.gif" lazyload alt="自己画的图.png"></p>
<h3 id="vm-stat：统计数据"><a href="#vm-stat：统计数据" class="headerlink" title="vm_stat：统计数据"></a>vm_stat：统计数据</h3><p>该数组用来进行数据统计，按照枚举类型 <code>zone_stat_item</code> 分为多个数组，以统计不同类型的数据（比如说 <code>NR_FREE_PAGES</code> 表示 zone 中的空闲页面1数量）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">zone_stat_item</span> &#123;</span><br>	<span class="hljs-comment">/* First 128 byte cacheline (assuming 64 bit words) */</span><br>	NR_FREE_PAGES,<br>	NR_ZONE_LRU_BASE, <span class="hljs-comment">/* Used only for compaction and reclaim retry */</span><br>	NR_ZONE_INACTIVE_ANON = NR_ZONE_LRU_BASE,<br>	NR_ZONE_ACTIVE_ANON,<br>	NR_ZONE_INACTIVE_FILE,<br>	NR_ZONE_ACTIVE_FILE,<br>	NR_ZONE_UNEVICTABLE,<br>	NR_ZONE_WRITE_PENDING,	<span class="hljs-comment">/* Count of dirty, writeback and unstable pages */</span><br>	NR_MLOCK,		<span class="hljs-comment">/* mlock()ed pages found and moved off LRU */</span><br>	<span class="hljs-comment">/* Second 128 byte cacheline */</span><br>	NR_BOUNCE,<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> IS_ENABLED(CONFIG_ZSMALLOC)</span><br>	NR_ZSPAGES,		<span class="hljs-comment">/* allocated in zsmalloc */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>	NR_FREE_CMA_PAGES,<br>	NR_VM_ZONE_STAT_ITEMS &#125;;<br></code></pre></td></tr></table></figure>



<h3 id="flags：标志位-1"><a href="#flags：标志位-1" class="headerlink" title="flags：标志位"></a>flags：标志位</h3><p>该 zone 的标志位，用以标识其所处的状态</p>
<h2 id="II-zone-的分类"><a href="#II-zone-的分类" class="headerlink" title="II.zone 的分类"></a>II.zone 的分类</h2><p>在 Linux kernel 当中，我们根据内存区段的不同用途，将其划分为不同的 zone，在 <code>/include/linux/mmzone.h</code> 中有着相应的枚举定义，如下：</p>
<blockquote>
<p>摆烂了，可能某天想起来会补充翻译</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">zone_type</span> &#123;</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * ZONE_DMA and ZONE_DMA32 are used when there are peripherals not able</span><br><span class="hljs-comment">     * to DMA to all of the addressable memory (ZONE_NORMAL).</span><br><span class="hljs-comment">     * On architectures where this area covers the whole 32 bit address</span><br><span class="hljs-comment">     * space ZONE_DMA32 is used. ZONE_DMA is left for the ones with smaller</span><br><span class="hljs-comment">     * DMA addressing constraints. This distinction is important as a 32bit</span><br><span class="hljs-comment">     * DMA mask is assumed when ZONE_DMA32 is defined. Some 64-bit</span><br><span class="hljs-comment">     * platforms may need both zones as they support peripherals with</span><br><span class="hljs-comment">     * different DMA addressing limitations.</span><br><span class="hljs-comment">     */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_ZONE_DMA</span><br>    ZONE_DMA,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_ZONE_DMA32</span><br>    ZONE_DMA32,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Normal addressable memory is in ZONE_NORMAL. DMA operations can be</span><br><span class="hljs-comment">     * performed on pages in ZONE_NORMAL if the DMA devices support</span><br><span class="hljs-comment">     * transfers to all addressable memory.</span><br><span class="hljs-comment">     */</span><br>    ZONE_NORMAL,<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_HIGHMEM</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * A memory area that is only addressable by the kernel through</span><br><span class="hljs-comment">     * mapping portions into its own address space. This is for example</span><br><span class="hljs-comment">     * used by i386 to allow the kernel to address the memory beyond</span><br><span class="hljs-comment">     * 900MB. The kernel will set up special mappings (page</span><br><span class="hljs-comment">     * table entries on i386) for each page that the kernel needs to</span><br><span class="hljs-comment">     * access.</span><br><span class="hljs-comment">     */</span><br>    ZONE_HIGHMEM,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * ZONE_MOVABLE is similar to ZONE_NORMAL, except that it contains</span><br><span class="hljs-comment">     * movable pages with few exceptional cases described below. Main use</span><br><span class="hljs-comment">     * cases for ZONE_MOVABLE are to make memory offlining/unplug more</span><br><span class="hljs-comment">     * likely to succeed, and to locally limit unmovable allocations - e.g.,</span><br><span class="hljs-comment">     * to increase the number of THP/huge pages. Notable special cases are:</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 1. Pinned pages: (long-term) pinning of movable pages might</span><br><span class="hljs-comment">     *    essentially turn such pages unmovable. Memory offlining might</span><br><span class="hljs-comment">     *    retry a long time.</span><br><span class="hljs-comment">     * 2. memblock allocations: kernelcore/movablecore setups might create</span><br><span class="hljs-comment">     *    situations where ZONE_MOVABLE contains unmovable allocations</span><br><span class="hljs-comment">     *    after boot. Memory offlining and allocations fail early.</span><br><span class="hljs-comment">     * 3. Memory holes: kernelcore/movablecore setups might create very rare</span><br><span class="hljs-comment">     *    situations where ZONE_MOVABLE contains memory holes after boot,</span><br><span class="hljs-comment">     *    for example, if we have sections that are only partially</span><br><span class="hljs-comment">     *    populated. Memory offlining and allocations fail early.</span><br><span class="hljs-comment">     * 4. PG_hwpoison pages: while poisoned pages can be skipped during</span><br><span class="hljs-comment">     *    memory offlining, such pages cannot be allocated.</span><br><span class="hljs-comment">     * 5. Unmovable PG_offline pages: in paravirtualized environments,</span><br><span class="hljs-comment">     *    hotplugged memory blocks might only partially be managed by the</span><br><span class="hljs-comment">     *    buddy (e.g., via XEN-balloon, Hyper-V balloon, virtio-mem). The</span><br><span class="hljs-comment">     *    parts not manged by the buddy are unmovable PG_offline pages. In</span><br><span class="hljs-comment">     *    some cases (virtio-mem), such pages can be skipped during</span><br><span class="hljs-comment">     *    memory offlining, however, cannot be moved/allocated. These</span><br><span class="hljs-comment">     *    techniques might use alloc_contig_range() to hide previously</span><br><span class="hljs-comment">     *    exposed pages from the buddy again (e.g., to implement some sort</span><br><span class="hljs-comment">     *    of memory unplug in virtio-mem).</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * In general, no unmovable allocations that degrade memory offlining</span><br><span class="hljs-comment">     * should end up in ZONE_MOVABLE. Allocators (like alloc_contig_range())</span><br><span class="hljs-comment">     * have to expect that migrating pages in ZONE_MOVABLE can fail (even</span><br><span class="hljs-comment">     * if has_unmovable_pages() states that there are no unmovable pages,</span><br><span class="hljs-comment">     * there can be false negatives).</span><br><span class="hljs-comment">     */</span><br>    ZONE_MOVABLE,<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_ZONE_DEVICE</span><br>    ZONE_DEVICE,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    __MAX_NR_ZONES<br><br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="X86-32"><a href="#X86-32" class="headerlink" title="X86-32"></a>X86-32</h3><p>如下表格所示（懒得找图了）</p>
<table>
<thead>
<tr>
<th align="center">Type</th>
<th align="center">Start address</th>
<th align="center">End address</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ZONE_DMA</td>
<td align="center">0MB</td>
<td align="center">16MB</td>
</tr>
<tr>
<td align="center">ZONE_NORMAL</td>
<td align="center">16MB</td>
<td align="center">896MB</td>
</tr>
<tr>
<td align="center">ZONE_HIGHMEM</td>
<td align="center">896MB</td>
<td align="center">…</td>
</tr>
</tbody></table>
<p>通常我们简单地划分为两部分：</p>
<ul>
<li><code>线性映射区</code>（前 896MB）：这一块内存直接映射到物理内存地址 0 起始往后的总计 896MB，为<strong>线性映射</strong></li>
<li><code>高端内存</code>（从 896MB 开始往后）：这一块内存的映射是<strong>不连续的</strong></li>
</ul>
<h3 id="X86-64"><a href="#X86-64" class="headerlink" title="X86-64"></a>X86-64</h3><p>如下表格所示（懒得找图了）</p>
<table>
<thead>
<tr>
<th align="center">Type</th>
<th align="center">Start address</th>
<th align="center">End address</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ZONE_DMA</td>
<td align="center">0MB</td>
<td align="center">16MB</td>
</tr>
<tr>
<td align="center">ZONE_DMA32</td>
<td align="center">16MB</td>
<td align="center">4GB</td>
</tr>
<tr>
<td align="center">ZONE_NORMAL</td>
<td align="center">4GB</td>
<td align="center">…</td>
</tr>
</tbody></table>
<p>在 64 位的 Linux kernel 中没有了“高端内存”这一概念</p>
<h1 id="0x03-struct-pglist-data：节点"><a href="#0x03-struct-pglist-data：节点" class="headerlink" title="0x03.struct pglist_data：节点"></a>0x03.struct pglist_data：节点</h1><p>zone 再向上一层便是<strong>节点</strong>——Linux 将_内存控制器（memory controller）_作为节点划分的依据，对于 UMA 架构而言只有一个节点，而对于 NUMA 架构而言通常有多个节点，对于同一个内存控制器下的 CPU 而言其对应的节点称之为_本地内存_，不同处理器之间通过总线进行进一步的连接。如下图所示，一个MC对应一个节点：</p>
<p><img src="https://i.loli.net/2021/11/27/hAopSNYg23VeWzq.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>一个节点使用 <code>pglist_data</code> 结构进行描述，该结构定义于 <code>/include/linux/mmzone.h</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 在 NUMA 机器上, 每个 NUMA 节点都有一个 pg_data_t 用以描述其内存布局。</span><br><span class="hljs-comment"> * 在 UMA 机器上则只有一个单独的 pglist_data 描述整个内存。</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 内存统计数据与页置换数据结构由一个 per-zone basis维持</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pglist_data</span> &#123;</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * node_zones 字段包含该节点所拥有的 zones。 并非所有的 zone 都已被填充，但这是一个满的列表。</span><br><span class="hljs-comment">     * 它被该节点的 node_zonelists 以及其他节点的 node_zonelists 所引用.</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zone</span> <span class="hljs-title">node_zones</span>[<span class="hljs-title">MAX_NR_ZONES</span>];</span><br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * node_zonelists 包含有对所有节点中所有区的引用。</span><br><span class="hljs-comment">     * 通常第一个区将会作为该节点的 node_zones 的引用.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zonelist</span> <span class="hljs-title">node_zonelists</span>[<span class="hljs-title">MAX_ZONELISTS</span>];</span><br><br>    <span class="hljs-type">int</span> nr_zones; <span class="hljs-comment">/* 该节点中被填充的 zone 的数量 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_FLAT_NODE_MEM_MAP    <span class="hljs-comment">/* 即 SPARSEMEM */</span></span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">node_mem_map</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_PAGE_EXTENSION</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page_ext</span> *<span class="hljs-title">node_page_ext</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_MEMORY_HOTPLUG) || defined(CONFIG_DEFERRED_STRUCT_PAGE_INIT)</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 若你期望 node_start_pfn, node_present_pages, </span><br><span class="hljs-comment">     * node_spanned_pages 或 nr_zones 保持不变，</span><br><span class="hljs-comment">     * 必须在任何时刻持有（这个锁）。</span><br><span class="hljs-comment">     * 同时在 deferred page 初始化期间对 pgdat-&gt;first_deferred_pfn 进行同步。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * （内核）提供了 pgdat_resize_lock() 与 pgdat_resize_unlock() </span><br><span class="hljs-comment">     * 以在没有对 CONFIG_MEMORY_HOTPLUG 或 CONFIG_DEFERRED_STRUCT_PAGE_INIT</span><br><span class="hljs-comment">     * 进行检查的情况下操纵 node_size_lock </span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 基于 zone-&gt;lock 与 zone-&gt;span_seqlock</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">spinlock_t</span> node_size_lock;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> node_start_pfn;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> node_present_pages; <span class="hljs-comment">/* 所有物理页的数量 */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> node_spanned_pages; <span class="hljs-comment">/* 所有物理页的大小，包括空洞 */</span><br><br>    <span class="hljs-type">int</span> node_id;<br>    <span class="hljs-type">wait_queue_head_t</span> kswapd_wait;<br>    <span class="hljs-type">wait_queue_head_t</span> pfmemalloc_wait;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">kswapd</span>;</span>    <span class="hljs-comment">/* 由 mem_hotplug_begin/end() 保护 */</span><br><br>    <span class="hljs-type">int</span> kswapd_order;<br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">zone_type</span> <span class="hljs-title">kswapd_highest_zoneidx</span>;</span><br><br>    <span class="hljs-type">int</span> kswapd_failures;        <span class="hljs-comment">/* 进行了 &#x27;reclaimed == 0&#x27; 判断的次数 */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_COMPACTION</span><br>    <span class="hljs-type">int</span> kcompactd_max_order;<br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">zone_type</span> <span class="hljs-title">kcompactd_highest_zoneidx</span>;</span><br>    <span class="hljs-type">wait_queue_head_t</span> kcompactd_wait;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">kcompactd</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 这是每个 node 保留的对用户空间分配不可用的页面</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>        totalreserve_pages;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_NUMA</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 若存在更多的未映射页面，则节点回收将会变得活跃</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>        min_unmapped_pages;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>        min_slab_pages;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* CONFIG_NUMA */</span></span><br><br>    <span class="hljs-comment">/* 页回收使用的写敏感字段 */</span><br>    ZONE_PADDING(_pad1_)<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_DEFERRED_STRUCT_PAGE_INIT</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 若在大机器上的内存初始化被推迟了，那么这是</span><br><span class="hljs-comment">     * 第一个需要被初始化的 PFN</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> first_deferred_pfn;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* CONFIG_DEFERRED_STRUCT_PAGE_INIT */</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_TRANSPARENT_HUGEPAGE</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">deferred_split</span> <span class="hljs-title">deferred_split_queue</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* 页回收扫描器通常访问的字段 */</span><br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * <span class="hljs-doctag">NOTE:</span> 若开启了 MEMCG 则其将不会被使用</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 使用 mem_cgroup_lruvec() 以查询 lruvecs.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lruvec</span>        __<span class="hljs-title">lruvec</span>;</span><br><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>        flags;<br><br>    ZONE_PADDING(_pad2_)<br><br>    <span class="hljs-comment">/* Per-node vmstats */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">per_cpu_nodestat</span> __<span class="hljs-title">percpu</span> *<span class="hljs-title">per_cpu_nodestats</span>;</span><br>    <span class="hljs-type">atomic_long_t</span>        vm_stat[NR_VM_NODE_STAT_ITEMS];<br>&#125; <span class="hljs-type">pg_data_t</span>;<br></code></pre></td></tr></table></figure>

<h2 id="几个比较重要的字段"><a href="#几个比较重要的字段" class="headerlink" title="几个比较重要的字段"></a>几个比较重要的字段</h2><p>简单讲讲其中几个重要的成员</p>
<h3 id="node-zones-：node-的-zone-列表"><a href="#node-zones-：node-的-zone-列表" class="headerlink" title="**node_zones**：node 的 zone 列表"></a>**node_zones**：node 的 zone 列表</h3><p>节点中最重要的字段 <code>node_zones</code> 作为一个 <code>zone 结构体数组</code> 记录了<strong>本节点上所有的 zone</strong>，其中有效的 zone 的个数由节点结构体的 <code>nr_zones</code> 字段指出</p>
<h3 id="node-zonelists：内存分配时备用-zone-的搜索顺序"><a href="#node-zonelists：内存分配时备用-zone-的搜索顺序" class="headerlink" title="node_zonelists：内存分配时备用 zone 的搜索顺序"></a>node_zonelists：内存分配时备用 zone 的搜索顺序</h3><p>该字段用以确定内存分配时对备用的 zone 的搜索顺序，在本节点常规内存分配失败时会沿着这个数组进行搜索，其中包含的 zone <strong>可以是非本节点的 zone</strong></p>
<p>这是一个其为一个 <code>zonelist</code> 类型的<strong>结构体数组</strong>，该结构体定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 单次分配请求在一个 zonelist 上操作. 一个 zonelist 便是一组 zone 的列表，</span><br><span class="hljs-comment"> * 其中第一个 zone 为分配的“目标”，而其他的 zone 为后备的zone，优先级降低。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 为了提高 zonelist 的读取速度, 在 zonerefs 中包含正在被读取的 entry 的 zone index。</span><br><span class="hljs-comment"> * 用来访问所给的 zoneref 结构体信息的帮助函数有：</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * zonelist_zone()	- 返回一个 struct zone 的指针作为 _zonerefs 中的一个 entry</span><br><span class="hljs-comment"> * zonelist_zone_idx()	- 返回作为 entry 的 zone 的 index</span><br><span class="hljs-comment"> * zonelist_node_idx()	- 返回作为 entry 的 node 的 index</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zonelist</span> &#123;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zoneref</span> _<span class="hljs-title">zonerefs</span>[<span class="hljs-title">MAX_ZONES_PER_ZONELIST</span> + 1];</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>可以看到的是其为一个  <code>zoneref</code> 类型的结构体数组，该结构体定义如下，包含了一个 zone 的指针以及一个 index：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 该结构包含了 zonelist 中一个 zone 的信息。 </span><br><span class="hljs-comment"> * 其被储存在这里以预防对大结构体的解引用与对表的查询。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zoneref</span> &#123;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zone</span> *<span class="hljs-title">zone</span>;</span>	<span class="hljs-comment">/* 指向实际上的 zone 的指针 */</span><br>	<span class="hljs-type">int</span> zone_idx;		<span class="hljs-comment">/* zone_idx(zoneref-&gt;zone) */</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="nr-zones：node-中-zone-的数量"><a href="#nr-zones：node-中-zone-的数量" class="headerlink" title="nr_zones：node 中 zone 的数量"></a>nr_zones：node 中 zone 的数量</h3><p>该字段存储了该节点中所有可用的 zone 的数量</p>
<h3 id="node-start-pfn：node-的起始页框标号"><a href="#node-start-pfn：node-的起始页框标号" class="headerlink" title="node_start_pfn：node 的起始页框标号"></a>node_start_pfn：node 的起始页框标号</h3><p>该字段记录了该节点上的物理内存起始页框标号</p>
<h3 id="node-present-pages：node-中物理页的总数量"><a href="#node-present-pages：node-中物理页的总数量" class="headerlink" title="node_present_pages：node 中物理页的总数量"></a>node_present_pages：node 中物理页的总数量</h3><p>该字段记录了节点中可用的物理页的总数量</p>
<h3 id="unsigned-long-node-spanned-pages：-node-中物理页的总大小"><a href="#unsigned-long-node-spanned-pages：-node-中物理页的总大小" class="headerlink" title="unsigned long node_spanned_pages： node 中物理页的总大小"></a>unsigned long node_spanned_pages： node 中物理页的总大小</h3><p>该字段记录了节点上<strong>包括空洞在内</strong>的页帧为单位的该节点内存的总长度</p>
<h3 id="node-id：node-的标号"><a href="#node-id：node-的标号" class="headerlink" title="node_id：node 的标号"></a>node_id：node 的标号</h3><p>该字段记录了该节点在系统中的标号，从 0 开始</p>
<h2 id="node-存储方式：全局数组-node-data"><a href="#node-存储方式：全局数组-node-data" class="headerlink" title="node 存储方式：全局数组 node_data[]"></a>node 存储方式：全局数组 node_data[]</h2><p>在 <code>/arch/x86/mm/numa.c</code> 中定义了一个 pglist_data 数组，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pglist_data</span> *<span class="hljs-title">node_data</span>[<span class="hljs-title">MAX_NUMNODES</span>] __<span class="hljs-title">read_mostly</span>;</span><br>EXPORT_SYMBOL(node_data);<br></code></pre></td></tr></table></figure>

<p>该数组中保存了系统中的<strong>所有的节点</strong></p>
<p>由此，我们最终得到这样一张架构图：</p>
<blockquote>
<p>还是偷的图，侵删</p>
</blockquote>
<p><img src="https://i.loli.net/2021/11/28/KcHILforOySi8YR.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<blockquote>
<p>我们可以使用 <code>numactl</code> 工具来查看系统中的节点信息，如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">numactl --hardware</span><br>available: 1 nodes (0)<br>node 0 cpus: 0 1 2 3<br>node 0 size: 11942 MB<br>node 0 free: 4464 MB<br>node distances:<br>node   0 <br>  0:  10 <br></code></pre></td></tr></table></figure>

<blockquote>
<p>笔者的机器比较弱，只有一个节点</p>
</blockquote>
</blockquote>
<h2 id="node-状态：全局数组-node-states"><a href="#node-状态：全局数组-node-states" class="headerlink" title="node 状态：全局数组 node_states[]"></a>node 状态：全局数组 node_states[]</h2><p>在 <code>/mm/page_alloc.c</code> 中定义了一个全局数组 <code>node_states</code> 用以标识对应标号的节点的状态，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Array of node states.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">nodemask_t</span> node_states[NR_NODE_STATES] __read_mostly = &#123;<br>    [N_POSSIBLE] = NODE_MASK_ALL,<br>    [N_ONLINE] = &#123; &#123; [<span class="hljs-number">0</span>] = <span class="hljs-number">1UL</span> &#125; &#125;,<br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_NUMA</span><br>    [N_NORMAL_MEMORY] = &#123; &#123; [<span class="hljs-number">0</span>] = <span class="hljs-number">1UL</span> &#125; &#125;,<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_HIGHMEM</span><br>    [N_HIGH_MEMORY] = &#123; &#123; [<span class="hljs-number">0</span>] = <span class="hljs-number">1UL</span> &#125; &#125;,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    [N_MEMORY] = &#123; &#123; [<span class="hljs-number">0</span>] = <span class="hljs-number">1UL</span> &#125; &#125;,<br>    [N_CPU] = &#123; &#123; [<span class="hljs-number">0</span>] = <span class="hljs-number">1UL</span> &#125; &#125;,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>    <span class="hljs-comment">/* NUMA */</span></span><br>&#125;;<br>EXPORT_SYMBOL(node_states);<br></code></pre></td></tr></table></figure>

<p>在这里的 <code>nodemask_t</code> 类型为一个<strong>位图</strong>类型，定义于 <code>/include/linux/nodemask.h</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> DECLARE_BITMAP(bits, MAX_NUMNODES); &#125; <span class="hljs-type">nodemask_t</span>;<br></code></pre></td></tr></table></figure>

<p>这个状态由一个枚举类型 <code>node_states</code> 定义，该枚举类型定义于 <code>/include/linux/nodemask.h</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 位掩码将为所有节点保存</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">node_states</span> &#123;</span><br>    N_POSSIBLE,        <span class="hljs-comment">/* 节点在某个时刻是联机的 */</span><br>    N_ONLINE,        <span class="hljs-comment">/* 节点是联机的 */</span><br>    N_NORMAL_MEMORY,    <span class="hljs-comment">/* 节点有着普通的内存 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_HIGHMEM</span><br>    N_HIGH_MEMORY,        <span class="hljs-comment">/* 节点有着普通或高端内存 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    N_HIGH_MEMORY = N_NORMAL_MEMORY,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    N_MEMORY,        <span class="hljs-comment">/* 节点有着内存(普通，高端，可移动) */</span><br>    N_CPU,        <span class="hljs-comment">/* 节点有着一个或多个 cpu */</span><br>    N_GENERIC_INITIATOR,    <span class="hljs-comment">/* 节点有一个或多个 Generic Initiators */</span><br>    NR_NODE_STATES<br>&#125;;<br></code></pre></td></tr></table></figure>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/OS/" class="category-chain-item">OS</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Linux/">#Linux</a>
      
        <a href="/tags/%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0/">#学习札记</a>
      
        <a href="/tags/Linux-Kernel/">#Linux Kernel</a>
      
        <a href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">#内存管理</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>【OS.0x02】Linux Kernel 内存管理浅析 I - 页、区、节点</div>
      <div>http://blog.arttnba3.cn/2021/11/28/OS-0X02-LINUX-KERNEL-MEMORY-5.11-PART-I/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>arttnba3</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2021年11月28日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/11/29/PWN-0X02-LINUX-KERNEL-PWN-PART-II/" title="【PWN.0x02】Linux Kernel Pwn II：通用结构体与技巧">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">【PWN.0x02】Linux Kernel Pwn II：通用结构体与技巧</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/11/24/FUZZ-0X01-SYZKALLER-I/" title="【FUZZ.0x01】syzkaller - I：使用 syzkaller 进行漏洞挖掘">
                        <span class="hidden-mobile">【FUZZ.0x01】syzkaller - I：使用 syzkaller 进行漏洞挖掘</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.4.17/Valine.min.js', function() {
        var options = Object.assign(
          {"appid":"ICj6cPRQWFTNiOttBHlzxnIv-gzGzoHsz","appkey":"tuvJh3xYxPFcW2JB6K26RKP2","path":"window.location.pathname","placeholder":"说点什么呗（笑）","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false,"appId":"ICj6cPRQWFTNiOttBHlzxnIv-gzGzoHsz","appKey":"tuvJh3xYxPFcW2JB6K26RKP2"},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  <!-- 网站运行时间的设置 -->
  <span id="timeDate">载入天数...</span>
  <span id="times">载入时分秒...</span>
  <script>
      var now = new Date();
      function createtime() {
          var grt= new Date("04/20/2020 17:48:48");//此处修改你的建站时间或者网站上线时间
          now.setTime(now.getTime()+250);
          days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
          hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
          if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
          mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
          seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
          snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
          document.getElementById("timeDate").innerHTML = "arttnba3的小屋已经安全存在了 "+dnum+" 天 ";
          document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
      }
  setInterval("createtime()",250);
  </script>
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.1/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
