<!DOCTYPE html>
<html lang="zh-CN" color-mode="light">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="keywords" content="" />
  <meta name="author" content="arttnba3" />
  <meta name="description" content="あがいた夢を捨てて揺れる今日は眠って誤魔化せ" />
  
  
  <title>
    
      【NOTES.0x00】glibc2.23malloc源码分析 - I：堆内存的基本组织形式 
      
      
      |
    
     arttnba3&#39;s blog
  </title>

  
    <link rel="apple-touch-icon" href="/img/favicon.png">
    <link rel="icon" href="/img/favicon.png">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  
<link rel="stylesheet" href="/css/color-scheme.css">
<link rel="stylesheet" href="/css/base.css">
<link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css">
<link rel="stylesheet" href="/css/github-markdown.css">
<link rel="stylesheet" href="/css/highlight.css">
<link rel="stylesheet" href="/css/comments.css">

  <!-- 代码块风格 -->
  

  <!-- jquery3.3.1 -->
  
    <script defer type="text/javascript" src="/plugins/jquery.min.js"></script>
  

  <!-- fancybox -->
  
    <link href="/plugins/jquery.fancybox.min.css" rel="stylesheet">
    <script defer type="text/javascript" src="/plugins/jquery.fancybox.min.js"></script>
  
  
<script src="/js/fancybox.js"></script>


  

  <script>
    var html = document.documentElement
    const colorMode = localStorage.getItem('color-mode')
    if (colorMode) {
      document.documentElement.setAttribute('color-mode', colorMode)
    }
  </script>
<meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="arttnba3's blog" type="application/atom+xml">
</head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a target="_blank" rel="noopener" href="https://arttnba3.cn">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img src="/img/avatar.png" alt="">
      
    </a>
    <div class="nickname"><a target="_blank" rel="noopener" href="https://arttnba3.cn">arttnba3's blog</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">Home</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">Archives</a>
        </li>
      
        <li class="nav-item" data-path="/categories/">
          <a href="/categories/">Categories</a>
        </li>
      
        <li class="nav-item" data-path="/tags/">
          <a href="/tags/">Tags</a>
        </li>
      
        <li class="nav-item" data-path="/friends/">
          <a href="/friends/">Friends</a>
        </li>
      
        <li class="nav-item" data-path="/about/">
          <a href="/about/">About</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->


  <!-- LaTex Display -->

  
    <script async type="text/javascript" src="/plugins/mathjax/tex-chtml.js"></script>
  
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    }
  </script>





  <!-- clipboard -->

  
    <script async type="text/javascript" src="/plugins/clipboard.min.js"></script>
  
  
<script src="/js/codeCopy.js"></script>







  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">【NOTES.0x00】glibc2.23malloc源码分析 - I：堆内存的基本组织形式</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime" title="更新时间"></i>
          2021-01-15 19:17:03
        </span>
        
              <span class="post-categories">
                <i class="iconfont icon-bookmark" title="分类"></i>
                
                <span class="span--category">
                  <a href="/categories/NOTES/" title="NOTES">
                    <b>#</b> NOTES
                  </a>
                </span>
                
              </span>
          
              <span class="post-tags">
                <i class="iconfont icon-tags" title="标签"></i>
                
                <span class="span--tag">
                  <a href="/tags/%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0/" title="学习札记">
                    <b>#</b> 学习札记
                  </a>
                </span>
                
                <span class="span--tag">
                  <a href="/tags/ptmalloc/" title="ptmalloc">
                    <b>#</b> ptmalloc
                  </a>
                </span>
                
                <span class="span--tag">
                  <a href="/tags/glibc/" title="glibc">
                    <b>#</b> glibc
                  </a>
                </span>
                
                <span class="span--tag">
                  <a href="/tags/%E5%A0%86-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" title="堆 - 内存管理">
                    <b>#</b> 堆 - 内存管理
                  </a>
                </span>
                
              </span>
          
      </div>
      <div class="markdown-body">
        <p>让我们先从最简单的chunk讲起…</p>
<span id="more"></span>

<h1 id="0x00-堆内存的组织形式"><a href="#0x00-堆内存的组织形式" class="headerlink" title="0x00.堆内存的组织形式"></a>0x00.堆内存的组织形式</h1><h2 id="一、malloc-chunk"><a href="#一、malloc-chunk" class="headerlink" title="一、malloc_chunk"></a>一、malloc_chunk</h2><p>思来想去还是先从最简单的堆块的基本组织形式——malloc_chunk结构体开始讲起，同时也事先讲完一些通用宏定义，<del>省得后面再不断的递归套娃回来看chunk相关的各种定义</del>（<del>←因为这个人真的遇到了这样的情况</del>）</p>
<p>通常情况下，我们将向系统所申请得到的内存块称之为chunk，在ptmalloc的内部使用malloc_chunk结构体来表示，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>首先我们先看一些相关的宏定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> INTERNAL_SIZE_T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTERNAL_SIZE_T size_t</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The corresponding word size */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE_SZ                (sizeof(INTERNAL_SIZE_T))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  MALLOC_ALIGNMENT is the minimum alignment for malloc&#x27;ed chunks.</span></span><br><span class="line"><span class="comment">  It must be a power of two at least 2 * SIZE_SZ, even on machines</span></span><br><span class="line"><span class="comment">  for which smaller alignments would suffice. It may be defined as</span></span><br><span class="line"><span class="comment">  larger than this though. Note however that code and data structures</span></span><br><span class="line"><span class="comment">  are optimized for the case of 8-byte alignment.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MALLOC_ALIGNMENT</span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> !SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_16)</span></span><br><span class="line"><span class="comment">/* This is the correct definition when there is no past ABI to constrain it.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Among configurations with a past ABI constraint, it differs from</span></span><br><span class="line"><span class="comment">   2*SIZE_SZ only on powerpc32.  For the time being, changing this is</span></span><br><span class="line"><span class="comment">   causing more compatibility problems due to malloc_get_state and</span></span><br><span class="line"><span class="comment">   malloc_set_state than will returning blocks not adequately aligned for</span></span><br><span class="line"><span class="comment">   long double objects under -mlong-double-128.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> MALLOC_ALIGNMENT       (2 *SIZE_SZ &lt; __alignof__ (long double)      \</span></span><br><span class="line"><span class="meta">                                  ? __alignof__ (long double) : 2 *SIZE_SZ)</span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> MALLOC_ALIGNMENT       (2 *SIZE_SZ)</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The corresponding bit mask value */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MALLOC_ALIGN_MASK      (MALLOC_ALIGNMENT - 1)</span></span><br></pre></td></tr></table></figure>

<p>大致如下：</p>
<ul>
<li><strong>INTERNAL_SIZE_T</strong>宏展开后<strong>其实就是size_t，32位下为4字节，64位下为8字节</strong>，<strong>SIZE_SZ为其别名</strong></li>
<li><strong>MALLOC_ALIGNMENT</strong>则定义了chunk在内存中对齐的字节数，一般来说算出来都是<strong>对2*SIZE_SZ对齐</strong>，即<strong>32位下8字节对齐，64位下16字节对齐</strong></li>
<li><strong>MALLOC_ALIGEN_MASK</strong>的值则是MALLOC_ALIGENMENT - 1，笔者猜测其表示的是<strong>标志位全满的标志位值</strong>（<strong>掩码</strong>）<strong>，用以进行后续的标志位清除运算等操作</strong></li>
</ul>
<blockquote>
<h3 id="The-alignof-operator"><a href="#The-alignof-operator" class="headerlink" title="The __alignof__ operator"></a><a target="_blank" rel="noopener" href="https://www.ibm.com/support/knowledgecenter/ssw_ibm_i_71/rzarg/sc09785202.htm?view=kc#ToC_180">The __alignof__ operator</a></h3><p>The __alignof__ operator is a language extension to C99 and Standard C++ that returns the number of bytes used in the alignment of its operand. The operand can be an expression or a parenthesized type identifier. If the operand is an expression representing an lvalue, the number returned by <strong>alignof</strong> represents the alignment that the lvalue is known to have. The type of the expression is determined at compile time, but the expression itself is not evaluated. If the operand is a type, the number represents the alignment usually required for the type on the target platform.</p>
<p>(from IBM Knowledge Center)</p>
<p>大意是说__alignof__运算符是对C99及标准C++的拓展，用以返回运算对象所占用空间的字节数</p>
</blockquote>
<p>结构体中一共有六个变量，大致如下：</p>
<ul>
<li><strong>prev_size</strong>:用以保存前一个内存物理地址相邻的chunk的size，<strong>仅在该chunk为free状态时会被使用到</strong></li>
<li><strong>size</strong>：顾名思义，用以保存这个chunk的<strong>总的大小，即同时包含chunk头</strong>（<strong>prev_size + size</strong>）<strong>和chunk剩余部分的大小</strong></li>
<li><strong>fd</strong>&amp;&amp;<strong>bk</strong>：<strong>仅在在chunk被free后使用</strong>，用以连接其他的chunk，<strong>也就是说当chunk处于被使用的状态时该字段无效，被用以存储用户的数据</strong></li>
<li><strong>fd_nextsize</strong>&amp;&amp;<strong>bk_nextsize</strong>：仅在在chunk被free后使用，用以连接其他的chunk</li>
</ul>
<p>后面我们还会再详细讲解这几个变量的相关内容，这里仅作一简览</p>
<p>由于最后的两个变量仅用于较大的free的chunk，故我们先暂且忽略</p>
<p>那么我们便可以知道：<strong>一个chunk在内存中大概是长这个样子的</strong>：</p>
<p><img src="https://i.loli.net/2020/12/18/qLi36sem4wYZMEo.png" alt="44FB88C98453823956FB22B5B8C8C113.png"></p>
<p>当然，我个人更喜欢用如下的结构来表示，<del>问就是👴喜欢和MALLOC_ALIGNMENT对齐的感觉</del></p>
<p><img src="https://i.loli.net/2020/12/18/MAmvtL1zrpo9sFV.png" alt="image.png"></p>
<h2 id="二、chunk相关宏"><a href="#二、chunk相关宏" class="headerlink" title="二、chunk相关宏"></a>二、chunk相关宏</h2><p>malloc.c中还定义了一些和malloc_chunk相关的宏，如下：</p>
<h3 id="1-chunk-size相关宏"><a href="#1-chunk-size相关宏" class="headerlink" title="1.chunk size相关宏"></a>1.chunk size相关宏</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  ---------- Size and alignment checks and conversions ----------</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* conversion from malloc headers to user pointers, and back */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk2mem(p)   ((void*)((char*)(p) + 2*SIZE_SZ))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mem2chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The smallest possible chunk */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_CHUNK_SIZE        (offsetof(struct malloc_chunk, fd_nextsize))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The smallest size we can malloc is an aligned minimal chunk */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MINSIZE  \</span></span><br><span class="line"><span class="meta">  (unsigned long)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check if m has acceptable alignment */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> aligned_OK(m)  (((unsigned long)(m) &amp; MALLOC_ALIGN_MASK) == 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> misaligned_chunk(p) \</span></span><br><span class="line"><span class="meta">  ((uintptr_t)(MALLOC_ALIGNMENT == 2 * SIZE_SZ ? (p) : chunk2mem (p)) \</span></span><br><span class="line"><span class="meta">   &amp; MALLOC_ALIGN_MASK)</span></span><br></pre></td></tr></table></figure>

<p>大致如下：</p>
<ul>
<li><strong>chunk2mem</strong>：将指向chunk的指针转为指向memory的指针，<strong>即指针由指向chunk header</strong>（刚好是prev_size的位置）<strong>移动到指向fd</strong></li>
<li><strong>mem2chunk</strong>：将指向memory的指针转换为指向chunk的指针，<strong>即指针由指向fd移动到指向chunk header</strong>，与chunk2mem互为逆操作</li>
<li><strong>MIN_CHUNK_SIZE</strong>：所可分配的最小的chunk的size，为<strong>由prev_size到fd_nextsize的偏移量，32位下是0x10，64位下是0x20，即一个最小的chunk应当包含有chunk header和fd、bk</strong></li>
<li><strong>MINSIZE</strong>：所能分配的最小chunk的size；我们所能分配的最小的size的chunk应当为<strong>一个内存对其的最小的chunk</strong>，这里<strong>算出来其实就是MIN_CHUNK_SIZE</strong>，MIN_CHUNK_SIZE加上MALLOC_ALIGN_MASK以后再和做了取反操作的MALLOC_ALIGN_MASK做与运算猜测实际上是为了消除掉标志位</li>
<li><strong>aligned_OK</strong>：该宏用以检查<strong>是否与MALLOC_ALIGNMENT对齐</strong>，因为<strong>若是与MALLOC_ALIGNMENT不对其的话，其与MALLOC_ALIGN_MASK进行与运算的结果必然不为0</strong>（这里应该就不需要我再说明为什么了…）</li>
<li><strong>misaligned_chunk</strong>：该宏用以检测<strong>一个chunk是否为未对齐的chunk</strong>，若是则<strong>返回未对齐的字节数</strong></li>
</ul>
<p>简单的图示如下：</p>
<p><img src="https://i.loli.net/2020/12/19/ZSDand7AebOoqB3.png" alt="image.png"></p>
<blockquote>
<h4 id="宏：offsetof"><a href="#宏：offsetof" class="headerlink" title="宏：offsetof"></a>宏：offsetof</h4><p>也是一个在很多文件中都有着定义的一个宏，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Some compilers, like SunOS4 cc, don&#x27;t have offsetof in &lt;stddef.h&gt;.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> offsetof</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> offsetof(type,ident) ((size_t)&amp;(((type*)0)-&gt;ident))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>该宏的作用是求出某个类型中某个成员的偏移，大致过程如下：</p>
<ul>
<li>将0转换为指向某个类型的指针</li>
<li>取地址符取出0-&gt;ident的地址</li>
<li>转换成size_t类型</li>
</ul>
<p>由于是以0作为地址基底来取地址的，因此便可以很方便地计算出某个成员的偏移</p>
</blockquote>
<h3 id="2-memory-request相关宏"><a href="#2-memory-request相关宏" class="headerlink" title="2.memory request相关宏"></a>2.memory request相关宏</h3><p>接下来这些宏用以对请求的堆块大小进行检查，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Check if a request is so large that it would wrap around zero when</span></span><br><span class="line"><span class="comment">   padded and aligned. To simplify some other code, the bound is made</span></span><br><span class="line"><span class="comment">   low enough so that adding MINSIZE will also not wrap around zero.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REQUEST_OUT_OF_RANGE(req)                                 \</span></span><br><span class="line"><span class="meta">  ((unsigned long) (req) &gt;=						      \</span></span><br><span class="line"><span class="meta">   (unsigned long) (INTERNAL_SIZE_T) (-2 * MINSIZE))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* pad request bytes into a usable size -- internal version */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> request2size(req)                                         \</span></span><br><span class="line"><span class="meta">  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \</span></span><br><span class="line"><span class="meta">   MINSIZE :                                                      \</span></span><br><span class="line"><span class="meta">   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Same, except also perform argument check */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> checked_request2size(req, sz)                             \</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span> (REQUEST_OUT_OF_RANGE (req)) &#123;					      \</span></span><br><span class="line"><span class="meta">      __set_errno (ENOMEM);						      \</span></span><br><span class="line"><span class="meta">      return 0;								      \</span></span><br><span class="line"><span class="meta">    &#125;									      \</span></span><br><span class="line"><span class="meta">  (sz) = request2size (req);</span></span><br></pre></td></tr></table></figure>

<p>大致如下：</p>
<ul>
<li><strong>REQUEST_OUT_OF_RANGE</strong>：宏如其名，用以<strong>检查用户请求的内存大小是否大于规定的最大内存大小</strong>，这个值被定义为4字节整型能表示的最大值再减去两个最小chunk的size所求得的值，为的是避免当有人真的尝试去分配了这样的一个大chunk时malloc内部将这个值加上MINSIZE后会发生整型上溢而变成0附近的一个较小的值</li>
<li><strong>request2size</strong>：作用是<strong>将用户请求的内存大小转换为内存对齐的大小，这个转换后的大小便是实际分配给用户的chunk的size</strong>；若是请求的内存大小<strong>小于MINSIZE得到的size直接为MINSIZE</strong>，<strong>否则则会得到一个与MALLOC_ALIGNMENT对齐的chunk size</strong></li>
<li><strong>checked_request2size</strong>：可以理解为<strong>request2size宏封装上了size检查的宏</strong>，需要注意的是若是REQUEST_OUT_OF_RANGE则该宏则会在设置errno标志位为ENOMEM后直接return 0，终止其调用函数的执行</li>
</ul>
<blockquote>
<h4 id="关于chunk间的内存复用及request2size计算相关事项"><a href="#关于chunk间的内存复用及request2size计算相关事项" class="headerlink" title="关于chunk间的内存复用及request2size计算相关事项"></a>关于chunk间的内存复用及request2size计算相关事项</h4><p><del>众所周知·</del>，ptmalloc在组织各chunk时允许一个chunk复用其物理相邻的下一个chunk的prev_size字段作为自己的储存空间，这也是为什么当<strong>一个chunk的物理相邻的前一个chunk处在被分配状态时该chunk的prev_size字段无效</strong>的原因，大致图示如下：</p>
<p><img src="https://i.loli.net/2020/12/19/HZfcpy4wkJGg9V3.png" alt="image.png"></p>
<p>因此，基于这样的一种空间复用的思想，request2size宏计算出来的size便如图右侧所示了</p>
</blockquote>
<h3 id="3-chunk标志位相关宏"><a href="#3-chunk标志位相关宏" class="headerlink" title="3.chunk标志位相关宏"></a>3.chunk标志位相关宏</h3><h4 id="①标志位定义及相关宏"><a href="#①标志位定义及相关宏" class="headerlink" title="①标志位定义及相关宏"></a>①标志位定义及相关宏</h4><p>我们知道对于一个malloc_chunk而言其size字段应当与MALLOC_ALIGNMENT对齐，而在这样的情况下一个chunk的size字段的低3&#x2F;4（32&#x2F;64位系统）位将会永远为0，无法得到充分的利用，因此<del>出于能压榨一点空间是一点空间的思想</del>一个chunk的size字段的低三位用以保存相关的三个状态，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   --------------- Physical chunk operations ---------------</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* size field is or&#x27;ed with PREV_INUSE when previous adjacent chunk in use */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREV_INUSE 0x1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* extract inuse bit of previous chunk */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prev_inuse(p)       ((p)-&gt;size &amp; PREV_INUSE)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* size field is or&#x27;ed with IS_MMAPPED if the chunk was obtained with mmap() */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_MMAPPED 0x2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* check for mmap()&#x27;ed chunk */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_is_mmapped(p) ((p)-&gt;size &amp; IS_MMAPPED)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* size field is or&#x27;ed with NON_MAIN_ARENA if the chunk was obtained</span></span><br><span class="line"><span class="comment">   from a non-main arena.  This is only set immediately before handing</span></span><br><span class="line"><span class="comment">   the chunk to the user, if necessary.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NON_MAIN_ARENA 0x4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* check for chunk from non-main arena */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_non_main_arena(p) ((p)-&gt;size &amp; NON_MAIN_ARENA)</span></span><br></pre></td></tr></table></figure>

<p>从低位到高位依次如下：</p>
<ul>
<li><strong>PREV_IN_USE</strong>：该chunk<strong>内存物理相邻的上一个chunk</strong>是否<strong>处于被分配状态</strong></li>
<li><strong>IS_MAPPED</strong>：该chunk是否是<strong>由mmap</strong>()<strong>进行内存分配得到的</strong></li>
<li><strong>NON_MAIN_ARENA</strong>：该chunk是否是一个<strong>不属于main_arena的chunk</strong></li>
</ul>
<p>因而有三个用以检测标志位的宏：<code>prev_inuse()</code>、<code>chunk_is_mapped</code>、<code>chunk_non_main_arena()</code>，这里便不再过多赘叙了</p>
<h4 id="②标志位操作相关宏及其他宏"><a href="#②标志位操作相关宏及其他宏" class="headerlink" title="②标志位操作相关宏及其他宏"></a>②标志位操作相关宏及其他宏</h4><p>malloc.c中这些宏的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Bits to mask off when extracting size</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Note: IS_MMAPPED is intentionally not masked off from size field in</span></span><br><span class="line"><span class="comment">   macros for which mmapped chunks should never be seen. This should</span></span><br><span class="line"><span class="comment">   cause helpful core dumps to occur if it is tried by accident by</span></span><br><span class="line"><span class="comment">   people extending or adapting this malloc.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get size, ignoring use bits */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunksize(p)         ((p)-&gt;size &amp; ~(SIZE_BITS))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Ptr to next physical malloc_chunk. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> next_chunk(p) ((mchunkptr) (((char *) (p)) + ((p)-&gt;size &amp; ~SIZE_BITS)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Ptr to previous physical malloc_chunk */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prev_chunk(p) ((mchunkptr) (((char *) (p)) - ((p)-&gt;prev_size)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Treat space at ptr + offset as a chunk */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* extract p&#x27;s inuse bit */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inuse(p)							      \</span></span><br><span class="line"><span class="meta">  ((((mchunkptr) (((char *) (p)) + ((p)-&gt;size &amp; ~SIZE_BITS)))-&gt;size) &amp; PREV_INUSE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* set/clear chunk as being inuse without otherwise disturbing */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_inuse(p)							      \</span></span><br><span class="line"><span class="meta">  ((mchunkptr) (((char *) (p)) + ((p)-&gt;size &amp; ~SIZE_BITS)))-&gt;size |= PREV_INUSE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clear_inuse(p)							      \</span></span><br><span class="line"><span class="meta">  ((mchunkptr) (((char *) (p)) + ((p)-&gt;size &amp; ~SIZE_BITS)))-&gt;size &amp;= ~(PREV_INUSE)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* check/set/clear inuse bits in known places */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inuse_bit_at_offset(p, s)					      \</span></span><br><span class="line"><span class="meta">  (((mchunkptr) (((char *) (p)) + (s)))-&gt;size &amp; PREV_INUSE)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_inuse_bit_at_offset(p, s)					      \</span></span><br><span class="line"><span class="meta">  (((mchunkptr) (((char *) (p)) + (s)))-&gt;size |= PREV_INUSE)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clear_inuse_bit_at_offset(p, s)					      \</span></span><br><span class="line"><span class="meta">  (((mchunkptr) (((char *) (p)) + (s)))-&gt;size &amp;= ~(PREV_INUSE))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set size at head, without disturbing its use bit */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_head_size(p, s)  ((p)-&gt;size = (((p)-&gt;size &amp; SIZE_BITS) | (s)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set size/use field */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_head(p, s)       ((p)-&gt;size = (s))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set size at footer (only when chunk is not in use) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_foot(p, s)       (((mchunkptr) ((char *) (p) + (s)))-&gt;prev_size = (s))</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>大致如下：</p>
<ul>
<li><strong>SIZE_BITS</strong>：该宏用以表示<strong>三个标志位全为1</strong></li>
<li><strong>chunksize</strong> ()：该宏用以<strong>清除size字段的标志位，得到原始的chunk size</strong></li>
<li><strong>next_chunk</strong> ()：该宏用以<strong>获得指向该chunk的物理相邻的下一个chunk的指针</strong></li>
<li><strong>prev_chunk</strong> ()：该宏用以<strong>获得指向该chunk的物理相邻的上一个chunk的指针</strong>，需要注意的是<strong>prev_size字段必须有效，即上一个chunk必须为free状态</strong></li>
<li><strong>chunk_at_offset</strong> ()：该宏用以<strong>将ptr + offset位置作为一个chunk来对待，获得一个指向ptr + offset位置的chunk指针</strong>（大意是假设ptr + offset上有一个chunk，然后我们用这个宏得到指向这个chunk的chunk指针，后面讲到top_chunk时会用到）</li>
<li><strong>inuse()、set_inuse()、clear_inuse</strong> ()：<strong>检测、设置、清除chunk的PREV_INUSE标志位</strong></li>
<li><strong>inuse_bit_at_offset()、set_inuse_bit_at_offset()、clear_inuse_bit_at_offset</strong> ()：将ptr + offset位置视为一个chunk并<strong>检测、设置、清除该chunk的PREV_INUSE标志位</strong></li>
<li><strong>set_head_size</strong> ()：该宏用以<strong>在不改变标志位的情况下改变一个chunk的size字段</strong></li>
<li><strong>set_size</strong> ()：该宏用以<strong>改变一个chunk的size字段</strong>，是前者的简化版本</li>
<li><strong>set_foot</strong> ()：该宏用以<strong>在将ptr + s视为一个chunk的地址的情况下将这个chunk的prev_size字段置为s</strong></li>
</ul>
<h2 id="三、Bins：存放闲置chunk的数组"><a href="#三、Bins：存放闲置chunk的数组" class="headerlink" title="三、Bins：存放闲置chunk的数组"></a>三、Bins：存放闲置chunk的数组</h2><p>对于闲置的chunk，ptmalloc会根据size的不同将之存放到不同的bins中进行统一的调度，而不会马上返还给系统，这样一来在用户再次进行请求时，ptmalloc便可从bins中挑选出合适的chunk给予用户，这样一来便能大幅度地减少系统调用的次数及其带来的巨大开销</p>
<p>malloc.c中对于bins的说明如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Bins</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    An array of bin headers for free chunks. Each bin is doubly</span></span><br><span class="line"><span class="comment">    linked.  The bins are approximately proportionally (log) spaced.</span></span><br><span class="line"><span class="comment">    There are a lot of these bins (128). This may look excessive, but</span></span><br><span class="line"><span class="comment">    works very well in practice.  Most bins hold sizes that are</span></span><br><span class="line"><span class="comment">    unusual as malloc request sizes, but are more usual for fragments</span></span><br><span class="line"><span class="comment">    and consolidated sets of chunks, which is what these bins hold, so</span></span><br><span class="line"><span class="comment">    they can be found quickly.  All procedures maintain the invariant</span></span><br><span class="line"><span class="comment">    that no consolidated chunk physically borders another one, so each</span></span><br><span class="line"><span class="comment">    chunk in a list is known to be preceeded and followed by either</span></span><br><span class="line"><span class="comment">    inuse chunks or the ends of memory.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Chunks in bins are kept in size order, with ties going to the</span></span><br><span class="line"><span class="comment">    approximately least recently used chunk. Ordering isn&#x27;t needed</span></span><br><span class="line"><span class="comment">    for the small bins, which all contain the same-sized chunks, but</span></span><br><span class="line"><span class="comment">    facilitates best-fit allocation for larger chunks. These lists</span></span><br><span class="line"><span class="comment">    are just sequential. Keeping them in order almost never requires</span></span><br><span class="line"><span class="comment">    enough traversal to warrant using fancier ordered data</span></span><br><span class="line"><span class="comment">    structures.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Chunks of the same size are linked with the most</span></span><br><span class="line"><span class="comment">    recently freed at the front, and allocations are taken from the</span></span><br><span class="line"><span class="comment">    back.  This results in LRU (FIFO) allocation order, which tends</span></span><br><span class="line"><span class="comment">    to give each chunk an equal opportunity to be consolidated with</span></span><br><span class="line"><span class="comment">    adjacent freed chunks, resulting in larger free chunks and less</span></span><br><span class="line"><span class="comment">    fragmentation.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    To simplify use in double-linked lists, each bin header acts</span></span><br><span class="line"><span class="comment">    as a malloc_chunk. This avoids special-casing for headers.</span></span><br><span class="line"><span class="comment">    But to conserve space and improve locality, we allocate</span></span><br><span class="line"><span class="comment">    only the fd/bk pointers of bins, and then use repositioning tricks</span></span><br><span class="line"><span class="comment">    to treat these as the fields of a malloc_chunk*.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> *<span class="title">mbinptr</span>;</span></span><br></pre></td></tr></table></figure>

<p>大意是说bins是一个用以存放闲置的chunk的数组，chunk按照size来存放在不同的下标的bin中，<strong>每个bin中的chunk都是使用双向链表进行链接的</strong></p>
<p>一共有着128个bin，其中对于small size chunk而言其存放于存放着相同size的chunk中，因此其每个bin内也就不需要排序，但这也有助于更大的chunk达到最佳的分配机制</p>
<p><strong>被free的chunk会放置于双向链表的头部，而在分配chunk时则是从链表的尾部取chunk</strong>，即<strong>bin中的chunk链表采取FIFO机制</strong></p>
<p>为了简化双向链表的使用，每一个bin header都被如同malloc_chunk一般使用，同时为了节省空间，<strong>在chunk中仅会使用FD&#x2F;BK字段</strong></p>
<p>同时还typedef了一个mbinptr类型，为指向malloc_chunk结构体的指针</p>
<p>在ptmalloc中<strong>bins数组中的bin一共可以划分为三类：unsorted bin、small bin、large bin</strong>，将会在后面进行说明</p>
<h3 id="1-bins通用宏"><a href="#1-bins通用宏" class="headerlink" title="1.bins通用宏"></a>1.bins通用宏</h3><p>malloc.c中定义了一些和bins相关的宏，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* addressing -- note that bin_at(0) does not exist */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bin_at(m, i) \</span></span><br><span class="line"><span class="meta">  (mbinptr) (((char *) &amp;((m)-&gt;bins[((i) - 1) * 2]))			      \</span></span><br><span class="line"><span class="meta">             - offsetof (struct malloc_chunk, fd))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* analog of ++bin */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> next_bin(b)  ((mbinptr) ((char *) (b) + (sizeof (mchunkptr) &lt;&lt; 1)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reminders about list directionality within bins */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> first(b)     ((b)-&gt;fd)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> last(b)      ((b)-&gt;bk)</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bin_index(sz) \</span></span><br><span class="line"><span class="meta">  ((in_smallbin_range (sz)) ? smallbin_index (sz) : largebin_index (sz))</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>bin_at</strong>：取出位于下标 i 的bin chunk，需要注意的是在这里获得的指针为原始存在bin中的指针再减去了chunk header的大小所得到的值，这是由于在bins数组中存放的为fd&#x2F;bk，需要减去chunk header的大小才能获得一个指向chunk的指针而不是指向mem的指针；从这里我们也可以看出一个bin占据bins数组两格的空间</li>
<li><strong>next_bin</strong>：获取下一个bin</li>
<li><strong>first &amp;&amp; last</strong>：获得bin chunk的fd&#x2F;bk</li>
</ul>
<p>简单的简析一下关于bin_at宏的这样一个看起来迷惑的操作：<strong>Bins数组中的每一个bin都被视作free chunk构建的双向循环链表中的一个特殊的chunk，而每个bin会在数组中存放FD &amp;&amp; BK，同时将物理相邻的上一个bin空间复用作为自己的chunk header</strong></p>
<p>关于bin chunk的内存复用思想如下图所示：</p>
<p><img src="https://i.loli.net/2020/12/22/6fZzuqnyxjcFAKl.png" alt="image.png"></p>
<p>同时有一个宏用以根据chunk的size获取相对应的bin下标，笔者在后面会展开讲这个宏里面的东西</p>
<h3 id="2-bins相关定义宏"><a href="#2-bins相关定义宏" class="headerlink" title="2.bins相关定义宏"></a>2.bins相关定义宏</h3><p>如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Indexing</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Bins for sizes &lt; 512 bytes contain chunks of all the same size, spaced</span></span><br><span class="line"><span class="comment">    8 bytes apart. Larger bins are approximately logarithmically spaced:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    64 bins of size       8</span></span><br><span class="line"><span class="comment">    32 bins of size      64</span></span><br><span class="line"><span class="comment">    16 bins of size     512</span></span><br><span class="line"><span class="comment">     8 bins of size    4096</span></span><br><span class="line"><span class="comment">     4 bins of size   32768</span></span><br><span class="line"><span class="comment">     2 bins of size  262144</span></span><br><span class="line"><span class="comment">     1 bin  of size what&#x27;s left</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    There is actually a little bit of slop in the numbers in bin_index</span></span><br><span class="line"><span class="comment">    for the sake of speed. This makes no difference elsewhere.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The bins top out around 1MB because we expect to service large</span></span><br><span class="line"><span class="comment">    requests via mmap.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Bin 0 does not exist.  Bin 1 is the unordered list; if that would be</span></span><br><span class="line"><span class="comment">    a valid chunk size the small bins are bumped up one.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NBINS             128</span></span><br></pre></td></tr></table></figure>

<p>对于装载着size小于512（0x200）的chunk的bin而言，每个bin中都存放着相同大小的chunk，而存放更大size的chunk的bin（large bin）中每个bin中chunk的大小并不一致，而是处于一定范围内，被分为7组，（32位下）每组bin中chunk size间公差如上表所示（64位直接 * 2即可）</p>
<p>同时，<strong>bin 0不存在，bin 1则是一个无序的链表</strong>（unsorted bin）</p>
<p>宏定义了<code>NBIINS</code>为<code>128</code>，也就是说理应有着128个bin存放不同类型的chunk，但是bin 0 不存在，因此<strong>实际上只有127个bin</strong>，在后续arena的定义中我们也能看出这一点</p>
<h4 id="①unsorted-bin相关宏"><a href="#①unsorted-bin相关宏" class="headerlink" title="①unsorted bin相关宏"></a>①unsorted bin相关宏</h4><p>如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Unsorted chunks</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    All remainders from chunk splits, as well as all returned chunks,</span></span><br><span class="line"><span class="comment">    are first placed in the &quot;unsorted&quot; bin. They are then placed</span></span><br><span class="line"><span class="comment">    in regular bins after malloc gives them ONE chance to be used before</span></span><br><span class="line"><span class="comment">    binning. So, basically, the unsorted_chunks list acts as a queue,</span></span><br><span class="line"><span class="comment">    with chunks being placed on it in free (and malloc_consolidate),</span></span><br><span class="line"><span class="comment">    and taken off (to be either used or placed in bins) in malloc.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The NON_MAIN_ARENA flag is never set for unsorted chunks, so it</span></span><br><span class="line"><span class="comment">    does not have to be taken into account in size comparisons.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The otherwise unindexable 1-bin is used to hold unsorted chunks. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unsorted_chunks(M)          (bin_at (M, 1))</span></span><br></pre></td></tr></table></figure>

<p>对于在chunk分割过程中所剩余的chunk、以及所有回归闲置的chunk都会<strong>首先被存放在unsorted bin当中</strong>；当调用malloc时其中的chunk会有机会被放回到常规的bins中；因此通常情况下unsort bin就像一个队列一样，在free&#x2F;malloc_consolidate中chunk会被放置其中，而在malloc时其中的chunk又会被重新拿走；<strong>unsorted bin中的chunk永远不会设置NON_MAIN_ARENA标志位</strong></p>
<p>同时我们也可以得知对于存放在unsorted bin中的chunk的size并没有做限制</p>
<p>定义了宏<strong>unsorted_chunks()<strong>用以获得unsorted bin，我们可以看到</strong>unsorted bin在bins数组中占用了下标0与下标1，也就是说其为bins中的第一个bin</strong></p>
<h4 id="②small-bins相关宏"><a href="#②small-bins相关宏" class="headerlink" title="②small bins相关宏"></a>②small bins相关宏</h4><p>bin 0不存在， 而bin 1 是unsorted bin， 故small bins应当从bin 2 开始存放</p>
<p>相关宏如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NSMALLBINS         64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALLBIN_WIDTH    MALLOC_ALIGNMENT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> in_smallbin_range(sz)  \</span></span><br><span class="line"><span class="meta">  ((unsigned long) (sz) &lt; (unsigned long) MIN_LARGE_SIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> smallbin_index(sz) \</span></span><br><span class="line"><span class="meta">  ((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) &gt;&gt; 4) : (((unsigned) (sz)) &gt;&gt; 3))\</span></span><br><span class="line"><span class="meta">   + SMALLBIN_CORRECTION)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>NSMALLBINS</strong>：small bins位于bins下标的终止，即<strong>从bin1开始到bin63一共62个bin是属于small bins的</strong>，这里需要注意的是<strong>不要直接理解为small bins的数量</strong>，后面会说明为什么是62个</li>
<li><strong>SMALLBIN_WIDTH</strong>：<strong>每个 small bin 之间所储存的chunk的size差值</strong></li>
<li><strong>SMALLBIN_CORRECTION</strong>：查阅了一下<del>指谷歌</del>，有一种说法是这个宏是用以检查bin是否被破坏的，若被破坏则针对后续的下标相关操作进行修正<del>这个宏一般来说都为0所以我也不懂有什么用，大概可以直接忽视掉，嗯x</del></li>
<li><strong>MIN_LARGE_SIZE</strong>：<strong>最小的large bin范围内的chunk的size</strong>，只有小于这个size的chunk才属于small bin的范围内，<strong>32位下为512，64位下为1024</strong></li>
<li><strong>in_smallbin_range</strong> ()：用以<strong>检查一个chunk的size是否属于small bin范围内</strong></li>
<li><strong>smallbin_index</strong> ()：用以<strong>获得一个small bin chunk处在bin中的index</strong>，由于bin 1是unsorted bin所以直接进行移位操作即可获得index</li>
</ul>
<p>通过MIN_LARGE_SIZE我们可以知道<strong>最大的small bin的size在32位下为504， 64位下为1008</strong>（减去了一个MALLOC_ALIGNMENT），<strong>由此我们便可以得出small bins的数量为62</strong></p>
<h4 id="③large-bins相关宏"><a href="#③large-bins相关宏" class="headerlink" title="③large bins相关宏"></a>③large bins相关宏</h4><p>如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index_32(sz)                                                \</span></span><br><span class="line"><span class="meta">  (((((unsigned long) (sz)) &gt;&gt; 6) <span class="string">&lt;= 38) ?  56 + (((unsigned long) (sz)) &gt;</span>&gt; 6) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 9) <span class="string">&lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;</span>&gt; 9) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 12) <span class="string">&lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;</span>&gt; 12) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 15) <span class="string">&lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;</span>&gt; 15) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 18) <span class="string">&lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;</span>&gt; 18) :\</span></span><br><span class="line"><span class="meta">   126)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index_32_big(sz)                                            \</span></span><br><span class="line"><span class="meta">  (((((unsigned long) (sz)) &gt;&gt; 6) <span class="string">&lt;= 45) ?  49 + (((unsigned long) (sz)) &gt;</span>&gt; 6) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 9) <span class="string">&lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;</span>&gt; 9) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 12) <span class="string">&lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;</span>&gt; 12) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 15) <span class="string">&lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;</span>&gt; 15) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 18) <span class="string">&lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;</span>&gt; 18) :\</span></span><br><span class="line"><span class="meta">   126)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// XXX It remains to be seen whether it is good to keep the widths of</span></span><br><span class="line"><span class="comment">// XXX the buckets the same or whether it should be scaled by a factor</span></span><br><span class="line"><span class="comment">// XXX of two as well.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index_64(sz)                                                \</span></span><br><span class="line"><span class="meta">  (((((unsigned long) (sz)) &gt;&gt; 6) <span class="string">&lt;= 48) ?  48 + (((unsigned long) (sz)) &gt;</span>&gt; 6) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 9) <span class="string">&lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;</span>&gt; 9) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 12) <span class="string">&lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;</span>&gt; 12) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 15) <span class="string">&lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;</span>&gt; 15) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 18) <span class="string">&lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;</span>&gt; 18) :\</span></span><br><span class="line"><span class="meta">   126)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index(sz) \</span></span><br><span class="line"><span class="meta">  (SIZE_SZ == 8 ? largebin_index_64 (sz)                                     \</span></span><br><span class="line"><span class="meta">   : MALLOC_ALIGNMENT == 16 ? largebin_index_32_big (sz)                     \</span></span><br><span class="line"><span class="meta">   : largebin_index_32 (sz))</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>largebin_index_32() &amp;&amp; largebin_index_64</strong> ()：一般情况下用以<strong>获取large bin chunk位于bin中的index</strong></li>
<li><strong>largebin_index_32_big</strong> ()：若是在32位下MALLOC_ALIGNMENT为16时才会启用的特殊宏用以获取index，这是因为常规情况下32位下MALLOC_ALIGNMENT为8，若是扩大到16的话自然计算large bin的index的策略也要改变</li>
<li><strong>largebin_index</strong> ()：对前面三个宏的封装，用以<strong>获取large bin chunk位于bin中的index</strong></li>
</ul>
<p>可以看得出来，相较于small bin而言，由于large bin采用了更为特殊的策略，故其获取index的过程也更为复杂，具体可以参见这一节开头先前的关于large bin size的说明</p>
<p>通过这些宏定义我们也可以算出<strong>一共有63个large bin</strong></p>
<h3 id="3-unlink：从bins中取出chunk"><a href="#3-unlink：从bins中取出chunk" class="headerlink" title="3.unlink：从bins中取出chunk"></a>3.unlink：从bins中取出chunk</h3><p>由于从各种bins中取出一个chunk的操作十分频繁，若是使用函数实现则会造成较大的开销，故unlink操作被单独实现为一个宏，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            \</span></span><br><span class="line"><span class="meta">    FD = P-&gt;fd;								      \</span></span><br><span class="line"><span class="meta">    BK = P-&gt;bk;								      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))		      \</span></span><br><span class="line"><span class="meta">      malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);  \</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span> &#123;								      \</span></span><br><span class="line"><span class="meta">        FD-&gt;bk = BK;							      \</span></span><br><span class="line"><span class="meta">        BK-&gt;fd = FD;							      \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (!in_smallbin_range (P-&gt;size)				      \</span></span><br><span class="line"><span class="meta">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123;		      \</span></span><br><span class="line"><span class="meta">	    <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0)	      \</span></span><br><span class="line"><span class="meta">		|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0))    \</span></span><br><span class="line"><span class="meta">	      malloc_printerr (check_action,				      \</span></span><br><span class="line"><span class="meta">			       <span class="string">&quot;corrupted double-linked list (not small)&quot;</span>,    \</span></span><br><span class="line"><span class="meta">			       P, AV);					      \</span></span><br><span class="line"><span class="meta">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == NULL) &#123;				      \</span></span><br><span class="line"><span class="meta">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P)				      \</span></span><br><span class="line"><span class="meta">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;		      \</span></span><br><span class="line"><span class="meta">                <span class="keyword">else</span> &#123;							      \</span></span><br><span class="line"><span class="meta">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;			      \</span></span><br><span class="line"><span class="meta">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;			      \</span></span><br><span class="line"><span class="meta">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;			      \</span></span><br><span class="line"><span class="meta">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;			      \</span></span><br><span class="line"><span class="meta">                  &#125;							      \</span></span><br><span class="line"><span class="meta">              &#125; <span class="keyword">else</span> &#123;							      \</span></span><br><span class="line"><span class="meta">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;		      \</span></span><br><span class="line"><span class="meta">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;		      \</span></span><br><span class="line"><span class="meta">              &#125;								      \</span></span><br><span class="line"><span class="meta">          &#125;								      \</span></span><br><span class="line"><span class="meta">      &#125;									      \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure>

<p>大致的一个流程如下：</p>
<ul>
<li>P为要被unlink的chunk，FD、BK则是chunk：P-&gt;fd与P-&gt;bk</li>
<li>检查FD-&gt;bk与BK-&gt;fd是否都指向P，若否，则输出错误信息</li>
<li>将FD-&gt;bk指向BK，将BK-&gt;fd指向FD，<strong>这个时候这个chunk便已经不在该bin的双向循环链表中了</strong></li>
<li><strong>若是chunk size位于small bin的范围内，则unlink结束，否则标志着此时chunk的fd_nextsize与bk_nextsize字段是启用的，需要接着将之从nextsize链表中unlink</strong>（large bin特有）</li>
<li>检查P-&gt;fd_nextsize-&gt;bk_size与P-&gt;bk_nextsize-&gt;fd_nextsize是否指向P，和前面的过程类似这里便不再赘叙</li>
<li><strong>若FD-&gt;fd_nextsize不为NULL，则将P从其所处nextsize链表中unlink</strong></li>
<li><strong>若FD-&gt;fd_nextsize为NULL时</strong>，若P-&gt;fd_nextsize指向自身，则将FD-&gt;fd_nextsize与FD-&gt;bk_nextsize都指向FD（代表该chunk不属于任何一个nextsize链表？），<strong>否则使用FD替换掉P所在的nextsize链表中的位置</strong></li>
</ul>
<p>大致过程如下图所示</p>
<p><img src="https://i.loli.net/2020/12/23/AVsn1tB9hydocYe.png" alt="image.png"></p>
<p><img src="https://i.loli.net/2020/12/23/MfhiGYa97XLRtHK.png" alt="image.png"></p>
<p><img src="https://i.loli.net/2020/12/23/gkAXzI2M8UviO9C.png" alt="image.png"></p>
<p><img src="https://i.loli.net/2020/12/23/TR23CkfSEOLYtgh.png" alt="image.png"></p>
<p><img src="https://i.loli.net/2020/12/23/FGMlVisw69xtThJ.png" alt="image.png"></p>
<p><img src="https://i.loli.net/2020/12/23/PNIcnpb1YJovmai.png" alt="image.png"></p>
<blockquote>
<p>unlink操作应该是我在0x00中画图最多的一部分了…</p>
</blockquote>
<blockquote>
<h5 id="builtin-expect-expr-var-：分支预测优化"><a href="#builtin-expect-expr-var-：分支预测优化" class="headerlink" title="__builtin_expect(expr, var)：分支预测优化"></a>__builtin_expect(expr, var)：分支预测优化</h5><p>gcc的分支预测优化代码，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Tell the compiler when a conditional or integer expression is</span></span><br><span class="line"><span class="comment">almost always true or almost always false.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HAVE_BUILTIN_EXPECT</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __builtin_expect(expr, val) (expr)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>该代码用于<strong>编译器</strong>分支预测优化，<strong>当expr的值在大部分情况下都为var时，便可以使用该宏，编译器会针对该分支预测进行相应的优化</strong></p>
</blockquote>
<blockquote>
<h5 id="malloc-printerr"><a href="#malloc-printerr" class="headerlink" title="malloc_printerr()"></a>malloc_printerr()</h5><p>定义于malloc.c中的一个函数，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">malloc_printerr</span> <span class="params">(<span class="type">int</span> action, <span class="type">const</span> <span class="type">char</span> *str, <span class="type">void</span> *ptr, mstate ar_ptr)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* Avoid using this arena in future.  We do not attempt to synchronize this</span></span><br><span class="line"><span class="comment">with anything else because we minimally want to ensure that __libc_message</span></span><br><span class="line"><span class="comment">gets its resources safely without stumbling on the current corruption.  */</span></span><br><span class="line"><span class="keyword">if</span> (ar_ptr)</span><br><span class="line">set_arena_corrupt (ar_ptr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((action &amp; <span class="number">5</span>) == <span class="number">5</span>)</span><br><span class="line">__libc_message (action &amp; <span class="number">2</span>, <span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (action &amp; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">2</span> * <span class="keyword">sizeof</span> (<span class="type">uintptr_t</span>) + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">buf[<span class="keyword">sizeof</span> (buf) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="type">char</span> *cp = _itoa_word ((<span class="type">uintptr_t</span>) ptr, &amp;buf[<span class="keyword">sizeof</span> (buf) - <span class="number">1</span>], <span class="number">16</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span> (cp &gt; buf)</span><br><span class="line">  *--cp = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">__libc_message (action &amp; <span class="number">2</span>, <span class="string">&quot;*** Error in `%s&#x27;: %s: 0x%s ***\n&quot;</span>,</span><br><span class="line">                __libc_argv[<span class="number">0</span>] ? : <span class="string">&quot;&lt;unknown&gt;&quot;</span>, str, cp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (action &amp; <span class="number">2</span>)</span><br><span class="line"><span class="built_in">abort</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先检查arena指针是否为空，若否则设置arena被破坏的标志位</p>
<p>随后根据action的不同的值做出不同的决策：</p>
<ul>
<li>5：直接输出错误信息</li>
<li>1：声明了一个buf数组用以存储地址信息，随后输出错误信息</li>
<li>2：直接调用abort()函数终止程序</li>
</ul>
<p>__libc_message()函数用于输出错误信息，该函数定义于sysdeps&#x2F;posix&#x2F;libc_fatal.c中，由于不是本篇文章的重点故不作详细说明</p>
<p>abort()函数定义于stdlib&#x2F;abort.c中，用以终止程序并把core给dump下来，这里也不再深入说明</p>
</blockquote>
<h3 id="4-binmap：用来标识bin状态（是否为空）的数组"><a href="#4-binmap：用来标识bin状态（是否为空）的数组" class="headerlink" title="4.binmap：用来标识bin状态（是否为空）的数组"></a>4.binmap：用来标识bin状态（是否为空）的数组</h3><p>我们先来看malloc.c中对于binmap的说明如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Binmap</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    To help compensate for the large number of bins, a one-level index</span></span><br><span class="line"><span class="comment">    structure is used for bin-by-bin searching.  `binmap&#x27; is a</span></span><br><span class="line"><span class="comment">    bitvector recording whether bins are definitely empty so they can</span></span><br><span class="line"><span class="comment">    be skipped over during during traversals.  The bits are NOT always</span></span><br><span class="line"><span class="comment">    cleared as soon as bins are empty, but instead only</span></span><br><span class="line"><span class="comment">    when they are noticed to be empty during traversal in malloc.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Conservatively use 32 bits per map word, even if on 64bit system */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BINMAPSHIFT      5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BITSPERMAP       (1U &lt;&lt; BINMAPSHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BINMAPSIZE       (NBINS / BITSPERMAP)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> idx2block(i)     ((i) &gt;&gt; BINMAPSHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> idx2bit(i)       ((1U &lt;&lt; ((i) &amp; ((1U &lt;&lt; BINMAPSHIFT) - 1))))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mark_bin(m, i)    ((m)-&gt;binmap[idx2block (i)] |= idx2bit (i))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unmark_bin(m, i)  ((m)-&gt;binmap[idx2block (i)] &amp;= ~(idx2bit (i)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> get_binmap(m, i)  ((m)-&gt;binmap[idx2block (i)] &amp; idx2bit (i))</span></span><br></pre></td></tr></table></figure>

<p>大意是说由于bins的数量过多，故ptmalloc在bin的遍历查找中使用一种称之为binmap的一级索引结构。binmap使用<strong>「位向量」</strong>来标记bins数组中的每一个bin，以便于能够快速遍历bins。</p>
<p><strong>在一个bin被置空时其binmap内对应的标志位并不会被立即清空，只会在下次重新遍历时重新置位</strong></p>
<p>binmap的设计思想是<strong>充分利用每一位来进行bin状态的标记</strong></p>
<p>首先定义了三个宏：</p>
<ul>
<li><strong>BINMAPSHIFT</strong>：binmap中一个map的计数量的移位数</li>
<li><strong>BITSPERMAP</strong>：binmap中每个map所储存的bit数，同时也是一个map所对应的bins数，<strong>为32</strong></li>
<li><strong>BINMAPSIZE</strong>：binmap的大小，在这里可以看出来binmap中map的数量是根据bins的数量来计算的，<strong>为4</strong></li>
</ul>
<p>binmap在ptmalloc中是unsigned int类型，32位&amp;&amp;64位下都是4字节，由此我们便可以得出binmap的大致结构应当如下图所示：</p>
<p><img src="https://i.loli.net/2020/12/27/PO3noG2fuUMitXz.png" alt="image.png"></p>
<p>由此还定义了如下宏：</p>
<ul>
<li><p><strong>idx2block</strong> ()：由bin对应bins数组的index获取其对应的binmap中的map的index（0~3）</p>
</li>
<li><p><strong>idx2bit</strong> ()：由bin对应bins数组的index获取其对应的binmap中的map的bit（该值应为2^n，n为[0, 31]中任一整数）</p>
</li>
<li><p><strong>mark_bin</strong> ()：在binmap中标记该bin为非空（设该bit为1）</p>
</li>
<li><p><strong>unmark_bin</strong> ()：在binmap中标记该bin为空（设该bit为0）</p>
</li>
<li><p><strong>get_binmap</strong> ()：获得一个bin在binmap中的标记位的<strong>原始值</strong></p>
<p>不过我们还需要注意的一点便是：<strong>fastbin不使用binmap标志位</strong>，fastbin是专门用以存储小chunk的独立于bins数组之外的bins数组，设计的目的是提高chunk的使用效率，下面我们就来讲讲fastbin</p>
</li>
</ul>
<h2 id="四、Fastbins：快速存取chunk的数组"><a href="#四、Fastbins：快速存取chunk的数组" class="headerlink" title="四、Fastbins：快速存取chunk的数组"></a>四、Fastbins：快速存取chunk的数组</h2><p>虽然我们在前面讲到在ptmalloc中使用Bins数组储存闲置的chunk，但是由于大部分程序都会频繁地申请以及释放一些较小的chunk，若是我们将大部分的时间都花在合并chunk、分割chunk、繁复的安全检查上，则会会大大地降低堆的利用效率，故ptmalloc<strong>独立于Bins之外单独设计了一个Fastbin用以储存一些size较小的闲置chunk</strong>，说明如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Fastbins</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    An array of lists holding recently freed small chunks.  Fastbins</span></span><br><span class="line"><span class="comment">    are not doubly linked.  It is faster to single-link them, and</span></span><br><span class="line"><span class="comment">    since chunks are never removed from the middles of these lists,</span></span><br><span class="line"><span class="comment">    double linking is not necessary. Also, unlike regular bins, they</span></span><br><span class="line"><span class="comment">    are not even processed in FIFO order (they use faster LIFO) since</span></span><br><span class="line"><span class="comment">    ordering doesn&#x27;t much matter in the transient contexts in which</span></span><br><span class="line"><span class="comment">    fastbins are normally used.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Chunks in fastbins keep their inuse bit set, so they cannot</span></span><br><span class="line"><span class="comment">    be consolidated with other free chunks. malloc_consolidate</span></span><br><span class="line"><span class="comment">    releases all chunks in fastbins and consolidates them with</span></span><br><span class="line"><span class="comment">    other free chunks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> *<span class="title">mfastbinptr</span>;</span></span><br></pre></td></tr></table></figure>



<ul>
<li><p>Fastbins是一个用以保存最近释放的较小的chunk的数组，为了提高速度其<strong>使用单向链表进行链接</strong></p>
</li>
<li><p><strong>Fastbin采取FILO&#x2F;LIFO的策略，即每次都取用fastbin链表头部的chunk，每次释放chunk时都插入至链表头部成为新的头结点</strong>，因而大幅提高了存取chunk的速度</p>
</li>
<li><p><strong>Fastbin中的chunk永远保持在in_use的状态，这也保证了她们不会被与其他的free chunk合并</strong></p>
</li>
<li><p><strong>malloc_consolidate()函数将会清空fastbin中所有的chunk，在进行相应的合并后送入普通的small bins中</strong></p>
</li>
</ul>
<h3 id="fastbin相关宏"><a href="#fastbin相关宏" class="headerlink" title="fastbin相关宏"></a>fastbin相关宏</h3><p>malloc.c中同样定义了一些与fastbin相关的宏，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[idx])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* offset 2 to use otherwise unindexable first 2 bins */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fastbin_index(sz) \</span></span><br><span class="line"><span class="meta">  ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</span></span><br><span class="line"><span class="comment">/* The maximum fastbin request size we support */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_FAST_SIZE     (80 * SIZE_SZ / 4)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NFASTBINS  (fastbin_index (request2size (MAX_FAST_SIZE)) + 1)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>fastbin</strong> ()：从一个arena中获取其fastbin数组相应下标的bin</p>
</li>
<li><p><strong>fastbin_index</strong> ()：根据chunk的size获取其应当处于的fast bin的index，在这里我们可以发现一点是<strong>fastbin计算index时是通过移位操作进行的，即标志位的不同对于fastbin index的计算并没有影响，这也是为什么我们在fastbin attack时能够利用malloc_hook - 0x23位置上的0x7f这个值分配到一个fake chunk的原因</strong>（后续会在malloc中说明fastbin相关的安全检查）</p>
</li>
<li><p><strong>MAX_FAST_SIZE</strong>：<strong>【定义上的】最大的fastbin chunk的size，超过这个size的chunk都将会被送入unsorted bin中；32位系统下为0x50，64位系统下为0xA0</strong></p>
</li>
<li><p><strong>NFASTBINS</strong>：Fastbins中bin的数量，简单计算一下便可知<strong>32位下NFASTBINS为11，64位下NFASTBINS为10</strong></p>
</li>
</ul>
<h3 id="fastbin-size详解"><a href="#fastbin-size详解" class="headerlink" title="fastbin size详解"></a>fastbin size详解</h3><p>需要注意的是虽然说定义了一个MAX_FAST_SIZE宏说明fastbin最大支持的size，但其实<strong>fastbin数组中的bin 7、8、9都是用不上的，这是因为fastbin chunk真正的size范围是由如下宏进行定义的</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> set_max_fast(s) \</span></span><br><span class="line"><span class="meta">  global_max_fast = (((s) == 0)						      \</span></span><br><span class="line"><span class="meta">                     ? SMALLBIN_WIDTH : ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> get_max_fast() global_max_fast</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">/* Maximum size of memory handled in fastbins.  */</span></span><br><span class="line"><span class="type">static</span> INTERNAL_SIZE_T global_max_fast;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>global_max_fast</strong>：<strong>fastbin chunk size最大值</strong></li>
<li><strong>set_max_fast</strong> ()：设置global_max_fast，<strong>若为0则初始化为SMALLBIN_WIDTH</strong></li>
<li><strong>get_max_fast</strong> ()：获取global_max_fast</li>
</ul>
<p>而<strong>在malloc_init_state()函数中初始化fastbin chunk的max size为DEFAULT_MXFAST，而不是MAX_FAST_SIZE</strong>，在后面的部分我们会详细解析这个函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">malloc_init_state</span> <span class="params">(mstate av)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">if</span> (av == &amp;main_arena)</span><br><span class="line">    set_max_fast (DEFAULT_MXFAST);</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>DEFAULT_MXFAST定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DEFAULT_MXFAST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_MXFAST     (64 * SIZE_SZ / 4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>也就是说<strong>32位下最大的fastbin chunk size为0x40， 64位下最大的fastbin chunk size为0x80，超过这个范围的chunk在free之后则会被送入unsorted bin中</strong></p>
<h2 id="五、malloc-par：堆管理器参数"><a href="#五、malloc-par：堆管理器参数" class="headerlink" title="五、malloc_par：堆管理器参数"></a>五、malloc_par：堆管理器参数</h2><p>在ptmalloc中使用malloc_par结构体来记录堆管理器的相关参数，该结构体定义于malloc.c中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_par</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Tunable parameters */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> trim_threshold;</span><br><span class="line">  INTERNAL_SIZE_T top_pad;</span><br><span class="line">  INTERNAL_SIZE_T mmap_threshold;</span><br><span class="line">  INTERNAL_SIZE_T arena_test;</span><br><span class="line">  INTERNAL_SIZE_T arena_max;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory map support */</span></span><br><span class="line">  <span class="type">int</span> n_mmaps;</span><br><span class="line">  <span class="type">int</span> n_mmaps_max;</span><br><span class="line">  <span class="type">int</span> max_n_mmaps;</span><br><span class="line">  <span class="comment">/* the mmap_threshold is dynamic, until the user sets</span></span><br><span class="line"><span class="comment">     it manually, at which point we need to disable any</span></span><br><span class="line"><span class="comment">     dynamic behavior. */</span></span><br><span class="line">  <span class="type">int</span> no_dyn_threshold;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Statistics */</span></span><br><span class="line">  INTERNAL_SIZE_T mmapped_mem;</span><br><span class="line">  <span class="comment">/*INTERNAL_SIZE_T  sbrked_mem;*/</span></span><br><span class="line">  <span class="comment">/*INTERNAL_SIZE_T  max_sbrked_mem;*/</span></span><br><span class="line">  INTERNAL_SIZE_T max_mmapped_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_total_mem;  <span class="comment">/* only kept for NO_THREADS */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First address handed out by MORECORE/sbrk.  */</span></span><br><span class="line">  <span class="type">char</span> *sbrk_base;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>主要是定义了和mmap和arena相关的一些参数（如数量上限等），以及sbrk的基址</p>
<h3 id="mp-：记录ptmalloc相关参数的malloc-par结构体"><a href="#mp-：记录ptmalloc相关参数的malloc-par结构体" class="headerlink" title="mp_：记录ptmalloc相关参数的malloc_par结构体"></a>mp_：记录ptmalloc相关参数的malloc_par结构体</h3><p>该静态结构体用以记录ptmalloc相关参数，同样定义于malloc.c中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_par</span> <span class="title">mp_</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  .top_pad = DEFAULT_TOP_PAD,</span><br><span class="line">  .n_mmaps_max = DEFAULT_MMAP_MAX,</span><br><span class="line">  .mmap_threshold = DEFAULT_MMAP_THRESHOLD,</span><br><span class="line">  .trim_threshold = DEFAULT_TRIM_THRESHOLD,</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NARENAS_FROM_NCORES(n) ((n) * (sizeof (long) == 4 ? 2 : 8))</span></span><br><span class="line">  .arena_test = NARENAS_FROM_NCORES (<span class="number">1</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>宏再展开的代码就不贴了，大概做了以下几件事：</p>
<ul>
<li>设置了<code>top_pad</code>为 0</li>
<li>设置了<code>n_maps_max</code>为 65535</li>
<li>设置了<code>mmap_threshold</code>为 128 * 1024</li>
<li>设置了<code>trim_threshold</code>为 128 * 1024</li>
<li>设置了<code>arena_test</code>在gcc中32下为2，64位下为8（不同的编译器中long的长度可能不同，这里仅以gcc为例）</li>
</ul>
<h2 id="六、heap-info：Heap-Header-for-heap-allocated-by-mmap"><a href="#六、heap-info：Heap-Header-for-heap-allocated-by-mmap" class="headerlink" title="六、heap_info：Heap Header(for heap allocated by mmap)"></a>六、heap_info：Heap Header(for heap allocated by mmap)</h2><p>该结构体类型定义于arena.c中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* A heap is a single contiguous memory region holding (coalesceable)</span></span><br><span class="line"><span class="comment">   malloc_chunks.  It is allocated with mmap() and always starts at an</span></span><br><span class="line"><span class="comment">   address aligned to HEAP_MAX_SIZE.  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  mstate ar_ptr; <span class="comment">/* Arena for this heap. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span> *<span class="title">prev</span>;</span> <span class="comment">/* Previous heap. */</span></span><br><span class="line">  <span class="type">size_t</span> size;   <span class="comment">/* Current size in bytes. */</span></span><br><span class="line">  <span class="type">size_t</span> mprotect_size; <span class="comment">/* Size in bytes that has been mprotected</span></span><br><span class="line"><span class="comment">                           PROT_READ|PROT_WRITE.  */</span></span><br><span class="line">  <span class="comment">/* Make sure the following data is properly aligned, particularly</span></span><br><span class="line"><span class="comment">     that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of</span></span><br><span class="line"><span class="comment">     MALLOC_ALIGNMENT. */</span></span><br><span class="line">  <span class="type">char</span> pad[<span class="number">-6</span> * SIZE_SZ &amp; MALLOC_ALIGN_MASK];</span><br><span class="line">&#125; heap_info;</span><br></pre></td></tr></table></figure>

<p><strong>heap_info位于一个heap块的开头，</strong>用以记录<strong>通过mmap系统调用从Memory Mapping Segment处申请到的内存块的信息</strong></p>
<p><strong>heap_info之间链接成一个单向链表</strong></p>
<p>其中有一个mstate类型，定义于include&#x2F;malloc.h中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _MALLOC_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc/malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* In the GNU libc we rename the global variable</span></span><br><span class="line"><span class="comment">   `__malloc_initialized&#x27; to `__libc_malloc_initialized&#x27;.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __malloc_initialized __libc_malloc_initialized</span></span><br><span class="line"><span class="comment">/* Nonzero if the malloc is already initialized.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> __malloc_initialized attribute_hidden;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">mstate</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>也就是说mstate其实是<strong>指向malloc_state结构体的指针</strong>的typedef别名，即<strong>指向arena的指针</strong></p>
<p>结合注释我们可以得出heap_info结构体的成员如下：</p>
<ul>
<li><strong>ar_ptr</strong>：指向管理该堆块的arena</li>
<li><strong>prev</strong>：该heap_info所链接的上一个heap_info</li>
<li><strong>size</strong>：记录该堆块的大小</li>
<li><strong>mprotect_size</strong>：记录该堆块中被保护（mprotected）的大小</li>
<li><strong>pad</strong>：即padding，用以<strong>在SIZE_SZ不正常的情况下进行填充以让内存对齐</strong>，<strong>正常情况下pad所占用空间应为0字节</strong></li>
</ul>
<p>那么我们可以得出使用mmap系统调用分配的一个heap的结构应当如下：</p>
<p><img src="https://i.loli.net/2021/01/14/vgjIJmEwQu6crLB.png" alt="image.png"></p>
<p>更多的会在后续讲到相关函数时说到</p>
<h3 id="heap-info相关宏"><a href="#heap-info相关宏" class="headerlink" title="heap_info相关宏"></a>heap_info相关宏</h3><p>arena.c中还定义了一些相关的宏，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_MIN_SIZE (32 * 1024)</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HEAP_MAX_SIZE</span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> DEFAULT_MMAP_THRESHOLD_MAX</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> HEAP_MAX_SIZE (2 * DEFAULT_MMAP_THRESHOLD_MAX)</span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> HEAP_MAX_SIZE (1024 * 1024) <span class="comment">/* must be a power of two */</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* HEAP_MIN_SIZE and HEAP_MAX_SIZE limit the size of mmap()ed heaps</span></span><br><span class="line"><span class="comment">   that are dynamically created for multi-threaded programs.  The</span></span><br><span class="line"><span class="comment">   maximum size must be a power of two, for fast determination of</span></span><br><span class="line"><span class="comment">   which heap belongs to a chunk.  It should be much larger than the</span></span><br><span class="line"><span class="comment">   mmap threshold, so that requests with a size just below that</span></span><br><span class="line"><span class="comment">   threshold can be fulfilled without creating too many heaps.  */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>HEAP_MIN_SIZE</strong>：用mmap所分配的堆块的最小大小，应当为<code>32 * 1024</code></p>
</li>
<li><p><strong>HEAP_MAX_SIZE</strong>：用mmap所分配的堆块的最大大小，这个值由<code>DEFAULE_MMAP_THRESHOLD_MAX</code>宏决定，该宏定义于malloc.c中，如下：</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DEFAULT_MMAP_THRESHOLD_MAX</span></span><br><span class="line">  <span class="comment">/* For 32-bit platforms we cannot increase the maximum mmap</span></span><br><span class="line"><span class="comment">     threshold much because it is also the minimum value for the</span></span><br><span class="line"><span class="comment">     maximum heap size and its alignment.  Going above 512k (i.e., 1M</span></span><br><span class="line"><span class="comment">     for new heaps) wastes too much address space.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> __WORDSIZE == 32</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> DEFAULT_MMAP_THRESHOLD_MAX (512 * 1024)</span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> DEFAULT_MMAP_THRESHOLD_MAX (4 * 1024 * 1024 * sizeof(long))</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>__WORDSIZE宏所获取的是字长的位数，定义于sysdeps&#x2F;x86&#x2F;bits&#x2F;wordsize.h下，这里便不再赘叙</p>
<p>那么我们便可以得知在32位下mmap所分配的堆块的最大大小应当为<code>2 * 512 * 1024</code>，64位下应当为<code>2 * 4 * 1024 * 1024 * (sizeof(long)) </code></p>
<p>由于使用mmap分配的堆块的大小是对于HEAP_MAX_SIZE对齐的，故通过此特点可以通过指向堆块上某位置的指针直接获取到一个指向该堆块的指针，因此也定义了相关宏，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* find the heap and corresponding arena for a given ptr */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> heap_for_ptr(ptr) \</span></span><br><span class="line"><span class="meta">  ((heap_info *) ((unsigned long) (ptr) &amp; ~(HEAP_MAX_SIZE - 1)))</span></span><br></pre></td></tr></table></figure>

<p>该宏用以通过一个指向某堆块上某位置的指针获取到指向该堆块的指针</p>
<h2 id="七、arena：线程内存池"><a href="#七、arena：线程内存池" class="headerlink" title="七、arena：线程内存池"></a>七、arena：线程内存池</h2><p>从最小的chunk开始自底向上分析现在终于到了分析arena的源码的时候，arena这个词直译是“竞技场”的意思，<del>wsm要起这种奇怪的名字我也不知道，可能是因为听起来比较帅气吧</del>，按照笔者的理解，arena在ptmalloc中用以表示<strong>「单个线程独立维护的内存池」</strong>，这是由于大部分情况下对于每个线程而言其都会单独有着一个arena实例用以管理属于该线程的堆内存区域，包括Bins、Fastbin等其实都是被放置在arena的结构体中统一进行管理的</p>
<p>在malloc.c中对于ptmalloc的内部数据结构说明如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   -------------------- Internal data structures --------------------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   All internal state is held in an instance of malloc_state defined</span></span><br><span class="line"><span class="comment">   below. There are no other static variables, except in two optional</span></span><br><span class="line"><span class="comment">   cases:</span></span><br><span class="line"><span class="comment"> * If USE_MALLOC_LOCK is defined, the mALLOC_MUTEx declared above.</span></span><br><span class="line"><span class="comment"> * If mmap doesn&#x27;t support MAP_ANONYMOUS, a dummy file descriptor</span></span><br><span class="line"><span class="comment">     for mmap.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Beware of lots of tricks that minimize the total bookkeeping space</span></span><br><span class="line"><span class="comment">   requirements. The result is a little over 1K bytes (for 4byte</span></span><br><span class="line"><span class="comment">   pointers and size_t.)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>ptmalloc内部的内存池结构是由malloc_state结构体进行定义的，即arena本身便为malloc_state的一个实例对象</p>
<h3 id="1-malloc-state结构体"><a href="#1-malloc-state结构体" class="headerlink" title="1.malloc_state结构体"></a>1.malloc_state结构体</h3><p>malloc_state结构体定义于malloc&#x2F;malloc.c中，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">  <span class="type">mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="type">int</span> flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  mchunkptr top;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> binmap[BINMAPSIZE];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">     by free_list_lock in arena.c.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">     the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">     free_list_lock in arena.c.  */</span></span><br><span class="line">  INTERNAL_SIZE_T attached_threads;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="①mutex：互斥锁"><a href="#①mutex：互斥锁" class="headerlink" title="①mutex：互斥锁"></a>①mutex：互斥锁</h4><p>从定义中我们不难读出<strong>mutex变量即为多线程互斥锁</strong>，用以保证线程安全</p>
<blockquote>
<p> ptmalloc中有着对多线程的支持</p>
</blockquote>
<h4 id="②flags：标志位"><a href="#②flags：标志位" class="headerlink" title="②flags：标志位"></a>②flags：标志位</h4><p>接下来是一个整形变量flags，即标志位，用以表示arena的一些状态，如：是否有fastbin、内存是否连续等</p>
<blockquote>
<h5 id="flags标志位相关"><a href="#flags标志位相关" class="headerlink" title="flags标志位相关"></a>flags标志位相关</h5><p>为了节省空间，glibc充分地使用了用每一位(bit)来表示不同状态的思想，与chunk的size的标志位异曲同工</p>
<p>相关代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">FASTCHUNKS_BIT held in max_fast indicates that there are probably</span></span><br><span class="line"><span class="comment">some fastbin chunks. It is set true on entering a chunk into any</span></span><br><span class="line"><span class="comment">fastbin, and cleared only in malloc_consolidate.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The truth value is inverted so that have_fastchunks will be true</span></span><br><span class="line"><span class="comment">upon startup (since statics are zero-filled), simplifying</span></span><br><span class="line"><span class="comment">initialization checks.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FASTCHUNKS_BIT        (1U)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> have_fastchunks(M)     (((M)-&gt;flags &amp; FASTCHUNKS_BIT) == 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clear_fastchunks(M)    catomic_or (&amp;(M)-&gt;flags, FASTCHUNKS_BIT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_fastchunks(M)      catomic_and (&amp;(M)-&gt;flags, ~FASTCHUNKS_BIT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">NONCONTIGUOUS_BIT indicates that MORECORE does not return contiguous</span></span><br><span class="line"><span class="comment">regions.  Otherwise, contiguity is exploited in merging together,</span></span><br><span class="line"><span class="comment">when possible, results from consecutive MORECORE calls.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The initial value comes from MORECORE_CONTIGUOUS, but is</span></span><br><span class="line"><span class="comment">changed dynamically if mmap is ever used as an sbrk substitute.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NONCONTIGUOUS_BIT     (2U)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> contiguous(M)          (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) == 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> noncontiguous(M)       (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) != 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_noncontiguous(M)   ((M)-&gt;flags |= NONCONTIGUOUS_BIT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_contiguous(M)      ((M)-&gt;flags &amp;= ~NONCONTIGUOUS_BIT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ARENA_CORRUPTION_BIT is set if a memory corruption was detected on the</span></span><br><span class="line"><span class="comment">arena.  Such an arena is no longer used to allocate chunks.  Chunks</span></span><br><span class="line"><span class="comment">allocated in that arena before detecting corruption are not freed.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARENA_CORRUPTION_BIT (4U)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arena_is_corrupt(A)	(((A)-&gt;flags &amp; ARENA_CORRUPTION_BIT))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_arena_corrupt(A)	((A)-&gt;flags |= ARENA_CORRUPTION_BIT)</span></span><br></pre></td></tr></table></figure>

<p>仅使用了flags的低三位作为标志位，从低位到高位的含义如下：</p>
<ul>
<li>是否<strong>不存在fastbin chunk</strong></li>
<li>是否<strong>不存在</strong>连续内存（块）</li>
<li>arena是否<strong>被破坏</strong></li>
</ul>
<p>并定义了相关的<strong>获取&amp;改变标志位</strong>的宏</p>
</blockquote>
<h4 id="③fastbinY：存放fastbin-chunk的数组"><a href="#③fastbinY：存放fastbin-chunk的数组" class="headerlink" title="③fastbinY：存放fastbin chunk的数组"></a>③fastbinY：存放fastbin chunk的数组</h4><p>首先是fastbin中所用的mchunkptr类型，定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Forward declarations.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">mchunkptr</span>;</span></span><br></pre></td></tr></table></figure>

<p>即mchunkptr为<strong>指向malloc_chunk</strong>结构体的指针<del>套娃everyday</del>，也就是说fastbinY是一个指针数组，用以存放指向malloc_chunk类型的指针</p>
<p>无论是从注释还是从名字中我们都可以知道<strong>这个数组便是fastbin</strong></p>
<h4 id="④top：指向Top-Chunk的指针"><a href="#④top：指向Top-Chunk的指针" class="headerlink" title="④top：指向Top Chunk的指针"></a>④top：指向Top Chunk的指针</h4><p>Top Chunk是所有chunk中较为特殊的一个chunk，由于系统调用的开销较大，故一般情况下malloc都不会频繁地直接调用brk系统调用开辟堆内存空间，而是会在一开始时先向系统申请一个较大的Top Chunk，后续需要取用内存时便从Top chunk中切割，直到Top chunk不足以分配所需大小的chunk时才会进行系统调用</p>
<p>关于Top Chunk的相关事宜会在后续分析内存分配机制时详细说明</p>
<h4 id="⑤last-remainder：chunk切割中的剩余部分"><a href="#⑤last-remainder：chunk切割中的剩余部分" class="headerlink" title="⑤last_remainder：chunk切割中的剩余部分"></a>⑤last_remainder：chunk切割中的剩余部分</h4><p>malloc在分配chunk时若是没找到size合适的chunk而是找到了一个size更大的chunk，则会<strong>从大chunk中切割掉一块返回给用户，剩下的那一块便是last_remainder，其随后会被放入unsorted bin中</strong>，相关事宜也会在后续分析内存分配机制时详细说明</p>
<h4 id="⑥bins：存放闲置chunk的数组"><a href="#⑥bins：存放闲置chunk的数组" class="headerlink" title="⑥bins：存放闲置chunk的数组"></a>⑥bins：存放闲置chunk的数组</h4><p>这个bins便是我们先前所说的用以存放闲置chunk的指针数组，在这里我们可以看到其一共有NBINS x 2 - 2个元素，即<strong>一共有NBINS - 1个bin，也就是127个bin，而bin0不存在，故应当有126个bin，其中包含1个unsorted bin， 62个small bin， 63个large bin</strong></p>
<h4 id="⑦binmap：用以表示binmap的数组"><a href="#⑦binmap：用以表示binmap的数组" class="headerlink" title="⑦binmap：用以表示binmap的数组"></a>⑦binmap：用以表示binmap的数组</h4><p>binmap用以标记一个bin中是否有chunk以方便检索，需要注意的是chunk被取出后若一个bin空了并不会立即被置0，而会在下一次遍历到时重新置位</p>
<p><strong>※fastbin不使用binmap标志位※</strong></p>
<h4 id="⑧next：指向下一个arena的指针"><a href="#⑧next：指向下一个arena的指针" class="headerlink" title="⑧next：指向下一个arena的指针"></a>⑧next：指向下一个arena的指针</h4><p>一个进程内所有的arena串成了一条循环单向链表，malloc_state中的next指针便是用以指向下一个arena，方便后续的遍历arena的操作（因为不是所有的线程都有自己独立的arena）</p>
<h4 id="⑨next-free：指向下一个空闲的arena的指针"><a href="#⑨next-free：指向下一个空闲的arena的指针" class="headerlink" title="⑨next_free：指向下一个空闲的arena的指针"></a>⑨next_free：指向下一个空闲的arena的指针</h4><p>与next指针类似，只不过指向的是空闲的arena（即没有被任一线程所占用），这里便不再赘叙</p>
<h4 id="⑩attached-threads：与该arena相关联的线程数"><a href="#⑩attached-threads：与该arena相关联的线程数" class="headerlink" title="⑩attached_threads：与该arena相关联的线程数"></a>⑩attached_threads：与该arena相关联的线程数</h4><p>该变量用以表示有多少个线程与该arena相关联，这是因为aerna的数量是有限的，并非每一个线程都有机会分配到一个arena，在线程数量较大的情况下会存在着多个线程共用一个arena的情况</p>
<h4 id="⑪system-mem：记录当前arena在堆区中所分配到的内存的总大小"><a href="#⑪system-mem：记录当前arena在堆区中所分配到的内存的总大小" class="headerlink" title="⑪system_mem：记录当前arena在堆区中所分配到的内存的总大小"></a>⑪system_mem：记录当前arena在堆区中所分配到的内存的总大小</h4><p>该变量用以记录记录当前arena在堆区中所分配到的内存的总大小，<del>似乎只在进行了系统调用brk调整堆区大小时会刷一波存在感</del></p>
<blockquote>
<p>按笔者自己测试64位下这个值似乎是0x21000的整数倍，后面继续分析源码的时候应该会知道为什么</p>
</blockquote>
<h4 id="⑫-max-system-mem：记录当前arena在堆区中所分配到的内存的总大小的最大值"><a href="#⑫-max-system-mem：记录当前arena在堆区中所分配到的内存的总大小的最大值" class="headerlink" title="⑫ max_system_mem：记录当前arena在堆区中所分配到的内存的总大小的最大值"></a>⑫ max_system_mem：记录当前arena在堆区中所分配到的内存的总大小的最大值</h4><p>当操作系统予进程以内存时，system_mem会随之增大，当内存被返还给操作系统时，sysyetm_mem会随之减小，<strong>max_system_mem变量便是用来记录在这个过程当中system_mem的峰值</strong></p>
<h3 id="2-arena相关变量"><a href="#2-arena相关变量" class="headerlink" title="2.arena相关变量"></a>2.arena相关变量</h3><p>在malloc&#x2F;arena.c中定义了arena相关的一些变量，如下：</p>
<h4 id="①thread-arena：每个线程所对应的arena"><a href="#①thread-arena：每个线程所对应的arena" class="headerlink" title="①thread_arena：每个线程所对应的arena"></a>①thread_arena：每个线程所对应的arena</h4><p>首先我们先看thread_arena，这是一个定义于arena.c中的变量，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Thread specific data.  */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __thread mstate thread_arena attribute_tls_model_ie;</span><br></pre></td></tr></table></figure>

<p>不难看出thread_arena是一个静态的每个线程都会有一份的全局变量，类型为mstate，由此我们可以知道的是，<strong>在允许的情况下，ptmalloc会为每个线程单独分配一个arena，而每个线程都会有一个thread_arena指针指向自己所用的arena</strong></p>
<blockquote>
<h4 id="thread：线程变量"><a href="#thread：线程变量" class="headerlink" title="__thread：线程变量"></a>__thread：线程变量</h4><p>GCC关键字之一，也是GCC内置的线程局部存储设施，其存储效率近似于全局变量</p>
<p>对于一个被__thread关键字修饰的一个变量而言，<strong>每个线程都会独立有一个该变量的实例，线程之间该变量实例的值互不干扰</strong></p>
<p>只能用以修饰POD类型变量、全局变量、静态变量</p>
</blockquote>
<blockquote>
<h4 id="attribute-tls-model-ie"><a href="#attribute-tls-model-ie" class="headerlink" title="attribute_tls_model_ie"></a>attribute_tls_model_ie</h4><p>该宏定义于include&#x2F;libc-symbols.h下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> attribute_tls_model_ie __attribute__ ((tls_model (<span class="string">&quot;initial-exec&quot;</span>)))</span></span><br></pre></td></tr></table></figure>

<p>是一个attribute，设置了其tls mode为”initial-exec”；该mode可用于优化定义于动态加载库中的线程局部变量，但需要对于该变量的所有引用操作都位于定义该变量的模块中</p>
<p>详见<a target="_blank" rel="noopener" href="https://www.ibm.com/support/knowledgecenter/en/SSXVZZ_16.1.0/com.ibm.xlcpp161.lelinux.doc/compiler_ref/opt_tls.html">IBM knowledgeCenter - ftls-model</a></p>
<blockquote>
<h5 id="Thread-Local-Storage：线程本地存储（TLS）"><a href="#Thread-Local-Storage：线程本地存储（TLS）" class="headerlink" title="Thread-Local Storage：线程本地存储（TLS）"></a>Thread-Local Storage：线程本地存储（TLS）</h5><p>对于一个进程中的所有线程而言，他们共享着同一个内存空间，因而若存在一全局&#x2F;静态变量，则所有线程都会共享一份变量实例，当一个线程对其进行修改时，则会同时影响到其他的线程，而结果并不一定是我们想要的</p>
<p>因而就有了TLS的概念——线程本地存储：<strong>各个线程独立拥有一个变量实例，相互之间并不影响</strong></p>
</blockquote>
</blockquote>
<blockquote>
<h4 id="attribute"><a href="#attribute" class="headerlink" title="__attribute__"></a>__attribute__</h4><p>GNU C特性，简单来说就是根据函数的不同的功能所决定的返回值而用来优化所生成的代码的，比如说内存分配函数通常会返回一个指向内存块的指针，那么就可以使用__attribute__((malloc))进行优化</p>
<p>详见<a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Common-Function-Attributes.html#Common-Function-Attributes">手册</a></p>
</blockquote>
<h4 id="②narenas：arena数量"><a href="#②narenas：arena数量" class="headerlink" title="②narenas：arena数量"></a>②narenas：arena数量</h4><p>该变量用以记录arena的数量，定义于arena.c中，如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">size_t</span> narenas = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>该静态变量被初始化为1，即默认一开始便有一个arena（main_arena）</p>
<h4 id="③main-arena：初始主线程arena"><a href="#③main-arena：初始主线程arena" class="headerlink" title="③main_arena：初始主线程arena"></a>③main_arena：初始主线程arena</h4><p>main_arena为一个定义于malloc.c中的静态的malloc_state结构体，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* There are several instances of this struct (&quot;arenas&quot;) in this</span></span><br><span class="line"><span class="comment">   malloc.  If you are adapting this malloc in a way that does NOT use</span></span><br><span class="line"><span class="comment">   a static or mmapped malloc_state, you MUST explicitly zero-fill it</span></span><br><span class="line"><span class="comment">   before using. This malloc relies on the property that malloc_state</span></span><br><span class="line"><span class="comment">   is initialized to all zeroes (as is true of C statics).  */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> <span class="title">main_arena</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  .mutex = _LIBC_LOCK_INITIALIZER,</span><br><span class="line">  .next = &amp;main_arena,</span><br><span class="line">  .attached_threads = <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由于其为libc中的静态变量，<strong>该arena会被随着libc文件一同加载到Memory Mapping Segment</strong></p>
<h4 id="④free-list：空闲arena链表（头结点）"><a href="#④free-list：空闲arena链表（头结点）" class="headerlink" title="④free_list：空闲arena链表（头结点）"></a>④free_list：空闲arena链表（头结点）</h4><p>free_list同样是一个mstate变量，用以保存空闲arena链表的头节点指针，定义于arena.c中，相关代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Arena free list.  free_list_lock synchronizes access to the</span></span><br><span class="line"><span class="comment">   free_list variable below, and the next_free and attached_threads</span></span><br><span class="line"><span class="comment">   members of struct malloc_state objects.  No other locks must be</span></span><br><span class="line"><span class="comment">   acquired after free_list_lock has been acquired.  */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">mutex_t</span> free_list_lock = _LIBC_LOCK_INITIALIZER;</span><br><span class="line"><span class="type">static</span> mstate free_list;</span><br></pre></td></tr></table></figure>

<p>我们可以看到为了应对多线程操作，free_list同样有着一个对应的互斥锁</p>
<h4 id="⑤-arena-mem：非主线程的arena所占用的内存空间总大小"><a href="#⑤-arena-mem：非主线程的arena所占用的内存空间总大小" class="headerlink" title="⑤ arena_mem：非主线程的arena所占用的内存空间总大小"></a>⑤ arena_mem：非主线程的arena所占用的内存空间总大小</h4><p>定义于arena.c中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Mapped memory in non-main arenas (reliable only for NO_THREADS). */</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> arena_mem;</span><br></pre></td></tr></table></figure>

<p>该变量用以记录非main_arena所分配到的空间的<strong>总大小</strong></p>
<h3 id="3-arena相关函数与宏"><a href="#3-arena相关函数与宏" class="headerlink" title="3.arena相关函数与宏"></a>3.arena相关函数与宏</h3><h4 id="①malloc-init-state-：初始化arena内成员"><a href="#①malloc-init-state-：初始化arena内成员" class="headerlink" title="①malloc_init_state()：初始化arena内成员"></a>①malloc_init_state()：初始化arena内成员</h4><p>该函数位于malloc.c中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Initialize a malloc_state struct.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   This is called only from within malloc_consolidate, which needs</span></span><br><span class="line"><span class="comment">   be called in the same contexts anyway.  It is never called directly</span></span><br><span class="line"><span class="comment">   outside of malloc_consolidate because some optimizing compilers try</span></span><br><span class="line"><span class="comment">   to inline it at all call points, which turns out not to be an</span></span><br><span class="line"><span class="comment">   optimization at all. (Inlining it in malloc_consolidate is fine though.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">malloc_init_state</span> <span class="params">(mstate av)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  mbinptr bin;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Establish circular links for normal bins */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; NBINS; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      bin = bin_at (av, i);</span><br><span class="line">      bin-&gt;fd = bin-&gt;bk = bin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> MORECORE_CONTIGUOUS</span></span><br><span class="line">  <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  set_noncontiguous (av);</span><br><span class="line">  <span class="keyword">if</span> (av == &amp;main_arena)</span><br><span class="line">    set_max_fast (DEFAULT_MXFAST);</span><br><span class="line">  av-&gt;flags |= FASTCHUNKS_BIT;</span><br><span class="line"></span><br><span class="line">  av-&gt;top = initial_top (av);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大概做了以下几件事：</p>
<ul>
<li><strong>将arena中所有bin</strong>（fastbin除外）<strong>的fd与bk都指向bin自身</strong></li>
<li>（使用sbrk进行增长的堆区域在内存中为连续区域的情况下若该arena非main_arena则）<strong>设置该arena的标志位中的noncontiguous</strong>，笔者推测这是由于非主线程arena的内存区域位于由mmap映射的MMS段，一般来说并非连续内存，故设置该标志位，而所管理的内存位于heap区的main_arena则可以通过系统调用sbrk在heap区进行增长，故不设置该标志位（MORECORE_CONTIGUOUS被设为1，即意为sbrk系统调用的堆区内存增长连续（MORECORE为sbrk的封装））</li>
<li>若该arena为main_arena则设置set_max_fast为默认值，该值32位下为0x40，64位下为0x80</li>
<li>设置标志位FASTCHUNKS_BIT，<strong>即一个arena在默认情况下并不拥有fastbin chunk</strong></li>
<li>将该areva的top chunk指针指向unsorted bin，<strong>用以表示初始时top chunk大小为0</strong></li>
</ul>
<h4 id="②-int-new-arena-：创建一个新的arena"><a href="#②-int-new-arena-：创建一个新的arena" class="headerlink" title="②_int_new_arena()：创建一个新的arena"></a>②_int_new_arena()：创建一个新的arena</h4><p>该函数定义于arena.c中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> mstate</span><br><span class="line">_int_new_arena (<span class="type">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">  mstate a;</span><br><span class="line">  heap_info *h;</span><br><span class="line">  <span class="type">char</span> *ptr;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> misalign;</span><br><span class="line"></span><br><span class="line">  h = new_heap (size + (<span class="keyword">sizeof</span> (*h) + <span class="keyword">sizeof</span> (*a) + MALLOC_ALIGNMENT),</span><br><span class="line">                mp_.top_pad);</span><br><span class="line">  <span class="keyword">if</span> (!h)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe size is too large to fit in a single heap.  So, just try</span></span><br><span class="line"><span class="comment">         to create a minimally-sized arena and let _int_malloc() attempt</span></span><br><span class="line"><span class="comment">         to deal with the large request via mmap_chunk().  */</span></span><br><span class="line">      h = new_heap (<span class="keyword">sizeof</span> (*h) + <span class="keyword">sizeof</span> (*a) + MALLOC_ALIGNMENT, mp_.top_pad);</span><br><span class="line">      <span class="keyword">if</span> (!h)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  a = h-&gt;ar_ptr = (mstate) (h + <span class="number">1</span>);</span><br><span class="line">  malloc_init_state (a);</span><br><span class="line">  a-&gt;attached_threads = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">/*a-&gt;next = NULL;*/</span></span><br><span class="line">  a-&gt;system_mem = a-&gt;max_system_mem = h-&gt;size;</span><br><span class="line">  arena_mem += h-&gt;size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set up the top chunk, with proper alignment. */</span></span><br><span class="line">  ptr = (<span class="type">char</span> *) (a + <span class="number">1</span>);</span><br><span class="line">  misalign = (<span class="type">unsigned</span> <span class="type">long</span>) chunk2mem (ptr) &amp; MALLOC_ALIGN_MASK;</span><br><span class="line">  <span class="keyword">if</span> (misalign &gt; <span class="number">0</span>)</span><br><span class="line">    ptr += MALLOC_ALIGNMENT - misalign;</span><br><span class="line">  top (a) = (mchunkptr) ptr;</span><br><span class="line">  set_head (top (a), (((<span class="type">char</span> *) h + h-&gt;size) - ptr) | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">  LIBC_PROBE (memory_arena_new, <span class="number">2</span>, a, size);</span><br><span class="line">  mstate replaced_arena = thread_arena;</span><br><span class="line">  thread_arena = a;</span><br><span class="line">  mutex_init (&amp;a-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  (<span class="type">void</span>) mutex_lock (&amp;list_lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Add the new arena to the global list.  */</span></span><br><span class="line">  a-&gt;next = main_arena.next;</span><br><span class="line">  <span class="comment">/* <span class="doctag">FIXME:</span> The barrier is an attempt to synchronize with read access</span></span><br><span class="line"><span class="comment">     in reused_arena, which does not acquire list_lock while</span></span><br><span class="line"><span class="comment">     traversing the list.  */</span></span><br><span class="line">  atomic_write_barrier ();</span><br><span class="line">  main_arena.next = a;</span><br><span class="line"></span><br><span class="line">  (<span class="type">void</span>) mutex_unlock (&amp;list_lock);</span><br><span class="line"></span><br><span class="line">  (<span class="type">void</span>) mutex_lock (&amp;free_list_lock);</span><br><span class="line">  detach_arena (replaced_arena);</span><br><span class="line">  (<span class="type">void</span>) mutex_unlock (&amp;free_list_lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Lock this arena.  NB: Another thread may have been attached to</span></span><br><span class="line"><span class="comment">     this arena because the arena is now accessible from the</span></span><br><span class="line"><span class="comment">     main_arena.next list and could have been picked by reused_arena.</span></span><br><span class="line"><span class="comment">     This can only happen for the last arena created (before the arena</span></span><br><span class="line"><span class="comment">     limit is reached).  At this point, some arena has to be attached</span></span><br><span class="line"><span class="comment">     to two threads.  We could acquire the arena lock before list_lock</span></span><br><span class="line"><span class="comment">     to make it less likely that reused_arena picks this new arena,</span></span><br><span class="line"><span class="comment">     but this could result in a deadlock with ptmalloc_lock_all.  */</span></span><br><span class="line"></span><br><span class="line">  (<span class="type">void</span>) mutex_lock (&amp;a-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数首先会尝试从Memory Mapping Segment区域分配一个大小为<code>size + heap_info + malloc_state + MALLOC_ALIGNMENT + __mp.top_pad</code>的内存块，若失败则<strong>重新尝试分配一个大小仅为<code>heap_info + malloc_state + MALLOC_ALIGNMENT + __mp.top_pad</code>的内存块</strong>，若仍失败则返回NULL，需要注意的是在new_heap()函数中<strong>该值会被自动转换为一个对分页大小对齐的size</strong>，<strong>若该值小于HEAP_MIN_SIZE</strong>（32*1024）<strong>则会被自动转换为HEAP_MIN_SIZE</strong>，详细会在后续new_heap()函数解析中说明</p>
<p>接下来该函数会将获得的内存块从<strong>heap header往后的一块大小为malloc_state的区域当作是一个新的arena来继续操作</strong></p>
<p>也就是说此时该内存块的布局应当如下：</p>
<p><img src="https://i.loli.net/2021/01/14/bevLqTFRpxkjCcW.png" alt="image.png"></p>
<p>随后会调用<code>malloc_init_state()</code>函数初始化该arena，并设置其关联线程数为1，设置分配到的内存大小为heap header中的size，并使arena_mem加上该size</p>
<p>最后，<strong>剩余的内存会被视作该arena的top chunk，并设置PREV_INUSE标志位</strong></p>
<p>此时这一块内存的布局如下：</p>
<p><img src="https://i.loli.net/2021/01/14/GM8qCiErXgFDYsy.png" alt="image.png"></p>
<p>需要注意的是若是内存地址未对MALLOC_ALIGNMENT对齐则会适当调整top chunk的位置</p>
<p><img src="https://i.loli.net/2021/01/14/sjQrLvNORFXhDbC.png" alt="image.png"></p>
<p>接下来会<strong>将该线程的arena设为该arena，并将该arena插入到arena链表中的main_arena之后</strong></p>
<p>最后解锁线程原arena，锁上新的arena，并将新的arena返回</p>
<blockquote>
<h5 id="LIBC-PROBE：「LIBC探针」"><a href="#LIBC-PROBE：「LIBC探针」" class="headerlink" title="LIBC_PROBE：「LIBC探针」"></a>LIBC_PROBE：「LIBC探针」</h5><p>LIBC_PROBE为系统探针的上层封装，该宏定义于include&#x2F;stap-probe.h中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_STAP_PROBE</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;sys/sdt.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Our code uses one macro LIBC_PROBE (name, n, arg1, ..., argn).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Without USE_STAP_PROBE, that does nothing but evaluates all</span></span><br><span class="line"><span class="comment">its arguments (to prevent bit rot, unlike e.g. assert).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Systemtap&#x27;s header defines the macros STAP_PROBE (provider, name) and</span></span><br><span class="line"><span class="comment">STAP_PROBEn (provider, name, arg1, ..., argn).  For &quot;provider&quot; we paste</span></span><br><span class="line"><span class="comment">in MODULE_NAME (libc, libpthread, etc.) automagically.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The format of the arg parameters is discussed here:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">https://sourceware.org/systemtap/wiki/UserSpaceProbeImplementation</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The precise details of how register names are specified is</span></span><br><span class="line"><span class="comment">architecture specific and can be found in the gdb and SystemTap</span></span><br><span class="line"><span class="comment">source code.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> LIBC_PROBE(name, n, ...)	\</span></span><br><span class="line"><span class="meta">LIBC_PROBE_1 (MODULE_NAME, name, n, ## __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> LIBC_PROBE_1(lib, name, n, ...) \</span></span><br><span class="line"><span class="meta">STAP_PROBE##n (lib, name, ## __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> STAP_PROBE0		STAP_PROBE</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> LIBC_PROBE_ASM(name, template) \</span></span><br><span class="line"><span class="meta">STAP_PROBE_ASM (MODULE_NAME, name, template)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> LIBC_PROBE_ASM_OPERANDS STAP_PROBE_ASM_OPERANDS</span></span><br><span class="line">...<span class="comment">//不使用PROBE的宏就不贴出来了，其逻辑仅为定义该宏为空</span></span><br></pre></td></tr></table></figure>

<p>依旧是套娃宏，STAP_PROBE##n宏定义在sys&#x2F;sdt.h下，需要注意的是<strong>这个文件似乎不属于glibc</strong></p>
<p><del>谷歌了一下，</del>在终端使用如下指令安装systemtap-sdt-dev</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install systemtap-sdt-dev</span><br></pre></td></tr></table></figure>

<p>然后就能获得sdt.h了</p>
<p>在sdt.h中定义了13个STAP_PROBE宏，如下：<del>令人看着头大的写法</del></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STAP_PROBE(provider, name) \</span></span><br><span class="line"><span class="meta">_SDT_PROBE(provider, name, 0, ())</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STAP_PROBE1(provider, name, arg1) \</span></span><br><span class="line"><span class="meta">_SDT_PROBE(provider, name, 1, (arg1))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STAP_PROBE2(provider, name, arg1, arg2) \</span></span><br><span class="line"><span class="meta">_SDT_PROBE(provider, name, 2, (arg1, arg2))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STAP_PROBE3(provider, name, arg1, arg2, arg3) \</span></span><br><span class="line"><span class="meta">_SDT_PROBE(provider, name, 3, (arg1, arg2, arg3))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STAP_PROBE4(provider, name, arg1, arg2, arg3, arg4) \</span></span><br><span class="line"><span class="meta">_SDT_PROBE(provider, name, 4, (arg1, arg2, arg3, arg4))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STAP_PROBE5(provider, name, arg1, arg2, arg3, arg4, arg5) \</span></span><br><span class="line"><span class="meta">_SDT_PROBE(provider, name, 5, (arg1, arg2, arg3, arg4, arg5))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STAP_PROBE6(provider, name, arg1, arg2, arg3, arg4, arg5, arg6)	\</span></span><br><span class="line"><span class="meta">_SDT_PROBE(provider, name, 6, (arg1, arg2, arg3, arg4, arg5, arg6))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STAP_PROBE7(provider, name, arg1, arg2, arg3, arg4, arg5, arg6, arg7) \</span></span><br><span class="line"><span class="meta">_SDT_PROBE(provider, name, 7, (arg1, arg2, arg3, arg4, arg5, arg6, arg7))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STAP_PROBE8(provider,name,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8) \</span></span><br><span class="line"><span class="meta">_SDT_PROBE(provider, name, 8, (arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STAP_PROBE9(provider,name,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9)\</span></span><br><span class="line"><span class="meta">_SDT_PROBE(provider, name, 9, (arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STAP_PROBE10(provider,name,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10) \</span></span><br><span class="line"><span class="meta">_SDT_PROBE(provider, name, 10, \</span></span><br><span class="line"><span class="meta">	     (arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STAP_PROBE11(provider,name,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11) \</span></span><br><span class="line"><span class="meta">_SDT_PROBE(provider, name, 11, \</span></span><br><span class="line"><span class="meta">	     (arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STAP_PROBE12(provider,name,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12) \</span></span><br><span class="line"><span class="meta">_SDT_PROBE(provider, name, 12, \</span></span><br><span class="line"><span class="meta">	     (arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12))</span></span><br></pre></td></tr></table></figure>

<p>依然是套娃定义，跟进</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __ASSEMBLER__</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _SDT_PROBE(provider, name, n, arglist)	\</span></span><br><span class="line"><span class="meta">_SDT_ASM_BODY(provider, name, _SDT_ASM_STRING_1, (_SDT_DEPAREN_##n arglist)) \</span></span><br><span class="line"><span class="meta">_SDT_ASM_BASE</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _SDT_ASM_1(x)			x;</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _SDT_ASM_2(a, b)		a,b;</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _SDT_ASM_3(a, b, c)		a,b,c;</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _SDT_ASM_5(a, b, c, d, e)	a,b,c,d,e;</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">...<span class="comment">//前面在stap-probe.h中若是没有def __ASSEMBLER__ 的话STAP_PROBE就是空了，所以后面的就不贴了</span></span><br></pre></td></tr></table></figure>

<p>依旧套娃，再度跟进</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _SDT_ASM_BODY(provider, name, pack_args, args)			      \</span></span><br><span class="line"><span class="meta">_SDT_ASM_1(990:	_SDT_NOP)					      \</span></span><br><span class="line"><span class="meta">_SDT_ASM_3(		.pushsection .note.stapsdt,_SDT_ASM_AUTOGROUP,<span class="string">&quot;note&quot;</span>) \</span></span><br><span class="line"><span class="meta">_SDT_ASM_1(		.balign 4)					      \</span></span><br><span class="line"><span class="meta">_SDT_ASM_3(		.4byte 992f-991f, 994f-993f, _SDT_NOTE_TYPE)	      \</span></span><br><span class="line"><span class="meta">_SDT_ASM_1(991:	.asciz _SDT_NOTE_NAME)				      \</span></span><br><span class="line"><span class="meta">_SDT_ASM_1(992:	.balign 4)					      \</span></span><br><span class="line"><span class="meta">_SDT_ASM_1(993:	_SDT_ASM_ADDR 990b)				      \</span></span><br><span class="line"><span class="meta">_SDT_ASM_1(		_SDT_ASM_ADDR _.stapsdt.base)			      \</span></span><br><span class="line"><span class="meta">_SDT_SEMAPHORE(provider,name)						      \</span></span><br><span class="line"><span class="meta">_SDT_ASM_STRING(provider)						      \</span></span><br><span class="line"><span class="meta">_SDT_ASM_STRING(name)							      \</span></span><br><span class="line"><span class="meta">pack_args args							      \</span></span><br><span class="line"><span class="meta">_SDT_ASM_1(994:	.balign 4)					      \</span></span><br><span class="line"><span class="meta">_SDT_ASM_1(		.popsection)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _SDT_ASM_BASE							      \</span></span><br><span class="line"><span class="meta">_SDT_ASM_1(.<span class="keyword">ifndef</span> _.stapsdt.base)					      \</span></span><br><span class="line"><span class="meta">_SDT_ASM_5(		.pushsection .stapsdt.base,<span class="string">&quot;aG&quot;</span>,<span class="string">&quot;progbits&quot;</span>,	      \</span></span><br><span class="line"><span class="meta">							.stapsdt.base,comdat) \</span></span><br><span class="line"><span class="meta">_SDT_ASM_1(		.weak _.stapsdt.base)				      \</span></span><br><span class="line"><span class="meta">_SDT_ASM_1(		.hidden _.stapsdt.base)				      \</span></span><br><span class="line"><span class="meta">_SDT_ASM_1(	_.stapsdt.base: .space 1)				      \</span></span><br><span class="line"><span class="meta">_SDT_ASM_2(		.size _.stapsdt.base, 1)			      \</span></span><br><span class="line"><span class="meta">_SDT_ASM_1(		.popsection)					      \</span></span><br><span class="line"><span class="meta">_SDT_ASM_1(.<span class="keyword">endif</span>)</span></span><br></pre></td></tr></table></figure>

<p><del>这你🦄的又套回去了啊</del></p>
<p>这↑里↓便是系统探针的实现原理了，由于不是本篇重点故具体代码就先不分析了（<del>其实是不会</del></p>
</blockquote>
<blockquote>
<h5 id="System-Tap：「内核探测工具」"><a href="#System-Tap：「内核探测工具」" class="headerlink" title="System Tap：「内核探测工具」"></a>System Tap：「内核探测工具」</h5><blockquote>
<p>In computing, SystemTap (stap) is a scripting language and tool for dynamically instrumenting running production Linux kernel-based operating systems. System administrators can use SystemTap to extract, filter and summarize data in order to enable diagnosis of complex performance or functional problems.</p>
<p>SystemTap consists of free and open-source software and includes contributions from Red Hat, IBM, Intel, Hitachi, Oracle, the University of Wisconsin-Madison and other community members</p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/SystemTap">WikiPedia: System Tap</a></p>
</blockquote>
<p>大意是说SystemTap是一个用以<strong>对基于Linux内核的操作系统进行动态插桩</strong>的脚本语言工具，系统管理员可以用它来提取、过滤、汇总数据以进行复杂性能或功能问题的诊断</p>
<blockquote>
<p>In order to aid in debugging and monitoring internal behavior, the GNU C Library exposes nearly-zero-overhead SystemTap probes marked with the libc provider.</p>
<p><a target="_blank" rel="noopener" href="http://ld2015.scusa.lsu.edu/gnu_c_libs/Internal-Probes.html#Internal-Probes">The GNU C Library : Internal Probe</a></p>
</blockquote>
<p>为了<strong>帮助调试和监视内部行为</strong>，GNU C库公开了用libc提供程序标记的<strong>开销几乎为零的</strong>系统探针。 </p>
<p>在get_free_list()函数中用到的探针为memory_arena_reuse_free_list，说明如下：</p>
<blockquote>
<p>Probe: <strong>memory_arena_reuse_free_list</strong> <em>(void *$arg1)</em></p>
<p>This probe is triggered when <code>malloc</code> has chosen an arena that is in the free list for use by a thread, within the <code>get_free_list</code> function. The argument $arg1 holds a pointer to the selected arena.</p>
<p><a target="_blank" rel="noopener" href="http://ld2015.scusa.lsu.edu/gnu_c_libs/Memory-Allocation-Probes.html#Memory-Allocation-Probes">The GNU C Library: Memory Allocation Probes</a></p>
</blockquote>
<p>总之，调试linux内核的时候便可以在这些地方使用相应的系统探针</p>
</blockquote>
<h4 id="③get-free-list-：尝试从free-list中获取一个空闲arena"><a href="#③get-free-list-：尝试从free-list中获取一个空闲arena" class="headerlink" title="③get_free_list()：尝试从free_list中获取一个空闲arena"></a>③get_free_list()：尝试从free_list中获取一个空闲arena</h4><p>该函数同样定义于arena.c中，用以从free_list中获取一个空闲的arena，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Remove an arena from free_list.  The arena may be in use because it</span></span><br><span class="line"><span class="comment">   was attached concurrently to a thread by reused_arena below.  */</span></span><br><span class="line"><span class="type">static</span> mstate</span><br><span class="line"><span class="title function_">get_free_list</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  mstate replaced_arena = thread_arena;</span><br><span class="line">  mstate result = free_list;</span><br><span class="line">  <span class="keyword">if</span> (result != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      (<span class="type">void</span>) mutex_lock (&amp;free_list_lock);</span><br><span class="line">      result = free_list;</span><br><span class="line">      <span class="keyword">if</span> (result != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  free_list = result-&gt;next_free;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* The arena will be attached to this thread.  */</span></span><br><span class="line">	  ++result-&gt;attached_threads;</span><br><span class="line"></span><br><span class="line">	  detach_arena (replaced_arena);</span><br><span class="line">	&#125;</span><br><span class="line">      (<span class="type">void</span>) mutex_unlock (&amp;free_list_lock);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (result != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          LIBC_PROBE (memory_arena_reuse_free_list, <span class="number">1</span>, result);</span><br><span class="line">          (<span class="type">void</span>) mutex_lock (&amp;result-&gt;mutex);</span><br><span class="line">	  thread_arena = result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>get_free_list()函数首先会检查free_list是否为空，<strong>若为空则直接返回NULL</strong>，不为空的情况下则会进行如下操作：</p>
<ul>
<li><strong>首先尝试锁上free_list_lock后再次检查free_list是否为空，若还是不为空才会取出头结点，并调用detach_arena()函数将当前线程原先使用的arena的关联线程数减一</strong>，这里的二次检查是为了防止多线程间的冲突（举个例子，可能有个线程在其之前先取出了free_list中的空闲arena，而当前线程必须要等待其解锁互斥锁free_list_lock后才能继续接下来的操作，若是仍使用前面所获取的arena那就乱套了）；</li>
<li>调用mutex_unlock()函数<strong>解锁free_list互斥锁，随后再次检查此前获得的arena是否为NULL</strong></li>
<li>若获得的<strong>arena不为NULL则锁上其互斥锁，将当前线程的thread_arena设为该arena</strong></li>
<li>将最终的result返回给上层函数</li>
</ul>
<h4 id="④arena-get-：获得一个arena"><a href="#④arena-get-：获得一个arena" class="headerlink" title="④arena_get()：获得一个arena"></a>④arena_get()：获得一个arena</h4><p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* arena_get() acquires an arena and locks the corresponding mutex.</span></span><br><span class="line"><span class="comment">   First, try the one last locked successfully by this thread.  (This</span></span><br><span class="line"><span class="comment">   is the common case and handled with a macro for speed.)  Then, loop</span></span><br><span class="line"><span class="comment">   once over the circularly linked list of arenas.  If no arena is</span></span><br><span class="line"><span class="comment">   readily available, create a new one.  In this latter case, `size&#x27;</span></span><br><span class="line"><span class="comment">   is just a hint as to how much memory will be required immediately</span></span><br><span class="line"><span class="comment">   in the new arena. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arena_get(ptr, size) do &#123; \</span></span><br><span class="line"><span class="meta">      ptr = thread_arena;						      \</span></span><br><span class="line"><span class="meta">      arena_lock (ptr, size);						      \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>arena_get()宏将会获取一个空间充足的arena并锁上对应的互斥锁：</p>
<ul>
<li><strong>将thread_arena给到ptr，并调用arena_lock()宏进行检查无误后尝试锁上互斥锁</strong></li>
<li><strong>若检查发现thread_arena为NULL</strong>（<strong>该线程第一次调用malloc</strong>）<strong>或该arena被破坏，则会尝试遍历arena链表寻找可用的arena</strong></li>
<li><strong>若无法找寻到可用的arena则会创建一个新的arena</strong></li>
</ul>
<p>接下来我们来看其内部实现的核心宏arena_lock()与核心函数arena_get2()</p>
<blockquote>
<h5 id="do-…-while-0-：约定俗成书写形式"><a href="#do-…-while-0-：约定俗成书写形式" class="headerlink" title="do{…}while(0)：约定俗成书写形式"></a>do{…}while(0)：约定俗成书写形式</h5><p>或许不少人在第一眼看到这个写法时都会觉得这么写是在脱裤子放屁（x）（包括笔者），但其实这种写法有其存在的意义所在</p>
<p>设想假如我们定义了这样一个宏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DO_SOMETHING_USELESS() foo1();foo2();</span></span><br></pre></td></tr></table></figure>

<p>而假设在这样一段代码中我们使用了这个宏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (somthing)</span><br><span class="line">	DO_SOMETHING_USELESS();</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;fxck you!\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>那么会被展开成如下形式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (somthing)</span><br><span class="line">	foo1();foo2();;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;fxck you!\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>毫无疑问下方的else便无法匹配到上方的if</p>
<p>可能有人想问了，若是加个括号呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DO_SOMETHING_USELESS() &#123; foo1();foo2(); &#125;</span></span><br></pre></td></tr></table></figure>

<p>则展开后是如下形式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (somthing)</span><br><span class="line">	&#123; foo1();foo2(); &#125;;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;fxck you!\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>由于多了一个分号，下方的else还是无法匹配到上方的if</p>
<p>因此考虑使用do{…}while(0)的写法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DO_SOMETHING_USELESS() do&#123; foo1();foo2(); &#125;while(0)</span></span><br></pre></td></tr></table></figure>

<p>则展开后是如下形式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (somthing)</span><br><span class="line">	<span class="keyword">do</span>&#123; foo1();foo2(); &#125;<span class="keyword">while</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;fxck you!\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>下方的else便能成功匹配到上方的if</p>
<p>可能有人要杠了：wsm不直接加括号、然后在调用该宏时不写分号？这是因为对于普通的C语言语句而言其末尾语法要求是要加分号的，因此古早时期宏的写法也便<strong>约定俗成</strong>要在语句末尾写上分号，因而便出现了do{}while(0)的写法，以便统一宏与一般语句的书写格式</p>
</blockquote>
<h4 id="⑤arena-lock-：将arena上锁"><a href="#⑤arena-lock-：将arena上锁" class="headerlink" title="⑤arena_lock()：将arena上锁"></a>⑤arena_lock()：将arena上锁</h4><p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> arena_lock(ptr, size) do &#123;					      \</span></span><br><span class="line"><span class="meta">      <span class="keyword">if</span> (ptr &amp;&amp; !arena_is_corrupt (ptr))				      \</span></span><br><span class="line"><span class="meta">        (void) mutex_lock (&amp;ptr-&gt;mutex);				      \</span></span><br><span class="line"><span class="meta">      <span class="keyword">else</span>								      \</span></span><br><span class="line"><span class="meta">        ptr = arena_get2 ((size), NULL);				      \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br></pre></td></tr></table></figure>

<p>首先检查ptr是否为空，并调用arena_is_corrupt宏检查arena是否被破坏</p>
<ul>
<li>若是检查通过，则调用mutex_lock()函数将arena中的互斥锁上锁（多线程相关函数便不在这里赘叙了）</li>
<li>若是检查不通过，则调用arena_get2()函数获得一个新的arena</li>
</ul>
<h4 id="⑥arena-get2-：遍历free-list，若无合适则尝试获取一个新的arena或使用已有arena"><a href="#⑥arena-get2-：遍历free-list，若无合适则尝试获取一个新的arena或使用已有arena" class="headerlink" title="⑥arena_get2()：遍历free_list，若无合适则尝试获取一个新的arena或使用已有arena"></a>⑥arena_get2()：遍历free_list，若无合适则尝试获取一个新的arena或使用已有arena</h4><p>arena_get2()函数同样定义于arena.c中，如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> mstate</span><br><span class="line">internal_function</span><br><span class="line"><span class="title function_">arena_get2</span> <span class="params">(<span class="type">size_t</span> size, mstate avoid_arena)</span></span><br><span class="line">&#123;</span><br><span class="line">  mstate a;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> <span class="type">size_t</span> narenas_limit;</span><br><span class="line"></span><br><span class="line">  a = get_free_list ();</span><br><span class="line">  <span class="keyword">if</span> (a == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Nothing immediately available, so generate a new arena.  */</span></span><br><span class="line">      <span class="keyword">if</span> (narenas_limit == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (mp_.arena_max != <span class="number">0</span>)</span><br><span class="line">            narenas_limit = mp_.arena_max;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (narenas &gt; mp_.arena_test)</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="type">int</span> n = __get_nprocs ();</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (n &gt;= <span class="number">1</span>)</span><br><span class="line">                narenas_limit = NARENAS_FROM_NCORES (n);</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                <span class="comment">/* We have no information about the system.  Assume two</span></span><br><span class="line"><span class="comment">                   cores.  */</span></span><br><span class="line">                narenas_limit = NARENAS_FROM_NCORES (<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    repeat:;</span><br><span class="line">      <span class="type">size_t</span> n = narenas;</span><br><span class="line">      <span class="comment">/* NB: the following depends on the fact that (size_t)0 - 1 is a</span></span><br><span class="line"><span class="comment">         very large number and that the underflow is OK.  If arena_max</span></span><br><span class="line"><span class="comment">         is set the value of arena_test is irrelevant.  If arena_test</span></span><br><span class="line"><span class="comment">         is set but narenas is not yet larger or equal to arena_test</span></span><br><span class="line"><span class="comment">         narenas_limit is 0.  There is no possibility for narenas to</span></span><br><span class="line"><span class="comment">         be too big for the test to always fail since there is not</span></span><br><span class="line"><span class="comment">         enough address space to create that many arenas.  */</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (n &lt;= narenas_limit - <span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (catomic_compare_and_exchange_bool_acq (&amp;narenas, n + <span class="number">1</span>, n))</span><br><span class="line">            <span class="keyword">goto</span> repeat;</span><br><span class="line">          a = _int_new_arena (size);</span><br><span class="line">	  <span class="keyword">if</span> (__glibc_unlikely (a == <span class="literal">NULL</span>))</span><br><span class="line">            catomic_decrement (&amp;narenas);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        a = reused_arena (avoid_arena);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先会调用get_free_list()函数尝试从free_list中获取一个arena，<strong>若成功则直接返回</strong></p>
<p>若无法从free_list中获取获取到arena（free_lIst为空），首先会检查<code>narenas_limit</code>变量是否为0，<strong>该变量用以记录一个进程中的arena数量限制</strong>，由于该变量为静态变量，故初始值默认应当为0</p>
<p>初始值为0的情况下便会先检查ptmalloc参数中的arena_max是否为0，由于mp_也是一个静态变量，故arena_max初始值也应当为0</p>
<p>若arena_max不为0（没有设定arena_max），则直接将其值赋予narenas_limit</p>
<p>否则，将narenas与ptmalloc参数中的arena_test进行比较，<strong>若是arena数量已经超出了test值</strong>，则<strong>重新初始化arena数量上限</strong>：调用<code>__get_nprocs()</code>函数<strong>获取CPU的核心数以设定arena的数量上限，32位下为核心数乘2，64位下为核心数乘8，若是无法获取到核心数，则直接按照核心数为2进行计算</strong>，当线程数大于核心数的2倍时，便必然有线程处于等待状态，因此在这里便根据核心数计算arena上限数（至于64位下为什么是乘8，笔者也暂且蒙在古里<del>指在蒙古待会</del>）</p>
<p>随后<strong>检查arena数量是否达到上限</strong>（narenas &#x3D;&#x3D; narena_limit），<strong>若否</strong>，则接下来会调用宏<code>catomic_compare_and_exchange_bool_acq</code><strong>将narenas的值加1</strong>，随后调用<code>_int_new_arena()</code>函数<strong>创建一个新的arena</strong>，若成功则返回，<strong>否则重新将narenas的值减1</strong></p>
<p>若<strong>arena数量已经达到上限</strong>，则会调用<code>reused_arena()</code>函数尝试从现有arena中寻找可用的arena上锁后返回，需要注意的是该函数遍历arena时会过滤掉传入的avoid_arena</p>
<blockquote>
<h5 id="glibc-likely-expr-amp-amp-glibc-unlikely-expr-：分支预测优化（封装宏）"><a href="#glibc-likely-expr-amp-amp-glibc-unlikely-expr-：分支预测优化（封装宏）" class="headerlink" title="__glibc_likely(expr) &amp;&amp; __glibc_unlikely(expr)：分支预测优化（封装宏）"></a>__glibc_likely(expr) &amp;&amp; __glibc_unlikely(expr)：分支预测优化（封装宏）</h5><p>对__builtin_expect宏的封装，定义于misc&#x2F;sys&#x2F;cdefs.h中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> __GNUC__ &gt;= 3</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __glibc_unlikely(cond)	__builtin_expect ((cond), 0)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __glibc_likely(cond)	__builtin_expect ((cond), 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __glibc_unlikely(cond)	(cond)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __glibc_likely(cond)	(cond)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>只有宏__GNUC__的值大于3时才会启用该宏，其核心是宏__bulltin_expect(expr, var)</p>
</blockquote>
<blockquote>
<h5 id="internal-function"><a href="#internal-function" class="headerlink" title="internal_function"></a>internal_function</h5><p>定义于malloc.c中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* On some platforms we can compile internal, not exported functions better.</span></span><br><span class="line"><span class="comment">Let the environment provide a macro and define it to be empty if it</span></span><br><span class="line"><span class="comment">is not available.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> internal_function</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> internal_function</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>大意是说这是为了一些特殊用途而预留的一个宏，该宏默认定义为空</p>
</blockquote>
<blockquote>
<h5 id="catomic-compare-and-exchange-bool-acq"><a href="#catomic-compare-and-exchange-bool-acq" class="headerlink" title="catomic_compare_and_exchange_bool_acq"></a>catomic_compare_and_exchange_bool_acq</h5><p>该宏定义于include&#x2F;atomic.h中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> catomic_compare_and_exchange_bool_acq</span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> __arch_c_compare_and_exchange_bool_32_acq</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> catomic_compare_and_exchange_bool_acq(mem, newval, oldval) \</span></span><br><span class="line"><span class="meta">__atomic_bool_bysize (__arch_c_compare_and_exchange_bool,acq,		      \</span></span><br><span class="line"><span class="meta">		        mem, newval, oldval)</span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> catomic_compare_and_exchange_bool_acq(mem, newval, oldval) \</span></span><br><span class="line"><span class="meta">(&#123; <span class="comment">/* Cannot use __oldval here, because macros later in this file might     \</span></span></span><br><span class="line"><span class="comment"><span class="meta">	call this macro with __oldval argument.	 */</span>			      \</span></span><br><span class="line"><span class="meta">__typeof (oldval) __atg4_old = (oldval);				      \</span></span><br><span class="line"><span class="meta">catomic_compare_and_exchange_val_acq (mem, newval, __atg4_old)	      \</span></span><br><span class="line"><span class="meta">!= __atg4_old;							      \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>在glibc源码中笔者并没有找到关于<code>__arch_c_compare_and_exchange_bool_32_acq</code>宏的定义，故默认应当是使用else这一块的内容</p>
<p>首先会将oldval的值拷贝一份，随后再调用宏<code>catomic_compare_and_exchange_val_acq</code>（<del>套娃来套娃去</del></p>
<p>该宏同样位于include&#x2F;atomic.h中，如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> catomic_compare_and_exchange_val_acq</span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> __arch_c_compare_and_exchange_val_32_acq</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> catomic_compare_and_exchange_val_acq(mem, newval, oldval) \</span></span><br><span class="line"><span class="meta">__atomic_val_bysize (__arch_c_compare_and_exchange_val,acq,		      \</span></span><br><span class="line"><span class="meta">		       mem, newval, oldval)</span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> catomic_compare_and_exchange_val_acq(mem, newval, oldval) \</span></span><br><span class="line"><span class="meta">atomic_compare_and_exchange_val_acq (mem, newval, oldval)</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><del>又套了一层娃</del></p>
<p>继续跟进</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Atomically store NEWVAL in *MEM if *MEM is equal to OLDVAL.</span></span><br><span class="line"><span class="comment">Return the old *MEM value.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined atomic_compare_and_exchange_val_acq \</span></span><br><span class="line"><span class="meta"> &amp;&amp; defined __arch_compare_and_exchange_val_32_acq</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> atomic_compare_and_exchange_val_acq(mem, newval, oldval) \</span></span><br><span class="line"><span class="meta">__atomic_val_bysize (__arch_compare_and_exchange_val,acq,		      \</span></span><br><span class="line"><span class="meta">		       mem, newval, oldval)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>宏<code>__arch_compare_and_exchange_val_32_acq</code>已经在sysdeps&#x2F;（多个文件夹中皆有）&#x2F;atomic-machine.h中定义了，我们直接跟进<code>__atomic_val_bysize</code>的定义即可</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Wrapper macros to call pre_NN_post (mem, ...) where NN is the</span></span><br><span class="line"><span class="comment">bit width of *MEM.  The calling macro puts parens around MEM</span></span><br><span class="line"><span class="comment">and following args.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __atomic_val_bysize(pre, post, mem, ...)			      \</span></span><br><span class="line"><span class="meta">(&#123;									      \</span></span><br><span class="line"><span class="meta"> __typeof (*mem) __atg1_result;					      \</span></span><br><span class="line"><span class="meta"> <span class="keyword">if</span> (sizeof (*mem) == 1)						      \</span></span><br><span class="line"><span class="meta">   __atg1_result = pre##_8_##post (mem, __VA_ARGS__);		      \</span></span><br><span class="line"><span class="meta"> <span class="keyword">else</span> <span class="keyword">if</span> (sizeof (*mem) == 2)					      \</span></span><br><span class="line"><span class="meta">   __atg1_result = pre##_16_##post (mem, __VA_ARGS__);		      \</span></span><br><span class="line"><span class="meta"> <span class="keyword">else</span> <span class="keyword">if</span> (sizeof (*mem) == 4)					      \</span></span><br><span class="line"><span class="meta">   __atg1_result = pre##_32_##post (mem, __VA_ARGS__);		      \</span></span><br><span class="line"><span class="meta"> <span class="keyword">else</span> <span class="keyword">if</span> (sizeof (*mem) == 8)					      \</span></span><br><span class="line"><span class="meta">   __atg1_result = pre##_64_##post (mem, __VA_ARGS__);		      \</span></span><br><span class="line"><span class="meta"> <span class="keyword">else</span>								      \</span></span><br><span class="line"><span class="meta">   abort ();								      \</span></span><br><span class="line"><span class="meta"> __atg1_result;							      \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br></pre></td></tr></table></figure>

<p>在这里则又会根据<code>*mem</code>的大小调用相应的宏，定义于sysdeps&#x2F;ia64&#x2F;atomic-machine.h中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __arch_compare_and_exchange_val_8_acq(mem, newval, oldval) \</span></span><br><span class="line"><span class="meta">(abort (), (__typeof (*mem)) 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __arch_compare_and_exchange_val_16_acq(mem, newval, oldval) \</span></span><br><span class="line"><span class="meta">(abort (), (__typeof (*mem)) 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __arch_compare_and_exchange_val_32_acq(mem, newval, oldval) \</span></span><br><span class="line"><span class="meta">__sync_val_compare_and_swap ((mem), (int) (long) (oldval), \</span></span><br><span class="line"><span class="meta">			       (int) (long) (newval))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __arch_compare_and_exchange_val_64_acq(mem, newval, oldval) \</span></span><br><span class="line"><span class="meta">__sync_val_compare_and_swap ((mem), (long) (oldval), (long) (newval))</span></span><br></pre></td></tr></table></figure>

<p>对于1字节与2字节长的指针，进程会直接调用abort()终止（笔者也不明白wsm这么设计），而对于4字节长与8字节长的指针，则会调用<strong>GCC内置的原子操作</strong><code>__sync_val_compare_and_swap</code></p>
<p>查看<a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc-4.1.1/gcc/Atomic-Builtins.html">GCC手册</a>中说明如下：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool __sync_bool_compare_and_swap (`type` *ptr, `type` oldval `type` newval, ...)</span><br></pre></td></tr></table></figure>

<p>type<code> __sync_val_compare_and_swap (</code>type<code>*ptr,</code>type<code>oldval</code>type<code> newval, ...)</code></p>
<p>ptrisoldval  ptr</p>
<p>The “bool” version returns true if the comparison is successful and newval was written. The “val” version returns the contents of <code>*</code>ptr before the operation. </p>
</blockquote>
<p>那么一切就真相大白了</p>
<p><del>套娃</del><code>catomic_compare_and_exchange_bool_acq</code>宏需要传入三个参数：<code>mem</code>、<code>newval</code>、<code>oldval</code>，其中mem应当要为一个指针类型，随后比较<code>oldval</code>与<code>*mem</code>的值是否相等，若是则将<code>*mem</code>赋值为<code>newval</code>并返回0，若否则返回非零值</p>
</blockquote>
<blockquote>
<h5 id="catomic-decrement"><a href="#catomic-decrement" class="headerlink" title="catomic_decrement"></a>catomic_decrement</h5><p>定义于include&#x2F;atomic.h中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> catomic_decrement</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> catomic_decrement(mem) catomic_add ((mem), -1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>套娃，跟进</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> catomic_add</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> catomic_add(mem, value) \</span></span><br><span class="line"><span class="meta">(void) catomic_exchange_and_add ((mem), (value))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>还是套娃，再跟进</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> catomic_exchange_and_add</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> catomic_exchange_and_add(mem, value) \</span></span><br><span class="line"><span class="meta">(&#123; __typeof (*(mem)) __atg7_oldv;					      \</span></span><br><span class="line"><span class="meta">  __typeof (mem) __atg7_memp = (mem);				      \</span></span><br><span class="line"><span class="meta">  __typeof (*(mem)) __atg7_value = (value);				      \</span></span><br><span class="line"><span class="meta">									      \</span></span><br><span class="line"><span class="meta">  do									      \</span></span><br><span class="line"><span class="meta">    __atg7_oldv = *__atg7_memp;					      \</span></span><br><span class="line"><span class="meta">  while (__builtin_expect						      \</span></span><br><span class="line"><span class="meta">	    (catomic_compare_and_exchange_bool_acq (__atg7_memp,	      \</span></span><br><span class="line"><span class="meta">						    __atg7_oldv		      \</span></span><br><span class="line"><span class="meta">						    + __atg7_value,	      \</span></span><br><span class="line"><span class="meta">						    __atg7_oldv), 0));	      \</span></span><br><span class="line"><span class="meta">									      \</span></span><br><span class="line"><span class="meta">  __atg7_oldv; &#125;)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>最终我们可以知道该宏的用处是将一个变量的值减一，同样由于考虑到多线程操作的情况，在这里使用的是原子操作</p>
</blockquote>
<h4 id="⑦reused-arena-：寻找可用arena上锁后返回"><a href="#⑦reused-arena-：寻找可用arena上锁后返回" class="headerlink" title="⑦reused_arena()：寻找可用arena上锁后返回"></a>⑦reused_arena()：寻找可用arena上锁后返回</h4><p>同样定义于arena.h中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Lock and return an arena that can be reused for memory allocation.</span></span><br><span class="line"><span class="comment">   Avoid AVOID_ARENA as we have already failed to allocate memory in</span></span><br><span class="line"><span class="comment">   it and it is currently locked.  */</span></span><br><span class="line"><span class="type">static</span> mstate</span><br><span class="line"><span class="title function_">reused_arena</span> <span class="params">(mstate avoid_arena)</span></span><br><span class="line">&#123;</span><br><span class="line">  mstate result;</span><br><span class="line">  <span class="comment">/* <span class="doctag">FIXME:</span> Access to next_to_use suffers from data races.  */</span></span><br><span class="line">  <span class="type">static</span> mstate next_to_use;</span><br><span class="line">  <span class="keyword">if</span> (next_to_use == <span class="literal">NULL</span>)</span><br><span class="line">    next_to_use = &amp;main_arena;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Iterate over all arenas (including those linked from</span></span><br><span class="line"><span class="comment">     free_list).  */</span></span><br><span class="line">  result = next_to_use;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (!arena_is_corrupt (result) &amp;&amp; !mutex_trylock (&amp;result-&gt;mutex))</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* <span class="doctag">FIXME:</span> This is a data race, see _int_new_arena.  */</span></span><br><span class="line">      result = result-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">while</span> (result != next_to_use);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Avoid AVOID_ARENA as we have already failed to allocate memory</span></span><br><span class="line"><span class="comment">     in that arena and it is currently locked.   */</span></span><br><span class="line">  <span class="keyword">if</span> (result == avoid_arena)</span><br><span class="line">    result = result-&gt;next;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Make sure that the arena we get is not corrupted.  */</span></span><br><span class="line">  mstate begin = result;</span><br><span class="line">  <span class="keyword">while</span> (arena_is_corrupt (result) || result == avoid_arena)</span><br><span class="line">    &#123;</span><br><span class="line">      result = result-&gt;next;</span><br><span class="line">      <span class="keyword">if</span> (result == begin)</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We could not find any arena that was either not corrupted or not the one</span></span><br><span class="line"><span class="comment">     we wanted to avoid.  */</span></span><br><span class="line">  <span class="keyword">if</span> (result == begin || result == avoid_arena)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* No arena available without contention.  Wait for the next in line.  */</span></span><br><span class="line">  LIBC_PROBE (memory_arena_reuse_wait, <span class="number">3</span>, &amp;result-&gt;mutex, result, avoid_arena);</span><br><span class="line">  (<span class="type">void</span>) mutex_lock (&amp;result-&gt;mutex);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">  <span class="comment">/* Attach the arena to the current thread.  Note that we may have</span></span><br><span class="line"><span class="comment">     selected an arena which was on free_list.  */</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Update the arena thread attachment counters.   */</span></span><br><span class="line">    mstate replaced_arena = thread_arena;</span><br><span class="line">    (<span class="type">void</span>) mutex_lock (&amp;free_list_lock);</span><br><span class="line">    detach_arena (replaced_arena);</span><br><span class="line">    ++result-&gt;attached_threads;</span><br><span class="line">    (<span class="type">void</span>) mutex_unlock (&amp;free_list_lock);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  LIBC_PROBE (memory_arena_reuse, <span class="number">2</span>, result, avoid_arena);</span><br><span class="line">  thread_arena = result;</span><br><span class="line">  next_to_use = result-&gt;next;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>操作步骤如下：</p>
<ul>
<li><p>首先检查next_to_use，若为NULL则设为main_arena</p>
</li>
<li><p>接下来从next_to_use开始遍历arena链表，若找到一个<strong>未被破坏且能成功上锁的arena</strong>（即该未被破坏的arena未被上锁）则跳转到下一步，否则会二次遍历arena链表，寻找<strong>未被破坏的且非avoid_arena</strong>的arena并上锁，若仍旧失败则返回NULL</p>
</li>
<li><p>接下来将<strong>原arena关联线程数减一，新arena关联线程数加一</strong>，并将next_to_use设为该arena的next指针指向的arena，为了防止多线程冲突，这一步操作会先锁上free_list，操作结束后再行解锁</p>
</li>
<li><p>最后<strong>将该线程arena设为获取到的arena并返回</strong></p>
</li>
</ul>
<h4 id="⑧detach-arena-：将arena关联线程数减一"><a href="#⑧detach-arena-：将arena关联线程数减一" class="headerlink" title="⑧detach_arena()：将arena关联线程数减一"></a>⑧detach_arena()：将arena关联线程数减一</h4><p>同样定义于arena.c中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* If REPLACED_ARENA is not NULL, detach it from this thread.  Must be</span></span><br><span class="line"><span class="comment">   called while free_list_lock is held.  */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">detach_arena</span> <span class="params">(mstate replaced_arena)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (replaced_arena != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      assert (replaced_arena-&gt;attached_threads &gt; <span class="number">0</span>);</span><br><span class="line">      <span class="comment">/* The current implementation only detaches from main_arena in</span></span><br><span class="line"><span class="comment">	 case of allocation failure.  This means that it is likely not</span></span><br><span class="line"><span class="comment">	 beneficial to put the arena on free_list even if the</span></span><br><span class="line"><span class="comment">	 reference count reaches zero.  */</span></span><br><span class="line">      --replaced_arena-&gt;attached_threads;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数首先会检查其参数replace_arena是否不为NULL，只有不为NULL时才会进一步操作</p>
<p>随后<strong>使用assert检查replace_arena的attached_threads成员是否大于0</strong></p>
<p>只有在一切正常的情况下，才会将该arena的关联线程数减一</p>
<h4 id="⑨arena-for-chunk-：获取一个堆块对应的arena"><a href="#⑨arena-for-chunk-：获取一个堆块对应的arena" class="headerlink" title="⑨arena_for_chunk()：获取一个堆块对应的arena"></a>⑨arena_for_chunk()：获取一个堆块对应的arena</h4><p>该宏定义于arena.c中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> arena_for_chunk(ptr) \</span></span><br><span class="line"><span class="meta">  (chunk_non_main_arena (ptr) ? heap_for_ptr (ptr)-&gt;ar_ptr : &amp;main_arena)</span></span><br></pre></td></tr></table></figure>

<p>首先会检查该chunk的<code>NON_MAIN_ARENA</code>标志位，若为false则直接返回main_arena，否则会先获取该chunk所属的heap后再通过heap header（heap_info）获取到其所属的arena</p>

      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
              <a href="/2020/11/23/CTF-0X01-ByteCTF2020-pwn/" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>上一页</span>
              </a>
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">
              <i class="iconfont icon-updatetime" title="更新时间"></i>
              2021-01-15 19:17:03
            </span>
            
                  <span class="post-categories">
                    <i class="iconfont icon-bookmark" title="分类"></i>
                    
                    <span class="span--category">
                      <a href="/categories/NOTES/" title="NOTES">
                        <b>#</b> NOTES
                      </a>
                    </span>
                    
                  </span>
              
                  <span class="post-tags">
                    <i class="iconfont icon-tags" title="标签"></i>
                    
                    <span class="span--tag">
                      <a href="/tags/%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0/" title="学习札记">
                        <b>#</b> 学习札记
                      </a>
                    </span>
                    
                    <span class="span--tag">
                      <a href="/tags/ptmalloc/" title="ptmalloc">
                        <b>#</b> ptmalloc
                      </a>
                    </span>
                    
                    <span class="span--tag">
                      <a href="/tags/glibc/" title="glibc">
                        <b>#</b> glibc
                      </a>
                    </span>
                    
                    <span class="span--tag">
                      <a href="/tags/%E5%A0%86-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" title="堆 - 内存管理">
                        <b>#</b> 堆 - 内存管理
                      </a>
                    </span>
                    
                  </span>
              
          </div>
          <div class="post-foot-prev">
            
              <a href="/2021/01/20/CTF-0X02-STARCTF2021-PWN/" target="_self">
                <span>下一页</span>
                <i class="iconfont icon-chevronright"></i>
              </a>
            
          </div>
        </div>
      
    </div>
    
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">目录</div>
    <div class="catalog-content">
      
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0x00-%E5%A0%86%E5%86%85%E5%AD%98%E7%9A%84%E7%BB%84%E7%BB%87%E5%BD%A2%E5%BC%8F"><span class="toc-text">0x00.堆内存的组织形式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81malloc-chunk"><span class="toc-text">一、malloc_chunk</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#The-alignof-operator"><span class="toc-text">The __alignof__ operator</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81chunk%E7%9B%B8%E5%85%B3%E5%AE%8F"><span class="toc-text">二、chunk相关宏</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-chunk-size%E7%9B%B8%E5%85%B3%E5%AE%8F"><span class="toc-text">1.chunk size相关宏</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8F%EF%BC%9Aoffsetof"><span class="toc-text">宏：offsetof</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-memory-request%E7%9B%B8%E5%85%B3%E5%AE%8F"><span class="toc-text">2.memory request相关宏</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8Echunk%E9%97%B4%E7%9A%84%E5%86%85%E5%AD%98%E5%A4%8D%E7%94%A8%E5%8F%8Arequest2size%E8%AE%A1%E7%AE%97%E7%9B%B8%E5%85%B3%E4%BA%8B%E9%A1%B9"><span class="toc-text">关于chunk间的内存复用及request2size计算相关事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-chunk%E6%A0%87%E5%BF%97%E4%BD%8D%E7%9B%B8%E5%85%B3%E5%AE%8F"><span class="toc-text">3.chunk标志位相关宏</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E6%A0%87%E5%BF%97%E4%BD%8D%E5%AE%9A%E4%B9%89%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%AE%8F"><span class="toc-text">①标志位定义及相关宏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E6%A0%87%E5%BF%97%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%9B%B8%E5%85%B3%E5%AE%8F%E5%8F%8A%E5%85%B6%E4%BB%96%E5%AE%8F"><span class="toc-text">②标志位操作相关宏及其他宏</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Bins%EF%BC%9A%E5%AD%98%E6%94%BE%E9%97%B2%E7%BD%AEchunk%E7%9A%84%E6%95%B0%E7%BB%84"><span class="toc-text">三、Bins：存放闲置chunk的数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-bins%E9%80%9A%E7%94%A8%E5%AE%8F"><span class="toc-text">1.bins通用宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-bins%E7%9B%B8%E5%85%B3%E5%AE%9A%E4%B9%89%E5%AE%8F"><span class="toc-text">2.bins相关定义宏</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0unsorted-bin%E7%9B%B8%E5%85%B3%E5%AE%8F"><span class="toc-text">①unsorted bin相关宏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1small-bins%E7%9B%B8%E5%85%B3%E5%AE%8F"><span class="toc-text">②small bins相关宏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2large-bins%E7%9B%B8%E5%85%B3%E5%AE%8F"><span class="toc-text">③large bins相关宏</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-unlink%EF%BC%9A%E4%BB%8Ebins%E4%B8%AD%E5%8F%96%E5%87%BAchunk"><span class="toc-text">3.unlink：从bins中取出chunk</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#builtin-expect-expr-var-%EF%BC%9A%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B%E4%BC%98%E5%8C%96"><span class="toc-text">__builtin_expect(expr, var)：分支预测优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#malloc-printerr"><span class="toc-text">malloc_printerr()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-binmap%EF%BC%9A%E7%94%A8%E6%9D%A5%E6%A0%87%E8%AF%86bin%E7%8A%B6%E6%80%81%EF%BC%88%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA%EF%BC%89%E7%9A%84%E6%95%B0%E7%BB%84"><span class="toc-text">4.binmap：用来标识bin状态（是否为空）的数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Fastbins%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%AD%98%E5%8F%96chunk%E7%9A%84%E6%95%B0%E7%BB%84"><span class="toc-text">四、Fastbins：快速存取chunk的数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fastbin%E7%9B%B8%E5%85%B3%E5%AE%8F"><span class="toc-text">fastbin相关宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fastbin-size%E8%AF%A6%E8%A7%A3"><span class="toc-text">fastbin size详解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81malloc-par%EF%BC%9A%E5%A0%86%E7%AE%A1%E7%90%86%E5%99%A8%E5%8F%82%E6%95%B0"><span class="toc-text">五、malloc_par：堆管理器参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mp-%EF%BC%9A%E8%AE%B0%E5%BD%95ptmalloc%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0%E7%9A%84malloc-par%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">mp_：记录ptmalloc相关参数的malloc_par结构体</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81heap-info%EF%BC%9AHeap-Header-for-heap-allocated-by-mmap"><span class="toc-text">六、heap_info：Heap Header(for heap allocated by mmap)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#heap-info%E7%9B%B8%E5%85%B3%E5%AE%8F"><span class="toc-text">heap_info相关宏</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81arena%EF%BC%9A%E7%BA%BF%E7%A8%8B%E5%86%85%E5%AD%98%E6%B1%A0"><span class="toc-text">七、arena：线程内存池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-malloc-state%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">1.malloc_state结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0mutex%EF%BC%9A%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-text">①mutex：互斥锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1flags%EF%BC%9A%E6%A0%87%E5%BF%97%E4%BD%8D"><span class="toc-text">②flags：标志位</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#flags%E6%A0%87%E5%BF%97%E4%BD%8D%E7%9B%B8%E5%85%B3"><span class="toc-text">flags标志位相关</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2fastbinY%EF%BC%9A%E5%AD%98%E6%94%BEfastbin-chunk%E7%9A%84%E6%95%B0%E7%BB%84"><span class="toc-text">③fastbinY：存放fastbin chunk的数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3top%EF%BC%9A%E6%8C%87%E5%90%91Top-Chunk%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-text">④top：指向Top Chunk的指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A4last-remainder%EF%BC%9Achunk%E5%88%87%E5%89%B2%E4%B8%AD%E7%9A%84%E5%89%A9%E4%BD%99%E9%83%A8%E5%88%86"><span class="toc-text">⑤last_remainder：chunk切割中的剩余部分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A5bins%EF%BC%9A%E5%AD%98%E6%94%BE%E9%97%B2%E7%BD%AEchunk%E7%9A%84%E6%95%B0%E7%BB%84"><span class="toc-text">⑥bins：存放闲置chunk的数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A6binmap%EF%BC%9A%E7%94%A8%E4%BB%A5%E8%A1%A8%E7%A4%BAbinmap%E7%9A%84%E6%95%B0%E7%BB%84"><span class="toc-text">⑦binmap：用以表示binmap的数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A7next%EF%BC%9A%E6%8C%87%E5%90%91%E4%B8%8B%E4%B8%80%E4%B8%AAarena%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-text">⑧next：指向下一个arena的指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A8next-free%EF%BC%9A%E6%8C%87%E5%90%91%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%A9%BA%E9%97%B2%E7%9A%84arena%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-text">⑨next_free：指向下一个空闲的arena的指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A9attached-threads%EF%BC%9A%E4%B8%8E%E8%AF%A5arena%E7%9B%B8%E5%85%B3%E8%81%94%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%95%B0"><span class="toc-text">⑩attached_threads：与该arena相关联的线程数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%AAsystem-mem%EF%BC%9A%E8%AE%B0%E5%BD%95%E5%BD%93%E5%89%8Darena%E5%9C%A8%E5%A0%86%E5%8C%BA%E4%B8%AD%E6%89%80%E5%88%86%E9%85%8D%E5%88%B0%E7%9A%84%E5%86%85%E5%AD%98%E7%9A%84%E6%80%BB%E5%A4%A7%E5%B0%8F"><span class="toc-text">⑪system_mem：记录当前arena在堆区中所分配到的内存的总大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%AB-max-system-mem%EF%BC%9A%E8%AE%B0%E5%BD%95%E5%BD%93%E5%89%8Darena%E5%9C%A8%E5%A0%86%E5%8C%BA%E4%B8%AD%E6%89%80%E5%88%86%E9%85%8D%E5%88%B0%E7%9A%84%E5%86%85%E5%AD%98%E7%9A%84%E6%80%BB%E5%A4%A7%E5%B0%8F%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-text">⑫ max_system_mem：记录当前arena在堆区中所分配到的内存的总大小的最大值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-arena%E7%9B%B8%E5%85%B3%E5%8F%98%E9%87%8F"><span class="toc-text">2.arena相关变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0thread-arena%EF%BC%9A%E6%AF%8F%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%89%80%E5%AF%B9%E5%BA%94%E7%9A%84arena"><span class="toc-text">①thread_arena：每个线程所对应的arena</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#thread%EF%BC%9A%E7%BA%BF%E7%A8%8B%E5%8F%98%E9%87%8F"><span class="toc-text">__thread：线程变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#attribute-tls-model-ie"><span class="toc-text">attribute_tls_model_ie</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Thread-Local-Storage%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%EF%BC%88TLS%EF%BC%89"><span class="toc-text">Thread-Local Storage：线程本地存储（TLS）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#attribute"><span class="toc-text">__attribute__</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1narenas%EF%BC%9Aarena%E6%95%B0%E9%87%8F"><span class="toc-text">②narenas：arena数量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2main-arena%EF%BC%9A%E5%88%9D%E5%A7%8B%E4%B8%BB%E7%BA%BF%E7%A8%8Barena"><span class="toc-text">③main_arena：初始主线程arena</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3free-list%EF%BC%9A%E7%A9%BA%E9%97%B2arena%E9%93%BE%E8%A1%A8%EF%BC%88%E5%A4%B4%E7%BB%93%E7%82%B9%EF%BC%89"><span class="toc-text">④free_list：空闲arena链表（头结点）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A4-arena-mem%EF%BC%9A%E9%9D%9E%E4%B8%BB%E7%BA%BF%E7%A8%8B%E7%9A%84arena%E6%89%80%E5%8D%A0%E7%94%A8%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E6%80%BB%E5%A4%A7%E5%B0%8F"><span class="toc-text">⑤ arena_mem：非主线程的arena所占用的内存空间总大小</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-arena%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E4%B8%8E%E5%AE%8F"><span class="toc-text">3.arena相关函数与宏</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0malloc-init-state-%EF%BC%9A%E5%88%9D%E5%A7%8B%E5%8C%96arena%E5%86%85%E6%88%90%E5%91%98"><span class="toc-text">①malloc_init_state()：初始化arena内成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1-int-new-arena-%EF%BC%9A%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84arena"><span class="toc-text">②_int_new_arena()：创建一个新的arena</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#LIBC-PROBE%EF%BC%9A%E3%80%8CLIBC%E6%8E%A2%E9%92%88%E3%80%8D"><span class="toc-text">LIBC_PROBE：「LIBC探针」</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#System-Tap%EF%BC%9A%E3%80%8C%E5%86%85%E6%A0%B8%E6%8E%A2%E6%B5%8B%E5%B7%A5%E5%85%B7%E3%80%8D"><span class="toc-text">System Tap：「内核探测工具」</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2get-free-list-%EF%BC%9A%E5%B0%9D%E8%AF%95%E4%BB%8Efree-list%E4%B8%AD%E8%8E%B7%E5%8F%96%E4%B8%80%E4%B8%AA%E7%A9%BA%E9%97%B2arena"><span class="toc-text">③get_free_list()：尝试从free_list中获取一个空闲arena</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3arena-get-%EF%BC%9A%E8%8E%B7%E5%BE%97%E4%B8%80%E4%B8%AAarena"><span class="toc-text">④arena_get()：获得一个arena</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#do-%E2%80%A6-while-0-%EF%BC%9A%E7%BA%A6%E5%AE%9A%E4%BF%97%E6%88%90%E4%B9%A6%E5%86%99%E5%BD%A2%E5%BC%8F"><span class="toc-text">do{…}while(0)：约定俗成书写形式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A4arena-lock-%EF%BC%9A%E5%B0%86arena%E4%B8%8A%E9%94%81"><span class="toc-text">⑤arena_lock()：将arena上锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A5arena-get2-%EF%BC%9A%E9%81%8D%E5%8E%86free-list%EF%BC%8C%E8%8B%A5%E6%97%A0%E5%90%88%E9%80%82%E5%88%99%E5%B0%9D%E8%AF%95%E8%8E%B7%E5%8F%96%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84arena%E6%88%96%E4%BD%BF%E7%94%A8%E5%B7%B2%E6%9C%89arena"><span class="toc-text">⑥arena_get2()：遍历free_list，若无合适则尝试获取一个新的arena或使用已有arena</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#glibc-likely-expr-amp-amp-glibc-unlikely-expr-%EF%BC%9A%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B%E4%BC%98%E5%8C%96%EF%BC%88%E5%B0%81%E8%A3%85%E5%AE%8F%EF%BC%89"><span class="toc-text">__glibc_likely(expr) &amp;&amp; __glibc_unlikely(expr)：分支预测优化（封装宏）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#internal-function"><span class="toc-text">internal_function</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#catomic-compare-and-exchange-bool-acq"><span class="toc-text">catomic_compare_and_exchange_bool_acq</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#catomic-decrement"><span class="toc-text">catomic_decrement</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A6reused-arena-%EF%BC%9A%E5%AF%BB%E6%89%BE%E5%8F%AF%E7%94%A8arena%E4%B8%8A%E9%94%81%E5%90%8E%E8%BF%94%E5%9B%9E"><span class="toc-text">⑦reused_arena()：寻找可用arena上锁后返回</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A7detach-arena-%EF%BC%9A%E5%B0%86arena%E5%85%B3%E8%81%94%E7%BA%BF%E7%A8%8B%E6%95%B0%E5%87%8F%E4%B8%80"><span class="toc-text">⑧detach_arena()：将arena关联线程数减一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A8arena-for-chunk-%EF%BC%9A%E8%8E%B7%E5%8F%96%E4%B8%80%E4%B8%AA%E5%A0%86%E5%9D%97%E5%AF%B9%E5%BA%94%E7%9A%84arena"><span class="toc-text">⑨arena_for_chunk()：获取一个堆块对应的arena</span></a></li></ol></li></ol></li></ol></li></ol>
      
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
      <div class="comments-container">
        




  
    <script async type="text/javascript" src="/plugins/valine.min.js" onload="loadValineSuc(this)"></script>
  

  <div id="vcomments"></div>

  <script>
    function loadValineSuc() {
      new Valine({
        el: '#vcomments',
        appId: 'ICj6cPRQWFTNiOttBHlzxnIv-gzGzoHsz',
        appKey: 'tuvJh3xYxPFcW2JB6K26RKP2',
        placeholder: '说点什么呗...',
        avatar: 'retro',
        lang: 'zh-CN'
      })
    }
  </script>

    <style>
      .comments-container .v .vempty {
        display: none!important;
      }
    </style>




      </div>
    
  </div>


        
<div class="footer">
  <div class="social">
    <ul>
      
        <li>
          <a title="github" target="_blank" rel="noopener" href="https://github.com/arttnba3">
            <i class="iconfont icon-github"></i>
          </a>
        </li>
      
        <li>
          <a title="email" href="mailto:arttnba@gmail.com">
            <i class="iconfont icon-envelope"></i>
          </a>
        </li>
      
        <li>
          <a title="twitter" target="_blank" rel="noopener" href="https://twitter.com/arttnba3">
            <i class="iconfont icon-twitter"></i>
          </a>
        </li>
      
        <li>
          <a title="rss" href="/atom.xml">
            <i class="iconfont icon-rss"></i>
          </a>
        </li>
      
    </ul>
  </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/arttnba3">Copyright © 2022 arttnba3</a>
        
    </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Theme by Oranges | Powered by Hexo</a>
        
    </div>
  
</div>

      </div>

      <div class="tools-bar">
        <div class="back-to-top tools-bar-item hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



        
  <div class="search-icon tools-bar-item" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-title">
        <span class="search-icon-input">
          <a href="javascript: void(0)">
            <i class="iconfont icon-search"></i>
          </a>
        </span>
        
          <input type="text" class="search-input" id="search-input" placeholder="搜索...">
        
        <span class="search-close-icon" id="search-close-icon">
          <a href="javascript: void(0)">
            <i class="iconfont icon-close"></i>
          </a>
        </span>
      </div>
      <div class="search-result" id="search-result"></div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    inputArea.onclick = function() {
      getSearchFile()
      this.onclick = null
    }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        // inputArea.focus()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'>首次搜索，正在载入索引文件，请稍后……<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + orig_data_title + "</a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<p class=\"search-result-abstract\">" + match_content + "...</p>"
                }
                str += "</li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>没有找到内容，请尝试更换检索词。<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>未找到search.xml文件，具体请参考：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>请求失败，尝试重新刷新页面或稍后重试。<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




        
  <div class="tools-bar-item theme-icon" id="switch-color-scheme">
    <a href="javascript: void(0)">
      <i id="theme-icon" class="iconfont icon-moon"></i>
    </a>
  </div>

  
<script src="/js/colorscheme.js"></script>





        
  
    <div class="share-icon tools-bar-item">
      <a href="javascript: void(0)" id="share-icon">
        <i class="iconfont iconshare"></i>
      </a>
      <div class="share-content hidden">
        
          <a class="share-item" href="https://twitter.com/intent/tweet?text=' + %E3%80%90NOTES.0x00%E3%80%91glibc2.23malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20-%20I%EF%BC%9A%E5%A0%86%E5%86%85%E5%AD%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E7%BB%87%E5%BD%A2%E5%BC%8F + '&url=' + http%3A%2F%2Fblog.arttnba3.cn%2F2021%2F01%2F15%2FNOTE-0X00-MALLOC-2.23-PART-I%2F + '" target="_blank" title="Twitter">
            <i class="iconfont icon-twitter"></i>
          </a>
        
        
          <a class="share-item" href="https://www.facebook.com/sharer.php?u=http://blog.arttnba3.cn/2021/01/15/NOTE-0X00-MALLOC-2.23-PART-I/" target="_blank" title="Facebook">
            <i class="iconfont icon-facebooksquare"></i>
          </a>
        
      </div>
    </div>
  
  
<script src="/js/shares.js"></script>



      </div>
    </div>
  </body>
</html>
