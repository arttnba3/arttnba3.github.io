<!DOCTYPE html>
<html lang="zh-CN" color-mode="light">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="keywords" content="" />
  <meta name="author" content="arttnba3" />
  <meta name="description" content="あがいた夢を捨てて揺れる今日は眠って誤魔化せ" />
  
  
  <title>
    
      【GLIBC.0x01】glibc2.23 malloc源码分析 - II：malloc 
      
      
      |
    
     arttnba3&#39;s blog
  </title>

  
    <link rel="apple-touch-icon" href="/img/favicon.png">
    <link rel="icon" href="/img/favicon.png">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  
<link rel="stylesheet" href="/css/color-scheme.css">
<link rel="stylesheet" href="/css/base.css">
<link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css">
<link rel="stylesheet" href="/css/github-markdown.css">
<link rel="stylesheet" href="/css/highlight.css">
<link rel="stylesheet" href="/css/comments.css">

  <!-- 代码块风格 -->
  

  <!-- jquery3.3.1 -->
  
    <script defer type="text/javascript" src="/plugins/jquery.min.js"></script>
  

  <!-- fancybox -->
  
    <link href="/plugins/jquery.fancybox.min.css" rel="stylesheet">
    <script defer type="text/javascript" src="/plugins/jquery.fancybox.min.js"></script>
  
  
<script src="/js/fancybox.js"></script>


  

  <script>
    var html = document.documentElement
    const colorMode = localStorage.getItem('color-mode')
    if (colorMode) {
      document.documentElement.setAttribute('color-mode', colorMode)
    }
  </script>
<meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="arttnba3's blog" type="application/atom+xml">
</head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a target="_blank" rel="noopener" href="https://arttnba3.cn">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img src="/img/avatar.png" alt="">
      
    </a>
    <div class="nickname"><a target="_blank" rel="noopener" href="https://arttnba3.cn">arttnba3's blog</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">Home</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">Archives</a>
        </li>
      
        <li class="nav-item" data-path="/categories/">
          <a href="/categories/">Categories</a>
        </li>
      
        <li class="nav-item" data-path="/tags/">
          <a href="/tags/">Tags</a>
        </li>
      
        <li class="nav-item" data-path="/friends/">
          <a href="/friends/">Friends</a>
        </li>
      
        <li class="nav-item" data-path="/about/">
          <a href="/about/">About</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->


  <!-- LaTex Display -->

  
    <script async type="text/javascript" src="/plugins/mathjax/tex-chtml.js"></script>
  
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    }
  </script>





  <!-- clipboard -->

  
    <script async type="text/javascript" src="/plugins/clipboard.min.js"></script>
  
  
<script src="/js/codeCopy.js"></script>







  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">【GLIBC.0x01】glibc2.23 malloc源码分析 - II：malloc</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime" title="更新时间"></i>
          2021-01-15 20:17:03
        </span>
        
              <span class="post-categories">
                <i class="iconfont icon-bookmark" title="分类"></i>
                
                <span class="span--category">
                  <a href="/categories/GLIBC/" title="GLIBC">
                    <b>#</b> GLIBC
                  </a>
                </span>
                
              </span>
          
              <span class="post-tags">
                <i class="iconfont icon-tags" title="标签"></i>
                
                <span class="span--tag">
                  <a href="/tags/%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0/" title="学习札记">
                    <b>#</b> 学习札记
                  </a>
                </span>
                
                <span class="span--tag">
                  <a href="/tags/ptmalloc/" title="ptmalloc">
                    <b>#</b> ptmalloc
                  </a>
                </span>
                
                <span class="span--tag">
                  <a href="/tags/glibc/" title="glibc">
                    <b>#</b> glibc
                  </a>
                </span>
                
                <span class="span--tag">
                  <a href="/tags/%E5%A0%86-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" title="堆 - 内存管理">
                    <b>#</b> 堆 - 内存管理
                  </a>
                </span>
                
              </span>
          
      </div>
      <div class="markdown-body">
        <p>简简单单泄露个内存</p>
<span id="more"></span>

<h1 id="0x00-malloc"><a href="#0x00-malloc" class="headerlink" title="0x00.malloc"></a>0x00.malloc</h1><p>我们在编写C语言程序需要动态分配一块合适大小的内存时，我们通常都要用到malloc函数（包括C++的new运算符的一种实现方式便是封装了malloc）</p>
<p>glibc源码中对于malloc函数的定义如下：</p>
<p>首先我们在<strong>malloc&#x2F;malloc.h</strong>文件中可以看到对malloc函数的外部引用声明:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Allocate SIZE bytes of memory.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> *<span class="title function_">malloc</span> <span class="params">(<span class="type">size_t</span> __size)</span> __THROW __attribute_malloc__ __wur;</span><br></pre></td></tr></table></figure>

<p>在这里我们会看到三个奇怪的符号：<code>__THROW</code>、<code>__attribute_malloc__</code>、<code>__wur</code>，<del>似乎常规的C语言教科书上并没有介绍过这样奇怪的东西</del></p>
<h2 id="THROW：C-下不抛出异常"><a href="#THROW：C-下不抛出异常" class="headerlink" title="__THROW：C++下不抛出异常"></a>__THROW：C++下不抛出异常</h2><p>是一个宏定义，定义于misc&#x2F;sys&#x2F;cddefs.h下，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* GCC can always grok prototypes.  For C++ programs we add throw()</span></span><br><span class="line"><span class="comment">   to help it optimize the function calls.  But this works only with</span></span><br><span class="line"><span class="comment">   gcc 2.8.x and egcs.  For gcc 3.2 and up we even mark C functions</span></span><br><span class="line"><span class="comment">   as non-throwing using a function attribute since programs can use</span></span><br><span class="line"><span class="comment">   the -fexceptions options for C code as well.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> !defined __cplusplus &amp;&amp; __GNUC_PREREQ (3, 3)</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> __THROW	__attribute__ ((__nothrow__ __LEAF))</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> __THROWNL	__attribute__ ((__nothrow__))</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> __NTH(fct)	__attribute__ ((__nothrow__ __LEAF)) fct</span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="keyword">if</span> defined __cplusplus &amp;&amp; __GNUC_PREREQ (2,8)</span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> __THROW	throw ()</span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> __THROWNL	throw ()</span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> __NTH(fct)	__LEAF_ATTR fct throw ()</span></span><br><span class="line"><span class="meta">#  <span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> __THROW</span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> __THROWNL</span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> __NTH(fct)	fct</span></span><br><span class="line"><span class="meta">#  <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>若是在C++环境</strong>，表明该函数不会扔出异常，以避免编译器生成对异常的处理代码，从而优化代码生成结果.</p>
<p><strong>在C环境下没有任何效果</strong></p>
<h2 id="attribute-malloc-：优化malloc类型函数"><a href="#attribute-malloc-：优化malloc类型函数" class="headerlink" title="__attribute_malloc__：优化malloc类型函数"></a>__attribute_malloc__：优化malloc类型函数</h2><p>这个符号同样定义于misc&#x2F;sys&#x2F;cdefs.h下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* At some point during the gcc 2.96 development the `malloc&#x27; attribute</span></span><br><span class="line"><span class="comment">   for functions was introduced.  We don&#x27;t want to use it unconditionally</span></span><br><span class="line"><span class="comment">   (although this would be possible) since it generates warnings.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __GNUC_PREREQ (2,96)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __attribute_malloc__ __attribute__ ((__malloc__))</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __attribute_malloc__ <span class="comment">/* Ignore */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>对于gcc2.96及以上的版本，该段代码将会使用编译器的__attribute__指令</p>
<p>查阅gcc手册中说明如下：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">malloc</span><br></pre></td></tr></table></figure>

<p>Using this attribute can improve optimization. Compiler predicts that a function with the attribute returns non-null in most cases. Functions like <code>malloc</code> and <code>calloc</code> have this property because they return a pointer to uninitialized or zeroed-out storage. However, functions like <code>realloc</code> do not have this property, as they can return a pointer to storage containing pointers.</p>
</blockquote>
<p>大意是malloc作为一种attribute可以用来优化类似malloc、calloc等内存分配函数的代码，<del>我自己是声明用来优化像我自己这样的函数的</del>，同时也阐明了<strong>realloc函数并不使用这样一个attribute特性，因为realloc函数可能会返回指向包含有其他指针的内存块的指针</strong></p>
<p>对于gcc2.96以下的版本，宏定义__attribute_malloc__<strong>是无效的</strong></p>
<blockquote>
<h4 id="GNUC-PREREQ"><a href="#GNUC-PREREQ" class="headerlink" title="__GNUC_PREREQ()"></a>__GNUC_PREREQ()</h4><p>定义于sys&#x2F;features.h下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Convenience macros to test the versions of glibc and gcc.</span></span><br><span class="line"><span class="comment">Use them like this:</span></span><br><span class="line"><span class="comment">#if __GNUC_PREREQ (2,8)</span></span><br><span class="line"><span class="comment">... code requiring gcc 2.8 or later ...</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">Note - they won&#x27;t work for gcc1 or glibc1, since the _MINOR macros</span></span><br><span class="line"><span class="comment">were not defined then.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined __GNUC__ &amp;&amp; defined __GNUC_MINOR__</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __GNUC_PREREQ(maj, min) \</span></span><br><span class="line"><span class="meta">	((__GNUC__ <span class="string">&lt;&lt; 16) + __GNUC_MINOR__ &gt;</span>= ((maj) &lt;&lt; 16) + (min))</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __GNUC_PREREQ(maj, min) 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>大意是检测gcc的版本，这里就不具体展开说明了</p>
<p><del>gcc pre-requirement</del></p>
</blockquote>
<h2 id="wur：若函数返回值未被引用则抛出警告"><a href="#wur：若函数返回值未被引用则抛出警告" class="headerlink" title="__wur：若函数返回值未被引用则抛出警告"></a>__wur：若函数返回值未被引用则抛出警告</h2><p>依然是位于misc&#x2F;sys&#x2F;cdefs.h下的一个宏定义，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* If fortification mode, we warn about unused results of certain</span></span><br><span class="line"><span class="comment">   function calls which can lead to problems.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __GNUC_PREREQ (3,4)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __attribute_warn_unused_result__ \</span></span><br><span class="line"><span class="meta">   __attribute__ ((__warn_unused_result__))</span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> __USE_FORTIFY_LEVEL &gt; 0</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> __wur __attribute_warn_unused_result__</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __attribute_warn_unused_result__ <span class="comment">/* empty */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __wur</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __wur <span class="comment">/* Ignore */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>若是gcc版本为3.4及以上，则首先会将<code>__attribute_warn_unused_result__</code>定义为<code>__attribute__ ((__warn_unused_result__))</code></p>
<p>该attribute在gcc手册中的说明如下：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">warn_unused_result</span><br></pre></td></tr></table></figure>

<p>The <code>warn_unused_result</code> attribute causes a warning to be emitted if a caller of the function with this attribute does not use its return value. This is useful for functions where not checking the result is either a security problem or always a bug, such as <code>realloc</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int fn () __attribute__ ((warn_unused_result));</span><br><span class="line">int foo ()</span><br><span class="line">&#123;</span><br><span class="line">if (fn () &lt; 0) return -1;</span><br><span class="line">fn ();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>results in warning on line 5.</p>
</blockquote>
<p>大意是<strong>若是该函数的返回值未被程序使用，则编译器会发出警告</strong><del>，然而又有谁会去注意warnings呢x</del></p>
<p>而<strong>当__USE_FORTIFY_LEVEL &gt; 0时</strong>，<code>__wur</code>会被启用，功能同上所述：检查函数返回值是否被使用，若否则发出警告</p>
<p>若是gcc版本为3.4以下，<strong>则该宏定义无效</strong></p>
<blockquote>
<h4 id="USE-FORTIFY-LEVEL"><a href="#USE-FORTIFY-LEVEL" class="headerlink" title="__USE_FORTIFY_LEVEL"></a>__USE_FORTIFY_LEVEL</h4><p>定义于features.h中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined _FORTIFY_SOURCE &amp;&amp; _FORTIFY_SOURCE &gt; 0</span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> !defined __OPTIMIZE__ || __OPTIMIZE__ &lt;= 0</span></span><br><span class="line"><span class="meta">#  <span class="keyword">warning</span> _FORTIFY_SOURCE requires compiling with optimization (-O)</span></span><br><span class="line"><span class="meta"># <span class="keyword">elif</span> !__GNUC_PREREQ (4, 1)</span></span><br><span class="line"><span class="meta">#  <span class="keyword">warning</span> _FORTIFY_SOURCE requires GCC 4.1 or later</span></span><br><span class="line"><span class="meta"># <span class="keyword">elif</span> _FORTIFY_SOURCE &gt; 1</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> __USE_FORTIFY_LEVEL 2</span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> __USE_FORTIFY_LEVEL 1</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __USE_FORTIFY_LEVEL</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __USE_FORTIFY_LEVEL 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>当_FORTIFY_SOURCE未被定义时则会置0，否则会对_FORTIFY_SOURCE的值进行判断，若大于1则为2，否则为1，<strong>无论如何只要定义了_FORTIFY_SOURCE且大于0，则__wur都会被启用</strong></p>
</blockquote>
<blockquote>
<h4 id="FORTIFY-SOURCE"><a href="#FORTIFY-SOURCE" class="headerlink" title="_FORTIFY_SOURCE"></a>_FORTIFY_SOURCE</h4><p>大概是和GCC编译选项相关的，可以使用<code>-D_FORTIFY_SOURCE</code>进行指定，如<code>-D_FORTIFY_SOURCE=1</code></p>
<p>Ubuntu18下默认<code>-D_FORTIFY_SOURCE=2</code></p>
</blockquote>
<h2 id="strong-alias：重命名malloc为-libc-malloc"><a href="#strong-alias：重命名malloc为-libc-malloc" class="headerlink" title="strong_alias：重命名malloc为__libc_malloc"></a>strong_alias：重命名malloc为__libc_malloc</h2><p>在上面我们已经简要地解析了在malloc.h中对于malloc函数的三个标记，大致是<strong>针对C++默认不抛出异常以优化代码，根据返回值皆为malloc类型进行代码编译优化，返回值未被使用时抛出警告</strong></p>
<p>但是在malloc.c中我们无法找到对于malloc函数的直接定义，<del>难道说实际上并没有这个函数🦄，事实上还真的没有这个函数x</del></p>
<p>不过我们可以在malloc.h中发现存在如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strong_alias (__libc_malloc, __malloc) strong_alias (__libc_malloc, <span class="built_in">malloc</span>)</span><br></pre></td></tr></table></figure>

<p>发现一个新的符号：<strong>strong_alias</strong></p>
<p>该宏定义于libc-symbols.h下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* GCC understands weak symbols and aliases; use its interface where</span><br><span class="line">   possible, instead of embedded assembly language.  */</span><br><span class="line"></span><br><span class="line">/* Define ALIASNAME as a strong alias for NAME.  */</span><br><span class="line"># define strong_alias(name, aliasname) _strong_alias(name, aliasname)</span><br><span class="line"># define _strong_alias(name, aliasname) \</span><br><span class="line">  extern __typeof (name) aliasname __attribute__ ((alias (#name)));</span><br></pre></td></tr></table></figure>

<p>_strong_alias宏是strong_alias的宏展开，而_strong_alias宏展开后则是<code>extern __typeof (name) aliasname __attribute__ ((alias (#name)));</code><del>无  限  套  娃</del></p>
<p><del>配合着glibc的注释，</del>不难理解，在这里<strong>将malloc声明为__libc_malloc的别名，即__libc_malloc才是我们在调用malloc时所真正调用的函数</strong></p>
<p>这下就真相大白了</p>
<blockquote>
<h4 id="typeof"><a href="#typeof" class="headerlink" title="__typeof"></a>__typeof</h4><p>拓展C关键字，用于获取某个东西的类型</p>
<p>用例如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> n)</span>&#123;<span class="keyword">return</span> n;&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> __typeof(foo()) var;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种情况下便可以获取到foo()函数的返回值为int类型，并以此声明一个int类型的变量var</p>
<p>需要注意的是__typeof(char)和__typeof(‘a’)所获得的结果是不一样的，后者会将之提升为int类型</p>
</blockquote>
<p>于是我们最终转到__libc_malloc的声明，在前面发现了一大段对于malloc的注释</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  malloc(size_t n)</span></span><br><span class="line"><span class="comment">  Returns a pointer to a newly allocated chunk of at least n bytes, or null</span></span><br><span class="line"><span class="comment">  if no space is available. Additionally, on failure, errno is</span></span><br><span class="line"><span class="comment">  set to ENOMEM on ANSI C systems.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  If n is zero, malloc returns a minumum-sized chunk. (The minimum</span></span><br><span class="line"><span class="comment">  size is 16 bytes on most 32bit systems, and 24 or 32 bytes on 64bit</span></span><br><span class="line"><span class="comment">  systems.)  On most systems, size_t is an unsigned type, so calls</span></span><br><span class="line"><span class="comment">  with negative arguments are interpreted as requests for huge amounts</span></span><br><span class="line"><span class="comment">  of space, which will often fail. The maximum supported value of n</span></span><br><span class="line"><span class="comment">  differs across systems, but is in all cases less than the maximum</span></span><br><span class="line"><span class="comment">  representable value of a size_t.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span>*  __libc_malloc(<span class="type">size_t</span>);</span><br><span class="line">libc_hidden_proto (__libc_malloc)</span><br></pre></td></tr></table></figure>

<p>故我们最终可以得知：当我们调用malloc函数时，其真正调用的函数应当是是<strong>__libc_malloc</strong></p>
<p>于是接下来我们来看看<strong>__libc_malloc函数的源码</strong></p>
<h1 id="0x01-libc-malloc"><a href="#0x01-libc-malloc" class="headerlink" title="0x01.__libc_malloc"></a>0x01.__libc_malloc</h1><p>该段代码同样位于malloc&#x2F;malloc.c中，我们首先先阅读这段关于malloc的注释</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  malloc(size_t n)</span></span><br><span class="line"><span class="comment">  Returns a pointer to a newly allocated chunk of at least n bytes, or null</span></span><br><span class="line"><span class="comment">  if no space is available. Additionally, on failure, errno is</span></span><br><span class="line"><span class="comment">  set to ENOMEM on ANSI C systems.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  If n is zero, malloc returns a minumum-sized chunk. (The minimum</span></span><br><span class="line"><span class="comment">  size is 16 bytes on most 32bit systems, and 24 or 32 bytes on 64bit</span></span><br><span class="line"><span class="comment">  systems.)  On most systems, size_t is an unsigned type, so calls</span></span><br><span class="line"><span class="comment">  with negative arguments are interpreted as requests for huge amounts</span></span><br><span class="line"><span class="comment">  of space, which will often fail. The maximum supported value of n</span></span><br><span class="line"><span class="comment">  differs across systems, but is in all cases less than the maximum</span></span><br><span class="line"><span class="comment">  representable value of a size_t.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span>*  __libc_malloc(<span class="type">size_t</span>);</span><br><span class="line">libc_hidden_proto (__libc_malloc)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>（arttnba3译）</p>
<p>malloc(size_t n)</p>
<p>将会返回一个指向分配给的至少n bytes大小的chunk的指针，若空间不足则会返回NULL。此外，在ANSI C标准的系统上，errno会被设为<strong>ENOMEM</strong></p>
<p>当n为0时，malloc将会返回一个最小size的chunk（32位系统下为16bytes，64位系统下则为24或32bytes）。在大部分系统上，size_t为无符号类型，因此负数大小的请求将会被解释为一个对于极巨大内存空间的请求，而这通常都会失败。对于支持的最大的内存请求通常在不同的操作系统上不一致，但都会比size_t类型所能表达的最大值要小</p>
</blockquote>
<blockquote>
<h4 id="errno"><a href="#errno" class="headerlink" title="errno"></a>errno</h4><p>定义于errno.h中的一个储存错误代码的变量，具体错误代码详见sysdeps&#x2F;mach&#x2F;hurd&#x2F;bits&#x2F;errno.h</p>
<p>其中ENOMEM的值为12</p>
<p>（笔者猜测ENOMEM应该为error: no memory的意思）</p>
</blockquote>
<p>也就是说malloc(0)并不会返回内存大小为0的内存空间，而是返回一个最小size的chunk</p>
<p>同时我们还能发现：在__libc_malloc的函数声明下还有一行奇怪的代码——libc_hidden_proto</p>
<h2 id="libc-hidden-proto：函数符号隐藏"><a href="#libc-hidden-proto：函数符号隐藏" class="headerlink" title="libc_hidden_proto：函数符号隐藏"></a>libc_hidden_proto：函数符号隐藏</h2><p>该符号被定义在include&#x2F;libc-symbols.h下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> IS_IN (libc)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> libc_hidden_proto(name, attrs...) hidden_proto (name, ##attrs)</span></span><br><span class="line">...<span class="comment">//中间的代码太多了，这里我就不copy了</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> libc_hidden_proto(name, attrs...)</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>在libc中该宏展开为hidden_proto宏，该宏同样定义于include&#x2F;libc-symbols.h中，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined SHARED &amp;&amp; !defined NO_HIDDEN</span></span><br><span class="line"><span class="meta"># <span class="keyword">ifndef</span> __ASSEMBLER__</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> __hidden_proto_hiddenattr(attrs...) \</span></span><br><span class="line"><span class="meta">  __attribute__ ((visibility (<span class="string">&quot;hidden&quot;</span>), ##attrs))</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> hidden_proto(name, attrs...) \</span></span><br><span class="line"><span class="meta">  __hidden_proto (name, , __GI_##name, ##attrs)</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> hidden_tls_proto(name, attrs...) \</span></span><br><span class="line"><span class="meta">  __hidden_proto (name, __thread, __GI_##name, ##attrs)</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> __hidden_proto(name, thread, internal, attrs...)	     \</span></span><br><span class="line"><span class="meta">  extern thread __typeof (name) name __asm__ (__hidden_asmname (#internal)) \</span></span><br><span class="line"><span class="meta">  __hidden_proto_hiddenattr (attrs);</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">ifndef</span> __ASSEMBLER__</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> hidden_proto(name, attrs...)</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>看得出来在多重套娃之后这其实是一个attribute，里边套的是visibility (“hidden”)，查看gcc手册我们可以发现其说明如下：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hidden</span><br></pre></td></tr></table></figure>

<p>Hidden visibility indicates that the entity declared has a new form of linkage, which we call “hidden linkage”. Two declarations of an object with hidden linkage refer to the same object if they are in the same shared object.</p>
</blockquote>
<p>大意是说这个attribute声明该函数的visibility为hidden，其有着一种新的链接形式，称之为“隐式链接”（hidden linkage），即<strong>对于链接该库的程序而言，该函数是隐藏的</strong></p>
<p>在<strong>非libc中该宏无效</strong></p>
<blockquote>
<h4 id="attribute-visibility-“hidden”"><a href="#attribute-visibility-“hidden”" class="headerlink" title="attribute: visibility(“hidden”)"></a>attribute: visibility(“hidden”)</h4><p>通俗来讲，hidden是用于抑制一个符号的表达的</p>
<p>设想如下情况：程序a需要同时链接libc-arttnba1.so和libc-arttnba2.so两个库，而两个库中若是存在同名的函数，那么库的加载先后顺序的不同将会导致程序所调用的函数不同，<strong>毫无疑问这将造成混乱调用</strong></p>
<p>在使用attribute的visibility(“hidden”)的情况下，<strong>该函数将会抑制自身符号的表达</strong>：</p>
<p>同样设想前面的情况，若是存在一个同名函数foo()，而libc-arttnba2.so中的foo()函数使用attribute设定了visibility为hidden的情况下，无论这两个动态链接库的加载先后顺序如何，都只会调用libc-arttnba1.so中的foo()函数</p>
</blockquote>
<p>接下来我们看该函数的定义部分</p>
<h2 id="libc-malloc函数定义："><a href="#libc-malloc函数定义：" class="headerlink" title="__libc_malloc函数定义："></a>__libc_malloc函数定义：</h2><p>若是第一次阅读libc源码，毫无疑问我们会十分惊奇地发现该函数的代码超乎想象的短，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line">__libc_malloc (<span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="type">void</span> *victim;</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *(*hook) (<span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line"></span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">  <span class="comment">/* Retry with another arena only if we were able to find a usable arena</span></span><br><span class="line"><span class="comment">     before.  */</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      LIBC_PROBE (memory_malloc_retry, <span class="number">1</span>, bytes);</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    (<span class="type">void</span>) mutex_unlock (&amp;ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">          ar_ptr == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">  <span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__libc_malloc)</span><br></pre></td></tr></table></figure>

<p>首先开头定义三个变量：mstate类型的ar_ptr，void类型指针victim，返回值为void类型指针的函数指针hook</p>
<blockquote>
<p>不难想到，ar_ptr即为arena pointer；victim应当为指向分配的chunk的指针；而这个hook应当就是我们比赛中常打的__malloc_hook</p>
</blockquote>
<h3 id="1-检查钩子-malloc-hook是否为NULL，若否，则调用钩子"><a href="#1-检查钩子-malloc-hook是否为NULL，若否，则调用钩子" class="headerlink" title="1.检查钩子__malloc_hook是否为NULL，若否，则调用钩子"></a>1.检查钩子__malloc_hook是否为NULL，若否，则调用钩子</h3><p>在函数一开始的时候会先调用<code>atomic_forced_read()</code>给hook变量赋值，传入这个函数的参数为<strong>__malloc_hook</strong></p>
<p>我们先看<code>atomic_forced_read()</code>，是一个定义于include&#x2F;atomic.h中的宏，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> atomic_forced_read</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> atomic_forced_read(x) \</span></span><br><span class="line"><span class="meta">  (&#123; __typeof (x) __x; __asm (<span class="string">&quot;&quot;</span> : <span class="string">&quot;=r&quot;</span> (__x) : <span class="string">&quot;0&quot;</span> (x)); __x; &#125;)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><del>直接翻译函数名是用原子能来读取</del></p>
<p>大概是<strong>通过使用原子操作</strong>将x读入到一个寄存器中再返回，原子操作简单来说就是不会被线程的调度打断的操作，用处是防止由于多线程冲突导致的该值被重载</p>
<p>接下来我们来看<strong>__malloc_hook</strong>的声明，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">weak_variable</span> <span class="params">(*__malloc_hook)</span></span><br><span class="line">  <span class="params">(<span class="type">size_t</span> __size, <span class="type">const</span> <span class="type">void</span> *)</span> = malloc_hook_ini;</span><br></pre></td></tr></table></figure>

<p>可见<strong>__malloc_hook应为一函数指针，初始时指向malloc_hook_ini函数</strong></p>
<blockquote>
<h4 id="weak-variable"><a href="#weak-variable" class="headerlink" title="weak_variable"></a>weak_variable</h4><p>定义于malloc.c中代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> weak_variable</span></span><br><span class="line"><span class="comment">/* In GNU libc we want the hook variables to be weak definitions to</span></span><br><span class="line"><span class="comment">avoid a problem with Emacs.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> weak_variable weak_function</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>还是套娃定义，跟进，在include&#x2F;libc-symbols.h中可见其定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This comes between the return type and function name in</span></span><br><span class="line"><span class="comment">a function definition to make that definition weak.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> weak_function __attribute__ ((weak))</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> weak_const_function __attribute__ ((weak, __const__))</span></span><br></pre></td></tr></table></figure>

<p>也就是说这还是一个gcc的attribute，查阅手册中说明如下：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">weak</span><br></pre></td></tr></table></figure>

<p>The <code>weak</code> attribute causes a declaration of an external symbol to be emitted as a weak symbol rather than a global. This is primarily useful in defining library functions that can be overridden in user code, though it can also be used with non-function declarations. The overriding symbol must have the same type as the weak symbol. In addition, if it designates a variable it must also have the same size and alignment as the weak symbol. Weak symbols are supported for ELF targets, and also for a.out targets when using the GNU assembler and linker.</p>
</blockquote>
<p>可知这个attribute大意是对于该符号而言链接器会去优先寻找全局符号，无法找寻到符合条件的全局符号后才会使用弱符号，以避免重定义错误；即当一个符号可能或需要被用户覆盖时，可将之声明为一个弱符号</p>
</blockquote>
<p>当<strong>hook钩子不为NULL时会执行其指向的函数并返回</strong>，__libc_malloc函数便于此暂时结束其旅程了</p>
<p>而__malloc_hook的初始值便不为NULL，故<strong>在第一次调用malloc函数时一定会转到执行malloc_hook_ini函数</strong></p>
<h4 id="①malloc-hook-ini：重置-malloc-hook为NULL，调用ptmalloc初始化函数，重新调用-libc-malloc分配内存块"><a href="#①malloc-hook-ini：重置-malloc-hook为NULL，调用ptmalloc初始化函数，重新调用-libc-malloc分配内存块" class="headerlink" title="①malloc_hook__ini：重置__malloc_hook为NULL，调用ptmalloc初始化函数，重新调用__libc_malloc分配内存块"></a>①malloc_hook__ini：重置__malloc_hook为NULL，调用ptmalloc初始化函数，重新调用__libc_malloc分配内存块</h4><p>由于malloc_hook_ini函数在第一次调用malloc时一定会被调用一次，故我们先来看看这个函数</p>
<p>malloc_hook_ini函数的声明在malloc.c中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">malloc_hook_ini</span> <span class="params">(<span class="type">size_t</span> sz,</span></span><br><span class="line"><span class="params">                              <span class="type">const</span> <span class="type">void</span> *caller)</span> __THROW;</span><br></pre></td></tr></table></figure>

<p>该函数定义于malloc&#x2F;hook.c中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">malloc_hook_ini</span> <span class="params">(<span class="type">size_t</span> sz, <span class="type">const</span> <span class="type">void</span> *caller)</span></span><br><span class="line">&#123;</span><br><span class="line">  __malloc_hook = <span class="literal">NULL</span>;</span><br><span class="line">  ptmalloc_init ();</span><br><span class="line">  <span class="keyword">return</span> __libc_malloc (sz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数做了三件小事：</p>
<ul>
<li><strong>将__malloc_hook赋值为NULL</strong>，这样一来在第二次及以后调用malloc时都不会进入malloc_hook_ini函数，而是接着__libc_malloc的函数进程往下走</li>
<li><strong>调用ptmalloc_init()函数</strong></li>
<li><strong>重新调用__libc_malloc()函数分配合适的内存块返回给用户</strong></li>
</ul>
<p>于是我们接下来来看看ptmalloc_init()函数</p>
<h4 id="②ptmalloc-init-：初始化ptmalloc堆管理器"><a href="#②ptmalloc-init-：初始化ptmalloc堆管理器" class="headerlink" title="②ptmalloc_init()：初始化ptmalloc堆管理器"></a>②ptmalloc_init()：初始化ptmalloc堆管理器</h4><p>该函数定义于malloc&#x2F;arena.c中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">ptmalloc_init</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__malloc_initialized &gt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  __malloc_initialized = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">  <span class="comment">/* In case this libc copy is in a non-default namespace, never use brk.</span></span><br><span class="line"><span class="comment">     Likewise if dlopened from statically linked program.  */</span></span><br><span class="line">  Dl_info di;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (_dl_open_hook != <span class="literal">NULL</span></span><br><span class="line">      || (_dl_addr (ptmalloc_init, &amp;di, &amp;l, <span class="literal">NULL</span>) != <span class="number">0</span></span><br><span class="line">          &amp;&amp; l-&gt;l_ns != LM_ID_BASE))</span><br><span class="line">    __morecore = __failing_morecore;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  thread_arena = &amp;main_arena;</span><br><span class="line">  thread_atfork (ptmalloc_lock_all, ptmalloc_unlock_all, ptmalloc_unlock_all2);</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *s = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_likely (_environ != <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">char</span> **runp = _environ;</span><br><span class="line">      <span class="type">char</span> *envline;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (__builtin_expect ((envline = next_env_entry (&amp;runp)) != <span class="literal">NULL</span>,</span><br><span class="line">                               <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="type">size_t</span> len = <span class="built_in">strcspn</span> (envline, <span class="string">&quot;=&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (envline[len] != <span class="string">&#x27;=&#x27;</span>)</span><br><span class="line">            <span class="comment">/* This is a &quot;MALLOC_&quot; variable at the end of the string</span></span><br><span class="line"><span class="comment">               without a &#x27;=&#x27; character.  Ignore it since otherwise we</span></span><br><span class="line"><span class="comment">               will access invalid memory below.  */</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">switch</span> (len)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">              <span class="keyword">if</span> (<span class="built_in">memcmp</span> (envline, <span class="string">&quot;CHECK_&quot;</span>, <span class="number">6</span>) == <span class="number">0</span>)</span><br><span class="line">                s = &amp;envline[<span class="number">7</span>];</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">              <span class="keyword">if</span> (!__builtin_expect (__libc_enable_secure, <span class="number">0</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="keyword">if</span> (<span class="built_in">memcmp</span> (envline, <span class="string">&quot;TOP_PAD_&quot;</span>, <span class="number">8</span>) == <span class="number">0</span>)</span><br><span class="line">                    __libc_mallopt (M_TOP_PAD, atoi (&amp;envline[<span class="number">9</span>]));</span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">memcmp</span> (envline, <span class="string">&quot;PERTURB_&quot;</span>, <span class="number">8</span>) == <span class="number">0</span>)</span><br><span class="line">                    __libc_mallopt (M_PERTURB, atoi (&amp;envline[<span class="number">9</span>]));</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">              <span class="keyword">if</span> (!__builtin_expect (__libc_enable_secure, <span class="number">0</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="keyword">if</span> (<span class="built_in">memcmp</span> (envline, <span class="string">&quot;MMAP_MAX_&quot;</span>, <span class="number">9</span>) == <span class="number">0</span>)</span><br><span class="line">                    __libc_mallopt (M_MMAP_MAX, atoi (&amp;envline[<span class="number">10</span>]));</span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">memcmp</span> (envline, <span class="string">&quot;ARENA_MAX&quot;</span>, <span class="number">9</span>) == <span class="number">0</span>)</span><br><span class="line">                    __libc_mallopt (M_ARENA_MAX, atoi (&amp;envline[<span class="number">10</span>]));</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">              <span class="keyword">if</span> (!__builtin_expect (__libc_enable_secure, <span class="number">0</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="keyword">if</span> (<span class="built_in">memcmp</span> (envline, <span class="string">&quot;ARENA_TEST&quot;</span>, <span class="number">10</span>) == <span class="number">0</span>)</span><br><span class="line">                    __libc_mallopt (M_ARENA_TEST, atoi (&amp;envline[<span class="number">11</span>]));</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">15</span>:</span><br><span class="line">              <span class="keyword">if</span> (!__builtin_expect (__libc_enable_secure, <span class="number">0</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="keyword">if</span> (<span class="built_in">memcmp</span> (envline, <span class="string">&quot;TRIM_THRESHOLD_&quot;</span>, <span class="number">15</span>) == <span class="number">0</span>)</span><br><span class="line">                    __libc_mallopt (M_TRIM_THRESHOLD, atoi (&amp;envline[<span class="number">16</span>]));</span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">memcmp</span> (envline, <span class="string">&quot;MMAP_THRESHOLD_&quot;</span>, <span class="number">15</span>) == <span class="number">0</span>)</span><br><span class="line">                    __libc_mallopt (M_MMAP_THRESHOLD, atoi (&amp;envline[<span class="number">16</span>]));</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (s &amp;&amp; s[<span class="number">0</span>])</span><br><span class="line">    &#123;</span><br><span class="line">      __libc_mallopt (M_CHECK_ACTION, (<span class="type">int</span>) (s[<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">      <span class="keyword">if</span> (check_action != <span class="number">0</span>)</span><br><span class="line">        __malloc_check_init ();</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="type">void</span> (*hook) (<span class="type">void</span>) = atomic_forced_read (__malloc_initialize_hook);</span><br><span class="line">  <span class="keyword">if</span> (hook != <span class="literal">NULL</span>)</span><br><span class="line">    (*hook)();</span><br><span class="line">  __malloc_initialized = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1）修改ptmalloc初始化标志位"><a href="#1）修改ptmalloc初始化标志位" class="headerlink" title="1）修改ptmalloc初始化标志位"></a>1）修改ptmalloc初始化标志位</h5><p>开头先检测<code>__maloc_initialized</code>是否大于等于0，若否才会继续执行接下来的一切，而第一步便是将之置0，故不难得出这是一个<strong>用来检测ptmalloc是否已经初始化</strong>的标志位；</p>
<p>该变量同样定义于arena.c中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Already initialized? */</span></span><br><span class="line"><span class="type">int</span> __malloc_initialized = <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>

<p>其初始值被设置为<code>-1</code>，保证了这个函数一定会被执行一次</p>
<h5 id="2）检查SHARED宏"><a href="#2）检查SHARED宏" class="headerlink" title="2）检查SHARED宏"></a>2）检查SHARED宏</h5><p>接下来会检查<code>SHARED</code>宏是否有被定义过，注释说明：<strong>假使该libc副本在非默认的命名空间中，则不要使用brk系统调用；同样的，若是在使用dlopen</strong>()<strong>打开一个静态链接的程序的情况下亦是如此</strong></p>
<p><del>这个宏的定义位置暂且找不到，这里就先不管了</del></p>
<h5 id="3）获取main-arena，添加atfork-mem入fork-handler链表"><a href="#3）获取main-arena，添加atfork-mem入fork-handler链表" class="headerlink" title="3）获取main_arena，添加atfork_mem入fork_handler链表"></a>3）获取main_arena，添加atfork_mem入fork_handler链表</h5><p>接下来会先设置该线程arena为main_arena，即在ptmalloc未初始化时默认会使用main_arena，而不是新建arena</p>
<p>随后是使用了<code>thread_atfork()</code>宏，该宏定义于sysdeps&#x2F;nptl&#x2F;malloc-machine.h中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ATFORK_MEM static struct fork_handler atfork_mem</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> thread_atfork(prepare, parent, child) \</span></span><br><span class="line"><span class="meta">  atfork_mem.prepare_handler = prepare;					      \</span></span><br><span class="line"><span class="meta">  atfork_mem.parent_handler = parent;					      \</span></span><br><span class="line"><span class="meta">  atfork_mem.child_handler = child;					      \</span></span><br><span class="line"><span class="meta">  atfork_mem.dso_handle = __dso_handle;					      \</span></span><br><span class="line"><span class="meta">  atfork_mem.refcntr = 1;						      \</span></span><br><span class="line"><span class="meta">  __linkin_atfork (&amp;atfork_mem)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> thread_atfork(prepare, parent, child) \</span></span><br><span class="line"><span class="meta">  atfork_mem.prepare_handler = prepare;					      \</span></span><br><span class="line"><span class="meta">  atfork_mem.parent_handler = parent;					      \</span></span><br><span class="line"><span class="meta">  atfork_mem.child_handler = child;					      \</span></span><br><span class="line"><span class="meta">  atfork_mem.dso_handle = &amp;__dso_handle == NULL ? NULL : __dso_handle;	      \</span></span><br><span class="line"><span class="meta">  atfork_mem.refcntr = 1;						      \</span></span><br><span class="line"><span class="meta">  __linkin_atfork (&amp;atfork_mem)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>这里的atfork_mem变量的类型为fork_handler结构体，该结构体定义与sysdeps&#x2F;nptl&#x2F;fork.h中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fork_handler</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">fork_handler</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="type">void</span> (*prepare_handler) (<span class="type">void</span>);</span><br><span class="line">  <span class="type">void</span> (*parent_handler) (<span class="type">void</span>);</span><br><span class="line">  <span class="type">void</span> (*child_handler) (<span class="type">void</span>);</span><br><span class="line">  <span class="type">void</span> *dso_handle;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> refcntr;</span><br><span class="line">  <span class="type">int</span> need_signal;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>不难看出fork_handler之间同样链接成一个单向链表</p>
<p>那么我们可以得出thread_atfork()宏设置了三个函数指针，并最终又调用了函数__linkin_atfork()，该函数定义于nptl&#x2F;register-atfork.c中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">attribute_hidden</span><br><span class="line">__linkin_atfork (<span class="keyword">struct</span> fork_handler *newp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    newp-&gt;next = __fork_handlers;</span><br><span class="line">  <span class="keyword">while</span> (catomic_compare_and_exchange_bool_acq (&amp;__fork_handlers,</span><br><span class="line">						newp, newp-&gt;next) != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得出__linkin_atfork()的作用应当为将atfork_mem添加入fork_handler链表中</p>
<p><strong>这一系列下来的操作的作用是：在接下来程序fork出子线程时会调用atfork_mem中的三个函数指针所指向的函数</strong></p>
<h5 id="4）环境变量-environ相关操作"><a href="#4）环境变量-environ相关操作" class="headerlink" title="4）环境变量__environ相关操作"></a>4）环境变量__environ相关操作</h5><p>接下来会检查_environ变量是否为NULL，该变量为__environ变量的弱别名，定义于posix&#x2F;environ.c中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This must be initialized; we cannot have a weak alias into bss.  */</span></span><br><span class="line"><span class="type">char</span> **__environ = <span class="literal">NULL</span>;</span><br><span class="line">weak_alias (__environ, environ)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The SVR4 ABI says `_environ&#x27; will be the name to use</span></span><br><span class="line"><span class="comment">   in case the user overrides the weak alias `environ&#x27;.  */</span></span><br><span class="line">weak_alias (__environ, _environ)</span><br></pre></td></tr></table></figure>

<p>weak_alias和strong_alias是类似的，只不过定义的是弱别名，这里便不再赘叙</p>
<p>__environ变量一般都不为NULL，因此在这里使用了分支预测优化封装宏__glibc_likely()（详细定义前文已有说明）</p>
<p>接下来会调用<code>next_env_entry()</code>函数，同样定义于arena.c中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> *</span><br><span class="line">internal_function</span><br><span class="line"><span class="title function_">next_env_entry</span> <span class="params">(<span class="type">char</span> ***position)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> **current = *position;</span><br><span class="line">  <span class="type">char</span> *result = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (*current != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect ((*current)[<span class="number">0</span>] == <span class="string">&#x27;M&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">          &amp;&amp; (*current)[<span class="number">1</span>] == <span class="string">&#x27;A&#x27;</span></span><br><span class="line">          &amp;&amp; (*current)[<span class="number">2</span>] == <span class="string">&#x27;L&#x27;</span></span><br><span class="line">          &amp;&amp; (*current)[<span class="number">3</span>] == <span class="string">&#x27;L&#x27;</span></span><br><span class="line">          &amp;&amp; (*current)[<span class="number">4</span>] == <span class="string">&#x27;O&#x27;</span></span><br><span class="line">          &amp;&amp; (*current)[<span class="number">5</span>] == <span class="string">&#x27;C&#x27;</span></span><br><span class="line">          &amp;&amp; (*current)[<span class="number">6</span>] == <span class="string">&#x27;_&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          result = &amp;(*current)[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Save current position for next visit.  */</span></span><br><span class="line">          *position = ++current;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      ++current;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大概作用是在<code>__environ</code>中找到<strong>开头为”MALLOC_“的字符串</strong>的地址，若找不到则返回NULL</p>
<p>通常情况下<code>__environ</code>中不存在这样的字符串，因而在这里用了builtin_expect宏</p>
<p>若该字符串存在，则会调用<code>strcspn()</code>函数查找字符<code>&#39;=&#39;</code>，若不存在则又会重新回去调用<code>next_env_entry()</code>函数</p>
<blockquote>
<p>笔者认为这里有可能造成死循环</p>
</blockquote>
<p>函数中设定的需要处理的字符串如下：</p>
<ul>
<li><strong>MALLOC_CHECK_</strong></li>
<li><strong>MALLOC_TOP_PAD_</strong></li>
<li><strong>MALLOC_PERTURB_</strong></li>
<li><strong>MALLOC_MMAP_MAX_</strong></li>
<li><strong>MALLOC_ARENA_MAX</strong></li>
<li><strong>MALLOC_ARENA_TEST</strong></li>
<li><strong>MALLOC_TRIM_THRESHOLD_</strong></li>
<li><strong>MALLOC_MMAP_THRESHOLD_</strong></li>
</ul>
<p>需要注意的是，针对<code>MALLOC_CHECK_</code>，ptmalloc_init()函数会单独进行处理，而剩下的则会调用<code>__libc_mallopt()</code>函数进行处理</p>
<p>该函数定义于malloc.c中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">__libc_mallopt (<span class="type">int</span> param_number, <span class="type">int</span> value)</span><br><span class="line">&#123;</span><br><span class="line">  mstate av = &amp;main_arena;</span><br><span class="line">  <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__malloc_initialized &lt; <span class="number">0</span>)</span><br><span class="line">    ptmalloc_init ();</span><br><span class="line">  (<span class="type">void</span>) mutex_lock (&amp;av-&gt;mutex);</span><br><span class="line">  <span class="comment">/* Ensure initialization/consolidation */</span></span><br><span class="line">  malloc_consolidate (av);</span><br><span class="line"></span><br><span class="line">  LIBC_PROBE (memory_mallopt, <span class="number">2</span>, param_number, value);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (param_number)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> M_MXFAST:</span><br><span class="line">      <span class="keyword">if</span> (value &gt;= <span class="number">0</span> &amp;&amp; value &lt;= MAX_FAST_SIZE)</span><br><span class="line">        &#123;</span><br><span class="line">          LIBC_PROBE (memory_mallopt_mxfast, <span class="number">2</span>, value, get_max_fast ());</span><br><span class="line">          set_max_fast (value);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> M_TRIM_THRESHOLD:</span><br><span class="line">      LIBC_PROBE (memory_mallopt_trim_threshold, <span class="number">3</span>, value,</span><br><span class="line">                  mp_.trim_threshold, mp_.no_dyn_threshold);</span><br><span class="line">      mp_.trim_threshold = value;</span><br><span class="line">      mp_.no_dyn_threshold = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> M_TOP_PAD:</span><br><span class="line">      LIBC_PROBE (memory_mallopt_top_pad, <span class="number">3</span>, value,</span><br><span class="line">                  mp_.top_pad, mp_.no_dyn_threshold);</span><br><span class="line">      mp_.top_pad = value;</span><br><span class="line">      mp_.no_dyn_threshold = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> M_MMAP_THRESHOLD:</span><br><span class="line">      <span class="comment">/* Forbid setting the threshold too high. */</span></span><br><span class="line">      <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) value &gt; HEAP_MAX_SIZE / <span class="number">2</span>)</span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          LIBC_PROBE (memory_mallopt_mmap_threshold, <span class="number">3</span>, value,</span><br><span class="line">                      mp_.mmap_threshold, mp_.no_dyn_threshold);</span><br><span class="line">          mp_.mmap_threshold = value;</span><br><span class="line">          mp_.no_dyn_threshold = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> M_MMAP_MAX:</span><br><span class="line">      LIBC_PROBE (memory_mallopt_mmap_max, <span class="number">3</span>, value,</span><br><span class="line">                  mp_.n_mmaps_max, mp_.no_dyn_threshold);</span><br><span class="line">      mp_.n_mmaps_max = value;</span><br><span class="line">      mp_.no_dyn_threshold = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> M_CHECK_ACTION:</span><br><span class="line">      LIBC_PROBE (memory_mallopt_check_action, <span class="number">2</span>, value, check_action);</span><br><span class="line">      check_action = value;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> M_PERTURB:</span><br><span class="line">      LIBC_PROBE (memory_mallopt_perturb, <span class="number">2</span>, value, perturb_byte);</span><br><span class="line">      perturb_byte = value;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> M_ARENA_TEST:</span><br><span class="line">      <span class="keyword">if</span> (value &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          LIBC_PROBE (memory_mallopt_arena_test, <span class="number">2</span>, value, mp_.arena_test);</span><br><span class="line">          mp_.arena_test = value;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> M_ARENA_MAX:</span><br><span class="line">      <span class="keyword">if</span> (value &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          LIBC_PROBE (memory_mallopt_arena_max, <span class="number">2</span>, value, mp_.arena_max);</span><br><span class="line">          mp_.arena_max = value;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  (<span class="type">void</span>) mutex_unlock (&amp;av-&gt;mutex);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__libc_mallopt)</span><br></pre></td></tr></table></figure>

<p>首先会检查<code>malloc_initialized</code>的值，若是小于0则会调用<code>ptmalloc_init()</code>函数，<del>这是又套娃回去了，不过这里在前面开头已经将其置0了，所以这种情况不会发生</del></p>
<p>接下来首先会锁上main_arena的互斥锁，随后调用<code>malloc_consolidate()</code>函数清空fastbin中的chunk，这个函数我们会在后面详细分析</p>
<p>接下来就是针对不同的情况对不同的变量设置不同的（初始？）值，完成后解锁main_arena并返回</p>
<p>而对于字符串<code>&quot;MALLOC_CHECK_&quot;</code>，则会先调用<code>__libc_mallopt()</code>函数，之后，检查变量<code>check_action</code>的值，若不为0则会调用<code>__malloc_check_init()</code>函数</p>
<blockquote>
<p>笔者认为这一步其实可以合并到前面的switch中，而不需要单开一个if</p>
</blockquote>
<p>check_action定义于malloc.c中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DEFAULT_CHECK_ACTION</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> DEFAULT_CHECK_ACTION 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> check_action = DEFAULT_CHECK_ACTION;</span><br></pre></td></tr></table></figure>

<p>即该静态变量的值默认为3，即默认情况下对于字符串<code>&quot;MALLOC_CHECK&quot;</code>，都会调用<code>__malloc_check_init()</code>函数</p>
<p>该函数定义于malloc&#x2F;hook.c中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> disallow_malloc_check;</span><br><span class="line"><span class="comment">/* Activate a standard set of debugging hooks. */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line">__malloc_check_init (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (disallow_malloc_check)</span><br><span class="line">    &#123;</span><br><span class="line">      disallow_malloc_check = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  using_malloc_checking = <span class="number">1</span>;</span><br><span class="line">  __malloc_hook = malloc_check;</span><br><span class="line">  __free_hook = free_check;</span><br><span class="line">  __realloc_hook = realloc_check;</span><br><span class="line">  __memalign_hook = memalign_check;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若是变量<code>disallow_malloc_check</code>不为0则会赋值为0后直接返回，否则会将<code>using_malloc_check</code>赋值为1后将四个hook钩子分别设为对应的check函数</p>
<h5 id="5）检查钩子-malloc-initialized-hook"><a href="#5）检查钩子-malloc-initialized-hook" class="headerlink" title="5）检查钩子__malloc_initialized_hook"></a>5）检查钩子__malloc_initialized_hook</h5><p>最后便是检查钩子<code>__malloc_initialize_hook</code>是否为NULL，若否，则会调用其所指向的函数</p>
<p>该hook定义于malloc.c中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">weak_variable</span> <span class="params">(*__malloc_initialize_hook)</span> <span class="params">(<span class="type">void</span>)</span> = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>即初始情况下该钩子应当为NULL</p>
<p>最后将<code>__malloc_initialized</code>的值设为1后，这个函数就结束了</p>
<h3 id="2-获取一个arena"><a href="#2-获取一个arena" class="headerlink" title="2.获取一个arena"></a>2.获取一个arena</h3><p>接下来会通过宏<code>arena_get()</code>尝试获取一个arena，这个宏的具体实现在前面已经详细叙述过了，这里就不再赘叙了</p>
<p>由于在ptmalloc_init()函数中已经将thread_arena设为main_arena了，所以第一次调用malloc时便会<strong>直接锁上main_arena后使用</strong></p>
<p>对于其他后续进行调用的线程则会<strong>先检查free_list是否有可用空闲arena，若没有可用空闲arena则尝试在Memory Mapping Segment新建一个arena，若失败则只能与其他线程共享arena</strong></p>
<h3 id="⭐3-调用-int-malloc-函数分配内存"><a href="#⭐3-调用-int-malloc-函数分配内存" class="headerlink" title="⭐3.调用_int_malloc()函数分配内存"></a>⭐3.调用_int_malloc()函数分配内存</h3><p>接下来__libc_malloc()函数会调用<code>_int_malloc()</code>函数<strong>真正开始进行内存分配</strong>，也就是说内存分配的<strong>核心函数其实是</strong><code>_int_malloc()</code>函数，__libc_malloc()函数其实本身还是对该函数的一层封装，并附加上一些堆管理器相关的操作，该函数我们会在后面详细进行解析</p>
<h3 id="4-检测结果，若为NULL则重新获得arena并重新调用-int-malloc-分配内存"><a href="#4-检测结果，若为NULL则重新获得arena并重新调用-int-malloc-分配内存" class="headerlink" title="4.检测结果，若为NULL则重新获得arena并重新调用_int_malloc()分配内存"></a>4.检测结果，若为NULL则重新获得arena并重新调用_int_malloc()分配内存</h3><p>若是<code>_int_malloc()</code>函数未能够成功获取到一个适合的堆块，则会向上层函数返回NULL，因此在这里会对其返回的结果进行检测</p>
<p>由于ptmalloc考虑到可能是arena不足以提供所需空间的原因，故在这里首先会调用<code>arena_gert_retry()</code>函数，重新尝试获得一个新的arena</p>
<h4 id="①arena-get-retry-：重新获得一个arena"><a href="#①arena-get-retry-：重新获得一个arena" class="headerlink" title="①arena_get_retry()：重新获得一个arena"></a>①arena_get_retry()：重新获得一个arena</h4><p>该函数定义于arena.c中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* If we don&#x27;t have the main arena, then maybe the failure is due to running</span></span><br><span class="line"><span class="comment">   out of mmapped areas, so we can try allocating on the main arena.</span></span><br><span class="line"><span class="comment">   Otherwise, it is likely that sbrk() has failed and there is still a chance</span></span><br><span class="line"><span class="comment">   to mmap(), so try one of the other arenas.  */</span></span><br><span class="line"><span class="type">static</span> mstate</span><br><span class="line"><span class="title function_">arena_get_retry</span> <span class="params">(mstate ar_ptr, <span class="type">size_t</span> bytes)</span></span><br><span class="line">&#123;</span><br><span class="line">  LIBC_PROBE (memory_arena_retry, <span class="number">2</span>, bytes, ar_ptr);</span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != &amp;main_arena)</span><br><span class="line">    &#123;</span><br><span class="line">      (<span class="type">void</span>) mutex_unlock (&amp;ar_ptr-&gt;mutex);</span><br><span class="line">      <span class="comment">/* Don&#x27;t touch the main arena if it is corrupt.  */</span></span><br><span class="line">      <span class="keyword">if</span> (arena_is_corrupt (&amp;main_arena))</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">      ar_ptr = &amp;main_arena;</span><br><span class="line">      (<span class="type">void</span>) mutex_lock (&amp;ar_ptr-&gt;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      (<span class="type">void</span>) mutex_unlock (&amp;ar_ptr-&gt;mutex);</span><br><span class="line">      ar_ptr = arena_get2 (bytes, ar_ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ar_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释中说明有两种可能的情况：</p>
<ul>
<li>若是我们使用的不是main_arena，则说明mmaped区域（Memory Mapping Segment）已经耗尽了，因此我们尝试回到main_arena上进行内存分配（by (s)brk）</li>
<li>若是我们使用的就是main_arena，则说明(s)brk系统调用失败（堆区可用空间耗尽），但我们仍然有可能在mmaped区域有可用的空间，此时ptmalloc选择尝试其他的arena</li>
</ul>
<p>因此其流程分支如下：</p>
<h5 id="1）原arena不为main-arena，则解锁后获取main-arena"><a href="#1）原arena不为main-arena，则解锁后获取main-arena" class="headerlink" title="1）原arena不为main_arena，则解锁后获取main_arena"></a>1）原arena不为main_arena，则解锁后获取main_arena</h5><p>首先会将原先使用的arena解锁，随后检查main_arena是否被破坏，<strong>若main_arena已被破坏则直接返回NULL，否则锁上main_arena</strong></p>
<h5 id="2）原arena为main-arena，解锁后调用arena-get2-获取其他arena"><a href="#2）原arena为main-arena，解锁后调用arena-get2-获取其他arena" class="headerlink" title="2）原arena为main_arena，解锁后调用arena_get2()获取其他arena"></a>2）原arena为main_arena，解锁后调用arena_get2()获取其他arena</h5><p>若原arena就是main_arena，则此时会尝试调用arena_get2()函数获取一个arena，在这里main_arena被作为avoid_arena参数传入因而不会又重新获取到main_arena</p>
<p>最后将获取到的arena（<strong>可能为NULL</strong>）返回，该函数的流程便结束了</p>
<h4 id="②重新调用-int-malloc-分配内存"><a href="#②重新调用-int-malloc-分配内存" class="headerlink" title="②重新调用_int_malloc()分配内存"></a>②重新调用_int_malloc()分配内存</h4><p>唯一需要注意的一点或许就是<code>_int_malloc()</code>函数返回的内存是mem而不是chunk，因此可以直接返回给用户进行使用</p>
<h3 id="5-检测无误后返回内存块"><a href="#5-检测无误后返回内存块" class="headerlink" title="5.检测无误后返回内存块"></a>5.检测无误后返回内存块</h3><p>大概是会检测如下三个点：</p>
<ul>
<li>所获得的堆块<strong>是否为NULL</strong></li>
<li>该堆块<strong>是否是通过mmap获得的</strong></li>
<li>（若该堆块是通过mmap获得的）该堆块<strong>所属的arena是否为我们此前所使用的arena</strong></li>
</ul>
<p>在最后一步使用了<code>arena_for_chunk()</code>宏，该宏已经在前面解析过了，这里便不再赘叙，简单来说就是<strong>获取一个chunk所属的arena</strong></p>
<p>若是三个都没通过则说明内存分配过程中可能出了问题，则会直接触发assert，随后abort()终止进程，core dump</p>
<p>任一检测通过，则将获取到的堆块返回给上层调用的用户，整个malloc的进程就结束了</p>
<h2 id="libc-hidden-def：函数定义隐藏"><a href="#libc-hidden-def：函数定义隐藏" class="headerlink" title="libc_hidden_def：函数定义隐藏"></a>libc_hidden_def：函数定义隐藏</h2><p>与libc_hidden_proto一样定义于libc-symbols.h下，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> IS_IN (libc)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> libc_hidden_proto(name, attrs...) hidden_proto (name, ##attrs)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> libc_hidden_tls_proto(name, attrs...) hidden_tls_proto (name, ##attrs)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> libc_hidden_def(name) hidden_def (name)</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> libc_hidden_proto(name, attrs...)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> libc_hidden_tls_proto(name, attrs...)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> libc_hidden_def(name)</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>同样是套娃定义，转到hidden_def，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined SHARED &amp;&amp; !defined NO_HIDDEN</span></span><br><span class="line"><span class="meta"># <span class="keyword">ifndef</span> __ASSEMBLER__</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> hidden_def(name)		__hidden_ver1(__GI_##name, name, name);</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line"><span class="comment">/* For assembly, we need to do the opposite of what we do in C:</span></span><br><span class="line"><span class="comment">   in assembly gcc __REDIRECT stuff is not in place, so functions</span></span><br><span class="line"><span class="comment">   are defined by its normal name and we need to create the</span></span><br><span class="line"><span class="comment">   __GI_* alias to it, in C __REDIRECT causes the function definition</span></span><br><span class="line"><span class="comment">   to use __GI_* name and we need to add alias to the real name.</span></span><br><span class="line"><span class="comment">   There is no reason to use hidden_weak over hidden_def in assembly,</span></span><br><span class="line"><span class="comment">   but we provide it for consistency with the C usage.</span></span><br><span class="line"><span class="comment">   hidden_proto doesn&#x27;t make sense for assembly but the equivalent</span></span><br><span class="line"><span class="comment">   is to call via the HIDDEN_JUMPTARGET macro instead of JUMPTARGET.  */</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> hidden_def(name)	strong_alias (name, __GI_##name)</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">ifndef</span> __ASSEMBLER__</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> hidden_proto(name, attrs...)</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> hidden_tls_proto(name, attrs...)</span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> HIDDEN_JUMPTARGET(name) JUMPTARGET(name)</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> <span class="comment">/* Not  __ASSEMBLER__ */</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> hidden_weak(name)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> hidden_def(name)</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>不难想到libc_hidden_def()和此前的libc_hidden_proto是相类似的，只不过该宏隐藏的是函数定义，这里便不再展开说明</p>
<h1 id="0x02-malloc-consolidate"><a href="#0x02-malloc-consolidate" class="headerlink" title="0x02.malloc_consolidate"></a>0x02.malloc_consolidate</h1><p>由于这个函数是ptmalloc中十分重要的一个函数，同时也是各种pwn题中经常用到的一个函数，故我们先来解析其代码</p>
<p>该函数定义于malloc.c中，用以<strong>清空fastbins中chunk、合并相邻空闲chunk</strong>，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  ------------------------- malloc_consolidate -------------------------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  malloc_consolidate is a specialized version of free() that tears</span></span><br><span class="line"><span class="comment">  down chunks held in fastbins.  Free itself cannot be used for this</span></span><br><span class="line"><span class="comment">  purpose since, among other things, it might place chunks back onto</span></span><br><span class="line"><span class="comment">  fastbins.  So, instead, we need to use a minor variant of the same</span></span><br><span class="line"><span class="comment">  code.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Also, because this routine needs to be called the first time through</span></span><br><span class="line"><span class="comment">  malloc anyway, it turns out to be the perfect place to trigger</span></span><br><span class="line"><span class="comment">  initialization code.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">malloc_consolidate</span><span class="params">(mstate av)</span></span><br><span class="line">&#123;</span><br><span class="line">  mfastbinptr*    fb;                 <span class="comment">/* current fastbin being consolidated */</span></span><br><span class="line">  mfastbinptr*    maxfb;              <span class="comment">/* last fastbin (for loop control) */</span></span><br><span class="line">  mchunkptr       p;                  <span class="comment">/* current chunk being consolidated */</span></span><br><span class="line">  mchunkptr       nextp;              <span class="comment">/* next chunk to consolidate */</span></span><br><span class="line">  mchunkptr       unsorted_bin;       <span class="comment">/* bin header */</span></span><br><span class="line">  mchunkptr       first_unsorted;     <span class="comment">/* chunk to link to */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* These have same use as in free() */</span></span><br><span class="line">  mchunkptr       nextchunk;</span><br><span class="line">  INTERNAL_SIZE_T size;</span><br><span class="line">  INTERNAL_SIZE_T nextsize;</span><br><span class="line">  INTERNAL_SIZE_T prevsize;</span><br><span class="line">  <span class="type">int</span>             nextinuse;</span><br><span class="line">  mchunkptr       bck;</span><br><span class="line">  mchunkptr       fwd;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If max_fast is 0, we know that av hasn&#x27;t</span></span><br><span class="line"><span class="comment">    yet been initialized, in which case do so below</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (get_max_fast () != <span class="number">0</span>) &#123;</span><br><span class="line">    clear_fastchunks(av);</span><br><span class="line"></span><br><span class="line">    unsorted_bin = unsorted_chunks(av);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Remove each chunk from fast bin and consolidate it, placing it</span></span><br><span class="line"><span class="comment">      then in unsorted bin. Among other reasons for doing this,</span></span><br><span class="line"><span class="comment">      placing in unsorted bin avoids needing to calculate actual bins</span></span><br><span class="line"><span class="comment">      until malloc is sure that chunks aren&#x27;t immediately going to be</span></span><br><span class="line"><span class="comment">      reused anyway.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    maxfb = &amp;fastbin (av, NFASTBINS - <span class="number">1</span>);</span><br><span class="line">    fb = &amp;fastbin (av, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      p = atomic_exchange_acq (fb, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">	  check_inuse_chunk(av, p);</span><br><span class="line">	  nextp = p-&gt;fd;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* Slightly streamlined version of consolidation code in free() */</span></span><br><span class="line">	  size = p-&gt;size &amp; ~(PREV_INUSE|NON_MAIN_ARENA);</span><br><span class="line">	  nextchunk = chunk_at_offset(p, size);</span><br><span class="line">	  nextsize = chunksize(nextchunk);</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">	    prevsize = p-&gt;prev_size;</span><br><span class="line">	    size += prevsize;</span><br><span class="line">	    p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">	    unlink(av, p, bck, fwd);</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">	    nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">	      size += nextsize;</span><br><span class="line">	      unlink(av, nextchunk, bck, fwd);</span><br><span class="line">	    &#125; <span class="keyword">else</span></span><br><span class="line">	      clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	    first_unsorted = unsorted_bin-&gt;fd;</span><br><span class="line">	    unsorted_bin-&gt;fd = p;</span><br><span class="line">	    first_unsorted-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span> (!in_smallbin_range (size)) &#123;</span><br><span class="line">	      p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">	      p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    set_head(p, size | PREV_INUSE);</span><br><span class="line">	    p-&gt;bk = unsorted_bin;</span><br><span class="line">	    p-&gt;fd = first_unsorted;</span><br><span class="line">	    set_foot(p, size);</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">else</span> &#123;</span><br><span class="line">	    size += nextsize;</span><br><span class="line">	    set_head(p, size | PREV_INUSE);</span><br><span class="line">	    av-&gt;top = p;</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">while</span> ( (p = nextp) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (fb++ != maxfb);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    malloc_init_state(av);</span><br><span class="line">    check_malloc_state(av);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先会先检查<strong>global_max_fast</strong>：</p>
<ul>
<li><strong>若不为0则会设置该arena的FASTCHUNKS_BIT标志位，意味着接下来该函数会清空该arena的fastbin中的chunks</strong></li>
<li><strong>若为0则意味着该线程的arena未进行初始化</strong>，此时便会<strong>调用malloc_init_state</strong>()<strong>函数初始化该arena，</strong>随后使用check_malloc_state()宏进行检查后<strong>该函数便结束了</strong>，在非DEBUG模式下（未定义宏MALLOC_DEBUG）该宏为空</li>
</ul>
<p>接在已经初始化的情况下接下来会<strong>分别获取指向arena中fastbinsY数组首尾元素的指针，用以对fastbinsY数组进行遍历，</strong>这个遍历由两层循环嵌套而成：</p>
<h2 id="外层循环：遍历fastbinsY数组元素"><a href="#外层循环：遍历fastbinsY数组元素" class="headerlink" title="外层循环：遍历fastbinsY数组元素"></a>外层循环：遍历fastbinsY数组元素</h2><p>我们单独将这个循环嵌套拿出来看为如下形式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	p = atomic_exchange_acq (fb, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (p != <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">	  		<span class="comment">// inner loop there</span></span><br><span class="line">		&#125; <span class="keyword">while</span> ( (p = nextp) != <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (fb++ != maxfb);</span><br></pre></td></tr></table></figure>

<p>我们不难看出外层循环的作用便是<strong>逐个取出fastbinsY数组中元素，随后交由内层循环进行下一步的处理</strong></p>
<p>在这里使用了一个宏<code>atomic_exchange_acq()</code>，用途是<strong>通过原子读操作设置新值，返回旧值</strong>，前面已解析过类似宏，这里便不再赘叙</p>
<p>虽然前文我们有讲到fastbinsY数组的下标包括7及往后都是用不到的，但是在这里仍会尝试对齐进行遍历</p>
<h3 id="内层循环：遍历fastbin-链表、合并空闲chunk"><a href="#内层循环：遍历fastbin-链表、合并空闲chunk" class="headerlink" title="内层循环：遍历fastbin 链表、合并空闲chunk"></a>内层循环：遍历fastbin 链表、合并空闲chunk</h3><p>在内层循环中会从我们从外层循环中所取得的fastbins链表的头结点开始进行遍历，并进行空闲chunk的合并以减少内存碎片</p>
<p>若<strong>获取到的头结点为NULL则会直接跳过该层循环</strong>，否则进入下面的步骤</p>
<p>在这里有一个宏<code>check_inuse_chunk()</code>，该宏在非DEBUG模式下（宏MALLOC_DEBUG undefined）也为空</p>
<p>首先会获取该节点chunk的size，在这里<strong>获取到的size清除了PREV_INUSE标志位与NON_MAIN_ARENA标志位</strong>，这是为了在后面的合并过程中能够准确地获取到高地址相邻chunk的位置</p>
<blockquote>
<p>说起来网上很多关于malloc_consolidate()的博客都有讲到所谓「前向合并」和「后向合并」，但是哪边是前哪边是后笔者暂且蒙在古里（注释里笔者也没看到forward&#x2F;backward…</p>
<p>那么下文我们按照对其称呼的惯例做出如下约定：将<strong>向高地址的合并称为「前向合并」，向低地址的合并称为「后向合并」</strong></p>
</blockquote>
<h4 id="①后向合并：使用unlink取出相邻低地址chunk（若已free）"><a href="#①后向合并：使用unlink取出相邻低地址chunk（若已free）" class="headerlink" title="①后向合并：使用unlink取出相邻低地址chunk（若已free）"></a>①后向合并：使用unlink取出相邻低地址chunk（若已free）</h4><p>首先会<strong>检查该chunk的PREV_IN_USE标志位，若不为1则说明低地址相邻chunk必为存放在bins数组中的free chunk</strong>，这是因为<strong>当一个chunk被使用中&#x2F;被放入fastbin中，其相邻高地址的chunk的PREV_INUSE标志位都不会被清除，只有放入bins中才会清除该标志位</strong>，相关机制我们会在后文的_int_free()函数中详细进行分析</p>
<p>这种情况下会<strong>在前面的size变量中加上原chunk的prevsize域的值，将chunk指针移动至指向该空闲chunk，如下图所示</strong></p>
<p><img src="https://i.loli.net/2021/01/23/GqBQHD12NtAESkT.png" alt="image.png"></p>
<p><strong>最后使用unlink宏从bins中取出该chunk</strong>，后向合并的过程就完成了</p>
<p><img src="https://i.loli.net/2021/01/23/pKVSclCIunvofOm.png" alt="image.png"></p>
<p>需要注意的是在这里是<strong>使用原chunk的prevsize域计算该空闲chunk的大小，而并非直接使用低地址空闲chunk的size域</strong></p>
<h4 id="②前向合并：若为top-chunk则合并入top-chunk中，否则会尝试合并后插入unsorted-bin中"><a href="#②前向合并：若为top-chunk则合并入top-chunk中，否则会尝试合并后插入unsorted-bin中" class="headerlink" title="②前向合并：若为top chunk则合并入top chunk中，否则会尝试合并后插入unsorted_bin中"></a>②前向合并：若为top chunk则合并入top chunk中，否则会尝试合并后插入unsorted_bin中</h4><h5 id="1）nextchunk为top-chunk"><a href="#1）nextchunk为top-chunk" class="headerlink" title="1）nextchunk为top chunk"></a>1）nextchunk为top chunk</h5><p>首先会检查nextchunk是否为top chunk，若是则流程会简便得多：<strong>将该chunk的size加上nextchunk的size，设置PREV_INUSE标志位，将arena的top chunk设置为该chunk后便进入下一步</strong></p>
<p><img src="https://i.loli.net/2021/01/23/QF5vhAYbGeqf4C9.png" alt="image.png"></p>
<h5 id="5）nextchunk不为top-chunk"><a href="#5）nextchunk不为top-chunk" class="headerlink" title="5）nextchunk不为top chunk"></a>5）nextchunk不为top chunk</h5><p>若nextchunk不为top chunk，则<strong>首先会检查nextchunk的物理相邻高地址chunk的PREV_INUSE标志位</strong></p>
<ul>
<li><strong>若不为0则会清除nextchunk的PREV_INSUE位</strong></li>
</ul>
<p><img src="https://i.loli.net/2021/01/23/YVaFRKonG4WBuXM.png" alt="image.png"></p>
<ul>
<li><strong>若为0则使用unlink将nextchunk从bins中取出</strong></li>
</ul>
<p><img src="https://i.loli.net/2021/01/23/LEBAKhTbSMlCcVr.png" alt="image.png"></p>
<p>接下来会<strong>将该chunk放入unsorted bin中，需要注意的是在这里使用的是头插法使其成为unsorted bin的头结点</strong></p>
<p><img src="https://i.loli.net/2021/01/23/BNJIPrGL9eTvX8U.png" alt="image.png"></p>
<p>接下来会检查chunk最终的大小，<strong>若是size不处于smallbins范围内则会设置其fd_nextsize与bk_nextsize为NULL</strong></p>
<p>最后，<strong>设置该chunk的PREV_INUSE位为1</strong>，设置<strong>当前情况下的物理相邻chunk的prevsize域为该chunk的size</strong></p>
<p><img src="https://i.loli.net/2021/01/23/5b7qYPjO1AmXkyF.png" alt="image.png"></p>
<h4 id="③检查链表中的下一个chunk，不为NULL则继续新一轮循环"><a href="#③检查链表中的下一个chunk，不为NULL则继续新一轮循环" class="headerlink" title="③检查链表中的下一个chunk，不为NULL则继续新一轮循环"></a>③检查链表中的下一个chunk，不为NULL则继续新一轮循环</h4><p>虽然chunk指针可能在合并中被修改，但是我们在前面已经保存了其fd，若不为NULL则进行下一轮循环，故可以继续遍历链表的进程</p>
<h1 id="0x03-int-malloc"><a href="#0x03-int-malloc" class="headerlink" title="0x03._int_malloc"></a>0x03._int_malloc</h1><p>该函数为<strong>ptmalloc内存分配机制的核心函数</strong>，定义于malloc.c中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   ------------------------------ malloc ------------------------------</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line">_int_malloc (mstate av, <span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  INTERNAL_SIZE_T nb;               <span class="comment">/* normalized request size */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> idx;                 <span class="comment">/* associated bin index */</span></span><br><span class="line">  mbinptr bin;                      <span class="comment">/* associated bin */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr victim;                 <span class="comment">/* inspected/selected chunk */</span></span><br><span class="line">  INTERNAL_SIZE_T size;             <span class="comment">/* its size */</span></span><br><span class="line">  <span class="type">int</span> victim_index;                 <span class="comment">/* its bin index */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr remainder;              <span class="comment">/* remainder from a split */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> remainder_size;     <span class="comment">/* its size */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> block;               <span class="comment">/* bit map traverser */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> bit;                 <span class="comment">/* bit map traverser */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">map</span>;                 <span class="comment">/* current word of binmap */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr fwd;                    <span class="comment">/* misc temp for linking */</span></span><br><span class="line">  mchunkptr bck;                    <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *errstr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     Convert request size to internal form by adding SIZE_SZ bytes</span></span><br><span class="line"><span class="comment">     overhead plus possibly more to obtain necessary alignment and/or</span></span><br><span class="line"><span class="comment">     to obtain a size of at least MINSIZE, the smallest allocatable</span></span><br><span class="line"><span class="comment">     size. Also, checked_request2size traps (returning 0) request sizes</span></span><br><span class="line"><span class="comment">     that are so large that they wrap around zero when padded and</span></span><br><span class="line"><span class="comment">     aligned.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  checked_request2size (bytes, nb);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* There are no usable arenas.  Fall back to sysmalloc to get a chunk from</span></span><br><span class="line"><span class="comment">     mmap.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (av == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">	alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If the size qualifies as a fastbin, first check corresponding bin.</span></span><br><span class="line"><span class="comment">     This code is safe to execute even if av is not yet initialized, so we</span></span><br><span class="line"><span class="comment">     can try it without checking, which saves some time on this fast path.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (nb) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>) (get_max_fast ()))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = fastbin_index (nb);</span><br><span class="line">      mfastbinptr *fb = &amp;fastbin (av, idx);</span><br><span class="line">      mchunkptr pp = *fb;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">          victim = pp;</span><br><span class="line">          <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim))</span><br><span class="line">             != victim);</span><br><span class="line">      <span class="keyword">if</span> (victim != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">              errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">            errout:</span><br><span class="line">              malloc_printerr (check_action, errstr, chunk2mem (victim), av);</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          check_remalloced_chunk (av, victim, nb);</span><br><span class="line">          <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If a small request, check regular bin.  Since these &quot;smallbins&quot;</span></span><br><span class="line"><span class="comment">     hold one size each, no searching within bins is necessary.</span></span><br><span class="line"><span class="comment">     (For a large request, we need to wait until unsorted chunks are</span></span><br><span class="line"><span class="comment">     processed to find best fit. But for small ones, fits are exact</span></span><br><span class="line"><span class="comment">     anyway, so we can check now, which is faster.)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = smallbin_index (nb);</span><br><span class="line">      bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">            malloc_consolidate (av);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              bck = victim-&gt;bk;</span><br><span class="line">	<span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">                &#123;</span><br><span class="line">                  errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">                  <span class="keyword">goto</span> errout;</span><br><span class="line">                &#125;</span><br><span class="line">              set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">              bin-&gt;bk = bck;</span><br><span class="line">              bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If this is a large request, consolidate fastbins before continuing.</span></span><br><span class="line"><span class="comment">     While it might look excessive to kill all fastbins before</span></span><br><span class="line"><span class="comment">     even seeing if there is space available, this avoids</span></span><br><span class="line"><span class="comment">     fragmentation problems normally associated with fastbins.</span></span><br><span class="line"><span class="comment">     Also, in practice, programs tend to have runs of either small or</span></span><br><span class="line"><span class="comment">     large requests, but less often mixtures, so consolidation is not</span></span><br><span class="line"><span class="comment">     invoked all that often in most programs. And the programs that</span></span><br><span class="line"><span class="comment">     it is called frequently in otherwise tend to fragment.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      idx = largebin_index (nb);</span><br><span class="line">      <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">        malloc_consolidate (av);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     Process recently freed or remaindered chunks, taking one only if</span></span><br><span class="line"><span class="comment">     it is exact fit, or, if this a small request, the chunk is remainder from</span></span><br><span class="line"><span class="comment">     the most recent non-exact fit.  Place other traversed chunks in</span></span><br><span class="line"><span class="comment">     bins.  Note that this step is the only place in any routine where</span></span><br><span class="line"><span class="comment">     chunks are placed in bins.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     The outer loop here is needed because we might not realize until</span></span><br><span class="line"><span class="comment">     near the end of malloc that we should have consolidated, so must</span></span><br><span class="line"><span class="comment">     do so and retry. This happens at most once, and only when we would</span></span><br><span class="line"><span class="comment">     otherwise need to expand memory to service a &quot;small&quot; request.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;; )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> iters = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">              || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">            malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                             chunk2mem (victim), av);</span><br><span class="line">          size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">             If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">             only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">             runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">             exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">             no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;</span><br><span class="line">              bck == unsorted_chunks (av) &amp;&amp;</span><br><span class="line">              victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">              (<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line">              remainder = chunk_at_offset (victim, nb);</span><br><span class="line">              unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;</span><br><span class="line">              av-&gt;last_remainder = remainder;</span><br><span class="line">              remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);</span><br><span class="line">              <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                &#123;</span><br><span class="line">                  remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                  remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                        (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">              set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">              set_foot (remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* remove from unsorted list */</span></span><br><span class="line">          unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">          bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (size == nb)</span><br><span class="line">            &#123;</span><br><span class="line">              set_inuse_bit_at_offset (victim, size);</span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* place chunk in bin */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (size))</span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = smallbin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = largebin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">              <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">                  size |= PREV_INUSE;</span><br><span class="line">                  <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">                  assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) (bck-&gt;bk-&gt;size))</span><br><span class="line">                    &#123;</span><br><span class="line">                      fwd = bck;</span><br><span class="line">                      bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">                      victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                      <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; fwd-&gt;size)</span><br><span class="line">                        &#123;</span><br><span class="line">                          fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">                          assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                      <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size == (<span class="type">unsigned</span> <span class="type">long</span>) fwd-&gt;size)</span><br><span class="line">                        <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                        fwd = fwd-&gt;fd;</span><br><span class="line">                      <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                          victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                          fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                        &#125;</span><br><span class="line">                      bck = fwd-&gt;bk;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          mark_bin (av, victim_index);</span><br><span class="line">          victim-&gt;bk = bck;</span><br><span class="line">          victim-&gt;fd = fwd;</span><br><span class="line">          fwd-&gt;bk = victim;</span><br><span class="line">          bck-&gt;fd = victim;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ITERS       10000</span></span><br><span class="line">          <span class="keyword">if</span> (++iters &gt;= MAX_ITERS)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         If a large request, scan through the chunks of current bin in</span></span><br><span class="line"><span class="comment">         sorted order to find smallest that fits.  Use the skip list for this.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range (nb))</span><br><span class="line">        &#123;</span><br><span class="line">          bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">          <span class="keyword">if</span> ((victim = first (bin)) != bin &amp;&amp;</span><br><span class="line">              (<span class="type">unsigned</span> <span class="type">long</span>) (victim-&gt;size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb))</span><br><span class="line">            &#123;</span><br><span class="line">              victim = victim-&gt;bk_nextsize;</span><br><span class="line">              <span class="keyword">while</span> (((<span class="type">unsigned</span> <span class="type">long</span>) (size = chunksize (victim)) &lt;</span><br><span class="line">                      (<span class="type">unsigned</span> <span class="type">long</span>) (nb)))</span><br><span class="line">                victim = victim-&gt;bk_nextsize;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">                 list does not have to be rerouted.  */</span></span><br><span class="line">              <span class="keyword">if</span> (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)</span><br><span class="line">                victim = victim-&gt;fd;</span><br><span class="line"></span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line">              unlink (av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Exhaust */</span></span><br><span class="line">              <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">                &#123;</span><br><span class="line">                  set_inuse_bit_at_offset (victim, size);</span><br><span class="line">                  <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                    victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">/* Split */</span></span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                  remainder = chunk_at_offset (victim, nb);</span><br><span class="line">                  <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                     have to perform a complete insert here.  */</span></span><br><span class="line">                  bck = unsorted_chunks (av);</span><br><span class="line">                  fwd = bck-&gt;fd;</span><br><span class="line">	  <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">                    &#123;</span><br><span class="line">                      errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">                      <span class="keyword">goto</span> errout;</span><br><span class="line">                    &#125;</span><br><span class="line">                  remainder-&gt;bk = bck;</span><br><span class="line">                  remainder-&gt;fd = fwd;</span><br><span class="line">                  bck-&gt;fd = remainder;</span><br><span class="line">                  fwd-&gt;bk = remainder;</span><br><span class="line">                  <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                    &#123;</span><br><span class="line">                      remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                      remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                  set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">                  set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">                  set_foot (remainder, remainder_size);</span><br><span class="line">                &#125;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         Search for a chunk by scanning bins, starting with next largest</span></span><br><span class="line"><span class="comment">         bin. This search is strictly by best-fit; i.e., the smallest</span></span><br><span class="line"><span class="comment">         (with ties going to approximately the least recently used) chunk</span></span><br><span class="line"><span class="comment">         that fits is selected.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         The bitmap avoids needing to check that most blocks are nonempty.</span></span><br><span class="line"><span class="comment">         The particular case of skipping all bins during warm-up phases</span></span><br><span class="line"><span class="comment">         when no chunks have been returned yet is faster than it might look.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      ++idx;</span><br><span class="line">      bin = bin_at (av, idx);</span><br><span class="line">      block = idx2block (idx);</span><br><span class="line">      <span class="built_in">map</span> = av-&gt;binmap[block];</span><br><span class="line">      bit = idx2bit (idx);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (;; )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/* Skip rest of block if there are no more set bits in this block.  */</span></span><br><span class="line">          <span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="keyword">do</span></span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="comment">/* out of bins */</span></span><br><span class="line">                    <span class="keyword">goto</span> use_top;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">while</span> ((<span class="built_in">map</span> = av-&gt;binmap[block]) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">              bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">              bit = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Advance to bin with set bit. There must be one. */</span></span><br><span class="line">          <span class="keyword">while</span> ((bit &amp; <span class="built_in">map</span>) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">              bin = next_bin (bin);</span><br><span class="line">              bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">              assert (bit != <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Inspect the bin. It is likely to be non-empty */</span></span><br><span class="line">          victim = last (bin);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*  If a false alarm (empty bin), clear the bit. */</span></span><br><span class="line">          <span class="keyword">if</span> (victim == bin)</span><br><span class="line">            &#123;</span><br><span class="line">              av-&gt;binmap[block] = <span class="built_in">map</span> &amp;= ~bit; <span class="comment">/* Write through */</span></span><br><span class="line">              bin = next_bin (bin);</span><br><span class="line">              bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">              <span class="comment">/*  We know the first chunk in this bin is big enough to use. */</span></span><br><span class="line">              assert ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb));</span><br><span class="line"></span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* unlink */</span></span><br><span class="line">              unlink (av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Exhaust */</span></span><br><span class="line">              <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">                &#123;</span><br><span class="line">                  set_inuse_bit_at_offset (victim, size);</span><br><span class="line">                  <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                    victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Split */</span></span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                  remainder = chunk_at_offset (victim, nb);</span><br><span class="line"></span><br><span class="line">                  <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                     have to perform a complete insert here.  */</span></span><br><span class="line">                  bck = unsorted_chunks (av);</span><br><span class="line">                  fwd = bck-&gt;fd;</span><br><span class="line">	  <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">                    &#123;</span><br><span class="line">                      errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>;</span><br><span class="line">                      <span class="keyword">goto</span> errout;</span><br><span class="line">                    &#125;</span><br><span class="line">                  remainder-&gt;bk = bck;</span><br><span class="line">                  remainder-&gt;fd = fwd;</span><br><span class="line">                  bck-&gt;fd = remainder;</span><br><span class="line">                  fwd-&gt;bk = remainder;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">/* advertise as last remainder */</span></span><br><span class="line">                  <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">                    av-&gt;last_remainder = remainder;</span><br><span class="line">                  <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                    &#123;</span><br><span class="line">                      remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                      remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                  set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">                  set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">                  set_foot (remainder, remainder_size);</span><br><span class="line">                &#125;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    use_top:</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         If large enough, split off the chunk bordering the end of memory</span></span><br><span class="line"><span class="comment">         (held in av-&gt;top). Note that this is in accord with the best-fit</span></span><br><span class="line"><span class="comment">         search rule.  In effect, av-&gt;top is treated as larger (and thus</span></span><br><span class="line"><span class="comment">         less well fitting) than any other available chunk since it can</span></span><br><span class="line"><span class="comment">         be extended to be as large as necessary (up to system</span></span><br><span class="line"><span class="comment">         limitations).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         We require that av-&gt;top always exists (i.e., has size &gt;=</span></span><br><span class="line"><span class="comment">         MINSIZE) after initialization, so if it would otherwise be</span></span><br><span class="line"><span class="comment">         exhausted by current request, it is replenished. (The main</span></span><br><span class="line"><span class="comment">         reason for ensuring it exists is that we may need MINSIZE space</span></span><br><span class="line"><span class="comment">         to put in fenceposts in sysmalloc.)</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      victim = av-&gt;top;</span><br><span class="line">      size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">        &#123;</span><br><span class="line">          remainder_size = size - nb;</span><br><span class="line">          remainder = chunk_at_offset (victim, nb);</span><br><span class="line">          av-&gt;top = remainder;</span><br><span class="line">          set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                    (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">          set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line">          <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">         here for all block sizes.  */</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">        &#123;</span><br><span class="line">          malloc_consolidate (av);</span><br><span class="line">          <span class="comment">/* restore original bin index */</span></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">            idx = smallbin_index (nb);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            idx = largebin_index (nb);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="type">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">          <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">            alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在函数一开始会创建一些后续分配机制所需使用的变量，具体用途见注释，这里便不再赘叙</p>
<h2 id="一、将请求大小转换为标准大小"><a href="#一、将请求大小转换为标准大小" class="headerlink" title="一、将请求大小转换为标准大小"></a>一、将请求大小转换为标准大小</h2><p>在_int_malloc()函数一开始时会将用户所请求的大小转换为对应的与<code>MALLOC_ALIGNMENT</code>对齐的大小，在这里使用了一个宏<code>checked_request2size()</code>，其会使用<code>request2size()</code>宏进行计算，chunk size的计算规则大致如下图所示（该宏会将请求的size先加上chunk header的大小）：</p>
<p><img src="https://i.loli.net/2020/12/19/HZfcpy4wkJGg9V3.png" alt="image.png"></p>
<blockquote>
<p>详见0x00.二.1</p>
</blockquote>
<h2 id="二、检查arena是否可用"><a href="#二、检查arena是否可用" class="headerlink" title="二、检查arena是否可用"></a>二、检查arena是否可用</h2><p>上文我们讲到，<strong>获取可用arena</strong>这一步骤是在<code>__libc_malloc()</code>函数中完成的，<code>_int_malloc()</code>函数所需要做的仅仅是使用上层调用函数传入的arena，<strong>但是在__libc_malloc</strong>()<strong>函数中我们有可能无法得到一个可用的arena</strong>（详见0x02.2 &amp; 0x02.4）</p>
<p>因而在这里会首先检查传入的arena，<strong>若为NULL则说明现有arena已经无法满足用户内存请求，此时会直接调用sysmalloc</strong>()<strong>函数通过mmap系统调用分配内存，并将所得的结果直接返回上层调用</strong></p>
<p>若sysmalloc返回结果不为NULL，则会调用<code>alloc_perturb()</code>函数对我们所获得的内存块进行预处理，该函数定义于malloc.c中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ------------------ Testing support ----------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> perturb_byte;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">alloc_perturb</span> <span class="params">(<span class="type">char</span> *p, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (perturb_byte))</span><br><span class="line">    <span class="built_in">memset</span> (p, perturb_byte ^ <span class="number">0xff</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若是静态全局变量<code>perturb_byte</code>为0，则会将该内存块中用户请求大小的部分全部设为<code>0xff</code></p>
<blockquote>
<p>这里用了一个不知所谓的异或操作，笔者暂且蒙在古里…</p>
</blockquote>
<h2 id="三、fastbin范围size请求相关操作"><a href="#三、fastbin范围size请求相关操作" class="headerlink" title="三、fastbin范围size请求相关操作"></a>三、fastbin范围size请求相关操作</h2><p>若所需chunk的size在fastbin的范围内（32位&lt;&#x3D;0x40，64位&lt;&#x3D;0x80，详见0x00.四），则会进行如下操作：</p>
<h3 id="1-尝试从fastbin对应下标取出chunk"><a href="#1-尝试从fastbin对应下标取出chunk" class="headerlink" title="1.尝试从fastbin对应下标取出chunk"></a>1.尝试从fastbin对应下标取出chunk</h3><h3 id="2-（若成功获得chunk）进行chunk-size安全检查"><a href="#2-（若成功获得chunk）进行chunk-size安全检查" class="headerlink" title="2.（若成功获得chunk）进行chunk size安全检查"></a>2.（若成功获得chunk）进行chunk size安全检查</h3><h1 id="0x04-sysmalloc："><a href="#0x04-sysmalloc：" class="headerlink" title="0x04.sysmalloc："></a>0x04.sysmalloc：</h1><p>定义于malloc.c中，用以<strong>真正调用系统调用的接口进行内存分配</strong>，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ----------- Routines dealing with system allocation -------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   sysmalloc handles malloc cases requiring more memory from the system.</span></span><br><span class="line"><span class="comment">   On entry, it is assumed that av-&gt;top does not have enough</span></span><br><span class="line"><span class="comment">   space to service request for nb bytes, thus requiring that av-&gt;top</span></span><br><span class="line"><span class="comment">   be extended or replaced.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">sysmalloc</span> <span class="params">(INTERNAL_SIZE_T nb, mstate av)</span></span><br><span class="line">&#123;</span><br><span class="line">  mchunkptr old_top;              <span class="comment">/* incoming value of av-&gt;top */</span></span><br><span class="line">  INTERNAL_SIZE_T old_size;       <span class="comment">/* its size */</span></span><br><span class="line">  <span class="type">char</span> *old_end;                  <span class="comment">/* its end address */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">long</span> size;                      <span class="comment">/* arg to first MORECORE or mmap call */</span></span><br><span class="line">  <span class="type">char</span> *brk;                      <span class="comment">/* return value from MORECORE */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">long</span> correction;                <span class="comment">/* arg to 2nd MORECORE call */</span></span><br><span class="line">  <span class="type">char</span> *snd_brk;                  <span class="comment">/* 2nd return val */</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T front_misalign; <span class="comment">/* unusable bytes at front of new space */</span></span><br><span class="line">  INTERNAL_SIZE_T end_misalign;   <span class="comment">/* partial page left at end of new space */</span></span><br><span class="line">  <span class="type">char</span> *aligned_brk;              <span class="comment">/* aligned offset into brk */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr p;                    <span class="comment">/* the allocated/returned chunk */</span></span><br><span class="line">  mchunkptr remainder;            <span class="comment">/* remainder from allocation */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> remainder_size;   <span class="comment">/* its size */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> pagesize = GLRO (dl_pagesize);</span><br><span class="line">  <span class="type">bool</span> tried_mmap = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If have mmap, and the request size meets the mmap threshold, and</span></span><br><span class="line"><span class="comment">     the system supports mmap, and there are few enough currently</span></span><br><span class="line"><span class="comment">     allocated mmapped regions, try to directly map this request</span></span><br><span class="line"><span class="comment">     rather than expanding top.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (av == <span class="literal">NULL</span></span><br><span class="line">      || ((<span class="type">unsigned</span> <span class="type">long</span>) (nb) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (mp_.mmap_threshold)</span><br><span class="line">	  &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max)))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">char</span> *mm;           <span class="comment">/* return value from mmap call*/</span></span><br><span class="line"></span><br><span class="line">    try_mmap:</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         Round up size to nearest page.  For mmapped chunks, the overhead</span></span><br><span class="line"><span class="comment">         is one SIZE_SZ unit larger than for normal chunks, because there</span></span><br><span class="line"><span class="comment">         is no following chunk whose prev_size field could be used.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         See the front_misalign handling below, for glibc there is no</span></span><br><span class="line"><span class="comment">         need for further alignments unless we have have high alignment.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (MALLOC_ALIGNMENT == <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">        size = ALIGN_UP (nb + SIZE_SZ, pagesize);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        size = ALIGN_UP (nb + SIZE_SZ + MALLOC_ALIGN_MASK, pagesize);</span><br><span class="line">      tried_mmap = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Don&#x27;t try if size wraps around 0 */</span></span><br><span class="line">      <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>) (nb))</span><br><span class="line">        &#123;</span><br><span class="line">          mm = (<span class="type">char</span> *) (MMAP (<span class="number">0</span>, size, PROT_READ | PROT_WRITE, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (mm != MAP_FAILED)</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 The offset to the start of the mmapped region is stored</span></span><br><span class="line"><span class="comment">                 in the prev_size field of the chunk. This allows us to adjust</span></span><br><span class="line"><span class="comment">                 returned start address to meet alignment requirements here</span></span><br><span class="line"><span class="comment">                 and in memalign(), and still be able to compute proper</span></span><br><span class="line"><span class="comment">                 address argument for later munmap in free() and realloc().</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (MALLOC_ALIGNMENT == <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="comment">/* For glibc, chunk2mem increases the address by 2*SIZE_SZ and</span></span><br><span class="line"><span class="comment">                     MALLOC_ALIGN_MASK is 2*SIZE_SZ-1.  Each mmap&#x27;ed area is page</span></span><br><span class="line"><span class="comment">                     aligned and therefore definitely MALLOC_ALIGN_MASK-aligned.  */</span></span><br><span class="line">                  assert (((INTERNAL_SIZE_T) chunk2mem (mm) &amp; MALLOC_ALIGN_MASK) == <span class="number">0</span>);</span><br><span class="line">                  front_misalign = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                front_misalign = (INTERNAL_SIZE_T) chunk2mem (mm) &amp; MALLOC_ALIGN_MASK;</span><br><span class="line">              <span class="keyword">if</span> (front_misalign &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                  correction = MALLOC_ALIGNMENT - front_misalign;</span><br><span class="line">                  p = (mchunkptr) (mm + correction);</span><br><span class="line">                  p-&gt;prev_size = correction;</span><br><span class="line">                  set_head (p, (size - correction) | IS_MMAPPED);</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                  p = (mchunkptr) mm;</span><br><span class="line">                  set_head (p, size | IS_MMAPPED);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* update statistics */</span></span><br><span class="line"></span><br><span class="line">              <span class="type">int</span> new = atomic_exchange_and_add (&amp;mp_.n_mmaps, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">              <span class="type">atomic_max</span> (&amp;mp_.max_n_mmaps, new);</span><br><span class="line"></span><br><span class="line">              <span class="type">unsigned</span> <span class="type">long</span> sum;</span><br><span class="line">              sum = atomic_exchange_and_add (&amp;mp_.mmapped_mem, size) + size;</span><br><span class="line">              <span class="type">atomic_max</span> (&amp;mp_.max_mmapped_mem, sum);</span><br><span class="line"></span><br><span class="line">              check_chunk (av, p);</span><br><span class="line"></span><br><span class="line">              <span class="keyword">return</span> chunk2mem (p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* There are no usable arenas and mmap also failed.  */</span></span><br><span class="line">  <span class="keyword">if</span> (av == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Record incoming configuration of top */</span></span><br><span class="line"></span><br><span class="line">  old_top = av-&gt;top;</span><br><span class="line">  old_size = chunksize (old_top);</span><br><span class="line">  old_end = (<span class="type">char</span> *) (chunk_at_offset (old_top, old_size));</span><br><span class="line"></span><br><span class="line">  brk = snd_brk = (<span class="type">char</span> *) (MORECORE_FAILURE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If not the first time through, we require old_size to be</span></span><br><span class="line"><span class="comment">     at least MINSIZE and to have prev_inuse set.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  assert ((old_top == initial_top (av) &amp;&amp; old_size == <span class="number">0</span>) ||</span><br><span class="line">          ((<span class="type">unsigned</span> <span class="type">long</span>) (old_size) &gt;= MINSIZE &amp;&amp;</span><br><span class="line">           prev_inuse (old_top) &amp;&amp;</span><br><span class="line">           ((<span class="type">unsigned</span> <span class="type">long</span>) old_end &amp; (pagesize - <span class="number">1</span>)) == <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Precondition: not enough current space to satisfy nb request */</span></span><br><span class="line">  assert ((<span class="type">unsigned</span> <span class="type">long</span>) (old_size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">    &#123;</span><br><span class="line">      heap_info *old_heap, *heap;</span><br><span class="line">      <span class="type">size_t</span> old_heap_size;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* First try to extend the current heap. */</span></span><br><span class="line">      old_heap = heap_for_ptr (old_top);</span><br><span class="line">      old_heap_size = old_heap-&gt;size;</span><br><span class="line">      <span class="keyword">if</span> ((<span class="type">long</span>) (MINSIZE + nb - old_size) &gt; <span class="number">0</span></span><br><span class="line">          &amp;&amp; grow_heap (old_heap, MINSIZE + nb - old_size) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          av-&gt;system_mem += old_heap-&gt;size - old_heap_size;</span><br><span class="line">          arena_mem += old_heap-&gt;size - old_heap_size;</span><br><span class="line">          set_head (old_top, (((<span class="type">char</span> *) old_heap + old_heap-&gt;size) - (<span class="type">char</span> *) old_top)</span><br><span class="line">                    | PREV_INUSE);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ((heap = new_heap (nb + (MINSIZE + <span class="keyword">sizeof</span> (*heap)), mp_.top_pad)))</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/* Use a newly allocated heap.  */</span></span><br><span class="line">          heap-&gt;ar_ptr = av;</span><br><span class="line">          heap-&gt;prev = old_heap;</span><br><span class="line">          av-&gt;system_mem += heap-&gt;size;</span><br><span class="line">          arena_mem += heap-&gt;size;</span><br><span class="line">          <span class="comment">/* Set up the new top.  */</span></span><br><span class="line">          top (av) = chunk_at_offset (heap, <span class="keyword">sizeof</span> (*heap));</span><br><span class="line">          set_head (top (av), (heap-&gt;size - <span class="keyword">sizeof</span> (*heap)) | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Setup fencepost and free the old top chunk with a multiple of</span></span><br><span class="line"><span class="comment">             MALLOC_ALIGNMENT in size. */</span></span><br><span class="line">          <span class="comment">/* The fencepost takes at least MINSIZE bytes, because it might</span></span><br><span class="line"><span class="comment">             become the top chunk again later.  Note that a footer is set</span></span><br><span class="line"><span class="comment">             up, too, although the chunk is marked in use. */</span></span><br><span class="line">          old_size = (old_size - MINSIZE) &amp; ~MALLOC_ALIGN_MASK;</span><br><span class="line">          set_head (chunk_at_offset (old_top, old_size + <span class="number">2</span> * SIZE_SZ), <span class="number">0</span> | PREV_INUSE);</span><br><span class="line">          <span class="keyword">if</span> (old_size &gt;= MINSIZE)</span><br><span class="line">            &#123;</span><br><span class="line">              set_head (chunk_at_offset (old_top, old_size), (<span class="number">2</span> * SIZE_SZ) | PREV_INUSE);</span><br><span class="line">              set_foot (chunk_at_offset (old_top, old_size), (<span class="number">2</span> * SIZE_SZ));</span><br><span class="line">              set_head (old_top, old_size | PREV_INUSE | NON_MAIN_ARENA);</span><br><span class="line">              _int_free (av, old_top, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              set_head (old_top, (old_size + <span class="number">2</span> * SIZE_SZ) | PREV_INUSE);</span><br><span class="line">              set_foot (old_top, (old_size + <span class="number">2</span> * SIZE_SZ));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (!tried_mmap)</span><br><span class="line">        <span class="comment">/* We can at least try to use to mmap memory.  */</span></span><br><span class="line">        <span class="keyword">goto</span> try_mmap;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span>     <span class="comment">/* av == main_arena */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">/* Request enough space for nb + pad + overhead */</span></span><br><span class="line">      size = nb + mp_.top_pad + MINSIZE;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         If contiguous, we can subtract out existing space that we hope to</span></span><br><span class="line"><span class="comment">         combine with new space. We add it back later only if</span></span><br><span class="line"><span class="comment">         we don&#x27;t actually get contiguous space.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (contiguous (av))</span><br><span class="line">        size -= old_size;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         Round to a multiple of page size.</span></span><br><span class="line"><span class="comment">         If MORECORE is not contiguous, this ensures that we only call it</span></span><br><span class="line"><span class="comment">         with whole-page arguments.  And if MORECORE is contiguous and</span></span><br><span class="line"><span class="comment">         this is not first time through, this preserves page-alignment of</span></span><br><span class="line"><span class="comment">         previous calls. Otherwise, we correct to page-align below.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      size = ALIGN_UP (size, pagesize);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         Don&#x27;t try to call MORECORE if argument is so big as to appear</span></span><br><span class="line"><span class="comment">         negative. Note that since mmap takes size_t arg, it may succeed</span></span><br><span class="line"><span class="comment">         below even if we cannot call MORECORE.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (size &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          brk = (<span class="type">char</span> *) (MORECORE (size));</span><br><span class="line">          LIBC_PROBE (memory_sbrk_more, <span class="number">2</span>, brk, size);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (brk != (<span class="type">char</span> *) (MORECORE_FAILURE))</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/* Call the `morecore&#x27; hook if necessary.  */</span></span><br><span class="line">          <span class="type">void</span> (*hook) (<span class="type">void</span>) = atomic_forced_read (__after_morecore_hook);</span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">            (*hook)();</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">             If have mmap, try using it as a backup when MORECORE fails or</span></span><br><span class="line"><span class="comment">             cannot be used. This is worth doing on systems that have &quot;holes&quot; in</span></span><br><span class="line"><span class="comment">             address space, so sbrk cannot extend to give contiguous space, but</span></span><br><span class="line"><span class="comment">             space is available elsewhere.  Note that we ignore mmap max count</span></span><br><span class="line"><span class="comment">             and threshold limits, since the space will not be used as a</span></span><br><span class="line"><span class="comment">             segregated mmap region.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Cannot merge with old top, so add its size back in */</span></span><br><span class="line">          <span class="keyword">if</span> (contiguous (av))</span><br><span class="line">            size = ALIGN_UP (size + old_size, pagesize);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* If we are relying on mmap as backup, then use larger units */</span></span><br><span class="line">          <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) (MMAP_AS_MORECORE_SIZE))</span><br><span class="line">            size = MMAP_AS_MORECORE_SIZE;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Don&#x27;t try if size wraps around 0 */</span></span><br><span class="line">          <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>) (nb))</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="type">char</span> *mbrk = (<span class="type">char</span> *) (MMAP (<span class="number">0</span>, size, PROT_READ | PROT_WRITE, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (mbrk != MAP_FAILED)</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="comment">/* We do not need, and cannot use, another sbrk call to find end */</span></span><br><span class="line">                  brk = mbrk;</span><br><span class="line">                  snd_brk = brk + size;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     Record that we no longer have a contiguous sbrk region.</span></span><br><span class="line"><span class="comment">                     After the first time mmap is used as backup, we do not</span></span><br><span class="line"><span class="comment">                     ever rely on contiguous space since this could incorrectly</span></span><br><span class="line"><span class="comment">                     bridge regions.</span></span><br><span class="line"><span class="comment">                   */</span></span><br><span class="line">                  set_noncontiguous (av);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (brk != (<span class="type">char</span> *) (MORECORE_FAILURE))</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (mp_.sbrk_base == <span class="number">0</span>)</span><br><span class="line">            mp_.sbrk_base = brk;</span><br><span class="line">          av-&gt;system_mem += size;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">             If MORECORE extends previous space, we can likewise extend top size.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (brk == old_end &amp;&amp; snd_brk == (<span class="type">char</span> *) (MORECORE_FAILURE))</span><br><span class="line">            set_head (old_top, (size + old_size) | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (contiguous (av) &amp;&amp; old_size &amp;&amp; brk &lt; old_end)</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">/* Oops!  Someone else killed our space..  Can&#x27;t touch anything.  */</span></span><br><span class="line">              malloc_printerr (<span class="number">3</span>, <span class="string">&quot;break adjusted to free malloc space&quot;</span>, brk,</span><br><span class="line">			       av);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">             Otherwise, make adjustments:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           * If the first time through or noncontiguous, we need to call sbrk</span></span><br><span class="line"><span class="comment">              just to find out where the end of memory lies.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           * We need to ensure that all returned chunks from malloc will meet</span></span><br><span class="line"><span class="comment">              MALLOC_ALIGNMENT</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           * If there was an intervening foreign sbrk, we need to adjust sbrk</span></span><br><span class="line"><span class="comment">              request size to account for fact that we will not be able to</span></span><br><span class="line"><span class="comment">              combine new space with existing space in old_top.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           * Almost all systems internally allocate whole pages at a time, in</span></span><br><span class="line"><span class="comment">              which case we might as well use the whole last page of request.</span></span><br><span class="line"><span class="comment">              So we allocate enough more memory to hit a page boundary now,</span></span><br><span class="line"><span class="comment">              which in turn causes future contiguous calls to page-align.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              front_misalign = <span class="number">0</span>;</span><br><span class="line">              end_misalign = <span class="number">0</span>;</span><br><span class="line">              correction = <span class="number">0</span>;</span><br><span class="line">              aligned_brk = brk;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* handle contiguous cases */</span></span><br><span class="line">              <span class="keyword">if</span> (contiguous (av))</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="comment">/* Count foreign sbrk as system_mem.  */</span></span><br><span class="line">                  <span class="keyword">if</span> (old_size)</span><br><span class="line">                    av-&gt;system_mem += brk - old_end;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">/* Guarantee alignment of first new chunk made from this space */</span></span><br><span class="line"></span><br><span class="line">                  front_misalign = (INTERNAL_SIZE_T) chunk2mem (brk) &amp; MALLOC_ALIGN_MASK;</span><br><span class="line">                  <span class="keyword">if</span> (front_misalign &gt; <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                      <span class="comment">/*</span></span><br><span class="line"><span class="comment">                         Skip over some bytes to arrive at an aligned position.</span></span><br><span class="line"><span class="comment">                         We don&#x27;t need to specially mark these wasted front bytes.</span></span><br><span class="line"><span class="comment">                         They will never be accessed anyway because</span></span><br><span class="line"><span class="comment">                         prev_inuse of av-&gt;top (and any chunk created from its start)</span></span><br><span class="line"><span class="comment">                         is always true after initialization.</span></span><br><span class="line"><span class="comment">                       */</span></span><br><span class="line"></span><br><span class="line">                      correction = MALLOC_ALIGNMENT - front_misalign;</span><br><span class="line">                      aligned_brk += correction;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     If this isn&#x27;t adjacent to existing space, then we will not</span></span><br><span class="line"><span class="comment">                     be able to merge with old_top space, so must add to 2nd request.</span></span><br><span class="line"><span class="comment">                   */</span></span><br><span class="line"></span><br><span class="line">                  correction += old_size;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">/* Extend the end address to hit a page boundary */</span></span><br><span class="line">                  end_misalign = (INTERNAL_SIZE_T) (brk + size + correction);</span><br><span class="line">                  correction += (ALIGN_UP (end_misalign, pagesize)) - end_misalign;</span><br><span class="line"></span><br><span class="line">                  assert (correction &gt;= <span class="number">0</span>);</span><br><span class="line">                  snd_brk = (<span class="type">char</span> *) (MORECORE (correction));</span><br><span class="line"></span><br><span class="line">                  <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     If can&#x27;t allocate correction, try to at least find out current</span></span><br><span class="line"><span class="comment">                     brk.  It might be enough to proceed without failing.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                     Note that if second sbrk did NOT fail, we assume that space</span></span><br><span class="line"><span class="comment">                     is contiguous with first sbrk. This is a safe assumption unless</span></span><br><span class="line"><span class="comment">                     program is multithreaded but doesn&#x27;t use locks and a foreign sbrk</span></span><br><span class="line"><span class="comment">                     occurred between our first and second calls.</span></span><br><span class="line"><span class="comment">                   */</span></span><br><span class="line"></span><br><span class="line">                  <span class="keyword">if</span> (snd_brk == (<span class="type">char</span> *) (MORECORE_FAILURE))</span><br><span class="line">                    &#123;</span><br><span class="line">                      correction = <span class="number">0</span>;</span><br><span class="line">                      snd_brk = (<span class="type">char</span> *) (MORECORE (<span class="number">0</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      <span class="comment">/* Call the `morecore&#x27; hook if necessary.  */</span></span><br><span class="line">                      <span class="type">void</span> (*hook) (<span class="type">void</span>) = atomic_forced_read (__after_morecore_hook);</span><br><span class="line">                      <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">                        (*hook)();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* handle non-contiguous cases */</span></span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="keyword">if</span> (MALLOC_ALIGNMENT == <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">                    <span class="comment">/* MORECORE/mmap must correctly align */</span></span><br><span class="line">                    assert (((<span class="type">unsigned</span> <span class="type">long</span>) chunk2mem (brk) &amp; MALLOC_ALIGN_MASK) == <span class="number">0</span>);</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      front_misalign = (INTERNAL_SIZE_T) chunk2mem (brk) &amp; MALLOC_ALIGN_MASK;</span><br><span class="line">                      <span class="keyword">if</span> (front_misalign &gt; <span class="number">0</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                          <span class="comment">/*</span></span><br><span class="line"><span class="comment">                             Skip over some bytes to arrive at an aligned position.</span></span><br><span class="line"><span class="comment">                             We don&#x27;t need to specially mark these wasted front bytes.</span></span><br><span class="line"><span class="comment">                             They will never be accessed anyway because</span></span><br><span class="line"><span class="comment">                             prev_inuse of av-&gt;top (and any chunk created from its start)</span></span><br><span class="line"><span class="comment">                             is always true after initialization.</span></span><br><span class="line"><span class="comment">                           */</span></span><br><span class="line"></span><br><span class="line">                          aligned_brk += MALLOC_ALIGNMENT - front_misalign;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">/* Find out current end of memory */</span></span><br><span class="line">                  <span class="keyword">if</span> (snd_brk == (<span class="type">char</span> *) (MORECORE_FAILURE))</span><br><span class="line">                    &#123;</span><br><span class="line">                      snd_brk = (<span class="type">char</span> *) (MORECORE (<span class="number">0</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Adjust top based on results of second sbrk */</span></span><br><span class="line">              <span class="keyword">if</span> (snd_brk != (<span class="type">char</span> *) (MORECORE_FAILURE))</span><br><span class="line">                &#123;</span><br><span class="line">                  av-&gt;top = (mchunkptr) aligned_brk;</span><br><span class="line">                  set_head (av-&gt;top, (snd_brk - aligned_brk + correction) | PREV_INUSE);</span><br><span class="line">                  av-&gt;system_mem += correction;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     If not the first time through, we either have a</span></span><br><span class="line"><span class="comment">                     gap due to foreign sbrk or a non-contiguous region.  Insert a</span></span><br><span class="line"><span class="comment">                     double fencepost at old_top to prevent consolidation with space</span></span><br><span class="line"><span class="comment">                     we don&#x27;t own. These fenceposts are artificial chunks that are</span></span><br><span class="line"><span class="comment">                     marked as inuse and are in any case too small to use.  We need</span></span><br><span class="line"><span class="comment">                     two to make sizes and alignments work out.</span></span><br><span class="line"><span class="comment">                   */</span></span><br><span class="line"></span><br><span class="line">                  <span class="keyword">if</span> (old_size != <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                      <span class="comment">/*</span></span><br><span class="line"><span class="comment">                         Shrink old_top to insert fenceposts, keeping size a</span></span><br><span class="line"><span class="comment">                         multiple of MALLOC_ALIGNMENT. We know there is at least</span></span><br><span class="line"><span class="comment">                         enough space in old_top to do this.</span></span><br><span class="line"><span class="comment">                       */</span></span><br><span class="line">                      old_size = (old_size - <span class="number">4</span> * SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK;</span><br><span class="line">                      set_head (old_top, old_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">                      <span class="comment">/*</span></span><br><span class="line"><span class="comment">                         Note that the following assignments completely overwrite</span></span><br><span class="line"><span class="comment">                         old_top when old_size was previously MINSIZE.  This is</span></span><br><span class="line"><span class="comment">                         intentional. We need the fencepost, even if old_top otherwise gets</span></span><br><span class="line"><span class="comment">                         lost.</span></span><br><span class="line"><span class="comment">                       */</span></span><br><span class="line">                      chunk_at_offset (old_top, old_size)-&gt;size =</span><br><span class="line">                        (<span class="number">2</span> * SIZE_SZ) | PREV_INUSE;</span><br><span class="line"></span><br><span class="line">                      chunk_at_offset (old_top, old_size + <span class="number">2</span> * SIZE_SZ)-&gt;size =</span><br><span class="line">                        (<span class="number">2</span> * SIZE_SZ) | PREV_INUSE;</span><br><span class="line"></span><br><span class="line">                      <span class="comment">/* If possible, release the rest. */</span></span><br><span class="line">                      <span class="keyword">if</span> (old_size &gt;= MINSIZE)</span><br><span class="line">                        &#123;</span><br><span class="line">                          _int_free (av, old_top, <span class="number">1</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">/* if (av !=  &amp;main_arena) */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) av-&gt;system_mem &gt; (<span class="type">unsigned</span> <span class="type">long</span>) (av-&gt;max_system_mem))</span><br><span class="line">    av-&gt;max_system_mem = av-&gt;system_mem;</span><br><span class="line">  check_malloc_state (av);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* finally, do the allocation */</span></span><br><span class="line">  p = av-&gt;top;</span><br><span class="line">  size = chunksize (p);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* check that one of the above allocation paths succeeded */</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">    &#123;</span><br><span class="line">      remainder_size = size - nb;</span><br><span class="line">      remainder = chunk_at_offset (p, nb);</span><br><span class="line">      av-&gt;top = remainder;</span><br><span class="line">      set_head (p, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">      set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">      check_malloced_chunk (av, p, nb);</span><br><span class="line">      <span class="keyword">return</span> chunk2mem (p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* catch all failure paths */</span></span><br><span class="line">  __set_errno (ENOMEM);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="0x05-new-heap："><a href="#0x05-new-heap：" class="headerlink" title="0x05.new_heap："></a>0x05.new_heap：</h1><p>定义于arena.c中，<strong>用以通过mmap系统调用分配内存</strong>，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Create a new heap.  size is automatically rounded up to a multiple</span></span><br><span class="line"><span class="comment">   of the page size. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> heap_info *</span><br><span class="line">internal_function</span><br><span class="line"><span class="title function_">new_heap</span> <span class="params">(<span class="type">size_t</span> size, <span class="type">size_t</span> top_pad)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> pagesize = GLRO (dl_pagesize);</span><br><span class="line">  <span class="type">char</span> *p1, *p2;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> ul;</span><br><span class="line">  heap_info *h;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (size + top_pad &lt; HEAP_MIN_SIZE)</span><br><span class="line">    size = HEAP_MIN_SIZE;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (size + top_pad &lt;= HEAP_MAX_SIZE)</span><br><span class="line">    size += top_pad;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (size &gt; HEAP_MAX_SIZE)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    size = HEAP_MAX_SIZE;</span><br><span class="line">  size = ALIGN_UP (size, pagesize);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* A memory region aligned to a multiple of HEAP_MAX_SIZE is needed.</span></span><br><span class="line"><span class="comment">     No swap space needs to be reserved for the following large</span></span><br><span class="line"><span class="comment">     mapping (on Linux, this is the case for all non-writable mappings</span></span><br><span class="line"><span class="comment">     anyway). */</span></span><br><span class="line">  p2 = MAP_FAILED;</span><br><span class="line">  <span class="keyword">if</span> (aligned_heap_area)</span><br><span class="line">    &#123;</span><br><span class="line">      p2 = (<span class="type">char</span> *) MMAP (aligned_heap_area, HEAP_MAX_SIZE, PROT_NONE,</span><br><span class="line">                          MAP_NORESERVE);</span><br><span class="line">      aligned_heap_area = <span class="literal">NULL</span>;</span><br><span class="line">      <span class="keyword">if</span> (p2 != MAP_FAILED &amp;&amp; ((<span class="type">unsigned</span> <span class="type">long</span>) p2 &amp; (HEAP_MAX_SIZE - <span class="number">1</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">          __munmap (p2, HEAP_MAX_SIZE);</span><br><span class="line">          p2 = MAP_FAILED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (p2 == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">      p1 = (<span class="type">char</span> *) MMAP (<span class="number">0</span>, HEAP_MAX_SIZE &lt;&lt; <span class="number">1</span>, PROT_NONE, MAP_NORESERVE);</span><br><span class="line">      <span class="keyword">if</span> (p1 != MAP_FAILED)</span><br><span class="line">        &#123;</span><br><span class="line">          p2 = (<span class="type">char</span> *) (((<span class="type">unsigned</span> <span class="type">long</span>) p1 + (HEAP_MAX_SIZE - <span class="number">1</span>))</span><br><span class="line">                         &amp; ~(HEAP_MAX_SIZE - <span class="number">1</span>));</span><br><span class="line">          ul = p2 - p1;</span><br><span class="line">          <span class="keyword">if</span> (ul)</span><br><span class="line">            __munmap (p1, ul);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            aligned_heap_area = p2 + HEAP_MAX_SIZE;</span><br><span class="line">          __munmap (p2 + HEAP_MAX_SIZE, HEAP_MAX_SIZE - ul);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/* Try to take the chance that an allocation of only HEAP_MAX_SIZE</span></span><br><span class="line"><span class="comment">             is already aligned. */</span></span><br><span class="line">          p2 = (<span class="type">char</span> *) MMAP (<span class="number">0</span>, HEAP_MAX_SIZE, PROT_NONE, MAP_NORESERVE);</span><br><span class="line">          <span class="keyword">if</span> (p2 == MAP_FAILED)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) p2 &amp; (HEAP_MAX_SIZE - <span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">              __munmap (p2, HEAP_MAX_SIZE);</span><br><span class="line">              <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (__mprotect (p2, size, PROT_READ | PROT_WRITE) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      __munmap (p2, HEAP_MAX_SIZE);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  h = (heap_info *) p2;</span><br><span class="line">  h-&gt;size = size;</span><br><span class="line">  h-&gt;mprotect_size = size;</span><br><span class="line">  LIBC_PROBE (memory_heap_new, <span class="number">2</span>, h, h-&gt;size);</span><br><span class="line">  <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
              <a href="/2021/01/15/GLIBC-0X00-MALLOC-2.23-PART-I/" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>上一页</span>
              </a>
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">
              <i class="iconfont icon-updatetime" title="更新时间"></i>
              2021-01-15 20:17:03
            </span>
            
                  <span class="post-categories">
                    <i class="iconfont icon-bookmark" title="分类"></i>
                    
                    <span class="span--category">
                      <a href="/categories/GLIBC/" title="GLIBC">
                        <b>#</b> GLIBC
                      </a>
                    </span>
                    
                  </span>
              
                  <span class="post-tags">
                    <i class="iconfont icon-tags" title="标签"></i>
                    
                    <span class="span--tag">
                      <a href="/tags/%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0/" title="学习札记">
                        <b>#</b> 学习札记
                      </a>
                    </span>
                    
                    <span class="span--tag">
                      <a href="/tags/ptmalloc/" title="ptmalloc">
                        <b>#</b> ptmalloc
                      </a>
                    </span>
                    
                    <span class="span--tag">
                      <a href="/tags/glibc/" title="glibc">
                        <b>#</b> glibc
                      </a>
                    </span>
                    
                    <span class="span--tag">
                      <a href="/tags/%E5%A0%86-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" title="堆 - 内存管理">
                        <b>#</b> 堆 - 内存管理
                      </a>
                    </span>
                    
                  </span>
              
          </div>
          <div class="post-foot-prev">
            
              <a href="/2021/01/20/CTF-0X02-STARCTF2021-PWN/" target="_self">
                <span>下一页</span>
                <i class="iconfont icon-chevronright"></i>
              </a>
            
          </div>
        </div>
      
    </div>
    
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">目录</div>
    <div class="catalog-content">
      
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0x00-malloc"><span class="toc-text">0x00.malloc</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#THROW%EF%BC%9AC-%E4%B8%8B%E4%B8%8D%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-text">__THROW：C++下不抛出异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#attribute-malloc-%EF%BC%9A%E4%BC%98%E5%8C%96malloc%E7%B1%BB%E5%9E%8B%E5%87%BD%E6%95%B0"><span class="toc-text">__attribute_malloc__：优化malloc类型函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GNUC-PREREQ"><span class="toc-text">__GNUC_PREREQ()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#wur%EF%BC%9A%E8%8B%A5%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E6%9C%AA%E8%A2%AB%E5%BC%95%E7%94%A8%E5%88%99%E6%8A%9B%E5%87%BA%E8%AD%A6%E5%91%8A"><span class="toc-text">__wur：若函数返回值未被引用则抛出警告</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#USE-FORTIFY-LEVEL"><span class="toc-text">__USE_FORTIFY_LEVEL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FORTIFY-SOURCE"><span class="toc-text">_FORTIFY_SOURCE</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#strong-alias%EF%BC%9A%E9%87%8D%E5%91%BD%E5%90%8Dmalloc%E4%B8%BA-libc-malloc"><span class="toc-text">strong_alias：重命名malloc为__libc_malloc</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#typeof"><span class="toc-text">__typeof</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x01-libc-malloc"><span class="toc-text">0x01.__libc_malloc</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#errno"><span class="toc-text">errno</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#libc-hidden-proto%EF%BC%9A%E5%87%BD%E6%95%B0%E7%AC%A6%E5%8F%B7%E9%9A%90%E8%97%8F"><span class="toc-text">libc_hidden_proto：函数符号隐藏</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#attribute-visibility-%E2%80%9Chidden%E2%80%9D"><span class="toc-text">attribute: visibility(“hidden”)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#libc-malloc%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="toc-text">__libc_malloc函数定义：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A3%80%E6%9F%A5%E9%92%A9%E5%AD%90-malloc-hook%E6%98%AF%E5%90%A6%E4%B8%BANULL%EF%BC%8C%E8%8B%A5%E5%90%A6%EF%BC%8C%E5%88%99%E8%B0%83%E7%94%A8%E9%92%A9%E5%AD%90"><span class="toc-text">1.检查钩子__malloc_hook是否为NULL，若否，则调用钩子</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#weak-variable"><span class="toc-text">weak_variable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0malloc-hook-ini%EF%BC%9A%E9%87%8D%E7%BD%AE-malloc-hook%E4%B8%BANULL%EF%BC%8C%E8%B0%83%E7%94%A8ptmalloc%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0%EF%BC%8C%E9%87%8D%E6%96%B0%E8%B0%83%E7%94%A8-libc-malloc%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E5%9D%97"><span class="toc-text">①malloc_hook__ini：重置__malloc_hook为NULL，调用ptmalloc初始化函数，重新调用__libc_malloc分配内存块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1ptmalloc-init-%EF%BC%9A%E5%88%9D%E5%A7%8B%E5%8C%96ptmalloc%E5%A0%86%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-text">②ptmalloc_init()：初始化ptmalloc堆管理器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%89%E4%BF%AE%E6%94%B9ptmalloc%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A0%87%E5%BF%97%E4%BD%8D"><span class="toc-text">1）修改ptmalloc初始化标志位</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%89%E6%A3%80%E6%9F%A5SHARED%E5%AE%8F"><span class="toc-text">2）检查SHARED宏</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%EF%BC%89%E8%8E%B7%E5%8F%96main-arena%EF%BC%8C%E6%B7%BB%E5%8A%A0atfork-mem%E5%85%A5fork-handler%E9%93%BE%E8%A1%A8"><span class="toc-text">3）获取main_arena，添加atfork_mem入fork_handler链表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%EF%BC%89%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F-environ%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C"><span class="toc-text">4）环境变量__environ相关操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%EF%BC%89%E6%A3%80%E6%9F%A5%E9%92%A9%E5%AD%90-malloc-initialized-hook"><span class="toc-text">5）检查钩子__malloc_initialized_hook</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%8E%B7%E5%8F%96%E4%B8%80%E4%B8%AAarena"><span class="toc-text">2.获取一个arena</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%AD%903-%E8%B0%83%E7%94%A8-int-malloc-%E5%87%BD%E6%95%B0%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="toc-text">⭐3.调用_int_malloc()函数分配内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%A3%80%E6%B5%8B%E7%BB%93%E6%9E%9C%EF%BC%8C%E8%8B%A5%E4%B8%BANULL%E5%88%99%E9%87%8D%E6%96%B0%E8%8E%B7%E5%BE%97arena%E5%B9%B6%E9%87%8D%E6%96%B0%E8%B0%83%E7%94%A8-int-malloc-%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="toc-text">4.检测结果，若为NULL则重新获得arena并重新调用_int_malloc()分配内存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0arena-get-retry-%EF%BC%9A%E9%87%8D%E6%96%B0%E8%8E%B7%E5%BE%97%E4%B8%80%E4%B8%AAarena"><span class="toc-text">①arena_get_retry()：重新获得一个arena</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%89%E5%8E%9Farena%E4%B8%8D%E4%B8%BAmain-arena%EF%BC%8C%E5%88%99%E8%A7%A3%E9%94%81%E5%90%8E%E8%8E%B7%E5%8F%96main-arena"><span class="toc-text">1）原arena不为main_arena，则解锁后获取main_arena</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%89%E5%8E%9Farena%E4%B8%BAmain-arena%EF%BC%8C%E8%A7%A3%E9%94%81%E5%90%8E%E8%B0%83%E7%94%A8arena-get2-%E8%8E%B7%E5%8F%96%E5%85%B6%E4%BB%96arena"><span class="toc-text">2）原arena为main_arena，解锁后调用arena_get2()获取其他arena</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E9%87%8D%E6%96%B0%E8%B0%83%E7%94%A8-int-malloc-%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="toc-text">②重新调用_int_malloc()分配内存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%A3%80%E6%B5%8B%E6%97%A0%E8%AF%AF%E5%90%8E%E8%BF%94%E5%9B%9E%E5%86%85%E5%AD%98%E5%9D%97"><span class="toc-text">5.检测无误后返回内存块</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#libc-hidden-def%EF%BC%9A%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E9%9A%90%E8%97%8F"><span class="toc-text">libc_hidden_def：函数定义隐藏</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x02-malloc-consolidate"><span class="toc-text">0x02.malloc_consolidate</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%96%E5%B1%82%E5%BE%AA%E7%8E%AF%EF%BC%9A%E9%81%8D%E5%8E%86fastbinsY%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0"><span class="toc-text">外层循环：遍历fastbinsY数组元素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%B1%82%E5%BE%AA%E7%8E%AF%EF%BC%9A%E9%81%8D%E5%8E%86fastbin-%E9%93%BE%E8%A1%A8%E3%80%81%E5%90%88%E5%B9%B6%E7%A9%BA%E9%97%B2chunk"><span class="toc-text">内层循环：遍历fastbin 链表、合并空闲chunk</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E5%90%8E%E5%90%91%E5%90%88%E5%B9%B6%EF%BC%9A%E4%BD%BF%E7%94%A8unlink%E5%8F%96%E5%87%BA%E7%9B%B8%E9%82%BB%E4%BD%8E%E5%9C%B0%E5%9D%80chunk%EF%BC%88%E8%8B%A5%E5%B7%B2free%EF%BC%89"><span class="toc-text">①后向合并：使用unlink取出相邻低地址chunk（若已free）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E5%89%8D%E5%90%91%E5%90%88%E5%B9%B6%EF%BC%9A%E8%8B%A5%E4%B8%BAtop-chunk%E5%88%99%E5%90%88%E5%B9%B6%E5%85%A5top-chunk%E4%B8%AD%EF%BC%8C%E5%90%A6%E5%88%99%E4%BC%9A%E5%B0%9D%E8%AF%95%E5%90%88%E5%B9%B6%E5%90%8E%E6%8F%92%E5%85%A5unsorted-bin%E4%B8%AD"><span class="toc-text">②前向合并：若为top chunk则合并入top chunk中，否则会尝试合并后插入unsorted_bin中</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%89nextchunk%E4%B8%BAtop-chunk"><span class="toc-text">1）nextchunk为top chunk</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%EF%BC%89nextchunk%E4%B8%8D%E4%B8%BAtop-chunk"><span class="toc-text">5）nextchunk不为top chunk</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E6%A3%80%E6%9F%A5%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AAchunk%EF%BC%8C%E4%B8%8D%E4%B8%BANULL%E5%88%99%E7%BB%A7%E7%BB%AD%E6%96%B0%E4%B8%80%E8%BD%AE%E5%BE%AA%E7%8E%AF"><span class="toc-text">③检查链表中的下一个chunk，不为NULL则继续新一轮循环</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x03-int-malloc"><span class="toc-text">0x03._int_malloc</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%B0%86%E8%AF%B7%E6%B1%82%E5%A4%A7%E5%B0%8F%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%A0%87%E5%87%86%E5%A4%A7%E5%B0%8F"><span class="toc-text">一、将请求大小转换为标准大小</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%A3%80%E6%9F%A5arena%E6%98%AF%E5%90%A6%E5%8F%AF%E7%94%A8"><span class="toc-text">二、检查arena是否可用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81fastbin%E8%8C%83%E5%9B%B4size%E8%AF%B7%E6%B1%82%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C"><span class="toc-text">三、fastbin范围size请求相关操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%B0%9D%E8%AF%95%E4%BB%8Efastbin%E5%AF%B9%E5%BA%94%E4%B8%8B%E6%A0%87%E5%8F%96%E5%87%BAchunk"><span class="toc-text">1.尝试从fastbin对应下标取出chunk</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%EF%BC%88%E8%8B%A5%E6%88%90%E5%8A%9F%E8%8E%B7%E5%BE%97chunk%EF%BC%89%E8%BF%9B%E8%A1%8Cchunk-size%E5%AE%89%E5%85%A8%E6%A3%80%E6%9F%A5"><span class="toc-text">2.（若成功获得chunk）进行chunk size安全检查</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x04-sysmalloc%EF%BC%9A"><span class="toc-text">0x04.sysmalloc：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x05-new-heap%EF%BC%9A"><span class="toc-text">0x05.new_heap：</span></a></li></ol>
      
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
      <div class="comments-container">
        




  
    <script async type="text/javascript" src="/plugins/valine.min.js" onload="loadValineSuc(this)"></script>
  

  <div id="vcomments"></div>

  <script>
    function loadValineSuc() {
      new Valine({
        el: '#vcomments',
        appId: 'ICj6cPRQWFTNiOttBHlzxnIv-gzGzoHsz',
        appKey: 'tuvJh3xYxPFcW2JB6K26RKP2',
        placeholder: '说点什么呗...',
        avatar: 'retro',
        lang: 'zh-CN'
      })
    }
  </script>

    <style>
      .comments-container .v .vempty {
        display: none!important;
      }
    </style>




      </div>
    
  </div>


        
<div class="footer">
  <div class="social">
    <ul>
      
        <li>
          <a title="github" target="_blank" rel="noopener" href="https://github.com/arttnba3">
            <i class="iconfont icon-github"></i>
          </a>
        </li>
      
        <li>
          <a title="email" href="mailto:arttnba@gmail.com">
            <i class="iconfont icon-envelope"></i>
          </a>
        </li>
      
        <li>
          <a title="twitter" target="_blank" rel="noopener" href="https://twitter.com/arttnba3">
            <i class="iconfont icon-twitter"></i>
          </a>
        </li>
      
        <li>
          <a title="rss" href="/atom.xml">
            <i class="iconfont icon-rss"></i>
          </a>
        </li>
      
    </ul>
  </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/arttnba3">Copyright © 2022 arttnba3</a>
        
    </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Theme by Oranges | Powered by Hexo</a>
        
    </div>
  
</div>

      </div>

      <div class="tools-bar">
        <div class="back-to-top tools-bar-item hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



        
  <div class="search-icon tools-bar-item" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-title">
        <span class="search-icon-input">
          <a href="javascript: void(0)">
            <i class="iconfont icon-search"></i>
          </a>
        </span>
        
          <input type="text" class="search-input" id="search-input" placeholder="搜索...">
        
        <span class="search-close-icon" id="search-close-icon">
          <a href="javascript: void(0)">
            <i class="iconfont icon-close"></i>
          </a>
        </span>
      </div>
      <div class="search-result" id="search-result"></div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    inputArea.onclick = function() {
      getSearchFile()
      this.onclick = null
    }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        // inputArea.focus()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'>首次搜索，正在载入索引文件，请稍后……<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + orig_data_title + "</a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<p class=\"search-result-abstract\">" + match_content + "...</p>"
                }
                str += "</li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>没有找到内容，请尝试更换检索词。<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>未找到search.xml文件，具体请参考：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>请求失败，尝试重新刷新页面或稍后重试。<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




        
  <div class="tools-bar-item theme-icon" id="switch-color-scheme">
    <a href="javascript: void(0)">
      <i id="theme-icon" class="iconfont icon-moon"></i>
    </a>
  </div>

  
<script src="/js/colorscheme.js"></script>





        
  
    <div class="share-icon tools-bar-item">
      <a href="javascript: void(0)" id="share-icon">
        <i class="iconfont iconshare"></i>
      </a>
      <div class="share-content hidden">
        
          <a class="share-item" href="https://twitter.com/intent/tweet?text=' + %E3%80%90GLIBC.0x01%E3%80%91glibc2.23%20malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20-%20II%EF%BC%9Amalloc + '&url=' + http%3A%2F%2Fblog.arttnba3.cn%2F2021%2F01%2F15%2FGLIBC-0X01-MALLOC-2.23-PART-II%2F + '" target="_blank" title="Twitter">
            <i class="iconfont icon-twitter"></i>
          </a>
        
        
          <a class="share-item" href="https://www.facebook.com/sharer.php?u=http://blog.arttnba3.cn/2021/01/15/GLIBC-0X01-MALLOC-2.23-PART-II/" target="_blank" title="Facebook">
            <i class="iconfont icon-facebooksquare"></i>
          </a>
        
      </div>
    </div>
  
  
<script src="/js/shares.js"></script>



      </div>
    </div>
  </body>
</html>
