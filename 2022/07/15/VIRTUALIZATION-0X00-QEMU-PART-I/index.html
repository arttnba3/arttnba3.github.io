<!DOCTYPE html>
<html lang="zh-CN" color-mode="light">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="keywords" content="" />
  <meta name="author" content="arttnba3" />
  <meta name="description" content="あがいた夢を捨てて揺れる今日は眠って誤魔化せ" />
  
  
  <title>
    
      【VIRTUALIZATION.0x00】Qemu - I：Qemu 简易食用指南 
      
      
      |
    
     arttnba3&#39;s blog
  </title>

  
    <link rel="apple-touch-icon" href="/img/favicon.png">
    <link rel="icon" href="/img/favicon.png">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  
<link rel="stylesheet" href="/css/color-scheme.css">
<link rel="stylesheet" href="/css/base.css">
<link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css">
<link rel="stylesheet" href="/css/github-markdown.css">
<link rel="stylesheet" href="/css/highlight.css">
<link rel="stylesheet" href="/css/comments.css">

  <!-- 代码块风格 -->
  

  <!-- jquery3.3.1 -->
  
    <script defer type="text/javascript" src="/plugins/jquery.min.js"></script>
  

  <!-- fancybox -->
  
    <link href="/plugins/jquery.fancybox.min.css" rel="stylesheet">
    <script defer type="text/javascript" src="/plugins/jquery.fancybox.min.js"></script>
  
  
<script src="/js/fancybox.js"></script>


  

  <script>
    var html = document.documentElement
    const colorMode = localStorage.getItem('color-mode')
    if (colorMode) {
      document.documentElement.setAttribute('color-mode', colorMode)
    }
  </script>
<meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="arttnba3's blog" type="application/atom+xml">
</head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a target="_blank" rel="noopener" href="https://arttnba3.cn">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img src="/img/avatar.png" alt="">
      
    </a>
    <div class="nickname"><a target="_blank" rel="noopener" href="https://arttnba3.cn">arttnba3's blog</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">Home</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">Archives</a>
        </li>
      
        <li class="nav-item" data-path="/categories/">
          <a href="/categories/">Categories</a>
        </li>
      
        <li class="nav-item" data-path="/tags/">
          <a href="/tags/">Tags</a>
        </li>
      
        <li class="nav-item" data-path="/friends/">
          <a href="/friends/">Friends</a>
        </li>
      
        <li class="nav-item" data-path="/about/">
          <a href="/about/">About</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->


  <!-- LaTex Display -->

  
    <script async type="text/javascript" src="/plugins/mathjax/tex-chtml.js"></script>
  
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    }
  </script>





  <!-- clipboard -->

  
    <script async type="text/javascript" src="/plugins/clipboard.min.js"></script>
  
  
<script src="/js/codeCopy.js"></script>







  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">【VIRTUALIZATION.0x00】Qemu - I：Qemu 简易食用指南</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime" title="更新时间"></i>
          2022-07-15 16:45:17
        </span>
        
              <span class="post-categories">
                <i class="iconfont icon-bookmark" title="分类"></i>
                
                <span class="span--category">
                  <a href="/categories/VIRTUALIZATION/" title="VIRTUALIZATION">
                    <b>#</b> VIRTUALIZATION
                  </a>
                </span>
                
              </span>
          
              <span class="post-tags">
                <i class="iconfont icon-tags" title="标签"></i>
                
                <span class="span--tag">
                  <a href="/tags/%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0/" title="学习札记">
                    <b>#</b> 学习札记
                  </a>
                </span>
                
                <span class="span--tag">
                  <a href="/tags/Qemu/" title="Qemu">
                    <b>#</b> Qemu
                  </a>
                </span>
                
                <span class="span--tag">
                  <a href="/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/" title="虚拟化">
                    <b>#</b> 虚拟化
                  </a>
                </span>
                
                <span class="span--tag">
                  <a href="/tags/PCI/" title="PCI">
                    <b>#</b> PCI
                  </a>
                </span>
                
              </span>
          
      </div>
      <div class="markdown-body">
        <p>不如 VMWare👋</p>
<span id="more"></span>

<h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><p>Qemu 是一款开源的虚拟机软件，支持多种不同架构的模拟（Emulation）以及配合 kvm 完成当前架构的虚拟化（Virtualization）的特性，是当前最火热的开源虚拟机软件</p>
<p><img src="https://s2.loli.net/2022/07/22/jfIDUCx5ZtMsHAY.png" alt="image.png"></p>
<p>Qemu 的基本运行架构如下图所示：</p>
<p><img src="https://s2.loli.net/2022/07/26/9L7HtFUQlyZdwXD.png" alt="image.png"></p>
<p>本篇文章笔者将简要叙述如何从源码编译特定架构的 Qemu 并进行一定程度的改造工作</p>
<h2 id="PRE-安装依赖"><a href="#PRE-安装依赖" class="headerlink" title="PRE.安装依赖"></a>PRE.安装依赖</h2><p>大概需要安装这些依赖：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt -y install ninja-build build-essential zlib1g-dev pkg-config libglib2.0-dev binutils-dev libpixman-1-dev libfdt-dev</span></span><br></pre></td></tr></table></figure>

<h1 id="0x01-从源码编译-QEMU"><a href="#0x01-从源码编译-QEMU" class="headerlink" title="0x01.从源码编译 QEMU"></a>0x01.从源码编译 QEMU</h1><h2 id="一、获取-QEMU-源码"><a href="#一、获取-QEMU-源码" class="headerlink" title="一、获取 QEMU 源码"></a>一、获取 QEMU 源码</h2><p>大概有两种途径：从官网下载或是直接从 Qemu 的GitHub 仓库拉下来。</p>
<h3 id="I-官网下载源码"><a href="#I-官网下载源码" class="headerlink" title="I.官网下载源码"></a>I.官网下载源码</h3><p>前往 <a target="_blank" rel="noopener" href="https://download.qemu.org/">qemu 的官网</a>进行下载：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget https://download.qemu.org/qemu-7.0.0.tar.xz</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar -xf qemu-7.0.0.tar.xz</span></span><br></pre></td></tr></table></figure>

<h3 id="II-GitHub-获取源码"><a href="#II-GitHub-获取源码" class="headerlink" title="II. GitHub 获取源码"></a>II. GitHub 获取源码</h3><p>直接从 <a target="_blank" rel="noopener" href="https://github.com/qemu/qemu">GitHub</a> 上面拉也行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> git@github.com:qemu/qemu.git</span></span><br></pre></td></tr></table></figure>

<h2 id="二、配置编译选项"><a href="#二、配置编译选项" class="headerlink" title="二、配置编译选项"></a>二、配置编译选项</h2><p>接下来创建 build 目录并配置对应的编译选项：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> build &amp;&amp; <span class="built_in">cd</span> build</span></span><br><span class="line"><span class="meta prompt_">build$ </span><span class="language-bash">../qemu-7.0.0/configure --enable-kvm --target-list=x86_64-softmmu --enable-debug</span></span><br></pre></td></tr></table></figure>

<p>这里我们手动指定了这几个编译选项：</p>
<ul>
<li><code>--enable-kvm</code>：开启 kvm 支持</li>
<li><code>--target-list=&lt;架构名&gt;</code>：指定要编译的 CPU 架构，这里我们指定为 <code>x86_64-softmmu</code> 即表示我们要编译 x86 架构的 64位 CPU</li>
<li><code>--enable-debug</code>：能够对 Qemu 进行调试</li>
</ul>
<blockquote>
<p>如果我们不指定的话会把所有架构都编译一遍，不过这里笔者只需要 x86 的；）</p>
</blockquote>
<h2 id="三、开始编译"><a href="#三、开始编译" class="headerlink" title="三、开始编译"></a>三、开始编译</h2><p>直接 make 就完事了</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">build$ </span><span class="language-bash">make</span></span><br></pre></td></tr></table></figure>

<p>需要花的时间还是不短的，在笔者的小破服务器上编译大概需要十几分钟左右，大概编译了两千多个文件，完成之后在当前目录下就会有一个热乎乎的可执行文件 <code>qemu-system_x86-64</code>，这个就是 Qemu 的本体了</p>
<p>之后可以 make install 给他安到 bin 里边，这样就能直接从命令行启动了</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">build$ </span><span class="language-bash">sudo make install</span></span><br></pre></td></tr></table></figure>

<h1 id="0x02-构建系统镜像并使用-vnc-连接"><a href="#0x02-构建系统镜像并使用-vnc-连接" class="headerlink" title="0x02.构建系统镜像并使用 vnc 连接"></a>0x02.构建系统镜像并使用 vnc 连接</h1><p>空有一个 <code>qemu</code> 的可执行文件还不行，我们最终还是要在 qemu 上面跑一个完整的操作系统的，那么这里有两种方法：</p>
<ul>
<li>使用 <code>qemu-img</code> 创建虚拟机镜像文件，通过 <code>-cdrom</code> 参数指定载入一个 ISO 镜像文件来安装一个现有的操作系统</li>
<li>使用 <code>debootstrap</code> 创建 ext4 硬盘镜像，并直接运行一个现成的裸的内核镜像文件（bzImage）</li>
</ul>
<h2 id="一、创建虚拟机镜像文件并通过-CDROM-安装-Ubuntu"><a href="#一、创建虚拟机镜像文件并通过-CDROM-安装-Ubuntu" class="headerlink" title="一、创建虚拟机镜像文件并通过 CDROM 安装 Ubuntu"></a>一、创建虚拟机镜像文件并通过 CDROM 安装 Ubuntu</h2><h3 id="I-使用-qemu-img-创建虚拟机磁盘镜像文件"><a href="#I-使用-qemu-img-创建虚拟机磁盘镜像文件" class="headerlink" title="I.使用 qemu-img 创建虚拟机磁盘镜像文件"></a>I.使用 <code>qemu-img</code> 创建虚拟机磁盘镜像文件</h3><p>这一步比较简单，主要是用 <code>build</code> 目录下的 <code>qemu-img</code> 来完成构建：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./build/qemu-img create -f qcow2 test.qcow2 20G</span></span><br><span class="line">Formatting &#x27;test.qcow2&#x27;, fmt=qcow2 cluster_size=65536 extended_l2=off compression_type=zlib size=21474836480 lazy_refcounts=off refcount_bits=16</span><br></pre></td></tr></table></figure>

<p>这里的 <code>-f</code> 参数指定的第一个参数为镜像格式，这里使用 QEMU 最通用的格式 <code>qcow2</code>；第二个参数为文件路径；第三个参数为镜像大小</p>
<blockquote>
<p>参见<a target="_blank" rel="noopener" href="https://docs.fedoraproject.org/zh-CN/Fedora/12/html/Virtualization_Guide/sect-Virtualization_Guide-Tips_and_tricks-Using_qemu_img.html">这里</a></p>
</blockquote>
<h3 id="II-通过-vnc-连接完成安装"><a href="#II-通过-vnc-连接完成安装" class="headerlink" title="II.通过 vnc 连接完成安装"></a>II.通过 vnc 连接完成安装</h3><p>在 qemu 启动时通过 <code>-cdrom</code> 参数可以指定加载的ISO文件路径，这里笔者选择安装一个 Ubuntu 22.04：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo ./build/qemu-system-x86_64 -m 2G -drive format=qcow2,file=test.qcow2 -enable-kvm -cdrom ~/Download/ubuntu-22.04-desktop-amd64.iso</span></span><br><span class="line">VNC server running on ::1:5900</span><br></pre></td></tr></table></figure>

<p>参数说明如下：</p>
<ul>
<li><code>-m</code>：虚拟机的内存大小</li>
<li><code>-drive</code> ：qemu 启动时额外加载的设备，这里我们使用 <code>format=qcow2,file=test.qcow2</code> 指定了加载设备 <code>test.qcow2</code>、格式为 <code>qcow2</code></li>
<li><code>-enable-kvm</code> ：启用 kvm 模式，需要注意的是该选项<strong>要求以 root 权限运行</strong></li>
<li><code>-cdrom</code>：指定 qemu 启动时装载的光碟文件路径</li>
</ul>
<p>启动后 qemu 默认会在 5900 端口启动一个 VNC server，此时我们便能通过 VNC 连接到 qemu 上，需要注意的是这里<strong>只能在本地进行连接</strong></p>
<p>如果是运行在远程服务器上的话，我们还需要额外指定 <code>-vnc</code> 参数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo ./build/qemu-system-x86_64 -m 2G -drive format=qcow2,file=test.qcow2 -enable-kvm -cdrom ~/Download/ubuntu-22.04-desktop-amd64.iso -vnc yourip:0</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是 <code>vnc</code> 参数中 ip 后面跟着的不是端口号，而是 <code>display numer</code>，对于默认的 <code>display 0</code> 而言其监听的端口号为 <code>5900</code>，而 <code>display 1</code> 就是 <code>5901</code> 端口，以此类推</p>
<p>之后我们便能通过 vnc 连接上远程服务器上的 qemu 了，这里笔者选择使用 <code>VNC Viewer</code> 进行连接：</p>
<p><img src="https://s2.loli.net/2022/07/11/3juM5iAgFERhYsS.png" alt="image.png"></p>
<p>成功连接上远程服务器上的 qemu：</p>
<p><img src="https://s2.loli.net/2022/07/11/UdlOA6DGaPFJqx2.png" alt="image.png"></p>
<p>之后就是常规的安装流程了，不过可能是由于 qemu 模拟显卡的问题（或者是 VNC 配置的问题），在一开始的时候安装界面的颜色会有点失真：</p>
<p><img src="https://s2.loli.net/2022/07/11/lsp4rnZqSdbcIGL.png" alt="image.png"></p>
<p>不过在安装准备结束的时候又恢复正常的颜色了，笔者目前推测应该是和显卡驱动有关：</p>
<p><img src="https://s2.loli.net/2022/07/11/g5jCb8yzmQYsvMd.png" alt="image.png"></p>
<p>之后就和正常使用虚拟机没有什么区别了，下次再次启动就不需要指定 <code>-cdrom</code> 参数了</p>
<p><img src="https://s2.loli.net/2022/07/11/WZiEx6vqnYapdl7.png" alt="image.png"></p>
<h2 id="二、构建-ext4-磁盘镜像并运行-kernel-bzImage"><a href="#二、构建-ext4-磁盘镜像并运行-kernel-bzImage" class="headerlink" title="二、构建 ext4 磁盘镜像并运行 kernel bzImage"></a>二、构建 ext4 磁盘镜像并运行 kernel bzImage</h2><p>如果你不需要一个完整的发行版 Linux 系统环境，只是想跑一个裸的简易的内核，也可以通过下面的方式完成：</p>
<h3 id="I-构建磁盘镜像"><a href="#I-构建磁盘镜像" class="headerlink" title="I.构建磁盘镜像"></a>I.构建磁盘镜像</h3><p>这里我们使用 <code>debootstrap</code> 来创建ext4硬盘镜像，直接使用由 Google 团队为 syzkaller 构建磁盘镜像的脚步即可</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get install debootstrap</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> image</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> image</span></span><br><span class="line"><span class="meta prompt_">image$ </span><span class="language-bash">wget https://raw.githubusercontent.com/google/syzkaller/master/tools/create-image.sh -O create-image.sh</span></span><br><span class="line"><span class="meta prompt_">image$ </span><span class="language-bash"><span class="built_in">chmod</span> +x create-image.sh</span></span><br><span class="line"><span class="meta prompt_">image$ </span><span class="language-bash">./create-image.sh</span></span><br></pre></td></tr></table></figure>

<p>完成之后在当前目录下就会有一个热乎乎的 <code>stretch.img</code>，这便是 ext4 磁盘镜像文件了</p>
<blockquote>
<p>wget 的这一步<strong>需要翻墙</strong>（<code>raw.githubusercontent.com</code> 在国内似乎是被墙了，总之笔者记忆里从没成功在不翻墙的情况下成功上去过），若嫌麻烦可以直接 copy <a href="./create-image.sh">笔者已经下好的</a></p>
</blockquote>
<h3 id="II-获取-kernel-bzImage"><a href="#II-获取-kernel-bzImage" class="headerlink" title="II.获取 kernel bzImage"></a>II.获取 kernel bzImage</h3><p>这部分参见<a href="http://blog.arttnba3.cn/2021/02/21/OS-0X01-LINUX-KERNEL-PART-II/#0x01-%E8%8E%B7%E5%8F%96%E5%86%85%E6%A0%B8%E9%95%9C%E5%83%8F%EF%BC%88bzImage%EF%BC%89">这里</a></p>
<h3 id="III-运行-qemu-并通过-vnc-进行连接"><a href="#III-运行-qemu-并通过-vnc-进行连接" class="headerlink" title="III.运行 qemu 并通过 vnc 进行连接"></a>III.运行 qemu 并通过 vnc 进行连接</h3><p>创建如下 bash 脚本并运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">	-m 2G \</span><br><span class="line">	-smp 2 \</span><br><span class="line">	-kernel ./bzImage \</span><br><span class="line">	-append <span class="string">&quot;root=/dev/sda&quot;</span> \</span><br><span class="line">	-drive file=./stretch.img,format=raw \</span><br><span class="line">	-enable-kvm \</span><br><span class="line">	-vnc yourip:0</span><br></pre></td></tr></table></figure>

<p>之后还是直接用 vnc 进行连接即可（如果只需要在本地运行的话可以不用附加 <code>-vnc</code> 参数，而是加上 <code>-nographic</code> 参数）：</p>
<p><img src="https://s2.loli.net/2022/07/12/yjcVlhtYOz4pQvC.png" alt="image.png"></p>
<h1 id="0x03-简易-QEMU-设备编写"><a href="#0x03-简易-QEMU-设备编写" class="headerlink" title="0x03.简易 QEMU 设备编写"></a>0x03.简易 QEMU 设备编写</h1><p>虽然 Qemu 支持模拟多种设备，但是并不能涵盖现存所有的设备类型，同时有的时候出于一些特殊的目的我们也需要自定义一些设备，因此本节主要讲述如何在 Qemu 当中编写一个新的设备</p>
<blockquote>
<p>注：qemu 官方在 <code>hw/misc/edu.c</code> 中也提供了一个教学用的设备样例，red hat 则在 <code>hw/misc/pci-testdev.c</code> 中提供了一个测试设备，我们可以参考这两个设备来构建我们的设备</p>
</blockquote>
<h2 id="一、PCI-basic-knowledge"><a href="#一、PCI-basic-knowledge" class="headerlink" title="一、PCI basic knowledge"></a>一、PCI basic knowledge</h2><p>在开始之前，我们首先来补充一些基础知识</p>
<h3 id="I、总线-amp-amp-PCI-设备"><a href="#I、总线-amp-amp-PCI-设备" class="headerlink" title="I、总线 &amp;&amp; PCI 设备"></a>I、总线 &amp;&amp; PCI 设备</h3><p>现代计算机通常采用总线（bus）结构，即存在一根主要的公共通信干线，CPU 及各种设备都通过这跟总线进行通信；总线是可以扩展的，即可以存在多个不同类型的总线相连，不同的设备接入到不同类型的总线上</p>
<p><img src="https://s2.loli.net/2022/07/21/fWTEztvhuXAqN8d.png" alt="image.png"></p>
<p>由于总线结构形似一棵树🌳，故有的时候我们也将这些设备、总线、CPU所形成的结构称之为<strong>设备树</strong>（Device Tree）</p>
<p><img src="https://s2.loli.net/2022/07/21/7rT3aEytb2lumZP.png" alt="image.png"></p>
<p>PCI 即 <code>Peripheral Component Interconnect</code>，是一种连接电脑主板和外部设备的总线标准，其通过多根 PCI bus 完成 CPU 与 多个 PCI 设备间的连接，，在 X86 硬件体系结构中几乎所有的设备都以各种形式连接到 PCI 设备树上；PCIe（PCI express）是新一代的总线标准，它沿用既有的PCI编程概念及信号标准，并且构建了更加高速的串行通信系统标准</p>
<p>在 Linux 下我们可以使用 <code>lspci</code> 指令查看插在当前机器的 PCI bus 上的 PCI 设备，使用 <code>-t</code> 参数查看树形结构，<code>-v</code> 参数可以查看详细信息：</p>
<blockquote>
<p>这里展示的结果有 virtio 设备是因为笔者是在阿里云学生机上使用的命令，这类机器一般其实都是用 Qemu 跑的虚拟机</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">lspci</span></span><br><span class="line">00:00.0 Host bridge: Intel Corporation 440FX - 82441FX PMC [Natoma] (rev 02)</span><br><span class="line">00:01.0 ISA bridge: Intel Corporation 82371SB PIIX3 ISA [Natoma/Triton II]</span><br><span class="line">00:01.1 IDE interface: Intel Corporation 82371SB PIIX3 IDE [Natoma/Triton II]</span><br><span class="line">00:01.2 USB controller: Intel Corporation 82371SB PIIX3 USB [Natoma/Triton II] (rev 01)</span><br><span class="line">00:01.3 Bridge: Intel Corporation 82371AB/EB/MB PIIX4 ACPI (rev 03)</span><br><span class="line">00:02.0 VGA compatible controller: Cirrus Logic GD 5446</span><br><span class="line">00:03.0 Ethernet controller: Red Hat, Inc. Virtio network device</span><br><span class="line">00:04.0 Communication controller: Red Hat, Inc. Virtio console</span><br><span class="line">00:05.0 SCSI storage controller: Red Hat, Inc. Virtio block device</span><br><span class="line">00:06.0 Unclassified device [00ff]: Red Hat, Inc. Virtio memory balloon</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">lspci -t -v</span></span><br><span class="line">-[0000:00]-+-00.0  Intel Corporation 440FX - 82441FX PMC [Natoma]</span><br><span class="line">           +-01.0  Intel Corporation 82371SB PIIX3 ISA [Natoma/Triton II]</span><br><span class="line">           +-01.1  Intel Corporation 82371SB PIIX3 IDE [Natoma/Triton II]</span><br><span class="line">           +-01.2  Intel Corporation 82371SB PIIX3 USB [Natoma/Triton II]</span><br><span class="line">           +-01.3  Intel Corporation 82371AB/EB/MB PIIX4 ACPI</span><br><span class="line">           +-02.0  Cirrus Logic GD 5446</span><br><span class="line">           +-03.0  Red Hat, Inc. Virtio network device</span><br><span class="line">           +-04.0  Red Hat, Inc. Virtio console</span><br><span class="line">           +-05.0  Red Hat, Inc. Virtio block device</span><br><span class="line">           \-06.0  Red Hat, Inc. Virtio memory balloon</span><br></pre></td></tr></table></figure>

<p>我们还可以使用 <code>lshw -businfo</code> 命令来获取设备信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo lshw -businfo</span></span><br><span class="line">[sudo] password for arttnba3:</span><br><span class="line">Bus info          Device       Class          Description</span><br><span class="line">=========================================================</span><br><span class="line">                               system         Alibaba Cloud ECS</span><br><span class="line">                               bus            Motherboard</span><br><span class="line">                               memory         96KiB BIOS</span><br><span class="line">cpu@0                          processor      Intel(R) Xeon(R) Platinum 8163 CPU @ 2.50GHz</span><br><span class="line">                               memory         2GiB System Memory</span><br><span class="line">                               memory         2GiB DIMM RAM</span><br><span class="line">pci@0000:00:00.0               bridge         440FX - 82441FX PMC [Natoma]</span><br><span class="line">pci@0000:00:01.0               bridge         82371SB PIIX3 ISA [Natoma/Triton II]</span><br><span class="line">pci@0000:00:01.1               storage        82371SB PIIX3 IDE [Natoma/Triton II]</span><br><span class="line">pci@0000:00:01.2               bus            82371SB PIIX3 USB [Natoma/Triton II]</span><br><span class="line">usb@1             usb1         bus            UHCI Host Controller</span><br><span class="line">usb@1:1                        input          QEMU USB Tablet</span><br><span class="line">pci@0000:00:01.3               bridge         82371AB/EB/MB PIIX4 ACPI</span><br><span class="line">pci@0000:00:02.0               display        GD 5446</span><br><span class="line">pci@0000:00:03.0               network        Virtio network device</span><br><span class="line">virtio@0          eth0         network        Ethernet interface</span><br><span class="line">pci@0000:00:04.0               communication  Virtio console</span><br><span class="line">virtio@1                       generic        Virtual I/O device</span><br><span class="line">pci@0000:00:05.0               storage        Virtio block device</span><br><span class="line">virtio@2          /dev/vda     disk           42GB Virtual I/O device</span><br><span class="line">virtio@2,1        /dev/vda1    volume         39GiB EXT4 volume</span><br><span class="line">pci@0000:00:06.0               generic        Virtio memory balloon</span><br><span class="line">virtio@3                       generic        Virtual I/O device</span><br><span class="line">                               system         PnP device PNP0b00</span><br><span class="line">                               input          PnP device PNP0303</span><br><span class="line">                               input          PnP device PNP0f13</span><br><span class="line">                               storage        PnP device PNP0700</span><br><span class="line">                               communication  PnP device PNP0501</span><br><span class="line">                  veth073b1a5  network        Ethernet interface</span><br><span class="line">                  veth2c8670f  network        Ethernet interface</span><br><span class="line">                  vethc0202a2  network        Ethernet interface</span><br><span class="line">                  veth49e878e  network        Ethernet interface</span><br></pre></td></tr></table></figure>

<h3 id="II、PCI-设备编号"><a href="#II、PCI-设备编号" class="headerlink" title="II、PCI 设备编号"></a>II、PCI 设备编号</h3><p>每个PCI 设备都有着三个编号：总线编号（Bus Number）、设备编号（Device Number）与功能编号（Function Number），作为设备的唯一标识；在此之上还有 PCI 域的概念，一个 PCI 域上最多可以连接 256 根 PCI 总线</p>
<p>当我们使用 <code>lspci</code> 命令查看 PCI 设备信息时，在每个设备开头都可以看到形如 <code>xx:yy.z</code> 的十六进制编号，这个格式其实是 <code>总线编号:设备编号.功能编号</code>，当我们使用 <code>lspci -v </code>查看 PCI 设备信息时，在总线编号前面的 4 位数字便是 PCI 域的编号</p>
<h3 id="III、PCI-设备配置空间"><a href="#III、PCI-设备配置空间" class="headerlink" title="III、PCI 设备配置空间"></a>III、PCI 设备配置空间</h3><p>每个 PCI 逻辑设备中都有着其自己的<strong>配置空间</strong>（configuration space），通常是设备地址空间的前 64 字节（新版的设备还扩展了 0x40~0xFF 这段配置空间），其中存放了一些设备的基本信息，如生厂商信息、IRQ中断号、mem 空间与 io 空间的起始地址与大小等</p>
<p>Intel 芯片组中我们可以使用 IO 空间的 <code>CF8/CFC</code> 地址（端口）来访问 PCI 设备的配置寄存器：</p>
<ul>
<li><code>CF8</code>：<strong>CONFIG_ADDRESS</strong>，即 PCI 配置空间地址端口。</li>
<li><code>CFH</code>：<strong>CONFIG_DATA</strong>，即 PCI 配置空间数据端口。</li>
</ul>
<p>当我们往 <code>CONFIG_ADDRESS</code> 端口填入对应的设备标识后，就可以从 <code>CONFIG_DATA</code> 端口上读写 PCI 配置空间的内存， <code>CONFIG_ADDRESS</code> 端口的格式如下：</p>
<ul>
<li><code>31</code> 位：Enable 位</li>
<li><code>23:16</code> 位：总线编号</li>
<li><code>15:11</code> 位：设备编号</li>
<li><code>10:8</code> 位：功能编号</li>
<li><code>7:2</code> 位：配置空间寄存器编号</li>
<li><code>1:0</code> 位：恒为 <code>00</code></li>
</ul>
<blockquote>
<p>除了通过端口访问外，我们也可以通过 MMIO 的方式访问一个 PCI 设备的地址空间</p>
</blockquote>
<p>现在我们来看 PCI 配置空间的结构，PCI 设备分为 <code>Bridge</code> 与 <code>Agent</code> 两类，故配置空间也分为相应的两类</p>
<p>Agent 类型配置空间又被称为 <code>Type 00h</code>，格式如下图所示：</p>
<p><img src="https://s2.loli.net/2022/07/21/CEpqkAM1D78XRLG.png" alt="image.png"></p>
<p>相应地，Bridge 类型配置空间被称为 <code>Type 01h</code>，与 Agent 类型配置空间大同小异：</p>
<p><img src="https://s2.loli.net/2022/07/21/emyrRVo5W6X12aG.png" alt="image.png"></p>
<p>简单介绍几个比较重要的字段：</p>
<ul>
<li><p>设备标识相关：</p>
<ul>
<li><p><code>Vendor ID</code>：生产厂商的 ID，例如 Intel 设备通常为 <code>0x8086</code></p>
</li>
<li><p><code>Device ID</code>：具体设备的 ID，通常也是由厂家自行指定的</p>
</li>
<li><p><code>Class Code</code>：类代码，用于区分设备类型</p>
</li>
<li><p><code>Revision ID</code>：PCI 设备的版本号，可以看作 Device ID 的扩展</p>
</li>
</ul>
</li>
<li><p>设备状态相关：</p>
<ul>
<li><p><code>Status</code>：设备的状态字寄存器，各 bit 含义如下图所示：</p>
<p><img src="https://s2.loli.net/2022/07/21/ZTplAr87OQ96cRU.png" alt="image.png"></p>
</li>
<li><p><code>Command</code>：设备的状态字寄存器，各 bit 含义如下图所示：</p>
<p><img src="https://s2.loli.net/2022/07/21/rM3YhuaoPK25mNn.png" alt="image.png"></p>
</li>
</ul>
</li>
<li><p>设备配置相关：</p>
<ul>
<li><p><code>Base Address Registers</code>：决定了 PCI 设备空间映射到系统空间的具体位置，有两种映射方式：MMIO 与 PMIO，映射方式由最低位决定，不可更改</p>
<ul>
<li><p>MMIO 下的 BAR：</p>
<p><img src="https://s2.loli.net/2022/07/21/CzV32oBP71at9Fg.png" alt="image.png"></p>
</li>
<li><p>PMIO 下的 BAR：</p>
<p><img src="https://s2.loli.net/2022/07/21/w4ind36EF9pPLcy.png" alt="image.png"></p>
</li>
</ul>
</li>
<li><p><code>Interrupt Pin</code>：中断引脚，该寄存器表示设备所连接的引脚</p>
</li>
<li><p><code>Interrupt Line</code>：中断编号</p>
</li>
</ul>
</li>
</ul>
<p>前面我们讲到 lspci 命令，我们可以使用 <code>-s</code> 来通过指定查看的具体 PCI 设备，通过 <code>-m</code> 查看部分信息，通过 <code>-nn</code> 查看比较详细的信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">lspci -vv -s 00:02.0 -m</span></span><br><span class="line">Device: 00:02.0</span><br><span class="line">Class:  VGA compatible controller</span><br><span class="line">Vendor: Cirrus Logic</span><br><span class="line">Device: GD 5446</span><br><span class="line">SVendor:        Red Hat, Inc.</span><br><span class="line">SDevice:        QEMU Virtual Machine</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">lspci -vv -s 00:02.0 -nn</span></span><br><span class="line">00:02.0 VGA compatible controller [0300]: Cirrus Logic GD 5446 [1013:00b8] (prog-if 00 [VGA controller])</span><br><span class="line">        Subsystem: Red Hat, Inc. QEMU Virtual Machine [1af4:1100]</span><br><span class="line">        Control: I/O+ Mem+ BusMaster- SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR+ FastB2B- DisINTx-</span><br><span class="line">        Status: Cap- 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast &gt;TAbort- &lt;TAbort- &lt;MAbort- &gt;SERR- &lt;PERR- INTx-</span><br><span class="line">        Region 0: Memory at fc000000 (32-bit, prefetchable) [size=32M]</span><br><span class="line">        Region 1: Memory at febd0000 (32-bit, non-prefetchable) [size=4K]</span><br><span class="line">        Expansion ROM at 000c0000 [disabled] [size=128K]</span><br><span class="line">        Kernel driver in use: cirrus</span><br><span class="line">        Kernel modules: cirrusfb, cirrus</span><br></pre></td></tr></table></figure>

<p>我们还可以直接使用 <code>-x</code> 参数来查看 PCI 设备的配置空间：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">lspci -s 00:02.0 -x</span></span><br><span class="line">00:02.0 VGA compatible controller: Cirrus Logic GD 5446</span><br><span class="line">00: 13 10 b8 00 03 01 00 00 00 00 00 03 00 00 00 00</span><br><span class="line">10: 08 00 00 fc 00 00 bd fe 00 00 00 00 00 00 00 00</span><br><span class="line">20: 00 00 00 00 00 00 00 00 00 00 00 00 f4 1a 00 11</span><br><span class="line">30: 00 00 bc fe 00 00 00 00 00 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure>

<p>在 Linux 当中我们也可以通过 procfs 或 sysfs 这样的文件系统来查看设备的相关配置信息，例如通过 <code>/proc/bus/pci/00/00.0</code> 文件我们同样可以查看 PCI 设备 <code>00:02.0</code> 的配置空间：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /proc/bus/pci/00/02.0 | xxd</span></span><br><span class="line">00000000: 1310 b800 0301 0000 0000 0003 0000 0000  ................</span><br><span class="line">00000010: 0800 00fc 0000 bdfe 0000 0000 0000 0000  ................</span><br><span class="line">00000020: 0000 0000 0000 0000 0000 0000 f41a 0011  ................</span><br><span class="line">00000030: 0000 bcfe 0000 0000 0000 0000 0000 0000  ................</span><br></pre></td></tr></table></figure>

<p>通过 <code>/sys/devices/pci0000:00/0000:00:02.0/resource</code> 获取到的信息中每行表示一个地址空间，其中第一行为 MMIO，第二行为 PMIO，三列信息分别为起始地址、终止地址、标志位 ，：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">cat</span> /sys/devices/pci0000\:00/0000\:00\:02.0/resource</span></span><br><span class="line">0x00000000fc000000 0x00000000fdffffff 0x0000000000042208</span><br><span class="line">0x00000000febd0000 0x00000000febd0fff 0x0000000000040200</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x00000000000c0000 0x00000000000dffff 0x0000000000000212</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>通过 <code>/sys/devices/pci0000:00/0000:00:02.0</code> 下的其他文件也可以访问该设备的一些其他资源信息（例如通过 <code>resource0</code> 可以直接访问 MMIO 空间，<code>resource1</code> 则为其 PMIO 空间）</p>
<h3 id="IV、PCI-设备内存-amp-端口空间与访问方式"><a href="#IV、PCI-设备内存-amp-端口空间与访问方式" class="headerlink" title="IV、PCI 设备内存 &amp; 端口空间与访问方式"></a>IV、PCI 设备内存 &amp; 端口空间与访问方式</h3><p>前面我们讲了 PCI 设备与特性和配置相关的配置空间，现在我们来看与 PCI 设备与实际操作相关的内存映射空间与端口映射空间</p>
<p>所有 IO 设备的内存与端口空间需要被映射到对应的地址空间&#x2F;端口空间中才能访问，这需要占用部分的内存地址空间与端口地址空间，即我们有两种映射外设资源的方式：</p>
<ul>
<li><strong>MMIO</strong>（Memory-mapped I&#x2F;O）：即内存映射 IO。这种方式将 IO 设备的内存与寄存器映射到指定的内存地址空间上，此时我们便可以通过常规的访问内存的方式来直接访问到设备的寄存器与内存</li>
<li><strong>PMIO</strong>（Port-mapped I&#x2F;O）：即端口映射 IO。这种方式将 IO 设备的寄存器编码到指定的端口上，我们需要通过访问端口的方式来访问设备的寄存器与内存（例如在 x86 下通过 <code>in</code> 与 <code>out</code> 这一类的指令可以读写端口）。IO 设备通过专用的针脚或者专用的总线与 CPU 连接，这与内存地址空间相独立，因此又称作 isolated I&#x2F;O</li>
</ul>
<p>完成映射之后通过相应的内存&#x2F;端口访问到的便是 PCI 设备的内存&#x2F;端口地址空间</p>
<blockquote>
<p>例如实模式下的 <code>0xA0000 ~ 0xBFFFF</code> 这 128KB 地址空间通常被用作显存的映射，当我们在实模式下读写这块区域时通常便是直接读写显卡上的显存，而并非普通的内存</p>
</blockquote>
<p>通过 procfs 的 <code>/proc/iomem</code> 我们可以查看物理地址空间的情况，其中我们便能看到各种设备所占用的地址空间</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">cat</span> /proc/iomem</span></span><br><span class="line">00000000-00000fff : Reserved</span><br><span class="line">00001000-0009fbff : System RAM</span><br><span class="line">0009fc00-0009ffff : Reserved</span><br><span class="line">000a0000-000bffff : PCI Bus 0000:00</span><br><span class="line">000c0000-000c91ff : Video ROM</span><br><span class="line">000c9800-000ca1ff : Adapter ROM</span><br><span class="line">000ca800-000ccbff : Adapter ROM</span><br><span class="line">000f0000-000fffff : Reserved</span><br><span class="line">  000f0000-000fffff : System ROM</span><br><span class="line">00100000-7ffdffff : System RAM</span><br><span class="line">  1f400000-20200e70 : Kernel code</span><br><span class="line">  20200e71-2105843f : Kernel data</span><br><span class="line">  2132b000-217fffff : Kernel bss</span><br><span class="line">7ffe0000-7fffffff : Reserved</span><br><span class="line">80000000-febfffff : PCI Bus 0000:00</span><br><span class="line">  fc000000-fdffffff : 0000:00:02.0</span><br><span class="line">    fc000000-fdffffff : cirrus</span><br><span class="line">  feb80000-febbffff : 0000:00:03.0</span><br><span class="line">  febd0000-febd0fff : 0000:00:02.0</span><br><span class="line">    febd0000-febd0fff : cirrus</span><br><span class="line">  febd1000-febd1fff : 0000:00:03.0</span><br><span class="line">  febd2000-febd2fff : 0000:00:04.0</span><br><span class="line">  febd3000-febd3fff : 0000:00:05.0</span><br><span class="line">fec00000-fec003ff : IOAPIC 0</span><br><span class="line">fee00000-fee00fff : Local APIC</span><br><span class="line">feffc000-feffffff : Reserved</span><br><span class="line">fffc0000-ffffffff : Reserved</span><br></pre></td></tr></table></figure>

<p>通过 procfs 的 <code>/proc/ioports</code> 我们可以查看 IO 端口情况，其中便包括各种设备对应的 PMIO 端口：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">cat</span> /proc/ioports</span></span><br><span class="line">0000-0cf7 : PCI Bus 0000:00</span><br><span class="line">  0000-001f : dma1</span><br><span class="line">  0020-0021 : pic1</span><br><span class="line">  0040-0043 : timer0</span><br><span class="line">  0050-0053 : timer1</span><br><span class="line">  0060-0060 : keyboard</span><br><span class="line">  0064-0064 : keyboard</span><br><span class="line">  0070-0071 : rtc0</span><br><span class="line">  0080-008f : dma page reg</span><br><span class="line">  00a0-00a1 : pic2</span><br><span class="line">  00c0-00df : dma2</span><br><span class="line">  00f0-00ff : fpu</span><br><span class="line">  0170-0177 : 0000:00:01.1</span><br><span class="line">    0170-0177 : ata_piix</span><br><span class="line">  01f0-01f7 : 0000:00:01.1</span><br><span class="line">    01f0-01f7 : ata_piix</span><br><span class="line">  0376-0376 : 0000:00:01.1</span><br><span class="line">    0376-0376 : ata_piix</span><br><span class="line">  03f2-03f2 : floppy</span><br><span class="line">  03f4-03f5 : floppy</span><br><span class="line">  03f6-03f6 : 0000:00:01.1</span><br><span class="line">    03f6-03f6 : ata_piix</span><br><span class="line">  03f7-03f7 : floppy</span><br><span class="line">  03f8-03ff : serial</span><br><span class="line">  0505-0505 : QEMU0001:00</span><br><span class="line">  0510-051b : QEMU0002:00</span><br><span class="line">    0510-051b : fw_cfg_io</span><br><span class="line">  0600-063f : 0000:00:01.3</span><br><span class="line">    0600-0603 : ACPI PM1a_EVT_BLK</span><br><span class="line">    0604-0605 : ACPI PM1a_CNT_BLK</span><br><span class="line">    0608-060b : ACPI PM_TMR</span><br><span class="line">  0700-070f : 0000:00:01.3</span><br><span class="line">    0700-0708 : piix4_smbus</span><br><span class="line">0cf8-0cff : PCI conf1</span><br><span class="line">0d00-adff : PCI Bus 0000:00</span><br><span class="line">ae0f-aeff : PCI Bus 0000:00</span><br><span class="line">af20-afdf : PCI Bus 0000:00</span><br><span class="line">afe0-afe3 : ACPI GPE0_BLK</span><br><span class="line">afe4-ffff : PCI Bus 0000:00</span><br><span class="line">  c000-c03f : 0000:00:05.0</span><br><span class="line">    c000-c03f : virtio-pci-legacy</span><br><span class="line">  c040-c05f : 0000:00:01.2</span><br><span class="line">    c040-c05f : uhci_hcd</span><br><span class="line">  c060-c07f : 0000:00:03.0</span><br><span class="line">    c060-c07f : virtio-pci-legacy</span><br><span class="line">  c080-c09f : 0000:00:04.0</span><br><span class="line">    c080-c09f : virtio-pci-legacy</span><br><span class="line">  c0a0-c0bf : 0000:00:06.0</span><br><span class="line">    c0a0-c0bf : virtio-pci-legacy</span><br><span class="line">  c0c0-c0cf : 0000:00:01.1</span><br><span class="line">    c0c0-c0cf : ata_piix</span><br></pre></td></tr></table></figure>



<h2 id="二、Qemu-Object-Model"><a href="#二、Qemu-Object-Model" class="headerlink" title="二、Qemu Object Model"></a>二、Qemu Object Model</h2><p>虽然 Qemu 是使用 C 编写的，但是其代码也充满了 OOP 的思想，在 Qemu 当中有着一套叫做 <strong>Qemu Object Model</strong> 的东西来实现面向对象，主要由这四个组件构成：</p>
<ul>
<li><code>Type</code>：用来定义一个「类」的基本属性，例如类的名字、大小、构造函数等</li>
<li><code>Class</code>：用来定义一个「类」的静态内容，例如类中存储的静态数据、方法函数指针等</li>
<li><code>Object</code>：动态分配的一个「类」的具体的实例（instance），储存类的动态数据</li>
<li><code>Property</code>：动态对象数据的访问器（accessor），可以通过监视器接口进行检查</li>
</ul>
<p>类似于 Golang，在 QOM 当中使用成员嵌套的方式来完成类的继承，父类作为类结构体的第一个成员 <code>parent</code> 而存在，因此也不支持多继承</p>
<blockquote>
<p>参见这个<a target="_blank" rel="noopener" href="https://www.linux-kvm.org/images/f/f6/2012-forum-QOM_CPU.pdf">ppt</a></p>
</blockquote>
<h3 id="I、TypeInfo-类的基本属性"><a href="#I、TypeInfo-类的基本属性" class="headerlink" title="I、TypeInfo - 类的基本属性"></a>I、TypeInfo - 类的基本属性</h3><p><code>TypeInfo</code> 这一结构体用来定义一个「类」的基本属性，该结构体定义于 <code>include/qom/object.h</code> 当中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TypeInfo:</span></span><br><span class="line"><span class="comment"> * @name: 类型名.</span></span><br><span class="line"><span class="comment"> * @parent: 父类型名.</span></span><br><span class="line"><span class="comment"> * @instance_size: 对象大小 (#Object 的衍生物). </span></span><br><span class="line"><span class="comment"> *   若 @instance_size 为 0, 则对象的大小为其父类的大小</span></span><br><span class="line"><span class="comment"> * @instance_init: 该函数被调用以初始化对象（译注：构造函数）. </span></span><br><span class="line"><span class="comment"> *   （译注：调用前）父类已被初始化，因此子类只需要初始化他自己的成员。</span></span><br><span class="line"><span class="comment"> * @instance_post_init: 该函数被调用以结束一个对象的初始化，</span></span><br><span class="line"><span class="comment"> *   在所有的 @instance_init 函数被调用之后.</span></span><br><span class="line"><span class="comment"> * @instance_finalize: 该函数在对象被析构时调用. 其在</span></span><br><span class="line"><span class="comment"> *   父类的 @instance_finalize 被调用之前被调用.</span></span><br><span class="line"><span class="comment"> *   在该函数中一个对象应当仅释放该对象特有的成员。</span></span><br><span class="line"><span class="comment"> * @abstract: 若该域为真，则该类为一个虚类，不能被直接实例化。</span></span><br><span class="line"><span class="comment"> * @class_size: 这个对象的类对象的大小 (#Object 的衍生物)</span></span><br><span class="line"><span class="comment"> *   若 @class_size 为 0, 则类的大小为其父类的大小。</span></span><br><span class="line"><span class="comment"> *   这允许一个类型在没有添加额外的虚函数时避免实现一个显式的类型。</span></span><br><span class="line"><span class="comment"> * @class_init: 该函数在所有父类初始化结束后被调用，</span></span><br><span class="line"><span class="comment"> *   以允许一个类设置他的默认虚方法指针.</span></span><br><span class="line"><span class="comment"> *   这也允许该函数重写父类的虚方法。</span></span><br><span class="line"><span class="comment"> * @class_base_init: 在所有的父类被初始化后、但</span></span><br><span class="line"><span class="comment"> *   在类自身初始化前，为所有的基类调用该函数。</span></span><br><span class="line"><span class="comment"> *   该函数用以撤销从父类 memcpy 到子类的影响.</span></span><br><span class="line"><span class="comment"> * @class_data: 传递给 @class_init 与 @class_base_init 的数据,</span></span><br><span class="line"><span class="comment"> *   这会在建立动态类型时有用。</span></span><br><span class="line"><span class="comment"> * @interfaces: 与这个类型相关的接口. </span></span><br><span class="line"><span class="comment"> *   其应当指向一个以 0 填充元素结尾的静态数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TypeInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *parent;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> instance_size;</span><br><span class="line">    <span class="type">void</span> (*instance_init)(Object *obj);</span><br><span class="line">    <span class="type">void</span> (*instance_post_init)(Object *obj);</span><br><span class="line">    <span class="type">void</span> (*instance_finalize)(Object *obj);</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> abstract;</span><br><span class="line">    <span class="type">size_t</span> class_size;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*class_init)(ObjectClass *klass, <span class="type">void</span> *data);</span><br><span class="line">    <span class="type">void</span> (*class_base_init)(ObjectClass *klass, <span class="type">void</span> *data);</span><br><span class="line">    <span class="type">void</span> *class_data;</span><br><span class="line"></span><br><span class="line">    InterfaceInfo *interfaces;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当我们在 Qemu 中要定义一个「类」的时候，我们实际上需要定义一个 TypeInfo 类型的变量，例如下面就是一个在 Qemu 定义一个自定义类的🌰：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> TypeInfo a3_type_info = &#123;</span><br><span class="line">    .name = <span class="string">&quot;a3_type&quot;</span>,</span><br><span class="line">    .parent = TYPE_OBJECT,</span><br><span class="line">    .interfaces = (InterfaceInfo[]) &#123;</span><br><span class="line">        &#123; &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> a3_register_types(<span class="type">void</span>) &#123;</span><br><span class="line">    type_register_static(&amp;a3_type_info);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type_init(a3_register_types);</span><br></pre></td></tr></table></figure>

<p><code>type_init()</code> 其实就是 <code>constructor</code> 这一 gcc attribute 的封装，其作用就是将一个函数加入到一个 <code>init_array</code> 当中，在 Qemu 程序启动时在进入到 main 函数之前会先调用 <code>init_array</code> 中的函数，因此这里会调用我们自定义的函数，其作用便是调用 <code>type_register_static()</code> 将我们自定义的类型 <code>a3_type_info</code> 注册到全局的类型表中</p>
<h3 id="II、Class-类的静态内容"><a href="#II、Class-类的静态内容" class="headerlink" title="II、Class - 类的静态内容"></a>II、Class - 类的静态内容</h3><p>当我们通过一个 <code>TypeInfo</code> 结构体定义了一个类之后，我们还需要定义一个 Class 结构体来定义这个类的静态内容，包括函数表、静态成员等，其应当继承于对应的 Class 结构体类型，例如我们若是要定义一个新的机器类，则其 Class 应当继承于 <code>MachineClass</code></p>
<p>所有 Class 结构体类型的最终的父类都是 <code>ObjectClass</code> 结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ObjectClass:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 所有类的基类.  #ObjectClass 仅包含一个整型类型 handler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ObjectClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    Type type;</span><br><span class="line">    GSList *interfaces;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *object_cast_cache[OBJECT_CLASS_CAST_CACHE];</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *class_cast_cache[OBJECT_CLASS_CAST_CACHE];</span><br><span class="line"></span><br><span class="line">    ObjectUnparent *unparent;</span><br><span class="line"></span><br><span class="line">    GHashTable *properties;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下面是一个最简单的🌰：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A3Class</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    ObjectClass parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完成 Class 的定义之后我们还应当在前面定义的 <code>a3_type_info</code> 中添加上 Class size 与 Class 的构造函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">a3_class_init</span><span class="params">(ObjectClass *oc, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 这里的 oc 参数便是新创建的 Class，全局只有一个该实例</span></span><br><span class="line">    <span class="comment">// 我们应当 cast 为我们自己的 Class 类型，之后再进行相应操作</span></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> TypeInfo a3_type_info = &#123;</span><br><span class="line">    .name = <span class="string">&quot;a3_type&quot;</span>,</span><br><span class="line">    .parent = TYPE_OBJECT,</span><br><span class="line">    .class_size = <span class="keyword">sizeof</span>(A3Class),</span><br><span class="line">    .class_init = a3_class_init,</span><br><span class="line">    .interfaces = (InterfaceInfo[]) &#123;</span><br><span class="line">        &#123; &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="III、Object-类的实例对象"><a href="#III、Object-类的实例对象" class="headerlink" title="III、Object - 类的实例对象"></a>III、Object - 类的实例对象</h3><p>我们还需要定义一个相应的 Object 类型来表示一个实例对象，其包含有这个类实际的具体数据，且应当继承于对应的 Object 结构体类型，例如我们若是要定义一个新的机器类型，其实例类型应当继承自 <code>MachineState</code></p>
<p>所有 Object 结构体类型的最终的父类都是 <code>Object</code> 结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Object:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 所有对象的基类。该对象的第一个成员为一个指向 #ObjectClass 的指针。</span></span><br><span class="line"><span class="comment"> * 因为 C 中将一个结构体的第一个成员组织在该结构体的 0 字节起始处，</span></span><br><span class="line"><span class="comment"> * 只要任何的子类将其父类作为第一个成员，我们都能直接转化为一个 #Object.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 因此, #Object 包含一个对对象类的引用作为其第一个成员。 </span></span><br><span class="line"><span class="comment"> * 这允许在运行时识别对象的真实类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Object</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    ObjectClass *<span class="class"><span class="keyword">class</span>;</span></span><br><span class="line">    ObjectFree *<span class="built_in">free</span>;</span><br><span class="line">    GHashTable *properties;</span><br><span class="line">    <span class="type">uint32_t</span> ref;</span><br><span class="line">    Object *parent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下面是一个🌰：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A3Object</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    Object parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完成 Object 的定义之后我们还应当在前面定义的 <code>a3_type_info</code> 中添加上 Object size 与 Object 的构造函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">a3_object_init</span><span class="params">(Object *obj)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 这里的 obj 参数便是动态创建的类型实例</span></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> TypeInfo a3_type_info = &#123;</span><br><span class="line">    .name = <span class="string">&quot;a3_type&quot;</span>,</span><br><span class="line">    .parent = TYPE_OBJECT,</span><br><span class="line">    .instance_init = a3_object_init,</span><br><span class="line">    .instance_size = <span class="keyword">sizeof</span>(A3Object),</span><br><span class="line">    .class_size = <span class="keyword">sizeof</span>(A3Class),</span><br><span class="line">    .class_init = a3_class_init,</span><br><span class="line">    .interfaces = (InterfaceInfo[]) &#123;</span><br><span class="line">        &#123; &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="IV、类的创建与释放"><a href="#IV、类的创建与释放" class="headerlink" title="IV、类的创建与释放"></a>IV、类的创建与释放</h3><p>类似于在 C++ 当中使用 <code>new</code> 与 <code>delete</code> 来创建与释放一个类实例，在 QOM 中我们应当使用 <code>object_new()</code> 与 <code>object_delete()</code> 来创建与销毁一个 QOM 类实例，本质上就是 <code>分配/释放类空间 + 显示调用构造/析构函数</code></p>
<p>QOM 判断创建类实例的类型是通过类的名字，即 <code>TypeInfo-&gt;name</code>，当创建类实例时 Qemu 会遍历所有的 TypeInfo 并寻找名字匹配的那个，从而调用到对应的构造函数，并将其基类 <code>Object-&gt;class</code> 指向对应的 class</p>
<p>下面是一个🌰：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create a QOM object</span></span><br><span class="line">A3Object *a3obj = object_new(<span class="string">&quot;a3_type&quot;</span>);</span><br><span class="line"><span class="comment">// delete a QOM object</span></span><br><span class="line">object_delete(a3obj);</span><br></pre></td></tr></table></figure>

<h2 id="三、MemoryRegion-Qemu-中的一块内存区域"><a href="#三、MemoryRegion-Qemu-中的一块内存区域" class="headerlink" title="三、MemoryRegion - Qemu 中的一块内存区域"></a>三、MemoryRegion - Qemu 中的一块内存区域</h2><p>在 Qemu 当中使用 <code>MemoryRegion</code> 结构体类型来表示一块具体的 Guest 物理内存区域，该结构体定义于 <code>include/exec/memory.h</code> 当中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** MemoryRegion:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 表示一块内存区域的一个结构体.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MemoryRegion</span> &#123;</span></span><br><span class="line">    Object parent_obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* private: */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The following fields should fit in a cache line */</span></span><br><span class="line">    <span class="type">bool</span> romd_mode;</span><br><span class="line">    <span class="type">bool</span> ram;</span><br><span class="line">    <span class="type">bool</span> subpage;</span><br><span class="line">    <span class="type">bool</span> readonly; <span class="comment">/* For RAM regions */</span></span><br><span class="line">    <span class="type">bool</span> nonvolatile;</span><br><span class="line">    <span class="type">bool</span> rom_device;</span><br><span class="line">    <span class="type">bool</span> flush_coalesced_mmio;</span><br><span class="line">    <span class="type">bool</span> global_locking;</span><br><span class="line">    <span class="type">uint8_t</span> dirty_log_mask;</span><br><span class="line">    <span class="type">bool</span> is_iommu;</span><br><span class="line">    RAMBlock *ram_block;</span><br><span class="line">    Object *owner;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> MemoryRegionOps *ops;</span><br><span class="line">    <span class="type">void</span> *opaque;</span><br><span class="line">    MemoryRegion *container;	<span class="comment">// 指向父 MemoryRegion</span></span><br><span class="line">    Int128 size;	<span class="comment">// 内存区域大小</span></span><br><span class="line">    hwaddr addr;	<span class="comment">// 在父 MR 中的偏移量</span></span><br><span class="line">    <span class="type">void</span> (*destructor)(MemoryRegion *mr);</span><br><span class="line">    <span class="type">uint64_t</span> align;</span><br><span class="line">    <span class="type">bool</span> terminates;</span><br><span class="line">    <span class="type">bool</span> ram_device;</span><br><span class="line">    <span class="type">bool</span> enabled;</span><br><span class="line">    <span class="type">bool</span> warning_printed; <span class="comment">/* For reservations */</span></span><br><span class="line">    <span class="type">uint8_t</span> vga_logging_count;</span><br><span class="line">    MemoryRegion *alias;	<span class="comment">// 仅在 alias MR 中，指向实际的 MR</span></span><br><span class="line">    hwaddr alias_offset;</span><br><span class="line">    <span class="type">int32_t</span> priority;</span><br><span class="line">    QTAILQ_HEAD(, MemoryRegion) subregions;</span><br><span class="line">    QTAILQ_ENTRY(MemoryRegion) subregions_link;</span><br><span class="line">    QTAILQ_HEAD(, CoalescedMemoryRange) coalesced;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">unsigned</span> ioeventfd_nb;</span><br><span class="line">    MemoryRegionIoeventfd *ioeventfds;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在 Qemu 当中有三种类型的 MemoryRegion：</p>
<ul>
<li>MemoryRegion 根：通过 <code>memory_region_init()</code> 进行初始化，其用以表示与管理由多个 sub-MemoryRegion 组成的一个内存区域，并不实际指向一块内存区域，例如 <code>system_memory</code></li>
<li>MemoryRegion 实体：通过 <code>memory_region_init_ram()</code> 初始化，表示具体的一块大小为 size 的内存空间，指向一块具体的内存</li>
<li>MemoryRegion 别名：通过 <code>memory_region_init_alias()</code> 初始化，作为另一个 MemoryRegion 实体的别名而存在，不指向一块实际内存</li>
</ul>
<p>MR 容器与 MR 实体间构成树形结构，其中容器为根节点而实体为子节点：</p>
<blockquote>
<p>下图来自于<a target="_blank" rel="noopener" href="https://richardweiyang-2.gitbook.io/understanding_qemu/00-as/02-memoryregion">这里</a></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">                       struct MemoryRegion</span><br><span class="line">                       +------------------------+                                         </span><br><span class="line">                       |name                    |                                         </span><br><span class="line">                       |  (const char *)        |                                         </span><br><span class="line">                       +------------------------+                                         </span><br><span class="line">                       |addr                    |                                         </span><br><span class="line">                       |  (hwaddr)              |                                         </span><br><span class="line">                       |size                    |                                         </span><br><span class="line">                       |  (Int128)              |                                         </span><br><span class="line">                       +------------------------+                                         </span><br><span class="line">                       |subregions              |                                         </span><br><span class="line">                       |    QTAILQ_HEAD()       |                                         </span><br><span class="line">                       +------------------------+                                         </span><br><span class="line">                                  |</span><br><span class="line">                                  |</span><br><span class="line">          ----+-------------------+---------------------+----</span><br><span class="line">              |                                         |</span><br><span class="line">              |                                         |</span><br><span class="line">              |                                         |</span><br><span class="line"></span><br><span class="line">struct MemoryRegion                            struct MemoryRegion</span><br><span class="line">+------------------------+                     +------------------------+</span><br><span class="line">|name                    |                     |name                    |</span><br><span class="line">|  (const char *)        |                     |  (const char *)        |</span><br><span class="line">+------------------------+                     +------------------------+</span><br><span class="line">|addr                    |                     |addr                    |</span><br><span class="line">|  (hwaddr)              |                     |  (hwaddr)              |</span><br><span class="line">|size                    |                     |size                    |</span><br><span class="line">|  (Int128)              |                     |  (Int128)              |</span><br><span class="line">+------------------------+                     +------------------------+</span><br><span class="line">|subregions              |                     |subregions              |</span><br><span class="line">|    QTAILQ_HEAD()       |                     |    QTAILQ_HEAD()       |</span><br><span class="line">+------------------------+                     +------------------------+</span><br></pre></td></tr></table></figure>

<p>相应地，基于 OOP 的思想，MemoryRegion 的成员函数被封装在函数表 <code>MemoryRegionOps</code> 当中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Memory region callbacks</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MemoryRegionOps</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 从内存区域上读. @addr 与 @mr 有关; @size 单位为字节. */</span></span><br><span class="line">    <span class="type">uint64_t</span> (*read)(<span class="type">void</span> *opaque,</span><br><span class="line">                     hwaddr addr,</span><br><span class="line">                     <span class="type">unsigned</span> size);</span><br><span class="line">    <span class="comment">/* 往内存区域上写. @addr 与 @mr 有关; @size 单位为字节. */</span></span><br><span class="line">    <span class="type">void</span> (*write)(<span class="type">void</span> *opaque,</span><br><span class="line">                  hwaddr addr,</span><br><span class="line">                  <span class="type">uint64_t</span> data,</span><br><span class="line">                  <span class="type">unsigned</span> size);</span><br><span class="line"></span><br><span class="line">    MemTxResult (*read_with_attrs)(<span class="type">void</span> *opaque,</span><br><span class="line">                                   hwaddr addr,</span><br><span class="line">                                   <span class="type">uint64_t</span> *data,</span><br><span class="line">                                   <span class="type">unsigned</span> size,</span><br><span class="line">                                   MemTxAttrs attrs);</span><br><span class="line">    MemTxResult (*write_with_attrs)(<span class="type">void</span> *opaque,</span><br><span class="line">                                    hwaddr addr,</span><br><span class="line">                                    <span class="type">uint64_t</span> data,</span><br><span class="line">                                    <span class="type">unsigned</span> size,</span><br><span class="line">                                    MemTxAttrs attrs);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">device_endian</span> <span class="title">endianness</span>;</span></span><br><span class="line">    <span class="comment">/* Guest可见约束: */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="comment">/* 若非 0，则指定了超出机器检查范围的访问大小界限</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">unsigned</span> min_access_size;</span><br><span class="line">        <span class="type">unsigned</span> max_access_size;</span><br><span class="line">        <span class="comment">/* If true, unaligned accesses are supported.  Otherwise unaligned</span></span><br><span class="line"><span class="comment">         * accesses throw machine checks.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">         <span class="type">bool</span> unaligned;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 若存在且 #false, 则该事务不会被设备所接受</span></span><br><span class="line"><span class="comment">         * (并导致机器的相关行为，例如机器检查异常).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">bool</span> (*accepts)(<span class="type">void</span> *opaque, hwaddr addr,</span><br><span class="line">                        <span class="type">unsigned</span> size, <span class="type">bool</span> is_write,</span><br><span class="line">                        MemTxAttrs attrs);</span><br><span class="line">    &#125; valid;</span><br><span class="line">    <span class="comment">/* 内部应用约束: */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="comment">/* 若非 0，则决定了最小的实现的 size .</span></span><br><span class="line"><span class="comment">         * 更小的 size 将被向上回绕，且将返回部分结果.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">unsigned</span> min_access_size;</span><br><span class="line">        <span class="comment">/* 若非 0，则决定了最大的实现的 size . </span></span><br><span class="line"><span class="comment">         * 更大的 size 将被作为一系列的更小的 size 的访问而完成.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">unsigned</span> max_access_size;</span><br><span class="line">        <span class="comment">/* 若为 true, 支持非对齐的访问.  </span></span><br><span class="line"><span class="comment">         * 否则所有的访问都将被转换为（可能多种）对齐的访问.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">bool</span> unaligned;</span><br><span class="line">    &#125; impl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当我们的 Guest 要读写虚拟机上的内存时，在 Qemu 内部实际上会调用 <code>address_space_rw()</code>，对于一般的 RAM 内存而言则直接对 MR 对应的内存进行操作，对于 MMIO 而言则最终调用到对应的 <code>MR-&gt;ops-&gt;read()</code> 或 <code>MR-&gt;ops-&gt;write()</code></p>
<p>关于 Qemu 内存管理更多的内容就暂且不在此展开了，不过现在我们知道的是在 Qemu 中使用 <code>MemoryRegion</code> 结构体来表示一段内存区域，<strong>那么我们同样可以通过在设备中添加 MemoryRegion 的方式来为设备添加内存，从而实现与设备间的 MMIO 通信</strong></p>
<p>同样的，为了统一接口，在 Qemu 当中 <strong>PMIO 的实现同样是通过 MemoryRegion 来完成的</strong></p>
<h2 id="四、Qemu-中-PCI-设备的编写"><a href="#四、Qemu-中-PCI-设备的编写" class="headerlink" title="四、Qemu 中 PCI 设备的编写"></a>四、Qemu 中 PCI 设备的编写</h2><p>在补充了这么多的 Qemu 相关的知识之后，现在我们可以开始在 Qemu 中编写 PCI 设备了，这里笔者将编写一个最简单的 Qemu 设备，并将源码放在 <code>hw/misc/a3dev.c</code> 中</p>
<p>Qemu 当中 PCI 设备实例的基类是 <code>PCIDevice</code>，因此我们应当创建一个继承自 <code>PCIDevice</code> 的类来表示我们的设备实例，这里笔者仅声明了两个 <code>MemoryRegion</code> 用作 MMIO 与 PMIO，以及一个用作数据存储的 buffer：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> A3DEV_BUF_SIZE 0x100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">A3PCIDevState</span> &#123;</span></span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    PCIDevice parent_obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*&lt; public &gt;*/</span></span><br><span class="line">    MemoryRegion mmio;</span><br><span class="line">    MemoryRegion pmio;</span><br><span class="line">    <span class="type">uint8_t</span> buf[A3DEV_BUF_SIZE];</span><br><span class="line">&#125; A3PCIDevState;</span><br></pre></td></tr></table></figure>

<p>以及定义一个空的 Class 模板，继承自 PCI 设备的静态类型 <code>PCIDeviceClass</code>，不过这一步并不是必须的，事实上我们可以直接用 <code>PCIDeviceClass</code> 作为我们设备类的 Class：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">A3PCIDevClass</span> &#123;</span></span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    PCIDeviceClass parent;</span><br><span class="line">&#125; A3PCIDevClass;</span><br></pre></td></tr></table></figure>

<p>以及两个将父类转为子类的宏，因为 QOM 基本函数传递的大都是父类指针，所以我们需要一个宏来进行类型检查 + 转型，这也是 Qemu 中惯用的做法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_A3DEV_PCI <span class="string">&quot;a3dev-pci&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> A3DEV_PCI(obj) \</span></span><br><span class="line"><span class="meta">    OBJECT_CHECK(A3PCIDevState, (obj), TYPE_A3DEV_PCI)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> A3DEV_PCI_GET_CLASS(obj) \</span></span><br><span class="line"><span class="meta">    OBJECT_GET_CLASS(A3PCIDevClass, obj, TYPE_A3DEV_PCI)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> A3DEV_PCI_CLASS(klass) \</span></span><br><span class="line"><span class="meta">    OBJECT_CLASS_CHECK(A3PCIDevClass, klass, TYPE_A3DEV_PCI)</span></span><br></pre></td></tr></table></figure>

<p>下面我们开始定义 MMIO 与 PMIO 的操作函数，这里笔者就简单地设置为读写设备内部的 buffer，并声明上两个 MemoryRegion 对应的函数表，需要注意的是这里传入的 <code>hwaddr</code> 类型参数其实为相对地址而非绝对地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">uint64_t</span></span><br><span class="line"><span class="title function_">a3dev_read</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">unsigned</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    A3PCIDevState *ds = A3DEV_PCI(opaque);</span><br><span class="line">    <span class="type">uint64_t</span> val = ~<span class="number">0LL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">8</span>)</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (addr + size &gt; A3DEV_BUF_SIZE)</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;val, &amp;ds-&gt;buf[addr], size);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">a3dev_write</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">uint64_t</span> val, <span class="type">unsigned</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    A3PCIDevState *ds = A3DEV_PCI(opaque);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">8</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (addr + size &gt; A3DEV_BUF_SIZE)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;ds-&gt;buf[addr], &amp;val, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint64_t</span></span><br><span class="line"><span class="title function_">a3dev_mmio_read</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">unsigned</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a3dev_read(opaque, addr, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint64_t</span></span><br><span class="line"><span class="title function_">a3dev_pmio_read</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">unsigned</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a3dev_read(opaque, addr, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">a3dev_mmio_write</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">uint64_t</span> val, <span class="type">unsigned</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    a3dev_write(opaque, addr, val, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">a3dev_pmio_write</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">uint64_t</span> val, <span class="type">unsigned</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    a3dev_write(opaque, addr, val, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> MemoryRegionOps a3dev_mmio_ops = &#123;</span><br><span class="line">    .read = a3dev_mmio_read,</span><br><span class="line">    .write = a3dev_mmio_write,</span><br><span class="line">    .endianness = DEVICE_LITTLE_ENDIAN,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> MemoryRegionOps a3dev_pmio_ops = &#123;</span><br><span class="line">    .read = a3dev_pmio_read,</span><br><span class="line">    .write = a3dev_pmio_write,</span><br><span class="line">    .endianness = DEVICE_LITTLE_ENDIAN,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后是设备实例的初始化函数，在 <code>PCIDeviceClass</code> 当中定义了一个名为 <code>realize</code> 的函数指针，当 PCI 设备被载入时便会调用这个函数指针指向的函数来初始化，所以这里我们也定义一个自己的初始化函数，不过我们需要做的工作其实基本上就只有初始化两个 <code>MemoryRegion</code>，<code>memory_region_init_io()</code> 会为这两个 <code>MemoryRegion</code> 进行初始化的工作，并设置函数表为我们指定的函数表，<code>pci_register_bar()</code> 则用来注册 BAR：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">a3dev_realize</span><span class="params">(PCIDevice *pci_dev, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    A3PCIDevState *ds = A3DEV_PCI(pci_dev);</span><br><span class="line"></span><br><span class="line">    memory_region_init_io(&amp;ds-&gt;mmio, OBJECT(ds), &amp;a3dev_mmio_ops,</span><br><span class="line">                        pci_dev, <span class="string">&quot;a3dev-mmio&quot;</span>, A3DEV_BUF_SIZE);</span><br><span class="line">    pci_register_bar(pci_dev, <span class="number">0</span>, PCI_BASE_ADDRESS_SPACE_MEMORY, &amp;ds-&gt;mmio);</span><br><span class="line">    memory_region_init_io(&amp;ds-&gt;pmio, OBJECT(ds), &amp;a3dev_pmio_ops,</span><br><span class="line">                        pci_dev, <span class="string">&quot;a3dev-pmio&quot;</span>, A3DEV_BUF_SIZE);</span><br><span class="line">    pci_register_bar(pci_dev, <span class="number">1</span>, PCI_BASE_ADDRESS_SPACE_IO, &amp;ds-&gt;pmio);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后是 Class 与 Object（也就是 instance）的初始化函数，这里需要注意的是在 Class 的初始化函数中我们应当设置父类 <code>PCIDeviceClass</code> 的一系列基本属性（也就是 PCI 设备的基本属性）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">a3dev_instance_init</span><span class="params">(Object *obj)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">a3dev_class_init</span><span class="params">(ObjectClass *oc, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    DeviceClass *dc = DEVICE_CLASS(oc);</span><br><span class="line">    PCIDeviceClass *pci = PCI_DEVICE_CLASS(oc);</span><br><span class="line"></span><br><span class="line">    pci-&gt;realize = a3dev_realize;</span><br><span class="line">    pci-&gt;vendor_id = PCI_VENDOR_ID_QEMU;</span><br><span class="line">    pci-&gt;device_id = <span class="number">0x1919</span>;</span><br><span class="line">    pci-&gt;revision = <span class="number">0x81</span>;</span><br><span class="line">    pci-&gt;class_id = PCI_CLASS_OTHERS;</span><br><span class="line"></span><br><span class="line">    dc-&gt;desc = <span class="string">&quot;arttnba3 test PCI device&quot;</span>;</span><br><span class="line">    set_bit(DEVICE_CATEGORY_MISC, dc-&gt;categories);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后就是为我们的 PCI 设备类型注册 TypeInfo 了，这里别忘了<strong>我们的接口中应当增加上 PCI 的接口</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> TypeInfo a3dev_type_info = &#123;</span><br><span class="line">    .name = TYPE_A3DEV_PCI,</span><br><span class="line">    .parent = TYPE_PCI_DEVICE,</span><br><span class="line">    .instance_init = a3dev_instance_init,</span><br><span class="line">    .instance_size = <span class="keyword">sizeof</span>(A3PCIDevState),</span><br><span class="line">    .class_size = <span class="keyword">sizeof</span>(A3PCIDevClass),</span><br><span class="line">    .class_init = a3dev_class_init,</span><br><span class="line">    .interfaces = (InterfaceInfo[]) &#123;</span><br><span class="line">        &#123; INTERFACE_CONVENTIONAL_PCI_DEVICE &#125;,</span><br><span class="line">        &#123; &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">a3dev_register_types</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    type_register_static(&amp;a3dev_type_info);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type_init(a3dev_register_types);</span><br></pre></td></tr></table></figure>

<p>最后我们在 meson 构建系统中加入我们新增的这个设备，在 <code>hw/misc/meson.build</code> 中加入如下语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">softmmu_ss.add(when: &#x27;CONFIG_PCI_A3DEV&#x27;, if_true: files(&#x27;a3dev.c&#x27;))</span><br></pre></td></tr></table></figure>

<p>并在 <code>hw/misc/Kconfig</code> 中添加如下内容，这表示我们的设备会在 <code>CONFIG_PCI_DEVICES=y</code> 时编译：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config PCI_A3DEV</span><br><span class="line">    bool</span><br><span class="line">    default y if PCI_DEVICES</span><br><span class="line">    depends on PCI</span><br></pre></td></tr></table></figure>

<p>之后编译 Qemu 并附加上 <code>-device a3dev-pci</code> ，之后随便起一个 Linux 系统，此时使用 <code>lspci</code> 指令我们便能看到我们新添加的 pci 设备：</p>
<p><img src="https://s2.loli.net/2022/07/28/Eu82rKgSlJBtbic.png" alt="image.png"></p>
<p>我们使用如下程序来测试我们的设备的输入输出，需要注意的是这需要 root 权限：</p>
<blockquote>
<p>PMIO，使用 iopl 更改端口权限后便能通过 in&#x2F;out 类指令读写端口</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">short</span> port_addr;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;[x] no port provided!&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (iopl(<span class="number">3</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;[x] no privilege!&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        port_addr = atoi(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] a3dev port addr start at: %d\n&quot;</span>, port_addr);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] now writing into a3dev-pci...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x100</span> / <span class="number">4</span>; i++) &#123;</span><br><span class="line">                outl(i, port_addr + i * <span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[+] writing done!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] now reading from a3dev-pci...&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x100</span> / <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i % <span class="number">8</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;\n[--%d--]&quot;</span>, port_addr + i * <span class="number">4</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; %d &quot;</span>, inl(port_addr + i * <span class="number">4</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;\n[+] reading done!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PMIO 测试成功，设备读写功能正常：</p>
<p><img src="https://s2.loli.net/2022/07/28/k4G1cOvNHwUtsjQ.png" alt="image.png"></p>
<blockquote>
<p>MMIO，使用 mmap 映射 <code>sys</code> 目录下设备的 <code>resource0</code> 文件即可直接读写</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write</span><span class="params">(<span class="type">uint32_t</span> *addr, <span class="type">uint32_t</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">        *addr = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">mmio_read</span><span class="params">(<span class="type">uint32_t</span> *addr)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> *addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">uint32_t</span> *mmio_addr;</span><br><span class="line">        <span class="type">int</span> dev_fd;</span><br><span class="line"></span><br><span class="line">        dev_fd = open(<span class="string">&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;</span>,</span><br><span class="line">                        O_RDWR | O_SYNC);</span><br><span class="line">        <span class="keyword">if</span> (dev_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;[x] failed to open mmio file! wrong path or no root!&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mmio_addr = (<span class="type">uint32_t</span>*)</span><br><span class="line">                mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, dev_fd, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (mmio_addr == MAP_FAILED) &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;failed to mmap!&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] start writing to a3dev-pci...&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x100</span> / <span class="number">4</span>; i++) &#123;</span><br><span class="line">                mmio_write(mmio_addr + i, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[+] write done!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] start reading from a3dev-pci...&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x100</span> / <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i % <span class="number">8</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;\n[--%p--]&quot;</span>, mmio_addr);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; %u &quot;</span>, mmio_read(mmio_addr + i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;\n[+] read done!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MMIO 测试成功，设备读写功能正常：</p>
<p><img src="https://s2.loli.net/2022/07/28/RCoHF7SWPIyD54j.png" alt="image.png"></p>
<h1 id="0x04-自定义-QEMU-机器类型"><a href="#0x04-自定义-QEMU-机器类型" class="headerlink" title="0x04.自定义 QEMU 机器类型"></a>0x04.自定义 QEMU 机器类型</h1><p>众所周知在 Qemu 当中有很多种不同的机器类型，其表示着包含一些默认设备（包含PCIe显卡、以太网控制器、SATA控制器等）的虚拟芯片组，例如 <code>pc</code> 对应于 Intel 的 <code>440FX</code> 芯片组（这也是 Qemu 默认选择的机器类型）</p>
<p><img src="https://s2.loli.net/2022/07/14/d1uhrIAYl682WSj.png" alt="image.png"></p>
<p>Qemu 主要支持两种大的 x86 芯片组：i440FX 和 Q35，后者相比前者而言的一个大的亮点便是增加了对 PCIe 的支持：</p>
<p><img src="https://s2.loli.net/2022/07/14/2xgwV7GeSskzWc4.png" alt="image.png"></p>
<p>我们可以使用 <code>-machine</code> 选项来指定我们要创建的虚拟机的机器类型，通过 <code>-machine ?</code> 选项可以查看当前支持的机器类型：</p>
<p><img src="https://s2.loli.net/2022/07/14/v6G5DV4SK7hCbRZ.png" alt="image.png"></p>
<p>但自带的机器类型通常往往无法满足我们多样化的要求，因此有的时候我们需要自行编写一种机器类型来满足我们的需求</p>
<h2 id="一、添加源码文件与编译选项"><a href="#一、添加源码文件与编译选项" class="headerlink" title="一、添加源码文件与编译选项"></a>一、添加源码文件与编译选项</h2><p>在 Qemu 源码目录中，与具体支持的硬件相关的代码都放在 <code>hw/</code> 目录下，例如默认的 <code>PC</code> 架构便定义于 <code>hw/i386/pc.c</code>，因此若是我们想要定义一种新的机器类型则在该目录下进行定义是最好的</p>
<p>老版本的 Qemu 是纯粹基于 Makefile 进行构建的，而现在的新版本 Qemu 中则是使用 meson 进行项目构建，因此笔者接下来将会同时介绍两种配置方法</p>
<h3 id="I、新版本-Qemu-配置方式（meson）"><a href="#I、新版本-Qemu-配置方式（meson）" class="headerlink" title="I、新版本 Qemu 配置方式（meson）"></a>I、新版本 Qemu 配置方式（meson）</h3><p>这里我们选择定义一种新的机器类型名为 <code>a3-pc</code>，并在 <code>hw/i386/a3-pc</code> 下创建如下目录结构：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree hw/i386/a3-pc/</span></span><br><span class="line">hw/i386/a3-pc/</span><br><span class="line">├── accel.c</span><br><span class="line">├── machine.c</span><br><span class="line">└── meson.build</span><br><span class="line"></span><br><span class="line">0 directories, 3 files</span><br></pre></td></tr></table></figure>

<p>三个文件说明如下：</p>
<ul>
<li><code>meson.build</code>：meson 项目构建文件</li>
<li><code>machine.c</code>：机器的主体代码</li>
<li><code>accel.c</code>：自定义的 accelerator 代码</li>
</ul>
<p>在 <code>meson.build</code> 中写入如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a3pc_ss = ss.source_set()</span><br><span class="line">a3pc_ss.add(files(&#x27;accel.c&#x27;))</span><br><span class="line">a3pc_ss.add(files(&#x27;machine.c&#x27;))</span><br><span class="line"></span><br><span class="line">i386_ss.add_all(when: &#x27;CONFIG_A3_PC&#x27;, if_true: a3pc_ss)</span><br></pre></td></tr></table></figure>

<p>之后在 <code>hw/i386/meson.build</code> 中添加该语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subdir(&#x27;a3-pc&#x27;)</span><br></pre></td></tr></table></figure>

<p>这里笔者选择创建一个 i386 类型的机器，因此我们还需要修改 <code>hw/i386/Kconfig</code>，添加如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">config A3_PC</span><br><span class="line">    bool</span><br></pre></td></tr></table></figure>

<p>在 <code>configs/devices/i386-softmmu/default.mak</code> 末尾添加如下内容，使得我们的新的机器类型会被默认编译进去：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_A3_PC=y</span><br></pre></td></tr></table></figure>

<h3 id="II、老版本-Qemu-配置方式（makefile）"><a href="#II、老版本-Qemu-配置方式（makefile）" class="headerlink" title="II、老版本 Qemu 配置方式（makefile）"></a>II、老版本 Qemu 配置方式（makefile）</h3><p>如果是版本稍微老一点的 Qemu 则应当在 <code>hw/a3-pc</code> 下创建如下目录结构：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree ./hw/a3-pc/</span></span><br><span class="line">./hw/a3-pc/</span><br><span class="line">├── accel.c</span><br><span class="line">├── machine.c</span><br><span class="line">└── Makefile.objs</span><br><span class="line"></span><br><span class="line">0 directories, 3 files</span><br></pre></td></tr></table></figure>

<p>三个文件说明如下：</p>
<ul>
<li><code>Makefile.objs</code>：机器的 Makefile 文件</li>
<li><code>machine.c</code>：机器的主体代码</li>
<li><code>accel.c</code>：自定义的 accelerator 代码，也可以直接用默认的 TCG accelerator</li>
</ul>
<p>并在 <code>Makefile.objs</code> 中添加如下内容：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj-<span class="variable">$(CONFIG_A3_PC)</span> += accel.o</span><br><span class="line">obj-<span class="variable">$(CONFIG_A3_PC)</span> += machine.o</span><br></pre></td></tr></table></figure>

<p>之后在 <code>hw/Makefile.objs</code> 中添加上该配置：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">devices-dirs-y = core/</span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(CONFIG_SOFTMMU)</span>, y)</span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line">devices-dirs-<span class="variable">$(CONFIG_A3_PC)</span> += a3-pc/</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>

<p>这里我们通过添加一个新的选项 <code>CONFIG_A3_PC</code> 来控制是否要进行该类型机器的编译</p>
<p>笔者选择创建一个 i386 类型的机器，因此我们还需要修改 <code>hw/i386/Kconfig</code>，添加如下内容，表示一个空白的机器，后面我们若是需要添加硬件则还需要在这部分进行改动：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">config A3_PC</span><br><span class="line">    bool</span><br></pre></td></tr></table></figure>

<p>最后我们在源码根目录的 <code>configure</code> 文件中添加如下内容即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">supported_a3_pc_target</span></span>() &#123;</span><br><span class="line">    <span class="built_in">test</span> <span class="string">&quot;<span class="variable">$a3_pc</span>&quot;</span> = <span class="string">&quot;yes&quot;</span> || <span class="built_in">return</span> 1</span><br><span class="line">    glob <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="string">&quot;*-softmmu&quot;</span> || <span class="built_in">return</span> 1</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$&#123;1%-softmmu&#125;</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">	x86_64)</span><br><span class="line">	    <span class="built_in">return</span> 0</span><br><span class="line">	    ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line">    <span class="built_in">return</span> 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">supported_target</span></span>() &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line">    supported_a3_pc_target <span class="string">&quot;<span class="variable">$1</span>&quot;</span> &amp;&amp; <span class="built_in">return</span> 0</span><br><span class="line">    print_error <span class="string">&quot;TCG disabled, but hardware accelerator not available for &#x27;<span class="variable">$target</span>&#x27;&quot;</span></span><br><span class="line">    <span class="built_in">return</span> 1</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="keyword">for</span> opt <span class="keyword">do</span></span><br><span class="line">  optarg=$(<span class="built_in">expr</span> <span class="string">&quot;x<span class="variable">$opt</span>&quot;</span> : <span class="string">&#x27;x[^=]*=\(.*\)&#x27;</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$opt</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">  --<span class="built_in">help</span>|-h) show_help=<span class="built_in">yes</span></span><br><span class="line">  ;;</span><br><span class="line">  <span class="comment">#...</span></span><br><span class="line">  ;;</span><br><span class="line">  --enable-a3-pc) a3_pc=<span class="string">&quot;yes&quot;</span></span><br><span class="line">  ;;</span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="comment"># 这一块可以放在 supported_whpx_target 的那个语句块下面</span></span><br><span class="line"><span class="keyword">if</span> supported_a3_pc_target <span class="variable">$target</span>; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;CONFIG_A3_PC=y&quot;</span> &gt;&gt; <span class="variable">$config_target_mak</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;CONFIG_A3_PC=y&quot;</span> &gt;&gt; <span class="variable">$config_host_mak</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>如果我们想要改变编译出来的可执行文件的名字，还可以在 <code>Makefile.target</code> 中修改如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ifdef</span> CONFIG_USER_ONLY</span><br><span class="line"><span class="comment"># user emulator name</span></span><br><span class="line">QEMU_PROG=qemu-<span class="variable">$(TARGET_NAME)</span></span><br><span class="line">QEMU_PROG_BUILD = <span class="variable">$(QEMU_PROG)</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">ifdef</span> CONFIG_A3_PC</span><br><span class="line"><span class="comment"># arttnba3 type machine</span></span><br><span class="line">QEMU_PROG=a3-pc</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment"># system emulator name</span></span><br><span class="line">QEMU_PROG=qemu-system-<span class="variable">$(TARGET_NAME)</span><span class="variable">$(EXESUF)</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>

<h2 id="二、定义新的-Machine-Type"><a href="#二、定义新的-Machine-Type" class="headerlink" title="二、定义新的 Machine Type"></a>二、定义新的 Machine Type</h2><h3 id="I、machine-c：machine-基本定义"><a href="#I、machine-c：machine-基本定义" class="headerlink" title="I、machine.c：machine 基本定义"></a>I、machine.c：machine 基本定义</h3><p>虽然 Qemu 是使用 C 语言编写的，但是在 Qemu 当中同样使用了 OOP 的思想，通过结构体嵌套的形式实现继承</p>
<p>在 Qemu 当中使用 <code>MachineState</code> 结构体类型表示一个通用虚拟机的状态，使用 <code>MachineClass</code> 结构体类型表示一个通用的虚拟机类型，因此对于我们需要创建的新的机器类型，我们需要分别定义他的状态类与类型类，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qemu/osdep.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qemu-common.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/boards.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qom/object.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sysemu/sysemu.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">A3PCMachineState</span> &#123;</span></span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    MachineState parent;</span><br><span class="line"></span><br><span class="line">    Notifier machine_done;</span><br><span class="line">&#125; A3PCMachineState;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">A3PCMachineClass</span> &#123;</span></span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    MachineClass parent;</span><br><span class="line">&#125; A3PCMachineClass;</span><br></pre></td></tr></table></figure>

<p>这里对于继承自 MachineState 的子类我们添加了一个新的 <code>Notifier</code> 类型的成员，可以用来在后面构建事件通知链</p>
<p>我们还需要定义一些相应的父子类间转型的宏，以及一个表示新增的 <code>a3-pc</code> 类型的宏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_A3PC_MACHINE MACHINE_TYPE_NAME(<span class="string">&quot;a3-pc&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> A3PC_MACHINE(obj) \</span></span><br><span class="line"><span class="meta">    OBJECT_CHECK(A3PCMachineState, (obj), TYPE_A3PC_MACHINE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> A3PC_MACHINE_GET_CLASS(obj) \</span></span><br><span class="line"><span class="meta">    OBJECT_GET_CLASS(A3PCMachineClass, obj, TYPE_A3PC_MACHINE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> A3PC_MACHINE_CLASS(klass) \</span></span><br><span class="line"><span class="meta">    OBJECT_CLASS_CHECK(A3PCMachineClass, klass, TYPE_A3PC_MACHINE)</span></span><br></pre></td></tr></table></figure>

<p>接下来我们定义 MachineState 与 MachineClass 的初始化函数，这里只是一个最最简单的空模板，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">a3_pc_machine_init_done</span><span class="params">(Notifier *notifier, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">a3_pc_machine_init</span><span class="params">(MachineState *machine)</span></span><br><span class="line">&#123;</span><br><span class="line">    A3PCMachineState *ms = A3PC_MACHINE(machine);</span><br><span class="line"></span><br><span class="line">    ms-&gt;machine_done.notify = a3_pc_machine_init_done;</span><br><span class="line">    qemu_add_machine_init_done_notifier(&amp;ms-&gt;machine_done);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">a3_pc_machine_class_init</span><span class="params">(ObjectClass *oc, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    MachineClass *mc = MACHINE_CLASS(oc);</span><br><span class="line"></span><br><span class="line">    mc-&gt;init = a3_pc_machine_init;</span><br><span class="line">    <span class="comment">// 这里设置了一个参数，指定了使用我们自己的 accelerator</span></span><br><span class="line">    mc-&gt;default_machine_opts = <span class="string">&quot;accel=a3acl&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们需要声明一个 <code>TypeInfo</code> 类型的变量，用来表示我们新建的这一种机器类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> TypeInfo a3_pc_machine_info = &#123;</span><br><span class="line">    .name = TYPE_A3PC_MACHINE,</span><br><span class="line">    .parent = TYPE_MACHINE,</span><br><span class="line">    .instance_size = <span class="keyword">sizeof</span>(A3PCMachineState),</span><br><span class="line">    .class_size = <span class="keyword">sizeof</span>(A3PCMachineClass),</span><br><span class="line">    .class_init = a3_pc_machine_class_init,</span><br><span class="line">    .interfaces = (InterfaceInfo[]) &#123;</span><br><span class="line">        &#123; &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最后就是注册我们的新机器类型了，这里使用 <code>type_init()</code> 来完成，原理是 gcc constructor attribute 使其会调用 <code>a3_pc_machine_register()</code> 来注册 <code>a3_pc_machine_info</code> ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">a3_pc_machine_register</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    type_register_static(&amp;a3_pc_machine_info);</span><br><span class="line">&#125;</span><br><span class="line">type_init(a3_pc_machine_register);</span><br></pre></td></tr></table></figure>

<h3 id="II、accel-c：accelerator-定义"><a href="#II、accel-c：accelerator-定义" class="headerlink" title="II、accel.c：accelerator 定义"></a>II、accel.c：accelerator 定义</h3><p>接下来就是定义我们自己的 accelerator，因为 Qemu 默认需要一个 accelerator，但如果再去和原有的 accelerator 做适配就太麻烦了（<del>因为👴是懒🐕</del>），所以这里我们自己定义一个空的 accelerator，不过这一部分我们只需要声明一个新的 <code>TypeInfo</code> 类型变量即可</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qemu/osdep.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qemu/module.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/boards.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/qdev-core.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sysemu/accel.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> a3_pc_allowed;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">a3_pc_init</span><span class="params">(MachineState *ms)</span></span><br><span class="line">&#123;</span><br><span class="line">    MachineClass *mc = MACHINE_GET_CLASS(ms);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * opt out of system RAM being allocated by generic code</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    mc-&gt;default_ram_id = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">a3_pc_accel_class_init</span><span class="params">(ObjectClass *oc, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    AccelClass *ac = ACCEL_CLASS(oc);</span><br><span class="line">    <span class="type">static</span> GlobalProperty compat[] = &#123;</span><br><span class="line">        &#123; <span class="string">&quot;migration&quot;</span>, <span class="string">&quot;store-global-state&quot;</span>, <span class="string">&quot;off&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;migration&quot;</span>, <span class="string">&quot;send-configuration&quot;</span>, <span class="string">&quot;off&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;migration&quot;</span>, <span class="string">&quot;send-section-footer&quot;</span>, <span class="string">&quot;off&quot;</span> &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ac-&gt;name = <span class="string">&quot;A3ACL&quot;</span>;</span><br><span class="line">    ac-&gt;init_machine = a3_pc_init;</span><br><span class="line">    ac-&gt;allowed = &amp;a3_pc_allowed;</span><br><span class="line">    ac-&gt;compat_props = g_ptr_array_new();</span><br><span class="line"></span><br><span class="line">    compat_props_add(ac-&gt;compat_props, compat, G_N_ELEMENTS(compat));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_A3_ACCEL ACCEL_CLASS_NAME(<span class="string">&quot;a3acl&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> TypeInfo a3_pc_accel_type = &#123;</span><br><span class="line">    .name = TYPE_A3_ACCEL,</span><br><span class="line">    .parent = TYPE_ACCEL,</span><br><span class="line">    .class_init = a3_pc_accel_class_init,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">a3_pc_type_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    type_register_static(&amp;a3_pc_accel_type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type_init(a3_pc_type_init);</span><br></pre></td></tr></table></figure>

<h4 id="新版本-accelerator-额外添加-ops"><a href="#新版本-accelerator-额外添加-ops" class="headerlink" title="*新版本 accelerator 额外添加 ops"></a>*新版本 accelerator 额外添加 ops</h4><p>需要注意的是 qemu 的 7.0 和 5.0 的版本之间代码架构有一定的改动，所以对于 7.0 版本我们还需要额外定义一个 AccelClassOps：</p>
<blockquote>
<p> 当然，也可以直接用原有的 accelerator ，比如说 <code>tcg</code>，直接在 machine.c 代码中指定 <code>accel=tcg</code> 即可</p>
</blockquote>
<blockquote>
<p>添加文件：accel&#x2F;a3acl&#x2F;a3acl-accel-ops.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * QEMU A3ACL vCPU common functionality</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Copyright (c) 22 arttnba3</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Just modify it like what you want : )</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qemu/osdep.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qemu-common.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sysemu/accel-ops.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">a3acl_handle_interrupt</span><span class="params">(CPUState *cpu, <span class="type">int</span> mask)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// do nothing</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">a3acl_kick_vcpu_thread</span><span class="params">(CPUState *unused)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// do nothing</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">a3acl_start_vcpu_thread</span><span class="params">(CPUState *cpu)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// do nothing</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">a3acl_accel_ops_init</span><span class="params">(AccelOpsClass *ops)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 这几个函数可以按照个人需要来进行改造，笔者这里仅作占位符</span></span><br><span class="line">    ops-&gt;create_vcpu_thread = a3acl_start_vcpu_thread;</span><br><span class="line">    ops-&gt;kick_vcpu_thread = a3acl_kick_vcpu_thread;</span><br><span class="line">    ops-&gt;handle_interrupt = a3acl_handle_interrupt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">a3acl_accel_ops_class_init</span><span class="params">(ObjectClass *oc, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    AccelOpsClass *ops = ACCEL_OPS_CLASS(oc);</span><br><span class="line"></span><br><span class="line">    ops-&gt;ops_init = a3acl_accel_ops_init;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> TypeInfo a3acl_accel_ops_type = &#123;</span><br><span class="line">    .name = ACCEL_OPS_NAME(<span class="string">&quot;a3acl&quot;</span>),</span><br><span class="line">    .parent = TYPE_ACCEL_OPS,</span><br><span class="line">    .class_init = a3acl_accel_ops_class_init,</span><br><span class="line">    .abstract = <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line">module_obj(ACCEL_OPS_NAME(<span class="string">&quot;a3acl&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">a3acl_accel_ops_register_types</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    type_register_static(&amp;a3acl_accel_ops_type);</span><br><span class="line">&#125;</span><br><span class="line">type_init(a3acl_accel_ops_register_types);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>添加文件：accel&#x2F;a3acl&#x2F;meson.build</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a3acl_ss = ss.source_set()</span><br><span class="line">a3acl_ss.add(files(</span><br><span class="line">  &#x27;a3acl-accel-ops.c&#x27;,</span><br><span class="line">))</span><br><span class="line"></span><br><span class="line">specific_ss.add_all(when: &#x27;CONFIG_A3ACL&#x27;, if_true: a3acl_ss)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>修改文件：accel&#x2F;meson.build</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if have_system</span><br><span class="line">  subdir(&#x27;hvf&#x27;)</span><br><span class="line">  subdir(&#x27;qtest&#x27;)</span><br><span class="line">  subdir(&#x27;kvm&#x27;)</span><br><span class="line">  subdir(&#x27;xen&#x27;)</span><br><span class="line">  subdir(&#x27;stubs&#x27;)</span><br><span class="line">  subdir(&#x27;a3acl&#x27;) # 加上这句</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>

<blockquote>
<p>修改文件：accel&#x2F;Kconfig</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 添加上这：</span><br><span class="line">config A3ACL</span><br><span class="line">    bool</span><br><span class="line">    default y</span><br></pre></td></tr></table></figure>

<h2 id="三、添加设备结构🕊"><a href="#三、添加设备结构🕊" class="headerlink" title="三、添加设备结构🕊"></a>三、添加设备结构🕊</h2><p>现在我们已经有了一台可以运行的空白的机器——但包括 CPU 在内的所有设备目前暂且都是不存在的，因此我们需要手动地构造机器的设备结构</p>
<h3 id="I、添加新的-PCIe-Host-Bridge"><a href="#I、添加新的-PCIe-Host-Bridge" class="headerlink" title="I、添加新的 PCIe Host Bridge"></a>I、添加新的 PCIe Host Bridge</h3><p>一个空的机器什么都没有，那自然是什么都干不了的，所以我们首先需要为这个机器添加上一个 <code>PCIe Host Bridge</code>，从而让我们的机器可以添加新的 PCIe 设备</p>
<p>惯例地就是定义一个新的 <code>PCIe Host Bridge</code> 类型的新 PCIe 设备：</p>
<blockquote>
<p>添加文件：include&#x2F;hw&#x2F;pci-host&#x2F;a3pc.h</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HW_A3_PC_PCIE_HOST_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HW_A3_PC_PCIE_HOST_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;exec/memory.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/pci/pcie_host.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">A3PCPCIEHost</span> &#123;</span></span><br><span class="line">    PCIExpressHost parent_obj;</span><br><span class="line"></span><br><span class="line">    MemoryRegion mem;</span><br><span class="line">    MemoryRegion io;</span><br><span class="line">&#125; A3PCPCIEHost;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_A3_PC_PCIE_HOST <span class="string">&quot;a3-pc-pcie-host&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> A3_PC_PCIE_HOST(obj) \</span></span><br><span class="line"><span class="meta">    OBJECT_CHECK(A3PCPCIEHost, (obj), TYPE_A3_PC_PCIE_HOST)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* HW_A3_PC_PCIE_HOST_H */</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>添加文件：hw&#x2F;pci-host&#x2F;a3pc.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qemu/osdep.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qemu-common.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;exec/memory.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/qdev-properties.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/pci/pci.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/pci/pcie_host.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/pci-host/a3pc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qemu/error-report.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">a3_pc_host_init</span><span class="params">(Object *obj)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// nothing to do</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">a3_pc_pcie_set_irq</span><span class="params">(<span class="type">void</span> *opaque, <span class="type">int</span> irq_num, <span class="type">int</span> level)</span></span><br><span class="line">&#123;</span><br><span class="line">    warn_report(<span class="string">&quot;A3-PC: not support INTx (irq %d, level %d)&quot;</span>,</span><br><span class="line">                irq_num, level);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">a3_pc_pcie_swizzle_map_irq_fn</span><span class="params">(PCIDevice *pci_dev, <span class="type">int</span> pin)</span></span><br><span class="line">&#123;</span><br><span class="line">    warn_report(<span class="string">&quot;A3-PC: not support INTx (pin %d)&quot;</span>, pin);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">a3_pc_pcie_host_realize</span><span class="params">(DeviceState *dev, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    PCIHostState *pci = PCI_HOST_BRIDGE(dev);</span><br><span class="line">    A3PCPCIEHost *h = A3_PC_PCIE_HOST(dev);</span><br><span class="line">    SysBusDevice *sbd = SYS_BUS_DEVICE(dev);</span><br><span class="line"></span><br><span class="line">    memory_region_init(&amp;h-&gt;mem, OBJECT(h), <span class="string">&quot;a3-pc-mem&quot;</span>, <span class="number">16</span>);</span><br><span class="line">    memory_region_init(&amp;h-&gt;io, OBJECT(h), <span class="string">&quot;a3-pc-io&quot;</span>, <span class="number">16</span>);</span><br><span class="line">    sysbus_init_mmio(sbd, &amp;h-&gt;mem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * A PCIe host in QEMU is required to provide</span></span><br><span class="line"><span class="comment">     * a pair of callbacks: set_irq() and map_irq()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    pci-&gt;bus = pci_register_root_bus(dev, <span class="string">&quot;a3-pcie0&quot;</span>,</span><br><span class="line">                                    a3_pc_pcie_set_irq,</span><br><span class="line">                                    a3_pc_pcie_swizzle_map_irq_fn,</span><br><span class="line">                                    h, &amp;h-&gt;mem, &amp;h-&gt;io, </span><br><span class="line">                                    <span class="number">0</span>, <span class="number">1</span>, TYPE_PCIE_BUS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> Property a3_pc_pcie_host_props[] = &#123;</span><br><span class="line">    DEFINE_PROP_END_OF_LIST(),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">a3_pc_class_init</span><span class="params">(ObjectClass *oc, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    DeviceClass *dc = DEVICE_CLASS(oc);</span><br><span class="line"></span><br><span class="line">    dc-&gt;realize = a3_pc_pcie_host_realize;</span><br><span class="line">    set_bit(DEVICE_CATEGORY_BRIDGE, dc-&gt;categories);</span><br><span class="line">    device_class_set_props(dc, a3_pc_pcie_host_props);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> TypeInfo a3_pc_pcie_host = &#123;</span><br><span class="line">    .name = TYPE_A3_PC_PCIE_HOST,</span><br><span class="line">    .parent = TYPE_PCI_HOST_BRIDGE,</span><br><span class="line">    .instance_size = <span class="keyword">sizeof</span>(A3PCPCIEHost),</span><br><span class="line">    .instance_init = a3_pc_host_init,</span><br><span class="line">    .class_init = a3_pc_class_init,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">a3_pc_pcie_host_register</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    type_register(&amp;a3_pc_pcie_host);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type_init(a3_pc_pcie_host_register);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>修改文件：hw&#x2F;pci-host&#x2F;meson.build</p>
<blockquote>
<p>老版本没测了，自己想该怎么改吧（笑）</p>
</blockquote>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># A3 devices</span><br><span class="line">pci_ss.add(when: &#x27;CONFIG_PCI&#x27;, if_true: files(&#x27;a3pc.c&#x27;))</span><br></pre></td></tr></table></figure>

<p>之后我们在我们的机器类型中加上 PCI 相关的两个指针成员：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">A3PCMachineState</span> &#123;</span></span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    MachineState parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* &lt;public&gt; */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* State for other subsystems/APIs: */</span></span><br><span class="line">    Notifier machine_done;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Pointers to devices and objects: */</span></span><br><span class="line">    PCIBus *bus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * QEMU requires the entire PCI(e) hierarchy be attached to</span></span><br><span class="line"><span class="comment">     * a PCI(e) bus, so BES-VNC machine has to implement one.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PCIHostState *pci;</span><br><span class="line">&#125; A3PCMachineState;</span><br></pre></td></tr></table></figure>

<p>最后在机器初始化函数中初始化一个我们自定义的这个 PCIe 设备即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">a3_pc_machine_init</span><span class="params">(MachineState *machine)</span></span><br><span class="line">&#123;</span><br><span class="line">    A3PCMachineState *ms = A3PC_MACHINE(machine);</span><br><span class="line">    DeviceState *dev = qdev_new(TYPE_A3_PC_PCIE_HOST);</span><br><span class="line"></span><br><span class="line">    sysbus_realize_and_unref(SYS_BUS_DEVICE(dev), &amp;error_fatal);</span><br><span class="line">    ms-&gt;pci = PCI_HOST_BRIDGE(dev);</span><br><span class="line"></span><br><span class="line">    memory_region_add_subregion(get_system_memory(), <span class="number">0</span>,</span><br><span class="line">                                sysbus_mmio_get_region(SYS_BUS_DEVICE(dev), <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    ms-&gt;machine_done.notify = a3_pc_machine_init_done;</span><br><span class="line">    qemu_add_machine_init_done_notifier(&amp;ms-&gt;machine_done);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意新版本和老版本的 API 不同，在老版本中应当使用如下 API：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">a3_pc_machine_init</span><span class="params">(MachineState *machine)</span></span><br><span class="line">&#123;</span><br><span class="line">    A3PCMachineState *ms = A3PC_MACHINE(machine);</span><br><span class="line"></span><br><span class="line">    DeviceState *dev = qdev_create(<span class="literal">NULL</span>, TYPE_A3_PC_PCIE_HOST);</span><br><span class="line"></span><br><span class="line">    qdev_init_nofail(dev);</span><br><span class="line">    ms-&gt;pci = PCI_HOST_BRIDGE(dev);</span><br><span class="line"></span><br><span class="line">    memory_region_add_subregion(get_system_memory(), <span class="number">0</span>,</span><br><span class="line">                                sysbus_mmio_get_region(SYS_BUS_DEVICE(dev), <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    ms-&gt;machine_done.notify = a3_pc_machine_init_done;</span><br><span class="line">    qemu_add_machine_init_done_notifier(&amp;ms-&gt;machine_done);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完成这些步骤之后我们的新机器就能随意插入各种 PCI 设备了；）</p>
<h3 id="II、添加新的-CPU-插槽🕊"><a href="#II、添加新的-CPU-插槽🕊" class="headerlink" title="II、添加新的 CPU 插槽🕊"></a>II、添加新的 CPU 插槽🕊</h3><p>当然，我们的机器还缺少了 CPU，没有 CPU 的机器自然是跑不起来的，因此这里我们还需要在我们的机器类型当中添加上相应的 CPU 插槽，由于 Qemu 内部的基础 x86 机器架构已经实现好了基础框架，所以我们直接改为继承自对应的 x86 基础机器类即可</p>
<blockquote>
<p>当然，如果是纯纯自定义的异架构，这里还是得自己手动写一套…</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">A3PCMachineState</span> &#123;</span></span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    X86MachineState parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* &lt;public&gt; */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* State for other subsystems/APIs: */</span></span><br><span class="line">    Notifier machine_done;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Pointers to devices and objects: */</span></span><br><span class="line">    PCIBus *bus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * QEMU requires the entire PCI(e) hierarchy be attached to</span></span><br><span class="line"><span class="comment">     * a PCI(e) bus, so BES-VNC machine has to implement one.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PCIHostState *pci;</span><br><span class="line">&#125; A3PCMachineState;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">A3PCMachineClass</span> &#123;</span></span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    X86MachineClass parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*&lt; public &gt;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Default CPU model version.  See x86_cpu_set_default_version(). */</span></span><br><span class="line">    <span class="type">int</span> default_cpu_version;</span><br><span class="line">&#125; A3PCMachineClass;</span><br></pre></td></tr></table></figure>

<p>不过机器定义的文件当中需要改动的部分会比预想的要多，<del>所以这里就先🕊🕊🕊了</del></p>
<h3 id="Extra-自定义-CPU-🕊"><a href="#Extra-自定义-CPU-🕊" class="headerlink" title="Extra.自定义 CPU 🕊"></a>Extra.自定义 CPU 🕊</h3><blockquote>
<p>🕊🕊🕊</p>
</blockquote>
<h2 id="四、编译运行🕊"><a href="#四、编译运行🕊" class="headerlink" title="四、编译运行🕊"></a>四、编译运行🕊</h2><p>由于我们新建立的机器类型为 <code>x86</code> 架构的机器，因此我们需要在执行 configure 脚本时指定 <code>--target-list=x86_64-softmmu</code> </p>
<p>这里需要注意的是前前面笔者提供了两种设置 <code>CONFIG_A3_PC</code> 的选项：如果我们是直接通过修改 <code>default.mak</code> 使得 <code>CONFIG_A3_PC=y</code>，则直接编译即可；若我们是通过修改了 <code>configure</code> 来指定 <code>CONFIG_A3_PC</code> 的值，则创建编译脚本的时候我们需要手动指定 <code>--enable-a3-pc</code> 来编译上我们新增的机器类型</p>
<p>编译完成后我们便能够看到我们新添加的机器类型 <code>a3-pc</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">build$ </span><span class="language-bash">./qemu-system-x86_64 -machine ?</span></span><br><span class="line">Supported machines are:</span><br><span class="line">microvm              microvm (i386)</span><br><span class="line">pc                   Standard PC (i440FX + PIIX, 1996) (alias of pc-i440fx-7.0)</span><br><span class="line">pc-i440fx-7.0        Standard PC (i440FX + PIIX, 1996) (default)</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">...</span></span><br><span class="line">a3-pc                (null)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>🕊🕊🕊</p>
</blockquote>

      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
              <a href="/2022/07/07/OS-0X04-LINUX-KERNEL-MEMORY-5.11-PART-III/" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>上一页</span>
              </a>
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">
              <i class="iconfont icon-updatetime" title="更新时间"></i>
              2022-07-15 16:45:17
            </span>
            
                  <span class="post-categories">
                    <i class="iconfont icon-bookmark" title="分类"></i>
                    
                    <span class="span--category">
                      <a href="/categories/VIRTUALIZATION/" title="VIRTUALIZATION">
                        <b>#</b> VIRTUALIZATION
                      </a>
                    </span>
                    
                  </span>
              
                  <span class="post-tags">
                    <i class="iconfont icon-tags" title="标签"></i>
                    
                    <span class="span--tag">
                      <a href="/tags/%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0/" title="学习札记">
                        <b>#</b> 学习札记
                      </a>
                    </span>
                    
                    <span class="span--tag">
                      <a href="/tags/Qemu/" title="Qemu">
                        <b>#</b> Qemu
                      </a>
                    </span>
                    
                    <span class="span--tag">
                      <a href="/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/" title="虚拟化">
                        <b>#</b> 虚拟化
                      </a>
                    </span>
                    
                    <span class="span--tag">
                      <a href="/tags/PCI/" title="PCI">
                        <b>#</b> PCI
                      </a>
                    </span>
                    
                  </span>
              
          </div>
          <div class="post-foot-prev">
            
              <a href="/2022/07/22/VIRTUALIZATION-0X01-QEMU-PART-II/" target="_self">
                <span>下一页</span>
                <i class="iconfont icon-chevronright"></i>
              </a>
            
          </div>
        </div>
      
    </div>
    
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">目录</div>
    <div class="catalog-content">
      
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0x00-%E4%B8%80%E5%88%87%E5%BC%80%E5%A7%8B%E4%B9%8B%E5%89%8D"><span class="toc-text">0x00.一切开始之前</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#PRE-%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96"><span class="toc-text">PRE.安装依赖</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x01-%E4%BB%8E%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91-QEMU"><span class="toc-text">0x01.从源码编译 QEMU</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E8%8E%B7%E5%8F%96-QEMU-%E6%BA%90%E7%A0%81"><span class="toc-text">一、获取 QEMU 源码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#I-%E5%AE%98%E7%BD%91%E4%B8%8B%E8%BD%BD%E6%BA%90%E7%A0%81"><span class="toc-text">I.官网下载源码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#II-GitHub-%E8%8E%B7%E5%8F%96%E6%BA%90%E7%A0%81"><span class="toc-text">II. GitHub 获取源码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E9%85%8D%E7%BD%AE%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9"><span class="toc-text">二、配置编译选项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%BC%80%E5%A7%8B%E7%BC%96%E8%AF%91"><span class="toc-text">三、开始编译</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x02-%E6%9E%84%E5%BB%BA%E7%B3%BB%E7%BB%9F%E9%95%9C%E5%83%8F%E5%B9%B6%E4%BD%BF%E7%94%A8-vnc-%E8%BF%9E%E6%8E%A5"><span class="toc-text">0x02.构建系统镜像并使用 vnc 连接</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%95%9C%E5%83%8F%E6%96%87%E4%BB%B6%E5%B9%B6%E9%80%9A%E8%BF%87-CDROM-%E5%AE%89%E8%A3%85-Ubuntu"><span class="toc-text">一、创建虚拟机镜像文件并通过 CDROM 安装 Ubuntu</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#I-%E4%BD%BF%E7%94%A8-qemu-img-%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E9%95%9C%E5%83%8F%E6%96%87%E4%BB%B6"><span class="toc-text">I.使用 qemu-img 创建虚拟机磁盘镜像文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#II-%E9%80%9A%E8%BF%87-vnc-%E8%BF%9E%E6%8E%A5%E5%AE%8C%E6%88%90%E5%AE%89%E8%A3%85"><span class="toc-text">II.通过 vnc 连接完成安装</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%9E%84%E5%BB%BA-ext4-%E7%A3%81%E7%9B%98%E9%95%9C%E5%83%8F%E5%B9%B6%E8%BF%90%E8%A1%8C-kernel-bzImage"><span class="toc-text">二、构建 ext4 磁盘镜像并运行 kernel bzImage</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#I-%E6%9E%84%E5%BB%BA%E7%A3%81%E7%9B%98%E9%95%9C%E5%83%8F"><span class="toc-text">I.构建磁盘镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#II-%E8%8E%B7%E5%8F%96-kernel-bzImage"><span class="toc-text">II.获取 kernel bzImage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#III-%E8%BF%90%E8%A1%8C-qemu-%E5%B9%B6%E9%80%9A%E8%BF%87-vnc-%E8%BF%9B%E8%A1%8C%E8%BF%9E%E6%8E%A5"><span class="toc-text">III.运行 qemu 并通过 vnc 进行连接</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x03-%E7%AE%80%E6%98%93-QEMU-%E8%AE%BE%E5%A4%87%E7%BC%96%E5%86%99"><span class="toc-text">0x03.简易 QEMU 设备编写</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81PCI-basic-knowledge"><span class="toc-text">一、PCI basic knowledge</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#I%E3%80%81%E6%80%BB%E7%BA%BF-amp-amp-PCI-%E8%AE%BE%E5%A4%87"><span class="toc-text">I、总线 &amp;&amp; PCI 设备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#II%E3%80%81PCI-%E8%AE%BE%E5%A4%87%E7%BC%96%E5%8F%B7"><span class="toc-text">II、PCI 设备编号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#III%E3%80%81PCI-%E8%AE%BE%E5%A4%87%E9%85%8D%E7%BD%AE%E7%A9%BA%E9%97%B4"><span class="toc-text">III、PCI 设备配置空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IV%E3%80%81PCI-%E8%AE%BE%E5%A4%87%E5%86%85%E5%AD%98-amp-%E7%AB%AF%E5%8F%A3%E7%A9%BA%E9%97%B4%E4%B8%8E%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F"><span class="toc-text">IV、PCI 设备内存 &amp; 端口空间与访问方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Qemu-Object-Model"><span class="toc-text">二、Qemu Object Model</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#I%E3%80%81TypeInfo-%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B1%9E%E6%80%A7"><span class="toc-text">I、TypeInfo - 类的基本属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#II%E3%80%81Class-%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E5%86%85%E5%AE%B9"><span class="toc-text">II、Class - 类的静态内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#III%E3%80%81Object-%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1"><span class="toc-text">III、Object - 类的实例对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IV%E3%80%81%E7%B1%BB%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%87%8A%E6%94%BE"><span class="toc-text">IV、类的创建与释放</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81MemoryRegion-Qemu-%E4%B8%AD%E7%9A%84%E4%B8%80%E5%9D%97%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F"><span class="toc-text">三、MemoryRegion - Qemu 中的一块内存区域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Qemu-%E4%B8%AD-PCI-%E8%AE%BE%E5%A4%87%E7%9A%84%E7%BC%96%E5%86%99"><span class="toc-text">四、Qemu 中 PCI 设备的编写</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x04-%E8%87%AA%E5%AE%9A%E4%B9%89-QEMU-%E6%9C%BA%E5%99%A8%E7%B1%BB%E5%9E%8B"><span class="toc-text">0x04.自定义 QEMU 机器类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%B7%BB%E5%8A%A0%E6%BA%90%E7%A0%81%E6%96%87%E4%BB%B6%E4%B8%8E%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9"><span class="toc-text">一、添加源码文件与编译选项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#I%E3%80%81%E6%96%B0%E7%89%88%E6%9C%AC-Qemu-%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F%EF%BC%88meson%EF%BC%89"><span class="toc-text">I、新版本 Qemu 配置方式（meson）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#II%E3%80%81%E8%80%81%E7%89%88%E6%9C%AC-Qemu-%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F%EF%BC%88makefile%EF%BC%89"><span class="toc-text">II、老版本 Qemu 配置方式（makefile）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%AE%9A%E4%B9%89%E6%96%B0%E7%9A%84-Machine-Type"><span class="toc-text">二、定义新的 Machine Type</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#I%E3%80%81machine-c%EF%BC%9Amachine-%E5%9F%BA%E6%9C%AC%E5%AE%9A%E4%B9%89"><span class="toc-text">I、machine.c：machine 基本定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#II%E3%80%81accel-c%EF%BC%9Aaccelerator-%E5%AE%9A%E4%B9%89"><span class="toc-text">II、accel.c：accelerator 定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E7%89%88%E6%9C%AC-accelerator-%E9%A2%9D%E5%A4%96%E6%B7%BB%E5%8A%A0-ops"><span class="toc-text">*新版本 accelerator 额外添加 ops</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%B7%BB%E5%8A%A0%E8%AE%BE%E5%A4%87%E7%BB%93%E6%9E%84%F0%9F%95%8A"><span class="toc-text">三、添加设备结构🕊</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#I%E3%80%81%E6%B7%BB%E5%8A%A0%E6%96%B0%E7%9A%84-PCIe-Host-Bridge"><span class="toc-text">I、添加新的 PCIe Host Bridge</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#II%E3%80%81%E6%B7%BB%E5%8A%A0%E6%96%B0%E7%9A%84-CPU-%E6%8F%92%E6%A7%BD%F0%9F%95%8A"><span class="toc-text">II、添加新的 CPU 插槽🕊</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Extra-%E8%87%AA%E5%AE%9A%E4%B9%89-CPU-%F0%9F%95%8A"><span class="toc-text">Extra.自定义 CPU 🕊</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C%F0%9F%95%8A"><span class="toc-text">四、编译运行🕊</span></a></li></ol></li></ol>
      
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
      <div class="comments-container">
        




  
    <script async type="text/javascript" src="/plugins/valine.min.js" onload="loadValineSuc(this)"></script>
  

  <div id="vcomments"></div>

  <script>
    function loadValineSuc() {
      new Valine({
        el: '#vcomments',
        appId: 'ICj6cPRQWFTNiOttBHlzxnIv-gzGzoHsz',
        appKey: 'tuvJh3xYxPFcW2JB6K26RKP2',
        placeholder: '说点什么呗...',
        avatar: 'retro',
        lang: 'zh-CN'
      })
    }
  </script>

    <style>
      .comments-container .v .vempty {
        display: none!important;
      }
    </style>




      </div>
    
  </div>


        
<div class="footer">
  <div class="social">
    <ul>
      
        <li>
          <a title="github" target="_blank" rel="noopener" href="https://github.com/arttnba3">
            <i class="iconfont icon-github"></i>
          </a>
        </li>
      
        <li>
          <a title="email" href="mailto:arttnba@gmail.com">
            <i class="iconfont icon-envelope"></i>
          </a>
        </li>
      
        <li>
          <a title="twitter" target="_blank" rel="noopener" href="https://twitter.com/arttnba3">
            <i class="iconfont icon-twitter"></i>
          </a>
        </li>
      
        <li>
          <a title="rss" href="/atom.xml">
            <i class="iconfont icon-rss"></i>
          </a>
        </li>
      
    </ul>
  </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/arttnba3">Copyright © 2022 arttnba3</a>
        
    </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Theme by Oranges | Powered by Hexo</a>
        
    </div>
  
</div>

      </div>

      <div class="tools-bar">
        <div class="back-to-top tools-bar-item hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



        
  <div class="search-icon tools-bar-item" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-title">
        <span class="search-icon-input">
          <a href="javascript: void(0)">
            <i class="iconfont icon-search"></i>
          </a>
        </span>
        
          <input type="text" class="search-input" id="search-input" placeholder="搜索...">
        
        <span class="search-close-icon" id="search-close-icon">
          <a href="javascript: void(0)">
            <i class="iconfont icon-close"></i>
          </a>
        </span>
      </div>
      <div class="search-result" id="search-result"></div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    inputArea.onclick = function() {
      getSearchFile()
      this.onclick = null
    }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        // inputArea.focus()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'>首次搜索，正在载入索引文件，请稍后……<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + orig_data_title + "</a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<p class=\"search-result-abstract\">" + match_content + "...</p>"
                }
                str += "</li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>没有找到内容，请尝试更换检索词。<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>未找到search.xml文件，具体请参考：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>请求失败，尝试重新刷新页面或稍后重试。<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




        
  <div class="tools-bar-item theme-icon" id="switch-color-scheme">
    <a href="javascript: void(0)">
      <i id="theme-icon" class="iconfont icon-moon"></i>
    </a>
  </div>

  
<script src="/js/colorscheme.js"></script>





        
  
    <div class="share-icon tools-bar-item">
      <a href="javascript: void(0)" id="share-icon">
        <i class="iconfont iconshare"></i>
      </a>
      <div class="share-content hidden">
        
          <a class="share-item" href="https://twitter.com/intent/tweet?text=' + %E3%80%90VIRTUALIZATION.0x00%E3%80%91Qemu%20-%20I%EF%BC%9AQemu%20%E7%AE%80%E6%98%93%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8D%97 + '&url=' + http%3A%2F%2Fblog.arttnba3.cn%2F2022%2F07%2F15%2FVIRTUALIZATION-0X00-QEMU-PART-I%2F + '" target="_blank" title="Twitter">
            <i class="iconfont icon-twitter"></i>
          </a>
        
        
          <a class="share-item" href="https://www.facebook.com/sharer.php?u=http://blog.arttnba3.cn/2022/07/15/VIRTUALIZATION-0X00-QEMU-PART-I/" target="_blank" title="Facebook">
            <i class="iconfont icon-facebooksquare"></i>
          </a>
        
      </div>
    </div>
  
  
<script src="/js/shares.js"></script>



      </div>
    </div>
  </body>
</html>
