<!DOCTYPE html>
<html lang="zh-CN" color-mode="light">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="keywords" content="" />
  <meta name="author" content="arttnba3" />
  <meta name="description" content="あがいた夢を捨てて揺れる今日は眠って誤魔化せ" />
  
  
  <title>
    
      【OS.0x03】Linux Kernel 内存管理浅析 II - Buddy System 
      
      
      |
    
     arttnba3&#39;s blog
  </title>

  
    <link rel="apple-touch-icon" href="/img/favicon.png">
    <link rel="icon" href="/img/favicon.png">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  
<link rel="stylesheet" href="/css/color-scheme.css">
<link rel="stylesheet" href="/css/base.css">
<link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css">
<link rel="stylesheet" href="/css/github-markdown.css">
<link rel="stylesheet" href="/css/highlight.css">
<link rel="stylesheet" href="/css/comments.css">

  <!-- 代码块风格 -->
  

  <!-- jquery3.3.1 -->
  
    <script defer type="text/javascript" src="/plugins/jquery.min.js"></script>
  

  <!-- fancybox -->
  
    <link href="/plugins/jquery.fancybox.min.css" rel="stylesheet">
    <script defer type="text/javascript" src="/plugins/jquery.fancybox.min.js"></script>
  
  
<script src="/js/fancybox.js"></script>


  

  <script>
    var html = document.documentElement
    const colorMode = localStorage.getItem('color-mode')
    if (colorMode) {
      document.documentElement.setAttribute('color-mode', colorMode)
    }
  </script>
<meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="arttnba3's blog" type="application/atom+xml">
</head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a target="_blank" rel="noopener" href="https://arttnba3.cn">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img src="/img/avatar.png" alt="">
      
    </a>
    <div class="nickname"><a target="_blank" rel="noopener" href="https://arttnba3.cn">arttnba3's blog</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">Home</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">Archives</a>
        </li>
      
        <li class="nav-item" data-path="/categories/">
          <a href="/categories/">Categories</a>
        </li>
      
        <li class="nav-item" data-path="/tags/">
          <a href="/tags/">Tags</a>
        </li>
      
        <li class="nav-item" data-path="/friends/">
          <a href="/friends/">Friends</a>
        </li>
      
        <li class="nav-item" data-path="/about/">
          <a href="/about/">About</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->


  <!-- LaTex Display -->

  
    <script async type="text/javascript" src="/plugins/mathjax/tex-chtml.js"></script>
  
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    }
  </script>





  <!-- clipboard -->

  
    <script async type="text/javascript" src="/plugins/clipboard.min.js"></script>
  
  
<script src="/js/codeCopy.js"></script>







  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">【OS.0x03】Linux Kernel 内存管理浅析 II - Buddy System</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime" title="更新时间"></i>
          2022-06-30 23:44:49
        </span>
        
              <span class="post-categories">
                <i class="iconfont icon-bookmark" title="分类"></i>
                
                <span class="span--category">
                  <a href="/categories/OS/" title="OS">
                    <b>#</b> OS
                  </a>
                </span>
                
              </span>
          
              <span class="post-tags">
                <i class="iconfont icon-tags" title="标签"></i>
                
                <span class="span--tag">
                  <a href="/tags/Linux/" title="Linux">
                    <b>#</b> Linux
                  </a>
                </span>
                
                <span class="span--tag">
                  <a href="/tags/%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0/" title="学习札记">
                    <b>#</b> 学习札记
                  </a>
                </span>
                
                <span class="span--tag">
                  <a href="/tags/Linux-Kernel/" title="Linux Kernel">
                    <b>#</b> Linux Kernel
                  </a>
                </span>
                
                <span class="span--tag">
                  <a href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" title="内存管理">
                    <b>#</b> 内存管理
                  </a>
                </span>
                
                <span class="span--tag">
                  <a href="/tags/buddy-system/" title="buddy system">
                    <b>#</b> buddy system
                  </a>
                </span>
                
              </span>
          
      </div>
      <div class="markdown-body">
        <p>HEY DUDE!</p>
<span id="more"></span>

<h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><p>在<a target="_blank" rel="noopener" href="http://localhost:4000/2021/11/28/OS-0X02-LINUX-KERNEL-MEMORY-5.11-PART-I/">上一篇文章</a>中笔者简要阐述了 Linux 内核当中内存的基本组织架构：页、区、节点，在本篇文章当中笔者将阐述内核中最<strong>基础</strong>的内存分配器——<strong>Buddy Systen</strong>（伙伴系统）</p>
<blockquote>
<p>通过读取 <code>/proc/buddyinfo</code> 可以获取当前系统中 buddy system 的详细信息</p>
<p><img src="https://i.loli.net/2021/11/30/eRiVXpyUkncYZus.png" alt="image.png"></p>
<blockquote>
<p>笔者的💻配置比较🚮，所以只有一个 node，非常抱歉…</p>
</blockquote>
</blockquote>
<blockquote>
<p>这篇文章其实很早就写了个框架了，但是后面一直没有来得及进行补完…（其实就是懒而已吧（恼））</p>
<p><img src="https://s2.loli.net/2022/06/08/7VaQ6riZOcmDuEg.png" alt="image.png"></p>
</blockquote>
<h1 id="0x01-buddy-system-中的内存组织形式"><a href="#0x01-buddy-system-中的内存组织形式" class="headerlink" title="0x01.buddy system 中的内存组织形式"></a>0x01.buddy system 中的内存组织形式</h1><h2 id="zone-中的-free-area-结构体数组"><a href="#zone-中的-free-area-结构体数组" class="headerlink" title="zone 中的 free_area 结构体数组"></a>zone 中的 free_area 结构体数组</h2><p>前文中我们讲到，每个 zone 结构体中都有一个 free_area 结构体数组，用以存储 buddy system <strong>按照 order 管理的页面</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> &#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">free_area</span>	<span class="title">free_area</span>[<span class="title">MAX_ORDER</span>];</span></span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<p>其中的 <code>MAX_ORDER</code> 为一个常量，值为 11</p>
<p>在 buddy system 中按照空闲页面的连续大小进行分阶管理，这里的 order 的实际含义为<strong>连续的空闲页面的大小</strong>，不过单位不是页面数，而是<code>阶</code>，即对于每个下标而言，其中所存储的页面大小为：<br>$$<br>2^{order}<br>$$<br>在 free_area 中存放的页面通过自身的相应字段连接成双向链表结构，由此我们得到这样一张_Overview_：</p>
<p><img src="https://i.loli.net/2021/11/30/sOwdI5YMNUjLSib.png" alt="自己画的图.png"></p>
<p>下面我们来解析 <code>free_area</code> 的具体结构，该结构体定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">free_area</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">free_list</span>[<span class="title">MIGRATE_TYPES</span>];</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		nr_free;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="free-list：空闲页面双向链表"><a href="#free-list：空闲页面双向链表" class="headerlink" title="free_list：空闲页面双向链表"></a>free_list：空闲页面双向链表</h3><p>我们不难看出：free_area 的 free_list 字段便是用以存放指向空闲页面的指针，其通过 page 结构体的 <code>lru</code> 字段将 page 结构体连接成双向链表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> &#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span>	<span class="comment">/* 页缓存与匿名页 */</span></span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * @lru: Pageout 链表, 例如 active_list 便由</span></span><br><span class="line"><span class="comment">			 * lruvec-&gt;lru_lock 保护。  </span></span><br><span class="line"><span class="comment">			 * 有时会被页所有者作为常规链表使用。</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lru</span>;</span></span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<p>page 结构体中的 <code>lru</code> 这一字段的类型为 <code>struct list_head</code>，这是内核编程中通用的双向链表结构，<strong>free_list 与 lru 链表都使用该字段</strong> 将页结构体组织为_双向链表_，即_一个页是不可能同时出现在 lru 链表与 buddy system 中的_</p>
<h4 id="迁移类型分链表"><a href="#迁移类型分链表" class="headerlink" title="迁移类型分链表"></a><em>迁移类型分链表</em></h4><p>在这里我们注意到free_area 中<strong>并非只有一个双向链表</strong>，而是按照不同的“迁移类型”（migrate type）进行分开存放，这是由于_页面迁移_机制的存在</p>
<p>页面迁移主要用以解决内核空间中的<strong>碎片问题</strong>，在长期的运行之后内存当中空闲页面的分布可能是零散的，这便导致了内核<strong>有可能无法映射到足够大的连续内存</strong>，因此需要进行_页面迁移_——将旧的页面迁移到新的位置</p>
<p><img src="https://i.loli.net/2021/11/30/q7T6EjtIb9PVFY3.png" alt="从知乎偷的图.png"></p>
<p>但<strong>并非所有的页面都是能够随意迁移的</strong>，因此我们在 buddy system 当中还需要将页面按照迁移类型进行分类</p>
<p>迁移类型由一个枚举类型定义，定义于 <code>/include/linux/mmzone.h</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">migratetype</span> &#123;</span></span><br><span class="line">	MIGRATE_UNMOVABLE,</span><br><span class="line">	MIGRATE_MOVABLE,</span><br><span class="line">	MIGRATE_RECLAIMABLE,</span><br><span class="line">	MIGRATE_PCPTYPES,	<span class="comment">/* the number of types on the pcp lists */</span></span><br><span class="line">	MIGRATE_HIGHATOMIC = MIGRATE_PCPTYPES,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CMA</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * MIGRATE_CMA migration type is designed to mimic the way</span></span><br><span class="line"><span class="comment">	 * ZONE_MOVABLE works.  Only movable pages can be allocated</span></span><br><span class="line"><span class="comment">	 * from MIGRATE_CMA pageblocks and page allocator never</span></span><br><span class="line"><span class="comment">	 * implicitly change migration type of MIGRATE_CMA pageblock.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * The way to use it is to change migratetype of a range of</span></span><br><span class="line"><span class="comment">	 * pageblocks to MIGRATE_CMA which can be done by</span></span><br><span class="line"><span class="comment">	 * __free_pageblock_cma() function.  What is important though</span></span><br><span class="line"><span class="comment">	 * is that a range of pageblocks must be aligned to</span></span><br><span class="line"><span class="comment">	 * MAX_ORDER_NR_PAGES should biggest page be bigger then</span></span><br><span class="line"><span class="comment">	 * a single pageblock.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	MIGRATE_CMA,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMORY_ISOLATION</span></span><br><span class="line">	MIGRATE_ISOLATE,	<span class="comment">/* can&#x27;t allocate from here */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	MIGRATE_TYPES</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>MIGRATE_UNMOVABLE</strong>：这类型页面在内存当中有着固定的位置，<strong>不能移动</strong></li>
<li><strong>MIGRATE_MOVABLE</strong>：这类页面<strong>可以随意移动</strong>，例如用户空间的页面，我们只需要复制数据后改变页表映射即可</li>
<li><strong>MIGRATE_RECLAIMABLE</strong>：这类页面<strong>不能直接移动，但是可以删除</strong>，例如映射自文件的页</li>
<li><strong>MIGRATE_PCPTYPES</strong>：<code>per_cpu_pageset</code>，即每 CPU 页帧缓存，其迁移<strong>仅限于同一节点内</strong></li>
<li><strong>MIGRATE_CMA</strong>：<code>Contiguous Memory Allocator</code>，即<strong>连续的物理内存</strong></li>
<li><strong>MIGRATE_ISOLATE</strong>：<strong>不能从该链表分配页面</strong>，该链表用于跨 NUMA 节点进行页面移动，将页面移动到使用该页面最为频繁的 CPU 所处节点</li>
<li><em>MIGRATE_TYPES_：表示迁移类型的数目，_并不存在这一链表</em></li>
</ul>
<p>以 <em>free_list[0]</em> 作为例子，我们可以得到如下 overview：</p>
<p><img src="https://i.loli.net/2021/11/30/sbNImKo6tBS5GUe.png" alt="自己画的图.png"></p>
<h3 id="nr-free：空闲页面（块）计数"><a href="#nr-free：空闲页面（块）计数" class="headerlink" title="nr_free：空闲页面（块）计数"></a>nr_free：空闲页面（块）计数</h3><p>该字段记录了在当前 free_area 中的空闲页面块的数量，对于 free_area[0] 以外的 free_area 而言其单位并非是单个页框，而是以_内存块_为单位</p>
<h1 id="0x02-页的分配"><a href="#0x02-页的分配" class="headerlink" title="0x02.页的分配"></a>0x02.页的分配</h1><p>buddy system 提供了一组用以进行页面分配的接口，接下来笔者将以自底向上的方式进行源码分析</p>
<h2 id="一、GFP（get-free-page）标志位"><a href="#一、GFP（get-free-page）标志位" class="headerlink" title="一、GFP（get free page）标志位"></a>一、GFP（get free page）标志位</h2><blockquote>
<p>GFP标志位这一节基本上搬运自<a target="_blank" rel="noopener" href="https://blog.csdn.net/yhb1047818384/article/details/112298996">这篇文章</a></p>
</blockquote>
<p>在 kernel memory allocation 中我们经常能见到 <code>gfp_t</code> 类型，其表示分配时的标志位，定义在 <code>include/linux/gfp.h</code> 中，大概有如下这些可用标志位：</p>
<ul>
<li><strong>内存管理区修饰符 (zone modifiers)</strong></li>
</ul>
<p>内存管理区修饰符主要描述从哪些内存管理区来分配内存</p>
<table>
<thead>
<tr>
<th align="left">flag</th>
<th align="left">description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">__GFP_DMA</td>
<td align="left">从ZONE_DMA区中分配内存</td>
</tr>
<tr>
<td align="left">__GFP_HIGNMEM</td>
<td align="left">从ZONE_HIGHMEM区中分配内存</td>
</tr>
<tr>
<td align="left">__GFP_DMA32</td>
<td align="left">从ZONE_DMA32区中分配内存</td>
</tr>
<tr>
<td align="left">__GFP_MOVABLE</td>
<td align="left">内存规整时可以迁移或回收页面</td>
</tr>
</tbody></table>
<ul>
<li><strong>移动和替换修饰符(mobility and placement modifiers)</strong></li>
</ul>
<p>移动和替换修饰符主要表示分配出来的页面具有的迁移属性</p>
<table>
<thead>
<tr>
<th align="left">flag</th>
<th align="left">description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">__GFP_RECLAIMABLE</td>
<td align="left">分配的内存页面可以回收</td>
</tr>
<tr>
<td align="left">__GFP_WRITE</td>
<td align="left">申请的页面会被弄成脏页</td>
</tr>
<tr>
<td align="left">__GFP_HARDWALL</td>
<td align="left">强制使用cpuset内存分配策略</td>
</tr>
<tr>
<td align="left">__GFP_THISNODE</td>
<td align="left">在指定的节点上分配内存</td>
</tr>
<tr>
<td align="left">__GFP_ACCOUNT</td>
<td align="left">kmemcg会记录分配过程</td>
</tr>
</tbody></table>
<ul>
<li><strong>水位修饰符 （watermark modifiers）</strong></li>
</ul>
<p>与水位线相关的标志位</p>
<table>
<thead>
<tr>
<th align="left">flag</th>
<th align="left">description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">__GFP_ATOMIC</td>
<td align="left">高优先级分配内存，分配器可以分配最低警戒水位线下的预留内存</td>
</tr>
<tr>
<td align="left">__GFP_HIGH</td>
<td align="left">分配内存的过程中不可以睡眠或执行页面回收动作</td>
</tr>
<tr>
<td align="left">__GFP_MEMALLOC</td>
<td align="left">允许访问所有的内存</td>
</tr>
<tr>
<td align="left">__GFP_NOMEMALLOC</td>
<td align="left">不允许访问最低警戒水位线下的系统预留内存</td>
</tr>
</tbody></table>
<ul>
<li><strong>页面回收修饰符（reclaim modifiers)</strong></li>
</ul>
<p>与页面回收相关的标志位</p>
<table>
<thead>
<tr>
<th align="left">flag</th>
<th align="left">description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">__GFP_IO</td>
<td align="left">启动物理I&#x2F;O传输</td>
</tr>
<tr>
<td align="left">__GFP_FS</td>
<td align="left">允许调用底层FS文件系统。可避免分配器递归到可能已经持有锁的文件系统中， 避免死锁</td>
</tr>
<tr>
<td align="left">__GFP_DIRECT_RECLAIM</td>
<td align="left">分配内存过程中可以使用直接内存回收</td>
</tr>
<tr>
<td align="left">__GFP_KSWAPD_RECLAIM</td>
<td align="left">内存到达低水位时唤醒kswapd线程异步回收内存</td>
</tr>
<tr>
<td align="left">__GFP_RECLAIM</td>
<td align="left">表示是否可以直接内存回收或者使用kswapd线程进行回收</td>
</tr>
<tr>
<td align="left">__GFP_RETRY_MAYFAIL</td>
<td align="left">分配内存可以可能会失败，但是在申请过程中会回收一些不必要的内存，是整个系统受益</td>
</tr>
<tr>
<td align="left">__GFP_NOFAIL</td>
<td align="left">内存分配失败后无限制的重复尝试，知道分配成功</td>
</tr>
<tr>
<td align="left">__GFP_NORETRY</td>
<td align="left">直接页面回收或者内存规整后还是无法分配内存时，不启用retry反复尝试分配内存，直接返回NULL</td>
</tr>
</tbody></table>
<ul>
<li><strong>行为修饰符 (action modifiers)</strong></li>
</ul>
<p>与分配时的行为相关的标志位</p>
<table>
<thead>
<tr>
<th align="left">flag</th>
<th align="left">description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">__GFP_NOWARN</td>
<td align="left">关闭内存分配过程中的WARNING</td>
</tr>
<tr>
<td align="left">__GFP_COMP</td>
<td align="left">分配的内存页面将被组合成复合页compound page</td>
</tr>
<tr>
<td align="left">__GFP_ZERO</td>
<td align="left">返回一个全部填充为0的页面</td>
</tr>
</tbody></table>
<ul>
<li><strong>组合类型标志(Useful GFP flag combinations)</strong></li>
</ul>
<p>前面描述的修饰符种过于繁多，因此linux定义了一些组合的类型标志，供开发者使用。</p>
<table>
<thead>
<tr>
<th align="left">flag</th>
<th align="left">element</th>
<th align="left">description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">GFP_ATOMIC</td>
<td align="left">__GFP_HIGH |__GFP_ATOMIC |__GFP_KSWAPD_RECLAIM</td>
<td align="left">分配过程不能休眠，分配具有高优先级，可以访问系统预留内存</td>
</tr>
<tr>
<td align="left">GFP_KERNEL</td>
<td align="left">__GFP_RECLAIM |__GFP_IO |__GFP_FS</td>
<td align="left">分配内存时可以被阻塞(即休眠)</td>
</tr>
<tr>
<td align="left">GFP_KERNEL_ACCOUNT</td>
<td align="left">GFP_KERNEL |__GFP_ACCOUNT</td>
<td align="left">和GFP_KERNEL作用一样，但是分配的过程会被kmemcg记录</td>
</tr>
<tr>
<td align="left">GFP_NOWAIT</td>
<td align="left">__GFP_KSWAPD_RECLAIM</td>
<td align="left">分配过程中不允许因直接内存回收而导致停顿</td>
</tr>
<tr>
<td align="left">GFP_NOIO</td>
<td align="left">__GFP_RECLAIM</td>
<td align="left">不需要启动任何的I&#x2F;O操作</td>
</tr>
<tr>
<td align="left">GFP_NOFS</td>
<td align="left">__GFP_RECLAIM |__GFP_IO</td>
<td align="left">不会有访问任何文件系统的操作</td>
</tr>
<tr>
<td align="left">GFP_USER</td>
<td align="left">__GFP_RECLAIM |__GFP_IO |__GFP_FS |__GFP_HARDWALL</td>
<td align="left">用户空间的进程分配内存</td>
</tr>
<tr>
<td align="left">GFP_DMA</td>
<td align="left">__GFP_DMA</td>
<td align="left">从ZONE_DMA区分配内存</td>
</tr>
<tr>
<td align="left">GFP_DMA32</td>
<td align="left">__GFP_DMA32</td>
<td align="left">从ZONE_DMA32区分配内存</td>
</tr>
<tr>
<td align="left">GFP_HIGHUSER</td>
<td align="left">GFP_USER | __GFP_HIGHMEM</td>
<td align="left">用户进程分配内存，优先使用ZONE_HIGHMEM， 且这些页面不允许迁移</td>
</tr>
<tr>
<td align="left">GFP_HIGHUSER_MOVABLE</td>
<td align="left">GFP_HIGHUSER | __GFP_MOVABLE</td>
<td align="left">和GFP_HIGHUSER类似，但是页面可以迁移</td>
</tr>
<tr>
<td align="left">GFP_TRANSHUGE_LIGHT</td>
<td align="left">GFP_HIGHUSER_MOVABLE | __GFP_COMP | __GFP_NOMEMALLOC | __GFP_NOWARN) &amp; ~__GFP_RECLAIM</td>
<td align="left">透明大页的内存分配， light表示不进行内存压缩和回收</td>
</tr>
<tr>
<td align="left">GFP_TRANSHUGE</td>
<td align="left">GFP_TRANSHUGE_LIGHT | __GFP_DIRECT_RECLAIM</td>
<td align="left">和GFP_TRANSHUGE_LIGHT类似，通常khugepaged使用该标志</td>
</tr>
</tbody></table>
<h2 id="二、alloc-context-结构体：分配的上下文"><a href="#二、alloc-context-结构体：分配的上下文" class="headerlink" title="二、alloc_context 结构体：分配的上下文"></a>二、alloc_context 结构体：分配的上下文</h2><p>这是一个分配过程中非常重要的结构体，用来表示我们单次内存分配的上下文信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 用以保存在分配时涉及到的函数间传递的</span></span><br><span class="line"><span class="comment"> * 绝大部分的不可变的分配参数的结构体，</span></span><br><span class="line"><span class="comment"> * 包括 alloc_pages 函数族</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * nodemask, migratetype 与 highest_zoneidx 仅在</span></span><br><span class="line"><span class="comment"> * __alloc_pages_nodemask() 中被初始化一次，之后不再改变.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * zonelist, preferred_zone 与 highest_zoneidx 最初在</span></span><br><span class="line"><span class="comment"> * __alloc_pages_nodemask() 中为快速路径设置, 之后可能会在</span></span><br><span class="line"><span class="comment"> * __alloc_pages_slowpath() 中被改变. 其他所有的函数通过</span></span><br><span class="line"><span class="comment"> * 常量指针传递该结构体。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">alloc_context</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> *<span class="title">zonelist</span>;</span></span><br><span class="line">	<span class="type">nodemask_t</span> *nodemask;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> *<span class="title">preferred_zoneref</span>;</span></span><br><span class="line">	<span class="type">int</span> migratetype;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * highest_zoneidx 表示分配请求中最高的可用 zone 的下标。</span></span><br><span class="line"><span class="comment">	 * 由于 zone 的性质, 相较于 highest_zoneidx，</span></span><br><span class="line"><span class="comment">	 * 在更低的 zone 上的内存会由 lowmem_reserve[highest_zoneidx] 保护。</span></span><br><span class="line"><span class="comment">	 * 译注：就是水位线机制，不记得的回去看上一篇文章</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * highest_zoneidx 同样被回收/压缩使用以限制目标 zone，</span></span><br><span class="line"><span class="comment">	 * 因为高于该下标的 zone 无法用于此分配请求</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">zone_type</span> <span class="title">highest_zoneidx</span>;</span></span><br><span class="line">	<span class="type">bool</span> spread_dirty_pages;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们主要关注如下成员：</p>
<ul>
<li>zonelist</li>
</ul>
<p>该成员表示在<strong>这一次的分配上下文</strong>中，我们将要操作的 zone 的<strong>列表</strong>，其为一个 <code>zonelist</code> 类型的<strong>结构体数组</strong>，该结构体定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 单次分配请求在一个 zonelist 上操作. 一个 zonelist 便是一组 zone 的列表，</span></span><br><span class="line"><span class="comment"> * 其中第一个 zone 为分配的“目标”，而其他的 zone 为后备的zone，优先级降低。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 为了提高 zonelist 的读取速度, 在 zonerefs 中包含正在被读取的 entry 的 zone index。</span></span><br><span class="line"><span class="comment"> * 用来访问所给的 zoneref 结构体信息的帮助函数有：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * zonelist_zone()	- 返回一个 struct zone 的指针作为 _zonerefs 中的一个 entry</span></span><br><span class="line"><span class="comment"> * zonelist_zone_idx()	- 返回作为 entry 的 zone 的 index</span></span><br><span class="line"><span class="comment"> * zonelist_node_idx()	- 返回作为 entry 的 node 的 index</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> _<span class="title">zonerefs</span>[<span class="title">MAX_ZONES_PER_ZONELIST</span> + 1];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到的是其为一个  <code>zoneref</code> 类型的结构体数组，该结构体定义如下，包含了一个 zone 的指针以及一个 index：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 该结构包含了 zonelist 中一个 zone 的信息。 </span></span><br><span class="line"><span class="comment"> * 其被储存在这里以预防对大结构体的解引用与对表的查询。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>;</span>	<span class="comment">/* 指向实际上的 zone 的指针 */</span></span><br><span class="line">	<span class="type">int</span> zone_idx;		<span class="comment">/* zone_idx(zoneref-&gt;zone) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>preferred_zoneref</li>
</ul>
<p>该成员为一个 <code>zoneref</code> 类型的结构体，表示<strong>优先用来进行分配的 zone</strong></p>
<ul>
<li>spread_dirty_pages</li>
</ul>
<p>布尔值，表示<strong>此次分配是否可能产生脏页</strong>（需要进行写回），通常分配需要写入的页会出现</p>
<h2 id="三、-alloc-pages-nodemask-：分配页面的「核心函数」，返回-page-结构体"><a href="#三、-alloc-pages-nodemask-：分配页面的「核心函数」，返回-page-结构体" class="headerlink" title="三、__alloc_pages_nodemask()：分配页面的「核心函数」，返回 page 结构体"></a>三、__alloc_pages_nodemask()：分配页面的「核心函数」，返回 page 结构体</h2><p>该函数是 buddy system 中用以进行页面分配的<strong>核心函数</strong>，所有的页面分配 API 都是基于该函数的封装，其需要传入的四个参数为：</p>
<ul>
<li><code>gfp_mask</code>：分配行为参数（可以参见 <a target="_blank" rel="noopener" href="https://blog.csdn.net/choumin/article/details/109603011">这里</a>）</li>
<li><code>order</code>：分配的连续物理页框的阶</li>
<li><code>preferred_nid</code> 选取的节点的 id</li>
<li><code>nodemask</code>：</li>
</ul>
<p>返回值为分配的<strong>连续物理页</strong>中的第一张物理页的 <code>page</code> 结构体</p>
<blockquote>
<p>如果你已经不记得 page 结构体与物理页的页框号间的转换公式了，可以回去看<a target="_blank" rel="noopener" href="http://localhost:4000/2021/11/28/OS-0X02-LINUX-KERNEL-MEMORY-5.11-PART-I/#%EF%BC%881%EF%BC%89page-%E7%BB%93%E6%9E%84%E4%BD%93%E5%88%B0-PFN%EF%BC%9Apage-%E7%BB%93%E6%9E%84%E4%BD%93%E5%9C%B0%E5%9D%80%E5%87%8F%E5%8E%BB%E5%AF%B9%E5%BA%94-mem-section-gt-section-mem-map">上一篇文章</a></p>
<p>当然，笔者比较好心（笑），这里直接给出计算公式，<code>mem_section</code> 结构体中的 <code>section_mem_map</code> 成员存储了其起始地址减掉其起始地址对应的物理页框的页框号的差值，该成员与 page 结构体间做<strong>指针差值运算</strong>便能获得 page 结构体对应的物理页框号：<br>$$<br>address_{struct\ page} - section_mem_map &#x3D; address_{struct\ page} - (address_{mem_map} - start_PFN)\<br>&#x3D;(address_{struct\ page} - address_{mem_map}) + start_PFN<br>\<br>&#x3D;PFN<br>$$</p>
</blockquote>
<p>这是一张_Overview_</p>
<p><img src="https://i.loli.net/2021/11/30/9srbaMvWeTSO1hc.png" alt="从知乎偷的.png"></p>
<p>该函数定义于 <code>/mm/page_alloc.c</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is the &#x27;heart&#x27; of the zoned buddy allocator.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *</span></span><br><span class="line"><span class="class">__<span class="title">alloc_pages_nodemask</span>(<span class="title">gfp_t</span> <span class="title">gfp_mask</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>, <span class="title">int</span> <span class="title">preferred_nid</span>,</span></span><br><span class="line"><span class="class">							<span class="title">nodemask_t</span> *<span class="title">nodemask</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> alloc_flags = ALLOC_WMARK_LOW;</span><br><span class="line">	<span class="type">gfp_t</span> alloc_mask; <span class="comment">/* 实际用于分配的 gfp_t ，这是一个int类型的整型*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">alloc_context</span> <span class="title">ac</span> =</span> &#123; &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 我们假定 order 的值在一些地方是正常的，</span></span><br><span class="line"><span class="comment">	 * 因此若请求超出范围则提前退出</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(order &gt;= MAX_ORDER)) &#123;</span><br><span class="line">		WARN_ON_ONCE(!(gfp_mask &amp; __GFP_NOWARN));</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gfp_mask &amp;= gfp_allowed_mask;</span><br><span class="line">	alloc_mask = gfp_mask;</span><br><span class="line">	<span class="keyword">if</span> (!prepare_alloc_pages(gfp_mask, order, preferred_nid, nodemask, &amp;ac, &amp;alloc_mask, &amp;alloc_flags))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 直到所有的 local zone 都被考虑之前，</span></span><br><span class="line"><span class="comment">	 * 禁止从 falling back 到内存碎片种类的第一次传递</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	alloc_flags |= alloc_flags_nofragment(ac.preferred_zoneref-&gt;zone, gfp_mask);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 第一次分配尝试 */</span></span><br><span class="line">	page = get_page_from_freelist(alloc_mask, order, alloc_flags, &amp;ac);</span><br><span class="line">	<span class="keyword">if</span> (likely(page))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 应用作用域分配约束 这主要与 GFP_NOFS 有关。</span></span><br><span class="line"><span class="comment">	 * GFP_NOIO 必须从一个特定的由 memalloc_no&#123;fs,io&#125;_&#123;save,restore&#125;</span></span><br><span class="line"><span class="comment">	 * 所标记的上下文中所有的分配请求中继承</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	alloc_mask = current_gfp_context(gfp_mask);</span><br><span class="line">	ac.spread_dirty_pages = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 恢复最初的 nodemask （其可能被替换为 &amp;cpuset_current_mems_allowed</span></span><br><span class="line"><span class="comment">	 * 以优化快速（分配）路径的尝试）</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ac.nodemask = nodemask;</span><br><span class="line"></span><br><span class="line">	page = __alloc_pages_slowpath(alloc_mask, order, &amp;ac);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">if</span> (memcg_kmem_enabled() &amp;&amp; (gfp_mask &amp; __GFP_ACCOUNT) &amp;&amp; page &amp;&amp;</span><br><span class="line">	    unlikely(__memcg_kmem_charge_page(page, gfp_mask, order) != <span class="number">0</span>)) &#123;</span><br><span class="line">		__free_pages(page, order);</span><br><span class="line">		page = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	trace_mm_page_alloc(page, order, alloc_mask, ac.migratetype);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__alloc_pages_nodemask);</span><br></pre></td></tr></table></figure>

<p>这个函数的具体步骤主要分为三步：</p>
<ul>
<li>检查参数合法性，并做分配前准备工作</li>
<li>进行<strong>快速分配</strong>，成功则直接返回结果</li>
<li>若快速分配失败，则进行<strong>慢速分配</strong></li>
</ul>
<p>接下来我们来深入快速分配与慢速分配的内部细节</p>
<h3 id="I-prepare-alloc-pages-：分配前的准备工作"><a href="#I-prepare-alloc-pages-：分配前的准备工作" class="headerlink" title="I. prepare_alloc_pages()：分配前的准备工作"></a>I. prepare_alloc_pages()：分配前的准备工作</h3><p>这个函数比较简单，主要是做分配前的一些准备的工作，包括初始化 <code>alloc_context</code> 结构体、获取 zone 数组等：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">prepare_alloc_pages</span><span class="params">(<span class="type">gfp_t</span> gfp_mask, <span class="type">unsigned</span> <span class="type">int</span> order,</span></span><br><span class="line"><span class="params">		<span class="type">int</span> preferred_nid, <span class="type">nodemask_t</span> *nodemask,</span></span><br><span class="line"><span class="params">		<span class="keyword">struct</span> alloc_context *ac, <span class="type">gfp_t</span> *alloc_mask,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">int</span> *alloc_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	ac-&gt;highest_zoneidx = gfp_zone(gfp_mask);</span><br><span class="line">	ac-&gt;zonelist = node_zonelist(preferred_nid, gfp_mask); <span class="comment">// 获取 zonelist</span></span><br><span class="line">	ac-&gt;nodemask = nodemask;</span><br><span class="line">	ac-&gt;migratetype = gfp_migratetype(gfp_mask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若开启了 cpuset（限制某一组进程只运行在某些cpu和内存节点上），则设置对应的标志位。</span></span><br><span class="line">	<span class="keyword">if</span> (cpusets_enabled()) &#123;</span><br><span class="line">		*alloc_mask |= __GFP_HARDWALL;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 若我们在中断上下文中, 则这与当前进程上下文无关。</span></span><br><span class="line"><span class="comment">		 * 这意味着任一 node 都是 ok 的.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!in_interrupt() &amp;&amp; !ac-&gt;nodemask)</span><br><span class="line">			ac-&gt;nodemask = &amp;cpuset_current_mems_allowed;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			*alloc_flags |= ALLOC_CPUSET;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fs_reclaim_acquire(gfp_mask);</span><br><span class="line">	fs_reclaim_release(gfp_mask);</span><br><span class="line"></span><br><span class="line">	might_sleep_if(gfp_mask &amp; __GFP_DIRECT_RECLAIM);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (should_fail_alloc_page(gfp_mask, order))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	*alloc_flags = current_alloc_flags(gfp_mask, *alloc_flags);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Dirty zone 的平衡仅在 fast path 中完成 */</span></span><br><span class="line">	ac-&gt;spread_dirty_pages = (gfp_mask &amp; __GFP_WRITE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * preferred zone 被用于进行数据统计， 但非常重要的是其页被用作</span></span><br><span class="line"><span class="comment">	 * zonelist 迭代器的起始点. 对于忽略内存策略的分配，其可能会被重置。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ac-&gt;preferred_zoneref = first_zones_zonelist(ac-&gt;zonelist,</span><br><span class="line">					ac-&gt;highest_zoneidx, ac-&gt;nodemask);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先调用 <code>node_zonelist()</code> 从 <code>preferred_nid</code> 参数所指定的 node 中获取一个 zonelist，其实就是取 <code>pglist_data-&gt;node_zonelists[gfp_zonelist(flags)]</code></li>
<li>进行 cpuset 相关判断与标志位设置，若是在中断上下文则直接将 nodemask 设为 <code>cpuset_current_mems_allowed</code></li>
<li>最后调用 <code>first_zones_zonelist()</code> 设置 preferred zone，大概是在 zonelist 中→nodemask 所包含的 zone 中→ <code>highest_zoneidx</code> 以下的第一个 zone</li>
</ul>
<blockquote>
<p>反正源码注释是这么写的hhh</p>
</blockquote>
<h3 id="II-get-page-from-freelist-：快速分配路径（核心分配函数）"><a href="#II-get-page-from-freelist-：快速分配路径（核心分配函数）" class="headerlink" title="II. get_page_from_freelist()：快速分配路径（核心分配函数）"></a>II. get_page_from_freelist()：快速分配路径（核心分配函数）</h3><p>该函数定义于 <code>/mm/page_alloc.c</code> 中，主要是遍历分配上下文对应的 zonelist 中的 zone 进行内存分配，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * get_page_from_freelist 遍历 zonelist 尝试分配页面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> page *</span><br><span class="line"><span class="title function_">get_page_from_freelist</span><span class="params">(<span class="type">gfp_t</span> gfp_mask, <span class="type">unsigned</span> <span class="type">int</span> order, <span class="type">int</span> alloc_flags,</span></span><br><span class="line"><span class="params">						<span class="type">const</span> <span class="keyword">struct</span> alloc_context *ac)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> *<span class="title">z</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span> *<span class="title">last_pgdat_dirty_limit</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">bool</span> no_fallback;</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 扫描 zonelist, 寻找有着足够空闲页面的 zone.</span></span><br><span class="line"><span class="comment">	 * 参见 __cpuset_node_allowed() 的注释（kernel/cpuset.c）</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	no_fallback = alloc_flags &amp; ALLOC_NOFRAGMENT; <span class="comment">// 避免内存碎片的flag</span></span><br><span class="line">	z = ac-&gt;preferred_zoneref; <span class="comment">// 先尝试从 preferred zone 中分配</span></span><br><span class="line">    <span class="comment">// 这是一个封装宏，表示从 z 开始遍历 zonelist 中的 zoneref 数组，</span></span><br><span class="line">    <span class="comment">// 其核心是单次迭代调用 next_zones_zonelist()，该函数返回:</span></span><br><span class="line">    <span class="comment">// 		在 nodemask 的 zone 中，以当前 zone 作为起点游标的</span></span><br><span class="line">    <span class="comment">// 		【位于或低于】highest_zoneidx 的下一个 zone</span></span><br><span class="line">	for_next_zone_zonelist_nodemask(zone, z, ac-&gt;highest_zoneidx,</span><br><span class="line">					ac-&gt;nodemask) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> mark;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开启了 cpuset 且 flag 中有 ALLOC_CPUSET 标志位，</span></span><br><span class="line">        <span class="comment">// 但是 cpuset 中不允许以该 gfp_mask 在该 zone 中分配，</span></span><br><span class="line">        <span class="comment">// 进行下一次迭代</span></span><br><span class="line">		<span class="keyword">if</span> (cpusets_enabled() &amp;&amp;</span><br><span class="line">			(alloc_flags &amp; ALLOC_CPUSET) &amp;&amp;</span><br><span class="line">			!__cpuset_zone_allowed(zone, gfp_mask))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 在分配页缓存（page cache）页以进行写入时, 我们想要</span></span><br><span class="line"><span class="comment">		 * 在一个节点的“脏限制”（dirty limit）内获得他, </span></span><br><span class="line"><span class="comment">         * 由此，没有一个节点有着超过全局允许的脏页比例。</span></span><br><span class="line"><span class="comment">		 * 脏限制考虑了节点的低端内存保留和高水位线，</span></span><br><span class="line"><span class="comment">		 * 以便于 kswapd 能平衡它，而不必从其 LRU 列表中写入页面。</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">XXX:</span> 现在, 在进入回收之前，</span></span><br><span class="line"><span class="comment">		 * 允许分配可能超过 慢速路径中 (spread_dirty_pages unset)</span></span><br><span class="line"><span class="comment">		 * 单节点的 dirty limit，这在一个允许节点们在一起都未够大以达到全局限制</span></span><br><span class="line"><span class="comment">         * 的 NUMA 设置中是很重要的。对于这些情况的合适的修补将需要对</span></span><br><span class="line"><span class="comment">		 * dirty-throttling 与 flusher threads 中节点的意识.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        <span class="comment">// 译注：原文就是XXX，笔者也不知道这个XXX是什么...</span></span><br><span class="line">        <span class="comment">// 大概就是检查当前zone对应node的脏页数量是不是达到限制了</span></span><br><span class="line">		<span class="keyword">if</span> (ac-&gt;spread_dirty_pages) &#123;</span><br><span class="line">			<span class="keyword">if</span> (last_pgdat_dirty_limit == zone-&gt;zone_pgdat)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!node_dirty_ok(zone-&gt;zone_pgdat)) &#123;</span><br><span class="line">				last_pgdat_dirty_limit = zone-&gt;zone_pgdat;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// node 数量大于1，且当前 zone 并非 preferred zone</span></span><br><span class="line">		<span class="keyword">if</span> (no_fallback &amp;&amp; nr_online_nodes &gt; <span class="number">1</span> &amp;&amp;</span><br><span class="line">		    zone != ac-&gt;preferred_zoneref-&gt;zone) &#123;</span><br><span class="line">			<span class="type">int</span> local_nid;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * 若移动到了 remote node（译注：非当前node？）, 则重试，</span></span><br><span class="line"><span class="comment">			 * 但允许 fragmenting fallbacks. 局部性比避免碎片更加重要。</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">            <span class="comment">// 比对当前 zone 是否在 local node（就是离当前CPU最近那个 node）</span></span><br><span class="line">            <span class="comment">// 若否，则去掉 ALLOC_NOFRAGMENT 标志位，并从 preferred zone 开始重试。</span></span><br><span class="line">            <span class="comment">// 即：kernel 更倾向于优先从 local zone 进行分配，哪怕会产生内存碎片</span></span><br><span class="line">			local_nid = zone_to_nid(ac-&gt;preferred_zoneref-&gt;zone);</span><br><span class="line">			<span class="keyword">if</span> (zone_to_nid(zone) != local_nid) &#123;</span><br><span class="line">				alloc_flags &amp;= ~ALLOC_NOFRAGMENT;</span><br><span class="line">				<span class="keyword">goto</span> retry;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前 zone 的水位线标记</span></span><br><span class="line">		mark = wmark_pages(zone, alloc_flags &amp; ALLOC_WMARK_MASK);</span><br><span class="line">		<span class="keyword">if</span> (!zone_watermark_fast(zone, order, mark,</span><br><span class="line">				       ac-&gt;highest_zoneidx, alloc_flags,</span><br><span class="line">				       gfp_mask)) &#123; <span class="comment">// 水位线相关操作</span></span><br><span class="line">			<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEFERRED_STRUCT_PAGE_INIT</span></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * 该 zone 的水位线失败, 但若其包含了 deferred pages，</span></span><br><span class="line"><span class="comment">			 * 则我们会看该 zone 是否还能再进行扩展</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (static_branch_unlikely(&amp;deferred_pages)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (_deferred_grow_zone(zone, order))</span><br><span class="line">					<span class="keyword">goto</span> try_this_zone;</span><br><span class="line">			&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">			<span class="comment">/* Checked here to keep the fast path fast */</span></span><br><span class="line">			BUILD_BUG_ON(ALLOC_NO_WATERMARKS &lt; NR_WMARK);</span><br><span class="line">            <span class="comment">// 该标志位意为【不检查水位线】，此时我们直接尝试从该 zone 中分配</span></span><br><span class="line">			<span class="keyword">if</span> (alloc_flags &amp; ALLOC_NO_WATERMARKS)</span><br><span class="line">				<span class="keyword">goto</span> try_this_zone;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (node_reclaim_mode == <span class="number">0</span> ||</span><br><span class="line">			    !zone_allows_reclaim(ac-&gt;preferred_zoneref-&gt;zone, zone))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 首先进行页面回收，之后查看是否满足水位线要求，若‘</span></span><br><span class="line">            <span class="comment">// 		不扫描/没有可回收/检查未通过</span></span><br><span class="line">            <span class="comment">// 则都会进行下一次迭代，尝试下一个 zone</span></span><br><span class="line">			ret = node_reclaim(zone-&gt;zone_pgdat, gfp_mask, order);</span><br><span class="line">			<span class="keyword">switch</span> (ret) &#123;</span><br><span class="line">			<span class="keyword">case</span> NODE_RECLAIM_NOSCAN:</span><br><span class="line">				<span class="comment">/* 不扫描 */</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">case</span> NODE_RECLAIM_FULL:</span><br><span class="line">				<span class="comment">/* 扫描了但不可回收 */</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="comment">/* 检查我们是否回收了足够页面 */</span></span><br><span class="line">				<span class="keyword">if</span> (zone_watermark_ok(zone, order, mark,</span><br><span class="line">					ac-&gt;highest_zoneidx, alloc_flags))</span><br><span class="line">					<span class="keyword">goto</span> try_this_zone;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">try_this_zone:</span><br><span class="line">        <span class="comment">// 来到该 label 表示我们终于通过了前面一系列的各种检查，现在开始正式进行页面分配</span></span><br><span class="line">        <span class="comment">// **************************</span></span><br><span class="line">        <span class="comment">// rmqueue() 即为我们在OS教科书上看到的的 buddy system 模型,</span></span><br><span class="line">        <span class="comment">// 取 freelist 对应下标 page，若无则向上遍历拆更高 order 的 page</span></span><br><span class="line">        <span class="comment">// **************************</span></span><br><span class="line">		page = rmqueue(ac-&gt;preferred_zoneref-&gt;zone, zone, order,</span><br><span class="line">				gfp_mask, alloc_flags, ac-&gt;migratetype);</span><br><span class="line">		<span class="keyword">if</span> (page) &#123;</span><br><span class="line">			prep_new_page(page, order, gfp_mask, alloc_flags);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * 若这是一个高阶的原子分配，</span></span><br><span class="line"><span class="comment">			 * 检查我们是否该为将来保留 pageblock</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (unlikely(order &amp;&amp; (alloc_flags &amp; ALLOC_HARDER)))</span><br><span class="line">				reserve_highatomic_pageblock(page, zone, order);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> page;	<span class="comment">// 取到了，返回</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;	<span class="comment">// 没取到</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEFERRED_STRUCT_PAGE_INIT</span></span><br><span class="line">			<span class="comment">/* 若该 zone 有 deferred pages，再试一遍 */</span></span><br><span class="line">			<span class="keyword">if</span> (static_branch_unlikely(&amp;deferred_pages)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (_deferred_grow_zone(zone, order))</span><br><span class="line">					<span class="keyword">goto</span> try_this_zone;</span><br><span class="line">			&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 在一台 UMA 机器上可能所以的 zone 都是破碎的，</span></span><br><span class="line"><span class="comment">	 * 若避免碎片, 重置并重试.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (no_fallback) &#123;</span><br><span class="line">		alloc_flags &amp;= ~ALLOC_NOFRAGMENT;</span><br><span class="line">		<span class="keyword">goto</span> retry;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数流程总结如下：</p>
<ul>
<li><p><code>for_next_zone_zonelist_nodemask</code> 迭代遍历分配上下文中 zonelist 中的 zoneref 数组 对应的 zone</p>
<blockquote>
<p>其核心是单次迭代调用 next_zones_zonelist()，该函数返回:</p>
<ul>
<li>在 nodemask 的 zone 中，以当前 zone 作为起点游标的【位于或低于】highest_zoneidx 的下一个 zone</li>
</ul>
</blockquote>
<ul>
<li><p>若开启了 cpuset，检查当前 zone 是否满足 cpuset 的要求，若否，则尝试下一个 zone</p>
</li>
<li><p>检查当前 zone 对应 node 的脏页数量是否超出限制，若否，则尝试下一个 zone</p>
</li>
<li><p>若 <code>ALLOC_NOFRAGMENT</code> 但是当前 zone 非 preferred zone、且对应 node 为 remote node，则清除该标志位后<strong>重新开始分配</strong>，因为 locality 比避免碎片更加重要</p>
</li>
<li><p>获取当前 zone 的水位线标记</p>
<ul>
<li>若是设置了 <code>ALLOC_NO_WATERMARKS</code> 则直接到下一步进行分配</li>
<li>若水位线检查未通过，调用 <code>node_reclaim()</code> 进行页面回收</li>
<li>若回收后页面还是不足，则尝试下一个 zone</li>
</ul>
</li>
<li><p>调用 <code>rmqueue()</code> 正式进行内存分配，该函数即为 buddy system 分配算法</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://s2.loli.net/2022/07/05/SJMKys31ofnTPXc.png" alt="偷的图.png"></p>
<h4 id="rmqueue-：从给定的-page-中进行页面分配"><a href="#rmqueue-：从给定的-page-中进行页面分配" class="headerlink" title="rmqueue()：从给定的 page 中进行页面分配"></a>rmqueue()：从给定的 page 中进行页面分配</h4><p>该函数定义于 <code>/mm/page_alloc.c</code> 中，主要是从给定 zone 中进行内存分配</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 从给定 zone 中进行内存分配. 对于 order-0 的分配则使用 pcplists.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span></span><br><span class="line"><span class="keyword">struct</span> page *<span class="title function_">rmqueue</span><span class="params">(<span class="keyword">struct</span> zone *preferred_zone,</span></span><br><span class="line"><span class="params">			<span class="keyword">struct</span> zone *zone, <span class="type">unsigned</span> <span class="type">int</span> order,</span></span><br><span class="line"><span class="params">			<span class="type">gfp_t</span> gfp_flags, <span class="type">unsigned</span> <span class="type">int</span> alloc_flags,</span></span><br><span class="line"><span class="params">			<span class="type">int</span> migratetype)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (likely(order == <span class="number">0</span>)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * MIGRATE_MOVABLE 的 pcplist 可能在 CMA 区域有着页面，</span></span><br><span class="line"><span class="comment">		 * 当从 CMA 的分配不被允许时我们需要略过它</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        <span class="comment">// 对于 order-0 的分配，</span></span><br><span class="line">        <span class="comment">// 若没有开启 CMA | 设置了 ALLOC_CMA | 迁移类型非 MIGRATE_MOVABLE</span></span><br><span class="line">        <span class="comment">// 则先从 pcplist 上分配</span></span><br><span class="line">		<span class="keyword">if</span> (!IS_ENABLED(CONFIG_CMA) || alloc_flags &amp; ALLOC_CMA ||</span><br><span class="line">				migratetype != MIGRATE_MOVABLE) &#123;</span><br><span class="line">			page = rmqueue_pcplist(preferred_zone, zone, gfp_flags,</span><br><span class="line">					migratetype, alloc_flags);</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 我们绝不希望 callers 尝试</span></span><br><span class="line"><span class="comment">	 * 在带有 __GFP_NOFAIL 时分配大于 order-1 的页</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	WARN_ON_ONCE((gfp_flags &amp; __GFP_NOFAIL) &amp;&amp; (order &gt; <span class="number">1</span>));</span><br><span class="line">	spin_lock_irqsave(&amp;zone-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		page = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 若由于非CMA的分配上下文导致略过了 pcplist，则order-0 的请求可以到达此处.</span></span><br><span class="line"><span class="comment">		 * HIGHATOMIC 区域为更高 order 的原子分配所保留，</span></span><br><span class="line"><span class="comment">		 * 故 order-0 的请求应略过它。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        <span class="comment">// 若 order &gt; 0 且带有 ALLOC_HARDER 标志位，调用 __rmqueue_smallest() 分配</span></span><br><span class="line">        <span class="comment">// 这个标志位意为将水位线减去 1/4，实际上 GFP_ATOMIC 中便会包含该标志位</span></span><br><span class="line">		<span class="keyword">if</span> (order &gt; <span class="number">0</span> &amp;&amp; alloc_flags &amp; ALLOC_HARDER) &#123;</span><br><span class="line">			page = __rmqueue_smallest(zone, order, MIGRATE_HIGHATOMIC);</span><br><span class="line">			<span class="keyword">if</span> (page)</span><br><span class="line">				trace_mm_page_alloc_zone_locked(page, order, migratetype);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 调用 __rmqueue() 进行分配，这个就是真正的核心分配函数了</span></span><br><span class="line">		<span class="keyword">if</span> (!page)</span><br><span class="line">			page = __rmqueue(zone, order, migratetype, alloc_flags);</span><br><span class="line">	&#125; <span class="keyword">while</span> (page &amp;&amp; check_new_pages(page, order)); <span class="comment">// 这个检查函数通过了返回false</span></span><br><span class="line">	spin_unlock(&amp;zone-&gt;lock);</span><br><span class="line">	<span class="keyword">if</span> (!page)</span><br><span class="line">		<span class="keyword">goto</span> failed;</span><br><span class="line">	__mod_zone_freepage_state(zone, -(<span class="number">1</span> &lt;&lt; order),</span><br><span class="line">				  get_pcppage_migratetype(page));</span><br><span class="line"></span><br><span class="line">	__count_zid_vm_events(PGALLOC, page_zonenum(page), <span class="number">1</span> &lt;&lt; order);</span><br><span class="line">	zone_statistics(preferred_zone, zone);</span><br><span class="line">	local_irq_restore(flags);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	<span class="comment">/* Separate test+clear to avoid unnecessary atomics */</span></span><br><span class="line">	<span class="keyword">if</span> (test_bit(ZONE_BOOSTED_WATERMARK, &amp;zone-&gt;flags)) &#123;</span><br><span class="line">		clear_bit(ZONE_BOOSTED_WATERMARK, &amp;zone-&gt;flags);</span><br><span class="line">		wakeup_kswapd(zone, <span class="number">0</span>, <span class="number">0</span>, zone_idx(zone));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	VM_BUG_ON_PAGE(page &amp;&amp; bad_range(zone, page), page);</span><br><span class="line">	<span class="keyword">return</span> page;</span><br><span class="line"></span><br><span class="line">failed:</span><br><span class="line">	local_irq_restore(flags);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析函数流程前我们先回顾一下这个概念——<code>per-cpu pageset</code> ，这是 zone 上的一个 per-cpu 的页面集，在分配时会优先从这里进行分配</p>
<p>该函数其实还是对分配的核心逻辑的封装，主要是以下流程：</p>
<ul>
<li>分配的 order 为 0，若没有开启 CMA | 设置了 ALLOC_CMA | 迁移类型非 MIGRATE_MOVABLE，则尝试从 per-cpu pageset 中分配并返回</li>
<li>order &gt; 0，调用 <code>__rmqueue_smallest()</code> 进行页面分配</li>
<li>之前未分配成功，调用 <code>__rmqueue()</code> 进行页面分配</li>
<li>结果检查，其中循环内是用 <code>check_new_pages()</code>，未通过则重新循环（回到第二步）</li>
</ul>
<h5 id="①-rmqueue-pcplist-：从-per-cpu-pageset-上做-order-0-的分配"><a href="#①-rmqueue-pcplist-：从-per-cpu-pageset-上做-order-0-的分配" class="headerlink" title="① rmqueue_pcplist()：从 per-cpu pageset 上做 order-0 的分配"></a>① rmqueue_pcplist()：从 per-cpu pageset 上做 order-0 的分配</h5><p>主要是关中断→页面分配→开中断三步走，最后分配调用到的是 <code>__rmqueue_pcplist()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Lock and remove page from the per-cpu list */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> page *<span class="title function_">rmqueue_pcplist</span><span class="params">(<span class="keyword">struct</span> zone *preferred_zone,</span></span><br><span class="line"><span class="params">			<span class="keyword">struct</span> zone *zone, <span class="type">gfp_t</span> gfp_flags,</span></span><br><span class="line"><span class="params">			<span class="type">int</span> migratetype, <span class="type">unsigned</span> <span class="type">int</span> alloc_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pages</span> *<span class="title">pcp</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">	local_irq_save(flags); <span class="comment">// 关中断</span></span><br><span class="line">	pcp = &amp;this_cpu_ptr(zone-&gt;pageset)-&gt;pcp;</span><br><span class="line">	<span class="built_in">list</span> = &amp;pcp-&gt;lists[migratetype]; <span class="comment">// 获取迁移类型链表</span></span><br><span class="line">	page = __rmqueue_pcplist(zone,  migratetype, alloc_flags, pcp, <span class="built_in">list</span>); <span class="comment">// 分配</span></span><br><span class="line">	<span class="keyword">if</span> (page) &#123;</span><br><span class="line">		__count_zid_vm_events(PGALLOC, page_zonenum(page), <span class="number">1</span>);</span><br><span class="line">		zone_statistics(preferred_zone, zone);</span><br><span class="line">	&#125;</span><br><span class="line">	local_irq_restore(flags); <span class="comment">// 开中断</span></span><br><span class="line">	<span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>__rmqueue_pcplist()</code> 主要就是一个大循环，若 pcplist 为空则调用 <code>rmqueue_bulk()</code> 先从 zone 上拿 pages，之后就是简单的链表脱链，分配结果使用 <code>check_new_page()</code> 进行检查：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 从 per-cpu 链表上取出 page, 调用者必须保护链表 */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *__<span class="title">rmqueue_pcplist</span>(<span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>, <span class="title">int</span> <span class="title">migratetype</span>,</span></span><br><span class="line"><span class="class">			<span class="title">unsigned</span> <span class="title">int</span> <span class="title">alloc_flags</span>,</span></span><br><span class="line"><span class="class">			<span class="keyword">struct</span> <span class="title">per_cpu_pages</span> *<span class="title">pcp</span>,</span></span><br><span class="line"><span class="class">			<span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">list</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (list_empty(<span class="built_in">list</span>)) &#123; <span class="comment">// list 是空的</span></span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">			pcp-&gt;count += rmqueue_bulk(zone, <span class="number">0</span>,</span><br><span class="line">					READ_ONCE(pcp-&gt;batch), <span class="built_in">list</span>,</span><br><span class="line">					migratetype, alloc_flags);</span><br><span class="line">			<span class="keyword">if</span> (unlikely(list_empty(<span class="built_in">list</span>)))</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 链表脱链</span></span><br><span class="line">		page = list_first_entry(<span class="built_in">list</span>, <span class="keyword">struct</span> page, lru);</span><br><span class="line">		list_del(&amp;page-&gt;lru);</span><br><span class="line">		pcp-&gt;count--;</span><br><span class="line">	&#125; <span class="keyword">while</span> (check_new_pcp(page));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>rmqueue_bulk()</code> 则最终会调用到 <code>__rmqueue()</code> 为 pcplist 进行 <code>pcp-&gt;batch</code> 次的 order-0 的页面分配，并建立链表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 为了高效率，从 buddy 分配器获得指定数量的元素, </span></span><br><span class="line"><span class="comment"> * 所有的单个元素都在持有锁的情况下进行.  将其添加到提供的链表中.</span></span><br><span class="line"><span class="comment"> * 返回放置在 *list 链表上的 pages 数量.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">rmqueue_bulk</span><span class="params">(<span class="keyword">struct</span> zone *zone, <span class="type">unsigned</span> <span class="type">int</span> order,</span></span><br><span class="line"><span class="params">			<span class="type">unsigned</span> <span class="type">long</span> count, <span class="keyword">struct</span> list_head *<span class="built_in">list</span>,</span></span><br><span class="line"><span class="params">			<span class="type">int</span> migratetype, <span class="type">unsigned</span> <span class="type">int</span> alloc_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, alloced = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	spin_lock(&amp;zone-&gt;lock);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> __rmqueue(zone, order, migratetype,</span><br><span class="line">								alloc_flags);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(page == <span class="literal">NULL</span>))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (unlikely(check_pcp_refill(page)))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 由 expand() 返回的分割 buddy 页面在此处以物理页框顺序接收。</span></span><br><span class="line"><span class="comment">		 * 页面被添加到 caller 的链表尾部。从 caller 的角度看，链表在</span></span><br><span class="line"><span class="comment">		 * 某些情况下是按照页码排序的。这对一些可以从头部前向的IO设备是有用的，</span></span><br><span class="line"><span class="comment">		 * 因为链表也是在物理页的顺序上的。这对于可以在物理页合理排序的情况下</span></span><br><span class="line"><span class="comment">		 * 合并IO请求的IO设备是有用的。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		list_add_tail(&amp;page-&gt;lru, <span class="built_in">list</span>);</span><br><span class="line">		alloced++;</span><br><span class="line">		<span class="keyword">if</span> (is_migrate_cma(get_pcppage_migratetype(page)))</span><br><span class="line">			__mod_zone_page_state(zone, NR_FREE_CMA_PAGES,</span><br><span class="line">					      -(<span class="number">1</span> &lt;&lt; order));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * i pages were removed from the buddy list even if some leak due</span></span><br><span class="line"><span class="comment">	 * to check_pcp_refill failing so adjust NR_FREE_PAGES based</span></span><br><span class="line"><span class="comment">	 * on i. Do not confuse with &#x27;alloced&#x27; which is the number of</span></span><br><span class="line"><span class="comment">	 * pages added to the pcp list.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	__mod_zone_page_state(zone, NR_FREE_PAGES, -(i &lt;&lt; order));</span><br><span class="line">	spin_unlock(&amp;zone-&gt;lock);</span><br><span class="line">	<span class="keyword">return</span> alloced;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="②-rmqueue-smallest-：遍历指定-migrationtype-链表的-buddy-算法（核心中的核心）"><a href="#②-rmqueue-smallest-：遍历指定-migrationtype-链表的-buddy-算法（核心中的核心）" class="headerlink" title="② __rmqueue_smallest()：遍历指定 migrationtype 链表的 buddy 算法（核心中的核心）"></a>② __rmqueue_smallest()：遍历指定 migrationtype 链表的 buddy 算法（核心中的核心）</h5><p>我们重新来回顾一下 <code>free_area</code> 的结构，在其中根据迁移类型分成了多个链表：</p>
<p><img src="https://i.loli.net/2021/11/30/sbNImKo6tBS5GUe.png" alt="自己画的图.png"></p>
<p>而一个 zone 是由多个 <code>free_area</code> 组成的，一个 <code>free_area</code> 对应一个 order，那么对于该函数而言其只会遍历特定的 order，那么就成了下面的模型：</p>
<p><img src="https://i.loli.net/2021/11/30/sOwdI5YMNUjLSib.png" alt="自己画的图.png"></p>
<p>现在我们可以以来看这个函数了：从待分配 order 所对应的 <code>free_area</code> 的指定的 migration type 链表上分配，若不够则一直向更高 order 进行分配后对半向下拆到低 order，这里向更高 order 分配是通过简单的循环 + 链表脱链操作完成的，而拆高阶 page 的操作则是通过 <code>expand()</code> 完成的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 对给定的 migrationtype 遍历 free lists </span></span><br><span class="line"><span class="comment"> * 并从 freelists 上移除最小可用的页面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> __always_inline</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *__<span class="title">rmqueue_smallest</span>(<span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>,</span></span><br><span class="line"><span class="class">						<span class="title">int</span> <span class="title">migratetype</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> current_order;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">free_area</span> *<span class="title">area</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 在 preferred list 上寻找一个合适 size 的 page */</span></span><br><span class="line">	<span class="keyword">for</span> (current_order = order; current_order &lt; MAX_ORDER; ++current_order) &#123;</span><br><span class="line">		area = &amp;(zone-&gt;free_area[current_order]);</span><br><span class="line">		page = get_page_from_free_area(area, migratetype);</span><br><span class="line">		<span class="keyword">if</span> (!page)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		del_page_from_free_list(page, zone, current_order);</span><br><span class="line">		expand(zone, page, order, current_order, migratetype);</span><br><span class="line">		set_pcppage_migratetype(page, migratetype);</span><br><span class="line">		<span class="keyword">return</span> page;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>expand()</code> 的逻辑就比较简单，从高阶 order 一直循环到待分配的 order：</p>
<ul>
<li>首先高阶 order–，之后页面拆两半，把后半部分挂到链表上，前半部分留到下次循环继续拆</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 此处再分割的顺序对 IO subsystem 而言是十分重要的.</span></span><br><span class="line"><span class="comment"> * 请不要在有好的理由及回归测试前改变这个顺序。</span></span><br><span class="line"><span class="comment"> * 特别地，当大块的内存被分割，更小块（内存）被传递的顺序</span></span><br><span class="line"><span class="comment"> * 则由他们在该函数中被分割的顺序决定。</span></span><br><span class="line"><span class="comment"> * 根据实际测试，这是影响传递给IO子系统的 pages 顺序的主要因素，</span></span><br><span class="line"><span class="comment"> * 考虑到包含一个内存大块（由一系列小的分配作用）的 buddy system 的行为，</span></span><br><span class="line"><span class="comment"> * 这也是合理的。这种行为是 sglist 合并成功的关键因素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * -- nyc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">expand</span><span class="params">(<span class="keyword">struct</span> zone *zone, <span class="keyword">struct</span> page *page,</span></span><br><span class="line"><span class="params">	<span class="type">int</span> low, <span class="type">int</span> high, <span class="type">int</span> migratetype)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> size = <span class="number">1</span> &lt;&lt; high;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (high &gt; low) &#123;</span><br><span class="line">		high--;</span><br><span class="line">		size &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">		VM_BUG_ON_PAGE(bad_range(zone, &amp;page[size]), &amp;page[size]);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 标记为 guard pages (或 page), 这将允许在 buddy 将被</span></span><br><span class="line"><span class="comment">		 * 释放时合并回分配器.对应的页表项不会被创建，</span></span><br><span class="line"><span class="comment">		 * pages 在 虚拟地址空间上仍将保持不存在。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (set_page_guard(zone, &amp;page[size], high, migratetype))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		add_to_free_list(&amp;page[size], zone, high, migratetype);</span><br><span class="line">		set_buddy_order(&amp;page[size], high);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="③-rmqueue-：分配封装函数"><a href="#③-rmqueue-：分配封装函数" class="headerlink" title="③ __rmqueue()：分配封装函数"></a>③ __rmqueue()：分配封装函数</h5><p>这个函数其实主要是对其他分配函数的封装，最终的核心函数其实都还是 <code>__rmqueue_smallest()</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 从 buddy allocator 上移除一个元素.</span></span><br><span class="line"><span class="comment"> * 在持有 zone-&gt;lock 时调用.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *</span></span><br><span class="line"><span class="class">__<span class="title">rmqueue</span>(<span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>, <span class="title">int</span> <span class="title">migratetype</span>,</span></span><br><span class="line"><span class="class">						<span class="title">unsigned</span> <span class="title">int</span> <span class="title">alloc_flags</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_CMA)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 通过当半数空闲内存在 CMA 区域时从 CMA 中分配</span></span><br><span class="line"><span class="comment">		 * 以平衡常规的与CMA区域的可迁移的分配。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (alloc_flags &amp; ALLOC_CMA &amp;&amp;</span><br><span class="line">		    zone_page_state(zone, NR_FREE_CMA_PAGES) &gt;</span><br><span class="line">		    zone_page_state(zone, NR_FREE_PAGES) / <span class="number">2</span>) &#123;</span><br><span class="line">			page = __rmqueue_cma_fallback(zone, order);</span><br><span class="line">			<span class="keyword">if</span> (page)</span><br><span class="line">				<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">retry:</span><br><span class="line">	page = __rmqueue_smallest(zone, order, migratetype);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!page)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (alloc_flags &amp; ALLOC_CMA)</span><br><span class="line">			page = __rmqueue_cma_fallback(zone, order);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!page &amp;&amp; __rmqueue_fallback(zone, order, migratetype,</span><br><span class="line">								alloc_flags))</span><br><span class="line">			<span class="keyword">goto</span> retry;</span><br><span class="line">	&#125;</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">if</span> (page)</span><br><span class="line">		trace_mm_page_alloc_zone_locked(page, order, migratetype);</span><br><span class="line">	<span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>流程如下：</p>
<ul>
<li>若开启了 CMA，比对常规区域与 CMA 区域的空闲页面数量，若 CMA 的多则调用 <code>__rmqueue_cma_fallback()</code> 从 CMA 区域分配（其实就是调用 <code>__rmqueue_smallest()</code> 从迁移类型为 <code>MIGRATE_CMA</code> 的链表上分配），成功则直接返回</li>
<li>调用 <code>__rmqueue_smallest()</code> 从指定迁移类型链表进行分配，若未成功：<ul>
<li>若设置了 <code>ALLOC_CMA</code> 的分配 flag，调用 <code>__rmqueue_cma_fallback()</code> 从 CMA 区域进行分配</li>
<li>若上一步失败则调用 <code>__rmqueue_fallback()</code> 尝试从其他迁移类型链表获取页面，若还是失败则重试这一个大步骤</li>
</ul>
</li>
</ul>
<h3 id="III-alloc-pages-slowpath-：慢速分配路径"><a href="#III-alloc-pages-slowpath-：慢速分配路径" class="headerlink" title="III. __alloc_pages_slowpath()：慢速分配路径"></a>III. __alloc_pages_slowpath()：慢速分配路径</h3><p>当快速路径的分配不成功时，说明系统当前可能已经没有足够的连续的空闲页面，这时我们就要进入到慢速路径的分配，<strong>进行内存碎片整理与内存回收</strong>，之后再进行分配</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *</span></span><br><span class="line"><span class="class">__<span class="title">alloc_pages_slowpath</span>(<span class="title">gfp_t</span> <span class="title">gfp_mask</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>,</span></span><br><span class="line"><span class="class">						<span class="keyword">struct</span> <span class="title">alloc_context</span> *<span class="title">ac</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">bool</span> can_direct_reclaim = gfp_mask &amp; __GFP_DIRECT_RECLAIM;</span><br><span class="line">	<span class="type">const</span> <span class="type">bool</span> costly_order = order &gt; PAGE_ALLOC_COSTLY_ORDER;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> alloc_flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> did_some_progress;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">compact_priority</span> <span class="title">compact_priority</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">compact_result</span> <span class="title">compact_result</span>;</span></span><br><span class="line">	<span class="type">int</span> compaction_retries;</span><br><span class="line">	<span class="type">int</span> no_progress_loops;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> cpuset_mems_cookie;</span><br><span class="line">	<span class="type">int</span> reserve_flags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 我们还进行了健全性检查，以发现非原子上下文中的 caller 滥用原子储备（的行为）。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON_ONCE((gfp_mask &amp; (__GFP_ATOMIC|__GFP_DIRECT_RECLAIM)) ==</span><br><span class="line">				(__GFP_ATOMIC|__GFP_DIRECT_RECLAIM)))</span><br><span class="line">		gfp_mask &amp;= ~__GFP_ATOMIC;</span><br><span class="line"></span><br><span class="line">retry_cpuset:</span><br><span class="line">	compaction_retries = <span class="number">0</span>;</span><br><span class="line">	no_progress_loops = <span class="number">0</span>;</span><br><span class="line">	compact_priority = DEF_COMPACT_PRIORITY;</span><br><span class="line">	cpuset_mems_cookie = read_mems_allowed_begin();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 仅在 kswapd 需要被唤醒前，快速路径使用保守的 alloc_flags 才能成功，</span></span><br><span class="line"><span class="comment">	 * 并且避免精确地设置 alloc_flags。 所以我们现在这么做。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 重新设置 alloc_flags，因为快速路径的分配在 kswapd 被唤醒之前</span></span><br><span class="line">    <span class="comment">// 只有使用保守的 alloc_flags 才能成功，而现在我们将唤醒 kswapd，</span></span><br><span class="line">    <span class="comment">// 因此恢复使用原有的 gfp_mask 对应的 alloc_flags</span></span><br><span class="line">	alloc_flags = gfp_to_alloc_flags(gfp_mask);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 我们需要为 zonelist 迭代器重新计算起始点，因为我们可能在快速路径中</span></span><br><span class="line"><span class="comment">	 * 使用了不同的 nodemask ，或是有个 cpuset 的修改而我们正在重试</span></span><br><span class="line"><span class="comment">	 * - 否则我们可能会无休止地迭代不合格的 zone</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ac-&gt;preferred_zoneref = first_zones_zonelist(ac-&gt;zonelist,</span><br><span class="line">					ac-&gt;highest_zoneidx, ac-&gt;nodemask);</span><br><span class="line">	<span class="keyword">if</span> (!ac-&gt;preferred_zoneref-&gt;zone)</span><br><span class="line">		<span class="keyword">goto</span> nopage;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 ALLOC_KSWAPD，唤醒 kswapd 线程回收内存</span></span><br><span class="line">	<span class="keyword">if</span> (alloc_flags &amp; ALLOC_KSWAPD)</span><br><span class="line">		wake_all_kswapds(order, gfp_mask, ac);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 调整后的 alloc_flags 可能会立即成功，所以先进行尝试</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	page = get_page_from_freelist(gfp_mask, order, alloc_flags, ac);</span><br><span class="line">	<span class="keyword">if</span> (page)</span><br><span class="line">		<span class="keyword">goto</span> got_pg;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 对于代价高的分配, 首先尝试直接的 compaction（译注：碎片整理机制）,</span></span><br><span class="line"><span class="comment">	 * 因为有可能我们仍有足够的基本页面，并不需要去回收. 对于不可迁移的高阶分配，</span></span><br><span class="line"><span class="comment">	 * 同样这么做, 因为 compaction 将尝试通过从相同迁移类型的块进行迁移</span></span><br><span class="line"><span class="comment">	 * 以避免永久的碎片. 别对允许忽视水位线的分配尝试这个，因为</span></span><br><span class="line"><span class="comment">	 * ALLOC_NO_WATERMARKS 还没发生。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (can_direct_reclaim &amp;&amp;</span><br><span class="line">			(costly_order ||</span><br><span class="line">			   (order &gt; <span class="number">0</span> &amp;&amp; ac-&gt;migratetype != MIGRATE_MOVABLE))</span><br><span class="line">			&amp;&amp; !gfp_pfmemalloc_allowed(gfp_mask)) &#123;</span><br><span class="line">		page = __alloc_pages_direct_compact(gfp_mask, order,</span><br><span class="line">						alloc_flags, ac,</span><br><span class="line">						INIT_COMPACT_PRIORITY,</span><br><span class="line">						&amp;compact_result);</span><br><span class="line">		<span class="keyword">if</span> (page)</span><br><span class="line">			<span class="keyword">goto</span> got_pg;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 检查带有 __GFP_NORETRY 的代价高的分配, 其</span></span><br><span class="line"><span class="comment">		 * 包括一些 THP page fault 的分配</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (costly_order &amp;&amp; (gfp_mask &amp; __GFP_NORETRY)) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * 若分配整个 pageblock(s) 且 compaction 由于所有的 zone</span></span><br><span class="line"><span class="comment">			 * 都在水位线下失败了，或是被禁止了因为其最近在该order上失败了，</span></span><br><span class="line"><span class="comment">			 * 除非分配器有请求的 compaction 与回收尝试，否则直接失败</span></span><br><span class="line"><span class="comment">			 *</span></span><br><span class="line"><span class="comment">			 * 回收是：</span></span><br><span class="line"><span class="comment">			 *  - 可能非常昂贵因为 zones 可能远低于他们的低水位线，</span></span><br><span class="line"><span class="comment">			 *    或是这是非常突发的高阶分配的一部分,</span></span><br><span class="line"><span class="comment">			 *  - 不一定会有帮助因为 isolate_freepages() 可能不会在</span></span><br><span class="line"><span class="comment">			 *    被释放的页面上迭代作为其线性扫描的一部分，且</span></span><br><span class="line"><span class="comment">			 *  - 不大可能会让整个 pageblocks 自己释放</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (compact_result == COMPACT_SKIPPED ||</span><br><span class="line">			    compact_result == COMPACT_DEFERRED)</span><br><span class="line">				<span class="keyword">goto</span> nopage;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * 看起来好像 reclaim/compaction 是值得尝试的, 但</span></span><br><span class="line"><span class="comment">			 * 同步的 compaction 可能会非常 expensive, 故保持</span></span><br><span class="line"><span class="comment">			 * 使用异步的 compaction.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			compact_priority = INIT_COMPACT_PRIORITY;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">	<span class="comment">/* 确保只要我们循环， kswapd 便不会意外地休眠 */</span></span><br><span class="line">	<span class="keyword">if</span> (alloc_flags &amp; ALLOC_KSWAPD)</span><br><span class="line">		wake_all_kswapds(order, gfp_mask, ac);</span><br><span class="line"></span><br><span class="line">	reserve_flags = __gfp_pfmemalloc_flags(gfp_mask);</span><br><span class="line">	<span class="keyword">if</span> (reserve_flags)</span><br><span class="line">		alloc_flags = current_alloc_flags(gfp_mask, reserve_flags);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 若内存策略可以忽略，重置 nodemask 与 zonelist 迭代器。</span></span><br><span class="line"><span class="comment">	 * 这些分配具有高优先级与系统性，而非用户导向。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!(alloc_flags &amp; ALLOC_CPUSET) || reserve_flags) &#123;</span><br><span class="line">		ac-&gt;nodemask = <span class="literal">NULL</span>;</span><br><span class="line">		ac-&gt;preferred_zoneref = first_zones_zonelist(ac-&gt;zonelist,</span><br><span class="line">					ac-&gt;highest_zoneidx, ac-&gt;nodemask);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 带着可能调整过 zonelist 与 alloc_flags 再次尝试 */</span></span><br><span class="line">	page = get_page_from_freelist(gfp_mask, order, alloc_flags, ac);</span><br><span class="line">	<span class="keyword">if</span> (page)</span><br><span class="line">		<span class="keyword">goto</span> got_pg;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 调用方不想要回收, 我们无法平衡任何事 */</span></span><br><span class="line">	<span class="keyword">if</span> (!can_direct_reclaim)</span><br><span class="line">		<span class="keyword">goto</span> nopage;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 避免递归地直接回收 */</span></span><br><span class="line">	<span class="keyword">if</span> (current-&gt;flags &amp; PF_MEMALLOC)</span><br><span class="line">		<span class="keyword">goto</span> nopage;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 尝试直接回收后分配 */</span></span><br><span class="line">	page = __alloc_pages_direct_reclaim(gfp_mask, order, alloc_flags, ac,</span><br><span class="line">							&amp;did_some_progress);</span><br><span class="line">	<span class="keyword">if</span> (page)</span><br><span class="line">		<span class="keyword">goto</span> got_pg;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 尝试直接 compaction 后分配 */</span></span><br><span class="line">	page = __alloc_pages_direct_compact(gfp_mask, order, alloc_flags, ac,</span><br><span class="line">					compact_priority, &amp;compact_result);</span><br><span class="line">	<span class="keyword">if</span> (page)</span><br><span class="line">		<span class="keyword">goto</span> got_pg;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 若是特别指定的请求，不要循环 */</span></span><br><span class="line">	<span class="keyword">if</span> (gfp_mask &amp; __GFP_NORETRY)</span><br><span class="line">		<span class="keyword">goto</span> nopage;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 不要重试高花销的高阶分配除非他们是</span></span><br><span class="line"><span class="comment">	 * __GFP_RETRY_MAYFAIL</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (costly_order &amp;&amp; !(gfp_mask &amp; __GFP_RETRY_MAYFAIL))</span><br><span class="line">		<span class="keyword">goto</span> nopage;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (should_reclaim_retry(gfp_mask, order, ac, alloc_flags,</span><br><span class="line">				 did_some_progress &gt; <span class="number">0</span>, &amp;no_progress_loops))</span><br><span class="line">		<span class="keyword">goto</span> retry;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 若0阶的回收无法取得任何进展，则重试 compaction 没有任何意义，</span></span><br><span class="line"><span class="comment">	 * 因为当前对 compaction 的实现是基于有足够的空闲内存的</span></span><br><span class="line"><span class="comment">	 *  (参见 __compaction_suitable)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (did_some_progress &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">			should_compact_retry(ac, order, alloc_flags,</span><br><span class="line">				compact_result, &amp;compact_priority,</span><br><span class="line">				&amp;compaction_retries))</span><br><span class="line">		<span class="keyword">goto</span> retry;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 在我们开始 OOM killing 之前处理可能的 cpuset 更新竞争 */</span></span><br><span class="line">	<span class="keyword">if</span> (check_retry_cpuset(cpuset_mems_cookie, ac))</span><br><span class="line">		<span class="keyword">goto</span> retry_cpuset;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 回收失败了, 开始 killing 一些东西 */</span></span><br><span class="line">    <span class="comment">// 要杀一些进程或是别的东西来腾内存了</span></span><br><span class="line">	page = __alloc_pages_may_oom(gfp_mask, order, ac, &amp;did_some_progress);</span><br><span class="line">	<span class="keyword">if</span> (page)</span><br><span class="line">		<span class="keyword">goto</span> got_pg;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 在无尽的循环中避免没有水位线的分配 */</span></span><br><span class="line">	<span class="keyword">if</span> (tsk_is_oom_victim(current) &amp;&amp;</span><br><span class="line">	    (alloc_flags &amp; ALLOC_OOM ||</span><br><span class="line">	     (gfp_mask &amp; __GFP_NOMEMALLOC)))</span><br><span class="line">		<span class="keyword">goto</span> nopage;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 若 OOM killer 取得了一些成效，重试 */</span></span><br><span class="line">	<span class="keyword">if</span> (did_some_progress) &#123;</span><br><span class="line">		no_progress_loops = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">goto</span> retry;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">nopage:</span><br><span class="line">	<span class="comment">/* 在我们失败之前处理可能的 cpuset 的更新竞争 */</span></span><br><span class="line">	<span class="keyword">if</span> (check_retry_cpuset(cpuset_mems_cookie, ac))</span><br><span class="line">		<span class="keyword">goto</span> retry_cpuset;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 确保 __GFP_NOFAIL 请求没有泄露且确保我们一直在重试</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (gfp_mask &amp; __GFP_NOFAIL) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 所有存在的 __GFP_NOFAIL 用户都是可以被阻塞的, </span></span><br><span class="line"><span class="comment">		 * 故对任何新的实际上需要 GFP_NOWAIT 的用户进行警告</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (WARN_ON_ONCE(!can_direct_reclaim))</span><br><span class="line">			<span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 这个上下文的 PF_MEMALLOC 请求非常奇怪</span></span><br><span class="line"><span class="comment">		 * 因为我们不能回收任何东西只能循环等待</span></span><br><span class="line"><span class="comment">		 * 某人来为我们做些什么</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		WARN_ON_ONCE(current-&gt;flags &amp; PF_MEMALLOC);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 无失败的高开销的 orders 是一项艰巨的要求，</span></span><br><span class="line"><span class="comment">		 * 我们对此并没有太多准备，故让我们警告这些用户</span></span><br><span class="line"><span class="comment">		 * 以便于我们能够识别出他们并将之转化为别的东西</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		WARN_ON_ONCE(order &gt; PAGE_ALLOC_COSTLY_ORDER);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 通过让他们能访问保留的内存来帮助非失败的分配</span></span><br><span class="line"><span class="comment">		 * 但不使用 ALLOC_NO_WATERMARKS 因为这可能</span></span><br><span class="line"><span class="comment">		 * 大量减少内存保留区而让情况更坏</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		page = __alloc_pages_cpuset_fallback(gfp_mask, order, ALLOC_HARDER, ac);</span><br><span class="line">		<span class="keyword">if</span> (page)</span><br><span class="line">			<span class="keyword">goto</span> got_pg;</span><br><span class="line"></span><br><span class="line">		cond_resched();</span><br><span class="line">		<span class="keyword">goto</span> retry;</span><br><span class="line">	&#125;</span><br><span class="line">fail:</span><br><span class="line">	warn_alloc(gfp_mask, ac-&gt;nodemask,</span><br><span class="line">			<span class="string">&quot;page allocation failure: order:%u&quot;</span>, order);</span><br><span class="line">got_pg:</span><br><span class="line">	<span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们先补充一个概念——<code>Memory compaction</code> 机制，其实就是整理内存碎片，对零散的内存页进行迁移，从而将零散的空闲内存页变成大块的空闲内存，不过这里只整理可以移动的碎片：</p>
<p><img src="https://i.loli.net/2021/11/30/q7T6EjtIb9PVFY3.png" alt="从知乎偷的图.png"></p>
<p>现在我们来看慢速分配的整个流程：</p>
<ul>
<li>使用原有的 gfp_flag 重新设置 alloc_flag，并重新计算 preferred zone，若设置了 <code>ALLOC_KSWAPD</code> 则调用 <code>wake_all_kswapds()</code> 唤醒 kswapd 线程进行内存回收</li>
<li>之后重新尝试快速路径的分配，若成功则直接返回</li>
<li>接下来调用 <code>__alloc_pages_direct_compact()</code> 进行 compaction，该函数内部在整理完后会重新尝试快速路径的分配，若成功则直接返回</li>
<li>（retry）接下来调用 <code>wake_all_kswapds()</code> 唤醒 kswapd 线程进行内存回收</li>
<li>调整 zonelist 与 alloc_flag，之后再次尝试快速路径分配，若成功则直接返回</li>
<li>若 gfp_flag 中没有 <code>__GFP_DIRECT_RECLAIM</code> 或是进程 PCB 的 flag 中有 <code>PF_MEMALLOC</code>，直接跳转到 （nopage）</li>
<li>调用 <code>__alloc_pages_direct_reclaim()</code> 进行内存回收（内部调用 <code>__perform_reclaim()</code>）与快速路径分配，若成功则直接返回</li>
<li>调用 <code>__alloc_pages_direct_compact()</code> 进行 compaction 与快速路径分配，若成功则直接返回</li>
<li>如果设置了 <code>__GFP_NORETRY</code> ，或是该次内存分配开销较高（<code>order &gt; PAGE_ALLOC_COSTLY_ORDER</code>）且未设置 <code>__GFP_RETRY_MAYFAIL</code>，直接跳到 （nopage）</li>
<li>调用 <code>should_reclaim_retry()</code> 判断是否需要重新回收，若是则跳回（retry）</li>
<li>调用 <code>should_compact_retry()</code> 判断是否需要重新进行 compaction，若是则跳回（retry）</li>
<li>调用 <code>check_retry_cpuset()</code> 检查 cpuset 是否发生变化，若是则跳转回开头</li>
<li>调用 <code>__alloc_pages_may_oom()</code> 尝试 kill 一些进程来释放内存，该函数内首先还是会先进行一次快速分配，之后才是调用 <code>out_of_memory()</code> 来杀掉最适合的进程以释放内存，最后若设置了 <code>__GFP_NOFAIL</code> 则调用 <code>__alloc_pages_cpuset_fallback()</code> 再次尝试内存分配，在该函数中会两次走快速路径进行分配（第一次会额外附加上 <code>ALLOC_CPUSET</code> 的 flag）</li>
<li>如果把当前进程杀掉了，跳到（nopage）；如果杀进程取得了成效，跳回（retry）</li>
<li>（nopage）调用 <code>check_retry_cpuset()</code> 检查 cpuset 是否发生变化，若是则跳转回开头</li>
<li>若设置了 <code>__GFP_NOFAIL</code> 则进行一系列的警告，并调用 <code>__alloc_pages_cpuset_fallback()</code> 再次尝试内存分配，若未成功则跳回（retry）</li>
<li>返回结果</li>
</ul>
<p><img src="https://s2.loli.net/2022/07/06/eCg12KJIZuw9aon.png" alt="image.png"></p>
<h2 id="四、上层封装分配函数"><a href="#四、上层封装分配函数" class="headerlink" title="四、上层封装分配函数"></a>四、<em>上层封装分配函数</em></h2><p>在 <code>__alloc_pages_nodemask()</code> 上层主要有三个页面分配函数，其调用路径如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">__alloc_pages_node  /*返回struct page的指针*/</span><br><span class="line">    __alloc_pages</span><br><span class="line">    	__alloc_pages_nodemask</span><br><span class="line"></span><br><span class="line">alloc_pages         /*返回struct page的指针*/</span><br><span class="line">    alloc_pages_current</span><br><span class="line">    	__alloc_pages_nodemask</span><br><span class="line">        </span><br><span class="line">__get_free_pages    /*返回页面的虚拟地址*/</span><br><span class="line">    __get_free_pages</span><br><span class="line">    	alloc_pages</span><br><span class="line">            alloc_pages_current</span><br><span class="line">            	__alloc_pages_nodemask</span><br></pre></td></tr></table></figure>

<h1 id="0x03-页的释放"><a href="#0x03-页的释放" class="headerlink" title="0x03.页的释放"></a>0x03.页的释放</h1><p>前面我们讲了页面是如何分配的，现在我们来看页面是如何释放的</p>
<h2 id="一、-free-one-page-：释放页面的核心函数"><a href="#一、-free-one-page-：释放页面的核心函数" class="headerlink" title="一、__free_one_page()：释放页面的核心函数"></a>一、__free_one_page()：释放页面的核心函数</h2><p>该函数是 buddy system 中用以进行页面释放的<strong>核心函数</strong>，所有的页面释放 API 都是基于该函数的封装</p>
<p>该函数定义于 <code>/mm/page_alloc.c</code> 中，主要作用是将特定页面释放到特定 zone 上，需要注意的是这里的 <code>one page</code> 不是一张页框而是一块连续内存（可能有多张页）</p>
<p>还需要注意的是这是一个释放页面的<strong>基本函数</strong>，故我们需要提供待释放页面的页结构体（struct page）、页框号、页面块的阶（order）、目标 zone、迁移类型等信息——这些信息通常由上层封装函数提供，这个函数所做的只是简单地将页挂回对应链表并检查合并的操作</p>
<p>如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * buddy system 分配器的释放函数.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * buddy system 的想法是为多种“orders”的内存块</span></span><br><span class="line"><span class="comment"> * 维护一个直接映射表（包含位值）. 底部级别的表包含</span></span><br><span class="line"><span class="comment"> * 对最小的可分配内存单元（这里便是页面）的映射,</span></span><br><span class="line"><span class="comment"> * 而往上每更高一级则描述了从其下的一级的一对单元，因此是&quot;buddies&quot;.</span></span><br><span class="line"><span class="comment"> * 从高层看，这里所做的仅是在标记底层可用的表项，</span></span><br><span class="line"><span class="comment"> * 并根据需要向上传播更改，再加上一些与 VM 系统的其他部分</span></span><br><span class="line"><span class="comment"> * 良好协作所需要的计数。</span></span><br><span class="line"><span class="comment"> * 在每个级别, 我们都保持一个 pages 的 list, 作为连续的</span></span><br><span class="line"><span class="comment"> * 长度为(1 &lt;&lt; order)的空闲页的头节点并标记上 PageBuddy.</span></span><br><span class="line"><span class="comment"> * Page&#x27;s order 被记录在 page_private(page) 域.</span></span><br><span class="line"><span class="comment"> * 故当我们在分配或释放其一时, 我们可以得到另一个的状态。</span></span><br><span class="line"><span class="comment"> * 也就是说，若我们分配一个小的块，而两个都是空闲的，</span></span><br><span class="line"><span class="comment"> * 区域的剩余部分必须被分割成块. 若一个块被释放了，</span></span><br><span class="line"><span class="comment"> * 而他的 buddy 也是闲置的, 那么这将触发合并成一个更大的块</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * -- nyc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __free_one_page(<span class="keyword">struct</span> page *page,</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> pfn,</span><br><span class="line">		<span class="keyword">struct</span> zone *zone, <span class="type">unsigned</span> <span class="type">int</span> order,</span><br><span class="line">		<span class="type">int</span> migratetype, <span class="type">fpi_t</span> fpi_flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">capture_control</span> *<span class="title">capc</span> =</span> task_capc(zone);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> buddy_pfn;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> combined_pfn;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> max_order;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">buddy</span>;</span></span><br><span class="line">	<span class="type">bool</span> to_tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里的 MAX_ORDER 和 pageblock_order 都是宏</span></span><br><span class="line">	max_order = <span class="type">min_t</span>(<span class="type">unsigned</span> <span class="type">int</span>, MAX_ORDER - <span class="number">1</span>, pageblock_order);</span><br><span class="line"></span><br><span class="line">	VM_BUG_ON(!zone_is_initialized(zone));</span><br><span class="line">	VM_BUG_ON_PAGE(page-&gt;flags &amp; PAGE_FLAGS_CHECK_AT_PREP, page);</span><br><span class="line"></span><br><span class="line">	VM_BUG_ON(migratetype == <span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">if</span> (likely(!is_migrate_isolate(migratetype)))</span><br><span class="line">		__mod_zone_freepage_state(zone, <span class="number">1</span> &lt;&lt; order, migratetype);</span><br><span class="line"></span><br><span class="line">	VM_BUG_ON_PAGE(pfn &amp; ((<span class="number">1</span> &lt;&lt; order) - <span class="number">1</span>), page);</span><br><span class="line">	VM_BUG_ON_PAGE(bad_range(zone, page), page);</span><br><span class="line"></span><br><span class="line">continue_merging:</span><br><span class="line">	<span class="keyword">while</span> (order &lt; max_order) &#123;</span><br><span class="line">		<span class="keyword">if</span> (compaction_capture(capc, page, order, migratetype)) &#123;</span><br><span class="line">			__mod_zone_freepage_state(zone, -(<span class="number">1</span> &lt;&lt; order),</span><br><span class="line">								migratetype);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		buddy_pfn = __find_buddy_pfn(pfn, order);	<span class="comment">// 计算 buddy 页框号</span></span><br><span class="line">		buddy = page + (buddy_pfn - pfn);		<span class="comment">// 计算 buddy 的页结构体，注意这里是指针加法</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!pfn_valid_within(buddy_pfn)) <span class="comment">// 页框号合法性检查</span></span><br><span class="line">			<span class="keyword">goto</span> done_merging;</span><br><span class="line">		<span class="keyword">if</span> (!page_is_buddy(page, buddy, order))  <span class="comment">// 检查 page 和 buddy 是否是一对</span></span><br><span class="line">			<span class="keyword">goto</span> done_merging;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 我们的 buddy（译注：释放页面的“配对”页面，可以看开头的注释） 是空闲的</span></span><br><span class="line"><span class="comment">		 * 或其为 CONFIG_DEBUG_PAGEALLOC 的 guard page，</span></span><br><span class="line"><span class="comment">		 * 与其合并后升到高一级的order。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (page_is_guard(buddy))</span><br><span class="line">			clear_page_guard(zone, buddy, order, migratetype);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			del_page_from_free_list(buddy, zone, order);</span><br><span class="line">		combined_pfn = buddy_pfn &amp; pfn;</span><br><span class="line">		page = page + (combined_pfn - pfn);</span><br><span class="line">		pfn = combined_pfn;</span><br><span class="line">		order++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (order &lt; MAX_ORDER - <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">/* 若我们到了这，这意味着 order &gt;= pageblock_order.</span></span><br><span class="line"><span class="comment">		 * 我们想要预防在常规 pageblock 与独立的pageblock 之间的合并。</span></span><br><span class="line"><span class="comment">		 * 没有这个，pageblock隔离可能造成错误的空闲页或CMA计数. </span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * 我们不想为了更频繁的低阶合并使用这个代码</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(has_isolate_pageblock(zone))) &#123;</span><br><span class="line">			<span class="type">int</span> buddy_mt;</span><br><span class="line"></span><br><span class="line">			buddy_pfn = __find_buddy_pfn(pfn, order);</span><br><span class="line">			buddy = page + (buddy_pfn - pfn);</span><br><span class="line">			buddy_mt = get_pageblock_migratetype(buddy);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (migratetype != buddy_mt</span><br><span class="line">					&amp;&amp; (is_migrate_isolate(migratetype) ||</span><br><span class="line">						is_migrate_isolate(buddy_mt)))</span><br><span class="line">				<span class="keyword">goto</span> done_merging;</span><br><span class="line">		&#125;</span><br><span class="line">		max_order = order + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">goto</span> continue_merging;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">done_merging:</span><br><span class="line">	set_buddy_order(page, order); <span class="comment">// 在 page-&gt;private 中储存其 order</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是插到链表头还是链表尾</span></span><br><span class="line">	<span class="keyword">if</span> (fpi_flags &amp; FPI_TO_TAIL)</span><br><span class="line">		to_tail = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (is_shuffle_order(order))</span><br><span class="line">		to_tail = shuffle_pick_tail();</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 该函数会检查是否下一个最高阶的 buddy 是否空闲</span></span><br><span class="line">        <span class="comment">// 若是，则可能正在释放的页面块将很快被合并，此时我们应当将其添加到链表的尾部</span></span><br><span class="line">        <span class="comment">// 这样就不大可能又被别的进程很快就分配走了，而是可能被合并为高阶页面</span></span><br><span class="line">		to_tail = buddy_merge_likely(pfn, buddy_pfn, page, order);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入特定迁移链表</span></span><br><span class="line">	<span class="keyword">if</span> (to_tail)</span><br><span class="line">		add_to_free_list_tail(page, zone, order, migratetype);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		add_to_free_list(page, zone, order, migratetype);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Notify page reporting subsystem of freed page */</span></span><br><span class="line">	<span class="keyword">if</span> (!(fpi_flags &amp; FPI_SKIP_REPORT_NOTIFY))</span><br><span class="line">		page_reporting_notify_free(order);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们将与待释放页面凑成一对的内存块称为 buddy，所谓凑成一对便是<strong>这两个内存块在物理上连续，且能凑成一个更高一阶的大内存块</strong>，由此称之为一对 buddies</p>
<p>该函数主要流程如下：</p>
<ul>
<li>（continue_merging，循环开头）调用 <code>__find_buddy_pfn()</code> 计算待释放页面的 buddy 的第一张物理页的页框号，算法比较暴力：<code>page_pfn ^ (1 &lt;&lt; order)</code></li>
<li>调用 <code>page_is_buddy()</code> 检查 buddy 与 待释放页面是否是一对 buddies，若否，则跳到（done_merging），这里的检查需要满足四个要素：<ul>
<li>buddy 不在空洞中</li>
<li>buddy 在 buddy system 中（即 buddy 也是空闲内存块）</li>
<li>待释放页面与其 buddy 在同一个 zone 中</li>
<li>待释放页面与其 buddy 有着同样的阶（order）</li>
</ul>
</li>
<li>若 buddy 为 guard page，则调用 <code>clear_page_guard()</code> 清楚这个属性让其变成空闲页面，这里清除的操作是通过将 page 结构体的 private 字段置 0 实现的；若否，则说明是常规的空闲页面，调用 <code>del_page_from_free_list()</code> 将其脱链</li>
<li>此时我们的新的高阶内存块就完成合成了，接下来我们回到循环开头重新寻找这个合成的新内存块的 buddy，这个循环一直持续到 <code>max_order</code> （一般是10），作为下一次循环的页框号的计算方式是 <code>buddy_pfn &amp; pfn</code>，之后做指针运算 <code>page + (combined_pfn - pfn)</code> 找到对应的 page 结构体</li>
<li>若退出循环时的 order 满足 <code>order &lt; MAX_ORDER - 1</code> ，则调用 <code>has_isolate_pageblock()</code> 检查 zone 中是否有 isolate block，若是则进行相关操作（<del>这块代码还没看懂</del>），最后跳转回（continue_merging）；这一步主要是防止 isolate pageblock 与常规的 pageblock 发生合并</li>
<li>（done_merging）这一步主要是调用 <code>set_buddy_order()</code> 在 page 结构体的 private 字段存放该内存块的 order</li>
<li>若是设置了 <code>FPI_TO_TAIL</code> flag，则将 <code>to_tail</code> 置为 true；否则，若内存块的 <code>order &gt;= SHUFFLE_ORDER</code>（<code>MAX_ORDER - 1</code>），则将 <code>to_tail</code> 置为随机结果（<code>shuffle_pick_tail()</code>）；否则置为调用 <code>buddy_merge_likely()</code> 的结果，该函数会检查是否下一个最高阶的 buddy 是否空闲，若是，则可能正在释放的页面块将很快被合并，此时我们应当将其添加到链表的尾部，这样就不大可能又被别的进程很快就分配走了，而是可能被合并为高阶页面</li>
<li>若 <code>to_tail</code> 为真，则调用 <code>add_to_free_list_tail()</code> 将该空闲页添加到链表末尾，否则调用 <code>add_to_free_list()</code> 添加到链表开头</li>
</ul>
<h2 id="二、上层封装函数"><a href="#二、上层封装函数" class="headerlink" title="二、上层封装函数"></a>二、<em>上层封装函数</em></h2><p>所有页面释放的函数其实都是对 <code>__free_one_page()</code> 的封装，最终都会调用到这个函数，路径如下：</p>
<p><img src="https://s2.loli.net/2022/07/06/ktV7cNlohiQCSWP.png" alt="image.png"></p>

      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
              <a href="/2022/05/28/ALGORITHM-0X04-RED_BLACK_TREE/" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>上一页</span>
              </a>
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">
              <i class="iconfont icon-updatetime" title="更新时间"></i>
              2022-06-30 23:44:49
            </span>
            
                  <span class="post-categories">
                    <i class="iconfont icon-bookmark" title="分类"></i>
                    
                    <span class="span--category">
                      <a href="/categories/OS/" title="OS">
                        <b>#</b> OS
                      </a>
                    </span>
                    
                  </span>
              
                  <span class="post-tags">
                    <i class="iconfont icon-tags" title="标签"></i>
                    
                    <span class="span--tag">
                      <a href="/tags/Linux/" title="Linux">
                        <b>#</b> Linux
                      </a>
                    </span>
                    
                    <span class="span--tag">
                      <a href="/tags/%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0/" title="学习札记">
                        <b>#</b> 学习札记
                      </a>
                    </span>
                    
                    <span class="span--tag">
                      <a href="/tags/Linux-Kernel/" title="Linux Kernel">
                        <b>#</b> Linux Kernel
                      </a>
                    </span>
                    
                    <span class="span--tag">
                      <a href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" title="内存管理">
                        <b>#</b> 内存管理
                      </a>
                    </span>
                    
                    <span class="span--tag">
                      <a href="/tags/buddy-system/" title="buddy system">
                        <b>#</b> buddy system
                      </a>
                    </span>
                    
                  </span>
              
          </div>
          <div class="post-foot-prev">
            
              <a href="/2022/07/07/OS-0X04-LINUX-KERNEL-MEMORY-5.11-PART-III/" target="_self">
                <span>下一页</span>
                <i class="iconfont icon-chevronright"></i>
              </a>
            
          </div>
        </div>
      
    </div>
    
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">目录</div>
    <div class="catalog-content">
      
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0x00-%E4%B8%80%E5%88%87%E5%BC%80%E5%A7%8B%E4%B9%8B%E5%89%8D"><span class="toc-text">0x00.一切开始之前</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x01-buddy-system-%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%84%E7%BB%87%E5%BD%A2%E5%BC%8F"><span class="toc-text">0x01.buddy system 中的内存组织形式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#zone-%E4%B8%AD%E7%9A%84-free-area-%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84"><span class="toc-text">zone 中的 free_area 结构体数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#free-list%EF%BC%9A%E7%A9%BA%E9%97%B2%E9%A1%B5%E9%9D%A2%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-text">free_list：空闲页面双向链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%81%E7%A7%BB%E7%B1%BB%E5%9E%8B%E5%88%86%E9%93%BE%E8%A1%A8"><span class="toc-text">迁移类型分链表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nr-free%EF%BC%9A%E7%A9%BA%E9%97%B2%E9%A1%B5%E9%9D%A2%EF%BC%88%E5%9D%97%EF%BC%89%E8%AE%A1%E6%95%B0"><span class="toc-text">nr_free：空闲页面（块）计数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x02-%E9%A1%B5%E7%9A%84%E5%88%86%E9%85%8D"><span class="toc-text">0x02.页的分配</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81GFP%EF%BC%88get-free-page%EF%BC%89%E6%A0%87%E5%BF%97%E4%BD%8D"><span class="toc-text">一、GFP（get free page）标志位</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81alloc-context-%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%9A%E5%88%86%E9%85%8D%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-text">二、alloc_context 结构体：分配的上下文</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81-alloc-pages-nodemask-%EF%BC%9A%E5%88%86%E9%85%8D%E9%A1%B5%E9%9D%A2%E7%9A%84%E3%80%8C%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E3%80%8D%EF%BC%8C%E8%BF%94%E5%9B%9E-page-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">三、__alloc_pages_nodemask()：分配页面的「核心函数」，返回 page 结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#I-prepare-alloc-pages-%EF%BC%9A%E5%88%86%E9%85%8D%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="toc-text">I. prepare_alloc_pages()：分配前的准备工作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#II-get-page-from-freelist-%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%88%86%E9%85%8D%E8%B7%AF%E5%BE%84%EF%BC%88%E6%A0%B8%E5%BF%83%E5%88%86%E9%85%8D%E5%87%BD%E6%95%B0%EF%BC%89"><span class="toc-text">II. get_page_from_freelist()：快速分配路径（核心分配函数）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#rmqueue-%EF%BC%9A%E4%BB%8E%E7%BB%99%E5%AE%9A%E7%9A%84-page-%E4%B8%AD%E8%BF%9B%E8%A1%8C%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D"><span class="toc-text">rmqueue()：从给定的 page 中进行页面分配</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-rmqueue-pcplist-%EF%BC%9A%E4%BB%8E-per-cpu-pageset-%E4%B8%8A%E5%81%9A-order-0-%E7%9A%84%E5%88%86%E9%85%8D"><span class="toc-text">① rmqueue_pcplist()：从 per-cpu pageset 上做 order-0 的分配</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-rmqueue-smallest-%EF%BC%9A%E9%81%8D%E5%8E%86%E6%8C%87%E5%AE%9A-migrationtype-%E9%93%BE%E8%A1%A8%E7%9A%84-buddy-%E7%AE%97%E6%B3%95%EF%BC%88%E6%A0%B8%E5%BF%83%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83%EF%BC%89"><span class="toc-text">② __rmqueue_smallest()：遍历指定 migrationtype 链表的 buddy 算法（核心中的核心）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A2-rmqueue-%EF%BC%9A%E5%88%86%E9%85%8D%E5%B0%81%E8%A3%85%E5%87%BD%E6%95%B0"><span class="toc-text">③ __rmqueue()：分配封装函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#III-alloc-pages-slowpath-%EF%BC%9A%E6%85%A2%E9%80%9F%E5%88%86%E9%85%8D%E8%B7%AF%E5%BE%84"><span class="toc-text">III. __alloc_pages_slowpath()：慢速分配路径</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E4%B8%8A%E5%B1%82%E5%B0%81%E8%A3%85%E5%88%86%E9%85%8D%E5%87%BD%E6%95%B0"><span class="toc-text">四、上层封装分配函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x03-%E9%A1%B5%E7%9A%84%E9%87%8A%E6%94%BE"><span class="toc-text">0x03.页的释放</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81-free-one-page-%EF%BC%9A%E9%87%8A%E6%94%BE%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0"><span class="toc-text">一、__free_one_page()：释放页面的核心函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%B8%8A%E5%B1%82%E5%B0%81%E8%A3%85%E5%87%BD%E6%95%B0"><span class="toc-text">二、上层封装函数</span></a></li></ol></li></ol>
      
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
      <div class="comments-container">
        




  
    <script async type="text/javascript" src="/plugins/valine.min.js" onload="loadValineSuc(this)"></script>
  

  <div id="vcomments"></div>

  <script>
    function loadValineSuc() {
      new Valine({
        el: '#vcomments',
        appId: 'ICj6cPRQWFTNiOttBHlzxnIv-gzGzoHsz',
        appKey: 'tuvJh3xYxPFcW2JB6K26RKP2',
        placeholder: '说点什么呗...',
        avatar: 'retro',
        lang: 'zh-CN'
      })
    }
  </script>

    <style>
      .comments-container .v .vempty {
        display: none!important;
      }
    </style>




      </div>
    
  </div>


        
<div class="footer">
  <div class="social">
    <ul>
      
        <li>
          <a title="github" target="_blank" rel="noopener" href="https://github.com/arttnba3">
            <i class="iconfont icon-github"></i>
          </a>
        </li>
      
        <li>
          <a title="email" href="mailto:arttnba@gmail.com">
            <i class="iconfont icon-envelope"></i>
          </a>
        </li>
      
        <li>
          <a title="twitter" target="_blank" rel="noopener" href="https://twitter.com/arttnba3">
            <i class="iconfont icon-twitter"></i>
          </a>
        </li>
      
        <li>
          <a title="rss" href="/atom.xml">
            <i class="iconfont icon-rss"></i>
          </a>
        </li>
      
    </ul>
  </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/arttnba3">Copyright © 2022 arttnba3</a>
        
    </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Theme by Oranges | Powered by Hexo</a>
        
    </div>
  
</div>

      </div>

      <div class="tools-bar">
        <div class="back-to-top tools-bar-item hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



        
  <div class="search-icon tools-bar-item" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-title">
        <span class="search-icon-input">
          <a href="javascript: void(0)">
            <i class="iconfont icon-search"></i>
          </a>
        </span>
        
          <input type="text" class="search-input" id="search-input" placeholder="搜索...">
        
        <span class="search-close-icon" id="search-close-icon">
          <a href="javascript: void(0)">
            <i class="iconfont icon-close"></i>
          </a>
        </span>
      </div>
      <div class="search-result" id="search-result"></div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    inputArea.onclick = function() {
      getSearchFile()
      this.onclick = null
    }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        // inputArea.focus()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'>首次搜索，正在载入索引文件，请稍后……<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + orig_data_title + "</a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<p class=\"search-result-abstract\">" + match_content + "...</p>"
                }
                str += "</li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>没有找到内容，请尝试更换检索词。<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>未找到search.xml文件，具体请参考：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>请求失败，尝试重新刷新页面或稍后重试。<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




        
  <div class="tools-bar-item theme-icon" id="switch-color-scheme">
    <a href="javascript: void(0)">
      <i id="theme-icon" class="iconfont icon-moon"></i>
    </a>
  </div>

  
<script src="/js/colorscheme.js"></script>





        
  
    <div class="share-icon tools-bar-item">
      <a href="javascript: void(0)" id="share-icon">
        <i class="iconfont iconshare"></i>
      </a>
      <div class="share-content hidden">
        
          <a class="share-item" href="https://twitter.com/intent/tweet?text=' + %E3%80%90OS.0x03%E3%80%91Linux%20Kernel%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%B5%85%E6%9E%90%20II%20-%20Buddy%20System + '&url=' + http%3A%2F%2Fblog.arttnba3.cn%2F2022%2F06%2F30%2FOS-0X03-LINUX-KERNEL-MEMORY-5.11-PART-II%2F + '" target="_blank" title="Twitter">
            <i class="iconfont icon-twitter"></i>
          </a>
        
        
          <a class="share-item" href="https://www.facebook.com/sharer.php?u=http://blog.arttnba3.cn/2022/06/30/OS-0X03-LINUX-KERNEL-MEMORY-5.11-PART-II/" target="_blank" title="Facebook">
            <i class="iconfont icon-facebooksquare"></i>
          </a>
        
      </div>
    </div>
  
  
<script src="/js/shares.js"></script>



      </div>
    </div>
  </body>
</html>
