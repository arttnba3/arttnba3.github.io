

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/avatar.png">
  <link rel="icon" href="/img/avatar.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="arttnba3">
  <meta name="keywords" content="">
  
    <meta name="description" content="不如 Windows XP 好用">
<meta property="og:type" content="article">
<meta property="og:title" content="【EXPR.0x00】MIT 6.828 课程实验报告">
<meta property="og:url" content="https://arttnba3.github.io/2022/02/21/EXPR-0X00-MIT_6_828/index.html">
<meta property="og:site_name" content="arttnba3&#39;s blog">
<meta property="og:description" content="不如 Windows XP 好用">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2022/02/21/UwuF2BlSxKCRAyH.png">
<meta property="article:published_time" content="2022-02-20T15:57:25.000Z">
<meta property="article:modified_time" content="2023-08-13T08:31:06.000Z">
<meta property="article:author" content="arttnba3">
<meta property="article:tag" content="操作系统">
<meta property="article:tag" content="实验笔记">
<meta property="article:tag" content="MIT">
<meta property="article:tag" content="XV6">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://s2.loli.net/2022/02/21/UwuF2BlSxKCRAyH.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>【EXPR.0x00】MIT 6.828 课程实验报告 - arttnba3&#39;s blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"arttnba3.github.io","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":"§"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.1.1"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 80vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>arttnba3&#39;s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/atom.xml">
                <i class="iconfont icon-rss"></i>
                rss
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://s2.loli.net/2022/02/21/zACSmrLl4E2pvoY.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="【EXPR.0x00】MIT 6.828 课程实验报告"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-02-21 02:57" pubdate>
          2022年2月21日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          129k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          1074 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
        <div class="scroll-down-bar">
          <i class="iconfont icon-arrowdown"></i>
        </div>
      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">【EXPR.0x00】MIT 6.828 课程实验报告</h1>
            
              <p class="note note-info">
                
                  
                    本文最后更新于：2023年8月13日 晚上
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <p>不如 Windows XP 好用</p>
<span id="more"></span>

<h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><blockquote>
<p>为什么要写这篇博客？参见 <a target="_blank" rel="noopener" href="https://arttnba3.cn/2022/03/18/PIECES-0X03-SHELL_OUTSIDE-3-IDEALIST_DEATH/">https://arttnba3.cn/2022/03/18/PIECES-0X03-SHELL_OUTSIDE-3-IDEALIST_DEATH&#x2F;</a></p>
</blockquote>
<p>MIT 6.828 是十分著名的一个综合性的操作系统实验课程，由麻省理工大学（MIT）开设，一共有 6 个 lab，基于 XV6——一个为OS课程教学而开发的 OS kernel，手把手带你一步步补全一个操作系统内核。笔者认为这是十分优秀且富有完成价值的一个 OS 实验，因此笔者决定趁大三寒假实习的空闲时间将本课程补完。</p>
<p>笔者选用其 2018 年的实验课程，因为自从 2019 起他们转向了 RISC-V，而笔者暂时不想离开 X86 的舒适区（笑），因为本次实验的主要目的还是学习操作系统，笔者不想在学习其他架构上花费太多时间</p>
<h2 id="PRE-环境搭建"><a href="#PRE-环境搭建" class="headerlink" title="PRE.环境搭建"></a>PRE.环境搭建</h2><blockquote>
<p>参见 <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2018/tools.html">https://pdos.csail.mit.edu/6.828/2018/tools.html</a></p>
<h1 id="Tools-Used-in-6-828"><a href="#Tools-Used-in-6-828" class="headerlink" title="Tools Used in 6.828"></a>Tools Used in 6.828</h1><p>You’ll use two sets of tools in this class: an x86 emulator, <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2018/tools.html#qemu">QEMU</a>, for running your kernel; and a <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2018/tools.html#chain">compiler toolchain</a>, including assembler, linker, C compiler, and debugger, for compiling and testing your kernel. This page has the information you’ll need to download and install your own copies. This class assumes familiarity with Unix commands throughout.</p>
<p>We highly recommend using a Debathena machine, such as athena.dialup.mit.edu, to work on the labs. If you use the MIT Athena machines that run Linux, then all the software tools you will need for this course are located in the 6.828 locker: just type ‘add -f 6.828’ to get access to them.</p>
<p>If you don’t have access to a Debathena machine, we recommend you use a virtual machine with Linux. If you really want to, you can build and install the tools on your own machine. We have instructions below for Linux and MacOS computers.</p>
<p>It should be possible to get this development environment running under windows with the help of <a target="_blank" rel="noopener" href="http://www.cygwin.com/">Cygwin</a>. Install cygwin, and be sure to install the flex and bison packages (they are under the development header).</p>
<p>For an overview of useful commands in the tools used in 6.828, see the <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2018/labguide.html">lab tools guide</a>.</p>
</blockquote>
<p>为了开始本次实验，我们主要需要这两样东西：</p>
<ul>
<li><p>一个 x86 模拟器：QEMU——用以运行内核</p>
</li>
<li><p>一套编译工具，包括汇编器、链接器、C 编译器、调试器——用以编译与测试内核</p>
</li>
</ul>
<h3 id="Compiler-Toolchain"><a href="#Compiler-Toolchain" class="headerlink" title="Compiler Toolchain"></a>Compiler Toolchain</h3><p>为了完成本次实验，笔者用了一个近乎全新的 Ubuntu 21.10，按课程页面进行如下操作：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get install -y build-essential gdb</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get install gcc-multilib</span><br></code></pre></td></tr></table></figure>

<p>检查，出现类似下面的输出说明安装成功</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">gcc -m32 -print-libgcc-file-name</span><br>/usr/lib/gcc/x86_64-linux-gnu/8/32/libgcc.a<br></code></pre></td></tr></table></figure>

<h3 id="QEMU-Emulator"><a href="#QEMU-Emulator" class="headerlink" title="QEMU Emulator"></a>QEMU Emulator</h3><p>为了更好地进行实验，MIT 6.828 课程的教师们将 qemu 进行了一定的改造，因此我们需要手动编译安装 patch 后的 QEMU</p>
<p>首先补充安装一些库：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt install libsdl1.2-dev libtool-bin libglib2.0-dev libz-dev libpixman-1-dev</span><br></code></pre></td></tr></table></figure>

<p>从 GitHub 拉源码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> https://github.com/mit-pdos/6.828-qemu.git qemu</span><br></code></pre></td></tr></table></figure>

<p>在源码目录下进行需要的配置，<code>[]</code> 里的是可选项（输入命令时不带这个框）</p>
<ul>
<li><p><code>--prefix=PFX</code>：指定安装 qemu 的目录，若未指定则默认为 <code>/usr/local</code></p>
</li>
<li><p><code>--target-list=&quot;i386-softmmu x86_64-softmmu</code>：精简化要安装的架构</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./configure --disable-kvm --disable-werror [--prefix=PFX] [--target-list=<span class="hljs-string">&quot;i386-softmmu x86_64-softmmu&quot;</span>]</span><br></code></pre></td></tr></table></figure>

<p>最后编译就完事了</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo make install</span><br></code></pre></td></tr></table></figure>

<blockquote>
<h3 id="可能出现的错误"><a href="#可能出现的错误" class="headerlink" title="可能出现的错误"></a>可能出现的错误</h3><p>笔者在编译 qemu 时遇到了这样的错误：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">...<br>  CC    stubs/qmp_pc_dimm_device_list.o<br>  AR    libqemustub.a<br>  LINK  qemu-ga<br>/usr/bin/ld: qga/commands-posix.o: in function `dev_major_minor&#x27;:<br>/home/arttnba3/Desktop/MIT_6.828/qqemu/qga/commands-posix.c:633: undefined reference to `major&#x27;<br>/usr/bin/ld: /home/arttnba3/Desktop/MIT_6.828/qqemu/qga/commands-posix.c:634: undefined reference to `minor&#x27;<br>collect2: error: ld returned 1 exit status<br>make: *** [Makefile:288: qemu-ga] Error 1<br></code></pre></td></tr></table></figure>

<p>参照 <a target="_blank" rel="noopener" href="http://patchwork.ozlabs.org/patch/709415/">[v3] build: include sys&#x2F;sysmacros.h for major() and minor() - Patchwork</a> ，在 qemu 源码目录下的 <code>qga/commands-posix.c</code> 加上一个 <code>#include &lt;sys/sysmacros.h&gt;</code></p>
<p>继续 make install，之后还可能出现这样一个错误：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">...<br>  Building optionrom/kvmvapic.img<br>  Building optionrom/kvmvapic.raw<br>  Signing optionrom/kvmvapic.bin<br>install -d -m 0755 <span class="hljs-string">&quot;/usr/local/share/qemu&quot;</span><br>install: cannot change permissions of ‘/usr/local/share/qemu’: No such file or directory<br>make: *** [Makefile:382: install-datadir] Error 1<br></code></pre></td></tr></table></figure>

<p>我们手动创建 <code>/usr/local/share/qemu</code> 这个目录即可</p>
<p>之后继续 make install，又报缺一个目录的错误（不能一次报完嘛 - - ）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">install -d -m 0755 &quot;/usr/local/share/qemu&quot;<br>install -d -m 0755 &quot;/usr/local/etc/qemu&quot;<br>install: cannot change permissions of ‘/usr/local/etc/qemu’: No such file or directory<br>make: *** [Makefile:392: install-confdir] Error 1<br></code></pre></td></tr></table></figure>

<p>依旧手动创建之，然后 make install，这里需要注意我们应当以 root 权限执行</p>
</blockquote>
<h1 id="0x01-Lab-1-Booting-a-PC"><a href="#0x01-Lab-1-Booting-a-PC" class="headerlink" title="0x01.Lab 1: Booting a PC"></a>0x01.Lab 1: Booting a PC</h1><blockquote>
<p>lab 页面： <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2018/labs/lab1/%5D">[https://pdos.csail.mit.edu/6.828/2018/labs/lab1/]</a>(<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2018/labs/lab1/">Lab 1: PC Bootstrap and GCC Calling Conventions</a>)</p>
</blockquote>
<blockquote>
<p>该 lab 大量内容与 <a target="_blank" rel="noopener" href="https://arttnba3.cn/2021/06/24/CODE-0X00-A3OS/">【CODE.0x00】从零开始的32位操作系统开发手记 - arttnba3’s blog</a>重复，<strong>相关知识笔者于本篇博客中仅做简述，不再重复摘抄，如有需要请自行阅读笔者的这篇博客</strong></p>
</blockquote>
<p>该 lab 总共三个部分：</p>
<ul>
<li><p>熟悉 x86 汇编语言、QEMU x86 模拟器、PC的开机引导流程</p>
</li>
<li><p>测试我们用于引导内核的 boot loader（xv6源码下 <code>boot</code> 目录）</p>
</li>
<li><p>深入研究 6.828 内核的初始模板（JOS）</p>
</li>
</ul>
<p>在开始实验之前我们首先把 xv6 源码拉到本地：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> https://pdos.csail.mit.edu/6.828/2018/jos.git lab</span><br></code></pre></td></tr></table></figure>

<p>对于 MIT 的学生来说需要将实验过程 <code>make handin</code> 之后提交到对应的仓库，不过笔者只是大洋彼岸旁听的（笑）所以这一步就跳过了</p>
<h2 id="Part-1-PC-Bootstrap"><a href="#Part-1-PC-Bootstrap" class="headerlink" title="Part 1: PC Bootstrap"></a>Part 1: PC Bootstrap</h2><p>这一部分的主要目的是让学生熟悉<strong>一个计算机是如何启动的</strong>，通电——载入 BIOS——BIOS载入 MBR——跳转到 MBR——（载入 loader）——载入内核</p>
<blockquote>
<p>参见笔者的<a target="_blank" rel="noopener" href="https://arttnba3.cn/2021/06/24/CODE-0X00-A3OS/">这篇博客</a></p>
</blockquote>
<h3 id="Getting-Started-with-x86-assembly"><a href="#Getting-Started-with-x86-assembly" class="headerlink" title="Getting Started with x86 assembly"></a>Getting Started with x86 assembly</h3><p>MIT 为那些不熟悉 x86 汇编语言的人准备了 <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2018/readings/pcasm-book.pdf">PC Assembly Language Book</a>，接下来我们来看 Exercise1：</p>
<blockquote>
<p>Exercise 1. Familiarize yourself with the assembly language materials available on <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2018/reference.html">the 6.828 reference page</a>. You don’t have to read them now, but you’ll almost certainly want to refer to some of this material when reading and writing x86 assembly.</p>
<p>We do recommend reading the section “The Syntax” in <a target="_blank" rel="noopener" href="http://www.delorie.com/djgpp/doc/brennan/brennan_att_inline_djgpp.html">Brennan’s Guide to Inline Assembly</a>. It gives a good (and quite brief) description of the AT&amp;T assembly syntax we’ll be using with the GNU assembler in JOS.</p>
</blockquote>
<p>这一部分主要就是熟悉 x86 汇编语言，笔者在高中的时候就已经会了故这里直接跳过（笑），不过其推荐的材料还是值得一读的。</p>
<p>比较令笔者不适的是实验中涉及到的汇编代码都是丑陋的 AT&amp;T 语法而并非优美的 x86 语法（恼）</p>
<h3 id="Simulating-the-x86"><a href="#Simulating-the-x86" class="headerlink" title="Simulating the x86"></a>Simulating the x86</h3><p>这一步我们开始编译 JOS（xv6）并尝试使用 qemu 运行，在刚刚 clone 下来的源码目录下进行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make</span><br>+ as kern/entry.S<br>+ cc kern/entrypgdir.c<br>+ cc kern/init.c<br>+ cc kern/console.c<br>+ cc kern/monitor.c<br>+ cc kern/printf.c<br>+ cc kern/kdebug.c<br>+ cc lib/printfmt.c<br>+ cc lib/readline.c<br>+ cc lib/string.c<br>+ ld obj/kern/kernel<br>ld: warning: section `.bss&#x27; type changed to PROGBITS<br>+ as boot/boot.S<br>+ cc -Os boot/main.c<br>+ ld boot/boot<br>boot block is 412 bytes (max 510)<br>+ mk obj/kern/kernel.img<br></code></pre></td></tr></table></figure>

<p>其会生成一个磁盘镜像文件</p>
<p>接下来启动 qemu，MIT 在其提供的 Makefile 文件中写好了启动的代码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make qemu</span><br></code></pre></td></tr></table></figure>

<p>启动界面如下，这两个界面都可以进行输入，还是十分方便的：</p>
<p><img src="https://s2.loli.net/2022/02/20/FCqAQm85o3OUzKH.png" srcset="/img/loading.gif" lazyload alt="imagepng"></p>
<p>在最初时 JOS 只提供了两个命令：<code>help</code> 和 <code>kerninfo</code>，<strong>补完剩下的功能让其成为一个完整的内核便是我们在后面几个 lab 中要做的事情</strong> <img src="https://s2.loli.net/2022/02/20/RmXtkdYnL7HGCK5.png" srcset="/img/loading.gif" lazyload alt="imagepng"></p>
<h3 id="The-PC’s-Physical-Address-Space"><a href="#The-PC’s-Physical-Address-Space" class="headerlink" title="The PC’s Physical Address Space"></a>The PC’s Physical Address Space</h3><p>一台 PC 的物理地址通常遵循如下布局（32位下）：</p>
<figure class="highlight mercury"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs mercury">+------------------+  &lt;- <span class="hljs-number">0</span>xFFFFFFFF (<span class="hljs-number">4</span>GB)<br>|      <span class="hljs-number">32</span>-bit      |<br>|  memory mapped   |<br>|     devices      |<br>|                  |<br><span class="hljs-built_in">/\</span><span class="hljs-built_in">/\</span><span class="hljs-built_in">/\</span><span class="hljs-built_in">/\</span><span class="hljs-built_in">/\</span><span class="hljs-built_in">/\</span><span class="hljs-built_in">/\</span><span class="hljs-built_in">/\</span><span class="hljs-built_in">/\</span><span class="hljs-built_in">/\</span><br><br><span class="hljs-built_in">/\</span><span class="hljs-built_in">/\</span><span class="hljs-built_in">/\</span><span class="hljs-built_in">/\</span><span class="hljs-built_in">/\</span><span class="hljs-built_in">/\</span><span class="hljs-built_in">/\</span><span class="hljs-built_in">/\</span><span class="hljs-built_in">/\</span><span class="hljs-built_in">/\</span><br>|                  |<br>|      Unused      |<br>|                  |<br>+------------------+  &lt;- depends on amount of RAM<br>|                  |<br>|                  |<br>| Extended Memory  |<br>|                  |<br>|                  |<br>+------------------+  &lt;- <span class="hljs-number">0</span>x00100000 (<span class="hljs-number">1</span>MB)<br>|     BIOS ROM     |<br>+------------------+  &lt;- <span class="hljs-number">0</span>x000F0000 (<span class="hljs-number">960</span>KB)<br>|  <span class="hljs-number">16</span>-bit devices, |<br>|  expansion ROMs  |<br>+------------------+  &lt;- <span class="hljs-number">0</span>x000C0000 (<span class="hljs-number">768</span>KB)<br>|   VGA Display    |<br>+------------------+  &lt;- <span class="hljs-number">0</span>x000A0000 (<span class="hljs-number">640</span>KB)<br>|                  |<br>|    Low Memory    |<br>|                  |<br>+------------------+  &lt;- <span class="hljs-number">0</span>x00000000<br></code></pre></td></tr></table></figure>

<blockquote>
<p>关于前面这 1MB 的具体内存布局，可以参见 <a target="_blank" rel="noopener" href="https://arttnba3.cn/2021/06/24/CODE-0X00-A3OS/#%E4%B8%80%E3%80%81%E5%AE%9E%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80">【CODE.0x00】从零开始的32位操作系统开发手记 - arttnba3’s blog</a></p>
</blockquote>
<h3 id="The-ROM-BIOS"><a href="#The-ROM-BIOS" class="headerlink" title="The ROM BIOS"></a>The ROM BIOS</h3><p>在这部分实验中我们将使用 gdb 来调试 qemu，MIT 同样在 Makefile 中编写好了相应的命令行，我们只需要在第一个终端界面中执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make qemu-gdb</span><br></code></pre></td></tr></table></figure>

<p>其会启动一个等待 gdb 连接 的qemu</p>
<p><img src="https://s2.loli.net/2022/02/20/rdO63wCxPUovYsN.png" srcset="/img/loading.gif" lazyload alt="imagepng"></p>
<p>接下来在第二个终端中执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make gdb</span><br></code></pre></td></tr></table></figure>

<p>其会启动 gdb 并自动连接上 qemu，这里我们可以看到 <code>CS:IP</code> 为 <code>0xf000:0xfff0</code>，即此时执行的代码地址为 <code>0xffff0</code> ，其实就是 <strong>BIOS 的入口点</strong></p>
<p><img src="https://s2.loli.net/2022/03/15/G8adZYg3pk9lBRr.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<blockquote>
<p>为了原汁原味模拟 MIT 实验的感觉，笔者并未装上 pwn 手常用的 pwndbg 插件（其实只是懒 + 怕出现奇怪的问题）</p>
</blockquote>
<p>MIT 对这个启动过程总结出如下三点：</p>
<ul>
<li><p>IBM PC 启动时执行 0x000ffff0 处代码，这是为 ROM BIOS 保留的内存区域的顶部</p>
</li>
<li><p>PC 启动时 <code>CS = 0xf000</code>，<code>IP = 0xfff0</code></p>
</li>
<li><p>执行的第一条指令为跳转指令，跳转至<code>CS = 0xf000, IP = 0xe05b</code> 处</p>
</li>
</ul>
<p>为什么QEMU 的启动流程是这样的？这首先是 Intel 设计 8088 处理器的模式，之后被 IBM 用在了最初的 PC 上，这是因为在 PC 上， BIOS 被“硬连线”（hard-wired）到物理地址的 <code>0x0000f0000 - 0x000fffff</code> 处（物理地址起始 64KB），这个设计保证了 BIOS 在启动或是系统重启时总能是第一个拿到机器控制权的，因为此时 RAM 中还没有任何其他的软件可以让处理器运行（笔者认为这是一句废话）。QEMU 自己有着一个 BIOS，在处理器复位后，其处在实模式下，且会将 <code>CS:IP</code> 设置为 <code>0xf000:0xfff0</code>，因此 PC 从此处的代码开始执行——将 CS 寄存器左移 4 位再加上 IP 寄存器便获得了当前执行的代码的地址 <code>0xffff0</code>——20位的地址线撑起了 1MB 的内存空间。</p>
<blockquote>
<p>当笔者翻译完 MIT 实验页面的这一段话之后发现这完全没有任何意义——对于二进制人来说这是再基础不过的知识了，因此后面只会酌情引入 MIT 实验文档的翻译，更多的是笔者自己认为有必要写下的笔记，例如上面的这一段话的末尾部分便是笔者自己写的。</p>
</blockquote>
<p>接下来看 Exercise 2，主要是让我们尝试跟进调试一下 BIOS，感受一下他会做些什么：</p>
<blockquote>
<p>Exercise 2. Use GDB’s si (Step Instruction) command to trace into the ROM BIOS for a few more instructions, and try to guess what it might be doing. You might want to look at <a target="_blank" rel="noopener" href="http://web.archive.org/web/20040404164813/members.iweb.net.au/~pstorr/pcbook/book2/book2.htm">http://web.archive.org/web/20040404164813/members.iweb.net.au/~pstorr/pcbook/book2/book2.htm</a>, as well as other materials on the <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2018/reference.html">6.828 reference materials page</a>. No need to figure out all the details - just the general idea of what the BIOS is doing first.</p>
</blockquote>
<p>BIOS 主要完成的工作便是设置中断向量表（Interrupt Vector Table，位于 <code>0x000 ~ 0x3fff</code>），初始化一些设备（例如 VGA display），此时显存被映射到 <code>0xa0000 ~ 0xbffff</code>，显示适配器的 BIOS 被加载到 <code>0xc0000 ~ 0xc7fff</code>，此时<strong>我们直接向显存映射区写入内容便可以在屏幕上显示字符</strong></p>
<p>之后 BIOS 会读出硬盘上的<strong>第一个扇区</strong>到 <code>0x7c00</code> 处，<strong>并跳转到该处</strong>，我们称被载入的第一个扇区为<strong>主引导记录</strong>（Master Boot Record, aka MBR），其从 BIOS 手中接过启动 PC 的接力棒</p>
<blockquote>
<p>MIT 原实验文档中写的是 BIOS 将中断描述符表（Interrupt Descriptor Table）载入到内存当中，但笔者认为在<strong>实模式下应当为中断向量表</strong>，这是因为中断描述符是一个属于保护模式下的概念，这里做出改正</p>
</blockquote>
<h2 id="Part-2-The-Boot-Loader"><a href="#Part-2-The-Boot-Loader" class="headerlink" title="Part 2: The Boot Loader"></a>Part 2: The Boot Loader</h2><p>通常 PC 的硬盘与软盘上的空间被按照 <code>扇区</code> 进行划分，最常见的扇区大小为 <code>512B</code>，单个扇区也是我们读写磁盘最小的操作单位，若磁盘是可引导的，则第一个扇区称为<strong>引导扇区</strong>，因为该扇区中存放着 <em>引导加载程序</em> 的代码，BIOS 在 PC 启动后完成其工作后会将该扇区读到内存中的 <code>0x7c00 ~ 0x7fff</code> 处，之后使用一个 <code>jmp</code> 跳转指令跳转至 <code>CS:IP = 0000:7C00</code>，将控制权交给这一部分代码</p>
<blockquote>
<p>MIT 文档认为，这个地址是相当随意的，<strong>但经笔者考证这是一个有来头的地址</strong>，参见<a target="_blank" rel="noopener" href="https://arttnba3.cn/2021/06/24/CODE-0X00-A3OS/#%E4%B8%80%E3%80%81%E5%AE%9E%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80">【CODE.0x00】从零开始的32位操作系统开发手记 - arttnba3’s blog</a></p>
</blockquote>
<p>由于 CD-ROM 的出现在 PC 发展史中较晚，这给了 PC 架构师足够的时间去重新思考并设计功能更加强大的引导方式，CD-ROM 通常使用 <code>2048B</code> 的扇区大小，且 BIOS 会将更多的扇区作为引导映像载入内存中，这部分内容可以参见<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2018/readings/boot-cdrom.pdf">“El Torito” Bootable CD-ROM Format Specification</a></p>
<p>6.828 的 boot loader 包含两个文件：<code>boot/boot.S</code> 与 <code>boot/main.c</code>，其完成以下两个工作：</p>
<ul>
<li><p>将处理器<strong>从实模式切换到保护模式</strong>（boot.S）</p>
<ul>
<li><p>打开 A20-Gate 以支持大于 1MB 的地址空间</p>
</li>
<li><p>加载全局段描述符表</p>
</li>
<li><p>设置 cr0 寄存器对应标志位，进入保护模式</p>
</li>
</ul>
</li>
<li><p>通过 x86 的特殊 I&#x2F;O 指令从磁盘上读取内核并将之载入内存，跳转到内核（boot.c）</p>
<ul>
<li><p>通过 <code>in</code> 与 <code>out</code> 这两条指令读取磁盘数据</p>
</li>
<li><p>检查并分析 ELF header，跳转到内核</p>
</li>
</ul>
</li>
</ul>
<p>在大二下学习操作系统课程时笔者有幸尝试亲手写过一个内核（虽然远没有完成），其中就包括写 loader，因此这一部分笔者还是相对较为熟悉的，不过 MIT 代码的精炼程度远非笔者从 <em>另一本书上抄抄改改而来的代码</em> 所能比拟的，推荐大家仔细阅读（笑）</p>
<p>下面看 Exercise 3，主要是参照 6.828 的手册学习 GDB，这里就不贴过程了：</p>
<blockquote>
<p>Exercise 3. Take a look at the <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2018/labguide.html">lab tools guide</a>, especially the section on GDB commands. Even if you’re familiar with GDB, this includes some esoteric GDB commands that are useful for OS work.</p>
<p>Set a breakpoint at address 0x7c00, which is where the boot sector will be loaded. Continue execution until that breakpoint. Trace through the code in boot&#x2F;boot.S, using the source code and the disassembly file obj&#x2F;boot&#x2F;boot.asm to keep track of where you are. Also use the x&#x2F;i command in GDB to disassemble sequences of instructions in the boot loader, and compare the original boot loader source code with both the disassembly in obj&#x2F;boot&#x2F;boot.asm and GDB.</p>
<p>Trace into bootmain() in boot&#x2F;main.c, and then into readsect(). Identify the exact assembly instructions that correspond to each of the statements in readsect(). Trace through the rest of readsect() and back out into bootmain(), and identify the begin and end of the for loop that reads the remaining sectors of the kernel from the disk. Find out what code will run when the loop is finished, set a breakpoint there, and continue to that breakpoint. Then step through the remainder of the boot loader.</p>
</blockquote>
<p>6.828 还提供给我们一份反编译后的 loader 文件，位于 <code>obj/boot/boot.asm</code>，为上面两个文件编译后在内存中的样子，并附上了贴心的注释，推荐大家配合着这份文件进行调试，<strong>极致享受</strong>（笑）</p>
<p><img src="https://s2.loli.net/2022/02/20/pGUmRero8DqvH5j.png" srcset="/img/loading.gif" lazyload alt="imagepng"></p>
<p>接下来解决一些 6.828 的习题：</p>
<ul>
<li><p>At what point does the processor start executing 32-bit code? What exactly causes the switch from 16- to 32-bit mode?</p>
<ul>
<li><p>在 <code>boot.main.c</code> 中的 bootmain() 中通过 <code>((void (*)(void)) (ELFHDR-&gt;e_entry))();</code> 跳转到内核入口点</p>
</li>
<li><p>当 MBR 设置了 cr0 寄存器的 <code>PE</code> 标志位后，处理器从实模式进入到保护模式，对应的汇编代码为 <code>ljmp $0x8,$0x7c32</code>，<strong>这是在加载了全局段描述符表后使用代码段描述符完成的一个跳转指令</strong></p>
<p><img src="https://s2.loli.net/2022/02/20/bDBS7YIQpKEAlqJ.png" srcset="/img/loading.gif" lazyload alt="imagepng"></p>
</li>
</ul>
</li>
<li><p>What is the <em>last</em> instruction of the boot loader executed, and what is the <em>first</em> instruction of the kernel it just loaded?</p>
<ul>
<li><p>boot loader 执行的最后一条指令为<code>((void (*)(void)) (ELFHDR-&gt;e_entry))();</code>，对应汇编代码 <code>call *0x10018</code>——这是 kernel 的入口点，而 kernel 执行的第一条指令为 <code>movw $0x1234, 0x472</code></p>
<p><img src="https://s2.loli.net/2022/02/20/DHyfhqPj7NgbsT6.png" srcset="/img/loading.gif" lazyload alt="imagepng"></p>
</li>
</ul>
</li>
<li><p><em>Where</em> is the first instruction of the kernel?</p>
<ul>
<li>kernel 的第一条指令在其 ELF 入口点标注的位置，这里是 <code>0x10018</code></li>
</ul>
</li>
<li><p>How does the boot loader decide how many sectors it must read in order to fetch the entire kernel from disk? Where does it find this information?</p>
<ul>
<li>loader 首先会从磁盘上读取前面一张页的内容（大小0x1000），在判断这是一个合法的 ELF header 之后解析其节表（其中包含每一节（section，也称段（segment））的相关信息，包括该段在文件内的偏移（p_offset）、在内存中的加载地址（p_vaddr）、在文件中的大小（p_filesz）、该段在内存中的大小（p_memsz）、该段的标志位（p_flags，主要标识 rwx 权限）），根据节表信息从磁盘上读取数据</li>
</ul>
</li>
</ul>
<h3 id="Loading-the-Kernel"><a href="#Loading-the-Kernel" class="headerlink" title="Loading the Kernel"></a>Loading the Kernel</h3><p>首先看 Exercise 4，主要是<strong>复习</strong>你的 C 语言知识，尤其是关于指针的那一部分（笑），这一块可以参考大名鼎鼎的 K&amp;R C，以及装载链接ELF文件等基础知识，笔者推荐阅读《程序员的自我修养》</p>
<blockquote>
<p>Exercise 4. Read about programming with pointers in C. The best reference for the C language is <em>The C Programming Language</em> by Brian Kernighan and Dennis Ritchie (known as ‘K&amp;R’). We recommend that students purchase this book (here is an <a target="_blank" rel="noopener" href="http://www.amazon.com/C-Programming-Language-2nd/dp/0131103628/sr=8-1/qid=1157812738/ref=pd_bbs_1/104-1502762-1803102?ie=UTF8&s=books">Amazon Link</a>) or find one of <a target="_blank" rel="noopener" href="http://library.mit.edu/F/AI9Y4SJ2L5ELEE2TAQUAAR44XV5RTTQHE47P9MKP5GQDLR9A8X-10422?func=item-global&doc_library=MIT01&doc_number=000355242&year=&volume=&sub_library=">MIT’s 7 copies</a>.</p>
<p>Read 5.1 (Pointers and Addresses) through 5.5 (Character Pointers and Functions) in K&amp;R. Then download the code for <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2018/labs/lab1/pointers.c">pointers.c</a>, run it, and make sure you understand where all of the printed values come from. In particular, make sure you understand where the pointer addresses in printed lines 1 and 6 come from, how all the values in printed lines 2 through 4 get there, and why the values printed in line 5 are seemingly corrupted.</p>
<p>There are other references on pointers in C (e.g., <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2018/readings/pointers.pdf">A tutorial by Ted Jensen</a> that cites K&amp;R heavily), though not as strongly recommended.</p>
<p><em>Warning:</em> Unless you are already thoroughly versed in C, do not skip or even skim this reading exercise. If you do not really understand pointers in C, you will suffer untold pain and misery in subsequent labs, and then eventually come to understand them the hard way. Trust us; you don’t want to find out what “the hard way” is.</p>
</blockquote>
<p>接下来是 Exercise 5，主要是改 Makefile 文件中指定的链接地址然后重新调试体验一下，这里就跳过了</p>
<blockquote>
<p>Exercise 5. Trace through the first few instructions of the boot loader again and identify the first instruction that would “break” or otherwise do the wrong thing if you were to get the boot loader’s link address wrong. Then change the link address in boot&#x2F;Makefrag to something wrong, run make clean, recompile the lab with make, and trace into the boot loader again to see what happens. Don’t forget to change the link address back and make clean again afterward!</p>
</blockquote>
<p>最后是 Exercise 6，使用 GDB 指令在 BIOS 将控制权交给 MBR 时查看内存 <code>0x00100000</code> 处的数据</p>
<blockquote>
<p>Exercise 6. We can examine memory using GDB’s x command. The <a target="_blank" rel="noopener" href="https://sourceware.org/gdb/current/onlinedocs/gdb/Memory.html">GDB manual</a> has full details, but for now, it is enough to know that the command x&#x2F;<em>N</em>x <em>ADDR</em> prints <em>N</em> words of memory at <em>ADDR</em>. (Note that both ‘x’s in the command are lowercase.) <em>Warning</em>: The size of a word is not a universal standard. In GNU assembly, a word is two bytes (the ‘w’ in xorw, which stands for word, means 2 bytes).</p>
<p>Reset the machine (exit QEMU&#x2F;GDB and start them again). Examine the 8 words of memory at 0x00100000 at the point the BIOS enters the boot loader, and then again at the point the boot loader enters the kernel. Why are they different? What is there at the second breakpoint? (You do not really need to use QEMU to answer this question. Just think.)</p>
</blockquote>
<p>虽然要求只看 8 个 word，但是笔者还是习惯多看一些（笑），这里可以看到在刚刚运行到 MBR 时该处数据都是0</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs gdb">The target architecture is set to &quot;i8086&quot;.<br>[f000:fff0]    0xffff0:    ljmp   $0xf000,$0xe05b<br>0x0000fff0 in ?? ()<br>+ symbol-file obj/kern/kernel<br>(gdb) x /20gx 0x00100000 <br>0x100000:    0x0000000000000000    0x0000000000000000<br>0x100010:    0x0000000000000000    0x0000000000000000<br>0x100020:    0x0000000000000000    0x0000000000000000<br>0x100030:    0x0000000000000000    0x0000000000000000<br>0x100040:    0x0000000000000000    0x0000000000000000<br>0x100050:    0x0000000000000000    0x0000000000000000<br>0x100060:    0x0000000000000000    0x0000000000000000<br>0x100070:    0x0000000000000000    0x0000000000000000<br>0x100080:    0x0000000000000000    0x0000000000000000<br>0x100090:    0x0000000000000000    0x0000000000000000<br>(gdb) b *0x7c00<br>Breakpoint 1 at 0x7c00<br>(gdb) c<br>Continuing.<br>[   0:7c00] =&gt; 0x7c00:    cli    <br><br>Breakpoint 1, 0x00007c00 in ?? ()<br>(gdb) x /20gx 0x00100000 <br>0x100000:    0x0000000000000000    0x0000000000000000<br>0x100010:    0x0000000000000000    0x0000000000000000<br>0x100020:    0x0000000000000000    0x0000000000000000<br>0x100030:    0x0000000000000000    0x0000000000000000<br>0x100040:    0x0000000000000000    0x0000000000000000<br>0x100050:    0x0000000000000000    0x0000000000000000<br>0x100060:    0x0000000000000000    0x0000000000000000<br>0x100070:    0x0000000000000000    0x0000000000000000<br>0x100080:    0x0000000000000000    0x0000000000000000<br>0x100090:    0x0000000000000000    0x0000000000000000<br>(gdb) <br></code></pre></td></tr></table></figure>

<p>接下来在进入内核时再次查看此处数据，发现已经被覆盖上了新的数据，主要是内核的汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs gdb">Breakpoint 1, 0x00007d81 in ?? ()<br>(gdb) x /20gx 0x00100000 <br>0x100000:    0x000000001badb002    0x7205c766e4524ffe<br>0x100010:    0x2000b81234000004    0xc0200fd8220f0011<br>0x100020:    0xc0220f800100010d    0xbde0fff010002fb8<br>0x100030:    0x110000bc00000000    0xfeeb0000006ce8f0<br>0x100040:    0x56e58955fb1e0ff3    0xc3810000017ee853<br>0x100050:    0x8308758b000112ba    0xff0778838d5608ec<br>0x100060:    0x8300000a03e850ff    0xec83297ef68510c4<br>0x100070:    0xffc6e850ff468d0c    0x08ec8310c483ffff<br>0x100080:    0x50ffff0794838d56    0x10c483000009dde8<br>0x100090:    0x83c35d5e5bf8658d    0x006a006a006a04ec<br>(gdb) <br></code></pre></td></tr></table></figure>

<p>这里我们注意到一个数字<code>0x1badb002</code>——<strong>这是 Multiboot Specification 标准要求的一个位于 header 的 magic number</strong>，在启动时会校验这个数，详情可以参见 <a target="_blank" rel="noopener" href="https://www.gnu.org/software/grub/manual/multiboot/multiboot.html">https://www.gnu.org/software/grub/manual/multiboot/multiboot.html</a></p>
<h2 id="Part-3-The-Kernel"><a href="#Part-3-The-Kernel" class="headerlink" title="Part 3: The Kernel"></a>Part 3: The Kernel</h2><p>在本部分中我们将开始学习 JOS 的最小实现的细节，并<strong>开始写一些代码</strong>。如同 boot loader 一般，内核在一开始也先执行一些汇编代码，以让 C 代码能恰当地执行</p>
<h3 id="Using-virtual-memory-to-work-around-position-dependence"><a href="#Using-virtual-memory-to-work-around-position-dependence" class="headerlink" title="Using virtual memory to work around position dependence"></a>Using virtual memory to work around position dependence</h3><p>MBR 的链接地址于加载地址完全匹配，因为其运行在实模式下，<del>他的一切都很真！实模式主打的就是真实！</del>，但内核的加载地址与链接地址却存在<strong>相当大的差别，OS 更倾向于被链接到一个更高的虚拟地址上运行，但其实际则位于物理低地址</strong></p>
<p>接下来我们使用 <code>objdump</code> 查看编译出的内核 ELF 文件来验证这个结论，结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">objdump -h ./obj/kern/kernel</span><br><br>./obj/kern/kernel:     file format elf32-i386<br><br>Sections:<br>Idx Name          Size      VMA       LMA       File off  Algn<br>  0 .text         00001a7f  f0100000  00100000  00001000  2**4<br>                  CONTENTS, ALLOC, LOAD, READONLY, CODE<br>  1 .rodata       000006bc  f0101a80  00101a80  00002a80  2**5<br>                  CONTENTS, ALLOC, LOAD, READONLY, DATA<br>  2 .stab         00004219  f010213c  0010213c  0000313c  2**2<br>                  CONTENTS, ALLOC, LOAD, READONLY, DATA<br>  3 .stabstr      0000198a  f0106355  00106355  00007355  2**0<br>                  CONTENTS, ALLOC, LOAD, READONLY, DATA<br>  4 .data         00009300  f0108000  00108000  00009000  2**12<br>                  CONTENTS, ALLOC, LOAD, DATA<br>  5 .got          00000008  f0111300  00111300  00012300  2**2<br>                  CONTENTS, ALLOC, LOAD, DATA<br>  6 .got.plt      0000000c  f0111308  00111308  00012308  2**2<br>                  CONTENTS, ALLOC, LOAD, DATA<br>  7 .data.rel.local 00001000  f0112000  00112000  00013000  2**12<br>                  CONTENTS, ALLOC, LOAD, DATA<br>  8 .data.rel.ro.local 00000044  f0113000  00113000  00014000  2**2<br>                  CONTENTS, ALLOC, LOAD, DATA<br>  9 .bss          00000648  f0113060  00113060  00014060  2**5<br>                  CONTENTS, ALLOC, LOAD, DATA<br> 10 .comment      00000023  00000000  00000000  000146a8  2**0<br>                  CONTENTS, READONLY<br></code></pre></td></tr></table></figure>

<p>VMA 为虚拟地址，LMA 为加载地址，可见确实如此。这是因为当 OS kernel 被运行在较高的虚拟地址时，其可以很方便地将虚拟地址空间的低地址部分留给用户程序使用，<strong>但通常大部分 32 位机器并没有足够大的内存，他们在 0xf0100000 处往往没有任何物理内存</strong>，因此我们需要实现<strong>虚拟地址到物理地址的映射</strong>，这需要借助页表的帮助。</p>
<p>在设置 cr0 寄存器的 <code>PG</code> 标志位前，我们的内存管理模式是<strong>分段</strong>模式，此时我们对内存的访问使用的是<strong>线性地址</strong>（linear address）——由段选择子与段描述符表来描述分段，完成线性地址到物理地址的映射；在设置了 cr0 寄存器的 <code>PG</code> 标志位之后，我们对内存访问使用的就是<strong>虚拟地址</strong>（virtual）——由页表描述虚拟地址空间到物理地址空间的映射，并由 MMU 完成翻译</p>
<p>32位下最常用的是二级页表，6.828 十分贴心地在 <code>kern/entrypgdir.c</code> 中手写了一个静态初始化的页表结构，设置了虚拟地址 <code>0xf0000000 ~ 0xf0400000</code> 到物理地址 <code>0x00000000 ~ 0x00400000</code> 映射，以及虚拟地址 <code>0x00000000 ~ 0x00400000</code> 到物理地址 <code>0x00000000 ~ 0x00400000</code> 映射。</p>
<p>若我们尝试访问不属于这两个地址范围的地址，则会触发缺页中断，由于我们尚未设置对应的中断处理程序，因此会导致 QEMU crash 并退出</p>
<p>接下来是 Exercise 7，查看分页机制开启前后 <code>0x00100000</code> 与 <code>0xf0100000</code> 这两个地址上的数据</p>
<blockquote>
<p>Exercise 7. Use QEMU and GDB to trace into the JOS kernel and stop at the <code>movl %eax, %cr0</code>. Examine memory at 0x00100000 and at 0xf0100000. Now, single step over that instruction using the stepi GDB command. Again, examine memory at 0x00100000 and at 0xf0100000. Make sure you understand what just happened.</p>
<p>What is the first instruction <em>after</em> the new mapping is established that would fail to work properly if the mapping weren’t in place? Comment out the <code>movl %eax, %cr0</code> in kern&#x2F;entry.S, trace into it, and see if you were right.</p>
</blockquote>
<p>结果如下，在成功建立页表映射之后这两个地址的数据是一致的，因为<strong>完成映射后这两个虚拟地址空间指向同一物理地址空间</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) <br>=&gt; 0x10001d:    mov    %cr0,%eax<br>0x0010001d in ?? ()<br>(gdb) si<br>=&gt; 0x100020:    or     $0x80010001,%eax<br>0x00100020 in ?? ()<br>(gdb) x /8x 0x00100000<br>0x100000:    0x1badb002    0x00000000    0xe4524ffe    0x7205c766<br>0x100010:    0x34000004    0x2000b812    0x220f0011    0xc0200fd8<br>(gdb) x /8x 0xf0100000<br>0xf0100000 &lt;_start-268435468&gt;:    0x00000000    0x00000000    0x00000000    0x00000000<br>0xf0100010 &lt;entry+4&gt;:    0x00000000    0x00000000    0x00000000    0x00000000<br>(gdb) si<br>=&gt; 0x100025:    mov    %eax,%cr0<br>0x00100025 in ?? ()<br>(gdb) <br>=&gt; 0x100028:    mov    $0xf010002f,%eax<br>0x00100028 in ?? ()<br>(gdb) x /8x 0x00100000<br>0x100000:    0x1badb002    0x00000000    0xe4524ffe    0x7205c766<br>0x100010:    0x34000004    0x2000b812    0x220f0011    0xc0200fd8<br>(gdb) x /8x 0xf0100000<br>0xf0100000 &lt;_start-268435468&gt;:    0x1badb002    0x00000000    0xe4524ffe    0x7205c766<br>0xf0100010 &lt;entry+4&gt;:    0x34000004    0x2000b812    0x220f0011    0xc0200fd8<br>(gdb) <br></code></pre></td></tr></table></figure>

<h3 id="Formatted-Printing-to-the-Console"><a href="#Formatted-Printing-to-the-Console" class="headerlink" title="Formatted Printing to the Console"></a>Formatted Printing to the Console</h3><p>这部分要求我们阅读 <code>kern/printf.c, lib/printfmt.c, kern/console.c</code> 以了解 xv6 向控制台输出字符的实现。在正式开始阅读代码之前，我们先自行思考一下：如何在一块 80 * 24 的屏幕上实现各种各样的输出功能？</p>
<p>我们不难想到，所有的输出操作最终都可以通过使用一个“输出原语”实现——「输出单个字符」，我们在实现其他的输出功能，例如 printf 或是 puts 时，只需要在这些函数内部多次调用这个输出原语即可。</p>
<p>这个输出原语应当完成如下功能：</p>
<ul>
<li><p>在屏幕光标处输出字符，并适当移动光标（例如普通字符则将光标向后移动一个字符，而 <code>\b</code> 则将光标向前移动一个字符， <code>\n</code> 则将光标移到下一行）</p>
</li>
<li><p>控制输出字符的颜色</p>
</li>
<li><p>完成基础的换行功能，当屏幕被字符填充满时进行滚屏</p>
</li>
</ul>
<p>前面我们讲到，在 BIOS 时期<strong>有一部分显存被映射到内存当中，其实我们只需要直接往显存上写入数据即可控制屏幕输出</strong>，因此最终涉及到与显卡交互的其实只有光标</p>
<p><code>0xB800~0xBFFF</code> 这块区域是供文本模式使用的显存，当我们在显存内的相应位置写入数据时，屏幕上就会出现对应的字符，在文本模式下显示器支持 <code>80 x 25</code> 16 色文本显示的窗口，一个字符占用两个字节：<strong>第一个字节为 ASCII 码，第二个字节为颜色信息</strong></p>
<p>现在我们来看 xv6 的源码，其使用一个 <code>cons_putc()</code> 函数实现了这个字符输出原语，定义于 <code>kern/console.c</code> 中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// output a character to the console</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">cons_putc</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span><br>&#123;<br>    serial_putc(c);<br>    lpt_putc(c);<br>    cga_putc(c);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们看到其最终调用三个函数：<code>serial_putc()</code>、<code>lpt_putc()</code>、<code>cga_putc()</code>，咋一看有些一头雾水，看函数名后缀似乎这三个函数都是用来输出单个字符的？</p>
<p>先看第一个函数 <code>serial_putc()</code>，其中调用了 <code>inb()</code> 和 <code>outb()</code> 两个函数，这是两个封装好的用以操作端口的函数，展开以后其实就是内联汇编写的 <code>inb</code> 和 <code>outb</code> 指令，单位都是字节</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//...</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> COM_TX        0    <span class="hljs-comment">// Out: Transmit buffer (DLAB=0)</span></span><br><span class="hljs-comment">//...</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> COM_LSR        5    <span class="hljs-comment">// In:    Line Status Register</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>   COM_LSR_DATA    0x01    <span class="hljs-comment">//   Data available</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>   COM_LSR_TXRDY    0x20    <span class="hljs-comment">//   Transmit buffer avail</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>   COM_LSR_TSRE    0x40    <span class="hljs-comment">//   Transmitter off</span></span><br><span class="hljs-comment">//...</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">serial_putc</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>;<br>         !(inb(COM1 + COM_LSR) &amp; COM_LSR_TXRDY) &amp;&amp; i &lt; <span class="hljs-number">12800</span>;<br>         i++)<br>        delay();<br><br>    outb(COM1 + COM_TX, c);<br>&#125;<br><br><span class="hljs-comment">// inc/x86.h</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">uint8_t</span><br><span class="hljs-title function_">inb</span><span class="hljs-params">(<span class="hljs-type">int</span> port)</span><br>&#123;<br>    <span class="hljs-type">uint8_t</span> data;<br>    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;inb %w1,%0&quot;</span> : <span class="hljs-string">&quot;=a&quot;</span> (data) : <span class="hljs-string">&quot;d&quot;</span> (port))</span>;<br>    <span class="hljs-keyword">return</span> data;<br>&#125;<br><br><span class="hljs-comment">// inc/x86.h</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">outb</span><span class="hljs-params">(<span class="hljs-type">int</span> port, <span class="hljs-type">uint8_t</span> data)</span><br>&#123;<br>    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;outb %0,%w1&quot;</span> : : <span class="hljs-string">&quot;a&quot;</span> (data), <span class="hljs-string">&quot;d&quot;</span> (port))</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>那么我们可以知道其主要功能就是从 <code>Line Status Register</code> 中读取数据，若不为 <code>COM_LSR_TXRDY</code> 则重试（最多 12800次），否则说明 <code>Transmit buffer</code> 已就绪，之后便向 <code>Transmit buffer</code> 中写入我们要输出的字符</p>
<p>这里调用了一个 delay 函数，主要是由于历史遗留问题从而需要显式地从 0x84 端口中读取 4 次 1 字节</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Stupid I/O delay routine necessitated by historical PC design flaws</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">delay</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    inb(<span class="hljs-number">0x84</span>);<br>    inb(<span class="hljs-number">0x84</span>);<br>    inb(<span class="hljs-number">0x84</span>);<br>    inb(<span class="hljs-number">0x84</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>serial_putc()</code> 的功能已经明了：检查对应端口状态，写入字符，接下来我们来看 <code>lpt_putc()</code>，还是从一个奇怪的端口读取数据并检查，之后向另外两个端口写入奇怪的数据，因为笔者不是硬件相关开发者所以这里就不深究了（笑）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/***** Parallel port output code *****/</span><br><span class="hljs-comment">// For information on PC parallel port programming, see the class References</span><br><span class="hljs-comment">// page.</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">lpt_putc</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; !(inb(<span class="hljs-number">0x378</span>+<span class="hljs-number">1</span>) &amp; <span class="hljs-number">0x80</span>) &amp;&amp; i &lt; <span class="hljs-number">12800</span>; i++)<br>        delay();<br>    outb(<span class="hljs-number">0x378</span>+<span class="hljs-number">0</span>, c);<br>    outb(<span class="hljs-number">0x378</span>+<span class="hljs-number">2</span>, <span class="hljs-number">0x08</span>|<span class="hljs-number">0x04</span>|<span class="hljs-number">0x01</span>);<br>    outb(<span class="hljs-number">0x378</span>+<span class="hljs-number">2</span>, <span class="hljs-number">0x08</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最后是 <code>cga_putc()</code>，这是实现字符规范化字符打印的<strong>核心函数</strong>：</p>
<ul>
<li><p>首先检查若未设置颜色参数则默认设置黑底白字</p>
</li>
<li><p>之后是对特殊字符的处理，对于普通字符则是直接写显存</p>
</li>
<li><p>在完成之后检查光标是否越界，若是则进行<strong>滚屏</strong>，这里实现的方法比较简单粗暴，直接移动整块内存后清空最后一行，将光标位置向前移动80字符（一行的宽度）</p>
</li>
<li><p>最后向显卡对应寄存器写入光标位置</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">cga_putc</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span><br>&#123;<br>    <span class="hljs-comment">// if no attribute given, then use black on white</span><br>    <span class="hljs-keyword">if</span> (!(c &amp; ~<span class="hljs-number">0xFF</span>))<br>        c |= <span class="hljs-number">0x0700</span>;<br><br>    <span class="hljs-keyword">switch</span> (c &amp; <span class="hljs-number">0xff</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;\b&#x27;</span>:<br>        <span class="hljs-keyword">if</span> (crt_pos &gt; <span class="hljs-number">0</span>) &#123;<br>            crt_pos--;<br>            crt_buf[crt_pos] = (c &amp; ~<span class="hljs-number">0xff</span>) | <span class="hljs-string">&#x27; &#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;\n&#x27;</span>:<br>        crt_pos += CRT_COLS;<br>        <span class="hljs-comment">/* fallthru */</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;\r&#x27;</span>:<br>        crt_pos -= (crt_pos % CRT_COLS);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;\t&#x27;</span>:<br>        cons_putc(<span class="hljs-string">&#x27; &#x27;</span>);<br>        cons_putc(<span class="hljs-string">&#x27; &#x27;</span>);<br>        cons_putc(<span class="hljs-string">&#x27; &#x27;</span>);<br>        cons_putc(<span class="hljs-string">&#x27; &#x27;</span>);<br>        cons_putc(<span class="hljs-string">&#x27; &#x27;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        crt_buf[crt_pos++] = c;        <span class="hljs-comment">/* write the character */</span><br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// What is the purpose of this?</span><br>    <span class="hljs-keyword">if</span> (crt_pos &gt;= CRT_SIZE) &#123;<br>        <span class="hljs-type">int</span> i;<br><br>        memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">uint16_t</span>));<br>        <span class="hljs-keyword">for</span> (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)<br>            crt_buf[i] = <span class="hljs-number">0x0700</span> | <span class="hljs-string">&#x27; &#x27;</span>;<br>        crt_pos -= CRT_COLS;<br>    &#125;<br><br>    <span class="hljs-comment">/* move that little blinky thing */</span><br>    outb(addr_6845, <span class="hljs-number">14</span>);<br>    outb(addr_6845 + <span class="hljs-number">1</span>, crt_pos &gt;&gt; <span class="hljs-number">8</span>);<br>    outb(addr_6845, <span class="hljs-number">15</span>);<br>    outb(addr_6845 + <span class="hljs-number">1</span>, crt_pos);<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>这个实现方法和笔者当时写实验性质 OS kernel 的时候倒是一样，不过令笔者不爽的是 xv6 将 <code>\t</code> 实现为别扭的 5 个空格（恼）</p>
</blockquote>
<p>这么一轮分析下来这个字符输出原语已经基本上分析得差不多了，剩下的一些高级的封装函数笔者就不深入分析贴在这里了，主要就是借助这个字符输出原语实现的一些 tricks，其中对于格式化字符串输出 xv6 实现为 <code>printfmt()</code> 函数，其核心为 <code>vprintfmt()</code> 函数，主要是用一个有穷自动状态机解析格式化字符串并从栈上读取参数输出。</p>
<p>接下来是 Exercise 8，补充格式化字符串打印中的 <code>%o</code> 参数的实现</p>
<blockquote>
<p>Exercise 8. We have omitted a small fragment of code - the code necessary to print octal numbers using patterns of the form “%o”. Find and fill in this code fragment.</p>
</blockquote>
<p>xv6 非常贴心地将数字输出实现为一个无前缀的多进制输出函数 <code>printnum()</code> ，参考 glibc 中 printf 的 8 进制输出是没有前缀的，我们只需要从栈上获取对应数值、设置 base后直接跳转调用即可</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// (unsigned) octal</span><br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;o&#x27;</span>:<br>    <span class="hljs-comment">// Replace this with your code.</span><br>    num = getuint(&amp;ap, lflag);<br>    base = <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">goto</span> number;<br><br><span class="hljs-comment">//...</span><br><br>number:<br>    printnum(putch, putdat, num, base, width, padc);<br>    <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure>

<p>内核入口点是 <code>kern/entry.S</code>，之后会调用到 <code>kern/init.c</code> 中的 <code>i386_init()</code>，其中有一句调用了 %o 的输出语句</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">cprintf(<span class="hljs-string">&quot;6828 decimal is %o octal!\n&quot;</span>, <span class="hljs-number">6828</span>);<br></code></pre></td></tr></table></figure>

<p>我们 make clean 之后重新 make 再 make qemu，查看效果，成功实现 %o 的输出功能：</p>
<p><img src="https://s2.loli.net/2022/03/15/T8WRyaDCi1blp9M.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>最后是 6.828 的一些练习题：</p>
<ol>
<li><p>Explain the interface between printf.c and console.c. Specifically, what function does console.c export? How is this function used by printf.c?</p>
<p><code>console.c</code> 提供了单个字符输出的函数 <code>cputchar()</code>，在 <code>printf.c</code> 中封装为 <code>putch()</code> 函数进行单个字符的输出</p>
</li>
<li><p>Explain the following from console.c:</p>
<p>1 if (crt_pos &gt;&#x3D; CRT_SIZE) {<br>2 int i;<br>3 memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));<br>4 for (i &#x3D; CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)<br>5 crt_buf[i] &#x3D; 0x0700 | ‘ ‘;<br>6 crt_pos -&#x3D; CRT_COLS;<br>7 }</p>
<p>这段代码的作用是<strong>在光标超出 80 x 24 显示区域时进行滚屏</strong>，主要原理就是将第一行往后的数据都向前移动一行，光标向前清空一行的显存为空格后向前移动一行（行宽 80 字符）</p>
</li>
<li><p>For the following questions you might wish to consult the notes for Lecture 2. These notes cover GCC’s calling convention on the x86.</p>
<p>Trace the execution of the following code step-by-step:</p>
<p>int x &#x3D; 1, y &#x3D; 3, z &#x3D; 4;<br>cprintf(“x %d, y %x, z %d\n”, x, y, z);</p>
<ul>
<li><p>In the call to <code>cprintf()</code>, to what does <code>fmt</code> point? To what does <code>ap</code> point?</p>
<p><del>二进制选手的送分题，</del>指向格式化字符串的指针与 x、y、z 三个参数都在栈上，<code>fmt</code> 指针指向存放格式化字符串的位置，这里应该是位于 .data 段上，<code>ap</code> 则指向栈上的参数 x</p>
</li>
<li><p>List (in order of execution) each call to <code>cons_putc</code>, <code>va_arg</code>, and <code>vcprintf</code>. For <code>cons_putc</code>, list its argument as well. For <code>va_arg</code>, list what <code>ap</code> points to before and after the call. For <code>vcprintf</code> list the values of its two arguments.</p>
<p><del>题目太长不看。</del> <code>cons_putc</code> 的参数为要输出的字符的数据，定义为一个 int 类型，实际上只用到了低 2 字节，第一个字节为 ASCII 码，第二个字节为显示的字符颜色与背景色；对于 <code>va_arg</code> 而言，<code>ap</code>指向栈上的某个位置，这个位置上应当存放着我们的可变长参数组中的某个参数，在调用后其会指向下一个参数；<code>vcprintf</code> 的两个参数一个是格式化字符串，另一个则是 <code>va_arg</code> 容器</p>
</li>
</ul>
</li>
<li><p>Run the following code.</p>
<p>unsigned int i &#x3D; 0x00646c72;<br>cprintf(“H%x Wo%s”, 57616, &amp;i);</p>
<p>What is the output? Explain how this output is arrived at in the step-by-step manner of the previous exercise. <a target="_blank" rel="noopener" href="http://web.cs.mun.ca/~michael/c/ascii-table.html">Here’s an ASCII table</a> that maps bytes to characters.</p>
<p>The output depends on that fact that the x86 is little-endian. If the x86 were instead big-endian what would you set <code>i</code> to in order to yield the same output? Would you need to change <code>57616</code> to a different value?</p>
<p><a target="_blank" rel="noopener" href="http://www.webopedia.com/TERM/b/big_endian.html">Here’s a description of little- and big-endian</a> and <a target="_blank" rel="noopener" href="http://www.networksorcery.com/enp/ien/ien137.txt">a more whimsical description</a>.</p>
<p>将代码添加到 <code>init.c</code> 中，实测输出如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">He110 World<br></code></pre></td></tr></table></figure>

<p>57616 作为 16 进制输出为 e110，而 变量 i 的值被作为一个字符串解析（我们输入的参数为指向 i 的指针），因此输出 “rld”；如果是大端序的话前者不会有变化而后者因为直接碰到 “\0” 于是什么也不输出</p>
</li>
<li><p>In the following code, what is going to be printed after <code>&#39;y=&#39;</code>? (note: the answer is not a specific value.) Why does this happen?</p>
<p>cprintf(“x&#x3D;%d y&#x3D;%d”, 3);</p>
<p>y会是一个相对随机的值，有一定概率会是一个指向栈上的指针（old rbp），关键得看编译器生成的代码；这是因为我们在调用 cprintf 时在格式字符串中写有两个参数，但我们只传了一个参数，cprintf 会从栈上存放 3 的位置再往后读一个参数打印出来</p>
</li>
<li><p>Let’s say that GCC changed its calling convention so that it pushed arguments on the stack in declaration order, so that the last argument is pushed last. How would you have to change <code>cprintf</code> or its interface so that it would still be possible to pass it a variable number of arguments?</p>
<p>使用最后一个参数来指定参数的数量即可。</p>
</li>
</ol>
<p>最后还有个打印不同颜色的 Challenge，懒得做了</p>
<h3 id="The-Stack"><a href="#The-Stack" class="headerlink" title="The Stack"></a>The Stack</h3><p>这一节主要讲 x86 下 C 的函数运行时栈与调用约定，并编写一个能够打印堆栈 backtrace 的函数（类似于 Linux 内核 crash 以后打印错误的那种函数）</p>
<p>首先是 Exercise 9，找到内核栈初始化的代码、内核栈在内存中的位置，以及内核保留栈空间的方法与堆栈指针被初始化指向该空间的位置</p>
<blockquote>
<p>Exercise 9. Determine where the kernel initializes its stack, and exactly where in memory its stack is located. How does the kernel reserve space for its stack? And at which “end” of this reserved area is the stack pointer initialized to point to?</p>
</blockquote>
<p>在内核入口函数中在调用 <code>i386_init()</code> 之前有一段代码初始化了内核栈</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs assembly"># Clear the frame pointer register (EBP)<br># so that once we get into debugging C code,<br># stack backtraces will be terminated properly.<br>movl    $0x0,%ebp            # nuke frame pointer<br><br># Set the stack pointer<br>movl    $(bootstacktop),%esp<br><br># now to C code<br>call    i386_init<br></code></pre></td></tr></table></figure>

<p>我们上手调试一下，结果如下，我们看到堆栈指针寄存器（esp）指向 <code>0xf0110000</code>，而栈帧指针寄存器（ebp）指向 0 地址，关于这两个寄存器之间的关系笔者不再赘叙，请各位读者自行复习 C 函数调用栈相关知识，可以看到这里我们的内核栈被初始化到内存高地址中一个固定的位置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs gdb">relocated () at kern/entry.S:74<br>74        movl    $0x0,%ebp            # nuke frame pointer<br>(gdb) si<br>=&gt; 0xf0100034 &lt;relocated+5&gt;:    mov    $0xf0110000,%esp<br>relocated () at kern/entry.S:77<br>77        movl    $(bootstacktop),%esp<br>(gdb) si<br>=&gt; 0xf0100039 &lt;relocated+10&gt;:    call   0xf01000aa &lt;i386_init&gt;<br>80        call    i386_init<br>(gdb) info registers<br>eax            0xf010002f          -267386833<br>ecx            0x0                 0<br>edx            0xffffff40          -192<br>ebx            0x10094             65684<br>esp            0xf0110000          0xf0110000 &lt;entry_pgtable&gt;<br>ebp            0x0                 0x0<br>esi            0x10094             65684<br>edi            0x0                 0<br>eip            0xf0100039          0xf0100039 &lt;relocated+10&gt;<br>eflags         0x86                [ PF SF ]<br>cs             0x8                 8<br>ss             0x10                16<br>ds             0x10                16<br>es             0x10                16<br>fs             0x10                16<br>gs             0x10                16<br>(gdb) <br></code></pre></td></tr></table></figure>

<p>6.828 文档中向我们揭示了栈回溯的原理：按照 C 函数调用栈的相关约定，ebp指针指向栈底，这个位置上存放了上一层调用的 ebp，再往后一个位置存放的是该函数的返回地址，即上层调用函数中调用了这个函数的指令的下一条指令的地址，因此利用 ebp 我们便可以回溯多层函数调用栈</p>
<p>下面看 Exercise 10，主要是让我们通过调试感知 C 函数调用栈</p>
<blockquote>
<p>Exercise 10. To become familiar with the C calling conventions on the x86, find the address of the <code>test_backtrace</code> function in obj&#x2F;kern&#x2F;kernel.asm, set a breakpoint there, and examine what happens each time it gets called after the kernel starts. How many 32-bit words does each recursive nesting level of <code>test_backtrace</code> push on the stack, and what are those words?</p>
<p>Note that, for this exercise to work properly, you should be using the patched version of QEMU available on the <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2018/tools.html">tools</a> page or on Athena. Otherwise, you’ll have to manually translate all breakpoint and memory addresses to linear addresses.</p>
</blockquote>
<p>然后是 Exercise 11，让我们补全实现 <code>mon_backtrace()</code></p>
<blockquote>
<p>Exercise 11. Implement the backtrace function as specified above. Use the same format as in the example, since otherwise the grading script will be confused. When you think you have it working right, run make grade to see if its output conforms to what our grading script expects, and fix it if it doesn’t. <em>After</em> you have handed in your Lab 1 code, you are welcome to change the output format of the backtrace function any way you like.</p>
<p>If you use <code>read_ebp()</code>, note that GCC may generate “optimized” code that calls <code>read_ebp()</code> <em>before</em> <code>mon_backtrace()</code>‘s function prologue, which results in an incomplete stack trace (the stack frame of the most recent function call is missing). While we have tried to disable optimizations that cause this reordering, you may want to examine the assembly of <code>mon_backtrace()</code> and make sure the call to <code>read_ebp()</code> is happening after the function prologue.</p>
</blockquote>
<p>我们需要实现打印如下格式的栈回溯</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dns">Stack backtrace:<br>  ebp f0109e58  eip f0100a62  args <span class="hljs-number">00000001</span> f0109e80 f0109e98 f0100ed<span class="hljs-number">2 00000031</span><br>  ebp f0109ed8  eip f<span class="hljs-number">01000d6</span>  args <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> f<span class="hljs-number">0100058</span> f0109f<span class="hljs-number">28 00000061</span><br>  ...<br></code></pre></td></tr></table></figure>

<p>在内核初始化时将 ebp 设为了0，这提供给我们一个很好的作为判断栈回溯终止的条件，最终的栈回溯函数代码如下，由于 6.828 说他们提供的 <code>read_ebp()</code> 函数可能会被编译器优化掉所以笔者自己写了内联汇编：</p>
<blockquote>
<p>AT &amp; T 语法，非常🥚疼</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">mon_backtrace</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-keyword">struct</span> Trapframe *tf)</span><br>&#123;<br>    <span class="hljs-comment">// Your code here.</span><br>    <span class="hljs-type">uint32_t</span> *old_ebp, last_eip;<br><br>    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;movl %%ebp, %0;&quot;</span> : <span class="hljs-string">&quot;=r&quot;</span> (old_ebp))</span>;<br>    cprintf(<span class="hljs-string">&quot;Stack backtrace:\n&quot;</span>);<br>    <span class="hljs-keyword">while</span> (old_ebp)<br>    &#123;<br>        last_eip = old_ebp[<span class="hljs-number">1</span>];<br>        cprintf(<span class="hljs-string">&quot;  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n&quot;</span>, <br>            old_ebp, last_eip, old_ebp[<span class="hljs-number">2</span>], old_ebp[<span class="hljs-number">3</span>], old_ebp[<span class="hljs-number">4</span>], old_ebp[<span class="hljs-number">5</span>], old_ebp[<span class="hljs-number">6</span>]);<br>        old_ebp = (<span class="hljs-type">uint32_t</span> *) old_ebp[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果如下，成功打印栈回溯：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make qemu</span><br>sed &quot;s/localhost:1234/localhost:26000/&quot; &lt; .gdbinit.tmpl &gt; .gdbinit<br>qemu-system-i386 -drive file=obj/kern/kernel.img,index=0,media=disk,format=raw -serial mon:stdio -gdb tcp::26000 -D qemu.log <br>6828 decimal is 15254 octal!<br>entering test_backtrace 5<br>entering test_backtrace 4<br>entering test_backtrace 3<br>entering test_backtrace 2<br>entering test_backtrace 1<br>entering test_backtrace 0<br>Stack backtrace:<br>  ebp f010ff18  eip f01000a5  args 00000000 00000000 00000000 f010004e f0111308<br>  ebp f010ff38  eip f010007a  args 00000000 00000001 f010ff78 f010004e f0111308<br>  ebp f010ff58  eip f010007a  args 00000001 00000002 f010ff98 f010004e f0111308<br>  ebp f010ff78  eip f010007a  args 00000002 00000003 f010ffb8 f010004e f0111308<br>  ebp f010ff98  eip f010007a  args 00000003 00000004 00000000 f010004e f0111308<br>  ebp f010ffb8  eip f010007a  args 00000004 00000005 00000000 f010004e f0111308<br>  ebp f010ffd8  eip f01000fc  args 00000005 00001aac 00000640 00000000 00000000<br>  ebp f010fff8  eip f010003e  args 00000003 00001003 00002003 00003003 00004003<br>leaving test_backtrace 0<br>leaving test_backtrace 1<br>//...<br></code></pre></td></tr></table></figure>

<p>最后是 lab 1 的最后一个练习——Exercise 12，要求我们打印栈回溯信息的同时打印函数名、函数位于的源文件及他们在源文件中的行号</p>
<blockquote>
<p>Exercise 12. Modify your stack backtrace function to display, for each eip, the function name, source file name, and line number corresponding to that eip.</p>
<p>In <code>debuginfo_eip</code>, where do _<em>STAB</em>* come from? This question has a long answer; to help you to discover the answer, here are some things you might want to do:</p>
<ul>
<li>look in the file kern&#x2F;kernel.ld for _<em>STAB</em>*</li>
<li>run objdump -h obj&#x2F;kern&#x2F;kernel</li>
<li>run objdump -G obj&#x2F;kern&#x2F;kernel</li>
<li>run gcc -pipe -nostdinc -O2 -fno-builtin -I. -MD -Wall -Wno-format -DJOS_KERNEL -gstabs -c -S kern&#x2F;init.c, and look at init.s.</li>
<li>see if the bootloader loads the symbol table in memory as part of loading the kernel binary</li>
</ul>
<p>Complete the implementation of <code>debuginfo_eip</code> by inserting the call to <code>stab_binsearch</code> to find the line number for an address.</p>
<p>Add a backtrace command to the kernel monitor, and extend your implementation of <code>mon_backtrace</code> to call <code>debuginfo_eip</code> and print a line for each stack frame of the form:</p>
<p>K&gt; backtrace<br>Stack backtrace:<br> ebp f010ff78 eip f01008ae args 00000001 f010ff8c 00000000 f0110580 00000000<br> kern&#x2F;monitor.c:143: monitor+106<br> ebp f010ffd8 eip f0100193 args 00000000 00001aac 00000660 00000000 00000000<br> kern&#x2F;init.c:49: i386_init+59<br> ebp f010fff8 eip f010003d args 00000000 00000000 0000ffff 10cf9a00 0000ffff<br> kern&#x2F;entry.S:70: +0<br>K&gt;</p>
<p>Each line gives the file name and line within that file of the stack frame’s eip, followed by the name of the function and the offset of the eip from the first instruction of the function (e.g., monitor+106 means the return eip is 106 bytes past the beginning of monitor).</p>
<p>Be sure to print the file and function names on a separate line, to avoid confusing the grading script.</p>
<p>Tip: printf format strings provide an easy, albeit obscure, way to print non-null-terminated strings like those in STABS tables. <code>printf(&quot;%.*s&quot;, length, string)</code> prints at most <code>length</code> characters of <code>string</code>. Take a look at the printf man page to find out why this works.</p>
<p>You may find that some functions are missing from the backtrace. For example, you will probably see a call to <code>monitor()</code> but not to <code>runcmd()</code>. This is because the compiler in-lines some function calls. Other optimizations may cause you to see unexpected line numbers. If you get rid of the -O2 from GNUMakefile, the backtraces may make more sense (but your kernel will run more slowly).</p>
</blockquote>
<p>我们如果要从头实现这个功能的话可能会有点麻烦，好在 JOS 为我们提供了一个可以实现该功能的库函数 <code>debuginfo_eip()</code>，直接拿来用就行</p>
<p>在拿来用之前我们需要注意其并未实现行号功能，我们还需要手动在 <code>kern/debug.c</code> 中补全实现，这一块原理比较复杂，主要靠其提供的 <code>stab_binsearch()</code> 函数实现，感兴趣的可以了解一下 stab：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Search within [lline, rline] for the line number stab.</span><br><span class="hljs-comment">// If found, set info-&gt;eip_line to the right line number.</span><br><span class="hljs-comment">// If not found, return -1.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Hint:</span><br><span class="hljs-comment">//    There&#x27;s a particular stabs type used for line numbers.</span><br><span class="hljs-comment">//    Look at the STABS documentation and &lt;inc/stab.h&gt; to find</span><br><span class="hljs-comment">//    which one.</span><br><span class="hljs-comment">// Your code here.</span><br>stab_binsearch(stabs, &amp;lfun, &amp;rfun, N_SLINE, addr - info-&gt;eip_fn_addr);<br><br><span class="hljs-keyword">if</span> (lfun &lt;= rfun)<br>&#123;<br>    info-&gt;eip_line = stabs[lfun].n_desc;<br>&#125;<br>  <span class="hljs-keyword">else</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在 backtrace 中需要注意的是其提供的函数名指针并非以 <code>\0</code> 结尾所以我们还需要手动指定输出长度，最终 backtrace 函数的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">mon_backtrace</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-keyword">struct</span> Trapframe *tf)</span><br>&#123;<br>    <span class="hljs-comment">// Your code here.</span><br>    <span class="hljs-type">uint32_t</span> *old_ebp, last_eip;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Eipdebuginfo</span> <span class="hljs-title">eipdebuginfo</span>;</span><br><br>    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;movl %%ebp, %0;&quot;</span> : <span class="hljs-string">&quot;=r&quot;</span> (old_ebp))</span>;<br>    cprintf(<span class="hljs-string">&quot;Stack backtrace:\n&quot;</span>);<br>    <span class="hljs-keyword">while</span> (old_ebp)<br>    &#123;<br>        last_eip = old_ebp[<span class="hljs-number">1</span>];<br>        debuginfo_eip(last_eip, &amp;eipdebuginfo);<br>        cprintf(<span class="hljs-string">&quot;  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n&quot;</span>, <br>            old_ebp, last_eip, old_ebp[<span class="hljs-number">2</span>], old_ebp[<span class="hljs-number">3</span>], old_ebp[<span class="hljs-number">4</span>], old_ebp[<span class="hljs-number">5</span>], old_ebp[<span class="hljs-number">6</span>]);<br>        cprintf(<span class="hljs-string">&quot;         %s:%d: &quot;</span>, <br>            eipdebuginfo.eip_file, eipdebuginfo.eip_line);<br>        cprintf(<span class="hljs-string">&quot;%.*s+%d\n&quot;</span>,<br>            eipdebuginfo.eip_fn_namelen, eipdebuginfo.eip_fn_name, last_eip - eipdebuginfo.eip_fn_addr);<br>        old_ebp = (<span class="hljs-type">uint32_t</span> *) old_ebp[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最终运行效果如下：</p>
<p><img src="https://s2.loli.net/2022/02/21/3JksWlBiI7VNYEG.png" srcset="/img/loading.gif" lazyload alt="imagepng"></p>
<p>运行 <code>make grade</code> 以检查 lab 1 的完成情况，可以看到我们成功完成了 lab 1 的代码部分，至此， lab 1 结束</p>
<p><img src="https://s2.loli.net/2022/02/21/GM57bwBngJP6UdO.png" srcset="/img/loading.gif" lazyload alt="imagepng"></p>
<h1 id="0x02-Lab-2-Memory-Management"><a href="#0x02-Lab-2-Memory-Management" class="headerlink" title="0x02.Lab 2: Memory Management"></a>0x02.Lab 2: Memory Management</h1><p>在这一部分当中我们需要实现 OS kernel 的<strong>内存管理模块</strong>，分为两部分：</p>
<ul>
<li><p>物理内存分配器：我们需要将所有的物理内存以「页」为单位进行管理，并记录下各个页的状态（空闲或已被分配）、共享该页面的进程数量等，并实现分配与释放物理页的函数</p>
</li>
<li><p>虚拟内存分配器：我们需要完成对页表的管理，主要是实现虚拟地址到物理地址的映射的建立功能</p>
</li>
</ul>
<p>首先用 git 拉 lab2 的代码下来，这里笔者前面 lab 1 的代码没有 handin 所以前面提示了一下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git checkout -b lab2 origin/lab2</span><br>M    kern/kdebug.c<br>M    kern/monitor.c<br>M    lib/printfmt.c<br>Branch &#x27;lab2&#x27; set up to track remote branch &#x27;lab2&#x27; from &#x27;origin&#x27;.<br>Switched to a new branch &#x27;lab2&#x27;<br></code></pre></td></tr></table></figure>

<p>lab 2 新增了这些文件：</p>
<ul>
<li>inc&#x2F;memlayout.h</li>
<li>kern&#x2F;pmap.c</li>
<li>kern&#x2F;pmap.h</li>
<li>kern&#x2F;kclock.h</li>
<li>kern&#x2F;kclock.c</li>
</ul>
<p><code>memlayout.h</code> 中描述了虚拟地址空间的布局，我们需要通过修改 <code>pmap.c</code> 来实现；在 <code>memlayout.h</code> 与 <code>pmap.h</code> 中定义了 <code>Pageinfo</code> 结构体，用以描述单个物理页，与 Linux 内核的做法类似，一个 Pageinfo 对应一张物理页，所以在该结构体中只需要存储该页的状态即可；<code>kclock.c</code> 与 <code>kclock.h</code> 用以操作电池后备时钟与 CMOS RAM 硬件，其在 BIOS 中记录了 PC 的物理内存容量与其他东西，在 <code>pmap.c</code> 中的代码需要读取该设备以计算可用物理内存，这部分代码 xv6 已经帮我们实现好了所以我们暂时不需要了解 CMOS 的原理</p>
<blockquote>
<p> 在笔者的 <a target="_blank" rel="noopener" href="https://arttnba3.cn/2021/06/24/CODE-0X00-A3OS/">【CODE.0x00】从零开始的32位操作系统开发手记 - arttnba3’s blog</a> 中记录了三种获取可用物理内存容量与布局的方式，原型来自 Linux 内核</p>
</blockquote>
<p>在 <code>memlayout.h</code> 中对将要建立的内存布局描述如下：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">/<span class="hljs-symbol">*</span><br> <span class="hljs-symbol">*</span> Virtual memory map:                                Permissions<br> <span class="hljs-symbol">*</span>                                                    kernel/user<br> <span class="hljs-symbol">*</span><br> <span class="hljs-symbol">*</span>    4 Gig --------&gt;  +------------------------------+<br> <span class="hljs-symbol">*</span>                     |<span class="hljs-string">                              </span>|<span class="hljs-string"> RW/--</span><br><span class="hljs-string"> *                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="hljs-string"> *                     :              .               :</span><br><span class="hljs-string"> *                     :              .               :</span><br><span class="hljs-string"> *                     :              .               :</span><br><span class="hljs-string"> *                     </span>|<span class="hljs-string">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>|<span class="hljs-string"> RW/--</span><br><span class="hljs-string"> *                     </span>|<span class="hljs-string">                              </span>|<span class="hljs-string"> RW/--</span><br><span class="hljs-string"> *                     </span>|<span class="hljs-string">   Remapped Physical Memory   </span>|<span class="hljs-string"> RW/--</span><br><span class="hljs-string"> *                     </span>|<span class="hljs-string">                              </span>|<span class="hljs-string"> RW/--</span><br><span class="hljs-string"> *    KERNBASE, ----&gt;  +------------------------------+ 0xf0000000      --+</span><br><span class="hljs-string"> *    KSTACKTOP        </span>|<span class="hljs-string">     CPU0&#x27;s Kernel Stack      </span>|<span class="hljs-string"> RW/--  KSTKSIZE   </span>|<br> <span class="hljs-symbol">*</span>                     |<span class="hljs-string"> - - - - - - - - - - - - - - -</span>|<span class="hljs-string">                   </span>|<br> <span class="hljs-symbol">*</span>                     |<span class="hljs-string">      Invalid Memory (*)      </span>|<span class="hljs-string"> --/--  KSTKGAP    </span>|<br> <span class="hljs-symbol">*</span>                     +------------------------------+                   |<span class="hljs-string"></span><br><span class="hljs-string"> *                     </span>|<span class="hljs-string">     CPU1&#x27;s Kernel Stack      </span>|<span class="hljs-string"> RW/--  KSTKSIZE   </span>|<br> <span class="hljs-symbol">*</span>                     |<span class="hljs-string"> - - - - - - - - - - - - - - -</span>|<span class="hljs-string">                 PTSIZE</span><br><span class="hljs-string"> *                     </span>|<span class="hljs-string">      Invalid Memory (*)      </span>|<span class="hljs-string"> --/--  KSTKGAP    </span>|<br> <span class="hljs-symbol">*</span>                     +------------------------------+                   |<span class="hljs-string"></span><br><span class="hljs-string"> *                     :              .               :                   </span>|<br> <span class="hljs-symbol">*</span>                     :              .               :                   |<span class="hljs-string"></span><br><span class="hljs-string"> *    MMIOLIM ------&gt;  +------------------------------+ 0xefc00000      --+</span><br><span class="hljs-string"> *                     </span>|<span class="hljs-string">       Memory-mapped I/O      </span>|<span class="hljs-string"> RW/--  PTSIZE</span><br><span class="hljs-string"> * ULIM, MMIOBASE --&gt;  +------------------------------+ 0xef800000</span><br><span class="hljs-string"> *                     </span>|<span class="hljs-string">  Cur. Page Table (User R-)   </span>|<span class="hljs-string"> R-/R-  PTSIZE</span><br><span class="hljs-string"> *    UVPT      ----&gt;  +------------------------------+ 0xef400000</span><br><span class="hljs-string"> *                     </span>|<span class="hljs-string">          RO PAGES            </span>|<span class="hljs-string"> R-/R-  PTSIZE</span><br><span class="hljs-string"> *    UPAGES    ----&gt;  +------------------------------+ 0xef000000</span><br><span class="hljs-string"> *                     </span>|<span class="hljs-string">           RO ENVS            </span>|<span class="hljs-string"> R-/R-  PTSIZE</span><br><span class="hljs-string"> * UTOP,UENVS ------&gt;  +------------------------------+ 0xeec00000</span><br><span class="hljs-string"> * UXSTACKTOP -/       </span>|<span class="hljs-string">     User Exception Stack     </span>|<span class="hljs-string"> RW/RW  PGSIZE</span><br><span class="hljs-string"> *                     +------------------------------+ 0xeebff000</span><br><span class="hljs-string"> *                     </span>|<span class="hljs-string">       Empty Memory (*)       </span>|<span class="hljs-string"> --/--  PGSIZE</span><br><span class="hljs-string"> *    USTACKTOP  ---&gt;  +------------------------------+ 0xeebfe000</span><br><span class="hljs-string"> *                     </span>|<span class="hljs-string">      Normal User Stack       </span>|<span class="hljs-string"> RW/RW  PGSIZE</span><br><span class="hljs-string"> *                     +------------------------------+ 0xeebfd000</span><br><span class="hljs-string"> *                     </span>|<span class="hljs-string">                              </span>|<br> <span class="hljs-symbol">*</span>                     |<span class="hljs-string">                              </span>|<br> <span class="hljs-symbol">*</span>                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br> <span class="hljs-symbol">*</span>                     .                              .<br> <span class="hljs-symbol">*</span>                     .                              .<br> <span class="hljs-symbol">*</span>                     .                              .<br> <span class="hljs-symbol">*</span>                     |<span class="hljs-string">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>|<br> <span class="hljs-symbol">*</span>                     |<span class="hljs-string">     Program Data &amp; Heap      </span>|<br> <span class="hljs-symbol">*</span>    UTEXT --------&gt;  +------------------------------+ 0x00800000<br> <span class="hljs-symbol">*</span>    PFTEMP -------&gt;  |<span class="hljs-string">       Empty Memory (*)       </span>|<span class="hljs-string">        PTSIZE</span><br><span class="hljs-string"> *                     </span>|<span class="hljs-string">                              </span>|<br> <span class="hljs-symbol">*</span>    UTEMP --------&gt;  +------------------------------+ 0x00400000      --+<br> <span class="hljs-symbol">*</span>                     |<span class="hljs-string">       Empty Memory (*)       </span>|<span class="hljs-string">                   </span>|<br> <span class="hljs-symbol">*</span>                     |<span class="hljs-string"> - - - - - - - - - - - - - - -</span>|<span class="hljs-string">                   </span>|<br> <span class="hljs-symbol">*</span>                     |<span class="hljs-string">  User STAB Data (optional)   </span>|<span class="hljs-string">                 PTSIZE</span><br><span class="hljs-string"> *    USTABDATA ----&gt;  +------------------------------+ 0x00200000        </span>|<br> <span class="hljs-symbol">*</span>                     |<span class="hljs-string">       Empty Memory (*)       </span>|<span class="hljs-string">                   </span>|<br> <span class="hljs-symbol">*</span>    0 ------------&gt;  +------------------------------+                 --+<br> <span class="hljs-symbol">*</span><br> <span class="hljs-symbol">*</span> (<span class="hljs-symbol">*</span>) Note: The kernel ensures that <span class="hljs-string">&quot;Invalid Memory&quot;</span> is <span class="hljs-symbol">*</span>never<span class="hljs-symbol">*</span> mapped.<br> <span class="hljs-symbol">*</span>     <span class="hljs-string">&quot;Empty Memory&quot;</span> is normally unmapped, but user programs may map pages<br> <span class="hljs-symbol">*</span>     there if desired.  JOS user programs map pages temporarily at UTEMP.<br> <span class="hljs-symbol">*</span>/<br></code></pre></td></tr></table></figure>

<h2 id="Part-1-Physical-Page-Management"><a href="#Part-1-Physical-Page-Management" class="headerlink" title="Part 1: Physical Page Management"></a>Part 1: Physical Page Management</h2><p>操作系统应当要管理好内存中的每一张内存页，JOS 同样以页为粒度进行管理，在本部分中我们需要为 JOS 编写一个物理内存页分配器，其使用一个链表来将空闲的物理页对应的 Pageinfo 结构体相连</p>
<p>在 Exercise 1 中要求我们实现该物理内存页分配器的几个函数</p>
<blockquote>
<p>Exercise 1. In the file kern&#x2F;pmap.c, you must implement code for the following functions (probably in the order given).</p>
<p><code>boot_alloc()</code><br><code>mem_init()</code> (only up to the call to <code>check_page_free_list(1)</code>)<br><code>page_init()</code><br><code>page_alloc()</code><br><code>page_free()</code></p>
<p><code>check_page_free_list()</code> and <code>check_page_alloc()</code> test your physical page allocator. You should boot JOS and see whether <code>check_page_alloc()</code> reports success. Fix your code so that it passes. You may find it helpful to add your own <code>assert()</code>s to verify that your assumptions are correct.</p>
</blockquote>
<p>笔者本人很想直接写一个 buddy system（笑），但一是技术力好像不大够的样子，二是在对 JOS 没有足够了解的情况下还是先按照给的注释来实现</p>
<p>我们先来看 <code>kern/pmap.c</code> ，在一开头声明了这几个全局变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// These variables are set by i386_detect_memory()</span><br><span class="hljs-type">size_t</span> npages;			<span class="hljs-comment">// Amount of physical memory (in pages)</span><br><span class="hljs-type">static</span> <span class="hljs-type">size_t</span> npages_basemem;	<span class="hljs-comment">// Amount of base memory (in pages)</span><br><br><span class="hljs-comment">// These variables are set in mem_init()</span><br><span class="hljs-type">pde_t</span> *kern_pgdir;		<span class="hljs-comment">// Kernel&#x27;s initial page directory</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">pages</span>;</span>		<span class="hljs-comment">// Physical page state array</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">page_free_list</span>;</span>	<span class="hljs-comment">// Free list of physical pages</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>npages</code>：以页为单位的物理内存总量</li>
<li><code>npages_basemem</code>：以页为单位的可用内存总量</li>
<li><code>kern_pgdir</code>：内核的页全局目录表</li>
<li><code>pages</code>：页结构体（PageInfo）数组的指针</li>
<li><code>page_free_list</code>：空闲的物理页单向链表头节点</li>
</ul>
<p>那么我们这里可以看出来这个内存管理有点类似于 FLATMEM 内存模型：直接由一个大的 page 结构体数组对应一块可用物理内存区域。再加上 “只有一个单向链表的 buddy system”，大概就如下图所示（笔者拿两张讲 Linux的图拆开拼成的）</p>
<p><img src="https://s2.loli.net/2022/03/15/umCBxeDPFc7I23h.png" srcset="/img/loading.gif" lazyload alt="JOS的内存管理"></p>
<p>这里我们需要注意一点：<strong>PageInfo 结构体并不需要存储地址信息，因为他是一个结构体数组直接对应整个物理内存空间</strong>，相应地就有 pages[0] 对应地址 0，pages[1] 对应地址 0x1000…<strong>我们其实很容易能得到 PageInfo 地址到物理页帧之间的转换公式</strong>，这里我们直接看在 <code>kern/pmap.h</code> 中实现的两个转换函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">physaddr_t</span><br><span class="hljs-title function_">page2pa</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> PageInfo *pp)</span><br>&#123;<br>	<span class="hljs-keyword">return</span> (pp - pages) &lt;&lt; PGSHIFT;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">struct</span> PageInfo*<br><span class="hljs-title function_">pa2page</span><span class="hljs-params">(<span class="hljs-type">physaddr_t</span> pa)</span><br>&#123;<br>	<span class="hljs-keyword">if</span> (PGNUM(pa) &gt;= npages)<br>		panic(<span class="hljs-string">&quot;pa2page called with invalid pa&quot;</span>);<br>	<span class="hljs-keyword">return</span> &amp;pages[PGNUM(pa)];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当然，我们现在所说的都是虚拟地址，我们仍需要一个虚拟地址与物理地址之间直接转换的函数，参照上图，由于是线性映射，故直接减去一个差值即可，在<code>kern/pmap.h</code> 中便实现了虚拟地址到物理地址转换的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* This macro takes a kernel virtual address -- an address that points above</span><br><span class="hljs-comment"> * KERNBASE, where the machine&#x27;s maximum 256MB of physical memory is mapped --</span><br><span class="hljs-comment"> * and returns the corresponding physical address.  It panics if you pass it a</span><br><span class="hljs-comment"> * non-kernel virtual address.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PADDR(kva) _paddr(__FILE__, __LINE__, kva)</span><br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">physaddr_t</span><br>_paddr(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file, <span class="hljs-type">int</span> line, <span class="hljs-type">void</span> *kva)<br>&#123;<br>	<span class="hljs-keyword">if</span> ((<span class="hljs-type">uint32_t</span>)kva &lt; KERNBASE)<br>		_panic(file, line, <span class="hljs-string">&quot;PADDR called with invalid kva %08lx&quot;</span>, kva);<br>	<span class="hljs-keyword">return</span> (<span class="hljs-type">physaddr_t</span>)kva - KERNBASE;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>现在我们可以开始补完 Exercise 1 的几个函数的代码了</p>
<h4 id="boot-alloc-：物理内存线性分配器"><a href="#boot-alloc-：物理内存线性分配器" class="headerlink" title="boot_alloc()：物理内存线性分配器"></a>boot_alloc()：物理内存线性分配器</h4><p>按惯例，先看注释：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// This simple physical memory allocator is used only while JOS is setting</span><br><span class="hljs-comment">// up its virtual memory system.  page_alloc() is the real allocator.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// If n&gt;0, allocates enough pages of contiguous physical memory to hold &#x27;n&#x27;</span><br><span class="hljs-comment">// bytes.  Doesn&#x27;t initialize the memory.  Returns a kernel virtual address.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// If n==0, returns the address of the next free page without allocating</span><br><span class="hljs-comment">// anything.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// If we&#x27;re out of memory, boot_alloc should panic.</span><br><span class="hljs-comment">// This function may ONLY be used during initialization,</span><br><span class="hljs-comment">// before the page_free_list list has been set up.</span><br></code></pre></td></tr></table></figure>

<ul>
<li><p>该函数为一个简易的 physical memory allocator，<strong>只在 JOS 建立其虚拟内存系统时使用</strong>，算是内核初始化过程中的一个临时函数</p>
</li>
<li><p>其功能主要是返回以页为单位的连续的物理内存空间的虚拟地址的起始地址，n为0时返回下一个空闲页面，OOM时 panic</p>
</li>
</ul>
<p>掌握了这些信息就可以开始写了，函数一开头定义了一个 static 的变量 <code>nextfree</code>，表示其分配方式是从内存一开始线性往后切割的，由于这是一个虚拟地址所以我们在计算是否 OOM 时还需要转化成物理地址，因为预设页表只映射了 4MB 内存故这里超出 4MB 我们直接 OOM panic；对页大小的对齐直接使用 <code>ROUNDUP</code> 即可</p>
<blockquote>
<p>ROUNDUP 是 GCC 的宏还是 JOS 的宏呢？暂且不考证（其实是没找到），这里直接“拿来主义”</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<br><span class="hljs-title function_">boot_alloc</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> n)</span><br>&#123;<br>	<span class="hljs-type">static</span> <span class="hljs-type">char</span> *nextfree;	<span class="hljs-comment">// virtual address of next byte of free memory</span><br>	<span class="hljs-type">char</span> *result;<br><br>	<span class="hljs-comment">// Initialize nextfree if this is the first time.</span><br>	<span class="hljs-comment">// &#x27;end&#x27; is a magic symbol automatically generated by the linker,</span><br>	<span class="hljs-comment">// which points to the end of the kernel&#x27;s bss segment:</span><br>	<span class="hljs-comment">// the first virtual address that the linker did *not* assign</span><br>	<span class="hljs-comment">// to any kernel code or global variables.</span><br>	<span class="hljs-keyword">if</span> (!nextfree) &#123;<br>		<span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> end[];<br>		nextfree = ROUNDUP((<span class="hljs-type">char</span> *) end, PGSIZE);<br>	&#125;<br><br>	<span class="hljs-comment">// Allocate a chunk large enough to hold &#x27;n&#x27; bytes, then update</span><br>	<span class="hljs-comment">// nextfree.  Make sure nextfree is kept aligned</span><br>	<span class="hljs-comment">// to a multiple of PGSIZE.</span><br>	<span class="hljs-comment">//</span><br>	<span class="hljs-comment">// LAB 2: Your code here.</span><br><br>	<span class="hljs-comment">// n == 0, return nextfree directly</span><br>	<span class="hljs-keyword">if</span> (!n)<br>		<span class="hljs-keyword">return</span> nextfree;<br>	<br>	<span class="hljs-comment">// fix up n to PGSIZE</span><br>	n = ROUNDUP(n, PGSIZE);<br>	<br>	<span class="hljs-comment">// check if OOM, panic</span><br>	<span class="hljs-keyword">if</span> (PADDR(nextfree + n) &gt; <span class="hljs-number">0x00400000</span>)<br>		panic(<span class="hljs-string">&quot;Out of Memory!&quot;</span>);<br>	<br>	<span class="hljs-comment">// normally return memory</span><br>	result = nextfree;<br>	nextfree += n;<br><br>	<span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="mem-init-：初始化二级页表，建立-freelist（part1）"><a href="#mem-init-：初始化二级页表，建立-freelist（part1）" class="headerlink" title="mem_init()：初始化二级页表，建立 freelist（part1）"></a>mem_init()：初始化二级页表，建立 freelist（part1）</h4><p>按顺序接下来到 <code>mem_init()</code> 函数，惯例先看注释，主要是初始化内核地址空间：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Set up a two-level page table:</span><br><span class="hljs-comment">//    kern_pgdir is its linear (virtual) address of the root</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// This function only sets up the kernel part of the address space</span><br><span class="hljs-comment">// (ie. addresses &gt;= UTOP).  The user part of the address space</span><br><span class="hljs-comment">// will be set up later.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// From UTOP to ULIM, the user is allowed to read but not write.</span><br><span class="hljs-comment">// Above ULIM the user cannot read or write.</span><br></code></pre></td></tr></table></figure>

<p>首先是通过 <code>i386_detect_memory()</code> 检测可用内存容量，之后用 <code>boot_alloc()</code> 分配一张页面做二级页表的 PGD，并<strong>建立自我映射，设置对应权限</strong>，以此我们便能通过虚拟地址访问页表了</p>
<blockquote>
<p>参见  <code>memlayout.h</code> 中的内存布局，<code>UVPT</code> 指向 PGD 起始地址，<code>PDX()</code> 则是将虚拟地址转换到页目录表项下标的宏，<code>PTE_U</code> 表示 ring0~ring3都能访问，<code>PTE_P</code> 表示该页面存在</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">mem_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>	<span class="hljs-type">uint32_t</span> cr0;<br>	<span class="hljs-type">size_t</span> n;<br><br>	<span class="hljs-comment">// Find out how much memory the machine has (npages &amp; npages_basemem).</span><br>	i386_detect_memory();<br><br>	<span class="hljs-comment">// Remove this line when you&#x27;re ready to test this function.</span><br>	<span class="hljs-comment">//panic(&quot;mem_init: This function is not finished\n&quot;);</span><br><br>	<span class="hljs-comment">//////////////////////////////////////////////////////////////////////</span><br>	<span class="hljs-comment">// create initial page directory.</span><br>	kern_pgdir = (<span class="hljs-type">pde_t</span> *) boot_alloc(PGSIZE);<br>	<span class="hljs-built_in">memset</span>(kern_pgdir, <span class="hljs-number">0</span>, PGSIZE);<br><br>	<span class="hljs-comment">//////////////////////////////////////////////////////////////////////</span><br>	<span class="hljs-comment">// Recursively insert PD in itself as a page table, to form</span><br>	<span class="hljs-comment">// a virtual page table at virtual address UVPT.</span><br>	<span class="hljs-comment">// (For now, you don&#x27;t have understand the greater purpose of the</span><br>	<span class="hljs-comment">// following line.)</span><br><br>	<span class="hljs-comment">// Permissions: kernel R, user R</span><br>	kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;<br></code></pre></td></tr></table></figure>

<p>接下来到由我们补全的部分：分配 pages 数组并初始化为 0，十几秒就能写完：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//////////////////////////////////////////////////////////////////////</span><br><span class="hljs-comment">// Allocate an array of npages &#x27;struct PageInfo&#x27;s and store it in &#x27;pages&#x27;.</span><br><span class="hljs-comment">// The kernel uses this array to keep track of physical pages: for</span><br><span class="hljs-comment">// each physical page, there is a corresponding struct PageInfo in this</span><br><span class="hljs-comment">// array.  &#x27;npages&#x27; is the number of physical pages in memory.  Use memset</span><br><span class="hljs-comment">// to initialize all fields of each struct PageInfo to 0.</span><br><span class="hljs-comment">// Your code goes here:</span><br>pages = (<span class="hljs-keyword">struct</span> PageInfo*) boot_alloc(npages * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> PageInfo));<br><span class="hljs-built_in">memset</span>(pages, <span class="hljs-number">0</span>, npages * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> PageInfo));<br></code></pre></td></tr></table></figure>

<p>继续阅读，接下来会调用 <code>page_init()</code> 初始化 pages 数组中的每一个 PageInfo ，主要是设置引用计数为 0 并链到 freelist 上，之后是三个检查函数，Exercise 1 中提到我们这一步只需要补全到 <code>check_page_free_list()</code>，所以接下来开始补全 <code>page_init()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//////////////////////////////////////////////////////////////////////</span><br><span class="hljs-comment">// Now that we&#x27;ve allocated the initial kernel data structures, we set</span><br><span class="hljs-comment">// up the list of free physical pages. Once we&#x27;ve done so, all further</span><br><span class="hljs-comment">// memory management will go through the page_* functions. In</span><br><span class="hljs-comment">// particular, we can now map memory using boot_map_region</span><br><span class="hljs-comment">// or page_insert</span><br>page_init();<br><br>check_page_free_list(<span class="hljs-number">1</span>);<br>check_page_alloc();<br>check_page();<br></code></pre></td></tr></table></figure>

<h4 id="page-init-：初始化-pages-数组与-freelist"><a href="#page-init-：初始化-pages-数组与-freelist" class="headerlink" title="page_init()：初始化 pages 数组与 freelist"></a>page_init()：初始化 pages 数组与 freelist</h4><p>惯例先看注释：初始化 pages 结构体与 freelist</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Initialize page structure and memory free list.</span><br><span class="hljs-comment">// After this is done, NEVER use boot_alloc again.  ONLY use the page</span><br><span class="hljs-comment">// allocator functions below to allocate and deallocate physical</span><br><span class="hljs-comment">// memory via the page_free_list.</span><br><span class="hljs-comment">//</span><br></code></pre></td></tr></table></figure>

<p>接下来按注释进行补全，我们需要明确哪些页在&#x2F;不在空闲状态：</p>
<ul>
<li>第一张物理内存页为在使用状态，保存着实模式的 IDT 与 BIOS 结构</li>
<li><code>[PGSIZE, npages_basemem * PGSIZE)</code> 为可用的空闲内存</li>
<li><code>[IOPHYSMEM, EXTPHYSMEM)</code> 这一块内存用作 IO，对我们来说是一个“内存空洞”，也不应当被使用</li>
<li><code>[EXTPHYSMEM, ...)</code> 这一块扩展内存，有的是在使用着的，有的又是空闲的，我们需要绕开：<ul>
<li>内核镜像</li>
<li>页表</li>
<li>其他数据结构</li>
</ul>
</li>
</ul>
<p>最后一个似乎比较棘手，但我们知道 boot_alloc() 初始化 nextfree 时用到一个变量 end 指向内核 bss 段末尾，说明<strong>往后的都是可用的内存</strong>，因此我们只需要将第三项往后一直到 nextfree 的内存页设为使用状态、nextfree 往后的内存设为空闲页链入 freelist 即可</p>
<p>这里我们需要注意一个点：<code>boot_alloc()</code> 分配的是虚拟内存，<strong>但是 pages 数组对应的是物理内存</strong>，因此这里别忘了进行转换（笔者就在这碰了坑）</p>
<p>注意以上这些标准之后，修改 <code>page_init()</code> 的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">page_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>	<span class="hljs-comment">// The example code here marks all physical pages as free.</span><br>	<span class="hljs-comment">// However this is not truly the case.  What memory is free?</span><br>	<span class="hljs-comment">//  1) Mark physical page 0 as in use.</span><br>	<span class="hljs-comment">//     This way we preserve the real-mode IDT and BIOS structures</span><br>	<span class="hljs-comment">//     in case we ever need them.  (Currently we don&#x27;t, but...)</span><br>	<span class="hljs-comment">//  2) The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)</span><br>	<span class="hljs-comment">//     is free.</span><br>	<span class="hljs-comment">//  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must</span><br>	<span class="hljs-comment">//     never be allocated.</span><br>	<span class="hljs-comment">//  4) Then extended memory [EXTPHYSMEM, ...).</span><br>	<span class="hljs-comment">//     Some of it is in use, some is free. Where is the kernel</span><br>	<span class="hljs-comment">//     in physical memory?  Which pages are already in use for</span><br>	<span class="hljs-comment">//     page tables and other data structures?</span><br>	<span class="hljs-comment">//</span><br>	<span class="hljs-comment">// Change the code to reflect this.</span><br>	<span class="hljs-comment">// NB: DO NOT actually touch the physical memory corresponding to</span><br>	<span class="hljs-comment">// free pages!</span><br><br>	<span class="hljs-comment">// 0) init</span><br>	<span class="hljs-type">size_t</span> 	i;<br>	<span class="hljs-type">size_t</span> 	next_free_addr;<br>	page_free_list = <span class="hljs-number">0</span>;<br><br>	<span class="hljs-comment">// 1) real-mode IDT and BIOS</span><br>	pages[<span class="hljs-number">0</span>].pp_ref = <span class="hljs-number">1</span>;<br><br>	<span class="hljs-comment">// 2) [PGSIZE, npages_basemem * PGSIZE), all free</span><br>	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; npages_basemem; i++) &#123;<br>		pages[i].pp_ref = <span class="hljs-number">0</span>;<br>		pages[i].pp_link = page_free_list;<br>		page_free_list = &amp;pages[i];<br>	&#125;<br><br>	<span class="hljs-comment">// 3) [IOPHYSMEM, EXTPHYSMEM), treat it as a hole</span><br>	<span class="hljs-keyword">for</span> (i = IOPHYSMEM/PGSIZE; i &lt; EXTPHYSMEM/PGSIZE; i++) &#123;<br>		pages[i].pp_ref = <span class="hljs-number">1</span>;<br>	&#125;<br><br>	<span class="hljs-comment">// 4) kernel image, page tables, other structure in user, others free</span><br>	next_free_addr = (<span class="hljs-type">size_t</span>) PADDR(boot_alloc(<span class="hljs-number">0</span>));<br>	<span class="hljs-keyword">for</span> (i = EXTPHYSMEM/PGSIZE; i &lt; next_free_addr / PGSIZE; i++) &#123;<br>		pages[i].pp_ref = <span class="hljs-number">1</span>;<br>	&#125;<br><br>	<span class="hljs-keyword">for</span> (i = next_free_addr / PGSIZE; i &lt; npages; i++) &#123;<br>		pages[i].pp_ref = <span class="hljs-number">0</span>;<br>		pages[i].pp_link = page_free_list;<br>		page_free_list = &amp;pages[i];<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="page-alloc-：分配单个空闲页面"><a href="#page-alloc-：分配单个空闲页面" class="headerlink" title="page_alloc()：分配单个空闲页面"></a>page_alloc()：分配单个空闲页面</h4><p>这一块比较简单，直接从 freelist 中取出一个页面即可，这里注意如果有 <code>ALLOC_ZERO</code> 则需要我们帮忙清零，<strong>而且我们分配时不应当增加引用计数，这应该是由 caller 完成的</strong></p>
<p>这里我们别忘了在清零时应当用 <code>page2kva</code> 将 PageInfo 结构体地址转化为其对应页面的虚拟地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Allocates a physical page.  If (alloc_flags &amp; ALLOC_ZERO), fills the entire</span><br><span class="hljs-comment">// returned physical page with &#x27;\0&#x27; bytes.  Does NOT increment the reference</span><br><span class="hljs-comment">// count of the page - the caller must do these if necessary (either explicitly</span><br><span class="hljs-comment">// or via page_insert).</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Be sure to set the pp_link field of the allocated page to NULL so</span><br><span class="hljs-comment">// page_free can check for double-free bugs.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Returns NULL if out of free memory.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Hint: use page2kva and memset</span><br><span class="hljs-keyword">struct</span> PageInfo *<br><span class="hljs-title function_">page_alloc</span><span class="hljs-params">(<span class="hljs-type">int</span> alloc_flags)</span><br>&#123;<br>	<span class="hljs-comment">// Fill this function in</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">victim</span>;</span><br><br>	<span class="hljs-comment">// out of memory</span><br>	<span class="hljs-keyword">if</span> (!page_free_list)<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	<br>	<span class="hljs-comment">// normal alloc</span><br>	victim = page_free_list;<br>	page_free_list = page_free_list.pp_link;<br>	victim.pp_link = <span class="hljs-number">0</span>;<br><br>	<span class="hljs-keyword">if</span> (alloc_flags &amp; ALLOC_ZERO)<br>		<span class="hljs-built_in">memset</span>(page2kva(victim), <span class="hljs-number">0</span>, PGSIZE);<br><br>	<span class="hljs-keyword">return</span> victim;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="page-free-：释放单个页面"><a href="#page-free-：释放单个页面" class="headerlink" title="page_free()：释放单个页面"></a>page_free()：释放单个页面</h4><p>主要是一些检查之后插入 freelist 头部即可，笔者还自行加了一个类似 ptmalloc 中对头部的简易 double free 检测（笑）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Return a page to the free list.</span><br><span class="hljs-comment">// (This function should only be called when pp-&gt;pp_ref reaches 0.)</span><br><span class="hljs-comment">//</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">page_free</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> PageInfo *pp)</span><br>&#123;<br>	<span class="hljs-comment">// Fill this function in</span><br>	<span class="hljs-comment">// Hint: You may want to panic if pp-&gt;pp_ref is nonzero or</span><br>	<span class="hljs-comment">// pp-&gt;pp_link is not NULL.</span><br><br>	<span class="hljs-comment">// check for double free at top</span><br>	<span class="hljs-keyword">if</span> (pp == page_free_list)<br>		panic(<span class="hljs-string">&quot;double free detected (freelist top)&quot;</span>);<br>	<br>	<span class="hljs-comment">// check double free by pp_link</span><br>	<span class="hljs-keyword">if</span> (pp-&gt;pp_link)<br>		panic(<span class="hljs-string">&quot;double free detected (pp_link)&quot;</span>);<br>	<br>	<span class="hljs-comment">// check validation by pp_ref</span><br>	<span class="hljs-keyword">if</span> (pp-&gt;pp_ref)<br>		panic(<span class="hljs-string">&quot;cannot free a page in use!&quot;</span>);<br>	<br>	pp-&gt;pp_link = page_free_list;<br>	page_free_list = pp;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>到这里 Exercise 1 就完成了，接下来进入 Part2.</p>
<h2 id="Part-2-Virtual-Memory"><a href="#Part-2-Virtual-Memory" class="headerlink" title="Part 2: Virtual Memory"></a>Part 2: Virtual Memory</h2><p>一上来就是 Exercise 2，主要是让我们了解 80386 下的<strong>分段</strong>和<strong>分页</strong></p>
<blockquote>
<p><strong>Exercise 2.</strong> Look at chapters 5 and 6 of the <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2018/readings/i386/toc.htm">Intel 80386 Reference Manual</a>, if you haven’t done so already. Read the sections about page translation and page-based protection closely (5.2 and 6.4). We recommend that you also skim the sections about segmentation; while JOS uses the paging hardware for virtual memory and protection, segment translation and segment-based protection cannot be disabled on the x86, so you will need a basic understanding of it.</p>
</blockquote>
<p>分段大家都懂，就是一个段寄存器里存放段选择子对应一个段描述符表示一块连续的内存称为一个segment，分页则是依托页表这一结构建立起虚拟地址到物理地址间的映射，那么是不是说明分页出现以后分段就自然而然地消失了呢？答案是否定的，<strong>分页与分段其实是同时存在的</strong>，因为这是由硬件（CPU）提供的功能</p>
<p>下图是一张分页与分段相结合的逻辑地址到物理地址间转换的过程</p>
<p><img src="https://s2.loli.net/2022/03/15/fYIXuTGWdMn7ViE.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>笔者这里参照其提供的文档简述一下分段+分页下的地址翻译</p>
<h4 id="Segment-Translation"><a href="#Segment-Translation" class="headerlink" title="Segment Translation"></a>Segment Translation</h4><p>进入保护模式之后，段寄存器并没有弃用，仍然承担着其“描述一个内存段”的作用，但仅有 16 位的、数量少得可怜的段寄存器早已无法满足人们的需求，因此在保护模式下段寄存器不再直接存放段的基址，而是存放着「段选择子」（segment selector）——真正的段描述符（segment descriptor）存放在一个名为「段描述符表」（segment descriptor table）的一块连续内存上，段选择子用以标识对应的段描述符在段描述符表中的下标与段的权限</p>
<p>因此在访问一个虚拟地址（逻辑地址）时首先需要通过段描述符翻译成对应的线性地址（若未开启分页则翻译的结果便直接为物理地址）</p>
<p><img src="https://s2.loli.net/2022/03/15/jhiSsfPoKgVyGdR.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>一个段描述符有着如下结构，需要注意的是<strong>系统段</strong>与普通的数据段和代码段等是有些许区别的，后者就是我们常用的普通的段，而前者通常用于表示中断门、陷阱门、调用门等</p>
<p><img src="https://s2.loli.net/2022/03/15/xhKpzoEHBXnVRk1.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>当然，既然段寄存器里存放的变成了段选择子，那么我们自然需要一个新的结构来对应表示段描述符表的地址，段描述符表分为两种——全局段描述符表与局部段描述符表，因而页引入了两个新的寄存器——GDTR 与 LDTR</p>
<p>需要注意的是，全局段描述符表的第一个段描述符为<strong>不可用的段描述符</strong></p>
<p><img src="https://s2.loli.net/2022/03/15/izYW8Dp7feT1wNE.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>最后我们来看段寄存器中存放的段选择子，结构较为简单，主要就是存放了对应的段描述符在段描述符表中的下标、访问权限、对应位于全局&#x2F;局部段描述符表</p>
<p><img src="https://s2.loli.net/2022/03/15/74PQFlKoHqLbsyW.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<blockquote>
<p>关于分段机制，更详细深入的说明参见 <a target="_blank" rel="noopener" href="https://arttnba3.cn/2021/06/24/CODE-0X00-A3OS/#%E4%B8%89%E3%80%81%E5%85%A8%E5%B1%80%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8%EF%BC%88Global-Descriptor-Table%EF%BC%89">https://arttnba3.cn/2021/06/24/CODE-0X00-A3OS/#%E4%B8%89%E3%80%81%E5%85%A8%E5%B1%80%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8%EF%BC%88Global-Descriptor-Table%EF%BC%89</a></p>
</blockquote>
<h4 id="Page-Translation"><a href="#Page-Translation" class="headerlink" title="Page Translation"></a>Page Translation</h4><p>讲完了分段机制，接下来到分页机制，分页机制将物理内存以「页」为粒度进行管理，通过「页表」这一数据结构完成线性地址到物理地址之间的映射</p>
<p>在保护模式下，是否开启分页是通过 Cr0 寄存器的 PG 位标识的，<strong>但是分段是默认开启的</strong>，怎么处理分段与分页之间的冲突呢？笔者认为可以这么理解：<strong>在开启分页之前，分段是直接对物理地址空间进行分段；在开启分页之后，分段是对页表映射后的线性地址空间进行分段</strong>，相当于是在分段与物理地址之间插入了一个中间层</p>
<p>于是我们接下来来看 32 位下启用二级页表的分页机制，在分页机制下一个 32 位的线性地址有着这样的三段式结构：</p>
<p><img src="https://s2.loli.net/2022/03/15/3pScjrUCxOkwJA7.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>在 Cr3 寄存器中存放着页目录表的地址；MMU在将一个线性地址翻译成物理地址时，首先通过 Cr3 寄存器获取到页目录表地址，通过线性地址的 DIR 域找到页目录表对应下标的页目录表项（Page Directory Entry），页目录表项中存放着对应的页表的地址，再通过线性地址的 PAGE 域找到页表对应下标的页表项（Page Table Entry），页表项中存放着对应的物理页地址，最后通过 OFFSET 域（即页内偏移）访问到对应物理页的对应数据</p>
<p><img src="https://s2.loli.net/2022/03/15/bnYKURW1xPg7CHN.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>一个页（目录）表项有着如下的结构，由于页目录表、页表、物理页都是以页为单位对齐的，因此我们只需要存放以页为单位的地址即可，空闲下来的这些位被用以存放页访问、读写权限等</p>
<p><img src="https://s2.loli.net/2022/03/15/begX4uJNymUs92a.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h3 id="Virtual-Linear-and-Physical-Addresses"><a href="#Virtual-Linear-and-Physical-Addresses" class="headerlink" title="Virtual, Linear, and Physical Addresses"></a>Virtual, Linear, and Physical Addresses</h3><p>我们现在正式对一堆各种地址名词下定义：</p>
<ul>
<li>「虚拟地址」：基于分段机制表示的地址，由一个段选择子与段内偏移组成</li>
<li>「线性地址」：基于分页机制表示的地址，是经过了分段翻译后的一个地址</li>
<li>「物理地址」：RAM 上的真实地址</li>
</ul>
<p>得到如下转换图例：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">           Selector  +--------------+         +-----------+<br>          ----------&gt;|<span class="hljs-string">              </span>|<span class="hljs-string">         </span>|<span class="hljs-string">           </span>|<br>                     |<span class="hljs-string"> Segmentation </span>|<span class="hljs-string">         </span>|<span class="hljs-string">  Paging   </span>|<br>Software             |<span class="hljs-string">              </span>|<span class="hljs-string">--------&gt;</span>|<span class="hljs-string">           </span>|<span class="hljs-string">----------&gt;  RAM</span><br><span class="hljs-string">            Offset   </span>|<span class="hljs-string">  Mechanism   </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> Mechanism </span>|<br>          ----------&gt;|<span class="hljs-string">              </span>|<span class="hljs-string">         </span>|<span class="hljs-string">           </span>|<br>                     +--------------+         +-----------+<br>            Virtual                   Linear                Physical<br></code></pre></td></tr></table></figure>

<p>其实在分页机制出现之后，分段机制就没有什么存在的意义了，因此你可以看到现代操作系统基本上都很少提分段的概念，大部分情况下虚拟地址就直接是线性地址（当然，其实还是有一些地方用到分段的权限验证等特性的）</p>
<p>同样地，为了简化地址翻译的操作，在 <code>boot/boot.S</code> 中 JOS <strong>初始化了一个所有的段描述符都对应段基址 0、段界限 0xffffffff 的全局段描述符表</strong>，这样虚拟地址实际上就直接是线性地址了</p>
<p>下面来看 Exercise 3，主要让我们熟悉 Qemu 提供的一些查看内存的指令</p>
<blockquote>
<p><strong>Exercise 3.</strong> While GDB can only access QEMU’s memory by virtual address, it’s often useful to be able to inspect physical memory while setting up virtual memory. Review the QEMU <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2018/labguide.html#qemu">monitor commands</a> from the lab tools guide, especially the <code>xp</code> command, which lets you inspect physical memory. To access the QEMU monitor, press Ctrl-a c in the terminal (the same binding returns to the serial console).</p>
<p>Use the xp command in the QEMU monitor and the x command in GDB to inspect memory at corresponding physical and virtual addresses and make sure you see the same data.</p>
<p>Our patched version of QEMU provides an info pg command that may also prove useful: it shows a compact but detailed representation of the current page tables, including all mapped memory ranges, permissions, and flags. Stock QEMU also provides an info mem command that shows an overview of which ranges of virtual addresses are mapped and with what permissions.</p>
</blockquote>
<p>先按 <code>Ctrl + A</code>，然后再按 <code>C</code>，进入 Qemu 的 monitor 模式，使用 <code>info pg</code> 指令查看分页映射，如下：</p>
<p><img src="https://s2.loli.net/2022/03/15/FlrKz6RbmSIBQf4.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>使用 <code>xp</code> 命令查看对应物理内存上数据与两个映射的虚拟地址上数据，完全一致</p>
<p><img src="https://s2.loli.net/2022/03/15/hupwIHRkyqefoD3.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>最后是 <code>info mem</code> 查看地址空间权限，虚拟地址空间起始 4MB 仅为可读权限，位于虚拟地址高 256MB 的起始 4MB 为可读写权限，<strong>但实际上对应的都是同一块物理地址空间</strong></p>
<p><img src="https://s2.loli.net/2022/03/15/N8nMTkh6Pgqlj5m.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>继续往下，在 JOS 中定义了两个 <code>uint32_t</code> 的别名 <code>uintptr_t</code> 与 <code>physaddr_t</code> 表示虚拟地址与物理地址（在编译器看来其实没有什么区别）</p>
<table>
<thead>
<tr>
<th>C type</th>
<th>Address type</th>
</tr>
</thead>
<tbody><tr>
<td><code>T*</code></td>
<td>Virtual</td>
</tr>
<tr>
<td><code>uintptr_t</code></td>
<td>Virtual</td>
</tr>
<tr>
<td><code>physaddr_t</code></td>
<td>Physical</td>
</tr>
</tbody></table>
<p>接下来是 MIT 6.828 的一个小习题：</p>
<blockquote>
<p><strong>Question</strong></p>
<ol>
<li>Assuming that the following JOS kernel code is correct, what type should variable <code>x</code> have, <code>uintptr_t</code> or <code>physaddr_t</code>?</li>
</ol>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">mystery_t x<span class="hljs-comment">;</span><br>char* value <span class="hljs-operator">=</span> return_a_pointer()<span class="hljs-comment">;</span><br>*value <span class="hljs-operator">=</span> <span class="hljs-number">10</span><span class="hljs-comment">;</span><br><span class="hljs-attribute">x</span> <span class="hljs-operator">=</span> (mystery_t) value<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>
</blockquote>
<p>我们知道虚拟地址是可以通过 MMU 进行翻译访问到物理地址的，但是一个物理地址经过 MMU 之后得到的可能是奇形怪状的东西（比如说物理地址同值的虚拟地址已经建立了一个映射），所以这里的 x 应当是 <code>uintptr_t</code> 类型</p>
<h3 id="Reference-counting"><a href="#Reference-counting" class="headerlink" title="Reference counting"></a>Reference counting</h3><p>在用以表示单个物理页框的 <code>PageInfo</code> 结构体中的成员 <code>pp_ref</code> 用以表示一张页面被引用的次数（引用计数），引用计数为 0 时表示该页为空闲页，但是引用计数的增&#x2F;减<strong>应当由使用者完成</strong>，因此在我们调用 <code>page_alloc()</code> 之后应当立即将引用计数 + 1，而当引用计数为 0 时我们才应当调用 <code>page_free()</code> 释放一张内存页</p>
<blockquote>
<p>最后这个工作 JOS 归并在 <code>page_decref()</code> 中完成</p>
</blockquote>
<h3 id="Page-Table-Management"><a href="#Page-Table-Management" class="headerlink" title="Page Table Management"></a>Page Table Management</h3><p>接下来是 Exercise4，让我们完成对页表的管理，补全对应函数</p>
<blockquote>
<p><strong>Exercise 4.</strong> In the file <code>kern/pmap.c</code>, you must implement code for the following functions.</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">pgdir_walk</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">boot_map_region</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">page_lookup</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">page_remove</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">page_insert</span><span class="hljs-params">()</span></span><br>	<br></code></pre></td></tr></table></figure>

<p><code>check_page()</code>, called from <code>mem_init()</code>, tests your page table management routines. You should make sure it reports success before proceeding.</p>
</blockquote>
<h4 id="pgdir-walk-：（创建并）返回-PTE"><a href="#pgdir-walk-：（创建并）返回-PTE" class="headerlink" title="pgdir_walk()：（创建并）返回 PTE"></a>pgdir_walk()：（创建并）返回 PTE</h4><p>按惯例先看注释，对于一个给定的页目录表地址与一个线性地址，该函数应当返回对应的「页表项」的地址，若对应的页表为空且指定了 <code>create</code> 标志位，则分配一张新的物理页作为新的页表，若否、或是分配物理页失败则直接返回 NULL；分配成功后应当增加该页的引用计数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Given &#x27;pgdir&#x27;, a pointer to a page directory, pgdir_walk returns</span><br><span class="hljs-comment">// a pointer to the page table entry (PTE) for linear address &#x27;va&#x27;.</span><br><span class="hljs-comment">// This requires walking the two-level page table structure.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// The relevant page table page might not exist yet.</span><br><span class="hljs-comment">// If this is true, and create == false, then pgdir_walk returns NULL.</span><br><span class="hljs-comment">// Otherwise, pgdir_walk allocates a new page table page with page_alloc.</span><br><span class="hljs-comment">//    - If the allocation fails, pgdir_walk returns NULL.</span><br><span class="hljs-comment">//    - Otherwise, the new page&#x27;s reference count is incremented,</span><br><span class="hljs-comment">//	the page is cleared,</span><br><span class="hljs-comment">//	and pgdir_walk returns a pointer into the new page table page.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Hint 1: you can turn a PageInfo * into the physical address of the</span><br><span class="hljs-comment">// page it refers to with page2pa() from kern/pmap.h.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Hint 2: the x86 MMU checks permission bits in both the page directory</span><br><span class="hljs-comment">// and the page table, so it&#x27;s safe to leave permissions in the page</span><br><span class="hljs-comment">// directory more permissive than strictly necessary.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Hint 3: look at inc/mmu.h for useful macros that manipulate page</span><br><span class="hljs-comment">// table and page directory entries.</span><br><span class="hljs-comment">//</span><br></code></pre></td></tr></table></figure>

<p>参照源码其他地方的相关写法，利用 JOS 提供的一些宏很容易就能补完该函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pte_t</span> *<br><span class="hljs-title function_">pgdir_walk</span><span class="hljs-params">(<span class="hljs-type">pde_t</span> *pgdir, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *va, <span class="hljs-type">int</span> create)</span><br>&#123;<br>	<span class="hljs-comment">// Fill this function in</span><br><br>	<span class="hljs-type">int</span> 	pde_idx;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">new_page_table_page</span>;</span><br>	<span class="hljs-type">pte_t</span> 	*page_table;<br><br>	<span class="hljs-keyword">if</span> (!pgdir)<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>	<span class="hljs-comment">// create page table if not exist</span><br>	pde_idx = PDX(va);<br>	<span class="hljs-keyword">if</span> (!pgdir[pde_idx] || !(pgdir[pde_idx] &amp; PTE_P))<br>	&#123;<br>		<span class="hljs-keyword">if</span> (create)<br>		&#123;<br>			new_page_table_page = page_alloc(ALLOC_ZERO);<br>			<span class="hljs-keyword">if</span> (!new_page_table_page)<br>				<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>			new_page_table_page-&gt;pp_ref++;<br>			pgdir[pde_idx] = (<span class="hljs-type">pde_t</span>) (page2pa(new_page_table_page) | PTE_P | PTE_W | PTE_U);<br>		&#125;<br>		<span class="hljs-keyword">else</span><br>		&#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-comment">// align to PGSIZE</span><br>	page_table = (<span class="hljs-type">pte_t</span>*) ((<span class="hljs-type">uint32_t</span>) KADDR(pgdir[pde_idx]) &amp; (~(PGSIZE - <span class="hljs-number">1</span>)));<br><br>	<span class="hljs-keyword">return</span> &amp;page_table[PTX(va)];<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="boot-map-region-：建立虚拟地址区域到物理地址区域映射"><a href="#boot-map-region-：建立虚拟地址区域到物理地址区域映射" class="headerlink" title="boot_map_region()：建立虚拟地址区域到物理地址区域映射"></a>boot_map_region()：建立虚拟地址区域到物理地址区域映射</h4><p>惯例先看注释，主要是建立虚拟地址 <code>[va, va+size)</code> 到物理地址 <code>[pa, pa+size)</code> 之间的映射，提示我们使用 <code>pgdir_walk()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Map [va, va+size) of virtual address space to physical [pa, pa+size)</span><br><span class="hljs-comment">// in the page table rooted at pgdir.  Size is a multiple of PGSIZE, and</span><br><span class="hljs-comment">// va and pa are both page-aligned.</span><br><span class="hljs-comment">// Use permission bits perm|PTE_P for the entries.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// This function is only intended to set up the ``static&#x27;&#x27; mappings</span><br><span class="hljs-comment">// above UTOP. As such, it should *not* change the pp_ref field on the</span><br><span class="hljs-comment">// mapped pages.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Hint: the TA solution uses pgdir_walk</span><br></code></pre></td></tr></table></figure>

<p>对应写入页表项条目即可，注意这里不需要改变页的引用计数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">boot_map_region</span><span class="hljs-params">(<span class="hljs-type">pde_t</span> *pgdir, <span class="hljs-type">uintptr_t</span> va, <span class="hljs-type">size_t</span> size, <span class="hljs-type">physaddr_t</span> pa, <span class="hljs-type">int</span> perm)</span><br>&#123;<br>	<span class="hljs-comment">// Fill this function in</span><br><br>	<span class="hljs-type">size_t</span> 		i;<br>	<span class="hljs-type">pte_t</span> 		*cur_pte;<br><br>	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; size / PGSIZE; i++)<br>	&#123;<br>		cur_pte = pgdir_walk(pgdir, (<span class="hljs-type">void</span> *)(va + i * PGSIZE), <span class="hljs-number">1</span>);<br>		<span class="hljs-keyword">if</span> (!cur_pte)<br>			panic(<span class="hljs-string">&quot;out of memory while creating page table!&quot;</span>);<br>		*cur_pte = (<span class="hljs-type">pte_t</span>) ((pa + i * PGSIZE) | PTE_P | perm);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="page-lookup-：返回虚拟地址对应-PageInfo-地址"><a href="#page-lookup-：返回虚拟地址对应-PageInfo-地址" class="headerlink" title="page_lookup()：返回虚拟地址对应 PageInfo 地址"></a>page_lookup()：返回虚拟地址对应 PageInfo 地址</h4><p>主要是让我们查找页表，返回虚拟地址对应的 PageInfo</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Return the page mapped at virtual address &#x27;va&#x27;.</span><br><span class="hljs-comment">// If pte_store is not zero, then we store in it the address</span><br><span class="hljs-comment">// of the pte for this page.  This is used by page_remove and</span><br><span class="hljs-comment">// can be used to verify page permissions for syscall arguments,</span><br><span class="hljs-comment">// but should not be used by most callers.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Return NULL if there is no page mapped at va.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Hint: the TA solution uses pgdir_walk and pa2page.</span><br><span class="hljs-comment">//</span><br></code></pre></td></tr></table></figure>

<p>直接用前面写的 <code>pgdir_walk()</code> 找到页表项再用 <code>pa2page()</code> 把物理地址转成 PageInfo 的虚拟地址即可，JOS 还提供了一个方便的页表项到物理地址转化的宏 <code>PTE_ADDR()</code> （一开始笔者都是纯手写…）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> PageInfo *<br><span class="hljs-title function_">page_lookup</span><span class="hljs-params">(<span class="hljs-type">pde_t</span> *pgdir, <span class="hljs-type">void</span> *va, <span class="hljs-type">pte_t</span> **pte_store)</span><br>&#123;<br>	<span class="hljs-comment">// Fill this function in</span><br><br>	<span class="hljs-type">pte_t</span> 		*pte;<br><br>	pte = pgdir_walk(pgdir, va, <span class="hljs-number">0</span>);<br><br>	<span class="hljs-keyword">if</span> (pte_store)<br>		*pte_store = pte;<br>    <br>    <span class="hljs-comment">// page not present</span><br>	<span class="hljs-keyword">if</span> (!pte || !((*pte) &amp; PTE_P))<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>	<span class="hljs-keyword">return</span> pa2page(PTE_ADDR(*pte));<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="page-remove-：解除页表虚拟地址映射"><a href="#page-remove-：解除页表虚拟地址映射" class="headerlink" title="page_remove()：解除页表虚拟地址映射"></a>page_remove()：解除页表虚拟地址映射</h4><p>主要是解除页表上对应虚拟地址到物理地址间的映射</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Unmaps the physical page at virtual address &#x27;va&#x27;.</span><br><span class="hljs-comment">// If there is no physical page at that address, silently does nothing.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Details:</span><br><span class="hljs-comment">//   - The ref count on the physical page should decrement.</span><br><span class="hljs-comment">//   - The physical page should be freed if the refcount reaches 0.</span><br><span class="hljs-comment">//   - The pg table entry corresponding to &#x27;va&#x27; should be set to 0.</span><br><span class="hljs-comment">//     (if such a PTE exists)</span><br><span class="hljs-comment">//   - The TLB must be invalidated if you remove an entry from</span><br><span class="hljs-comment">//     the page table.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Hint: The TA solution is implemented using page_lookup,</span><br><span class="hljs-comment">// 	tlb_invalidate, and page_decref.</span><br><span class="hljs-comment">//</span><br></code></pre></td></tr></table></figure>

<p>清空页表项并减少引用计数即可，若引用计数为 0 则释放该页，别忘了使用 <code>tlb_invalidate()</code> 清除 TLB 中缓存</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">page_remove</span><span class="hljs-params">(<span class="hljs-type">pde_t</span> *pgdir, <span class="hljs-type">void</span> *va)</span><br>&#123;<br>	<span class="hljs-comment">// Fill this function in</span><br><br>	<span class="hljs-type">pte_t</span> 				*pte;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> 	*<span class="hljs-title">pp</span>;</span><br><br> 	<span class="hljs-comment">// get the PageInfo and PTE</span><br>	pp = page_lookup(pgdir, va, &amp;pte);<br>	<span class="hljs-keyword">if</span> (pp)<br>	&#123;<br>		<span class="hljs-comment">// clear PTE</span><br>		tlb_invalidate(pgdir, va);<br>		*pte = (<span class="hljs-type">pte_t</span>) <span class="hljs-literal">NULL</span>;<br><br>		<span class="hljs-comment">// decrease refcount</span><br>		page_decref(pp);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="page-insert-：建立虚拟地址到物理页映射"><a href="#page-insert-：建立虚拟地址到物理页映射" class="headerlink" title="page_insert()：建立虚拟地址到物理页映射"></a>page_insert()：建立虚拟地址到物理页映射</h4><p>建立单个虚拟地址到单张物理页上的映射，分配并增加页引用计数，若已有一个映射则移除现有映射并清空 TLB 对应条目</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Map the physical page &#x27;pp&#x27; at virtual address &#x27;va&#x27;.</span><br><span class="hljs-comment">// The permissions (the low 12 bits) of the page table entry</span><br><span class="hljs-comment">// should be set to &#x27;perm|PTE_P&#x27;.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Requirements</span><br><span class="hljs-comment">//   - If there is already a page mapped at &#x27;va&#x27;, it should be page_remove()d.</span><br><span class="hljs-comment">//   - If necessary, on demand, a page table should be allocated and inserted</span><br><span class="hljs-comment">//     into &#x27;pgdir&#x27;.</span><br><span class="hljs-comment">//   - pp-&gt;pp_ref should be incremented if the insertion succeeds.</span><br><span class="hljs-comment">//   - The TLB must be invalidated if a page was formerly present at &#x27;va&#x27;.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Corner-case hint: Make sure to consider what happens when the same</span><br><span class="hljs-comment">// pp is re-inserted at the same virtual address in the same pgdir.</span><br><span class="hljs-comment">// However, try not to distinguish this case in your code, as this</span><br><span class="hljs-comment">// frequently leads to subtle bugs; there&#x27;s an elegant way to handle</span><br><span class="hljs-comment">// everything in one code path.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// RETURNS:</span><br><span class="hljs-comment">//   0 on success</span><br><span class="hljs-comment">//   -E_NO_MEM, if page table couldn&#x27;t be allocated</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Hint: The TA solution is implemented using pgdir_walk, page_remove,</span><br><span class="hljs-comment">// and page2pa.</span><br><span class="hljs-comment">//</span><br></code></pre></td></tr></table></figure>

<p>官方推荐用 <code>page_remove()</code> 完成对现有页的解引用，但是会重复调用 <code>pgdir_walk()</code>，所以笔者直接展开操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">page_insert</span><span class="hljs-params">(<span class="hljs-type">pde_t</span> *pgdir, <span class="hljs-keyword">struct</span> PageInfo *pp, <span class="hljs-type">void</span> *va, <span class="hljs-type">int</span> perm)</span><br>&#123;<br>	<span class="hljs-comment">// Fill this function in</span><br>	<span class="hljs-type">pte_t</span> 				*pte;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> 	*<span class="hljs-title">old_pp</span>;</span><br><br> 	<span class="hljs-comment">// get pte of va, create it if not exist</span><br>	pte = pgdir_walk(pgdir, va, <span class="hljs-number">1</span>);<br>	<span class="hljs-keyword">if</span> (!pte)<br>		<span class="hljs-keyword">return</span> -E_NO_MEM;<br>	<br>	<span class="hljs-comment">// page already present, dereference it</span><br>	<span class="hljs-keyword">if</span> ((*pte) &amp; PTE_P)<br>	&#123;<br>		old_pp = pa2page(PTE_ADDR(*pte));<br><br>		<span class="hljs-comment">// if insert the same, just set the perm and return</span><br>		<span class="hljs-keyword">if</span> (old_pp == pp)<br>		&#123;<br>			*pte = page2pa(pp) | perm | PTE_P;<br>			<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>		&#125;<br><br>		<span class="hljs-comment">// clear PTE</span><br>		tlb_invalidate(pgdir, va);<br>		*pte = (<span class="hljs-type">pte_t</span>) <span class="hljs-literal">NULL</span>;<br><br>		<span class="hljs-comment">// decrease refcount</span><br>		page_decref(old_pp);<br>	&#125;<br><br>	pp-&gt;pp_ref++;<br>	*pte = page2pa(pp) | perm | PTE_P;<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>到这里时运行 lab2 的分数检查程序应该有 40 分了</p>
<h2 id="Part-3-Kernel-Address-Space"><a href="#Part-3-Kernel-Address-Space" class="headerlink" title="Part 3: Kernel Address Space"></a>Part 3: Kernel Address Space</h2><p>kernel 占据高 256MB的虚拟地址空间而 user 使用剩余的虚拟地址空间</p>
<h3 id="Permissions-and-Fault-Isolation"><a href="#Permissions-and-Fault-Isolation" class="headerlink" title="Permissions and Fault Isolation"></a>Permissions and Fault Isolation</h3><p>因为一张页目录表同时映射了用户空间与内核空间，因此我们需要通过页表中的权限位限制用户对一些地址空间的访问：</p>
<ul>
<li>对于 <code>ULIM</code> 往高地址的内存，用户无权访问</li>
<li>对于 <code>[UTOP, ULIM)</code> 这块区域的内存，用户与内核都<strong>只有只读权限</strong>，这块区域的映射将页表、PageInfo 数组等结构暴露给用户，但只有位于内核空间的映射可以写入页表与 PageInfo 数组</li>
</ul>
<h3 id="Initializing-the-Kernel-Address-Space"><a href="#Initializing-the-Kernel-Address-Space" class="headerlink" title="Initializing the Kernel Address Space"></a>Initializing the Kernel Address Space</h3><p>接下来是 Exercise 5：完成 <code>mem_init()</code> 的剩余部分</p>
<blockquote>
<p><strong>Exercise 5.</strong> Fill in the missing code in <code>mem_init()</code> after the call to <code>check_page()</code>.</p>
<p>Your code should now pass the <code>check_kern_pgdir()</code> and <code>check_page_installed_pgdir()</code> checks.</p>
</blockquote>
<h4 id="mem-init-：（part2）"><a href="#mem-init-：（part2）" class="headerlink" title="mem_init()：（part2）"></a>mem_init()：（part2）</h4><p>目光放回 <code>mem_init()</code>，接下来又到了该我们补全的地方：将 pages 映射到线性地址 <code>UPAGES</code> 上，新建映射的权限应为用户与内核都可读，但 pages 结构体应当为内核可读写而用户不可知，因此应当建立新的映射，这里该用上我们之前写的 <code>boot_map_region()</code> 了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//////////////////////////////////////////////////////////////////////</span><br><span class="hljs-comment">// Now we set up virtual memory</span><br><br><span class="hljs-comment">//////////////////////////////////////////////////////////////////////</span><br><span class="hljs-comment">// Map &#x27;pages&#x27; read-only by the user at linear address UPAGES</span><br><span class="hljs-comment">// Permissions:</span><br><span class="hljs-comment">//    - the new image at UPAGES -- kernel R, user R</span><br><span class="hljs-comment">//      (ie. perm = PTE_U | PTE_P)</span><br><span class="hljs-comment">//    - pages itself -- kernel RW, user NONE</span><br><span class="hljs-comment">// Your code goes here:</span><br>boot_map_region(kern_pgdir, UPAGES, <br>	ROUNDUP(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> PageInfo) * npages, PGSIZE), PADDR(pages), <br>	PTE_U);<br></code></pre></td></tr></table></figure>

<p>然后到初始化内核栈了，这里内核栈被分为两块：</p>
<ul>
<li>常规的可读写内核栈</li>
<li>内核栈保护页面，读写到该页面上时说明栈爆了，称为 guard page</li>
</ul>
<p>guard page 不需要我们建立新的映射，因为如果爆栈了读写到 guard page 自然会触发 page fault，这时我们便知道爆栈了</p>
<p>需要注意内核栈应仅为内核可读写，应设置页表项的 Supervisor 权限位，即不使用 <code>PTE_U</code> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//////////////////////////////////////////////////////////////////////</span><br><span class="hljs-comment">// Use the physical memory that &#x27;bootstack&#x27; refers to as the kernel</span><br><span class="hljs-comment">// stack.  The kernel stack grows down from virtual address KSTACKTOP.</span><br><span class="hljs-comment">// We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)</span><br><span class="hljs-comment">// to be the kernel stack, but break this into two pieces:</span><br><span class="hljs-comment">//     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory</span><br><span class="hljs-comment">//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if</span><br><span class="hljs-comment">//       the kernel overflows its stack, it will fault rather than</span><br><span class="hljs-comment">//       overwrite memory.  Known as a &quot;guard page&quot;.</span><br><span class="hljs-comment">//     Permissions: kernel RW, user NONE</span><br><span class="hljs-comment">// Your code goes here:</span><br>boot_map_region(kern_pgdir, KSTACKTOP - KSTKSIZE, KSTKSIZE, <br>	PADDR(bootstack), PTE_W);<br></code></pre></td></tr></table></figure>

<p>最后是建立内核空间的映射，将高虚拟地址处的内核映射到物理地址起始处</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//////////////////////////////////////////////////////////////////////</span><br><span class="hljs-comment">// Map all of physical memory at KERNBASE.</span><br><span class="hljs-comment">// Ie.  the VA range [KERNBASE, 2^32) should map to</span><br><span class="hljs-comment">//      the PA range [0, 2^32 - KERNBASE)</span><br><span class="hljs-comment">// We might not have 2^32 - KERNBASE bytes of physical memory, but</span><br><span class="hljs-comment">// we just set up the mapping anyway.</span><br><span class="hljs-comment">// Permissions: kernel RW, user NONE</span><br><span class="hljs-comment">// Your code goes here:</span><br>boot_map_region(kern_pgdir, KERNBASE,<br>	ROUNDUP(<span class="hljs-number">0xffffffff</span> - KERNBASE, PGSIZE), <br>	<span class="hljs-number">0</span>, PTE_W);<br></code></pre></td></tr></table></figure>

<p>完成这一切之后运行分数判断程序，全部通过，至此，lab2 的所有编程练习完美通过</p>
<p><img src="https://s2.loli.net/2022/03/15/IGJUqd92siweVzg.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>下面是习题 Time</p>
<blockquote>
<p><strong>Question</strong></p>
<ol>
<li><p>What entries (rows) in the page directory have been filled in at this point? What addresses do they map and where do they point? In other words, fill out this table as much as possible:</p>
<table>
<thead>
<tr>
<th>Entry</th>
<th>Base Virtual Address</th>
<th>Points to (logically):</th>
</tr>
</thead>
<tbody><tr>
<td>1023</td>
<td>?</td>
<td>Page table for top 4MB of phys memory</td>
</tr>
<tr>
<td>1022</td>
<td>?</td>
<td>?</td>
</tr>
<tr>
<td>.</td>
<td>?</td>
<td>?</td>
</tr>
<tr>
<td>.</td>
<td>?</td>
<td>?</td>
</tr>
<tr>
<td>.</td>
<td>?</td>
<td>?</td>
</tr>
<tr>
<td>2</td>
<td>0x00800000</td>
<td>?</td>
</tr>
<tr>
<td>1</td>
<td>0x00400000</td>
<td>?</td>
</tr>
<tr>
<td>0</td>
<td>0x00000000</td>
<td>[see next question]</td>
</tr>
</tbody></table>
<p><del>破题🐕都不做</del></p>
</li>
<li><p>We have placed the kernel and user environment in the same address space. Why will user programs not be able to read or write the kernel’s memory? What specific mechanisms protect the kernel memory?</p>
<p>由于页表项相关权限位的存在，导致用户进程（运行在 ring3）无法读写内核的内存空间，内存分页机制保护了内核内存</p>
</li>
<li><p>What is the maximum amount of physical memory that this operating system can support? Why?</p>
<p>操作系统最大可支持的物理内存应当为 4GB，这是一个 32 位长度的地址能够表示的范围上限</p>
</li>
<li><p>How much space overhead is there for managing memory, if we actually had the maximum amount of physical memory? How is this overhead broken down?</p>
<p><del>看不懂题目，摸了！</del>对于页表结构而言，一个二级页表刚好能满载 4GB 空间，需要一张页目录表与 1024 张页表，总计 <code>4198400</code> 字节空间；对于 PageInfo 结构体数组而言，一个 PageInfo 结构体占用的空间为 8 字节（4 字节对齐），那么要管理 4GB 的空间总计需要 <code>1048576</code> 个 PageInfo 结构体，占据 <code>8388608</code> 字节的空间；两者总计消耗 0.29% 的内存空间，笔者认为这个开销还是挺小的</p>
</li>
<li><p>Revisit the page table setup in <code>kern/entry.S</code> and <code>kern/entrypgdir.c</code>. Immediately after we turn on paging, EIP is still a low number (a little over 1MB). At what point do we transition to running at an EIP above KERNBASE? What makes it possible for us to continue executing at a low EIP between when we enable paging and when we begin running at an EIP above KERNBASE? Why is this transition necessary?</p>
<p>因为在启用分页之后低 1MB 的线性空间仍然映射到低 1MB 的物理空间，因此此时仍能正常运行；在 <code>call i386_init</code> 时跳转到 <code>kern/init.c</code> 中的 <code>i386_init()</code> 函数，此时 eip 便位于内核虚拟地址空间中了；在页表中建立双重映射；因为在开启分页之后 eip 暂时还运行在低地址空间，因此要先有个临时的双重映射保证进入内核虚拟地址空间之前的正常运行</p>
</li>
</ol>
</blockquote>
<p>接下来是选做部分：MIT 6.828 的 Challenge</p>
<blockquote>
<p><em>Challenge!</em> We consumed many physical pages to hold the page tables for the KERNBASE mapping. Do a more space-efficient job using the PTE_PS (“Page Size”) bit in the page directory entries. This bit was <em>not</em> supported in the original 80386, but is supported on more recent x86 processors. You will therefore have to refer to <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2018/readings/ia32/IA32-3A.pdf">Volume 3 of the current Intel manuals</a>. Make sure you design the kernel to use this optimization only on processors that support it!</p>
</blockquote>
<p>这个 challenge 的意思大概就是开启 4MB 的大页，这首先需要我们修改 Cr4 寄存器，设置 <strong>Page-Size Extensions</strong> 标志位为 1 后内存页的大小就从 4KB 变成了 4MB，还需要设置页表项的 <code>PTE_PS</code> 位，主要都是苦力活这里就先摸了（</p>
<p>下一个 Challenge，新增一个 <code>showmappings</code> 命令：</p>
<blockquote>
<p><em>Challenge!</em> Extend the JOS kernel monitor with commands to:</p>
<ul>
<li>Display in a useful and easy-to-read format all of the physical page mappings (or lack thereof) that apply to a particular range of virtual&#x2F;linear addresses in the currently active address space. For example, you might enter <code>&#39;showmappings 0x3000 0x5000&#39;</code> to display the physical page mappings and corresponding permission bits that apply to the pages at virtual addresses 0x3000, 0x4000, and 0x5000.</li>
<li>Explicitly set, clear, or change the permissions of any mapping in the current address space.</li>
<li>Dump the contents of a range of memory given either a virtual or physical address range. Be sure the dump code behaves correctly when the range extends across page boundaries!</li>
<li>Do anything else that you think might be useful later for debugging the kernel. (There’s a good chance it will be!)</li>
</ul>
</blockquote>
<p>使用 strtol 将字符串转为数字后使用 <code>page_lookup()</code> 查阅页表后打印即可</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">mon_show_mapping</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-keyword">struct</span> Trapframe *tf)</span><br>&#123;<br>	<span class="hljs-type">uintptr_t</span> 			vstart, vend;<br>	<span class="hljs-type">pte_t</span>				*pte;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> 	*<span class="hljs-title">pp</span>;</span><br><br>	<span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">3</span>)<br>	&#123;<br>		cprintf(<span class="hljs-string">&quot;Usage: showmappings addr_start addr_end\n&quot;</span>);<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	&#125;<br><br>	vstart = strtol(argv[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>	vend = strtol(argv[<span class="hljs-number">2</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>	<span class="hljs-keyword">if</span> (vstart &gt; vend)<br>	&#123;<br>		cprintf(<span class="hljs-string">&quot;Invalid start or end address!\n&quot;</span>);<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	&#125;<br><br>	cprintf(<span class="hljs-string">&quot;Virtual address\t\tPhysical Address\n&quot;</span>);<br>	<span class="hljs-keyword">for</span> (; vstart &lt;= vend; vstart += PGSIZE)<br>	&#123;<br>		cprintf(<span class="hljs-string">&quot;  %010p\t\t &quot;</span>, vstart);<br>		pp = page_lookup(kern_pgdir, (<span class="hljs-type">void</span>*) vstart, &amp;pte);<br>		<span class="hljs-keyword">if</span> (!pte)<br>			cprintf(<span class="hljs-string">&quot; Not mapped yet.\n&quot;</span>);<br>		<span class="hljs-keyword">else</span><br>			cprintf(<span class="hljs-string">&quot;  %010p\n&quot;</span>, page2pa(pp));<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>效果如下所示</p>
<p><img src="https://s2.loli.net/2022/03/16/Zz7vt2aeMJlUGVD.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h3 id="Address-Space-Layout-Alternatives"><a href="#Address-Space-Layout-Alternatives" class="headerlink" title="Address Space Layout Alternatives"></a>Address Space Layout Alternatives</h3><p>当前的 JOS 内存布局并非是唯一的一种，一个操作系统还能将内核映射在线性低地址空间、而将线性高地址空间给用户进程使用，但由于 x86的一种向后兼容模式——虚拟 8086 模式将处理器“硬连线”到线性地址空间底部，因此若内核映射到此处则完全不可用</p>
<p>虽然这可能比想象中困难，但我们仍然有能将内核映射到低线性地址空间的方案——允许用户进程直接访问整个地址空间，但仍将内核与各进程间分割开来</p>
<blockquote>
<p>笔者评价：闲得慌</p>
</blockquote>
<p>下面是三个<del>闲得慌</del>的 Challenge：</p>
<blockquote>
<p><em>Challenge!</em> Each user-level environment maps the kernel. Change JOS so that the kernel has its own page table and so that a user-level environment runs with a minimal number of kernel pages mapped. That is, each user-level environment maps just enough pages mapped so that the user-level environment can enter and leave the kernel correctly. You also have to come up with a plan for the kernel to read&#x2F;write arguments to system calls.</p>
</blockquote>
<p>大概是给内核设置一个独立的页表，而<strong>用户进程仅保留必须用到的内核映射，例如内核入口点</strong>（比如说系统调用），笔者认为这个实现差不多是 KPTI 的思想，这里就不手抄一份 KPTI 了<del>，用户进程还啥影子都没有，写个🐓</del></p>
<blockquote>
<p><em>Challenge!</em> Write up an outline of how a kernel could be designed to allow user environments unrestricted use of the full 4GB virtual and linear address space. Hint: do the previous challenge exercise first, which reduces the kernel to a few mappings in a user environment. Hint: the technique is sometimes known as “<em>follow the bouncing kernel</em>.” In your design, be sure to address exactly what has to happen when the processor transitions between kernel and user modes, and how the kernel would accomplish such transitions. Also describe how the kernel would access physical memory and I&#x2F;O devices in this scheme, and how the kernel would access a user environment’s virtual address space during system calls and the like. Finally, think about and describe the advantages and disadvantages of such a scheme in terms of flexibility, performance, kernel complexity, and other factors you can think of.</p>
</blockquote>
<p>大概是设计与实现上面的方案，并确保自己明确其中的细节</p>
<blockquote>
<p><em>Challenge!</em> Since our JOS kernel’s memory management system only allocates and frees memory on page granularity, we do not have anything comparable to a general-purpose <code>malloc</code>&#x2F;<code>free</code> facility that we can use within the kernel. This could be a problem if we want to support certain types of I&#x2F;O devices that require <em>physically contiguous</em> buffers larger than 4KB in size, or if we want user-level environments, and not just the kernel, to be able to allocate and map 4MB <em>superpages</em> for maximum processor efficiency. (See the earlier challenge problem about PTE_PS.)</p>
<p>Generalize the kernel’s memory allocation system to support pages of a variety of power-of-two allocation unit sizes from 4KB up to some reasonable maximum of your choice. Be sure you have some way to divide larger allocation units into smaller ones on demand, and to coalesce multiple small allocation units back into larger units when possible. Think about the issues that might arise in such a system.</p>
</blockquote>
<p>完善内核内存管理系统，提供更大粒度与更小粒度的 allocator（比如说 buddy system + slub allocator），这里就不手抄一份 buddy system 和 slub allocator 了，笔者暂时也没有更好的内存分配方案</p>
<blockquote>
<p><del>👴是懒🐕👴自豪</del></p>
</blockquote>
<p>至此，lab2 全部完成</p>
<h1 id="0x03-Lab-3-User-Environments"><a href="#0x03-Lab-3-User-Environments" class="headerlink" title="0x03.Lab 3: User Environments"></a>0x03.Lab 3: User Environments</h1><p>在这一部分我们终于要迈入用户进程的世界，实现特权级的分离，并完成系统调用的编写以及一个用户进程的运行</p>
<p><strong>注意</strong>：本 lab 中 <code>environment</code> 与 <code>process</code> 代指同一事物——运行的进程的抽象体，6.828 在这里更多使用 environment 而不是 process 是为了指出 JOS environment 与 UNIX process 提供了不同的接口，且不提供相同的语义</p>
<p>首先是惯例地将 lab 3代码拉到本地</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git add .</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git commit -am <span class="hljs-string">&#x27;changes to lab2 after handin&#x27;</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git pull</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git checkout -b lab3 origin/lab3</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git merge lab2</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>这里笔者本想先跑一跑内核玩玩，但是遇到一个奇怪的问题：在分配页目录表地址空间后、建立映射时会 panic 掉，经笔者调试发现在 boot_alloc() 中初始化 nextfree 的值所指向的那张内存页上<strong>仍然存在着一些内核变量，即这并非是一个闲置的内存页</strong>，于是我们的指向页目录表的指针就被 memset 清零了…</p>
<p>为什么？让我们将目光放回 <code>boot_alloc()</code> 函数中，在我们初始化 nextfree 时使用的是一个外部引入的变量 <code>end</code> 对内存页进行向上对齐得到的地址，这里说是由链接器生成的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Initialize nextfree if this is the first time.</span><br><span class="hljs-comment">// &#x27;end&#x27; is a magic symbol automatically generated by the linker,</span><br><span class="hljs-comment">// which points to the end of the kernel&#x27;s bss segment:</span><br><span class="hljs-comment">// the first virtual address that the linker did *not* assign</span><br><span class="hljs-comment">// to any kernel code or global variables.</span><br><span class="hljs-keyword">if</span> (!nextfree) &#123;<br>	<span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> end[];<br>	nextfree = ROUNDUP((<span class="hljs-type">char</span> *) end, PGSIZE);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>**但经过笔者反编译内核文件、打印 end 变量信息发现，其并不指向 bss 的末尾，后面还有几个变量，且其刚好落在内存页对齐的地址…**这也是为什么 ROUNDUP 不能顺利拯救 nextfree 的原因，可能也是为什么之前没有出现该问题的原因：之前 end 不一定刚好落在内存页对齐的地址，向上对齐一个页自然就早已超出 bss 了，但是现在链接器恰好将其生成在了一个微妙的位置</p>
<p><img src="https://s2.loli.net/2022/03/16/FzLf8Z39beEkXrH.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p><img src="https://s2.loli.net/2022/03/16/1YAmcNrF8h3iLTy.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>笔者甚至怀疑 end 可能之前甚至都不在 bss 段末尾，可能也不是链接器生成的“末尾变量”…但是一看 IDA 的反编译结果，<strong>好像确乎有个 end 在整个镜像的最末尾，但他又指回了那个位置尴尬的 end 变量</strong></p>
<p><img src="https://s2.loli.net/2022/03/16/qDMFGo9v83PAOpY.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>笔者暂且不知道是什么原因导致了这个现象的发生，目前的解决方案是在计算 nextfree 时多加一个 page 进行 ROUNDUP，<strong>但在后面的 check_kern_pgdir 里面又 panic 掉了…</strong></p>
<blockquote>
<p>lab2 跑得好好的 lab3 咋突然莫名其妙炸了，👴不理解</p>
</blockquote>
<p>于是笔者<strong>将 lab2 分支的 kern&#x2F;pmap.c 拷贝过来，让 end 加上一个 page，内存管理这一块又一切正常了…</strong></p>
<blockquote>
<p>👴愿意称之为灵异事件</p>
</blockquote>
<p>那就只能是 lab3 中的一些改动把内存管理给 crash 掉了，笔者检索该函数的 panic 信息，发现确乎是在检查 lab3 新增的内存映射区域时 panic 的（这块内存我们还没映射）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// check envs array (new test for lab 3)</span><br>n = ROUNDUP(NENV*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Env), PGSIZE);<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i += PGSIZE)<br>	assert(check_va2pa(pgdir, UENVS + i) == PADDR(envs) + i);<br></code></pre></td></tr></table></figure>

<p>所以接下来重新开始 lab3 的旅程</p>
<blockquote>
<p>但👴觉得 end 确乎是对齐错了</p>
</blockquote>
</blockquote>
<p>在 lab3 中新增了以下文件：</p>
<table>
<thead>
<tr>
<th><code>inc/</code></th>
<th><code>env.h</code></th>
<th>Public definitions for user-mode environments</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><code>trap.h</code></td>
<td>Public definitions for trap handling</td>
</tr>
<tr>
<td></td>
<td><code>syscall.h</code></td>
<td>Public definitions for system calls from user environments to the kernel</td>
</tr>
<tr>
<td></td>
<td><code>lib.h</code></td>
<td>Public definitions for the user-mode support library</td>
</tr>
<tr>
<td><code>kern/</code></td>
<td><code>env.h</code></td>
<td>Kernel-private definitions for user-mode environments</td>
</tr>
<tr>
<td></td>
<td><code>env.c</code></td>
<td>Kernel code implementing user-mode environments</td>
</tr>
<tr>
<td></td>
<td><code>trap.h</code></td>
<td>Kernel-private trap handling definitions</td>
</tr>
<tr>
<td></td>
<td><code>trap.c</code></td>
<td>Trap handling code</td>
</tr>
<tr>
<td></td>
<td><code>trapentry.S</code></td>
<td>Assembly-language trap handler entry-points</td>
</tr>
<tr>
<td></td>
<td><code>syscall.h</code></td>
<td>Kernel-private definitions for system call handling</td>
</tr>
<tr>
<td></td>
<td><code>syscall.c</code></td>
<td>System call implementation code</td>
</tr>
<tr>
<td><code>lib/</code></td>
<td><code>Makefrag</code></td>
<td>Makefile fragment to build user-mode library, <code>obj/lib/libjos.a</code></td>
</tr>
<tr>
<td></td>
<td><code>entry.S</code></td>
<td>Assembly-language entry-point for user environments</td>
</tr>
<tr>
<td></td>
<td><code>libmain.c</code></td>
<td>User-mode library setup code called from <code>entry.S</code></td>
</tr>
<tr>
<td></td>
<td><code>syscall.c</code></td>
<td>User-mode system call stub functions</td>
</tr>
<tr>
<td></td>
<td><code>console.c</code></td>
<td>User-mode implementations of <code>putchar</code> and <code>getchar</code>, providing console I&#x2F;O</td>
</tr>
<tr>
<td></td>
<td><code>exit.c</code></td>
<td>User-mode implementation of <code>exit</code></td>
</tr>
<tr>
<td></td>
<td><code>panic.c</code></td>
<td>User-mode implementation of <code>panic</code></td>
</tr>
<tr>
<td><code>user/</code></td>
<td><code>*</code></td>
<td>Various test programs to check kernel lab 3 code</td>
</tr>
</tbody></table>
<h2 id="Part-A-User-Environments-and-Exception-Handling"><a href="#Part-A-User-Environments-and-Exception-Handling" class="headerlink" title="Part A: User Environments and Exception Handling"></a>Part A: User Environments and Exception Handling</h2><p>在新加入的头文件 <code>inc/env.h</code> 中包含了 JOS 的基本的用户环境定义，内核使用结构体 <code>Env</code> 来标识每一个用户环境，在本 lab 中我们需要完成 JOS 的多环境支持</p>
<p>在 <code>kern/env.c</code> 中，内核维护三个与环境有关的全局变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">envs</span> =</span> <span class="hljs-literal">NULL</span>;		<span class="hljs-comment">// All environments</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">curenv</span> =</span> <span class="hljs-literal">NULL</span>;		<span class="hljs-comment">// The current env</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">env_free_list</span>;</span>	<span class="hljs-comment">// Free environment list</span><br></code></pre></td></tr></table></figure>

<p>在 JOS 启动时会初始化一个长度为 <code>NENV</code> 的 <code>Env</code> 结构体数组，其中闲置的 Env 结构体链在 <code>env_free_list</code> 中，而 <code>curenv</code> 指向当前环境的 Env 结构体（类似于 Linux 内核中的 current() 指向 当前 CPU 上运行的进程的 task_struct），在启动阶段 curenv 为 NULL</p>
<blockquote>
<p>笔者认为还是叫进程好听，既然是同一个东西，没有必要为了和 UNIX 区分开来而特意改个莫名其妙的名字</p>
</blockquote>
<h3 id="Environment-State"><a href="#Environment-State" class="headerlink" title="Environment State"></a>Environment State</h3><p><code>Env</code> 结构体定义如下，笔者认为可以类比做 Linux 下的 <code>task_struct</code> ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> &#123;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Trapframe</span> <span class="hljs-title">env_tf</span>;</span>	<span class="hljs-comment">// Saved registers</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">env_link</span>;</span>		<span class="hljs-comment">// Next free Env</span><br>	<span class="hljs-type">envid_t</span> env_id;			<span class="hljs-comment">// Unique environment identifier</span><br>	<span class="hljs-type">envid_t</span> env_parent_id;		<span class="hljs-comment">// env_id of this env&#x27;s parent</span><br>	<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">EnvType</span> <span class="hljs-title">env_type</span>;</span>		<span class="hljs-comment">// Indicates special system environments</span><br>	<span class="hljs-type">unsigned</span> env_status;		<span class="hljs-comment">// Status of the environment</span><br>	<span class="hljs-type">uint32_t</span> env_runs;		<span class="hljs-comment">// Number of times environment has run</span><br><br>	<span class="hljs-comment">// Address space</span><br>	<span class="hljs-type">pde_t</span> *env_pgdir;		<span class="hljs-comment">// Kernel virtual address of page dir</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>各字段说明如下：</p>
<ul>
<li><p><strong>env_tf</strong>: 进程上下文中的寄存器状态</p>
</li>
<li><p><strong>env_link</strong>: 在 <code>env_free_list</code> 链表中指向下一个空闲 Env 结构体</p>
</li>
<li><p><strong>env_id</strong>: 唯一标识单个进程的 id，在 Env 结构体被重新分配后通常会发生改变</p>
</li>
<li><p><strong>env_parent_id</strong>: 父进程的 id</p>
</li>
<li><p><strong>env_type</strong>: 进程类型，对于大部分进程而言应当为 <code>ENV_TYPE_USER</code> 在后续的 lab 中会补充更多的为系统服务而出现的类型</p>
</li>
</ul>
<blockquote>
<p>用户进程与内核进程的既视感</p>
</blockquote>
<ul>
<li><p><strong>env_status</strong>: 进程状态，可选值范围如下：</p>
<ul>
<li><p><code>ENV_FREE</code>: 该 Env 结构体空闲</p>
</li>
<li><p><code>ENV_RUNNABLE</code>: 该 Env 结构体对应着一个等待运行的进程</p>
</li>
<li><p><code>ENV_RUNNING</code>: 该 Env 结构体对应着一个正在运行的进程</p>
</li>
<li><p><code>ENV_NOT_RUNNABLE</code>: 该 Env 结构体对应进程未准备好继续运行（例如在等待另一个进程的信号）</p>
</li>
<li><p><code>ENV_DYING</code>: 该 Env 结构体对应一个僵尸进程，我们将在 lab4 中用到它</p>
</li>
</ul>
</li>
<li><p><strong>env_pgdir</strong>: 进程页目录表</p>
</li>
</ul>
<p>需要注意的是，JOS 中的进程并没有自己的内核栈，同一时刻内只有一个进程可以处在内核态，所以 JOS 只需要一个单独的内核栈</p>
<h3 id="Allocating-the-Environments-Array"><a href="#Allocating-the-Environments-Array" class="headerlink" title="Allocating the Environments Array"></a>Allocating the Environments Array</h3><p>首先是一个小练习，在 <code>mem_init()</code> 中为 envs 数组分配空间</p>
<blockquote>
<p><strong>Exercise 1.</strong> Modify <code>mem_init()</code> in <code>kern/pmap.c</code> to allocate and map the <code>envs</code> array. This array consists of exactly <code>NENV</code> instances of the <code>Env</code> structure allocated much like how you allocated the <code>pages</code> array. Also like the <code>pages</code> array, the memory backing <code>envs</code> should also be mapped user read-only at <code>UENVS</code> (defined in <code>inc/memlayout.h</code>) so user processes can read from this array.</p>
<p>You should run your code and make sure <code>check_kern_pgdir()</code> succeeds.</p>
</blockquote>
<p>注意应在 <code>page_init()</code> 之前调用 <code>boot_alloc()</code> 分配空间，在这之后再进行映射，不要图省事写到一起</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//////////////////////////////////////////////////////////////////////</span><br><span class="hljs-comment">// Make &#x27;envs&#x27; point to an array of size &#x27;NENV&#x27; of &#x27;struct Env&#x27;.</span><br><span class="hljs-comment">// LAB 3: Your code here.</span><br>envs = boot_alloc(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Env) * NENV);<br><span class="hljs-built_in">memset</span>(envs, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Env) * NENV);<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-comment">//////////////////////////////////////////////////////////////////////</span><br><span class="hljs-comment">// Map the &#x27;envs&#x27; array read-only by the user at linear address UENVS</span><br><span class="hljs-comment">// (ie. perm = PTE_U | PTE_P).</span><br><span class="hljs-comment">// Permissions:</span><br><span class="hljs-comment">//    - the new image at UENVS  -- kernel R, user R</span><br><span class="hljs-comment">//    - envs itself -- kernel RW, user NONE</span><br><span class="hljs-comment">// LAB 3: Your code here.</span><br>boot_map_region(kern_pgdir, UENVS, <br>	ROUNDUP(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Env) * NENV, PGSIZE), <br>	PADDR(envs), PTE_U);<br></code></pre></td></tr></table></figure>



<h3 id="Creating-and-Running-Environments"><a href="#Creating-and-Running-Environments" class="headerlink" title="Creating and Running Environments"></a>Creating and Running Environments</h3><p>我们将在 <code>kern/env.c</code> 中编写运行用户环境所需的代码，因为目前还没有文件系统，所以目前临时的一个做法是将一个 ELF 文件以 raw 格式（链接内核时使用 <code>-b binary</code> 选项）嵌入到内核镜像中，这也是为什么我们能在内核符号文件 <code>obj/kern/kernel.sym</code> 中见到一些奇怪符号的缘故，这也是为什么实验一开始笔者反编译内核镜像见到奇怪的符号的缘故</p>
<p><img src="https://s2.loli.net/2022/03/16/w3GDsF2iCI1BVkd.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>在 <code>kern/init.c</code> 中的 <code>i386_init()</code> 中我们可以看到启动用户进程的代码，然而设置用户进程的代码尚未完工，这也是我们接下来需要完成的——Exercise2：</p>
<blockquote>
<p><strong>Exercise 2.</strong> In the file <code>env.c</code>, finish coding the following functions:</p>
<ul>
<li><p><code>env_init()</code></p>
<p>Initialize all of the <code>Env</code> structures in the <code>envs</code> array and add them to the <code>env_free_list</code>. Also calls <code>env_init_percpu</code>, which configures the segmentation hardware with separate segments for privilege level 0 (kernel) and privilege level 3 (user).</p>
</li>
<li><p><code>env_setup_vm()</code></p>
<p>Allocate a page directory for a new environment and initialize the kernel portion of the new environment’s address space.</p>
</li>
<li><p><code>region_alloc()</code></p>
<p>Allocates and maps physical memory for an environment</p>
</li>
<li><p><code>load_icode()</code></p>
<p>You will need to parse an ELF binary image, much like the boot loader already does, and load its contents into the user address space of a new environment.</p>
</li>
<li><p><code>env_create()</code></p>
<p>Allocate an environment with <code>env_alloc</code> and call <code>load_icode</code> to load an ELF binary into it.</p>
</li>
<li><p><code>env_run()</code></p>
<p>Start a given environment running in user mode.</p>
</li>
</ul>
<p>As you write these functions, you might find the new cprintf verb <code>%e</code> useful – it prints a description corresponding to an error code. For example,</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">r</span> = <span class="hljs-literal">-E_NO_MEM</span>;<br>panic(<span class="hljs-string">&quot;env_alloc: %e&quot;</span>, <span class="hljs-built_in">r</span>);<br></code></pre></td></tr></table></figure>

<p>will panic with the message “env_alloc: out of memory”.</p>
</blockquote>
<p>在开始之前，我们先看实验说明提供给我们的一个内核运行链：</p>
<ul>
<li><code>start</code> (<code>kern/entry.S</code>)</li>
<li><code>i386_init</code> (<code>kern/init.c</code>)<ul>
<li><code>cons_init</code></li>
<li><code>mem_init</code></li>
<li><code>env_init</code></li>
<li><code>trap_init</code> (still incomplete at this point)</li>
<li><code>env_create</code></li>
<li><code>env_run</code><ul>
<li><code>env_pop_tf</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>现在开始补全实验代码。</p>
<h4 id="env-init-：初始化-Env-结构体，建立-freelist"><a href="#env-init-：初始化-Env-结构体，建立-freelist" class="headerlink" title="env_init()：初始化 Env 结构体，建立 freelist"></a>env_init()：初始化 Env 结构体，建立 freelist</h4><p>首先看 <code>env_init()</code> 函数的注释，主要是将 envs 数组中所有 Env 结构体链到 <code>env_free_list</code> 上，并确保与数组相同的从前向后的连接顺序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Mark all environments in &#x27;envs&#x27; as free, set their env_ids to 0,</span><br><span class="hljs-comment">// and insert them into the env_free_list.</span><br><span class="hljs-comment">// Make sure the environments are in the free list in the same order</span><br><span class="hljs-comment">// they are in the envs array (i.e., so that the first call to</span><br><span class="hljs-comment">// env_alloc() returns envs[0]).</span><br><span class="hljs-comment">//</span><br></code></pre></td></tr></table></figure>

<p>后向遍历 envs 数组建立单向链表即可</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">env_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>	<span class="hljs-comment">// Set up envs array</span><br>	<span class="hljs-comment">// LAB 3: Your code here.</span><br>	<span class="hljs-type">int</span> i;<br>	<br>	env_free_list = <span class="hljs-literal">NULL</span>;<br>	<span class="hljs-keyword">for</span> (i = NENV - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>	&#123;<br>		envs[i].env_id = <span class="hljs-number">0</span>;<br>		envs[i].env_status = ENV_FREE;<br>		envs[i].env_link = env_free_list;<br>		env_free_list = &amp;envs[i];<br>	&#125;<br><br>	<span class="hljs-comment">// Per-CPU part of the initialization</span><br>	env_init_percpu();<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="env-setup-vm-：分配进程环境资源"><a href="#env-setup-vm-：分配进程环境资源" class="headerlink" title="env_setup_vm()：分配进程环境资源"></a>env_setup_vm()：分配进程环境资源</h4><p>惯例先看注释，主要是让我们分配用户进程所需资源：就目前而言只是分配一个页目录表，并建立对应的内核入口点的映射</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Initialize the kernel virtual memory layout for environment e.</span><br><span class="hljs-comment">// Allocate a page directory, set e-&gt;env_pgdir accordingly,</span><br><span class="hljs-comment">// and initialize the kernel portion of the new environment&#x27;s address space.</span><br><span class="hljs-comment">// Do NOT (yet) map anything into the user portion</span><br><span class="hljs-comment">// of the environment&#x27;s virtual address space.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Returns 0 on success, &lt; 0 on error.  Errors include:</span><br><span class="hljs-comment">//	-E_NO_MEM if page directory or table could not be allocated.</span><br><span class="hljs-comment">//</span><br></code></pre></td></tr></table></figure>

<p>所有的进程共享同一份内核空间（<code>UTOP</code> 往上的虚拟空间），除了<code>UVPT</code>——每个进程各自应当有一份独立的页目录表，因此在该函数中我们需要初始化单个进程的页表对内核空间的映射，参照 <code>inc/memlayout.h</code> 中的布局</p>
<p>在 JOS 中其实是类似于普通 OS 以前的做法：每个进程共享一份完整的内核地址空间的映射，但笔者认为其实我们只需要映射只读的 pages 数组与 envs 数组即可，<strong>内核的其他区域用户是没有任何访问权限的，那其实没必要建立映射</strong>，笔者认为比较理想的一个状态是类似 KPTI 那样的——用户态与内核态各自有一张页表，其中内核态页表完整映射内核空间，用户态页表仅映射内核入口点，同时两张页表都完整映射用户空间</p>
<p>这并非不能实现，但是<strong>这或许需要对 JOS 源码进行相当大的改动，且该函数除了创建用户进程以外还承担了创建内核进程的任务，而后者是需要对内核空间有访问权限的</strong>，且 KPTI 确乎会带来一定的开销（但是可以防止熔断与幽灵漏洞的攻击，可能作为一个安全研究员第一想到的并不是性能而是安全性），因此这里笔者还是选择老老实实地完整拷贝一份内核页表</p>
<blockquote>
<p>这里别忘了 page_alloc() 分配的是 page 结构体的地址，我们还需要手动转为虚拟地址</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span><br><span class="hljs-title function_">env_setup_vm</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Env *e)</span><br>&#123;<br>	<span class="hljs-type">int</span> i;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">p</span> =</span> <span class="hljs-literal">NULL</span>;<br><br>	<span class="hljs-comment">// Allocate a page for the page directory</span><br>	<span class="hljs-keyword">if</span> (!(p = page_alloc(ALLOC_ZERO)))<br>		<span class="hljs-keyword">return</span> -E_NO_MEM;<br><br>	<span class="hljs-comment">// Now, set e-&gt;env_pgdir and initialize the page directory.</span><br>	<span class="hljs-comment">//</span><br>	<span class="hljs-comment">// Hint:</span><br>	<span class="hljs-comment">//    - The VA space of all envs is identical above UTOP</span><br>	<span class="hljs-comment">//	(except at UVPT, which we&#x27;ve set below).</span><br>	<span class="hljs-comment">//	See inc/memlayout.h for permissions and layout.</span><br>	<span class="hljs-comment">//	Can you use kern_pgdir as a template?  Hint: Yes.</span><br>	<span class="hljs-comment">//	(Make sure you got the permissions right in Lab 2.)</span><br>	<span class="hljs-comment">//    - The initial VA below UTOP is empty.</span><br>	<span class="hljs-comment">//    - You do not need to make any more calls to page_alloc.</span><br>	<span class="hljs-comment">//    - Note: In general, pp_ref is not maintained for</span><br>	<span class="hljs-comment">//	physical pages mapped only above UTOP, but env_pgdir</span><br>	<span class="hljs-comment">//	is an exception -- you need to increment env_pgdir&#x27;s</span><br>	<span class="hljs-comment">//	pp_ref for env_free to work correctly.</span><br>	<span class="hljs-comment">//    - The functions in kern/pmap.h are handy.</span><br><br>	<span class="hljs-comment">// LAB 3: Your code here.</span><br>	p-&gt;pp_ref++;<br><br>	<span class="hljs-comment">// copy kernel pgdir</span><br>	<span class="hljs-built_in">memcpy</span>(page2kva(p), kern_pgdir, PGSIZE);<br><br>	e-&gt;env_pgdir = page2kva(p);<br><br>	<span class="hljs-comment">// UVPT maps the env&#x27;s own page table read-only.</span><br>	<span class="hljs-comment">// Permissions: kernel R, user R</span><br>	e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_P | PTE_U;<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>而且仔细想来，KPTI并非是基于安全性的改进，<strong>而是对漏洞不得不做出的妥协</strong>，况且这也就只是做个实验而已，暂时还是不大张旗鼓地改了</p>
</blockquote>
<h4 id="region-alloc-：为进程分配物理页面，建立映射"><a href="#region-alloc-：为进程分配物理页面，建立映射" class="headerlink" title="region_alloc()：为进程分配物理页面，建立映射"></a>region_alloc()：为进程分配物理页面，建立映射</h4><p>主要是为用户进程的 va 起始处 len 长度的虚拟地址空间分配物理页面，别忘了大小按页面粒度对齐以及页表项用户可写权限</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Allocate len bytes of physical memory for environment env,</span><br><span class="hljs-comment">// and map it at virtual address va in the environment&#x27;s address space.</span><br><span class="hljs-comment">// Does not zero or otherwise initialize the mapped pages in any way.</span><br><span class="hljs-comment">// Pages should be writable by user and kernel.</span><br><span class="hljs-comment">// Panic if any allocation attempt fails.</span><br><span class="hljs-comment">//</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">region_alloc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Env *e, <span class="hljs-type">void</span> *va, <span class="hljs-type">size_t</span> len)</span><br>&#123;<br>	<span class="hljs-comment">// LAB 3: Your code here.</span><br>	<span class="hljs-comment">// (But only if you need it for load_icode.)</span><br>	<span class="hljs-comment">//</span><br>	<span class="hljs-comment">// Hint: It is easier to use region_alloc if the caller can pass</span><br>	<span class="hljs-comment">//   &#x27;va&#x27; and &#x27;len&#x27; values that are not page-aligned.</span><br>	<span class="hljs-comment">//   You should round va down, and round (va + len) up.</span><br>	<span class="hljs-comment">//   (Watch out for corner-cases!)</span><br>	<span class="hljs-type">size_t</span> start, end;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">new_p</span>;</span><br><br>	start = ((<span class="hljs-type">size_t</span>)va) &amp; (~PGSIZE);<br>	end = ROUNDUP((<span class="hljs-type">size_t</span>)va + len, PGSIZE);<br><br>	<span class="hljs-keyword">for</span> (; start &lt; end; start += PGSIZE)<br>	&#123;<br>		new_p = page_alloc(<span class="hljs-number">0</span>);<br>		<span class="hljs-keyword">if</span> (!new_p)<br>			panic(<span class="hljs-string">&quot;Out of memory while allocating region for env!&quot;</span>);<br>		new_p-&gt;pp_ref++;<br>		<span class="hljs-keyword">if</span>(page_insert(e-&gt;env_pgdir, new_p, (<span class="hljs-type">void</span>*)start, PTE_U | PTE_W))<br>			panic(<span class="hljs-string">&quot;OOM while inserting page into page table!&quot;</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="load-icode-：解析-ELF-文件，作为新进程载入"><a href="#load-icode-：解析-ELF-文件，作为新进程载入" class="headerlink" title="load_icode()：解析 ELF 文件，作为新进程载入"></a>load_icode()：解析 ELF 文件，作为新进程载入</h4><p>先看注释，让我们手写一个 ELF 解析器，为各个存在于 ELF 中的段分配空间（例如 bss 段在 ELF 中就不占空间）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Set up the initial program binary, stack, and processor flags</span><br><span class="hljs-comment">// for a user process.</span><br><span class="hljs-comment">// This function is ONLY called during kernel initialization,</span><br><span class="hljs-comment">// before running the first user-mode environment.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// This function loads all loadable segments from the ELF binary image</span><br><span class="hljs-comment">// into the environment&#x27;s user memory, starting at the appropriate</span><br><span class="hljs-comment">// virtual addresses indicated in the ELF program header.</span><br><span class="hljs-comment">// At the same time it clears to zero any portions of these segments</span><br><span class="hljs-comment">// that are marked in the program header as being mapped</span><br><span class="hljs-comment">// but not actually present in the ELF file - i.e., the program&#x27;s bss section.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// All this is very similar to what our boot loader does, except the boot</span><br><span class="hljs-comment">// loader also needs to read the code from disk.  Take a look at</span><br><span class="hljs-comment">// boot/main.c to get ideas.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Finally, this function maps one page for the program&#x27;s initial stack.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// load_icode panics if it encounters problems.</span><br><span class="hljs-comment">//  - How might load_icode fail?  What might be wrong with the given input?</span><br><span class="hljs-comment">//</span><br></code></pre></td></tr></table></figure>

<p>主要还是苦力活，解析 ELF header，选出可载入段（<code>ph-&gt;p_type == ELF_PROG_LOAD</code>），分配内存，在页表中建立映射，不过这里提示我们可以抄一抄 <code>boot/main.c</code> 中的解析方法（<del>那👴当然要抄🌶</del>）</p>
<blockquote>
<p> 关于 ELF 格式网上大把资料，不会的可以参见 <a target="_blank" rel="noopener" href="https://arttnba3.cn/2021/06/24/CODE-0X00-A3OS/#%E4%B8%83%E3%80%81%E5%8F%AF%E6%89%A7%E8%A1%8C-ELF-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E6%B5%85%E6%9E%90">https://arttnba3.cn/2021/06/24/CODE-0X00-A3OS/#%E4%B8%83%E3%80%81%E5%8F%AF%E6%89%A7%E8%A1%8C-ELF-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E6%B5%85%E6%9E%90</a></p>
</blockquote>
<p>这里我们需要注意的是，由于我们仅需要在用户空间建立映射，而我们在分配完空间之后还需要将数据拷贝上去，考虑到用户空间页表中也映射了内核空间，<strong>我们可以先切换到用户页表处理数据，完成之后再切换回内核页表</strong>，在 JOS 中提供了一个 <code>lcr3()</code> 让我们能直接更改 cr3 寄存器的值（该寄存器中存放着页目录表的地址）</p>
<p>别忘了将 ELF header 中的 entry （<strong>程序入口点</strong>）给到 Env 结构体中寄存器结构体的 eip</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">load_icode</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Env *e, <span class="hljs-type">uint8_t</span> *binary)</span><br>&#123;<br>	<span class="hljs-comment">// Hints:</span><br>	<span class="hljs-comment">//  Load each program segment into virtual memory</span><br>	<span class="hljs-comment">//  at the address specified in the ELF segment header.</span><br>	<span class="hljs-comment">//  You should only load segments with ph-&gt;p_type == ELF_PROG_LOAD.</span><br>	<span class="hljs-comment">//  Each segment&#x27;s virtual address can be found in ph-&gt;p_va</span><br>	<span class="hljs-comment">//  and its size in memory can be found in ph-&gt;p_memsz.</span><br>	<span class="hljs-comment">//  The ph-&gt;p_filesz bytes from the ELF binary, starting at</span><br>	<span class="hljs-comment">//  &#x27;binary + ph-&gt;p_offset&#x27;, should be copied to virtual address</span><br>	<span class="hljs-comment">//  ph-&gt;p_va.  Any remaining memory bytes should be cleared to zero.</span><br>	<span class="hljs-comment">//  (The ELF header should have ph-&gt;p_filesz &lt;= ph-&gt;p_memsz.)</span><br>	<span class="hljs-comment">//  Use functions from the previous lab to allocate and map pages.</span><br>	<span class="hljs-comment">//</span><br>	<span class="hljs-comment">//  All page protection bits should be user read/write for now.</span><br>	<span class="hljs-comment">//  ELF segments are not necessarily page-aligned, but you can</span><br>	<span class="hljs-comment">//  assume for this function that no two segments will touch</span><br>	<span class="hljs-comment">//  the same virtual page.</span><br>	<span class="hljs-comment">//</span><br>	<span class="hljs-comment">//  You may find a function like region_alloc useful.</span><br>	<span class="hljs-comment">//</span><br>	<span class="hljs-comment">//  Loading the segments is much simpler if you can move data</span><br>	<span class="hljs-comment">//  directly into the virtual addresses stored in the ELF binary.</span><br>	<span class="hljs-comment">//  So which page directory should be in force during</span><br>	<span class="hljs-comment">//  this function?</span><br>	<span class="hljs-comment">//</span><br>	<span class="hljs-comment">//  You must also do something with the program&#x27;s entry point,</span><br>	<span class="hljs-comment">//  to make sure that the environment starts executing there.</span><br>	<span class="hljs-comment">//  What?  (See env_run() and env_pop_tf() below.)</span><br><br>	<span class="hljs-comment">// LAB 3: Your code here.</span><br><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Elf</span> *<span class="hljs-title">elfhdr</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Proghdr</span> *<span class="hljs-title">ph</span>, *<span class="hljs-title">eph</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">ustack</span>;</span><br><br>	<span class="hljs-comment">// check ELF magic</span><br>	elfhdr = (<span class="hljs-keyword">struct</span> Elf*) binary;<br>	<span class="hljs-keyword">if</span> (elfhdr-&gt;e_magic != ELF_MAGIC)<br>		panic(<span class="hljs-string">&quot;Invalid ELF header!&quot;</span>);<br><br>	<span class="hljs-comment">// switch to user pgdir</span><br>	lcr3(PADDR(e-&gt;env_pgdir));<br>	<br>	<span class="hljs-comment">// analyze the header table and copy data</span><br>	ph = (<span class="hljs-keyword">struct</span> Proghdr *) (binary + elfhdr-&gt;e_phoff);<br>	eph = ph + elfhdr-&gt;e_phnum;<br>	<span class="hljs-keyword">for</span> (; ph &lt; eph; ph++)<br>	&#123;<br>		<span class="hljs-keyword">if</span> (ph-&gt;p_type != ELF_PROG_LOAD)<br>			<span class="hljs-keyword">continue</span>;<br>		<br>		region_alloc(e, (<span class="hljs-type">void</span>*)ph-&gt;p_va, ph-&gt;p_memsz);<br>		<span class="hljs-built_in">memset</span>((<span class="hljs-type">void</span>*)(ph-&gt;p_va), <span class="hljs-number">0</span>, ph-&gt;p_memsz);<br>		<span class="hljs-built_in">memcpy</span>((<span class="hljs-type">void</span>*)(ph-&gt;p_va), (<span class="hljs-type">void</span>*)(binary + ph-&gt;p_offset), ph-&gt;p_filesz);<br>	&#125;<br><br>	<span class="hljs-comment">// set the entry point</span><br>	e-&gt;env_tf.tf_eip = elfhdr-&gt;e_entry;<br><br>	<span class="hljs-comment">// Now map one page for the program&#x27;s initial stack</span><br>	<span class="hljs-comment">// at virtual address USTACKTOP - PGSIZE.</span><br><br>	<span class="hljs-comment">// LAB 3: Your code here.</span><br>	region_alloc(e, (<span class="hljs-type">void</span>*)(USTACKTOP - PGSIZE), PGSIZE);<br>	ustack = page_lookup(e-&gt;env_pgdir, (<span class="hljs-type">void</span>*)(USTACKTOP - PGSIZE), <span class="hljs-literal">NULL</span>);<br>	page_insert(kern_pgdir, ustack, (<span class="hljs-type">void</span>*)(USTACKTOP - PGSIZE), PTE_U | PTE_W);<br><br>	<span class="hljs-comment">// recover kernel pgdir</span><br>	lcr3(PADDR(kern_pgdir));<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="env-create-：创建进程环境"><a href="#env-create-：创建进程环境" class="headerlink" title="env_create()：创建进程环境"></a>env_create()：创建进程环境</h4><p>调用 <code>env_alloc()</code> 分配 PCB、调用 <code>load_icode()</code> 解析载入 ELF 即可</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Allocates a new env with env_alloc, loads the named elf</span><br><span class="hljs-comment">// binary into it with load_icode, and sets its env_type.</span><br><span class="hljs-comment">// This function is ONLY called during kernel initialization,</span><br><span class="hljs-comment">// before running the first user-mode environment.</span><br><span class="hljs-comment">// The new env&#x27;s parent ID is set to 0.</span><br><span class="hljs-comment">//</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">env_create</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> *binary, <span class="hljs-keyword">enum</span> EnvType type)</span><br>&#123;<br>	<span class="hljs-comment">// LAB 3: Your code here.</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">new_env</span>;</span><br>	<span class="hljs-keyword">switch</span>(env_alloc(&amp;new_env, <span class="hljs-number">0</span>))<br>	&#123;<br>		<span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:		<span class="hljs-comment">// success</span><br>				<span class="hljs-keyword">break</span>;<br>		<span class="hljs-keyword">case</span> -E_NO_FREE_ENV:<br>				panic(<span class="hljs-string">&quot;No free Env now!&quot;</span>);<br>		<span class="hljs-keyword">case</span> -E_NO_MEM:<br>				panic(<span class="hljs-string">&quot;OOM while alloc the Env!&quot;</span>);<br>		<span class="hljs-keyword">default</span>:<br>				panic(<span class="hljs-string">&quot;unknown fault from env_alloc!&quot;</span>);<br>	&#125;<br>	<br>	new_env-&gt;env_type = type;<br>	load_icode(new_env, binary);<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="env-run-：将进程加入运行队列"><a href="#env-run-：将进程加入运行队列" class="headerlink" title="env_run()：将进程加入运行队列"></a>env_run()：将进程加入运行队列</h4><p>分为三步走：</p>
<ul>
<li>若当前有进程在运行（curenv !&#x3D; NULL)，将其状态设为 <code>ENV_RUNNABLE</code></li>
<li>将 curenv 设为待运行进程的 Env并改变其状态、增加运行次数计数，切换到用户页表</li>
<li>恢复用户进程运行上下文，从内核态切换到用户态</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Context switch from curenv to env e.</span><br><span class="hljs-comment">// Note: if this is the first call to env_run, curenv is NULL.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// This function does not return.</span><br><span class="hljs-comment">//</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">env_run</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Env *e)</span><br>&#123;<br>	<span class="hljs-comment">// Step 1: If this is a context switch (a new environment is running):</span><br>	<span class="hljs-comment">//	   1. Set the current environment (if any) back to</span><br>	<span class="hljs-comment">//	      ENV_RUNNABLE if it is ENV_RUNNING (think about</span><br>	<span class="hljs-comment">//	      what other states it can be in),</span><br>	<span class="hljs-comment">//	   2. Set &#x27;curenv&#x27; to the new environment,</span><br>	<span class="hljs-comment">//	   3. Set its status to ENV_RUNNING,</span><br>	<span class="hljs-comment">//	   4. Update its &#x27;env_runs&#x27; counter,</span><br>	<span class="hljs-comment">//	   5. Use lcr3() to switch to its address space.</span><br>	<span class="hljs-comment">// Step 2: Use env_pop_tf() to restore the environment&#x27;s</span><br>	<span class="hljs-comment">//	   registers and drop into user mode in the</span><br>	<span class="hljs-comment">//	   environment.</span><br><br>	<span class="hljs-comment">// Hint: This function loads the new environment&#x27;s state from</span><br>	<span class="hljs-comment">//	e-&gt;env_tf.  Go back through the code you wrote above</span><br>	<span class="hljs-comment">//	and make sure you have set the relevant parts of</span><br>	<span class="hljs-comment">//	e-&gt;env_tf to sensible values.</span><br><br>	<span class="hljs-comment">// LAB 3: Your code here.</span><br>	<span class="hljs-keyword">if</span> (curenv)<br>	&#123;<br>		<span class="hljs-keyword">switch</span> (curenv-&gt;env_status)<br>		&#123;<br>			<span class="hljs-keyword">case</span> ENV_RUNNING:<br>			<span class="hljs-keyword">case</span> ENV_RUNNABLE:<br>			<span class="hljs-keyword">case</span> ENV_NOT_RUNNABLE:<br>					curenv-&gt;env_status = ENV_RUNNABLE;<br>					<span class="hljs-keyword">break</span>;<br>			<span class="hljs-keyword">case</span> ENV_FREE:<br>					panic(<span class="hljs-string">&quot;running a free Env!&quot;</span>);<br>			<span class="hljs-keyword">case</span> ENV_DYING:<br>					panic(<span class="hljs-string">&quot;running a dying Env!&quot;</span>);<br>			<span class="hljs-keyword">default</span>:<br>					panic(<span class="hljs-string">&quot;The env is crashed!&quot;</span>);<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-comment">// set the curenv</span><br>	curenv = e;<br>	curenv-&gt;env_status = ENV_RUNNING;<br>	curenv-&gt;env_runs++;<br><br>	<span class="hljs-comment">// recover the context of process and ret2usr</span><br>	lcr3(PADDR(curenv-&gt;env_pgdir));<br>	env_pop_tf(&amp;curenv-&gt;env_tf);<br><br>	<span class="hljs-comment">// we never arrive there</span><br>	panic(<span class="hljs-string">&quot;env_run not yet implemented&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>完成这一切后，我们来跑一下这份代码，<strong>你会发现内核成功地运行了程序 hello，并在其尝试调用 0x30号中断时 触发了 triple fault 导致运行暂停</strong></p>
<p><img src="https://s2.loli.net/2022/03/17/5E9QxkMsrFnKoOq.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>那为什么会触发 triple fault 呢？如同 32位 Linux kernel 所做的一般，JOS 也将系统调用实现为一个中断，这便是第一个 fault（需要注意 fault 并非都代表错误，很多机制其实是通过这种“fault”的触发而实现的）；而由于 JOS 尚未设置中断处理程序，因此 CPU 会生成一个 general protection exception，这便是 double fault；然后 CPU 又要处理生成的这个 exception，但是没有对应的处理程序（套娃了），于是就 triple fault 了，但是这并不会无限嵌套下去，在 triple fault 的时候系统就完全无法运行了，通常情况下就重启了，因为我们是 patched qemu 所以会被 qemu 挂起</p>
<h3 id="Handling-Interrupts-and-Exceptions"><a href="#Handling-Interrupts-and-Exceptions" class="headerlink" title="Handling Interrupts and Exceptions"></a>Handling Interrupts and Exceptions</h3><p>因此接下来我们来实现中断处理与异常处理，首先是 Exercise 3，阅读了解中断与异常相关基础知识</p>
<blockquote>
<p><strong>Exercise 3.</strong> Read <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2018/readings/i386/c09.htm">Chapter 9, Exceptions and Interrupts</a> in the <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2018/readings/i386/toc.htm">80386 Programmer’s Manual</a> (or Chapter 5 of the <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2018/readings/ia32/IA32-3A.pdf">IA-32 Developer’s Manual</a>), if you haven’t already.</p>
</blockquote>
<p><strong>中断</strong>（interrupt）与<strong>异常</strong>（exception）是两种特别的改变控制流的方式，其工作原理类似于非编程式的 <code>call</code> 指令——改变正常的程序流程以处理外部事件或报告错误与异常情况</p>
<p>中断与异常的区别在于中断用以处理处理器外的异步事件，而异常则是处理器在运行时检测到异常事件后的处理</p>
<p>中断与异常通常有如下来源：</p>
<ul>
<li>中断：<ul>
<li>可屏蔽中断，通过 INTR 引脚发出</li>
<li>不可屏蔽中断，通过 NMI 引脚发出</li>
</ul>
</li>
<li>异常：<ul>
<li>由处理器检测到的，具体可分为 faults、traps 与 aborts</li>
<li>编程式的，通过指令 into、int 3、int n、bound 可触发异常，通常称之为“软中断”，但处理器将其作为异常来处理</li>
</ul>
</li>
</ul>
<h4 id="Identify-Interrupts"><a href="#Identify-Interrupts" class="headerlink" title="Identify Interrupts"></a>Identify Interrupts</h4><p>处理器将不同的中断与异常进行独立标号，其中 NMI 与异常对应标号 0 ~ 31（并非所有标号都有对应用途，部分标号为未来保留）；可屏蔽中断的标识符由外部中断控制器（例如 Intel 8259A 的可编程中断控制器（Programmable Interrupt Controller））确定，并在处理器的中断确认序列中与处理器通信，8259A 的 PIC 分配的标号可以由软件指定，范围为 32 ~ 255</p>
<p>根据异常报告的方式与是否支持重启指令将其分为三类：</p>
<ul>
<li><p>Faults：在“指令造成异常前”被报告的异常，可以是在指令开始执行时或是执行过程中被检测到，若在执行指令时检测到异常，则会保存当前上下文，完成异常处理后再恢复上下文，<strong>重新从造成异常的指令开始执行</strong></p>
<blockquote>
<p>举个🌰：Linux 中的 page fault 就是这样的一种异常，当读写尚未分配内存页的地址时（比如说 mmap 分配了一个 vma 但是还没分配物理页框）便会触发缺页异常处理程序，分配内存页后再重新从读写的指令开始运行</p>
</blockquote>
</li>
<li><p>Traps：在检测到异常的指令后立即在指令边界报告的异常（<del>别问，👴也没看懂英文原文啥意思</del>）</p>
<blockquote>
<p>举个🌰：系统调用的流程简化后类似于一个陷阱，用户态进程布置好数据后通过指令陷入到内核态，内核完成处理后再返回用户态，执行下一条指令</p>
</blockquote>
</li>
<li><p>Aborts：是一种既不精确定位指令也不重启程序的异常，通常用来报告<strong>严重的错误</strong>（例如硬件错误或非法值）</p>
<blockquote>
<p>例如除以 0 可能就是一种 Abort？</p>
</blockquote>
</li>
</ul>
<p>下表显示了中断与异常对应类型的标识符</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs smali">Table 9-1. Interrupt<span class="hljs-built_in"> and </span>Exception ID Assignments<br><br>Identifier   Description<br><br>0            Divide error<br>1            Debug exceptions<br>2            Nonmaskable interrupt<br>3            Breakpoint (one-byte INT 3 instruction)<br>4            Overflow (INTO instruction)<br>5            Bounds<span class="hljs-built_in"> check </span>(BOUND instruction)<br>6            Invalid opcode<br>7            Coprocessor<span class="hljs-built_in"> not </span>available<br>8            Double fault<br>9            (reserved)<br>10           Invalid TSS<br>11           Segment<span class="hljs-built_in"> not </span>present<br>12           Stack exception<br>13           General protection<br>14           Page fault<br>15           (reserved)<br>16           Coprecessor error<br>17-31        (reserved)<br>32-255       Available for external interrupts via INTR pin<br></code></pre></td></tr></table></figure>

<h4 id="Enabling-and-Disabling-Interrupts"><a href="#Enabling-and-Disabling-Interrupts" class="headerlink" title="Enabling and Disabling Interrupts"></a>Enabling and Disabling Interrupts</h4><p>若多个中断同时发生，我们不应当在处理一个中断时跑去处理另一个中断，因此需要明确什么时候能进行中断处理</p>
<p>对于不可屏蔽中断而言，处理器在执行到 iret 指令之前都会忽略 NMI 引脚上的中断信号</p>
<p>对于可屏蔽中断而言，当 IF 标志位为 0 时中断被关闭，只有在 IF &#x3D;&#x3D; 1时才能进行，与其他标志位一样，在处理器重置时 IF 会被清空，我们可以通过 <code>cli</code> 与 <code>sli</code> 指令清空或设置 IF 标志位，这两个指令只有在 CLI （特权级）&lt;&#x3D; IOPL 时才可用，否则会触发保护异常</p>
<p>IF 标志位还会被这些操作影响：</p>
<ul>
<li><code>pushf</code> 指令将 eflags 寄存器的值推到栈上</li>
<li>在任务切换时会调用 <code>popf</code> 与 <code>iret</code> 指令载入标志位寄存器</li>
<li>在通过中断门时会自动重置 IF 标志位，关闭中断</li>
</ul>
<p>RF 标志位用以控制 debug fault，对于给定指令其最多会被触发一次</p>
<p>对 ss 寄存器的更改（mov 或 pop）也会影响一些中断与异常，例如我们改变堆栈（<code>ss:esp</code>）的过程中（刚好改了 ss 没改 esp）处理了中断或异常，则堆栈指针在中断&#x2F;异常处理的过程中是不一致的，因此 80386 在更改 ss 的指令后的指令边界处禁止 NMI、INTR、debug fault 或单步陷阱，可能会有例外：page fault 或 general protection fault，因此我们需要使用 80386 的 <code>lss</code> 指令</p>
<h4 id="Priority-Among-Simultaneous-Interrupts-and-Exceptions"><a href="#Priority-Among-Simultaneous-Interrupts-and-Exceptions" class="headerlink" title="Priority Among Simultaneous Interrupts and Exceptions"></a>Priority Among Simultaneous Interrupts and Exceptions</h4><p>中断与异常的处理同样有着优先级，处理器会先处理高优先级的异常而丢弃低优先级的异常，当中断处理返回时会发现被丢弃的异常并重新处理；优先级顺序如下：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Table</span> <span class="hljs-number">9</span><span class="hljs-number">-2.</span> Priority Among Simultaneous Interrupts <span class="hljs-keyword">and</span> Exceptions<br><br>Priority   <span class="hljs-keyword">Class</span> <span class="hljs-keyword">of</span> Interrupt <span class="hljs-keyword">or</span> <span class="hljs-keyword">Exception</span><br><br>HIGHEST    Faults <span class="hljs-keyword">except</span> <span class="hljs-keyword">debug</span> faults<br>Trap instructions <span class="hljs-keyword">INTO</span>, <span class="hljs-type">INT</span> n, <span class="hljs-type">INT</span> <span class="hljs-number">3</span><br><span class="hljs-keyword">Debug</span> traps <span class="hljs-keyword">for</span> this instruction<br><span class="hljs-keyword">Debug</span> faults <span class="hljs-keyword">for</span> next instruction<br>NMI interrupt<br>LOWEST     INTR interrupt<br></code></pre></td></tr></table></figure>

<h4 id="Interrupt-Descriptor-Table"><a href="#Interrupt-Descriptor-Table" class="headerlink" title="Interrupt Descriptor Table"></a>Interrupt Descriptor Table</h4><p>类似于段描述符表，中断同样有着对应的<strong>门描述符</strong>（Gate Descriptor）结构与一张<strong>中断描述符表</strong>（Interrupt Descriptor Table），不同于 GDT 与 LDT，IDT 的第一个描述符是可用的，因为中断与异常一共有着 256 个标号，因此一张中断描述符表上最多可以有 256 个中断描述符（也可以少于这个数量）</p>
<p>中断描述符表的地址存放在 IDT 寄存器（IDTR）中，我们可以通过 <code>lidt</code> 指令（通过线性地址装载 IDT，只能在 0 特权级下执行）与 <code>sidt</code> 指令（拷贝当前 IDTR 的值，可以在任何特权级下执行）操作 IDTR</p>
<p>中断描述符表的结构如下：</p>
<p><img src="https://s2.loli.net/2022/03/17/vPQKmeGVhyJ3ADT.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p><img src="https://s2.loli.net/2022/03/17/5WujsrOYPpkMIze.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h4 id="IDT-Descriptor"><a href="#IDT-Descriptor" class="headerlink" title="IDT Descriptor"></a>IDT Descriptor</h4><p>中断描述符表中包含如下三种描述符：</p>
<ul>
<li>任务门（用作任务切换，后面可能会讲到）</li>
<li>中断门</li>
<li>陷阱门</li>
</ul>
<p>描述符的结构如下所示</p>
<p><img src="https://s2.loli.net/2022/03/17/Q3GiDPscdyKmLIT.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h4 id="Interrupt-Procedures"><a href="#Interrupt-Procedures" class="headerlink" title="Interrupt Procedures"></a>Interrupt Procedures</h4><p>如同 call 指令一般，中断与异常其实就是“call”中断处理程序——处理器通过中断或异常标号作为 IDT 的索引找到对应的中断描述符，若是一个中断门或陷阱门则其会以类似“call”调用门的方式调用处理程序，若是一个任务门，则会以类似“call”任务门的方式引起任务切换</p>
<p>中断门与陷阱门并不直接指向处理程序，而是通过下图的方式找到处理程序地址：门的选择子指向一个 GDT&#x2F;LDT 中的可执行段，门的 offset 域指向中断&#x2F;异常处理程序的开头</p>
<p><img src="https://s2.loli.net/2022/03/17/yoAXZpNmQDS3Vvr.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>如同 call 指令引起的控制流转移一般，中断与异常的处理过程同样使用堆栈存储返回原始过程所需的信息，并使用 iret 指令从栈上恢复这些信息，如同下图所示：</p>
<p><img src="https://s2.loli.net/2022/03/17/qWnwvs9NreXpuiD.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>在通过中断门或陷阱门后会将 eflags 存到栈上，并重置 TF （trap flag）标志位，以此防止单步执行的调试过程影响中断响应，完成后 iret 指令会从栈上恢复 eflags，需要注意的是通过中断门后会重置 IF ，但通过陷阱门并不会重置 IF</p>
<p>在中断过程中 CPU 不允许将控制权转移到低于当前特权级的段上，否则会触发 general protection fault，因此我们可以通过任一下列策略防止这种情况的发生：</p>
<ul>
<li>将处理程序放在合适的段中，这样的策略适合一些特殊的异常处理程序（例如 divided by zero），这样的处理程序必须仅使用堆栈中的可用数据，若其需要来自数据段的数据，则需要确保数据段的特权级为 3，从而使其不受访问保护</li>
<li>将处理程序放在特权级 0 的段中</li>
</ul>
<h4 id="Interrupt-Tasks"><a href="#Interrupt-Tasks" class="headerlink" title="Interrupt Tasks"></a>Interrupt Tasks</h4><p>IDT 中的任务门并不直接指向一个任务，如同下图所示，门的选择子指向 GDT 中的一个 TSS 描述符，当中断或异常触发通过任务门时，将会进行任务的切换</p>
<p><img src="https://s2.loli.net/2022/03/17/GZBLwKDji6f7gdC.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>使用一个独立的任务来处理中断有如下优点：</p>
<ul>
<li>会自动保存进程上下文</li>
<li>中断处理程序可以通过一个单独的地址空间与其他任务独立开来，比如通过一个 LDT 或 独立页表</li>
</ul>
<p>任务的切换参见 <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2018/readings/i386/c07.htm">Chapter 7</a>.，需要说明的是中断任务同样通过 iret 指令返回原进程；若是任务切换是由一个带着错误代码的异常引起的，则处理器会自动将错误代码存到处理程序的栈上</p>
<p>在 80386 中使用中断任务时，实际上有两个调度器：软件调度器（OS的一部分）与硬件调度器（处理器中断机制的一部分），软件调度器的设计应该考虑到硬件调度器可以在启用中断时调度中断任务这一事实</p>
<h4 id="Interrupt-Summary"><a href="#Interrupt-Summary" class="headerlink" title="Interrupt Summary"></a>Interrupt Summary</h4><p>下表总结了 386 所识别的异常：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Table</span> <span class="hljs-number">9</span><span class="hljs-number">-6.</span> <span class="hljs-keyword">Exception</span> <span class="hljs-keyword">Summary</span><br><br>Description               Interrupt   <span class="hljs-keyword">Return</span> Address  <span class="hljs-keyword">Exception</span>     <span class="hljs-keyword">Function</span> That Can Generate<br>Number      Points <span class="hljs-keyword">to</span>       <span class="hljs-keyword">Type</span>          the <span class="hljs-keyword">Exception</span><br>Faulting<br>Instruction<br><br>Divide error               <span class="hljs-number">0</span>          YES             FAULT         DIV, IDIV<br><span class="hljs-keyword">Debug</span> exceptions           <span class="hljs-number">1</span><br><span class="hljs-keyword">Some</span> <span class="hljs-keyword">debug</span> exceptions are traps <span class="hljs-keyword">and</span> <span class="hljs-keyword">some</span> are faults.  The <span class="hljs-keyword">exception</span><br><span class="hljs-keyword">handler</span> can determine which has occurred <span class="hljs-keyword">by</span> examining DR6.  (Refer <span class="hljs-keyword">to</span> Chapter <span class="hljs-number">12.</span>)<br><span class="hljs-keyword">Some</span> <span class="hljs-keyword">debug</span> exceptions are traps <span class="hljs-keyword">and</span> <span class="hljs-keyword">some</span> are faults.  The <span class="hljs-keyword">exception</span><br><span class="hljs-keyword">handler</span> can determine which has occurred <span class="hljs-keyword">by</span> examining DR6.  (Refer <span class="hljs-keyword">to</span> Chapter <span class="hljs-number">12.</span>) <span class="hljs-keyword">Any</span> instruction<br>Breakpoint                 <span class="hljs-number">3</span>          <span class="hljs-keyword">NO</span>              TRAP          One-byte <span class="hljs-type">INT</span> <span class="hljs-number">3</span><br>Overflow                   <span class="hljs-number">4</span>          <span class="hljs-keyword">NO</span>              TRAP          <span class="hljs-keyword">INTO</span><br>Bounds <span class="hljs-keyword">check</span>               <span class="hljs-number">5</span>          YES             FAULT         BOUND<br>Invalid opcode             <span class="hljs-number">6</span>          YES             FAULT         <span class="hljs-keyword">Any</span> illegal instruction<br>Coprocessor <span class="hljs-keyword">not</span> available  <span class="hljs-number">7</span>          YES             FAULT         ESC, WAIT<br><span class="hljs-type">Double</span> fault               <span class="hljs-number">8</span>          YES             <span class="hljs-keyword">ABORT</span>         <span class="hljs-keyword">Any</span> instruction that can<br>generate an <span class="hljs-keyword">exception</span><br>Coprocessor Segment<br>Overrun                    <span class="hljs-number">9</span>          <span class="hljs-keyword">NO</span>              <span class="hljs-keyword">ABORT</span>         <span class="hljs-keyword">Any</span> operand <span class="hljs-keyword">of</span> an ESC<br>instruction that wraps around<br>the <span class="hljs-keyword">end</span> <span class="hljs-keyword">of</span> a segment.<br>Invalid TSS               <span class="hljs-number">10</span>          YES             FAULT<br>An invalid-TSS fault <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> restartable <span class="hljs-keyword">if</span> it occurs during the<br>processing <span class="hljs-keyword">of</span> an <span class="hljs-keyword">external</span> interrupt.        JMP, <span class="hljs-keyword">CALL</span>, IRET, <span class="hljs-keyword">any</span> interrupt<br>Segment <span class="hljs-keyword">not</span> present       <span class="hljs-number">11</span>          YES             FAULT         <span class="hljs-keyword">Any</span> segment-register modifier<br>Stack <span class="hljs-keyword">exception</span>           <span class="hljs-number">12</span>          YES             FAULT         <span class="hljs-keyword">Any</span> memory reference thru SS<br>General Protection        <span class="hljs-number">13</span>          YES             FAULT/<span class="hljs-keyword">ABORT</span><br><span class="hljs-keyword">All</span> GP faults are restartable. <span class="hljs-keyword">If</span> the fault occurs <span class="hljs-keyword">while</span> attempting <span class="hljs-keyword">to</span><br>vector <span class="hljs-keyword">to</span> the <span class="hljs-keyword">handler</span> <span class="hljs-keyword">for</span> an <span class="hljs-keyword">external</span> interrupt, the interrupted program <span class="hljs-keyword">is</span><br>restartable, but the interrupt may be lost.  <span class="hljs-keyword">Any</span> memory reference <span class="hljs-keyword">or</span> code<br><span class="hljs-keyword">fetch</span><br>Page fault                <span class="hljs-number">14</span>          YES             FAULT         <span class="hljs-keyword">Any</span> memory reference <span class="hljs-keyword">or</span> code<br><span class="hljs-keyword">fetch</span><br>Coprocessor error         <span class="hljs-number">16</span>          YES             FAULT<br>Coprocessor errors are reported <span class="hljs-keyword">as</span> a fault <span class="hljs-keyword">on</span> the first ESC <span class="hljs-keyword">or</span> WAIT<br>instruction executed <span class="hljs-keyword">after</span> the ESC instruction that caused the error.        ESC, WAIT<br>Two-byte SW Interrupt     <span class="hljs-number">0</span><span class="hljs-number">-255</span>       <span class="hljs-keyword">NO</span>              TRAP          <span class="hljs-type">INT</span> n<br></code></pre></td></tr></table></figure>

<blockquote>
<p>详细说明参见 <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2018/readings/i386/s09_08.htm">https://pdos.csail.mit.edu/6.828/2018/readings/i386/s09_08.htm</a></p>
</blockquote>
<h4 id="Error-Code"><a href="#Error-Code" class="headerlink" title="Error Code"></a>Error Code</h4><p>若异常与一个特定的段相关联，则处理器会将一个错误代码存到异常处理程序的栈上，格式如下图所示</p>
<p><img src="https://s2.loli.net/2022/03/17/zTLnsmHUW2RVYue.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>在错误代码中并不包含特权级字段，取而代之的是两个新的位：</p>
<ul>
<li>EXT bit：程序外部的事件造成了异常</li>
<li>I-bit（IDT-bit）：错误代码的 index 字段引用 IDT 中的门描述符</li>
</ul>
<p>若未设置 I-bit，则 TI 位指示错误代码引用 GDT（0）还是 LDT（1），剩下的 14 位为段选择子的高 14 位</p>
<p>下表总结了异常中的错误代码信息：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Description                       Interrupt     <span class="hljs-built_in">Error</span> Code<br>Number<br><br>Divide <span class="hljs-built_in">error</span>                       0            <span class="hljs-literal">No</span><br><span class="hljs-built_in">Debug</span> exceptions                   1            <span class="hljs-literal">No</span><br>Breakpoint                         3            <span class="hljs-literal">No</span><br>Overflow                           4            <span class="hljs-literal">No</span><br>Bounds check                       5            <span class="hljs-literal">No</span><br>Invalid opcode                     6            <span class="hljs-literal">No</span><br>Coprocessor <span class="hljs-keyword">not</span> available          7            <span class="hljs-literal">No</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">System </span><span class="hljs-built_in">error</span>                       8            <span class="hljs-literal">Yes</span> (always 0)<br>Coprocessor Segment Overrun        9            <span class="hljs-literal">No</span><br>Invalid TSS                       10            <span class="hljs-literal">Yes</span><br>Segment <span class="hljs-keyword">not</span> present               11            <span class="hljs-literal">Yes</span><br>Stack exception                   12            <span class="hljs-literal">Yes</span><br>General protection fault          13            <span class="hljs-literal">Yes</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">Page </span>fault                        14            <span class="hljs-literal">Yes</span><br>Coprocessor <span class="hljs-built_in">error</span>                 16            <span class="hljs-literal">No</span><br>Two-byte SW interrupt             0-255         <span class="hljs-literal">No</span><br></code></pre></td></tr></table></figure>

<h3 id="Basics-of-Protected-Control-Transfer"><a href="#Basics-of-Protected-Control-Transfer" class="headerlink" title="Basics of Protected Control Transfer"></a>Basics of Protected Control Transfer</h3><p>异常与中断都是“被保护的控制流切换”——将处理器切换至内核态（CPL&#x3D;0），且不会给用户态代码影响内核或其他环境的机会</p>
<p>在 Intel 术语中，一个中断通常是由处理器外部的异步事件触发的，例如外设的 I&#x2F;O；而异常则是由当前运行的代码同步触发的事件，例如非法内存访问</p>
<p>为了确保中断与异常“真正受到保护”，其被设计为：触发其的代码只能在特定条件下进入内核的特定位置，通过以下两种机制：</p>
<ul>
<li><strong>中断描述符表</strong>：处理器确保中断与异常只能通过特定的入口点进入内核，这便是中断描述符表中的「门」结构，x86允许多达 256 个不同的入口点——对应 256 个中断描述符表索引，处理器从该表中对应条目加载：<ul>
<li>eip：异常处理程序代码地址</li>
<li>cs：代码段选择子，在其 0 ~ 1 位中包含运行异常处理程序的特权级（在 JOS 中所有异常都在 0 特权级下处理）</li>
</ul>
</li>
<li><strong>任务状态段</strong>：处理器需要一个地方来保存中断发生前的上下文，以便在完成处理后恢复上下文，但这个区域不应当被用户进程访问，中断处理需要陷入内核，于是也需要独立的内核堆栈，因此<strong>任务状态段</strong>（TSS）结构指定了内核堆栈的地址与段选择子，处理器将旧的 ss、esp、eflags、cs、eip、（可选）error code 压到内核栈上，从中断描述符中加载 cs 与 eip，并设置 <code>ss:esp</code> 以引用新的堆栈</li>
</ul>
<p>我们在 JOS 中 TSS 仅用来定义从用户态切换到内核态时应切换到的内核堆栈，不使用其他字段</p>
<h3 id="Types-of-Exceptions-and-Interrupts"><a href="#Types-of-Exceptions-and-Interrupts" class="headerlink" title="Types of Exceptions and Interrupts"></a>Types of Exceptions and Interrupts</h3><p><del>说过了.jpg</del></p>
<p>本节我们将扩展 JOS 的 0 ~31 号异常向量，下一届我们将扩展软中断（0x30）作为 JOS 的系统调用入口点，在 lab4 中我们将扩展 JOS 以让其处理硬件中断（例如时钟中断）</p>
<h3 id="An-Example"><a href="#An-Example" class="headerlink" title="An Example"></a>An Example</h3><p><del>懒得看，反正就那回事</del></p>
<h3 id="Nested-Exceptions-and-Interrupts"><a href="#Nested-Exceptions-and-Interrupts" class="headerlink" title="Nested Exceptions and Interrupts"></a>Nested Exceptions and Interrupts</h3><p>对于内核中的嵌套中断而言不需要重复切换内核堆栈，只需要保存旧的上下文到内核堆栈上即可</p>
<h3 id="Setting-Up-the-IDT"><a href="#Setting-Up-the-IDT" class="headerlink" title="Setting Up the IDT"></a>Setting Up the IDT</h3><p>接下来我们将设置 IDT 的 0~31 号中断向量，随后我们会设置系统调用中断的处理程序，在后面的 lab 中设置 32 ~ 47 号中断（设备中断）</p>
<p>我们应当实现如下所示控制流程：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">      IDT                   trapentry.S         trap.c</span><br><span class="hljs-code">   </span><br><span class="hljs-code">+----------------+</span>                        <br>|   &amp;handler1    |---------&gt; handler1:          trap (struct Trapframe *tf)<br>|                |             // do stuff      &#123;<br>|                |             call trap          // handle the exception/interrupt<br><span class="hljs-section">|                |             // ...           &#125;</span><br><span class="hljs-section">+----------------+</span><br>|   &amp;handler2    |--------&gt; handler2:<br>|                |            // do stuff<br>|                |            call trap<br><span class="hljs-section">|                |            // ...</span><br><span class="hljs-section">+----------------+</span><br><span class="hljs-code">       .</span><br><span class="hljs-code">       .</span><br><span class="hljs-section">       .</span><br><span class="hljs-section">+----------------+</span><br>|   &amp;handlerX    |--------&gt; handlerX:<br>|                |             // do stuff<br>|                |             call trap<br><span class="hljs-section">|                |             // ...</span><br><span class="hljs-section">+----------------+</span><br></code></pre></td></tr></table></figure>

<p>每一个异常或中断都应在 <code>trapentry.S</code> 中有其自己的 handler，而 <code>trap_init()</code> 应当初始化这些 handler，每个 handler 应当在栈上建立一个 <code>struct Trapframe</code>（参见 <code>inc/trap.h</code>）并将其指针作为参数调用 <code>trap()</code>，由其对应调用到相应的处理函数</p>
<p>补充了那么多的基础知识，接下来是 Exercise 4——编辑 <code>trapentry.S</code> 与 <code>trap.c</code> 实现中断与异常处理</p>
<blockquote>
<p><strong>Exercise 4.</strong> Edit <code>trapentry.S</code> and <code>trap.c</code> and implement the features described above. The macros <code>TRAPHANDLER</code> and <code>TRAPHANDLER_NOEC</code> in <code>trapentry.S</code> should help you, as well as the T_* defines in <code>inc/trap.h</code>. You will need to add an entry point in <code>trapentry.S</code> (using those macros) for each trap defined in <code>inc/trap.h</code>, and you’ll have to provide <code>_alltraps</code> which the <code>TRAPHANDLER</code> macros refer to. You will also need to modify <code>trap_init()</code> to initialize the <code>idt</code> to point to each of these entry points defined in <code>trapentry.S</code>; the <code>SETGATE</code> macro will be helpful here.</p>
<p>Your <code>_alltraps</code> should:</p>
<ol>
<li>push values to make the stack look like a struct Trapframe</li>
<li>load <code>GD_KD</code> into <code>%ds</code> and <code>%es</code></li>
<li><code>pushl %esp</code> to pass a pointer to the Trapframe as an argument to trap()</li>
<li><code>call trap</code> (can <code>trap</code> ever return?)</li>
</ol>
<p>Consider using the <code>pushal</code> instruction; it fits nicely with the layout of the <code>struct Trapframe</code>.</p>
<p>Test your trap handling code using some of the test programs in the <code>user</code> directory that cause exceptions before making any system calls, such as <code>user/divzero</code>. You should be able to get make grade to succeed on the <code>divzero</code>, <code>softint</code>, and <code>badsegment</code> tests at this point.</p>
</blockquote>
<p>我们需要在 <code>trapentry.S</code> 中建立中断入口点，这里 JOS 预先为我们提供了两个宏用来声明这些入口点，他们最终都会跳转到 <code>_alltraps</code> 标号处：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c">* TRAPHANDLER defines a globally-visible function <span class="hljs-keyword">for</span> handling a trap.<br> * It pushes a trap number onto the <span class="hljs-built_in">stack</span>, then jumps to _alltraps.<br> * Use TRAPHANDLER <span class="hljs-keyword">for</span> traps where the CPU automatically pushes an error code.<br> *<br> * You shouldn<span class="hljs-number">&#x27;</span>t call a TRAPHANDLER function from C, but you may<br> * need to _declare_ one in <span class="hljs-title function_">C</span> <span class="hljs-params">(<span class="hljs-keyword">for</span> instance, to get a function pointer</span><br><span class="hljs-params"> * during IDT setup)</span>.  You can declare the function with<br> *   <span class="hljs-type">void</span> <span class="hljs-title function_">NAME</span><span class="hljs-params">()</span>;<br> * where NAME is the argument passed to TRAPHANDLER.<br> */<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TRAPHANDLER(name, num)						\</span><br><span class="hljs-meta">	.globl name;		<span class="hljs-comment">/* define global symbol for &#x27;name&#x27; */</span>	\</span><br><span class="hljs-meta">	.type name, @function;	<span class="hljs-comment">/* symbol type is function */</span>		\</span><br><span class="hljs-meta">	.align 2;		<span class="hljs-comment">/* align function definition */</span>		\</span><br><span class="hljs-meta">	name:			<span class="hljs-comment">/* function starts here */</span>		\</span><br><span class="hljs-meta">	pushl $(num);							\</span><br><span class="hljs-meta">	jmp _alltraps</span><br><br><span class="hljs-comment">/* Use TRAPHANDLER_NOEC for traps where the CPU doesn&#x27;t push an error code.</span><br><span class="hljs-comment"> * It pushes a 0 in place of the error code, so the trap frame has the same</span><br><span class="hljs-comment"> * format in either case.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TRAPHANDLER_NOEC(name, num)					\</span><br><span class="hljs-meta">	.globl name;							\</span><br><span class="hljs-meta">	.type name, @function;						\</span><br><span class="hljs-meta">	.align 2;							\</span><br><span class="hljs-meta">	name:								\</span><br><span class="hljs-meta">	pushl $0;							\</span><br><span class="hljs-meta">	pushl $(num);							\</span><br><span class="hljs-meta">	jmp _alltraps</span><br></code></pre></td></tr></table></figure>

<p>我们先参照 <code>inc/trap.h</code> 中提供的 <code>T_*</code> 宏声明对应入口点，对于会有 error code 的中断使用 <code>TRAPHANDLER</code> 宏，否则使用 </p>
<p><code>TRAPHANDLER_NOEC</code> 宏，是否有 error code 参见上面的表格；宏里的 <code>name</code> 字段好像是可以随意声明的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Lab 3: Your code here for generating entry points for the different traps.</span><br><span class="hljs-comment"> */</span><br>	TRAPHANDLER_NOEC(int0, T_DIVIDE)<br>	TRAPHANDLER_NOEC(int1, T_DEBUG)<br>	TRAPHANDLER_NOEC(int2, T_NMI)<br>	TRAPHANDLER_NOEC(int3, T_BRKPT)<br>	TRAPHANDLER_NOEC(int4, T_OFLOW)<br>	TRAPHANDLER_NOEC(int5, T_BOUND)<br>	TRAPHANDLER_NOEC(int6, T_ILLOP)<br>	TRAPHANDLER_NOEC(int7, T_DEVICE)<br>	TRAPHANDLER(int8, T_DBLFLT)<br><br>	TRAPHANDLER(int10, T_TSS)<br>	TRAPHANDLER(int11, T_SEGNP)<br>	TRAPHANDLER(int12, T_STACK)<br>	TRAPHANDLER(int13, T_GPFLT)<br>	TRAPHANDLER(int14, T_PGFLT)<br><br>	TRAPHANDLER_NOEC(int16, T_FPERR)<br>	TRAPHANDLER_NOEC(__syscall, T_SYSCALL)<br></code></pre></td></tr></table></figure>

<p>之后就是实现 <code>_alltraps</code>，按注释我们应当向栈上压入对应数据形成一个 <code>Trapframe</code> 结构体，实际上只需要推入 es、ds、<code>PushRegs</code> 结构体，剩余的都会在我们运行到 <code>_alltraps</code> 前被压入栈上：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PushRegs</span> &#123;</span><br>	<span class="hljs-comment">/* registers as pushed by pusha */</span><br>	<span class="hljs-type">uint32_t</span> reg_edi;<br>	<span class="hljs-type">uint32_t</span> reg_esi;<br>	<span class="hljs-type">uint32_t</span> reg_ebp;<br>	<span class="hljs-type">uint32_t</span> reg_oesp;		<span class="hljs-comment">/* Useless */</span><br>	<span class="hljs-type">uint32_t</span> reg_ebx;<br>	<span class="hljs-type">uint32_t</span> reg_edx;<br>	<span class="hljs-type">uint32_t</span> reg_ecx;<br>	<span class="hljs-type">uint32_t</span> reg_eax;<br>&#125; __attribute__((packed));<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Trapframe</span> &#123;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PushRegs</span> <span class="hljs-title">tf_regs</span>;</span><br>	<span class="hljs-type">uint16_t</span> tf_es;<br>	<span class="hljs-type">uint16_t</span> tf_padding1;<br>	<span class="hljs-type">uint16_t</span> tf_ds;<br>	<span class="hljs-type">uint16_t</span> tf_padding2;<br>	<span class="hljs-type">uint32_t</span> tf_trapno;<br>	<span class="hljs-comment">/* below here defined by x86 hardware */</span><br>	<span class="hljs-type">uint32_t</span> tf_err;<br>	<span class="hljs-type">uintptr_t</span> tf_eip;<br>	<span class="hljs-type">uint16_t</span> tf_cs;<br>	<span class="hljs-type">uint16_t</span> tf_padding3;<br>	<span class="hljs-type">uint32_t</span> tf_eflags;<br>	<span class="hljs-comment">/* below here only when crossing rings, such as from user to kernel */</span><br>	<span class="hljs-type">uintptr_t</span> tf_esp;<br>	<span class="hljs-type">uint16_t</span> tf_ss;<br>	<span class="hljs-type">uint16_t</span> tf_padding4;<br>&#125; __attribute__((packed));<br></code></pre></td></tr></table></figure>

<p>这里的 padding 其实不需要我们手动压入栈上，我们在使用 <code>pushl</code> 指令压入 ds 与 es 时他们会自动扩展为 4 字节；之后我们还需要将 ds 与 es 的值设为 <code>GD_KD</code>，最后压入 esp 后手动调用 <code>trap()</code> 即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Lab 3: Your code here for _alltraps</span><br><span class="hljs-comment"> */</span><br><br>_alltraps:<br>	pushl %ds<br>	pushl %es<br>	pushal<br>	push $GD_KD<br>	popl %ds<br>	push $GD_KD<br>	popl %es<br>	pushl %esp<br>	call trap<br></code></pre></td></tr></table></figure>

<p>最后使用 <code>SETGATE</code> 宏在 <code>trap_init()</code> 中装载中断描述符，其接收的第一个参数是一个 <code>Gatedesc</code> 类型结构体，用来表示一个门描述符：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Gate descriptors for interrupts and traps</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Gatedesc</span> &#123;</span><br>	<span class="hljs-type">unsigned</span> gd_off_15_0 : <span class="hljs-number">16</span>;   <span class="hljs-comment">// low 16 bits of offset in segment</span><br>	<span class="hljs-type">unsigned</span> gd_sel : <span class="hljs-number">16</span>;        <span class="hljs-comment">// segment selector</span><br>	<span class="hljs-type">unsigned</span> gd_args : <span class="hljs-number">5</span>;        <span class="hljs-comment">// # args, 0 for interrupt/trap gates</span><br>	<span class="hljs-type">unsigned</span> gd_rsv1 : <span class="hljs-number">3</span>;        <span class="hljs-comment">// reserved(should be zero I guess)</span><br>	<span class="hljs-type">unsigned</span> gd_type : <span class="hljs-number">4</span>;        <span class="hljs-comment">// type(STS_&#123;TG,IG32,TG32&#125;)</span><br>	<span class="hljs-type">unsigned</span> gd_s : <span class="hljs-number">1</span>;           <span class="hljs-comment">// must be 0 (system)</span><br>	<span class="hljs-type">unsigned</span> gd_dpl : <span class="hljs-number">2</span>;         <span class="hljs-comment">// descriptor(meaning new) privilege level</span><br>	<span class="hljs-type">unsigned</span> gd_p : <span class="hljs-number">1</span>;           <span class="hljs-comment">// Present</span><br>	<span class="hljs-type">unsigned</span> gd_off_31_16 : <span class="hljs-number">16</span>;  <span class="hljs-comment">// high bits of offset in segment</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>这里因为<strong>我们还没有定义任何处理函数所以直接声明新的函数即可</strong>，现在还没有出现陷阱所以都是普通的中断，这里注意系统调用与调试中断的特权级应设为3，因为用户进程需要能够访问其入口点：</p>
<blockquote>
<p>一开始笔者在想，好像还没有函数定义啊，后面看了一眼别人的实验报告，直接声明新的函数，还没有函数体，属实佩服…</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">trap_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>	<span class="hljs-keyword">extern</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Segdesc</span> <span class="hljs-title">gdt</span>[];</span><br><br>	<span class="hljs-comment">// LAB 3: Your code here.</span><br><br>	<span class="hljs-comment">// declaration</span><br>	<span class="hljs-type">void</span> <span class="hljs-title function_">int0</span><span class="hljs-params">()</span>;<br>	<span class="hljs-type">void</span> <span class="hljs-title function_">int1</span><span class="hljs-params">()</span>;<br>	<span class="hljs-type">void</span> <span class="hljs-title function_">int2</span><span class="hljs-params">()</span>;<br>	<span class="hljs-type">void</span> <span class="hljs-title function_">int3</span><span class="hljs-params">()</span>;<br>	<span class="hljs-type">void</span> <span class="hljs-title function_">int4</span><span class="hljs-params">()</span>;<br>	<span class="hljs-type">void</span> <span class="hljs-title function_">int5</span><span class="hljs-params">()</span>;<br>	<span class="hljs-type">void</span> <span class="hljs-title function_">int6</span><span class="hljs-params">()</span>;<br>	<span class="hljs-type">void</span> <span class="hljs-title function_">int7</span><span class="hljs-params">()</span>;<br>	<span class="hljs-type">void</span> <span class="hljs-title function_">int8</span><span class="hljs-params">()</span>;<br><br>	<span class="hljs-type">void</span> <span class="hljs-title function_">int10</span><span class="hljs-params">()</span>;<br>	<span class="hljs-type">void</span> <span class="hljs-title function_">int11</span><span class="hljs-params">()</span>;<br>	<span class="hljs-type">void</span> <span class="hljs-title function_">int12</span><span class="hljs-params">()</span>;<br>	<span class="hljs-type">void</span> <span class="hljs-title function_">int13</span><span class="hljs-params">()</span>;<br>	<span class="hljs-type">void</span> <span class="hljs-title function_">int14</span><span class="hljs-params">()</span>;<br><br>	<span class="hljs-type">void</span> <span class="hljs-title function_">int16</span><span class="hljs-params">()</span>;<br>	<span class="hljs-type">void</span> __syscall()<br>	&#123;<br>		cprintf(<span class="hljs-string">&quot;syscall!\n&quot;</span>);<br>	&#125;<br><br>	<span class="hljs-comment">// set up IDT</span><br>	SETGATE(idt[T_DIVIDE], <span class="hljs-number">0</span>, GD_KT, int0, <span class="hljs-number">0</span>);<br>	SETGATE(idt[T_DEBUG], <span class="hljs-number">0</span>, GD_KT, int1, <span class="hljs-number">0</span>);<br>	SETGATE(idt[T_NMI], <span class="hljs-number">0</span>, GD_KT, int2, <span class="hljs-number">0</span>);<br>	SETGATE(idt[T_BRKPT], <span class="hljs-number">0</span>, GD_KT, int3, <span class="hljs-number">3</span>);<br>	SETGATE(idt[T_OFLOW], <span class="hljs-number">0</span>, GD_KT, int4, <span class="hljs-number">0</span>);<br>	SETGATE(idt[T_BOUND], <span class="hljs-number">0</span>, GD_KT, int5, <span class="hljs-number">0</span>);<br>	SETGATE(idt[T_ILLOP], <span class="hljs-number">0</span>, GD_KT, int6, <span class="hljs-number">0</span>);<br>	SETGATE(idt[T_DEVICE], <span class="hljs-number">0</span>, GD_KT, int7, <span class="hljs-number">0</span>);<br>	SETGATE(idt[T_DBLFLT], <span class="hljs-number">0</span>, GD_KT, int8, <span class="hljs-number">0</span>);<br><br>	SETGATE(idt[T_TSS], <span class="hljs-number">0</span>, GD_KT, int10, <span class="hljs-number">0</span>);<br>	SETGATE(idt[T_SEGNP], <span class="hljs-number">0</span>, GD_KT, int11, <span class="hljs-number">0</span>);<br>	SETGATE(idt[T_STACK], <span class="hljs-number">0</span>, GD_KT, int12, <span class="hljs-number">0</span>);<br>	SETGATE(idt[T_GPFLT], <span class="hljs-number">0</span>, GD_KT, int13, <span class="hljs-number">0</span>);<br>	SETGATE(idt[T_PGFLT], <span class="hljs-number">0</span>, GD_KT, int14, <span class="hljs-number">0</span>);<br><br>	SETGATE(idt[T_FPERR], <span class="hljs-number">0</span>, GD_KT, int16, <span class="hljs-number">0</span>);<br>	SETGATE(idt[T_SYSCALL], <span class="hljs-number">0</span>, GD_KT, __syscall, <span class="hljs-number">3</span>);<br><br>	<span class="hljs-comment">// Per-CPU setup </span><br>	trap_init_percpu();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里笔者将 syscall 定义为一个打印函数，运行效果如下，成功通过中断门完成了系统调用：</p>
<p><img src="https://s2.loli.net/2022/03/17/O9Y6lED152vKHIZ.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>当然，后面 panic 掉了，因为我们的中断处理程序没有完成</p>
<blockquote>
<p>这个时候运行评分程序应当有 30 分</p>
</blockquote>
<p>接下来看一下 Challenge，让我们自动化生成一个 table：</p>
<blockquote>
<p><em>Challenge!</em> You probably have a lot of very similar code right now, between the lists of <code>TRAPHANDLER</code> in <code>trapentry.S</code> and their installations in <code>trap.c</code>. Clean this up. Change the macros in <code>trapentry.S</code> to automatically generate a table for <code>trap.c</code> to use. Note that you can switch between laying down code and data in the assembler by using the directives <code>.text</code> and <code>.data</code>.</p>
</blockquote>
<p><del>不会做，摸了</del></p>
<p>最后是习题 Time：</p>
<blockquote>
<p><strong>Questions</strong></p>
<p>Answer the following questions in your <code>answers-lab3.txt</code>:</p>
<ol>
<li><p>What is the purpose of having an individual handler function for each exception&#x2F;interrupt? (i.e., if all exceptions&#x2F;interrupts were delivered to the same handler, what feature that exists in the current implementation could not be provided?)</p>
<p>笔者只能想到是为了降低代码的耦合性，因为其实并非是不能全部通过同一函数实现中断处理，只不过是把各个中断处理程序塞到中断入口点里罢了</p>
</li>
<li><p>Did you have to do anything to make the <code>user/softint</code> program behave correctly? The grade script expects it to produce a general protection fault (trap 13), but <code>softint</code>‘s code says <code>int $14</code>. <em>Why</em> should this produce interrupt vector 13? What happens if the kernel actually allows <code>softint</code>‘s <code>int $14</code> instruction to invoke the kernel’s page fault handler (which is interrupt vector 14)?</p>
<p>因为 General Protection Fault 属于 0 特权级，用户态无权限触发，因此在访问其向量时会触发 Page Fault</p>
</li>
</ol>
</blockquote>
<p>接下来进入 Part B，继续完善我们的中断处理程序</p>
<h2 id="Part-B-Page-Faults-Breakpoints-Exceptions-and-System-Calls"><a href="#Part-B-Page-Faults-Breakpoints-Exceptions-and-System-Calls" class="headerlink" title="Part B: Page Faults, Breakpoints Exceptions, and System Calls"></a>Part B: Page Faults, Breakpoints Exceptions, and System Calls</h2><p>本节中我们将改进中断处理代码以实现一些需要通过异常处理实现的重要的原语</p>
<h3 id="Handling-Page-Faults"><a href="#Handling-Page-Faults" class="headerlink" title="Handling Page Faults"></a>Handling Page Faults</h3><p>缺页异常是一个十分重要的机制，出于性能的考虑，我们并不需要在一开始就为对应线性地址分配物理页，而可以在访问到他们时触发缺页异常后再分配物理页（例如 mmap 映射区域）</p>
<p>当触发缺页异常时，处理器会将造成缺页异常的线性地址存放在 cr2 寄存器中，JOS 提供了一个缺页异常处理函数 <code>page_fault_handler()</code>，在接下来的 Exercise 5 中我们需要修改 <code>trap_dispatch()</code> 以处理缺页异常</p>
<blockquote>
<p><strong>Exercise 5.</strong> Modify <code>trap_dispatch()</code> to dispatch page fault exceptions to <code>page_fault_handler()</code>. You should now be able to get make grade to succeed on the <code>faultread</code>, <code>faultreadkernel</code>, <code>faultwrite</code>, and <code>faultwritekernel</code> tests. If any of them don’t work, figure out why and fix them. Remember that you can boot JOS into a particular user program using make run-<em>x</em> or make run-<em>x</em>-nox. For instance, make run-hello-nox runs the <em>hello</em> user program.</p>
</blockquote>
<p>笔者直接用一个大的 switch 进行操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">trap_dispatch</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Trapframe *tf)</span><br>&#123;<br>	<span class="hljs-comment">// Handle processor exceptions.</span><br>	<span class="hljs-comment">// LAB 3: Your code here.</span><br>	<span class="hljs-keyword">switch</span>(tf-&gt;tf_trapno)<br>	&#123;<br>		<span class="hljs-keyword">case</span> T_DIVIDE:<br>		<span class="hljs-keyword">case</span> T_DEBUG:<br>		<span class="hljs-keyword">case</span> T_NMI:<br>		<span class="hljs-keyword">case</span> T_BRKPT:<br>		<span class="hljs-keyword">case</span> T_OFLOW:<br>		<span class="hljs-keyword">case</span> T_BOUND:<br>		<span class="hljs-keyword">case</span> T_ILLOP:<br>		<span class="hljs-keyword">case</span> T_DEVICE:<br>		<span class="hljs-keyword">case</span> T_DBLFLT:<br>		<span class="hljs-keyword">case</span> T_TSS:<br>		<span class="hljs-keyword">case</span> T_SEGNP:<br>		<span class="hljs-keyword">case</span> T_STACK:<br>		<span class="hljs-keyword">case</span> T_GPFLT:<br>			<span class="hljs-keyword">break</span>;<br>		<span class="hljs-keyword">case</span> T_PGFLT:<br>			page_fault_handler(tf);<br>			<span class="hljs-keyword">return</span> ;<br>		<span class="hljs-keyword">case</span> T_FPERR:<br>		<span class="hljs-keyword">case</span> T_ALIGN:<br>		<span class="hljs-keyword">case</span> T_MCHK:<br>		<span class="hljs-keyword">case</span> T_SIMDERR:<br>		<span class="hljs-keyword">case</span> T_SYSCALL:<br>			<span class="hljs-keyword">break</span>;<br>	&#125;<br><br>	<span class="hljs-comment">// Unexpected trap: The user process or the kernel has a bug.</span><br>	print_trapframe(tf);<br>	<span class="hljs-keyword">if</span> (tf-&gt;tf_cs == GD_KT)<br>		panic(<span class="hljs-string">&quot;unhandled trap in kernel&quot;</span>);<br>	<span class="hljs-keyword">else</span> &#123;<br>		env_destroy(curenv);<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行评分程序，成功通过缺页异常部分：</p>
<p><img src="https://s2.loli.net/2022/03/17/6CYuBxpQh5njEvP.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h3 id="The-Breakpoint-Exception"><a href="#The-Breakpoint-Exception" class="headerlink" title="The Breakpoint Exception"></a>The Breakpoint Exception</h3><p>断点异常通常被用于调试程序，调试原理是将程序中对应指令替换为 int3 软中断；在 JOS 中我们将其转化为任何用户环境都可以唤醒一个 JOS kernel monitor 的一个“伪系统调用”</p>
<p>接下来是 Exercise 6，补完 <code>trap_dispatch()</code> 使得断点异常能唤起一个 kernel monitor</p>
<blockquote>
<p><strong>Exercise 6.</strong> Modify <code>trap_dispatch()</code> to make breakpoint exceptions invoke the kernel monitor. You should now be able to get make grade to succeed on the <code>breakpoint</code> test.</p>
</blockquote>
<p>简单修改一下之前的大 switch 即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">case</span> T_BRKPT:<br>	monitor(tf);<br>	<span class="hljs-keyword">return</span> ;<br></code></pre></td></tr></table></figure>

<p>此时应该能通过 grade 中的断点评分</p>
<p><img src="https://s2.loli.net/2022/03/17/sJYUfEvIPtBrdFo.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>接下来又是 Challenge，完成单步调试器：</p>
<blockquote>
<p><em>Challenge!</em> Modify the JOS kernel monitor so that you can ‘continue’ execution from the current location (e.g., after the <code>int3</code>, if the kernel monitor was invoked via the breakpoint exception), and so that you can single-step one instruction at a time. You will need to understand certain bits of the <code>EFLAGS</code> register in order to implement single-stepping.</p>
<p><em>Optional:</em> If you’re feeling really adventurous, find some x86 disassembler source code - e.g., by ripping it out of QEMU, or out of GNU binutils, or just write it yourself - and extend the JOS kernel monitor to be able to disassemble and display instructions as you are stepping through them. Combined with the symbol table loading from lab 1, this is the stuff of which real kernel debuggers are made.</p>
</blockquote>
<p><del>闲出屁来才有时间去做这玩意，👴忙着呢</del></p>
<p>之后是习题 Time：</p>
<blockquote>
<p><strong>Questions</strong></p>
<ol>
<li><p>The break point test case will either generate a break point exception or a general protection fault depending on how you initialized the break point entry in the IDT (i.e., your call to <code>SETGATE</code> from <code>trap_init</code>). Why? How do you need to set it up in order to get the breakpoint exception to work as specified above and what incorrect setup would cause it to trigger a general protection fault?</p>
<p>这取决于 IDT 中门描述符的特权级，若特权级为 0 ，用户进程没有权限访问对应页面，自然会触发缺页异常；若特权级为3，则自然能正常通过门描述符触发断点异常。</p>
</li>
<li><p>What do you think is the point of these mechanisms, particularly in light of what the <code>user/softint</code> test program does?</p>
<p>目的是不允许用户随意通过门描述符进入不该进入的处理程序中</p>
</li>
</ol>
</blockquote>
<h3 id="System-calls"><a href="#System-calls" class="headerlink" title="System calls"></a>System calls</h3><p>用户进程通过系统调用向内核请求资源，当用户进程进行系统调用时，处理器进入内核态，保存用户进程上下文，之后内核执行对应的系统调用代码，最后恢复回用户进程</p>
<p>在 JOS 中我们使用 <code>int 0x30</code> 来实现系统调用，进程通过对应的寄存器传递系统调用号（eax）与参数（edx，ecx，ebx，edi，esi），返回值存放在 rax 寄存器中</p>
<p>接下来是 Exercise 7，补完 JOS 的系统调用机制</p>
<blockquote>
<p><strong>Exercise 7.</strong> Add a handler in the kernel for interrupt vector <code>T_SYSCALL</code>. You will have to edit <code>kern/trapentry.S</code> and <code>kern/trap.c</code>‘s <code>trap_init()</code>. You also need to change <code>trap_dispatch()</code> to handle the system call interrupt by calling <code>syscall()</code> (defined in <code>kern/syscall.c</code>) with the appropriate arguments, and then arranging for the return value to be passed back to the user process in <code>%eax</code>. Finally, you need to implement <code>syscall()</code> in <code>kern/syscall.c</code>. Make sure <code>syscall()</code> returns <code>-E_INVAL</code> if the system call number is invalid. You should read and understand <code>lib/syscall.c</code> (especially the inline assembly routine) in order to confirm your understanding of the system call interface. Handle all the system calls listed in <code>inc/syscall.h</code> by invoking the corresponding kernel function for each call.</p>
<p>Run the <code>user/hello</code> program under your kernel (make run-hello). It should print “<code>hello, world</code>“ on the console and then cause a page fault in user mode. If this does not happen, it probably means your system call handler isn’t quite right. You should also now be able to get make grade to succeed on the <code>testbss</code> test.</p>
</blockquote>
<p>首先是在大 switch 里调用 JOS 的 syscall 接口，这里<strong>别忘了显式地将返回值给到 eax</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">case</span> T_SYSCALL:<br>	tf-&gt;tf_regs.reg_eax = syscall(tf-&gt;tf_regs.reg_eax, <br>		tf-&gt;tf_regs.reg_edx, tf-&gt;tf_regs.reg_ecx, <br>		tf-&gt;tf_regs.reg_ebx, tf-&gt;tf_regs.reg_edi, <br>		tf-&gt;tf_regs.reg_esi);<br>	<span class="hljs-keyword">return</span>;<br></code></pre></td></tr></table></figure>

<p>之后修改 <code>kern/syscall.c</code> 中的 <code>syscall()</code> 函数，笔者本想选择声明一个系统调用表，在进行调用时直接查表调用即可，但是 JOS 已经写了一个 switch 在这里，那就一切从简吧（笑）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Dispatches to the correct kernel function, passing the arguments.</span><br><span class="hljs-type">int32_t</span><br><span class="hljs-title function_">syscall</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> syscallno, <span class="hljs-type">uint32_t</span> a1, <span class="hljs-type">uint32_t</span> a2, <span class="hljs-type">uint32_t</span> a3, <span class="hljs-type">uint32_t</span> a4, <span class="hljs-type">uint32_t</span> a5)</span><br>&#123;<br>	<span class="hljs-comment">// Call the function corresponding to the &#x27;syscallno&#x27; parameter.</span><br>	<span class="hljs-comment">// Return any appropriate return value.</span><br>	<span class="hljs-comment">// LAB 3: Your code here.</span><br><br>	<span class="hljs-comment">// panic(&quot;syscall not implemented&quot;);</span><br><br>	<span class="hljs-keyword">switch</span> (syscallno) &#123;<br>		<span class="hljs-keyword">case</span> SYS_cputs:<br>			sys_cputs((<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)a1, a2);<br>			<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">case</span> SYS_cgetc:<br>			<span class="hljs-keyword">return</span> sys_cgetc();<br>		<span class="hljs-keyword">case</span> SYS_getenvid:<br>			<span class="hljs-keyword">return</span> sys_getenvid();<br>		<span class="hljs-keyword">case</span> SYS_env_destroy:<br>			<span class="hljs-keyword">return</span> sys_env_destroy(a1);<br>		<span class="hljs-keyword">default</span>:<br>			<span class="hljs-keyword">return</span> -E_INVAL;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>完成之后应当能通过 grade 里的 testbss：</p>
<p><img src="https://s2.loli.net/2022/03/17/qseB1tyViWIrdDG.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>之后是 Challenge，修改代码使用 sysenter 与 sysexit 实现系统调用机制</p>
<blockquote>
<p><em>hallenge!</em> Implement system calls using the <code>sysenter</code> and <code>sysexit</code> instructions instead of using <code>int 0x30</code> and <code>iret</code>.</p>
<p>The <code>sysenter/sysexit</code> instructions were designed by Intel to be faster than <code>int/iret</code>. They do this by using registers instead of the stack and by making assumptions about how the segmentation registers are used. The exact details of these instructions can be found in Volume 2B of the Intel reference manuals.</p>
<p>The easiest way to add support for these instructions in JOS is to add a <code>sysenter_handler</code> in <code>kern/trapentry.S</code> that saves enough information about the user environment to return to it, sets up the kernel environment, pushes the arguments to <code>syscall()</code> and calls <code>syscall()</code> directly. Once <code>syscall()</code> returns, set everything up for and execute the <code>sysexit</code> instruction. You will also need to add code to <code>kern/init.c</code> to set up the necessary model specific registers (MSRs). Section 6.1.2 in Volume 2 of the AMD Architecture Programmer’s Manual and the reference on SYSENTER in Volume 2B of the Intel reference manuals give good descriptions of the relevant MSRs. You can find an implementation of <code>wrmsr</code> to add to <code>inc/x86.h</code> for writing to these MSRs <a target="_blank" rel="noopener" href="http://ftp.kh.edu.tw/Linux/SuSE/people/garloff/linux/k6mod.c">here</a>.</p>
<p>Finally, <code>lib/syscall.c</code> must be changed to support making a system call with <code>sysenter</code>. Here is a possible register layout for the <code>sysenter</code> instruction:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-built_in">eax</span>                - <span class="hljs-keyword">syscall</span> number<br><span class="hljs-built_in">edx</span>, <span class="hljs-built_in">ecx</span>, <span class="hljs-built_in">ebx</span>, <span class="hljs-built_in">edi</span> - arg1, arg2, arg3, arg4<br><span class="hljs-built_in">esi</span>                - return pc<br><span class="hljs-built_in">ebp</span>                - return <span class="hljs-built_in">esp</span><br><span class="hljs-built_in">esp</span>                - trashed by <span class="hljs-keyword">sysenter</span><br><br></code></pre></td></tr></table></figure>

<p>GCC’s inline assembler will automatically save registers that you tell it to load values directly into. Don’t forget to either save (push) and restore (pop) other registers that you clobber, or tell the inline assembler that you’re clobbering them. The inline assembler doesn’t support saving <code>%ebp</code>, so you will need to add code to save and restore it yourself. The return address can be put into <code>%esi</code> by using an instruction like <code>leal after_sysenter_label, %%esi</code>.</p>
<p>Note that this only supports 4 arguments, so you will need to leave the old method of doing system calls around to support 5 argument system calls. Furthermore, because this fast path doesn’t update the current environment’s trap frame, it won’t be suitable for some of the system calls we add in later labs.</p>
<p>You may have to revisit your code once we enable asynchronous interrupts in the next lab. Specifically, you’ll need to enable interrupts when returning to the user process, which <code>sysexit</code> doesn’t do for you.</p>
</blockquote>
<p><del>没那闲工夫，👴选择摸了</del></p>
<h3 id="User-mode-startup"><a href="#User-mode-startup" class="headerlink" title="User-mode startup"></a>User-mode startup</h3><p>用户进程的入口点在 <code>lib/entry.S</code>，其在初始化后会调用 <code>libmain()</code>，接下来我们要修改该函数：将全局变量 <code>thisenv</code> 指向当前进程的 Env 结构体</p>
<p><code>libmain()</code> 之后会调用 <code>umain()</code>，定义于 <code>user/hello.c</code> 中，在打印 hello world 之后其会尝试访问 <code>thisenv-&gt;env_id</code>，在之前的实验中这会触发异常，接下来我们应当初始化 <code>thisenv</code> 以让他不触发异常</p>
<p>于是我们来到了 Exercise 8，<strong>进入到用户态的世界</strong>（其实系统调用那里已经在用户态与内核态“来去之间”了）</p>
<blockquote>
<p><strong>Exercise 8.</strong> Add the required code to the user library, then boot your kernel. You should see <code>user/hello</code> print “<code>hello, world</code>“ and then print “<code>i am environment 00001000</code>“. <code>user/hello</code> then attempts to “exit” by calling <code>sys_env_destroy()</code> (see <code>lib/libmain.c</code> and <code>lib/exit.c</code>). Since the kernel currently only supports one user environment, it should report that it has destroyed the only environment and then drop into the kernel monitor. You should be able to get make grade to succeed on the <code>hello</code> test.</p>
</blockquote>
<p>获取到进程 id 后遍历 envs 数组即可</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">libmain</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br>	<span class="hljs-comment">// set thisenv to point at our Env structure in envs[].</span><br>	<span class="hljs-comment">// LAB 3: Your code here.</span><br>	<span class="hljs-type">int</span> env_id;<br>	<span class="hljs-type">size_t</span> i;<br><br>	env_id = sys_getenvid();<br>	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; NENV; i++)<br>	&#123;<br>		<span class="hljs-keyword">if</span> (envs[i].env_id == env_id)<br>		&#123;<br>			thisenv = &amp;envs[i];<br>			<span class="hljs-keyword">break</span>;<br>		&#125;<br>	&#125;<br>	<span class="hljs-comment">// thisenv = 0;</span><br><br>	<span class="hljs-comment">// save the name of the program so that panic() can use it</span><br>	<span class="hljs-keyword">if</span> (argc &gt; <span class="hljs-number">0</span>)<br>		binaryname = argv[<span class="hljs-number">0</span>];<br><br>	<span class="hljs-comment">// call user main routine</span><br>	umain(argc, argv);<br><br>	<span class="hljs-comment">// exit gracefully</span><br>	<span class="hljs-built_in">exit</span>();<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>这时运行评分程序应当能通过 hello：</p>
<p><img src="https://s2.loli.net/2022/03/17/nUNeugYvxTH7p5b.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h3 id="Page-faults-and-memory-protection"><a href="#Page-faults-and-memory-protection" class="headerlink" title="Page faults and memory protection"></a>Page faults and memory protection</h3><p>OS 通常依赖于硬件以保护内存，当一个程序尝试访问非法地址或无权限地址时处理器会停止进程运行，并带着造成异常的指令信息陷入内核，若该异常可以被修复则内核将其修复后再让程序继续运行，否则会终止程序运行</p>
<p>一个可以被修复的异常的范例便是栈的增长，在初始时我们仅为用户进程栈分配了一张页，当栈突破一张页的大小时便会触发缺页异常，此时内核应当自动分配一个新的内存页到该处，并让程序继续运行</p>
<p>系统调用同样可以在内存保护上造成问题：大部分的系统调用接口都会让用户程序向内核传递一个指针，而内核需要解引用这些指针，这便会有两个问题“</p>
<ul>
<li>内核空间中的缺页异常比用户空间中的缺页异常要严重得多，若内核在操纵自己的数据结构时出现缺页异常，那就是 kernel bug，应当引起 kernel panic，但若这些指针来自于用户进程，则应当要标识出这缺页异常是代表用户进程的</li>
<li>内核有着高于用户进程的权限，因此用户程序可能会传递一个指向用户不可读写但是内核可读写的区域，这也是内核需要注意的</li>
</ul>
<p>因此接下来我们要实现一个地址检查的功能，内核需要用其来检查用户程序传入的指针是否指向用户空间，以及页表是否允许相关操作</p>
<p>以此，内核永远不会因为解引用用户提供的指针而造成缺页异常，若内核发生了缺页异常，则应当 panic——这就是接下来的 Exercise 9，修改 <code>kern/trap.c</code> 让内核态下发生的缺页异常造成 kernel panic</p>
<blockquote>
<p><strong>Exercise 9.</strong> Change <code>kern/trap.c</code> to panic if a page fault happens in kernel mode.</p>
<p>Hint: to determine whether a fault happened in user mode or in kernel mode, check the low bits of the <code>tf_cs</code>.</p>
<p>Read <code>user_mem_assert</code> in <code>kern/pmap.c</code> and implement <code>user_mem_check</code> in that same file.</p>
<p>Change <code>kern/syscall.c</code> to sanity check arguments to system calls.</p>
<p>Boot your kernel, running <code>user/buggyhello</code>. The environment should be destroyed, and the kernel should <em>not</em> panic. You should see:</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">[<span class="hljs-number">00001000</span>] user_mem_check <span class="hljs-keyword">assertion</span> failure <span class="hljs-keyword">for</span> va <span class="hljs-number">00000001</span><br>[<span class="hljs-number">00001000</span>] free env <span class="hljs-number">00001000</span><br>Destroyed the <span class="hljs-keyword">only</span> environment - <span class="hljs-keyword">nothing</span> more <span class="hljs-keyword">to</span> <span class="hljs-keyword">do</span>!<br><br></code></pre></td></tr></table></figure>

<p>Finally, change <code>debuginfo_eip</code> in <code>kern/kdebug.c</code> to call <code>user_mem_check</code> on <code>usd</code>, <code>stabs</code>, and <code>stabstr</code>. If you now run <code>user/breakpoint</code>, you should be able to run backtrace from the kernel monitor and see the backtrace traverse into <code>lib/libmain.c</code> before the kernel panics with a page fault. What causes this page fault? You don’t need to fix it, but you should understand why it happens.</p>
</blockquote>
<p>首先是修改缺页异常处理程序，若我们需要确定一个缺页异常发生在用户态还是内核态，只需要检查 Trapframe 中 cs 段寄存器的 RPL 位即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">page_fault_handler</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Trapframe *tf)</span><br>&#123;<br>	<span class="hljs-type">uint32_t</span> fault_va;<br><br>	<span class="hljs-comment">// Read processor&#x27;s CR2 register to find the faulting address</span><br>	fault_va = rcr2();<br><br>	<span class="hljs-comment">// Handle kernel-mode page faults.</span><br><br>	<span class="hljs-comment">// LAB 3: Your code here.</span><br><br>	<span class="hljs-comment">// check whether it happened in kernel mode or not</span><br>	<span class="hljs-keyword">if</span> (!(tf-&gt;tf_cs &amp; <span class="hljs-number">0b11</span>))<br>		panic(<span class="hljs-string">&quot;kernel page fault!&quot;</span>);<br><br>	<span class="hljs-comment">// We&#x27;ve already handled kernel-mode exceptions, so if we get here,</span><br>	<span class="hljs-comment">// the page fault happened in user mode.</span><br><br>	<span class="hljs-comment">// Destroy the environment that caused the fault.</span><br>	cprintf(<span class="hljs-string">&quot;[%08x] user fault va %08x ip %08x\n&quot;</span>,<br>		curenv-&gt;env_id, fault_va, tf-&gt;tf_eip);<br>	print_trapframe(tf);<br>	env_destroy(curenv);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="user-mem-check-：检查用户地址合法性"><a href="#user-mem-check-：检查用户地址合法性" class="headerlink" title="user_mem_check()：检查用户地址合法性"></a>user_mem_check()：检查用户地址合法性</h4><p>最后是修改 <code>user_mem_check()</code>，主要是以下两点：</p>
<ul>
<li>检查地址是否落在用户空间</li>
<li>检查页表项，用户是否有相应权限</li>
</ul>
<p>这里需要注意的是可能发生的整型溢出导致的地址回绕：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Check that an environment is allowed to access the range of memory</span><br><span class="hljs-comment">// [va, va+len) with permissions &#x27;perm | PTE_P&#x27;.</span><br><span class="hljs-comment">// Normally &#x27;perm&#x27; will contain PTE_U at least, but this is not required.</span><br><span class="hljs-comment">// &#x27;va&#x27; and &#x27;len&#x27; need not be page-aligned; you must test every page that</span><br><span class="hljs-comment">// contains any of that range.  You will test either &#x27;len/PGSIZE&#x27;,</span><br><span class="hljs-comment">// &#x27;len/PGSIZE + 1&#x27;, or &#x27;len/PGSIZE + 2&#x27; pages.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// A user program can access a virtual address if (1) the address is below</span><br><span class="hljs-comment">// ULIM, and (2) the page table gives it permission.  These are exactly</span><br><span class="hljs-comment">// the tests you should implement here.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// If there is an error, set the &#x27;user_mem_check_addr&#x27; variable to the first</span><br><span class="hljs-comment">// erroneous virtual address.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Returns 0 if the user program can access this range of addresses,</span><br><span class="hljs-comment">// and -E_FAULT otherwise.</span><br><span class="hljs-comment">//</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">user_mem_check</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Env *env, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *va, <span class="hljs-type">size_t</span> len, <span class="hljs-type">int</span> perm)</span><br>&#123;<br>	<span class="hljs-comment">// LAB 3: Your code here.</span><br><br>	<span class="hljs-type">uint32_t</span> start, end;<br>	<span class="hljs-type">pte_t</span> *pte;<br><br>	start = ((<span class="hljs-type">uint32_t</span>) va) &amp; (~(PGSIZE - <span class="hljs-number">1</span>));<br>	end = ROUNDUP(((<span class="hljs-type">uint32_t</span>) va) + len, PGSIZE);<br><br>	<span class="hljs-keyword">for</span> (; start &lt; end; start += PGSIZE)<br>	&#123;<br>		pte = pgdir_walk(env-&gt;env_pgdir, (<span class="hljs-type">void</span>*)start, <span class="hljs-number">0</span>);<br>		<span class="hljs-keyword">if</span> ((!pte) || (start &gt;= ULIM) || !(*pte &amp; PTE_P) || ((*pte &amp; perm) != perm))<br>		&#123;<br>			user_mem_check_addr =  (start &lt; (<span class="hljs-type">uint32_t</span>)va ? (<span class="hljs-type">uint32_t</span>)va : start);<br>			<span class="hljs-keyword">return</span> -E_FAULT;<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最后是修改 <code>debuginfo_eip()</code>，在 <code>usd</code>, <code>stabs</code>, <code>stabstr</code> 这三个地方加上 <code>user_mem_check()</code> 进行地址合法性检查</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//...</span><br><br>	<span class="hljs-comment">// Make sure this memory is valid.</span><br>	<span class="hljs-comment">// Return -1 if it is not.  Hint: Call user_mem_check.</span><br>	<span class="hljs-comment">// LAB 3: Your code here.</span><br>	<span class="hljs-keyword">if</span> (user_mem_check(curenv, (<span class="hljs-type">void</span>*)usd, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> UserStabData), PTE_U))<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>	stabs = usd-&gt;stabs;<br>	stab_end = usd-&gt;stab_end;<br>	stabstr = usd-&gt;stabstr;<br>	stabstr_end = usd-&gt;stabstr_end;<br><br>	<span class="hljs-comment">// Make sure the STABS and string table memory is valid.</span><br>	<span class="hljs-comment">// LAB 3: Your code here.</span><br>	<span class="hljs-keyword">if</span> (user_mem_check(curenv, (<span class="hljs-type">void</span>*)stabs, stab_end - stabs, PTE_U))<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>	<br>	<span class="hljs-keyword">if</span> (user_mem_check(curenv, (<span class="hljs-type">void</span>*)stabstr, stabstr_end - stabstr, PTE_U))<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure>

<p>最后是 Exercise 10，防止 evilhello 导致 kernel panic</p>
<blockquote>
<p><strong>Exercise 10.</strong> Boot your kernel, running <code>user/evilhello</code>. The environment should be destroyed, and the kernel should not panic. You should see:</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dns">[<span class="hljs-number">00000000</span>] new env <span class="hljs-number">00001000</span><br>...<br>[<span class="hljs-number">00001000</span>] user_mem_check assertion failure for va f010000c<br>[<span class="hljs-number">00001000</span>] free env <span class="hljs-number">00001000</span><br></code></pre></td></tr></table></figure>
</blockquote>
<p>我们先看 <code>user/evilhello.c</code> ，里面为系统调用 <code>sys_cputs()</code> 传递了一个内核空间中的地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// evil hello world -- kernel pointer passed to kernel</span><br><span class="hljs-comment">// kernel should destroy user environment in response</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;inc/lib.h&gt;</span></span><br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">umain</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br>	<span class="hljs-comment">// try to print the kernel entry point as a string!  mua ha ha!</span><br>	sys_cputs((<span class="hljs-type">char</span>*)<span class="hljs-number">0xf010000c</span>, <span class="hljs-number">100</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>因此我们只需要在对应系统调用加上地址合法性检查即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Print a string to the system console.</span><br><span class="hljs-comment">// The string is exactly &#x27;len&#x27; characters long.</span><br><span class="hljs-comment">// Destroys the environment on memory errors.</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">sys_cputs</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s, <span class="hljs-type">size_t</span> len)</span><br>&#123;<br>	<span class="hljs-comment">// Check that the user has permission to read memory [s, s+len).</span><br>	<span class="hljs-comment">// Destroy the environment if not.</span><br><br>	<span class="hljs-comment">// LAB 3: Your code here.</span><br>	user_mem_assert(curenv, s, len, <span class="hljs-number">0</span>);<br><br>	<span class="hljs-comment">// Print the string supplied by the user.</span><br>	cprintf(<span class="hljs-string">&quot;%.*s&quot;</span>, len, s);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行评分程序，我们成功通过了所有测试，拿到满分</p>
<p><img src="https://s2.loli.net/2022/03/17/Xo6q4wWvFJptYzl.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>至此， lab3 全部完成</p>
<h1 id="0x04-Lab-4-Preemptive-Multitasking"><a href="#0x04-Lab-4-Preemptive-Multitasking" class="headerlink" title="0x04. Lab 4: Preemptive Multitasking"></a>0x04. Lab 4: Preemptive Multitasking</h1><p>在 lab4 中我们将实现抢占式多任务调度</p>
<p>首先还是先 commit lab3 的代码，把 lab4 分支拉下来：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git add .</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git commit -m <span class="hljs-string">&quot;lab3&quot;</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git checkout -b lab4 origin/lab4</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git merge lab3</span><br></code></pre></td></tr></table></figure>

<p>在 lab4 当中新增了如下文件：</p>
<table>
<thead>
<tr>
<th><code>kern/cpu.h</code></th>
<th>Kernel-private definitions for multiprocessor support</th>
</tr>
</thead>
<tbody><tr>
<td><code>kern/mpconfig.c</code></td>
<td>Code to read the multiprocessor configuration</td>
</tr>
<tr>
<td><code>kern/lapic.c</code></td>
<td>Kernel code driving the local APIC unit in each processor</td>
</tr>
<tr>
<td><code>kern/mpentry.S</code></td>
<td>Assembly-language entry code for non-boot CPUs</td>
</tr>
<tr>
<td><code>kern/spinlock.h</code></td>
<td>Kernel-private definitions for spin locks, including the big kernel lock</td>
</tr>
<tr>
<td><code>kern/spinlock.c</code></td>
<td>Kernel code implementing spin locks</td>
</tr>
<tr>
<td><code>kern/sched.c</code></td>
<td>Code skeleton of the scheduler that you are about to implement</td>
</tr>
</tbody></table>
<h2 id="Part-A-Multiprocessor-Support-and-Cooperative-Multitasking"><a href="#Part-A-Multiprocessor-Support-and-Cooperative-Multitasking" class="headerlink" title="Part A: Multiprocessor Support and Cooperative Multitasking"></a>Part A: Multiprocessor Support and Cooperative Multitasking</h2><p>在本 lab 的第一部分，我们将扩展 JOS 以让其能运行在一个多处理器系统上，并实现一些系统调用以允许用户级的进程创建新的进程；我们同时还将实现 <em>协作式的</em> 轮询调度（round-robin scheduling），允许内核在当前进程自愿放弃CPU 时进行进程调度；在 Part C 中我们还将实现 <em>抢占式</em> 的调度，其允许内核在一段时间后重新获取 CPU 的控制权</p>
<h3 id="Multiprocessor-Support"><a href="#Multiprocessor-Support" class="headerlink" title="Multiprocessor Support"></a>Multiprocessor Support</h3><p>我们将让 JOS 支持”对称式多处理“（symmetric multiprocessing）——一种所有 CPU 都有对系统资源同等的权限的多处理器模型。在引导过程中，SMP 中的 CPU 可以分为两种：由一个引导处理器（bootstrap processor，BSP）负责系统的初始化与启动工作，剩余的应用处理器（application processors，APs）则在系统运行之后再由 BSP 唤醒。而由哪个 CPU 来作为 BSP 则是由硬件与 BIOS 决定的。</p>
<p>在 SMP 系统中，每个 CPU 都附带有一个本地 APIC （LAPIC）单元，其不仅负责分发中断，还负责为其连接的 CPU 提供一个标识符，本次实验我们将利用 LAPIC 单元的下列基本功能（参见 <code>kern/lapic.c</code>）</p>
<ul>
<li>读取 LAPIC ID 以识别代码当前运行的 CPU（参见 <code>cpunum()</code>）</li>
<li>从 BSP 向 APs 发送 <code>STARTUP</code> 这一处理器间中断（interprocessor interrupt）以将其唤醒（参见 <code>lapic_startap()</code>）</li>
<li>在 part C 中，我们对 LAPIC 的内置计时器进行编程以触发时钟中断从而支持抢占式多任务（参见 <code>apic_init()</code>）</li>
</ul>
<blockquote>
<p><strong>Exercise 1.</strong> Implement <code>mmio_map_region</code> in <code>kern/pmap.c</code>. To see how this is used, look at the beginning of <code>lapic_init</code> in <code>kern/lapic.c</code>. You’ll have to do the next exercise, too, before the tests for <code>mmio_map_region</code> will run.</p>
</blockquote>
<p>处理器通过 MMIO 访问其 LAPIC：一部分物理内存被<strong>硬连线</strong>到部分 IO 设备的寄存器上，因此我们可以使用普通的存取指令来访问设备寄存器，相应地这块内存便是一个内存空洞。LAPIC 对应的内存空洞则在<strong>物理地址</strong> <code>0xFE000000</code> 处，占用 32 MB，我们无法通过基于 <code>KERNBASE</code> 的线性映射进行访问（超出 32 位地址了），但 JOS 在 <code>MMIOBASE</code> 处留了 4MB 的空白所以我们可以映射到此处</p>
<p>接下来是 Exercise 1，让我们实现 <code>mmio_map_region()</code></p>
<blockquote>
<p><strong>Exercise 1.</strong> Implement <code>mmio_map_region</code> in <code>kern/pmap.c</code>. To see how this is used, look at the beginning of <code>lapic_init</code> in <code>kern/lapic.c</code>. You’ll have to do the next exercise, too, before the tests for <code>mmio_map_region</code> will run.</p>
</blockquote>
<p>这个函数主要的作用就是将指定的物理内存映射到对应的虚拟内存上，只不过目标是 mmio 内存，直接使用我们之前写的 <code>boot_map_region()</code> 即可，以页为单位从 <code>MMIOBASE</code> 开始映射，若剩余的留给 MMIO 的区域不够则 panic，这里别忘了页表项标志位应设为 <code>PTE_W | PTE_PCD | PTE_PWT</code> （可写 &amp;&amp; 禁用高速缓存 &amp;&amp; 页级通写位）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Reserve size bytes in the MMIO region and map [pa,pa+size) at this</span><br><span class="hljs-comment">// location.  Return the base of the reserved region.  size does *not*</span><br><span class="hljs-comment">// have to be multiple of PGSIZE.</span><br><span class="hljs-comment">//</span><br><span class="hljs-type">void</span> *<br><span class="hljs-title function_">mmio_map_region</span><span class="hljs-params">(<span class="hljs-type">physaddr_t</span> pa, <span class="hljs-type">size_t</span> size)</span><br>&#123;<br>	<span class="hljs-comment">// Where to start the next region.  Initially, this is the</span><br>	<span class="hljs-comment">// beginning of the MMIO region.  Because this is static, its</span><br>	<span class="hljs-comment">// value will be preserved between calls to mmio_map_region</span><br>	<span class="hljs-comment">// (just like nextfree in boot_alloc).</span><br>	<span class="hljs-type">static</span> <span class="hljs-type">uintptr_t</span> base = MMIOBASE;<br><br>	<span class="hljs-comment">// Reserve size bytes of virtual memory starting at base and</span><br>	<span class="hljs-comment">// map physical pages [pa,pa+size) to virtual addresses</span><br>	<span class="hljs-comment">// [base,base+size).  Since this is device memory and not</span><br>	<span class="hljs-comment">// regular DRAM, you&#x27;ll have to tell the CPU that it isn&#x27;t</span><br>	<span class="hljs-comment">// safe to cache access to this memory.  Luckily, the page</span><br>	<span class="hljs-comment">// tables provide bits for this purpose; simply create the</span><br>	<span class="hljs-comment">// mapping with PTE_PCD|PTE_PWT (cache-disable and</span><br>	<span class="hljs-comment">// write-through) in addition to PTE_W.  (If you&#x27;re interested</span><br>	<span class="hljs-comment">// in more details on this, see section 10.5 of IA32 volume</span><br>	<span class="hljs-comment">// 3A.)</span><br>	<span class="hljs-comment">//</span><br>	<span class="hljs-comment">// Be sure to round size up to a multiple of PGSIZE and to</span><br>	<span class="hljs-comment">// handle if this reservation would overflow MMIOLIM (it&#x27;s</span><br>	<span class="hljs-comment">// okay to simply panic if this happens).</span><br>	<span class="hljs-comment">//</span><br>	<span class="hljs-comment">// Hint: The staff solution uses boot_map_region.</span><br>	<span class="hljs-comment">//</span><br>	<span class="hljs-comment">// Your code here:</span><br><br>	size = ROUNDUP(pa + size, PGSIZE);<br>	pa = ROUNDDOWN(pa, PGSIZE);<br>	size -= pa;<br>	<span class="hljs-keyword">if</span> ((base + size) &gt; MMIOLIM || (base + size) &lt; MMIOBASE)<br>		panic(<span class="hljs-string">&quot;Run out of MMIO region!&quot;</span>);<br>	<br>	boot_map_region(kern_pgdir, base, size, pa, PTE_W | PTE_PCD | PTE_PWT);<br>	base += size;<br>	<span class="hljs-keyword">return</span> (<span class="hljs-type">void</span>*)(base - size);<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="Application-Processor-Bootstrap"><a href="#Application-Processor-Bootstrap" class="headerlink" title="Application Processor Bootstrap"></a>Application Processor Bootstrap</h4><p>在启动 APs 之前 BSP 应当收集多处理器系统的相关信息，例如 CPU 总数、APIC IDs 以及 LAPIC 单元的 MMIO 地址，<code>mp_init()</code> 函数通过读取 BIOS 的内存区中的 MP 配置表来获取这些信息；在<code>boot_aps()</code> 中将 APs 启动（实模式），并将 AP 入口代码拷贝到一个实模式下可寻址的内存区域，不同于 bootloader，我们可以控制 APs 开始执行代码的位置，我们将入口代码复制到 0x7000 （<code>MPENTRY_PADDR</code>）处，不过其实任何 640KB 以下的未使用的页对齐的物理地址都可以被使用</p>
<p>之后 <code>boot_aps()</code> 通过向每一个 APs 的 LAPIC 单元发送 <code>STARTUP</code> IPI 以唤醒他们，其中包含有入口点的地址，在经过简单的设置之后 每个 AP 都将进入开启分页的保护模式，并调用 <code>mp_main()</code> 函数；<code>boot_aps()</code> 会等到每个被唤醒的 AP 在设置自己对应的 <code>struct CpuInfo</code> 中的 <code>cpu_status</code> 域的 <code>CPU_STARTED</code> 标志位后才会接着唤醒下一个</p>
<p>接下来是 Exercise 2，阅读启动过程的代码并修改 <code>page_init()</code> 以避免将 <code>MPENTRY_ADDR</code> 对应的页也链到 freelist 上</p>
<blockquote>
<p><strong>Exercise 2.</strong> Read <code>boot_aps()</code> and <code>mp_main()</code> in <code>kern/init.c</code>, and the assembly code in <code>kern/mpentry.S</code>. Make sure you understand the control flow transfer during the bootstrap of APs. Then modify your implementation of <code>page_init()</code> in <code>kern/pmap.c</code> to avoid adding the page at <code>MPENTRY_PADDR</code> to the free list, so that we can safely copy and run AP bootstrap code at that physical address. Your code should pass the updated <code>check_page_free_list()</code> test (but might fail the updated <code>check_kern_pgdir()</code> test, which we will fix soon).</p>
</blockquote>
<p>首先拜读一下 <code>boot_aps()</code>，逻辑还是比较简单的，主要就是拷贝启动代码到 0x7000，之后通过 <code>lapic_startap()</code> 唤醒单个 AP 并进行忙等待直到其设置自己的 <code>CPU_STARTED</code> 标志位，而 <code>mp_main()</code> 则主要是将内核页表装载到 AP 自己的 cr3 上，以及初始化自己的环境、IDT、从运行队列中取出进程（后面这些都需要我们在后续实现）</p>
<p>我们直接看修改 <code>page_init()</code>，如果在建 freelist 时对每一张内存页都进行一次判断那就太耗时了，笔者的选择是等到 freelist 建完之后再将对应页进行脱链</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">page_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>	<span class="hljs-comment">// LAB 4:</span><br>	<span class="hljs-comment">// Change your code to mark the physical page at MPENTRY_PADDR</span><br>	<span class="hljs-comment">// as in use</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">mpentry</span>, *<span class="hljs-title">mp_prev</span>;</span><br>    <br>    <span class="hljs-comment">//...</span><br>    <br>    <span class="hljs-comment">// 5) mark the physical page at MPENTRY_PADDR as in use</span><br>	mpentry = pa2page(MPENTRY_PADDR);<br>	mp_prev = pa2page(MPENTRY_PADDR + PGSIZE);<br>	mp_prev-&gt;pp_link = mpentry-&gt;pp_link;<br>	mpentry-&gt;pp_ref = <span class="hljs-number">1</span>;<br>	mpentry-&gt;pp_link = <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>接下来是习题：</p>
<blockquote>
<p><strong>Question</strong></p>
<ol>
<li>Compare <code>kern/mpentry.S</code> side by side with <code>boot/boot.S</code>. Bearing in mind that <code>kern/mpentry.S</code> is compiled and linked to run above <code>KERNBASE</code> just like everything else in the kernel, what is the purpose of macro <code>MPBOOTPHYS</code>? Why is it necessary in <code>kern/mpentry.S</code> but not in <code>boot/boot.S</code>? In other words, what could go wrong if it were omitted in <code>kern/mpentry.S</code>?<br>Hint: recall the differences between the link address and the load address that we have discussed in Lab 1.</li>
</ol>
</blockquote>
<p><code>MPBOOTPHYS</code> 宏主要的作用就是计算 entry code 中需要用到的地址的<strong>真实物理地址</strong>，因为 entry code 在被链接进内核二进制文件后其地址不一定是 0x7000 起始，但是我们将其加载到了该位置，因此对于绝对地址的索引需要计算其加载到该地址上之后的地址</p>
<h4 id="Per-CPU-State-and-Initialization"><a href="#Per-CPU-State-and-Initialization" class="headerlink" title="Per-CPU State and Initialization"></a>Per-CPU State and Initialization</h4><p>对于一个多处理器 OS 而言我们很有必要为每个 CPU 都分配一块私有空间（例如 Linux 中的 percpu 变量），我们可以分配一个数组并使用 <code>cpunum()</code> 获取到 CPU 标号作为下标索引，以下是我们应当注意的 per-CPU state：</p>
<ul>
<li><p><strong>Per-CPU kernel stack</strong>.</p>
<p>每个 CPU 都应当有属于其自己的堆栈，在 JOS 中数组 <code>percpu_kstacks[NCPU][KSTKSIZE]</code> 为每个 CPU 保留一份自己的堆栈区域；正如在 lab2 中我们将 BSP 的堆栈映射到了 KSTACKTOP 下，在本 lab 中我们将为每个 CPU 创建自己的堆栈，且应确保其堆栈占用一块连续的虚拟内存区域</p>
</li>
<li><p><strong>Per-CPU TSS and TSS descriptor</strong>.</p>
<p>我们同样需要一个 per-CPU 任务状态段来确定每个 CPU 的内核栈的位置，每个 CPU 的 TSS 被存放在 <code>cpus[i].cpu_ts</code> 中，对应的 TSS descriptor 则在 <code>gdt[(GD_TSS0) &gt;&gt; 3] + i]</code> ，定义于 <code>kern/trap.c</code> 中的全局变量 <code>ts</code> 则不再使用</p>
</li>
<li><p><strong>Per-CPU current environment pointer</strong>.</p>
<p>因为每个 CPU 都可以独立运行用户进程，因此我们将符号 <code>curenv</code> 重定义为 <code>cpus[cpunum()].cpu_env</code> ，指向运行在当前 CPU 上进程的 PCB</p>
</li>
<li><p><strong>Per-CPU system registers</strong>.</p>
<p>所有的寄存器对一个 CPU 而言都是私有的，因此我们还需要在每个 CPU 上都初始化其 cr3、gdt、idt…</p>
</li>
</ul>
<p>接下来是 Exercise 3，修改 <code>mem_init_mp()</code> 以为每个 CPU 分配一个内核栈</p>
<blockquote>
<p><strong>Exercise 3.</strong> Modify <code>mem_init_mp()</code> (in <code>kern/pmap.c</code>) to map per-CPU stacks starting at <code>KSTACKTOP</code>, as shown in <code>inc/memlayout.h</code>. The size of each stack is <code>KSTKSIZE</code> bytes plus <code>KSTKGAP</code> bytes of unmapped guard pages. Your code should pass the new check in <code>check_kern_pgdir()</code>.</p>
</blockquote>
<p>直接用 <code>boot_map_region</code> 创建映射即可，注意这里不管我们有多少个 CPU 都要建立 <code>NCPU</code> 个内核栈（这个时候 <code>ncpu</code> 变量还没初始化，而且整个 <code>percpu_kstack</code> 数组的大小是在编译期确定的）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Modify mappings in kern_pgdir to support SMP</span><br><span class="hljs-comment">//   - Map the per-CPU stacks in the region [KSTACKTOP-PTSIZE, KSTACKTOP)</span><br><span class="hljs-comment">//</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">mem_init_mp</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>	<span class="hljs-comment">// Map per-CPU stacks starting at KSTACKTOP, for up to &#x27;NCPU&#x27; CPUs.</span><br>	<span class="hljs-comment">//</span><br>	<span class="hljs-comment">// For CPU i, use the physical memory that &#x27;percpu_kstacks[i]&#x27; refers</span><br>	<span class="hljs-comment">// to as its kernel stack. CPU i&#x27;s kernel stack grows down from virtual</span><br>	<span class="hljs-comment">// address kstacktop_i = KSTACKTOP - i * (KSTKSIZE + KSTKGAP), and is</span><br>	<span class="hljs-comment">// divided into two pieces, just like the single stack you set up in</span><br>	<span class="hljs-comment">// mem_init:</span><br>	<span class="hljs-comment">//     * [kstacktop_i - KSTKSIZE, kstacktop_i)</span><br>	<span class="hljs-comment">//          -- backed by physical memory</span><br>	<span class="hljs-comment">//     * [kstacktop_i - (KSTKSIZE + KSTKGAP), kstacktop_i - KSTKSIZE)</span><br>	<span class="hljs-comment">//          -- not backed; so if the kernel overflows its stack,</span><br>	<span class="hljs-comment">//             it will fault rather than overwrite another CPU&#x27;s stack.</span><br>	<span class="hljs-comment">//             Known as a &quot;guard page&quot;.</span><br>	<span class="hljs-comment">//     Permissions: kernel RW, user NONE</span><br>	<span class="hljs-comment">//</span><br>	<span class="hljs-comment">// LAB 4: Your code here:</span><br>	<span class="hljs-type">int</span> i;<br>	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; NCPU; i++)<br>	&#123;<br>		boot_map_region(kern_pgdir, <br>			KSTACKTOP - i * (KSTKSIZE + KSTKGAP) - KSTKSIZE, <br>			KSTKSIZE, <br>			PADDR(&amp;percpu_kstacks[i]), <br>			PTE_W);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>接下来是 Exercise 4，更改 <code>trap_init_percpu()</code> 以让其能正常在所有 CPU 上运行</p>
<blockquote>
<p><strong>Exercise 4.</strong> The code in <code>trap_init_percpu()</code> (<code>kern/trap.c</code>) initializes the TSS and TSS descriptor for the BSP. It worked in Lab 3, but is incorrect when running on other CPUs. Change the code so that it can work on all CPUs. (Note: your new code should not use the global <code>ts</code> variable any more.)</p>
</blockquote>
<p>主要就是把全局变量 <code>ts</code> 替换成 <code>thiscpu</code> 指向的 <code>CpuInfo</code> 结构体的 <code>cpu_ts</code> 成员即可，以及修改全局段描述符表中对应段描述符为 tss 描述符时注意使用 <code>cpunum()</code> 来获取当前 CPU 的标号，还有就是注意将 tss 的 esp 初始化为对应 cpu 的栈，这里还要注意一点就是 <code>ltr</code> 指令所用的值应为 <em>对应的描述符在全局描述符表中的偏移</em> ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Initialize and load the per-CPU TSS and IDT</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">trap_init_percpu</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>	<span class="hljs-comment">// The example code here sets up the Task State Segment (TSS) and</span><br>	<span class="hljs-comment">// the TSS descriptor for CPU 0. But it is incorrect if we are</span><br>	<span class="hljs-comment">// running on other CPUs because each CPU has its own kernel stack.</span><br>	<span class="hljs-comment">// Fix the code so that it works for all CPUs.</span><br>	<span class="hljs-comment">//</span><br>	<span class="hljs-comment">// Hints:</span><br>	<span class="hljs-comment">//   - The macro &quot;thiscpu&quot; always refers to the current CPU&#x27;s</span><br>	<span class="hljs-comment">//     struct CpuInfo;</span><br>	<span class="hljs-comment">//   - The ID of the current CPU is given by cpunum() or</span><br>	<span class="hljs-comment">//     thiscpu-&gt;cpu_id;</span><br>	<span class="hljs-comment">//   - Use &quot;thiscpu-&gt;cpu_ts&quot; as the TSS for the current CPU,</span><br>	<span class="hljs-comment">//     rather than the global &quot;ts&quot; variable;</span><br>	<span class="hljs-comment">//   - Use gdt[(GD_TSS0 &gt;&gt; 3) + i] for CPU i&#x27;s TSS descriptor;</span><br>	<span class="hljs-comment">//   - You mapped the per-CPU kernel stacks in mem_init_mp()</span><br>	<span class="hljs-comment">//   - Initialize cpu_ts.ts_iomb to prevent unauthorized environments</span><br>	<span class="hljs-comment">//     from doing IO (0 is not the correct value!)</span><br>	<span class="hljs-comment">//</span><br>	<span class="hljs-comment">// ltr sets a &#x27;busy&#x27; flag in the TSS selector, so if you</span><br>	<span class="hljs-comment">// accidentally load the same TSS on more than one CPU, you&#x27;ll</span><br>	<span class="hljs-comment">// get a triple fault.  If you set up an individual CPU&#x27;s TSS</span><br>	<span class="hljs-comment">// wrong, you may not get a fault until you try to return from</span><br>	<span class="hljs-comment">// user space on that CPU.</span><br>	<span class="hljs-comment">//</span><br>	<span class="hljs-comment">// LAB 4: Your code here:</span><br><br>	<span class="hljs-comment">// Setup a TSS so that we get the right stack</span><br>	<span class="hljs-comment">// when we trap to the kernel.</span><br>	thiscpu-&gt;cpu_ts.ts_esp0 = KSTACKTOP - (KSTKSIZE + KSTKGAP) * cpunum();<br>	thiscpu-&gt;cpu_ts.ts_ss0 = GD_KD;<br>	thiscpu-&gt;cpu_ts.ts_iomb = <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Taskstate);<br><br>	<span class="hljs-comment">// Initialize the TSS slot of the gdt.</span><br>	gdt[(GD_TSS0 &gt;&gt; <span class="hljs-number">3</span>) + cpunum()] = SEG16(STS_T32A, (<span class="hljs-type">uint32_t</span>) (&amp;thiscpu-&gt;cpu_ts),<br>					<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Taskstate) - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>	gdt[(GD_TSS0 &gt;&gt; <span class="hljs-number">3</span>) + cpunum()].sd_s = <span class="hljs-number">0</span>;<br><br>	<span class="hljs-comment">// Load the TSS selector (like other segment selectors, the</span><br>	<span class="hljs-comment">// bottom three bits are special; we leave them 0)</span><br>	ltr(GD_TSS0 + (cpunum() * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Segdesc)));<br><br>	<span class="hljs-comment">// Load the IDT</span><br>	lidt(&amp;idt_pd);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行 <code>make qemu CPUS=4</code>，可以看到我们的几个处理器都成功地启动了：</p>
<p><img src="https://s2.loli.net/2022/03/21/VvEiuky4DseIRTq.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h4 id="Locking"><a href="#Locking" class="headerlink" title="Locking"></a>Locking</h4><p>伴随着多处理器系统的出现， <em>条件竞争</em> （race condition）成为了我们不得不考虑的一个问题，因此我们需要使用 <code>锁</code> 来保护临界区中的数据，在同一时间段只有一个 CPU 可以改变临界区内的数据，比较朴素的一个办法就是使用一个全局的 <em>big kernel lock</em> ，当用户进程进入内核态时上锁，退出后再解锁，这样在同一时刻只有一个用户进程可以运行在内核态，确保了内核数据的安全</p>
<p>在 <code>kern/spinlock.h</code> 中定义了一个大的内核锁 <code>kernel_lock</code>，同时提供了加锁与解锁的函数 <code>lock_kernel()</code> 和 <code>unlock_kernel()</code>，我们应当在以下四个地方使用大内核锁：</p>
<ul>
<li>在 BSP 唤醒 APs 前请求锁（<code>i386_init()</code>）</li>
<li>在初始化当前 AP 后请求锁（<code>mp_main()</code>），之后调用 <code>sched_yield()</code> 以在该 AP 上运行用户进程</li>
<li>在从用户态陷入内核态时请求锁（<code>trap()</code>），为了确定陷阱发生在用户态还是内核态，我们应当检查 <code>tf_cs</code> 的 RPL</li>
<li>在从内核态切换到用户态之前释放锁（<code>env_run()</code>），不要过早或过晚，否则可能会造成竞态或死锁</li>
</ul>
<p>于是接下来就是 Exercise 5：在上述位置补充相应的锁</p>
<blockquote>
<p><strong>Exercise 5.</strong> Apply the big kernel lock as described above, by calling <code>lock_kernel()</code> and <code>unlock_kernel()</code> at the proper locations.</p>
</blockquote>
<p>在 JOS 中，一个自旋锁起其实被定义为一个普通的整型变量，<strong>但是上锁与解锁的操作是通过原子指令完成的</strong>，而原子指令的实现<strong>其实是通过 <code>lock</code> 前缀完成的</strong>，被该前缀修饰的指令在访问内存时同时会完成对总线的控制，直到指令结束，从而<strong>从硬件层面保证了指令的原子性</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">uint32_t</span><br><span class="hljs-title function_">xchg</span><span class="hljs-params">(<span class="hljs-keyword">volatile</span> <span class="hljs-type">uint32_t</span> *addr, <span class="hljs-type">uint32_t</span> newval)</span><br>&#123;<br>	<span class="hljs-type">uint32_t</span> result;<br><br>	<span class="hljs-comment">// The + in &quot;+m&quot; denotes a read-modify-write operand.</span><br>	<span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;lock; xchgl %0, %1&quot;</span></span><br><span class="hljs-params">		     : <span class="hljs-string">&quot;+m&quot;</span> (*addr), <span class="hljs-string">&quot;=a&quot;</span> (result)</span><br><span class="hljs-params">		     : <span class="hljs-string">&quot;1&quot;</span> (newval)</span><br><span class="hljs-params">		     : <span class="hljs-string">&quot;cc&quot;</span>)</span>;<br>	<span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>现在你知道一个自旋锁该怎么实现了吧 ；）那么互斥锁呢？互斥锁的实现其实需要依赖额外的辅助结构…</p>
</blockquote>
<p>这里 <code>lock_kernel()</code> 和 <code>unlock_kernel()</code>直接操作的就是大内核锁，所以我们直接将其放置在对应位置即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">i386_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>	<span class="hljs-comment">// ...</span><br><br>	<span class="hljs-comment">// Acquire the big kernel lock before waking up APs</span><br>	<span class="hljs-comment">// Your code here:</span><br>	lock_kernel();<br>    <br>    <span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Setup code for APs</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">mp_main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>	<span class="hljs-comment">// We are in high EIP now, safe to switch to kern_pgdir </span><br>	lcr3(PADDR(kern_pgdir));<br>	cprintf(<span class="hljs-string">&quot;SMP: CPU %d starting\n&quot;</span>, cpunum());<br><br>	lapic_init();<br>	env_init_percpu();<br>	trap_init_percpu();<br>	xchg(&amp;thiscpu-&gt;cpu_status, CPU_STARTED); <span class="hljs-comment">// tell boot_aps() we&#x27;re up</span><br><br>	<span class="hljs-comment">// Now that we have finished some basic setup, call sched_yield()</span><br>	<span class="hljs-comment">// to start running processes on this CPU.  But make sure that</span><br>	<span class="hljs-comment">// only one CPU can enter the scheduler at a time!</span><br>	<span class="hljs-comment">//</span><br>	<span class="hljs-comment">// Your code here:</span><br>	lock_kernel();<br>    sched_yield();<br><br>	<span class="hljs-comment">// Remove this after you finish Exercise 6</span><br>	<span class="hljs-keyword">for</span> (;;);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Trapframe *tf)</span><br>&#123;<br>	<span class="hljs-comment">// ...</span><br><br>	<span class="hljs-keyword">if</span> ((tf-&gt;tf_cs &amp; <span class="hljs-number">3</span>) == <span class="hljs-number">3</span>) &#123;<br>		<span class="hljs-comment">// Trapped from user mode.</span><br>		<span class="hljs-comment">// Acquire the big kernel lock before doing any</span><br>		<span class="hljs-comment">// serious kernel work.</span><br>		<span class="hljs-comment">// LAB 4: Your code here.</span><br>		assert(curenv);<br>		lock_kernel();<br><br>    <span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">env_run</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Env *e)</span><br>&#123;<br>	<span class="hljs-comment">// ...</span><br><br>	<span class="hljs-comment">// recover the context of process and ret2usr</span><br>    unlock_kernel();<br>	lcr3(PADDR(curenv-&gt;env_pgdir));<br>	env_pop_tf(&amp;curenv-&gt;env_tf);<br><br>	<span class="hljs-comment">// we never arrive there</span><br>	panic(<span class="hljs-string">&quot;env_run not yet implemented&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>下面是习题 time：为什么有了大内核锁我们还要为每个 CPU 分配一个独立的内核栈？</p>
<blockquote>
<p><strong>Question</strong></p>
<ol>
<li>It seems that using the big kernel lock guarantees that only one CPU can run the kernel code at a time. Why do we still need separate kernel stacks for each CPU? Describe a scenario in which using a shared kernel stack will go wrong, even with the protection of the big kernel lock.</li>
</ol>
</blockquote>
<p>我们在从用户态陷入到内核态再到获取到锁中间仍有一段需要压栈的过程，因此若多个用户进程同时陷入内核态则会破坏掉内核栈上保存的属于其他用户进程的栈帧</p>
<p>之后是 Challenge，为四个地方加上锁：</p>
<blockquote>
<p><em>Challenge!</em> The big kernel lock is simple and easy to use. Nevertheless, it eliminates all concurrency in kernel mode. Most modern operating systems use different locks to protect different parts of their shared state, an approach called <em>fine-grained locking</em>. Fine-grained locking can increase performance significantly, but is more difficult to implement and error-prone. If you are brave enough, drop the big kernel lock and embrace concurrency in JOS!</p>
<p>It is up to you to decide the locking granularity (the amount of data that a lock protects). As a hint, you may consider using spin locks to ensure exclusive access to these shared components in the JOS kernel:</p>
<ul>
<li>The page allocator.</li>
<li>The console driver.</li>
<li>The scheduler.</li>
<li>The inter-process communication (IPC) state that you will implement in the part C.</li>
</ul>
</blockquote>
<p>第四个在 part C 才实现，我们先看前三个</p>
<p>首先是 page allocator，我们在这里声明一个全局的锁变量，在 <code>page_init()</code> 中对其初始化，并在 <code>page_alloc()</code> 与 <code>page_free()</code> 中都加入对该锁的使用，这里笔者选择为这两个函数再添加一层 wrapper 来使用锁</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// spinlock for page allocator</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">page_lock</span>;</span><br><br><span class="hljs-comment">// ...</span><br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">page_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <br>	<span class="hljs-comment">// 6) init page_lock</span><br>	__spin_initlock(&amp;page_lock, <span class="hljs-string">&quot;page allocator lock&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *</span><br><span class="hljs-class">__<span class="hljs-title">page_alloc</span>(<span class="hljs-title">int</span> <span class="hljs-title">alloc_flags</span>)</span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-comment">// ...</span><br><br><span class="hljs-keyword">struct</span> PageInfo *<br><span class="hljs-title function_">page_alloc</span><span class="hljs-params">(<span class="hljs-type">int</span> alloc_flags)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">res</span>;</span><br><br>	spin_lock(&amp;page_lock);<br>	res = __page_alloc(alloc_flags);<br>	spin_unlock(&amp;page_lock);<br><br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">// ...</span><br><br><span class="hljs-type">void</span><br>__page_free(<span class="hljs-keyword">struct</span> PageInfo *pp)<br>&#123;<br>    <span class="hljs-comment">//...</span><br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">page_free</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> PageInfo *pp)</span><br>&#123;<br>	spin_lock(&amp;page_lock);<br>	res = __page_free(pp);<br>	spin_unlock(&amp;page_lock);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>console driver 其实也是同样的思路，不过笔者分为读和写两个锁：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">read_lock</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">write_lock</span>;</span><br><br><span class="hljs-comment">// ...</span><br><br><span class="hljs-comment">// initialize the console devices</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">cons_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>	cga_init();<br>	kbd_init();<br>	serial_init();<br><br>	__spin_initlock(&amp;read_lock, <span class="hljs-string">&quot;console read lock&quot;</span>);<br>	__spin_initlock(&amp;write_lock, <span class="hljs-string">&quot;console write lock&quot;</span>);<br><br>	<span class="hljs-keyword">if</span> (!serial_exists)<br>		cprintf(<span class="hljs-string">&quot;Serial port does not exist!\n&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// `High&#x27;-level console I/O.  Used by readline and cprintf.</span><br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">cputchar</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span><br>&#123;<br>	spin_lock(&amp;write_lock);<br>	cons_putc(c);<br>	spin_unlock(&amp;write_lock);<br>&#125;<br><br><span class="hljs-type">int</span><br><span class="hljs-title function_">getchar</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>	<span class="hljs-type">int</span> c;<br><br>	spin_lock(&amp;read_lock);<br><br>	<span class="hljs-keyword">while</span> ((c = cons_getc()) == <span class="hljs-number">0</span>)<br>		<span class="hljs-comment">/* do nothing */</span>;<br><br>	spin_unlock(&amp;read_lock);<br><br>	<span class="hljs-keyword">return</span> c;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><del>scheduler 现在还没有写呢，所以👴选择摸了</del></p>
<h3 id="Round-Robin-Scheduling"><a href="#Round-Robin-Scheduling" class="headerlink" title="Round-Robin Scheduling"></a>Round-Robin Scheduling</h3><blockquote>
<p>关于这个算法，笔者在<a target="_blank" rel="noopener" href="https://arttnba3.cn/2021/09/07/PIECES-0X01-SHELL_OUTSIDE-1-WINDY_SUMMER/#%E5%85%B3%E4%BA%8E%E8%BD%AE%E8%AF%A2%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E4%BD%A0%E6%89%80%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8C%E4%B8%89%E4%BA%8B">这篇博客</a>里写了他的来龙去脉</p>
</blockquote>
<p>接下来我们需要实现 <em>轮询调度算法</em> ：</p>
<ul>
<li><code>sched_yield()</code> 用以从遍历 <code>envs[]</code> 数组并选择第一个状态为 <code>ENV_RUNNABLE</code> 的进程去运行</li>
<li><code>sched_yield()</code> 不应当让一个进程被同时跑在两个 CPU 上</li>
<li>JOS 还实现了一个新的系统调用 <code>sys_yield()</code> 以让当前用户进程休眠，使当前 CPU 去运行另一个进程</li>
</ul>
<p>接下来是 Exercise 6 了，在 <code>sched_yield()</code>  中实现轮询调度算法：</p>
<blockquote>
<p><strong>Exercise 6.</strong> Implement round-robin scheduling in <code>sched_yield()</code> as described above. Don’t forget to modify <code>syscall()</code> to dispatch <code>sys_yield()</code>.</p>
<p>Make sure to invoke <code>sched_yield()</code> in <code>mp_main</code>.</p>
<p>Modify <code>kern/init.c</code> to create three (or more!) environments that all run the program <code>user/yield.c</code>.</p>
<p>Run make qemu. You should see the environments switch back and forth between each other five times before terminating, like below.</p>
<p>Test also with several CPUS: make qemu CPUS&#x3D;2.</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs erlang">...<br>Hello, I am environment <span class="hljs-number">00001000</span>.<br>Hello, I am environment <span class="hljs-number">00001001</span>.<br>Hello, I am environment <span class="hljs-number">00001002</span>.<br>Back in environment <span class="hljs-number">00001000</span>, iteration <span class="hljs-number">0</span>.<br>Back in environment <span class="hljs-number">00001001</span>, iteration <span class="hljs-number">0</span>.<br>Back in environment <span class="hljs-number">00001002</span>, iteration <span class="hljs-number">0</span>.<br>Back in environment <span class="hljs-number">00001000</span>, iteration <span class="hljs-number">1</span>.<br>Back in environment <span class="hljs-number">00001001</span>, iteration <span class="hljs-number">1</span>.<br>Back in environment <span class="hljs-number">00001002</span>, iteration <span class="hljs-number">1</span>.<br>...<br></code></pre></td></tr></table></figure>

<p>After the <code>yield</code> programs exit, there will be no runnable environment in the system, the scheduler should invoke the JOS kernel monitor. If any of this does not happen, then fix your code before proceeding.</p>
</blockquote>
<p>前面的 Challenge 说到为 scheduler 加锁，因此笔者选择在 <code>kern/env.h</code> 中声明一个自旋锁，定义放在 <code>kern/env.c</code> 中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">sched_lock</span>;</span>		<span class="hljs-comment">// lock for Env in scheduler</span><br></code></pre></td></tr></table></figure>

<p>在 <code>env_init()</code> 中对其初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">env_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br><br>	<span class="hljs-comment">// initialize the scheduler lock</span><br>	__spin_initlock(&amp;sched_lock, <span class="hljs-string">&quot;scheduler lock&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>最后就是实现 <code>sched_yield()</code> 了，这里为了保证公平因此我们应当从当前进程往后进行遍历而不是每次都从 env[0] 开始，需要注意的是若我们轮询一遍进程数组发现没有其他可运行进程的话需要返回到发起 yield 的进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Choose a user environment to run and run it.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">sched_yield</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">idle</span>;</span><br><br>	<span class="hljs-comment">// Implement simple round-robin scheduling.</span><br>	<span class="hljs-comment">//</span><br>	<span class="hljs-comment">// Search through &#x27;envs&#x27; for an ENV_RUNNABLE environment in</span><br>	<span class="hljs-comment">// circular fashion starting just after the env this CPU was</span><br>	<span class="hljs-comment">// last running.  Switch to the first such environment found.</span><br>	<span class="hljs-comment">//</span><br>	<span class="hljs-comment">// If no envs are runnable, but the environment previously</span><br>	<span class="hljs-comment">// running on this CPU is still ENV_RUNNING, it&#x27;s okay to</span><br>	<span class="hljs-comment">// choose that environment.</span><br>	<span class="hljs-comment">//</span><br>	<span class="hljs-comment">// Never choose an environment that&#x27;s currently running on</span><br>	<span class="hljs-comment">// another CPU (env_status == ENV_RUNNING). If there are</span><br>	<span class="hljs-comment">// no runnable environments, simply drop through to the code</span><br>	<span class="hljs-comment">// below to halt the cpu.</span><br><br>	<span class="hljs-comment">// LAB 4: Your code here.</span><br>	<span class="hljs-type">int</span> i, start_idx;<br><br>	spin_lock(&amp;sched_lock);<br><br>	idle = <span class="hljs-literal">NULL</span>;<br><br>	<span class="hljs-keyword">if</span> (curenv)<br>		start_idx = ENVX(curenv-&gt;env_id) + <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">else</span><br>		start_idx = <span class="hljs-number">0</span>;<br><br>	<span class="hljs-comment">// traversal envs</span><br>	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; NENV; i++)<br>	&#123;<br>		<span class="hljs-keyword">if</span> (envs[(start_idx + i) % NENV].env_status == ENV_RUNNABLE)<br>		&#123;<br>			idle = &amp;envs[(start_idx + i) % NENV];<br>			<span class="hljs-keyword">break</span>;<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-comment">// no other runnable, try to rerun curenv</span><br>	<span class="hljs-keyword">if</span> (!idle &amp;&amp; curenv <br>		&amp;&amp; curenv-&gt;env_status == ENV_RUNNING<br>		&amp;&amp; curenv-&gt;env_cpunum == cpunum())<br>		idle = curenv;<br><br>	<span class="hljs-keyword">if</span> (idle)<br>	&#123;<br>		idle-&gt;env_status = ENV_RUNNING;<br>		spin_unlock(&amp;sched_lock);<br>		env_run(idle);<br>	&#125;<br><br>	spin_unlock(&amp;sched_lock);<br>	<span class="hljs-comment">// sched_halt never returns</span><br>	sched_halt();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里我们的自旋锁还需要保护整个 env 数组，在 <code>env_alloc()</code> 与 <code>env_free()</code> 上套一层 wrapper：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <br><span class="hljs-title function_">env_alloc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Env **newenv_store, <span class="hljs-type">envid_t</span> parent_id)</span><br>&#123;<br>	<span class="hljs-type">int</span> res;<br><br>	spin_lock(&amp;sched_lock);<br>	res = __env_alloc(newenv_store, parent_id);<br>	spin_unlock(&amp;sched_lock);<br><br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">env_free</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Env *e)</span><br>&#123;<br>	spin_lock(&amp;sched_lock);<br>	__env_free(e);<br>	spin_unlock(&amp;sched_lock);<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>这里笔者为了完成加锁的那个 Challenge，走了不少弯路…也掉了几次坑….</p>
</blockquote>
<p>别忘了在 <code>kern/syscall.c</code> 中补充上对 <code>sys_yield()</code> 的调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Dispatches to the correct kernel function, passing the arguments.</span><br><span class="hljs-type">int32_t</span><br><span class="hljs-title function_">syscall</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> syscallno, <span class="hljs-type">uint32_t</span> a1, <span class="hljs-type">uint32_t</span> a2, <span class="hljs-type">uint32_t</span> a3, <span class="hljs-type">uint32_t</span> a4, <span class="hljs-type">uint32_t</span> a5)</span><br>&#123;<br>	<span class="hljs-comment">// Call the function corresponding to the &#x27;syscallno&#x27; parameter.</span><br>	<span class="hljs-comment">// Return any appropriate return value.</span><br>	<span class="hljs-comment">// LAB 3: Your code here.</span><br><br>	<span class="hljs-comment">// panic(&quot;syscall not implemented&quot;);</span><br><br>	<span class="hljs-keyword">switch</span> (syscallno) &#123;<br>		<span class="hljs-keyword">case</span> SYS_cputs:<br>			sys_cputs((<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)a1, a2);<br>			<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">case</span> SYS_cgetc:<br>			<span class="hljs-keyword">return</span> sys_cgetc();<br>		<span class="hljs-keyword">case</span> SYS_getenvid:<br>			<span class="hljs-keyword">return</span> sys_getenvid();<br>		<span class="hljs-keyword">case</span> SYS_env_destroy:<br>			<span class="hljs-keyword">return</span> sys_env_destroy(a1);<br>		<span class="hljs-keyword">case</span> SYS_yield:<br>			sys_yield();<br>			<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">default</span>:<br>			<span class="hljs-keyword">return</span> -E_INVAL;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>之后是习题 Time：</p>
<blockquote>
<p><strong>Question</strong></p>
<ol>
<li>In your implementation of <code>env_run()</code> you should have called <code>lcr3()</code>. Before and after the call to <code>lcr3()</code>, your code makes references (at least it should) to the variable <code>e</code>, the argument to <code>env_run</code>. Upon loading the <code>%cr3</code> register, the addressing context used by the MMU is instantly changed. But a virtual address (namely <code>e</code>) has meaning relative to a given address context–the address context specifies the physical address to which the virtual address maps. Why can the pointer <code>e</code> be dereferenced both before and after the addressing switch?</li>
<li>Whenever the kernel switches from one environment to another, it must ensure the old environment’s registers are saved so they can be restored properly later. Why? Where does this happen?</li>
</ol>
</blockquote>
<p>两个 Challenge，</p>
<blockquote>
<p><em>Challenge!</em> Add a less trivial scheduling policy to the kernel, such as a fixed-priority scheduler that allows each environment to be assigned a priority and ensures that higher-priority environments are always chosen in preference to lower-priority environments. If you’re feeling really adventurous, try implementing a Unix-style adjustable-priority scheduler or even a lottery or stride scheduler. (Look up “lottery scheduling” and “stride scheduling” in Google.)</p>
<p>Write a test program or two that verifies that your scheduling algorithm is working correctly (i.e., the right environments get run in the right order). It may be easier to write these test programs once you have implemented <code>fork()</code> and IPC in parts B and C of this lab.</p>
</blockquote>
<blockquote>
<p><em>Challenge!</em> The JOS kernel currently does not allow applications to use the x86 processor’s x87 floating-point unit (FPU), MMX instructions, or Streaming SIMD Extensions (SSE). Extend the <code>Env</code> structure to provide a save area for the processor’s floating point state, and extend the context switching code to save and restore this state properly when switching from one environment to another. The <code>FXSAVE</code> and <code>FXRSTOR</code> instructions may be useful, but note that these are not in the old i386 user’s manual because they were introduced in more recent processors. Write a user-level test program that does something cool with floating-point.</p>
</blockquote>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/EXPERIMENTS/" class="category-chain-item">EXPERIMENTS</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">#操作系统</a>
      
        <a href="/tags/%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/">#实验笔记</a>
      
        <a href="/tags/MIT/">#MIT</a>
      
        <a href="/tags/XV6/">#XV6</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>【EXPR.0x00】MIT 6.828 课程实验报告</div>
      <div>https://arttnba3.github.io/2022/02/21/EXPR-0X00-MIT_6_828/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>arttnba3</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年2月21日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/03/08/CTF-0X06-D3CTF2022_D3KHEAP/" title="【CTF.0x06】D^ 3CTF2022 d3kheap 出题手记">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">【CTF.0x06】D^ 3CTF2022 d3kheap 出题手记</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/01/17/CVE-0X05-CVE-2019-13272/" title="【CVE.0x05】CVE-2019-13272 ptrace 漏洞复现及简要分析">
                        <span class="hidden-mobile">【CVE.0x05】CVE-2019-13272 ptrace 漏洞复现及简要分析</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.4.17/Valine.min.js', function() {
        var options = Object.assign(
          {"appid":"ICj6cPRQWFTNiOttBHlzxnIv-gzGzoHsz","appkey":"tuvJh3xYxPFcW2JB6K26RKP2","path":"window.location.pathname","placeholder":"说点什么呗（笑）","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false,"appId":"ICj6cPRQWFTNiOttBHlzxnIv-gzGzoHsz","appKey":"tuvJh3xYxPFcW2JB6K26RKP2"},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  <!-- 网站运行时间的设置 -->
  <span id="timeDate">载入天数...</span>
  <span id="times">载入时分秒...</span>
  <script>
      var now = new Date();
      function createtime() {
          var grt= new Date("04/20/2020 17:48:48");//此处修改你的建站时间或者网站上线时间
          now.setTime(now.getTime()+250);
          days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
          hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
          if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
          mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
          seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
          snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
          document.getElementById("timeDate").innerHTML = "arttnba3的小屋已经安全存在了 "+dnum+" 天 ";
          document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
      }
  setInterval("createtime()",250);
  </script>
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.1/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
